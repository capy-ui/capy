//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (475)
//--------------------------------------------------------------------------------
pub const MIXERCONTROL_CONTROLTYPE_CUSTOM = @as(u32, 0);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEANMETER = @as(u32, 268500992);
pub const MIXERCONTROL_CONTROLTYPE_SIGNEDMETER = @as(u32, 268566528);
pub const MIXERCONTROL_CONTROLTYPE_PEAKMETER = @as(u32, 268566529);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER = @as(u32, 268632064);
pub const MIXERCONTROL_CONTROLTYPE_BOOLEAN = @as(u32, 536936448);
pub const MIXERCONTROL_CONTROLTYPE_ONOFF = @as(u32, 536936449);
pub const MIXERCONTROL_CONTROLTYPE_MUTE = @as(u32, 536936450);
pub const MIXERCONTROL_CONTROLTYPE_MONO = @as(u32, 536936451);
pub const MIXERCONTROL_CONTROLTYPE_LOUDNESS = @as(u32, 536936452);
pub const MIXERCONTROL_CONTROLTYPE_STEREOENH = @as(u32, 536936453);
pub const MIXERCONTROL_CONTROLTYPE_BASS_BOOST = @as(u32, 536945271);
pub const MIXERCONTROL_CONTROLTYPE_BUTTON = @as(u32, 553713664);
pub const MIXERCONTROL_CONTROLTYPE_DECIBELS = @as(u32, 805568512);
pub const MIXERCONTROL_CONTROLTYPE_SIGNED = @as(u32, 805437440);
pub const MIXERCONTROL_CONTROLTYPE_UNSIGNED = @as(u32, 805502976);
pub const MIXERCONTROL_CONTROLTYPE_PERCENT = @as(u32, 805634048);
pub const MIXERCONTROL_CONTROLTYPE_SLIDER = @as(u32, 1073872896);
pub const MIXERCONTROL_CONTROLTYPE_PAN = @as(u32, 1073872897);
pub const MIXERCONTROL_CONTROLTYPE_QSOUNDPAN = @as(u32, 1073872898);
pub const MIXERCONTROL_CONTROLTYPE_FADER = @as(u32, 1342373888);
pub const MIXERCONTROL_CONTROLTYPE_VOLUME = @as(u32, 1342373889);
pub const MIXERCONTROL_CONTROLTYPE_BASS = @as(u32, 1342373890);
pub const MIXERCONTROL_CONTROLTYPE_TREBLE = @as(u32, 1342373891);
pub const MIXERCONTROL_CONTROLTYPE_EQUALIZER = @as(u32, 1342373892);
pub const MIXERCONTROL_CONTROLTYPE_SINGLESELECT = @as(u32, 1879113728);
pub const MIXERCONTROL_CONTROLTYPE_MUX = @as(u32, 1879113729);
pub const MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = @as(u32, 1895890944);
pub const MIXERCONTROL_CONTROLTYPE_MIXER = @as(u32, 1895890945);
pub const MIXERCONTROL_CONTROLTYPE_MICROTIME = @as(u32, 1610809344);
pub const MIXERCONTROL_CONTROLTYPE_MILLITIME = @as(u32, 1627586560);
pub const WAVE_MAPPER = @as(u32, 4294967295);
pub const ENDPOINT_FORMAT_RESET_MIX_ONLY = @as(u32, 1);
pub const ENDPOINT_HARDWARE_SUPPORT_VOLUME = @as(u32, 1);
pub const ENDPOINT_HARDWARE_SUPPORT_MUTE = @as(u32, 2);
pub const ENDPOINT_HARDWARE_SUPPORT_METER = @as(u32, 4);
pub const AUDIOCLOCK_CHARACTERISTIC_FIXED_FREQ = @as(u32, 1);
pub const AMBISONICS_PARAM_VERSION_1 = @as(u32, 1);
pub const AUDCLNT_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287487));
pub const AUDCLNT_E_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287486));
pub const AUDCLNT_E_WRONG_ENDPOINT_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287485));
pub const AUDCLNT_E_DEVICE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287484));
pub const AUDCLNT_E_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287483));
pub const AUDCLNT_E_BUFFER_TOO_LARGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287482));
pub const AUDCLNT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287481));
pub const AUDCLNT_E_UNSUPPORTED_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287480));
pub const AUDCLNT_E_INVALID_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287479));
pub const AUDCLNT_E_DEVICE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287478));
pub const AUDCLNT_E_BUFFER_OPERATION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287477));
pub const AUDCLNT_E_THREAD_NOT_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287476));
pub const AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287474));
pub const AUDCLNT_E_ENDPOINT_CREATE_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287473));
pub const AUDCLNT_E_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287472));
pub const AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287471));
pub const AUDCLNT_E_EXCLUSIVE_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287470));
pub const AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287469));
pub const AUDCLNT_E_EVENTHANDLE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287468));
pub const AUDCLNT_E_INCORRECT_BUFFER_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287467));
pub const AUDCLNT_E_BUFFER_SIZE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287466));
pub const AUDCLNT_E_CPUUSAGE_EXCEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287465));
pub const AUDCLNT_E_BUFFER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287464));
pub const AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287463));
pub const AUDCLNT_E_INVALID_DEVICE_PERIOD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287456));
pub const AUDCLNT_E_INVALID_STREAM_FLAG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287455));
pub const AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287454));
pub const AUDCLNT_E_OUT_OF_OFFLOAD_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287453));
pub const AUDCLNT_E_OFFLOAD_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287452));
pub const AUDCLNT_E_NONOFFLOAD_MODE_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287451));
pub const AUDCLNT_E_RESOURCES_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287450));
pub const AUDCLNT_E_RAW_MODE_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287449));
pub const AUDCLNT_E_ENGINE_PERIODICITY_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287448));
pub const AUDCLNT_E_ENGINE_FORMAT_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287447));
pub const AUDCLNT_E_HEADTRACKING_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287440));
pub const AUDCLNT_E_HEADTRACKING_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287424));
pub const AUDCLNT_E_EFFECT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287423));
pub const AUDCLNT_E_EFFECT_STATE_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287422));
pub const AUDCLNT_S_BUFFER_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196161));
pub const AUDCLNT_S_THREAD_ALREADY_REGISTERED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196162));
pub const AUDCLNT_S_POSITION_STALLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 143196163));
pub const AUDCLNT_STREAMFLAGS_CROSSPROCESS = @as(u32, 65536);
pub const AUDCLNT_STREAMFLAGS_LOOPBACK = @as(u32, 131072);
pub const AUDCLNT_STREAMFLAGS_EVENTCALLBACK = @as(u32, 262144);
pub const AUDCLNT_STREAMFLAGS_NOPERSIST = @as(u32, 524288);
pub const AUDCLNT_STREAMFLAGS_RATEADJUST = @as(u32, 1048576);
pub const AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY = @as(u32, 134217728);
pub const AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM = @as(u32, 2147483648);
pub const AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED = @as(u32, 268435456);
pub const AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE = @as(u32, 536870912);
pub const AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED = @as(u32, 1073741824);
pub const SPTLAUDCLNT_E_DESTROYED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287232));
pub const SPTLAUDCLNT_E_OUT_OF_ORDER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287231));
pub const SPTLAUDCLNT_E_RESOURCES_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287230));
pub const SPTLAUDCLNT_E_NO_MORE_OBJECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287229));
pub const SPTLAUDCLNT_E_PROPERTY_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287228));
pub const SPTLAUDCLNT_E_ERRORS_IN_OBJECT_CALLS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287227));
pub const SPTLAUDCLNT_E_METADATA_FORMAT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287226));
pub const SPTLAUDCLNT_E_STREAM_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287225));
pub const SPTLAUDCLNT_E_INVALID_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287224));
pub const SPTLAUDCLNT_E_STREAM_NOT_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287222));
pub const SPTLAUDCLNT_E_STATIC_OBJECT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287221));
pub const SPTLAUDCLNT_E_OBJECT_ALREADY_ACTIVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287220));
pub const SPTLAUDCLNT_E_INTERNAL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004287219));
pub const DEVICE_STATE_ACTIVE = @as(u32, 1);
pub const DEVICE_STATE_DISABLED = @as(u32, 2);
pub const DEVICE_STATE_NOTPRESENT = @as(u32, 4);
pub const DEVICE_STATE_UNPLUGGED = @as(u32, 8);
pub const DEVICE_STATEMASK_ALL = @as(u32, 15);
pub const PKEY_AudioEndpoint_FormFactor = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 0 };
pub const PKEY_AudioEndpoint_ControlPanelPageProvider = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 1 };
pub const PKEY_AudioEndpoint_Association = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 2 };
pub const PKEY_AudioEndpoint_PhysicalSpeakers = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 3 };
pub const PKEY_AudioEndpoint_GUID = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 4 };
pub const PKEY_AudioEndpoint_Disable_SysFx = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 5 };
pub const ENDPOINT_SYSFX_ENABLED = @as(u32, 0);
pub const ENDPOINT_SYSFX_DISABLED = @as(u32, 1);
pub const PKEY_AudioEndpoint_FullRangeSpeakers = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 6 };
pub const PKEY_AudioEndpoint_Supports_EventDriven_Mode = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 7 };
pub const PKEY_AudioEndpoint_JackSubType = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 8 };
pub const PKEY_AudioEndpoint_Default_VolumeInDb = PROPERTYKEY{ .fmtid = Guid.initString("1da5d803-d492-4edd-8c23-e0c0ffee7f0e"), .pid = 9 };
pub const PKEY_AudioEngine_DeviceFormat = PROPERTYKEY{ .fmtid = Guid.initString("f19f064d-082c-4e27-bc73-6882a1bb8e4c"), .pid = 0 };
pub const PKEY_AudioEngine_OEMFormat = PROPERTYKEY{ .fmtid = Guid.initString("e4870e26-3cc5-4cd2-ba46-ca0a9a70ed04"), .pid = 3 };
pub const PKEY_AudioEndpointLogo_IconEffects = PROPERTYKEY{ .fmtid = Guid.initString("f1ab780d-2010-4ed3-a3a6-8b87f0f0c476"), .pid = 0 };
pub const PKEY_AudioEndpointLogo_IconPath = PROPERTYKEY{ .fmtid = Guid.initString("f1ab780d-2010-4ed3-a3a6-8b87f0f0c476"), .pid = 1 };
pub const PKEY_AudioEndpointSettings_MenuText = PROPERTYKEY{ .fmtid = Guid.initString("14242002-0320-4de4-9555-a7d82b73c286"), .pid = 0 };
pub const PKEY_AudioEndpointSettings_LaunchContract = PROPERTYKEY{ .fmtid = Guid.initString("14242002-0320-4de4-9555-a7d82b73c286"), .pid = 1 };
pub const DEVINTERFACE_AUDIO_RENDER = Guid.initString("e6327cad-dcec-4949-ae8a-991e976a79d2");
pub const DEVINTERFACE_AUDIO_CAPTURE = Guid.initString("2eef81be-33fa-4800-9670-1cd474972c3f");
pub const DEVINTERFACE_MIDI_OUTPUT = Guid.initString("6dc23320-ab33-4ce4-80d4-bbb3ebbf2814");
pub const DEVINTERFACE_MIDI_INPUT = Guid.initString("504be32c-ccf6-4d2c-b73f-6f8b3747e22b");
pub const EVENTCONTEXT_VOLUMESLIDER = Guid.initString("e2c2e9de-09b1-4b04-84e5-07931225ee04");
pub const SPATIAL_AUDIO_STANDARD_COMMANDS_START = @as(u32, 200);
pub const SPATIAL_AUDIO_POSITION = @as(u32, 200);
pub const SPTLAUD_MD_CLNT_E_COMMAND_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286976));
pub const SPTLAUD_MD_CLNT_E_OBJECT_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286975));
pub const SPTLAUD_MD_CLNT_E_INVALID_ARGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286974));
pub const SPTLAUD_MD_CLNT_E_METADATA_FORMAT_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286973));
pub const SPTLAUD_MD_CLNT_E_VALUE_BUFFER_INCORRECT_SIZE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286972));
pub const SPTLAUD_MD_CLNT_E_MEMORY_BOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286971));
pub const SPTLAUD_MD_CLNT_E_NO_MORE_COMMANDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286970));
pub const SPTLAUD_MD_CLNT_E_BUFFER_ALREADY_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286969));
pub const SPTLAUD_MD_CLNT_E_BUFFER_NOT_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286968));
pub const SPTLAUD_MD_CLNT_E_FRAMECOUNT_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286967));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286960));
pub const SPTLAUD_MD_CLNT_E_ITEM_COPY_OVERFLOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286959));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286958));
pub const SPTLAUD_MD_CLNT_E_ITEMS_ALREADY_OPEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286957));
pub const SPTLAUD_MD_CLNT_E_ATTACH_FAILED_INTERNAL_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286956));
pub const SPTLAUD_MD_CLNT_E_DETACH_FAILED_INTERNAL_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286955));
pub const SPTLAUD_MD_CLNT_E_NO_BUFFER_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286954));
pub const SPTLAUD_MD_CLNT_E_NO_MORE_ITEMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286953));
pub const SPTLAUD_MD_CLNT_E_FRAMEOFFSET_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286952));
pub const SPTLAUD_MD_CLNT_E_ITEM_MUST_HAVE_COMMANDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286951));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMOFFSET_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286944));
pub const SPTLAUD_MD_CLNT_E_NO_ITEMS_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286943));
pub const SPTLAUD_MD_CLNT_E_COMMAND_ALREADY_WRITTEN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286942));
pub const SPTLAUD_MD_CLNT_E_FORMAT_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286941));
pub const SPTLAUD_MD_CLNT_E_BUFFER_STILL_ATTACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286940));
pub const SPTLAUD_MD_CLNT_E_ITEMS_LOCKED_FOR_WRITING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2004286939));
pub const WAVERR_BADFORMAT = @as(u32, 32);
pub const WAVERR_STILLPLAYING = @as(u32, 33);
pub const WAVERR_UNPREPARED = @as(u32, 34);
pub const WAVERR_SYNC = @as(u32, 35);
pub const WAVERR_LASTERROR = @as(u32, 35);
pub const WHDR_DONE = @as(u32, 1);
pub const WHDR_PREPARED = @as(u32, 2);
pub const WHDR_BEGINLOOP = @as(u32, 4);
pub const WHDR_ENDLOOP = @as(u32, 8);
pub const WHDR_INQUEUE = @as(u32, 16);
pub const WAVECAPS_PITCH = @as(u32, 1);
pub const WAVECAPS_PLAYBACKRATE = @as(u32, 2);
pub const WAVECAPS_VOLUME = @as(u32, 4);
pub const WAVECAPS_LRVOLUME = @as(u32, 8);
pub const WAVECAPS_SYNC = @as(u32, 16);
pub const WAVECAPS_SAMPLEACCURATE = @as(u32, 32);
pub const WAVE_INVALIDFORMAT = @as(u32, 0);
pub const WAVE_FORMAT_1M08 = @as(u32, 1);
pub const WAVE_FORMAT_1S08 = @as(u32, 2);
pub const WAVE_FORMAT_1M16 = @as(u32, 4);
pub const WAVE_FORMAT_1S16 = @as(u32, 8);
pub const WAVE_FORMAT_2M08 = @as(u32, 16);
pub const WAVE_FORMAT_2S08 = @as(u32, 32);
pub const WAVE_FORMAT_2M16 = @as(u32, 64);
pub const WAVE_FORMAT_2S16 = @as(u32, 128);
pub const WAVE_FORMAT_4M08 = @as(u32, 256);
pub const WAVE_FORMAT_4S08 = @as(u32, 512);
pub const WAVE_FORMAT_4M16 = @as(u32, 1024);
pub const WAVE_FORMAT_4S16 = @as(u32, 2048);
pub const WAVE_FORMAT_44M08 = @as(u32, 256);
pub const WAVE_FORMAT_44S08 = @as(u32, 512);
pub const WAVE_FORMAT_44M16 = @as(u32, 1024);
pub const WAVE_FORMAT_44S16 = @as(u32, 2048);
pub const WAVE_FORMAT_48M08 = @as(u32, 4096);
pub const WAVE_FORMAT_48S08 = @as(u32, 8192);
pub const WAVE_FORMAT_48M16 = @as(u32, 16384);
pub const WAVE_FORMAT_48S16 = @as(u32, 32768);
pub const WAVE_FORMAT_96M08 = @as(u32, 65536);
pub const WAVE_FORMAT_96S08 = @as(u32, 131072);
pub const WAVE_FORMAT_96M16 = @as(u32, 262144);
pub const WAVE_FORMAT_96S16 = @as(u32, 524288);
pub const WAVE_FORMAT_PCM = @as(u32, 1);
pub const MIDIERR_UNPREPARED = @as(u32, 64);
pub const MIDIERR_STILLPLAYING = @as(u32, 65);
pub const MIDIERR_NOMAP = @as(u32, 66);
pub const MIDIERR_NOTREADY = @as(u32, 67);
pub const MIDIERR_NODEVICE = @as(u32, 68);
pub const MIDIERR_INVALIDSETUP = @as(u32, 69);
pub const MIDIERR_BADOPENMODE = @as(u32, 70);
pub const MIDIERR_DONT_CONTINUE = @as(u32, 71);
pub const MIDIERR_LASTERROR = @as(u32, 71);
pub const MIDIPATCHSIZE = @as(u32, 128);
pub const MIDI_CACHE_ALL = @as(u32, 1);
pub const MIDI_CACHE_BESTFIT = @as(u32, 2);
pub const MIDI_CACHE_QUERY = @as(u32, 3);
pub const MIDI_UNCACHE = @as(u32, 4);
pub const MOD_MIDIPORT = @as(u32, 1);
pub const MOD_SYNTH = @as(u32, 2);
pub const MOD_SQSYNTH = @as(u32, 3);
pub const MOD_FMSYNTH = @as(u32, 4);
pub const MOD_MAPPER = @as(u32, 5);
pub const MOD_WAVETABLE = @as(u32, 6);
pub const MOD_SWSYNTH = @as(u32, 7);
pub const MIDICAPS_VOLUME = @as(u32, 1);
pub const MIDICAPS_LRVOLUME = @as(u32, 2);
pub const MIDICAPS_CACHE = @as(u32, 4);
pub const MIDICAPS_STREAM = @as(u32, 8);
pub const MHDR_DONE = @as(u32, 1);
pub const MHDR_PREPARED = @as(u32, 2);
pub const MHDR_INQUEUE = @as(u32, 4);
pub const MHDR_ISSTRM = @as(u32, 8);
pub const MEVT_F_SHORT = @as(i32, 0);
pub const MEVT_F_LONG = @as(i32, -2147483648);
pub const MEVT_F_CALLBACK = @as(i32, 1073741824);
pub const MIDISTRM_ERROR = @as(i32, -2);
pub const MIDIPROP_SET = @as(i32, -2147483648);
pub const MIDIPROP_GET = @as(i32, 1073741824);
pub const MIDIPROP_TIMEDIV = @as(i32, 1);
pub const MIDIPROP_TEMPO = @as(i32, 2);
pub const AUXCAPS_CDAUDIO = @as(u32, 1);
pub const AUXCAPS_AUXIN = @as(u32, 2);
pub const AUXCAPS_VOLUME = @as(u32, 1);
pub const AUXCAPS_LRVOLUME = @as(u32, 2);
pub const MIXER_SHORT_NAME_CHARS = @as(u32, 16);
pub const MIXER_LONG_NAME_CHARS = @as(u32, 64);
pub const MIXERR_INVALLINE = @as(u32, 1024);
pub const MIXERR_INVALCONTROL = @as(u32, 1025);
pub const MIXERR_INVALVALUE = @as(u32, 1026);
pub const MIXERR_LASTERROR = @as(u32, 1026);
pub const MIXER_OBJECTF_HANDLE = @as(i32, -2147483648);
pub const MIXER_OBJECTF_MIXER = @as(i32, 0);
pub const MIXER_OBJECTF_WAVEOUT = @as(i32, 268435456);
pub const MIXER_OBJECTF_WAVEIN = @as(i32, 536870912);
pub const MIXER_OBJECTF_MIDIOUT = @as(i32, 805306368);
pub const MIXER_OBJECTF_MIDIIN = @as(i32, 1073741824);
pub const MIXER_OBJECTF_AUX = @as(i32, 1342177280);
pub const MIXERLINE_LINEF_ACTIVE = @as(i32, 1);
pub const MIXERLINE_LINEF_DISCONNECTED = @as(i32, 32768);
pub const MIXERLINE_LINEF_SOURCE = @as(i32, -2147483648);
pub const MIXERLINE_COMPONENTTYPE_DST_FIRST = @as(i32, 0);
pub const MIXERLINE_COMPONENTTYPE_DST_LAST = @as(u32, 8);
pub const MIXERLINE_COMPONENTTYPE_SRC_FIRST = @as(i32, 4096);
pub const MIXERLINE_COMPONENTTYPE_SRC_LAST = @as(u32, 4106);
pub const MIXERLINE_TARGETTYPE_UNDEFINED = @as(u32, 0);
pub const MIXERLINE_TARGETTYPE_WAVEOUT = @as(u32, 1);
pub const MIXERLINE_TARGETTYPE_WAVEIN = @as(u32, 2);
pub const MIXERLINE_TARGETTYPE_MIDIOUT = @as(u32, 3);
pub const MIXERLINE_TARGETTYPE_MIDIIN = @as(u32, 4);
pub const MIXERLINE_TARGETTYPE_AUX = @as(u32, 5);
pub const MIXER_GETLINEINFOF_DESTINATION = @as(i32, 0);
pub const MIXER_GETLINEINFOF_SOURCE = @as(i32, 1);
pub const MIXER_GETLINEINFOF_LINEID = @as(i32, 2);
pub const MIXER_GETLINEINFOF_COMPONENTTYPE = @as(i32, 3);
pub const MIXER_GETLINEINFOF_TARGETTYPE = @as(i32, 4);
pub const MIXER_GETLINEINFOF_QUERYMASK = @as(i32, 15);
pub const MIXERCONTROL_CONTROLF_UNIFORM = @as(i32, 1);
pub const MIXERCONTROL_CONTROLF_MULTIPLE = @as(i32, 2);
pub const MIXERCONTROL_CONTROLF_DISABLED = @as(i32, -2147483648);
pub const MIXERCONTROL_CT_CLASS_MASK = @as(i32, -268435456);
pub const MIXERCONTROL_CT_CLASS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_CLASS_METER = @as(i32, 268435456);
pub const MIXERCONTROL_CT_CLASS_SWITCH = @as(i32, 536870912);
pub const MIXERCONTROL_CT_CLASS_NUMBER = @as(i32, 805306368);
pub const MIXERCONTROL_CT_CLASS_SLIDER = @as(i32, 1073741824);
pub const MIXERCONTROL_CT_CLASS_FADER = @as(i32, 1342177280);
pub const MIXERCONTROL_CT_CLASS_TIME = @as(i32, 1610612736);
pub const MIXERCONTROL_CT_CLASS_LIST = @as(i32, 1879048192);
pub const MIXERCONTROL_CT_SUBCLASS_MASK = @as(i32, 251658240);
pub const MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_SWITCH_BUTTON = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_METER_POLLED = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MICROSECS = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_TIME_MILLISECS = @as(i32, 16777216);
pub const MIXERCONTROL_CT_SC_LIST_SINGLE = @as(i32, 0);
pub const MIXERCONTROL_CT_SC_LIST_MULTIPLE = @as(i32, 16777216);
pub const MIXERCONTROL_CT_UNITS_MASK = @as(i32, 16711680);
pub const MIXERCONTROL_CT_UNITS_CUSTOM = @as(i32, 0);
pub const MIXERCONTROL_CT_UNITS_BOOLEAN = @as(i32, 65536);
pub const MIXERCONTROL_CT_UNITS_SIGNED = @as(i32, 131072);
pub const MIXERCONTROL_CT_UNITS_UNSIGNED = @as(i32, 196608);
pub const MIXERCONTROL_CT_UNITS_DECIBELS = @as(i32, 262144);
pub const MIXERCONTROL_CT_UNITS_PERCENT = @as(i32, 327680);
pub const MIXER_GETLINECONTROLSF_ALL = @as(i32, 0);
pub const MIXER_GETLINECONTROLSF_ONEBYID = @as(i32, 1);
pub const MIXER_GETLINECONTROLSF_ONEBYTYPE = @as(i32, 2);
pub const MIXER_GETLINECONTROLSF_QUERYMASK = @as(i32, 15);
pub const MIXER_GETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_GETCONTROLDETAILSF_LISTTEXT = @as(i32, 1);
pub const MIXER_GETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const MIXER_SETCONTROLDETAILSF_VALUE = @as(i32, 0);
pub const MIXER_SETCONTROLDETAILSF_CUSTOM = @as(i32, 1);
pub const MIXER_SETCONTROLDETAILSF_QUERYMASK = @as(i32, 15);
pub const DRV_MAPPER_PREFERRED_INPUT_GET = @as(u32, 16384);
pub const DRV_MAPPER_PREFERRED_OUTPUT_GET = @as(u32, 16386);
pub const DRVM_MAPPER = @as(u32, 8192);
pub const DRVM_MAPPER_STATUS = @as(u32, 8192);
pub const WIDM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEIN_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEIN_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEIN_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const WODM_MAPPER_STATUS = @as(u32, 8192);
pub const WAVEOUT_MAPPER_STATUS_DEVICE = @as(u32, 0);
pub const WAVEOUT_MAPPER_STATUS_MAPPED = @as(u32, 1);
pub const WAVEOUT_MAPPER_STATUS_FORMAT = @as(u32, 2);
pub const ACMERR_BASE = @as(u32, 512);
pub const ACMERR_NOTPOSSIBLE = @as(u32, 512);
pub const ACMERR_BUSY = @as(u32, 513);
pub const ACMERR_UNPREPARED = @as(u32, 514);
pub const ACMERR_CANCELED = @as(u32, 515);
pub const ACM_METRIC_COUNT_DRIVERS = @as(u32, 1);
pub const ACM_METRIC_COUNT_CODECS = @as(u32, 2);
pub const ACM_METRIC_COUNT_CONVERTERS = @as(u32, 3);
pub const ACM_METRIC_COUNT_FILTERS = @as(u32, 4);
pub const ACM_METRIC_COUNT_DISABLED = @as(u32, 5);
pub const ACM_METRIC_COUNT_HARDWARE = @as(u32, 6);
pub const ACM_METRIC_COUNT_LOCAL_DRIVERS = @as(u32, 20);
pub const ACM_METRIC_COUNT_LOCAL_CODECS = @as(u32, 21);
pub const ACM_METRIC_COUNT_LOCAL_CONVERTERS = @as(u32, 22);
pub const ACM_METRIC_COUNT_LOCAL_FILTERS = @as(u32, 23);
pub const ACM_METRIC_COUNT_LOCAL_DISABLED = @as(u32, 24);
pub const ACM_METRIC_HARDWARE_WAVE_INPUT = @as(u32, 30);
pub const ACM_METRIC_HARDWARE_WAVE_OUTPUT = @as(u32, 31);
pub const ACM_METRIC_MAX_SIZE_FORMAT = @as(u32, 50);
pub const ACM_METRIC_MAX_SIZE_FILTER = @as(u32, 51);
pub const ACM_METRIC_DRIVER_SUPPORT = @as(u32, 100);
pub const ACM_METRIC_DRIVER_PRIORITY = @as(u32, 101);
pub const ACM_DRIVERENUMF_NOLOCAL = @as(i32, 1073741824);
pub const ACM_DRIVERENUMF_DISABLED = @as(i32, -2147483648);
pub const ACM_DRIVERADDF_NAME = @as(i32, 1);
pub const ACM_DRIVERADDF_FUNCTION = @as(i32, 3);
pub const ACM_DRIVERADDF_NOTIFYHWND = @as(i32, 4);
pub const ACM_DRIVERADDF_TYPEMASK = @as(i32, 7);
pub const ACM_DRIVERADDF_LOCAL = @as(i32, 0);
pub const ACM_DRIVERADDF_GLOBAL = @as(i32, 8);
pub const ACMDM_USER = @as(u32, 16384);
pub const ACMDM_RESERVED_LOW = @as(u32, 24576);
pub const ACMDM_RESERVED_HIGH = @as(u32, 28671);
pub const ACMDM_DRIVER_ABOUT = @as(u32, 24587);
pub const ACM_DRIVERPRIORITYF_ENABLE = @as(i32, 1);
pub const ACM_DRIVERPRIORITYF_DISABLE = @as(i32, 2);
pub const ACM_DRIVERPRIORITYF_ABLEMASK = @as(i32, 3);
pub const ACM_DRIVERPRIORITYF_BEGIN = @as(i32, 65536);
pub const ACM_DRIVERPRIORITYF_END = @as(i32, 131072);
pub const ACM_DRIVERPRIORITYF_DEFERMASK = @as(i32, 196608);
pub const ACMDRIVERDETAILS_SHORTNAME_CHARS = @as(u32, 32);
pub const ACMDRIVERDETAILS_LONGNAME_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_COPYRIGHT_CHARS = @as(u32, 80);
pub const ACMDRIVERDETAILS_LICENSING_CHARS = @as(u32, 128);
pub const ACMDRIVERDETAILS_FEATURES_CHARS = @as(u32, 512);
pub const ACMDRIVERDETAILS_SUPPORTF_CODEC = @as(i32, 1);
pub const ACMDRIVERDETAILS_SUPPORTF_CONVERTER = @as(i32, 2);
pub const ACMDRIVERDETAILS_SUPPORTF_FILTER = @as(i32, 4);
pub const ACMDRIVERDETAILS_SUPPORTF_HARDWARE = @as(i32, 8);
pub const ACMDRIVERDETAILS_SUPPORTF_ASYNC = @as(i32, 16);
pub const ACMDRIVERDETAILS_SUPPORTF_LOCAL = @as(i32, 1073741824);
pub const ACMDRIVERDETAILS_SUPPORTF_DISABLED = @as(i32, -2147483648);
pub const ACMFORMATTAGDETAILS_FORMATTAG_CHARS = @as(u32, 48);
pub const ACM_FORMATTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATTAGDETAILSF_FORMATTAG = @as(i32, 1);
pub const ACM_FORMATTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FORMATTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFORMATDETAILS_FORMAT_CHARS = @as(u32, 128);
pub const ACM_FORMATDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FORMATDETAILSF_FORMAT = @as(i32, 1);
pub const ACM_FORMATDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FORMATENUMF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATENUMF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATENUMF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATENUMF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATENUMF_CONVERT = @as(i32, 1048576);
pub const ACM_FORMATENUMF_SUGGEST = @as(i32, 2097152);
pub const ACM_FORMATENUMF_HARDWARE = @as(i32, 4194304);
pub const ACM_FORMATENUMF_INPUT = @as(i32, 8388608);
pub const ACM_FORMATENUMF_OUTPUT = @as(i32, 16777216);
pub const ACM_FORMATSUGGESTF_WFORMATTAG = @as(i32, 65536);
pub const ACM_FORMATSUGGESTF_NCHANNELS = @as(i32, 131072);
pub const ACM_FORMATSUGGESTF_NSAMPLESPERSEC = @as(i32, 262144);
pub const ACM_FORMATSUGGESTF_WBITSPERSAMPLE = @as(i32, 524288);
pub const ACM_FORMATSUGGESTF_TYPEMASK = @as(i32, 16711680);
pub const MM_ACM_FORMATCHOOSE = @as(u32, 32768);
pub const FORMATCHOOSE_MESSAGE = @as(u32, 0);
pub const FORMATCHOOSE_FORMATTAG_VERIFY = @as(u32, 0);
pub const FORMATCHOOSE_FORMAT_VERIFY = @as(u32, 1);
pub const FORMATCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFORMATCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFORMATCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT = @as(i32, 64);
pub const ACMFORMATCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMFILTERTAGDETAILS_FILTERTAG_CHARS = @as(u32, 48);
pub const ACM_FILTERTAGDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERTAGDETAILSF_FILTERTAG = @as(i32, 1);
pub const ACM_FILTERTAGDETAILSF_LARGESTSIZE = @as(i32, 2);
pub const ACM_FILTERTAGDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACMFILTERDETAILS_FILTER_CHARS = @as(u32, 128);
pub const ACM_FILTERDETAILSF_INDEX = @as(i32, 0);
pub const ACM_FILTERDETAILSF_FILTER = @as(i32, 1);
pub const ACM_FILTERDETAILSF_QUERYMASK = @as(i32, 15);
pub const ACM_FILTERENUMF_DWFILTERTAG = @as(i32, 65536);
pub const MM_ACM_FILTERCHOOSE = @as(u32, 32768);
pub const FILTERCHOOSE_MESSAGE = @as(u32, 0);
pub const FILTERCHOOSE_FILTERTAG_VERIFY = @as(u32, 0);
pub const FILTERCHOOSE_FILTER_VERIFY = @as(u32, 1);
pub const FILTERCHOOSE_CUSTOM_VERIFY = @as(u32, 2);
pub const ACMFILTERCHOOSE_STYLEF_SHOWHELP = @as(i32, 4);
pub const ACMFILTERCHOOSE_STYLEF_ENABLEHOOK = @as(i32, 8);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE = @as(i32, 16);
pub const ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE = @as(i32, 32);
pub const ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT = @as(i32, 64);
pub const ACMFILTERCHOOSE_STYLEF_CONTEXTHELP = @as(i32, 128);
pub const ACMSTREAMHEADER_STATUSF_DONE = @as(i32, 65536);
pub const ACMSTREAMHEADER_STATUSF_PREPARED = @as(i32, 131072);
pub const ACMSTREAMHEADER_STATUSF_INQUEUE = @as(i32, 1048576);
pub const ACM_STREAMOPENF_QUERY = @as(u32, 1);
pub const ACM_STREAMOPENF_ASYNC = @as(u32, 2);
pub const ACM_STREAMOPENF_NONREALTIME = @as(u32, 4);
pub const ACM_STREAMSIZEF_SOURCE = @as(i32, 0);
pub const ACM_STREAMSIZEF_DESTINATION = @as(i32, 1);
pub const ACM_STREAMSIZEF_QUERYMASK = @as(i32, 15);
pub const ACM_STREAMCONVERTF_BLOCKALIGN = @as(u32, 4);
pub const ACM_STREAMCONVERTF_START = @as(u32, 16);
pub const ACM_STREAMCONVERTF_END = @as(u32, 32);
pub const SND_SYNC = @as(u32, 0);
pub const SND_ASYNC = @as(u32, 1);
pub const SND_NODEFAULT = @as(u32, 2);
pub const SND_MEMORY = @as(u32, 4);
pub const SND_LOOP = @as(u32, 8);
pub const SND_NOSTOP = @as(u32, 16);
pub const SND_NOWAIT = @as(i32, 8192);
pub const SND_ALIAS = @as(i32, 65536);
pub const SND_ALIAS_ID = @as(i32, 1114112);
pub const SND_FILENAME = @as(i32, 131072);
pub const SND_RESOURCE = @as(i32, 262148);
pub const SND_PURGE = @as(u32, 64);
pub const SND_APPLICATION = @as(u32, 128);
pub const SND_SENTRY = @as(i32, 524288);
pub const SND_RING = @as(i32, 1048576);
pub const SND_SYSTEM = @as(i32, 2097152);
pub const SND_ALIAS_START = @as(u32, 0);
pub const ACMDM_DRIVER_NOTIFY = @as(u32, 24577);
pub const ACMDM_DRIVER_DETAILS = @as(u32, 24586);
pub const ACMDM_HARDWARE_WAVE_CAPS_INPUT = @as(u32, 24596);
pub const ACMDM_HARDWARE_WAVE_CAPS_OUTPUT = @as(u32, 24597);
pub const ACMDM_FORMATTAG_DETAILS = @as(u32, 24601);
pub const ACMDM_FORMAT_DETAILS = @as(u32, 24602);
pub const ACMDM_FORMAT_SUGGEST = @as(u32, 24603);
pub const ACMDM_FILTERTAG_DETAILS = @as(u32, 24626);
pub const ACMDM_FILTER_DETAILS = @as(u32, 24627);
pub const ACMDM_STREAM_OPEN = @as(u32, 24652);
pub const ACMDM_STREAM_CLOSE = @as(u32, 24653);
pub const ACMDM_STREAM_SIZE = @as(u32, 24654);
pub const ACMDM_STREAM_CONVERT = @as(u32, 24655);
pub const ACMDM_STREAM_RESET = @as(u32, 24656);
pub const ACMDM_STREAM_PREPARE = @as(u32, 24657);
pub const ACMDM_STREAM_UNPREPARE = @as(u32, 24658);
pub const ACMDM_STREAM_UPDATE = @as(u32, 24659);

//--------------------------------------------------------------------------------
// Section: Types (229)
//--------------------------------------------------------------------------------
pub const LPWAVECALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hdrvr: ?HDRVR,
        uMsg: u32,
        dwUser: usize,
        dw1: usize,
        dw2: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hdrvr: ?HDRVR,
        uMsg: u32,
        dwUser: usize,
        dw1: usize,
        dw2: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const LPMIDICALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hdrvr: ?HDRVR,
        uMsg: u32,
        dwUser: usize,
        dw1: usize,
        dw2: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hdrvr: ?HDRVR,
        uMsg: u32,
        dwUser: usize,
        dw1: usize,
        dw2: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const MIDI_WAVE_OPEN_TYPE = enum(u32) {
    CALLBACK_TYPEMASK = 458752,
    CALLBACK_NULL = 0,
    CALLBACK_WINDOW = 65536,
    CALLBACK_TASK = 131072,
    CALLBACK_FUNCTION = 196608,
    // CALLBACK_THREAD = 131072, this enum value conflicts with CALLBACK_TASK
    CALLBACK_EVENT = 327680,
    WAVE_FORMAT_QUERY = 1,
    WAVE_ALLOWSYNC = 2,
    WAVE_MAPPED = 4,
    WAVE_FORMAT_DIRECT = 8,
    WAVE_FORMAT_DIRECT_QUERY = 9,
    WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = 16,
    MIDI_IO_STATUS = 32,
    _,
    pub fn initFlags(o: struct {
        CALLBACK_TYPEMASK: u1 = 0,
        CALLBACK_NULL: u1 = 0,
        CALLBACK_WINDOW: u1 = 0,
        CALLBACK_TASK: u1 = 0,
        CALLBACK_FUNCTION: u1 = 0,
        CALLBACK_EVENT: u1 = 0,
        WAVE_FORMAT_QUERY: u1 = 0,
        WAVE_ALLOWSYNC: u1 = 0,
        WAVE_MAPPED: u1 = 0,
        WAVE_FORMAT_DIRECT: u1 = 0,
        WAVE_FORMAT_DIRECT_QUERY: u1 = 0,
        WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE: u1 = 0,
        MIDI_IO_STATUS: u1 = 0,
    }) MIDI_WAVE_OPEN_TYPE {
        return @as(MIDI_WAVE_OPEN_TYPE, @enumFromInt((if (o.CALLBACK_TYPEMASK == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_TYPEMASK) else 0) | (if (o.CALLBACK_NULL == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_NULL) else 0) | (if (o.CALLBACK_WINDOW == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_WINDOW) else 0) | (if (o.CALLBACK_TASK == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK) else 0) | (if (o.CALLBACK_FUNCTION == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_FUNCTION) else 0) | (if (o.CALLBACK_EVENT == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.CALLBACK_EVENT) else 0) | (if (o.WAVE_FORMAT_QUERY == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY) else 0) | (if (o.WAVE_ALLOWSYNC == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_ALLOWSYNC) else 0) | (if (o.WAVE_MAPPED == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED) else 0) | (if (o.WAVE_FORMAT_DIRECT == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT) else 0) | (if (o.WAVE_FORMAT_DIRECT_QUERY == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY) else 0) | (if (o.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE) else 0) | (if (o.MIDI_IO_STATUS == 1) @intFromEnum(MIDI_WAVE_OPEN_TYPE.MIDI_IO_STATUS) else 0)));
    }
};
pub const CALLBACK_TYPEMASK = MIDI_WAVE_OPEN_TYPE.CALLBACK_TYPEMASK;
pub const CALLBACK_NULL = MIDI_WAVE_OPEN_TYPE.CALLBACK_NULL;
pub const CALLBACK_WINDOW = MIDI_WAVE_OPEN_TYPE.CALLBACK_WINDOW;
pub const CALLBACK_TASK = MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_FUNCTION = MIDI_WAVE_OPEN_TYPE.CALLBACK_FUNCTION;
pub const CALLBACK_THREAD = MIDI_WAVE_OPEN_TYPE.CALLBACK_TASK;
pub const CALLBACK_EVENT = MIDI_WAVE_OPEN_TYPE.CALLBACK_EVENT;
pub const WAVE_FORMAT_QUERY = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_QUERY;
pub const WAVE_ALLOWSYNC = MIDI_WAVE_OPEN_TYPE.WAVE_ALLOWSYNC;
pub const WAVE_MAPPED = MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED;
pub const WAVE_FORMAT_DIRECT = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT;
pub const WAVE_FORMAT_DIRECT_QUERY = MIDI_WAVE_OPEN_TYPE.WAVE_FORMAT_DIRECT_QUERY;
pub const WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = MIDI_WAVE_OPEN_TYPE.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE;
pub const MIDI_IO_STATUS = MIDI_WAVE_OPEN_TYPE.MIDI_IO_STATUS;

pub const MIXERLINE_COMPONENTTYPE = enum(u32) {
    DST_DIGITAL = 1,
    DST_HEADPHONES = 5,
    DST_LINE = 2,
    DST_MONITOR = 3,
    DST_SPEAKERS = 4,
    DST_TELEPHONE = 6,
    DST_UNDEFINED = 0,
    DST_VOICEIN = 8,
    DST_WAVEIN = 7,
    SRC_ANALOG = 4106,
    SRC_AUXILIARY = 4105,
    SRC_COMPACTDISC = 4101,
    SRC_DIGITAL = 4097,
    SRC_LINE = 4098,
    SRC_MICROPHONE = 4099,
    SRC_PCSPEAKER = 4103,
    SRC_SYNTHESIZER = 4100,
    SRC_TELEPHONE = 4102,
    SRC_UNDEFINED = 4096,
    SRC_WAVEOUT = 4104,
};
pub const MIXERLINE_COMPONENTTYPE_DST_DIGITAL = MIXERLINE_COMPONENTTYPE.DST_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_DST_HEADPHONES = MIXERLINE_COMPONENTTYPE.DST_HEADPHONES;
pub const MIXERLINE_COMPONENTTYPE_DST_LINE = MIXERLINE_COMPONENTTYPE.DST_LINE;
pub const MIXERLINE_COMPONENTTYPE_DST_MONITOR = MIXERLINE_COMPONENTTYPE.DST_MONITOR;
pub const MIXERLINE_COMPONENTTYPE_DST_SPEAKERS = MIXERLINE_COMPONENTTYPE.DST_SPEAKERS;
pub const MIXERLINE_COMPONENTTYPE_DST_TELEPHONE = MIXERLINE_COMPONENTTYPE.DST_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_DST_UNDEFINED = MIXERLINE_COMPONENTTYPE.DST_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_DST_VOICEIN = MIXERLINE_COMPONENTTYPE.DST_VOICEIN;
pub const MIXERLINE_COMPONENTTYPE_DST_WAVEIN = MIXERLINE_COMPONENTTYPE.DST_WAVEIN;
pub const MIXERLINE_COMPONENTTYPE_SRC_ANALOG = MIXERLINE_COMPONENTTYPE.SRC_ANALOG;
pub const MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY = MIXERLINE_COMPONENTTYPE.SRC_AUXILIARY;
pub const MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = MIXERLINE_COMPONENTTYPE.SRC_COMPACTDISC;
pub const MIXERLINE_COMPONENTTYPE_SRC_DIGITAL = MIXERLINE_COMPONENTTYPE.SRC_DIGITAL;
pub const MIXERLINE_COMPONENTTYPE_SRC_LINE = MIXERLINE_COMPONENTTYPE.SRC_LINE;
pub const MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE = MIXERLINE_COMPONENTTYPE.SRC_MICROPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER = MIXERLINE_COMPONENTTYPE.SRC_PCSPEAKER;
pub const MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = MIXERLINE_COMPONENTTYPE.SRC_SYNTHESIZER;
pub const MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE = MIXERLINE_COMPONENTTYPE.SRC_TELEPHONE;
pub const MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED = MIXERLINE_COMPONENTTYPE.SRC_UNDEFINED;
pub const MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT = MIXERLINE_COMPONENTTYPE.SRC_WAVEOUT;

pub const AUDIO_VOLUME_NOTIFICATION_DATA = extern struct {
    guidEventContext: Guid,
    bMuted: BOOL,
    fMasterVolume: f32,
    nChannels: u32,
    afChannelVolumes: [1]f32,
};

pub const HMIDI = *opaque {};

pub const HMIDIIN = *opaque {};

pub const HMIDIOUT = *opaque {};

pub const HMIDISTRM = *opaque {};

pub const HMIXER = *opaque {};

pub const HMIXEROBJ = *opaque {};

pub const HWAVE = *opaque {};

pub const HWAVEOUT = *opaque {};

pub const HWAVEIN = *opaque {};

pub const HACMDRIVERID = *opaque {};

pub const HACMDRIVER = *opaque {};

pub const HACMSTREAM = *opaque {};

pub const HACMOBJ = *opaque {};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMessageFilter_Value = Guid.initString("00000016-0000-0000-c000-000000000046");
pub const IID_IMessageFilter = &IID_IMessageFilter_Value;
pub const IMessageFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleInComingCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessageFilter,
                dwCallType: u32,
                htaskCaller: ?HTASK,
                dwTickCount: u32,
                lpInterfaceInfo: ?*INTERFACEINFO,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMessageFilter,
                dwCallType: u32,
                htaskCaller: ?HTASK,
                dwTickCount: u32,
                lpInterfaceInfo: ?*INTERFACEINFO,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        RetryRejectedCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessageFilter,
                htaskCallee: ?HTASK,
                dwTickCount: u32,
                dwRejectType: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMessageFilter,
                htaskCallee: ?HTASK,
                dwTickCount: u32,
                dwRejectType: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        MessagePending: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessageFilter,
                htaskCallee: ?HTASK,
                dwTickCount: u32,
                dwPendingType: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMessageFilter,
                htaskCallee: ?HTASK,
                dwTickCount: u32,
                dwPendingType: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessageFilter_HandleInComingCall(self: *const T, dwCallType: u32, htaskCaller: ?HTASK, dwTickCount: u32, lpInterfaceInfo: ?*INTERFACEINFO) u32 {
                return @as(*const IMessageFilter.VTable, @ptrCast(self.vtable)).HandleInComingCall(@as(*const IMessageFilter, @ptrCast(self)), dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessageFilter_RetryRejectedCall(self: *const T, htaskCallee: ?HTASK, dwTickCount: u32, dwRejectType: u32) u32 {
                return @as(*const IMessageFilter.VTable, @ptrCast(self.vtable)).RetryRejectedCall(@as(*const IMessageFilter, @ptrCast(self)), htaskCallee, dwTickCount, dwRejectType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessageFilter_MessagePending(self: *const T, htaskCallee: ?HTASK, dwTickCount: u32, dwPendingType: u32) u32 {
                return @as(*const IMessageFilter.VTable, @ptrCast(self.vtable)).MessagePending(@as(*const IMessageFilter, @ptrCast(self)), htaskCallee, dwTickCount, dwPendingType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WAVEFORMATEXTENSIBLE = extern struct {
    Format: WAVEFORMATEX align(1),
    Samples: extern union {
        wValidBitsPerSample: u16 align(1),
        wSamplesPerBlock: u16 align(1),
        wReserved: u16 align(1),
    } align(1),
    dwChannelMask: u32 align(1),
    SubFormat: Guid align(1),
};

pub const WAVEFILTER = extern struct {
    cbStruct: u32 align(1),
    dwFilterTag: u32 align(1),
    fdwFilter: u32 align(1),
    dwReserved: [5]u32 align(1),
};

pub const VOLUMEWAVEFILTER = extern struct {
    wfltr: WAVEFILTER align(1),
    dwVolume: u32 align(1),
};

pub const ECHOWAVEFILTER = extern struct {
    wfltr: WAVEFILTER align(1),
    dwVolume: u32 align(1),
    dwDelay: u32 align(1),
};

pub const WAVEHDR = extern struct {
    lpData: ?PSTR align(1),
    dwBufferLength: u32 align(1),
    dwBytesRecorded: u32 align(1),
    dwUser: usize align(1),
    dwFlags: u32 align(1),
    dwLoops: u32 align(1),
    lpNext: ?*WAVEHDR align(1),
    reserved: usize align(1),
};

pub const WAVEOUTCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const WAVEOUTCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const WAVEOUTCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEOUTCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEINCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
};

pub const WAVEINCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
};

pub const WAVEINCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEINCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwFormats: u32 align(1),
    wChannels: u16 align(1),
    wReserved1: u16 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const WAVEFORMAT = extern struct {
    wFormatTag: u16 align(1),
    nChannels: u16 align(1),
    nSamplesPerSec: u32 align(1),
    nAvgBytesPerSec: u32 align(1),
    nBlockAlign: u16 align(1),
};

pub const PCMWAVEFORMAT = extern struct {
    wf: WAVEFORMAT align(1),
    wBitsPerSample: u16 align(1),
};

pub const WAVEFORMATEX = extern struct {
    wFormatTag: u16 align(1),
    nChannels: u16 align(1),
    nSamplesPerSec: u32 align(1),
    nAvgBytesPerSec: u32 align(1),
    nBlockAlign: u16 align(1),
    wBitsPerSample: u16 align(1),
    cbSize: u16 align(1),
};

pub const MIDIOUTCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
};

pub const MIDIOUTCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
};

pub const MIDIOUTCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIOUTCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wVoices: u16 align(1),
    wNotes: u16 align(1),
    wChannelMask: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIINCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwSupport: u32 align(1),
};

pub const MIDIINCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwSupport: u32 align(1),
};

pub const MIDIINCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIINCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIDIHDR = extern struct {
    lpData: ?PSTR align(1),
    dwBufferLength: u32 align(1),
    dwBytesRecorded: u32 align(1),
    dwUser: usize align(1),
    dwFlags: u32 align(1),
    lpNext: ?*MIDIHDR align(1),
    reserved: usize align(1),
    dwOffset: u32 align(1),
    dwReserved: [8]usize align(1),
};

pub const MIDIEVENT = extern struct {
    dwDeltaTime: u32 align(1),
    dwStreamID: u32 align(1),
    dwEvent: u32 align(1),
    dwParms: [1]u32 align(1),
};

pub const MIDISTRMBUFFVER = extern struct {
    dwVersion: u32 align(1),
    dwMid: u32 align(1),
    dwOEMVersion: u32 align(1),
};

pub const MIDIPROPTIMEDIV = extern struct {
    cbStruct: u32 align(1),
    dwTimeDiv: u32 align(1),
};

pub const MIDIPROPTEMPO = extern struct {
    cbStruct: u32 align(1),
    dwTempo: u32 align(1),
};

pub const AUXCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const AUXCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
};

pub const AUXCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const AUXCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    wTechnology: u16 align(1),
    wReserved1: u16 align(1),
    dwSupport: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIXERCAPSA = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
};

pub const MIXERCAPSW = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
};

pub const MIXERCAPS2A = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]CHAR align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIXERCAPS2W = extern struct {
    wMid: u16 align(1),
    wPid: u16 align(1),
    vDriverVersion: u32 align(1),
    szPname: [32]u16 align(1),
    fdwSupport: u32 align(1),
    cDestinations: u32 align(1),
    ManufacturerGuid: Guid align(1),
    ProductGuid: Guid align(1),
    NameGuid: Guid align(1),
};

pub const MIXERLINEA = extern struct {
    cbStruct: u32 align(1),
    dwDestination: u32 align(1),
    dwSource: u32 align(1),
    dwLineID: u32 align(1),
    fdwLine: u32 align(1),
    dwUser: usize align(1),
    dwComponentType: MIXERLINE_COMPONENTTYPE align(1),
    cChannels: u32 align(1),
    cConnections: u32 align(1),
    cControls: u32 align(1),
    szShortName: [16]CHAR align(1),
    szName: [64]CHAR align(1),
    Target: extern struct {
        dwType: u32 align(1),
        dwDeviceID: u32 align(1),
        wMid: u16 align(1),
        wPid: u16 align(1),
        vDriverVersion: u32 align(1),
        szPname: [32]CHAR align(1),
    } align(1),
};

pub const MIXERLINEW = extern struct {
    cbStruct: u32 align(1),
    dwDestination: u32 align(1),
    dwSource: u32 align(1),
    dwLineID: u32 align(1),
    fdwLine: u32 align(1),
    dwUser: usize align(1),
    dwComponentType: MIXERLINE_COMPONENTTYPE align(1),
    cChannels: u32 align(1),
    cConnections: u32 align(1),
    cControls: u32 align(1),
    szShortName: [16]u16 align(1),
    szName: [64]u16 align(1),
    Target: extern struct {
        dwType: u32 align(1),
        dwDeviceID: u32 align(1),
        wMid: u16 align(1),
        wPid: u16 align(1),
        vDriverVersion: u32 align(1),
        szPname: [32]u16 align(1),
    } align(1),
};

pub const MIXERCONTROLA = extern struct {
    cbStruct: u32 align(1),
    dwControlID: u32 align(1),
    dwControlType: u32 align(1),
    fdwControl: u32 align(1),
    cMultipleItems: u32 align(1),
    szShortName: [16]CHAR align(1),
    szName: [64]CHAR align(1),
    Bounds: extern union {
        Anonymous1: extern struct {
            lMinimum: i32 align(1),
            lMaximum: i32 align(1),
        } align(1),
        Anonymous2: extern struct {
            dwMinimum: u32 align(1),
            dwMaximum: u32 align(1),
        } align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
    Metrics: extern union {
        cSteps: u32 align(1),
        cbCustomData: u32 align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
};

pub const MIXERCONTROLW = extern struct {
    cbStruct: u32 align(1),
    dwControlID: u32 align(1),
    dwControlType: u32 align(1),
    fdwControl: u32 align(1),
    cMultipleItems: u32 align(1),
    szShortName: [16]u16 align(1),
    szName: [64]u16 align(1),
    Bounds: extern union {
        Anonymous1: extern struct {
            lMinimum: i32 align(1),
            lMaximum: i32 align(1),
        } align(1),
        Anonymous2: extern struct {
            dwMinimum: u32 align(1),
            dwMaximum: u32 align(1),
        } align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
    Metrics: extern union {
        cSteps: u32 align(1),
        cbCustomData: u32 align(1),
        dwReserved: [6]u32 align(1),
    } align(1),
};

pub const MIXERLINECONTROLSA = extern struct {
    cbStruct: u32 align(1),
    dwLineID: u32 align(1),
    Anonymous: extern union {
        dwControlID: u32 align(1),
        dwControlType: u32 align(1),
    } align(1),
    cControls: u32 align(1),
    cbmxctrl: u32 align(1),
    pamxctrl: ?*MIXERCONTROLA align(1),
};

pub const MIXERLINECONTROLSW = extern struct {
    cbStruct: u32 align(1),
    dwLineID: u32 align(1),
    Anonymous: extern union {
        dwControlID: u32 align(1),
        dwControlType: u32 align(1),
    } align(1),
    cControls: u32 align(1),
    cbmxctrl: u32 align(1),
    pamxctrl: ?*MIXERCONTROLW align(1),
};

pub const MIXERCONTROLDETAILS = extern struct {
    cbStruct: u32 align(1),
    dwControlID: u32 align(1),
    cChannels: u32 align(1),
    Anonymous: extern union {
        hwndOwner: ?HWND align(1),
        cMultipleItems: u32 align(1),
    } align(1),
    cbDetails: u32 align(1),
    paDetails: ?*anyopaque align(1),
};

pub const MIXERCONTROLDETAILS_LISTTEXTA = extern struct {
    dwParam1: u32 align(1),
    dwParam2: u32 align(1),
    szName: [64]CHAR align(1),
};

pub const MIXERCONTROLDETAILS_LISTTEXTW = extern struct {
    dwParam1: u32 align(1),
    dwParam2: u32 align(1),
    szName: [64]u16 align(1),
};

pub const MIXERCONTROLDETAILS_BOOLEAN = extern struct {
    fValue: i32 align(1),
};

pub const MIXERCONTROLDETAILS_SIGNED = extern struct {
    lValue: i32 align(1),
};

pub const MIXERCONTROLDETAILS_UNSIGNED = extern struct {
    dwValue: u32 align(1),
};

pub const AUDCLNT_SHAREMODE = enum(i32) {
    SHARED = 0,
    EXCLUSIVE = 1,
};
pub const AUDCLNT_SHAREMODE_SHARED = AUDCLNT_SHAREMODE.SHARED;
pub const AUDCLNT_SHAREMODE_EXCLUSIVE = AUDCLNT_SHAREMODE.EXCLUSIVE;

pub const AUDIO_STREAM_CATEGORY = enum(i32) {
    Other = 0,
    ForegroundOnlyMedia = 1,
    Communications = 3,
    Alerts = 4,
    SoundEffects = 5,
    GameEffects = 6,
    GameMedia = 7,
    GameChat = 8,
    Speech = 9,
    Movie = 10,
    Media = 11,
    FarFieldSpeech = 12,
    UniformSpeech = 13,
    VoiceTyping = 14,
};
pub const AudioCategory_Other = AUDIO_STREAM_CATEGORY.Other;
pub const AudioCategory_ForegroundOnlyMedia = AUDIO_STREAM_CATEGORY.ForegroundOnlyMedia;
pub const AudioCategory_Communications = AUDIO_STREAM_CATEGORY.Communications;
pub const AudioCategory_Alerts = AUDIO_STREAM_CATEGORY.Alerts;
pub const AudioCategory_SoundEffects = AUDIO_STREAM_CATEGORY.SoundEffects;
pub const AudioCategory_GameEffects = AUDIO_STREAM_CATEGORY.GameEffects;
pub const AudioCategory_GameMedia = AUDIO_STREAM_CATEGORY.GameMedia;
pub const AudioCategory_GameChat = AUDIO_STREAM_CATEGORY.GameChat;
pub const AudioCategory_Speech = AUDIO_STREAM_CATEGORY.Speech;
pub const AudioCategory_Movie = AUDIO_STREAM_CATEGORY.Movie;
pub const AudioCategory_Media = AUDIO_STREAM_CATEGORY.Media;
pub const AudioCategory_FarFieldSpeech = AUDIO_STREAM_CATEGORY.FarFieldSpeech;
pub const AudioCategory_UniformSpeech = AUDIO_STREAM_CATEGORY.UniformSpeech;
pub const AudioCategory_VoiceTyping = AUDIO_STREAM_CATEGORY.VoiceTyping;

pub const AudioSessionState = enum(i32) {
    Inactive = 0,
    Active = 1,
    Expired = 2,
};
pub const AudioSessionStateInactive = AudioSessionState.Inactive;
pub const AudioSessionStateActive = AudioSessionState.Active;
pub const AudioSessionStateExpired = AudioSessionState.Expired;

pub const _AUDCLNT_BUFFERFLAGS = enum(i32) {
    DATA_DISCONTINUITY = 1,
    SILENT = 2,
    TIMESTAMP_ERROR = 4,
};
pub const AUDCLNT_BUFFERFLAGS_DATA_DISCONTINUITY = _AUDCLNT_BUFFERFLAGS.DATA_DISCONTINUITY;
pub const AUDCLNT_BUFFERFLAGS_SILENT = _AUDCLNT_BUFFERFLAGS.SILENT;
pub const AUDCLNT_BUFFERFLAGS_TIMESTAMP_ERROR = _AUDCLNT_BUFFERFLAGS.TIMESTAMP_ERROR;

pub const AUDCLNT_STREAMOPTIONS = enum(u32) {
    NONE = 0,
    RAW = 1,
    MATCH_FORMAT = 2,
    AMBISONICS = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        RAW: u1 = 0,
        MATCH_FORMAT: u1 = 0,
        AMBISONICS: u1 = 0,
    }) AUDCLNT_STREAMOPTIONS {
        return @as(AUDCLNT_STREAMOPTIONS, @enumFromInt((if (o.NONE == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.NONE) else 0) | (if (o.RAW == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.RAW) else 0) | (if (o.MATCH_FORMAT == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.MATCH_FORMAT) else 0) | (if (o.AMBISONICS == 1) @intFromEnum(AUDCLNT_STREAMOPTIONS.AMBISONICS) else 0)));
    }
};
pub const AUDCLNT_STREAMOPTIONS_NONE = AUDCLNT_STREAMOPTIONS.NONE;
pub const AUDCLNT_STREAMOPTIONS_RAW = AUDCLNT_STREAMOPTIONS.RAW;
pub const AUDCLNT_STREAMOPTIONS_MATCH_FORMAT = AUDCLNT_STREAMOPTIONS.MATCH_FORMAT;
pub const AUDCLNT_STREAMOPTIONS_AMBISONICS = AUDCLNT_STREAMOPTIONS.AMBISONICS;

pub const AudioClientProperties = extern struct {
    cbSize: u32,
    bIsOffload: BOOL,
    eCategory: AUDIO_STREAM_CATEGORY,
    Options: AUDCLNT_STREAMOPTIONS,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioClient_Value = Guid.initString("1cb9ad4c-dbfa-4c32-b178-c2f568a703b2");
pub const IID_IAudioClient = &IID_IAudioClient_Value;
pub const IAudioClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                ShareMode: AUDCLNT_SHAREMODE,
                StreamFlags: u32,
                hnsBufferDuration: i64,
                hnsPeriodicity: i64,
                pFormat: ?*const WAVEFORMATEX,
                AudioSessionGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                ShareMode: AUDCLNT_SHAREMODE,
                StreamFlags: u32,
                hnsBufferDuration: i64,
                hnsPeriodicity: i64,
                pFormat: ?*const WAVEFORMATEX,
                AudioSessionGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                pNumBufferFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                pNumBufferFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                phnsLatency: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                phnsLatency: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPadding: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                pNumPaddingFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                pNumPaddingFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                ShareMode: AUDCLNT_SHAREMODE,
                pFormat: ?*const WAVEFORMATEX,
                ppClosestMatch: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                ShareMode: AUDCLNT_SHAREMODE,
                pFormat: ?*const WAVEFORMATEX,
                ppClosestMatch: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMixFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                ppDeviceFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                ppDeviceFormat: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevicePeriod: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                phnsDefaultDevicePeriod: ?*i64,
                phnsMinimumDevicePeriod: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                phnsDefaultDevicePeriod: ?*i64,
                phnsMinimumDevicePeriod: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                eventHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                eventHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_Initialize(self: *const T, ShareMode: AUDCLNT_SHAREMODE, StreamFlags: u32, hnsBufferDuration: i64, hnsPeriodicity: i64, pFormat: ?*const WAVEFORMATEX, AudioSessionGuid: ?*const Guid) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAudioClient, @ptrCast(self)), ShareMode, StreamFlags, hnsBufferDuration, hnsPeriodicity, pFormat, AudioSessionGuid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_GetBufferSize(self: *const T, pNumBufferFrames: ?*u32) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetBufferSize(@as(*const IAudioClient, @ptrCast(self)), pNumBufferFrames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_GetStreamLatency(self: *const T, phnsLatency: ?*i64) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetStreamLatency(@as(*const IAudioClient, @ptrCast(self)), phnsLatency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_GetCurrentPadding(self: *const T, pNumPaddingFrames: ?*u32) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetCurrentPadding(@as(*const IAudioClient, @ptrCast(self)), pNumPaddingFrames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_IsFormatSupported(self: *const T, ShareMode: AUDCLNT_SHAREMODE, pFormat: ?*const WAVEFORMATEX, ppClosestMatch: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).IsFormatSupported(@as(*const IAudioClient, @ptrCast(self)), ShareMode, pFormat, ppClosestMatch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_GetMixFormat(self: *const T, ppDeviceFormat: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetMixFormat(@as(*const IAudioClient, @ptrCast(self)), ppDeviceFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_GetDevicePeriod(self: *const T, phnsDefaultDevicePeriod: ?*i64, phnsMinimumDevicePeriod: ?*i64) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetDevicePeriod(@as(*const IAudioClient, @ptrCast(self)), phnsDefaultDevicePeriod, phnsMinimumDevicePeriod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_Start(self: *const T) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Start(@as(*const IAudioClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_Stop(self: *const T) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Stop(@as(*const IAudioClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_Reset(self: *const T) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).Reset(@as(*const IAudioClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_SetEventHandle(self: *const T, eventHandle: ?HANDLE) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).SetEventHandle(@as(*const IAudioClient, @ptrCast(self)), eventHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient_GetService(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IAudioClient.VTable, @ptrCast(self.vtable)).GetService(@as(*const IAudioClient, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAudioClient2_Value = Guid.initString("726778cd-f60a-4eda-82de-e47610cd78aa");
pub const IID_IAudioClient2 = &IID_IAudioClient2_Value;
pub const IAudioClient2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioClient.VTable,
        IsOffloadCapable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient2,
                Category: AUDIO_STREAM_CATEGORY,
                pbOffloadCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient2,
                Category: AUDIO_STREAM_CATEGORY,
                pbOffloadCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient2,
                pProperties: ?*const AudioClientProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient2,
                pProperties: ?*const AudioClientProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferSizeLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient2,
                pFormat: ?*const WAVEFORMATEX,
                bEventDriven: BOOL,
                phnsMinBufferDuration: ?*i64,
                phnsMaxBufferDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient2,
                pFormat: ?*const WAVEFORMATEX,
                bEventDriven: BOOL,
                phnsMinBufferDuration: ?*i64,
                phnsMaxBufferDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioClient.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient2_IsOffloadCapable(self: *const T, Category: AUDIO_STREAM_CATEGORY, pbOffloadCapable: ?*BOOL) HRESULT {
                return @as(*const IAudioClient2.VTable, @ptrCast(self.vtable)).IsOffloadCapable(@as(*const IAudioClient2, @ptrCast(self)), Category, pbOffloadCapable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient2_SetClientProperties(self: *const T, pProperties: ?*const AudioClientProperties) HRESULT {
                return @as(*const IAudioClient2.VTable, @ptrCast(self.vtable)).SetClientProperties(@as(*const IAudioClient2, @ptrCast(self)), pProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient2_GetBufferSizeLimits(self: *const T, pFormat: ?*const WAVEFORMATEX, bEventDriven: BOOL, phnsMinBufferDuration: ?*i64, phnsMaxBufferDuration: ?*i64) HRESULT {
                return @as(*const IAudioClient2.VTable, @ptrCast(self.vtable)).GetBufferSizeLimits(@as(*const IAudioClient2, @ptrCast(self)), pFormat, bEventDriven, phnsMinBufferDuration, phnsMaxBufferDuration);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioClient3ActivationParams = extern struct {
    tracingContextId: Guid,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IAudioClient3_Value = Guid.initString("7ed4ee07-8e67-4cd4-8c1a-2b7a5987ad42");
pub const IID_IAudioClient3 = &IID_IAudioClient3_Value;
pub const IAudioClient3 = extern struct {
    pub const VTable = extern struct {
        base: IAudioClient2.VTable,
        GetSharedModeEnginePeriod: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient3,
                pFormat: ?*const WAVEFORMATEX,
                pDefaultPeriodInFrames: ?*u32,
                pFundamentalPeriodInFrames: ?*u32,
                pMinPeriodInFrames: ?*u32,
                pMaxPeriodInFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient3,
                pFormat: ?*const WAVEFORMATEX,
                pDefaultPeriodInFrames: ?*u32,
                pFundamentalPeriodInFrames: ?*u32,
                pMinPeriodInFrames: ?*u32,
                pMaxPeriodInFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSharedModeEnginePeriod: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient3,
                ppFormat: ?*?*WAVEFORMATEX,
                pCurrentPeriodInFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient3,
                ppFormat: ?*?*WAVEFORMATEX,
                pCurrentPeriodInFrames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeSharedAudioStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClient3,
                StreamFlags: u32,
                PeriodInFrames: u32,
                pFormat: ?*const WAVEFORMATEX,
                AudioSessionGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClient3,
                StreamFlags: u32,
                PeriodInFrames: u32,
                pFormat: ?*const WAVEFORMATEX,
                AudioSessionGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioClient2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient3_GetSharedModeEnginePeriod(self: *const T, pFormat: ?*const WAVEFORMATEX, pDefaultPeriodInFrames: ?*u32, pFundamentalPeriodInFrames: ?*u32, pMinPeriodInFrames: ?*u32, pMaxPeriodInFrames: ?*u32) HRESULT {
                return @as(*const IAudioClient3.VTable, @ptrCast(self.vtable)).GetSharedModeEnginePeriod(@as(*const IAudioClient3, @ptrCast(self)), pFormat, pDefaultPeriodInFrames, pFundamentalPeriodInFrames, pMinPeriodInFrames, pMaxPeriodInFrames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient3_GetCurrentSharedModeEnginePeriod(self: *const T, ppFormat: ?*?*WAVEFORMATEX, pCurrentPeriodInFrames: ?*u32) HRESULT {
                return @as(*const IAudioClient3.VTable, @ptrCast(self.vtable)).GetCurrentSharedModeEnginePeriod(@as(*const IAudioClient3, @ptrCast(self)), ppFormat, pCurrentPeriodInFrames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClient3_InitializeSharedAudioStream(self: *const T, StreamFlags: u32, PeriodInFrames: u32, pFormat: ?*const WAVEFORMATEX, AudioSessionGuid: ?*const Guid) HRESULT {
                return @as(*const IAudioClient3.VTable, @ptrCast(self.vtable)).InitializeSharedAudioStream(@as(*const IAudioClient3, @ptrCast(self)), StreamFlags, PeriodInFrames, pFormat, AudioSessionGuid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioRenderClient_Value = Guid.initString("f294acfc-3146-4483-a7bf-addca7c260e2");
pub const IID_IAudioRenderClient = &IID_IAudioRenderClient_Value;
pub const IAudioRenderClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioRenderClient,
                NumFramesRequested: u32,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioRenderClient,
                NumFramesRequested: u32,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioRenderClient,
                NumFramesWritten: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioRenderClient,
                NumFramesWritten: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioRenderClient_GetBuffer(self: *const T, NumFramesRequested: u32, ppData: ?*?*u8) HRESULT {
                return @as(*const IAudioRenderClient.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IAudioRenderClient, @ptrCast(self)), NumFramesRequested, ppData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioRenderClient_ReleaseBuffer(self: *const T, NumFramesWritten: u32, dwFlags: u32) HRESULT {
                return @as(*const IAudioRenderClient.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IAudioRenderClient, @ptrCast(self)), NumFramesWritten, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioCaptureClient_Value = Guid.initString("c8adbd64-e71e-48a0-a4de-185c395cd317");
pub const IID_IAudioCaptureClient = &IID_IAudioCaptureClient_Value;
pub const IAudioCaptureClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioCaptureClient,
                ppData: ?*?*u8,
                pNumFramesToRead: ?*u32,
                pdwFlags: ?*u32,
                pu64DevicePosition: ?*u64,
                pu64QPCPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioCaptureClient,
                ppData: ?*?*u8,
                pNumFramesToRead: ?*u32,
                pdwFlags: ?*u32,
                pu64DevicePosition: ?*u64,
                pu64QPCPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioCaptureClient,
                NumFramesRead: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioCaptureClient,
                NumFramesRead: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioCaptureClient,
                pNumFramesInNextPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioCaptureClient,
                pNumFramesInNextPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioCaptureClient_GetBuffer(self: *const T, ppData: ?*?*u8, pNumFramesToRead: ?*u32, pdwFlags: ?*u32, pu64DevicePosition: ?*u64, pu64QPCPosition: ?*u64) HRESULT {
                return @as(*const IAudioCaptureClient.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IAudioCaptureClient, @ptrCast(self)), ppData, pNumFramesToRead, pdwFlags, pu64DevicePosition, pu64QPCPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioCaptureClient_ReleaseBuffer(self: *const T, NumFramesRead: u32) HRESULT {
                return @as(*const IAudioCaptureClient.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IAudioCaptureClient, @ptrCast(self)), NumFramesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioCaptureClient_GetNextPacketSize(self: *const T, pNumFramesInNextPacket: ?*u32) HRESULT {
                return @as(*const IAudioCaptureClient.VTable, @ptrCast(self.vtable)).GetNextPacketSize(@as(*const IAudioCaptureClient, @ptrCast(self)), pNumFramesInNextPacket);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioClock_Value = Guid.initString("cd63314f-3fba-4a1b-812c-ef96358728e7");
pub const IID_IAudioClock = &IID_IAudioClock_Value;
pub const IAudioClock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClock,
                pu64Frequency: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClock,
                pu64Frequency: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClock,
                pu64Position: ?*u64,
                pu64QPCPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClock,
                pu64Position: ?*u64,
                pu64QPCPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCharacteristics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClock,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClock,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClock_GetFrequency(self: *const T, pu64Frequency: ?*u64) HRESULT {
                return @as(*const IAudioClock.VTable, @ptrCast(self.vtable)).GetFrequency(@as(*const IAudioClock, @ptrCast(self)), pu64Frequency);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClock_GetPosition(self: *const T, pu64Position: ?*u64, pu64QPCPosition: ?*u64) HRESULT {
                return @as(*const IAudioClock.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IAudioClock, @ptrCast(self)), pu64Position, pu64QPCPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClock_GetCharacteristics(self: *const T, pdwCharacteristics: ?*u32) HRESULT {
                return @as(*const IAudioClock.VTable, @ptrCast(self.vtable)).GetCharacteristics(@as(*const IAudioClock, @ptrCast(self)), pdwCharacteristics);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioClock2_Value = Guid.initString("6f49ff73-6727-49ac-a008-d98cf5e70048");
pub const IID_IAudioClock2 = &IID_IAudioClock2_Value;
pub const IAudioClock2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDevicePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClock2,
                DevicePosition: ?*u64,
                QPCPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClock2,
                DevicePosition: ?*u64,
                QPCPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClock2_GetDevicePosition(self: *const T, DevicePosition: ?*u64, QPCPosition: ?*u64) HRESULT {
                return @as(*const IAudioClock2.VTable, @ptrCast(self.vtable)).GetDevicePosition(@as(*const IAudioClock2, @ptrCast(self)), DevicePosition, QPCPosition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioClockAdjustment_Value = Guid.initString("f6e4c0a0-46d9-4fb8-be21-57a3ef2b626c");
pub const IID_IAudioClockAdjustment = &IID_IAudioClockAdjustment_Value;
pub const IAudioClockAdjustment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSampleRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClockAdjustment,
                flSampleRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClockAdjustment,
                flSampleRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClockAdjustment_SetSampleRate(self: *const T, flSampleRate: f32) HRESULT {
                return @as(*const IAudioClockAdjustment.VTable, @ptrCast(self.vtable)).SetSampleRate(@as(*const IAudioClockAdjustment, @ptrCast(self)), flSampleRate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISimpleAudioVolume_Value = Guid.initString("87ce5498-68d6-44e5-9215-6da47ef883d8");
pub const IID_ISimpleAudioVolume = &IID_ISimpleAudioVolume_Value;
pub const ISimpleAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleAudioVolume,
                fLevel: f32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleAudioVolume,
                fLevel: f32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMasterVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleAudioVolume,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleAudioVolume,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleAudioVolume,
                bMute: BOOL,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleAudioVolume,
                bMute: BOOL,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleAudioVolume,
                pbMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleAudioVolume,
                pbMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleAudioVolume_SetMasterVolume(self: *const T, fLevel: f32, EventContext: ?*const Guid) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).SetMasterVolume(@as(*const ISimpleAudioVolume, @ptrCast(self)), fLevel, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleAudioVolume_GetMasterVolume(self: *const T, pfLevel: ?*f32) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).GetMasterVolume(@as(*const ISimpleAudioVolume, @ptrCast(self)), pfLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleAudioVolume_SetMute(self: *const T, bMute: BOOL, EventContext: ?*const Guid) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).SetMute(@as(*const ISimpleAudioVolume, @ptrCast(self)), bMute, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleAudioVolume_GetMute(self: *const T, pbMute: ?*BOOL) HRESULT {
                return @as(*const ISimpleAudioVolume.VTable, @ptrCast(self.vtable)).GetMute(@as(*const ISimpleAudioVolume, @ptrCast(self)), pbMute);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIO_DUCKING_OPTIONS = enum(u32) {
    EFAULT = 0,
    O_NOT_DUCK_OTHER_STREAMS = 1,
    _,
    pub fn initFlags(o: struct {
        EFAULT: u1 = 0,
        O_NOT_DUCK_OTHER_STREAMS: u1 = 0,
    }) AUDIO_DUCKING_OPTIONS {
        return @as(AUDIO_DUCKING_OPTIONS, @enumFromInt((if (o.EFAULT == 1) @intFromEnum(AUDIO_DUCKING_OPTIONS.EFAULT) else 0) | (if (o.O_NOT_DUCK_OTHER_STREAMS == 1) @intFromEnum(AUDIO_DUCKING_OPTIONS.O_NOT_DUCK_OTHER_STREAMS) else 0)));
    }
};
pub const AUDIO_DUCKING_OPTIONS_DEFAULT = AUDIO_DUCKING_OPTIONS.EFAULT;
pub const AUDIO_DUCKING_OPTIONS_DO_NOT_DUCK_OTHER_STREAMS = AUDIO_DUCKING_OPTIONS.O_NOT_DUCK_OTHER_STREAMS;

const IID_IAudioClientDuckingControl_Value = Guid.initString("c789d381-a28c-4168-b28f-d3a837924dc3");
pub const IID_IAudioClientDuckingControl = &IID_IAudioClientDuckingControl_Value;
pub const IAudioClientDuckingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDuckingOptionsForCurrentStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioClientDuckingControl,
                options: AUDIO_DUCKING_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioClientDuckingControl,
                options: AUDIO_DUCKING_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioClientDuckingControl_SetDuckingOptionsForCurrentStream(self: *const T, options: AUDIO_DUCKING_OPTIONS) HRESULT {
                return @as(*const IAudioClientDuckingControl.VTable, @ptrCast(self.vtable)).SetDuckingOptionsForCurrentStream(@as(*const IAudioClientDuckingControl, @ptrCast(self)), options);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUDIO_EFFECT_STATE = enum(i32) {
    FF = 0,
    N = 1,
};
pub const AUDIO_EFFECT_STATE_OFF = AUDIO_EFFECT_STATE.FF;
pub const AUDIO_EFFECT_STATE_ON = AUDIO_EFFECT_STATE.N;

pub const AUDIO_EFFECT = extern struct {
    id: Guid,
    canSetState: BOOL,
    state: AUDIO_EFFECT_STATE,
};

const IID_IAudioEffectsChangedNotificationClient_Value = Guid.initString("a5ded44f-3c5d-4b2b-bd1e-5dc1ee20bbf6");
pub const IID_IAudioEffectsChangedNotificationClient = &IID_IAudioEffectsChangedNotificationClient_Value;
pub const IAudioEffectsChangedNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAudioEffectsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioEffectsChangedNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioEffectsChangedNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioEffectsChangedNotificationClient_OnAudioEffectsChanged(self: *const T) HRESULT {
                return @as(*const IAudioEffectsChangedNotificationClient.VTable, @ptrCast(self.vtable)).OnAudioEffectsChanged(@as(*const IAudioEffectsChangedNotificationClient, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioEffectsManager_Value = Guid.initString("4460b3ae-4b44-4527-8676-7548a8acd260");
pub const IID_IAudioEffectsManager = &IID_IAudioEffectsManager_Value;
pub const IAudioEffectsManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterAudioEffectsChangedNotificationCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioEffectsManager,
                client: ?*IAudioEffectsChangedNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioEffectsManager,
                client: ?*IAudioEffectsChangedNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterAudioEffectsChangedNotificationCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioEffectsManager,
                client: ?*IAudioEffectsChangedNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioEffectsManager,
                client: ?*IAudioEffectsChangedNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioEffectsManager,
                effects: ?*?*AUDIO_EFFECT,
                numEffects: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioEffectsManager,
                effects: ?*?*AUDIO_EFFECT,
                numEffects: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAudioEffectState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioEffectsManager,
                effectId: Guid,
                state: AUDIO_EFFECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioEffectsManager,
                effectId: Guid,
                state: AUDIO_EFFECT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioEffectsManager_RegisterAudioEffectsChangedNotificationCallback(self: *const T, client: ?*IAudioEffectsChangedNotificationClient) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).RegisterAudioEffectsChangedNotificationCallback(@as(*const IAudioEffectsManager, @ptrCast(self)), client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioEffectsManager_UnregisterAudioEffectsChangedNotificationCallback(self: *const T, client: ?*IAudioEffectsChangedNotificationClient) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).UnregisterAudioEffectsChangedNotificationCallback(@as(*const IAudioEffectsManager, @ptrCast(self)), client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioEffectsManager_GetAudioEffects(self: *const T, effects: ?*?*AUDIO_EFFECT, numEffects: ?*u32) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).GetAudioEffects(@as(*const IAudioEffectsManager, @ptrCast(self)), effects, numEffects);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioEffectsManager_SetAudioEffectState(self: *const T, effectId: Guid, state: AUDIO_EFFECT_STATE) HRESULT {
                return @as(*const IAudioEffectsManager.VTable, @ptrCast(self.vtable)).SetAudioEffectState(@as(*const IAudioEffectsManager, @ptrCast(self)), effectId, state);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioStreamVolume_Value = Guid.initString("93014887-242d-4068-8a15-cf5e93b90fe3");
pub const IID_IAudioStreamVolume = &IID_IAudioStreamVolume_Value;
pub const IAudioStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStreamVolume,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioStreamVolume,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStreamVolume,
                dwIndex: u32,
                fLevel: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioStreamVolume,
                dwIndex: u32,
                fLevel: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStreamVolume,
                dwIndex: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioStreamVolume,
                dwIndex: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]const f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]const f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStreamVolume_GetChannelCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IAudioStreamVolume, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStreamVolume_SetChannelVolume(self: *const T, dwIndex: u32, fLevel: f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).SetChannelVolume(@as(*const IAudioStreamVolume, @ptrCast(self)), dwIndex, fLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStreamVolume_GetChannelVolume(self: *const T, dwIndex: u32, pfLevel: ?*f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelVolume(@as(*const IAudioStreamVolume, @ptrCast(self)), dwIndex, pfLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStreamVolume_SetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]const f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).SetAllVolumes(@as(*const IAudioStreamVolume, @ptrCast(self)), dwCount, pfVolumes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStreamVolume_GetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]f32) HRESULT {
                return @as(*const IAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetAllVolumes(@as(*const IAudioStreamVolume, @ptrCast(self)), dwCount, pfVolumes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AMBISONICS_TYPE = enum(i32) {
    D = 0,
};
pub const AMBISONICS_TYPE_FULL3D = AMBISONICS_TYPE.D;

pub const AMBISONICS_CHANNEL_ORDERING = enum(i32) {
    N = 0,
};
pub const AMBISONICS_CHANNEL_ORDERING_ACN = AMBISONICS_CHANNEL_ORDERING.N;

pub const AMBISONICS_NORMALIZATION = enum(i32) {
    SN3D = 0,
    N3D = 1,
};
pub const AMBISONICS_NORMALIZATION_SN3D = AMBISONICS_NORMALIZATION.SN3D;
pub const AMBISONICS_NORMALIZATION_N3D = AMBISONICS_NORMALIZATION.N3D;

pub const AMBISONICS_PARAMS = extern struct {
    u32Size: u32,
    u32Version: u32,
    u32Type: AMBISONICS_TYPE,
    u32ChannelOrdering: AMBISONICS_CHANNEL_ORDERING,
    u32Normalization: AMBISONICS_NORMALIZATION,
    u32Order: u32,
    u32NumChannels: u32,
    pu32ChannelMap: ?*u32,
};

const IID_IAudioAmbisonicsControl_Value = Guid.initString("28724c91-df35-4856-9f76-d6a26413f3df");
pub const IID_IAudioAmbisonicsControl = &IID_IAudioAmbisonicsControl_Value;
pub const IAudioAmbisonicsControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioAmbisonicsControl,
                pAmbisonicsParams: [*]const AMBISONICS_PARAMS,
                cbAmbisonicsParams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioAmbisonicsControl,
                pAmbisonicsParams: [*]const AMBISONICS_PARAMS,
                cbAmbisonicsParams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHeadTracking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioAmbisonicsControl,
                bEnableHeadTracking: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioAmbisonicsControl,
                bEnableHeadTracking: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHeadTracking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioAmbisonicsControl,
                pbEnableHeadTracking: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioAmbisonicsControl,
                pbEnableHeadTracking: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioAmbisonicsControl,
                X: f32,
                Y: f32,
                Z: f32,
                W: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioAmbisonicsControl,
                X: f32,
                Y: f32,
                Z: f32,
                W: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioAmbisonicsControl_SetData(self: *const T, pAmbisonicsParams: [*]const AMBISONICS_PARAMS, cbAmbisonicsParams: u32) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).SetData(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), pAmbisonicsParams, cbAmbisonicsParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioAmbisonicsControl_SetHeadTracking(self: *const T, bEnableHeadTracking: BOOL) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).SetHeadTracking(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), bEnableHeadTracking);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioAmbisonicsControl_GetHeadTracking(self: *const T, pbEnableHeadTracking: ?*BOOL) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).GetHeadTracking(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), pbEnableHeadTracking);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioAmbisonicsControl_SetRotation(self: *const T, X: f32, Y: f32, Z: f32, W: f32) HRESULT {
                return @as(*const IAudioAmbisonicsControl.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const IAudioAmbisonicsControl, @ptrCast(self)), X, Y, Z, W);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IChannelAudioVolume_Value = Guid.initString("1c158861-b533-4b30-b1cf-e853e51c59b8");
pub const IID_IChannelAudioVolume = &IID_IChannelAudioVolume_Value;
pub const IChannelAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelAudioVolume,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChannelAudioVolume,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelAudioVolume,
                dwIndex: u32,
                fLevel: f32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChannelAudioVolume,
                dwIndex: u32,
                fLevel: f32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelAudioVolume,
                dwIndex: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChannelAudioVolume,
                dwIndex: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelAudioVolume,
                dwCount: u32,
                pfVolumes: [*]const f32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChannelAudioVolume,
                dwCount: u32,
                pfVolumes: [*]const f32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelAudioVolume,
                dwCount: u32,
                pfVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IChannelAudioVolume,
                dwCount: u32,
                pfVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelAudioVolume_GetChannelCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IChannelAudioVolume, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelAudioVolume_SetChannelVolume(self: *const T, dwIndex: u32, fLevel: f32, EventContext: ?*const Guid) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).SetChannelVolume(@as(*const IChannelAudioVolume, @ptrCast(self)), dwIndex, fLevel, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelAudioVolume_GetChannelVolume(self: *const T, dwIndex: u32, pfLevel: ?*f32) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).GetChannelVolume(@as(*const IChannelAudioVolume, @ptrCast(self)), dwIndex, pfLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelAudioVolume_SetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]const f32, EventContext: ?*const Guid) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).SetAllVolumes(@as(*const IChannelAudioVolume, @ptrCast(self)), dwCount, pfVolumes, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelAudioVolume_GetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]f32) HRESULT {
                return @as(*const IChannelAudioVolume.VTable, @ptrCast(self.vtable)).GetAllVolumes(@as(*const IChannelAudioVolume, @ptrCast(self)), dwCount, pfVolumes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioObjectType = enum(u32) {
    None = 0,
    Dynamic = 1,
    FrontLeft = 2,
    FrontRight = 4,
    FrontCenter = 8,
    LowFrequency = 16,
    SideLeft = 32,
    SideRight = 64,
    BackLeft = 128,
    BackRight = 256,
    TopFrontLeft = 512,
    TopFrontRight = 1024,
    TopBackLeft = 2048,
    TopBackRight = 4096,
    BottomFrontLeft = 8192,
    BottomFrontRight = 16384,
    BottomBackLeft = 32768,
    BottomBackRight = 65536,
    BackCenter = 131072,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Dynamic: u1 = 0,
        FrontLeft: u1 = 0,
        FrontRight: u1 = 0,
        FrontCenter: u1 = 0,
        LowFrequency: u1 = 0,
        SideLeft: u1 = 0,
        SideRight: u1 = 0,
        BackLeft: u1 = 0,
        BackRight: u1 = 0,
        TopFrontLeft: u1 = 0,
        TopFrontRight: u1 = 0,
        TopBackLeft: u1 = 0,
        TopBackRight: u1 = 0,
        BottomFrontLeft: u1 = 0,
        BottomFrontRight: u1 = 0,
        BottomBackLeft: u1 = 0,
        BottomBackRight: u1 = 0,
        BackCenter: u1 = 0,
    }) AudioObjectType {
        return @as(AudioObjectType, @enumFromInt((if (o.None == 1) @intFromEnum(AudioObjectType.None) else 0) | (if (o.Dynamic == 1) @intFromEnum(AudioObjectType.Dynamic) else 0) | (if (o.FrontLeft == 1) @intFromEnum(AudioObjectType.FrontLeft) else 0) | (if (o.FrontRight == 1) @intFromEnum(AudioObjectType.FrontRight) else 0) | (if (o.FrontCenter == 1) @intFromEnum(AudioObjectType.FrontCenter) else 0) | (if (o.LowFrequency == 1) @intFromEnum(AudioObjectType.LowFrequency) else 0) | (if (o.SideLeft == 1) @intFromEnum(AudioObjectType.SideLeft) else 0) | (if (o.SideRight == 1) @intFromEnum(AudioObjectType.SideRight) else 0) | (if (o.BackLeft == 1) @intFromEnum(AudioObjectType.BackLeft) else 0) | (if (o.BackRight == 1) @intFromEnum(AudioObjectType.BackRight) else 0) | (if (o.TopFrontLeft == 1) @intFromEnum(AudioObjectType.TopFrontLeft) else 0) | (if (o.TopFrontRight == 1) @intFromEnum(AudioObjectType.TopFrontRight) else 0) | (if (o.TopBackLeft == 1) @intFromEnum(AudioObjectType.TopBackLeft) else 0) | (if (o.TopBackRight == 1) @intFromEnum(AudioObjectType.TopBackRight) else 0) | (if (o.BottomFrontLeft == 1) @intFromEnum(AudioObjectType.BottomFrontLeft) else 0) | (if (o.BottomFrontRight == 1) @intFromEnum(AudioObjectType.BottomFrontRight) else 0) | (if (o.BottomBackLeft == 1) @intFromEnum(AudioObjectType.BottomBackLeft) else 0) | (if (o.BottomBackRight == 1) @intFromEnum(AudioObjectType.BottomBackRight) else 0) | (if (o.BackCenter == 1) @intFromEnum(AudioObjectType.BackCenter) else 0)));
    }
};
pub const AudioObjectType_None = AudioObjectType.None;
pub const AudioObjectType_Dynamic = AudioObjectType.Dynamic;
pub const AudioObjectType_FrontLeft = AudioObjectType.FrontLeft;
pub const AudioObjectType_FrontRight = AudioObjectType.FrontRight;
pub const AudioObjectType_FrontCenter = AudioObjectType.FrontCenter;
pub const AudioObjectType_LowFrequency = AudioObjectType.LowFrequency;
pub const AudioObjectType_SideLeft = AudioObjectType.SideLeft;
pub const AudioObjectType_SideRight = AudioObjectType.SideRight;
pub const AudioObjectType_BackLeft = AudioObjectType.BackLeft;
pub const AudioObjectType_BackRight = AudioObjectType.BackRight;
pub const AudioObjectType_TopFrontLeft = AudioObjectType.TopFrontLeft;
pub const AudioObjectType_TopFrontRight = AudioObjectType.TopFrontRight;
pub const AudioObjectType_TopBackLeft = AudioObjectType.TopBackLeft;
pub const AudioObjectType_TopBackRight = AudioObjectType.TopBackRight;
pub const AudioObjectType_BottomFrontLeft = AudioObjectType.BottomFrontLeft;
pub const AudioObjectType_BottomFrontRight = AudioObjectType.BottomFrontRight;
pub const AudioObjectType_BottomBackLeft = AudioObjectType.BottomBackLeft;
pub const AudioObjectType_BottomBackRight = AudioObjectType.BottomBackRight;
pub const AudioObjectType_BackCenter = AudioObjectType.BackCenter;

pub const SPATIAL_AUDIO_STREAM_OPTIONS = enum(u32) {
    NONE = 0,
    OFFLOAD = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        OFFLOAD: u1 = 0,
    }) SPATIAL_AUDIO_STREAM_OPTIONS {
        return @as(SPATIAL_AUDIO_STREAM_OPTIONS, @enumFromInt((if (o.NONE == 1) @intFromEnum(SPATIAL_AUDIO_STREAM_OPTIONS.NONE) else 0) | (if (o.OFFLOAD == 1) @intFromEnum(SPATIAL_AUDIO_STREAM_OPTIONS.OFFLOAD) else 0)));
    }
};
pub const SPATIAL_AUDIO_STREAM_OPTIONS_NONE = SPATIAL_AUDIO_STREAM_OPTIONS.NONE;
pub const SPATIAL_AUDIO_STREAM_OPTIONS_OFFLOAD = SPATIAL_AUDIO_STREAM_OPTIONS.OFFLOAD;

pub const SpatialAudioObjectRenderStreamActivationParams = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
};

pub const SpatialAudioObjectRenderStreamActivationParams2 = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    Options: SPATIAL_AUDIO_STREAM_OPTIONS align(1),
};

const IID_IAudioFormatEnumerator_Value = Guid.initString("dcdaa858-895a-4a22-a5eb-67bda506096d");
pub const IID_IAudioFormatEnumerator = &IID_IAudioFormatEnumerator_Value;
pub const IAudioFormatEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioFormatEnumerator,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioFormatEnumerator,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioFormatEnumerator,
                index: u32,
                format: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioFormatEnumerator,
                index: u32,
                format: ?*?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioFormatEnumerator_GetCount(self: *const T, count: ?*u32) HRESULT {
                return @as(*const IAudioFormatEnumerator.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IAudioFormatEnumerator, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioFormatEnumerator_GetFormat(self: *const T, index: u32, format: ?*?*WAVEFORMATEX) HRESULT {
                return @as(*const IAudioFormatEnumerator.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioFormatEnumerator, @ptrCast(self)), index, format);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectBase_Value = Guid.initString("cce0b8f2-8d4d-4efb-a8cf-3d6ecf1c30e0");
pub const IID_ISpatialAudioObjectBase = &IID_ISpatialAudioObjectBase_Value;
pub const ISpatialAudioObjectBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectBase,
                buffer: ?*?*u8,
                bufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectBase,
                buffer: ?*?*u8,
                bufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectBase,
                frameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectBase,
                frameCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectBase,
                isActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectBase,
                isActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioObjectType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectBase,
                audioObjectType: ?*AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectBase,
                audioObjectType: ?*AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectBase_GetBuffer(self: *const T, buffer: ?*?*u8, bufferLength: ?*u32) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), buffer, bufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectBase_SetEndOfStream(self: *const T, frameCount: u32) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).SetEndOfStream(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), frameCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectBase_IsActive(self: *const T, isActive: ?*BOOL) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).IsActive(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), isActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectBase_GetAudioObjectType(self: *const T, audioObjectType: ?*AudioObjectType) HRESULT {
                return @as(*const ISpatialAudioObjectBase.VTable, @ptrCast(self.vtable)).GetAudioObjectType(@as(*const ISpatialAudioObjectBase, @ptrCast(self)), audioObjectType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObject_Value = Guid.initString("dde28967-521b-46e5-8f00-bd6f2bc8ab1d");
pub const IID_ISpatialAudioObject = &IID_ISpatialAudioObject_Value;
pub const ISpatialAudioObject = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObject,
                x: f32,
                y: f32,
                z: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObject,
                x: f32,
                y: f32,
                z: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObject,
                volume: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObject,
                volume: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObject_SetPosition(self: *const T, x: f32, y: f32, z: f32) HRESULT {
                return @as(*const ISpatialAudioObject.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const ISpatialAudioObject, @ptrCast(self)), x, y, z);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObject_SetVolume(self: *const T, volume: f32) HRESULT {
                return @as(*const ISpatialAudioObject.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const ISpatialAudioObject, @ptrCast(self)), volume);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamBase_Value = Guid.initString("feaaf403-c1d8-450d-aa05-e0ccee7502a8");
pub const IID_ISpatialAudioObjectRenderStreamBase = &IID_ISpatialAudioObjectRenderStreamBase_Value;
pub const ISpatialAudioObjectRenderStreamBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableDynamicObjectCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
                riid: ?*const Guid,
                service: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
                riid: ?*const Guid,
                service: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginUpdatingAudioObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
                availableDynamicObjectCount: ?*u32,
                frameCountPerBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
                availableDynamicObjectCount: ?*u32,
                frameCountPerBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUpdatingAudioObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamBase,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_GetAvailableDynamicObjectCount(self: *const T, value: ?*u32) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).GetAvailableDynamicObjectCount(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_GetService(self: *const T, riid: ?*const Guid, service: ?*?*anyopaque) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).GetService(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)), riid, service);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_Start(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).Start(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_Stop(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).Stop(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_Reset(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_BeginUpdatingAudioObjects(self: *const T, availableDynamicObjectCount: ?*u32, frameCountPerBuffer: ?*u32) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).BeginUpdatingAudioObjects(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)), availableDynamicObjectCount, frameCountPerBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamBase_EndUpdatingAudioObjects(self: *const T) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamBase.VTable, @ptrCast(self.vtable)).EndUpdatingAudioObjects(@as(*const ISpatialAudioObjectRenderStreamBase, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStream_Value = Guid.initString("bab5f473-b423-477b-85f5-b5a332a04153");
pub const IID_ISpatialAudioObjectRenderStream = &IID_ISpatialAudioObjectRenderStream_Value;
pub const ISpatialAudioObjectRenderStream = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStream,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStream,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStream_ActivateSpatialAudioObject(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObject) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStream.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObject(@as(*const ISpatialAudioObjectRenderStream, @ptrCast(self)), type_, audioObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamNotify_Value = Guid.initString("dddf83e6-68d7-4c70-883f-a1836afb4a50");
pub const IID_ISpatialAudioObjectRenderStreamNotify = &IID_ISpatialAudioObjectRenderStreamNotify_Value;
pub const ISpatialAudioObjectRenderStreamNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAvailableDynamicObjectCountChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamNotify,
                sender: ?*ISpatialAudioObjectRenderStreamBase,
                hnsComplianceDeadlineTime: i64,
                availableDynamicObjectCountChange: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamNotify,
                sender: ?*ISpatialAudioObjectRenderStreamBase,
                hnsComplianceDeadlineTime: i64,
                availableDynamicObjectCountChange: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamNotify_OnAvailableDynamicObjectCountChange(self: *const T, sender: ?*ISpatialAudioObjectRenderStreamBase, hnsComplianceDeadlineTime: i64, availableDynamicObjectCountChange: u32) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamNotify.VTable, @ptrCast(self.vtable)).OnAvailableDynamicObjectCountChange(@as(*const ISpatialAudioObjectRenderStreamNotify, @ptrCast(self)), sender, hnsComplianceDeadlineTime, availableDynamicObjectCountChange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioClient_Value = Guid.initString("bbf8e066-aaaa-49be-9a4d-fd2a858ea27f");
pub const IID_ISpatialAudioClient = &IID_ISpatialAudioClient_Value;
pub const ISpatialAudioClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStaticObjectPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                type: AudioObjectType,
                x: ?*f32,
                y: ?*f32,
                z: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                type: AudioObjectType,
                x: ?*f32,
                y: ?*f32,
                z: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNativeStaticObjectTypeMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                mask: ?*AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                mask: ?*AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxDynamicObjectCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedAudioObjectFormatEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                enumerator: ?*?*IAudioFormatEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                enumerator: ?*?*IAudioFormatEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxFrameCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                objectFormat: ?*const WAVEFORMATEX,
                frameCountPerBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                objectFormat: ?*const WAVEFORMATEX,
                frameCountPerBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAudioObjectFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                objectFormat: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                objectFormat: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSpatialAudioStreamAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                streamUuid: ?*const Guid,
                auxiliaryInfo: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                streamUuid: ?*const Guid,
                auxiliaryInfo: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateSpatialAudioStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient,
                activationParams: ?*const PROPVARIANT,
                riid: ?*const Guid,
                stream: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient,
                activationParams: ?*const PROPVARIANT,
                riid: ?*const Guid,
                stream: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_GetStaticObjectPosition(self: *const T, type_: AudioObjectType, x: ?*f32, y: ?*f32, z: ?*f32) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetStaticObjectPosition(@as(*const ISpatialAudioClient, @ptrCast(self)), type_, x, y, z);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_GetNativeStaticObjectTypeMask(self: *const T, mask: ?*AudioObjectType) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetNativeStaticObjectTypeMask(@as(*const ISpatialAudioClient, @ptrCast(self)), mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_GetMaxDynamicObjectCount(self: *const T, value: ?*u32) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetMaxDynamicObjectCount(@as(*const ISpatialAudioClient, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_GetSupportedAudioObjectFormatEnumerator(self: *const T, enumerator: ?*?*IAudioFormatEnumerator) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetSupportedAudioObjectFormatEnumerator(@as(*const ISpatialAudioClient, @ptrCast(self)), enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_GetMaxFrameCount(self: *const T, objectFormat: ?*const WAVEFORMATEX, frameCountPerBuffer: ?*u32) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).GetMaxFrameCount(@as(*const ISpatialAudioClient, @ptrCast(self)), objectFormat, frameCountPerBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_IsAudioObjectFormatSupported(self: *const T, objectFormat: ?*const WAVEFORMATEX) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).IsAudioObjectFormatSupported(@as(*const ISpatialAudioClient, @ptrCast(self)), objectFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_IsSpatialAudioStreamAvailable(self: *const T, streamUuid: ?*const Guid, auxiliaryInfo: ?*const PROPVARIANT) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).IsSpatialAudioStreamAvailable(@as(*const ISpatialAudioClient, @ptrCast(self)), streamUuid, auxiliaryInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient_ActivateSpatialAudioStream(self: *const T, activationParams: ?*const PROPVARIANT, riid: ?*const Guid, stream: ?*?*anyopaque) HRESULT {
                return @as(*const ISpatialAudioClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioStream(@as(*const ISpatialAudioClient, @ptrCast(self)), activationParams, riid, stream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpatialAudioClient2_Value = Guid.initString("caabe452-a66a-4bee-a93e-e320463f6a53");
pub const IID_ISpatialAudioClient2 = &IID_ISpatialAudioClient2_Value;
pub const ISpatialAudioClient2 = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioClient.VTable,
        IsOffloadCapable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient2,
                category: AUDIO_STREAM_CATEGORY,
                isOffloadCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient2,
                category: AUDIO_STREAM_CATEGORY,
                isOffloadCapable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxFrameCountForCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioClient2,
                category: AUDIO_STREAM_CATEGORY,
                offloadEnabled: BOOL,
                objectFormat: ?*const WAVEFORMATEX,
                frameCountPerBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioClient2,
                category: AUDIO_STREAM_CATEGORY,
                offloadEnabled: BOOL,
                objectFormat: ?*const WAVEFORMATEX,
                frameCountPerBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioClient.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient2_IsOffloadCapable(self: *const T, category: AUDIO_STREAM_CATEGORY, isOffloadCapable: ?*BOOL) HRESULT {
                return @as(*const ISpatialAudioClient2.VTable, @ptrCast(self.vtable)).IsOffloadCapable(@as(*const ISpatialAudioClient2, @ptrCast(self)), category, isOffloadCapable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioClient2_GetMaxFrameCountForCategory(self: *const T, category: AUDIO_STREAM_CATEGORY, offloadEnabled: BOOL, objectFormat: ?*const WAVEFORMATEX, frameCountPerBuffer: ?*u32) HRESULT {
                return @as(*const ISpatialAudioClient2.VTable, @ptrCast(self.vtable)).GetMaxFrameCountForCategory(@as(*const ISpatialAudioClient2, @ptrCast(self)), category, offloadEnabled, objectFormat, frameCountPerBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SpatialAudioClientActivationParams = extern struct {
    tracingContextId: Guid,
    appId: Guid,
    majorVersion: i32,
    minorVersion1: i32,
    minorVersion2: i32,
    minorVersion3: i32,
};

pub const SpatialAudioHrtfDirectivityType = enum(i32) {
    OmniDirectional = 0,
    Cardioid = 1,
    Cone = 2,
};
pub const SpatialAudioHrtfDirectivity_OmniDirectional = SpatialAudioHrtfDirectivityType.OmniDirectional;
pub const SpatialAudioHrtfDirectivity_Cardioid = SpatialAudioHrtfDirectivityType.Cardioid;
pub const SpatialAudioHrtfDirectivity_Cone = SpatialAudioHrtfDirectivityType.Cone;

pub const SpatialAudioHrtfEnvironmentType = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
    Outdoors = 3,
    Average = 4,
};
pub const SpatialAudioHrtfEnvironment_Small = SpatialAudioHrtfEnvironmentType.Small;
pub const SpatialAudioHrtfEnvironment_Medium = SpatialAudioHrtfEnvironmentType.Medium;
pub const SpatialAudioHrtfEnvironment_Large = SpatialAudioHrtfEnvironmentType.Large;
pub const SpatialAudioHrtfEnvironment_Outdoors = SpatialAudioHrtfEnvironmentType.Outdoors;
pub const SpatialAudioHrtfEnvironment_Average = SpatialAudioHrtfEnvironmentType.Average;

pub const SpatialAudioHrtfDistanceDecayType = enum(i32) {
    NaturalDecay = 0,
    CustomDecay = 1,
};
pub const SpatialAudioHrtfDistanceDecay_NaturalDecay = SpatialAudioHrtfDistanceDecayType.NaturalDecay;
pub const SpatialAudioHrtfDistanceDecay_CustomDecay = SpatialAudioHrtfDistanceDecayType.CustomDecay;

pub const SpatialAudioHrtfDirectivity = extern struct {
    Type: SpatialAudioHrtfDirectivityType align(1),
    Scaling: f32 align(1),
};

pub const SpatialAudioHrtfDirectivityCardioid = extern struct {
    directivity: SpatialAudioHrtfDirectivity align(1),
    Order: f32 align(1),
};

pub const SpatialAudioHrtfDirectivityCone = extern struct {
    directivity: SpatialAudioHrtfDirectivity align(1),
    InnerAngle: f32 align(1),
    OuterAngle: f32 align(1),
};

pub const SpatialAudioHrtfDirectivityUnion = extern union {
    Cone: SpatialAudioHrtfDirectivityCone,
    Cardiod: SpatialAudioHrtfDirectivityCardioid,
    Omni: SpatialAudioHrtfDirectivity,
};

pub const SpatialAudioHrtfDistanceDecay = extern struct {
    Type: SpatialAudioHrtfDistanceDecayType align(1),
    MaxGain: f32 align(1),
    MinGain: f32 align(1),
    UnityGainDistance: f32 align(1),
    CutoffDistance: f32 align(1),
};

pub const SpatialAudioHrtfActivationParams = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    DistanceDecay: ?*SpatialAudioHrtfDistanceDecay align(1),
    Directivity: ?*SpatialAudioHrtfDirectivityUnion align(1),
    Environment: ?*SpatialAudioHrtfEnvironmentType align(1),
    Orientation: ?*f32 align(1),
};

pub const SpatialAudioHrtfActivationParams2 = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    DistanceDecay: ?*SpatialAudioHrtfDistanceDecay align(1),
    Directivity: ?*SpatialAudioHrtfDirectivityUnion align(1),
    Environment: ?*SpatialAudioHrtfEnvironmentType align(1),
    Orientation: ?*f32 align(1),
    Options: SPATIAL_AUDIO_STREAM_OPTIONS align(1),
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForHrtf_Value = Guid.initString("d7436ade-1978-4e14-aba0-555bd8eb83b4");
pub const IID_ISpatialAudioObjectForHrtf = &IID_ISpatialAudioObjectForHrtf_Value;
pub const ISpatialAudioObjectForHrtf = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForHrtf,
                x: f32,
                y: f32,
                z: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForHrtf,
                x: f32,
                y: f32,
                z: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGain: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForHrtf,
                gain: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForHrtf,
                gain: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOrientation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForHrtf,
                orientation: ?*const ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForHrtf,
                orientation: ?*const ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnvironment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForHrtf,
                environment: SpatialAudioHrtfEnvironmentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForHrtf,
                environment: SpatialAudioHrtfEnvironmentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDistanceDecay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForHrtf,
                distanceDecay: ?*SpatialAudioHrtfDistanceDecay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForHrtf,
                distanceDecay: ?*SpatialAudioHrtfDistanceDecay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForHrtf,
                directivity: ?*SpatialAudioHrtfDirectivityUnion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForHrtf,
                directivity: ?*SpatialAudioHrtfDirectivityUnion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForHrtf_SetPosition(self: *const T, x: f32, y: f32, z: f32) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), x, y, z);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForHrtf_SetGain(self: *const T, gain: f32) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetGain(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), gain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForHrtf_SetOrientation(self: *const T, orientation: ?*const ?*f32) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetOrientation(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), orientation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForHrtf_SetEnvironment(self: *const T, environment: SpatialAudioHrtfEnvironmentType) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetEnvironment(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForHrtf_SetDistanceDecay(self: *const T, distanceDecay: ?*SpatialAudioHrtfDistanceDecay) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetDistanceDecay(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), distanceDecay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForHrtf_SetDirectivity(self: *const T, directivity: ?*SpatialAudioHrtfDirectivityUnion) HRESULT {
                return @as(*const ISpatialAudioObjectForHrtf.VTable, @ptrCast(self.vtable)).SetDirectivity(@as(*const ISpatialAudioObjectForHrtf, @ptrCast(self)), directivity);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamForHrtf_Value = Guid.initString("e08deef9-5363-406e-9fdc-080ee247bbe0");
pub const IID_ISpatialAudioObjectRenderStreamForHrtf = &IID_ISpatialAudioObjectRenderStreamForHrtf_Value;
pub const ISpatialAudioObjectRenderStreamForHrtf = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObjectForHrtf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamForHrtf,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObjectForHrtf,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamForHrtf,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObjectForHrtf,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamForHrtf_ActivateSpatialAudioObjectForHrtf(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObjectForHrtf) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamForHrtf.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObjectForHrtf(@as(*const ISpatialAudioObjectRenderStreamForHrtf, @ptrCast(self)), type_, audioObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MMDeviceEnumerator_Value = Guid.initString("bcde0395-e52f-467c-8e3d-c4579291692e");
pub const CLSID_MMDeviceEnumerator = &CLSID_MMDeviceEnumerator_Value;

pub const DIRECTX_AUDIO_ACTIVATION_PARAMS = extern struct {
    cbDirectXAudioActivationParams: u32,
    guidAudioSession: Guid,
    dwAudioStreamFlags: u32,
};

pub const EDataFlow = enum(i32) {
    eRender = 0,
    eCapture = 1,
    eAll = 2,
    EDataFlow_enum_count = 3,
};
pub const eRender = EDataFlow.eRender;
pub const eCapture = EDataFlow.eCapture;
pub const eAll = EDataFlow.eAll;
pub const EDataFlow_enum_count = EDataFlow.EDataFlow_enum_count;

pub const ERole = enum(i32) {
    eConsole = 0,
    eMultimedia = 1,
    eCommunications = 2,
    ERole_enum_count = 3,
};
pub const eConsole = ERole.eConsole;
pub const eMultimedia = ERole.eMultimedia;
pub const eCommunications = ERole.eCommunications;
pub const ERole_enum_count = ERole.ERole_enum_count;

pub const EndpointFormFactor = enum(i32) {
    RemoteNetworkDevice = 0,
    Speakers = 1,
    LineLevel = 2,
    Headphones = 3,
    Microphone = 4,
    Headset = 5,
    Handset = 6,
    UnknownDigitalPassthrough = 7,
    SPDIF = 8,
    DigitalAudioDisplayDevice = 9,
    UnknownFormFactor = 10,
    EndpointFormFactor_enum_count = 11,
};
pub const RemoteNetworkDevice = EndpointFormFactor.RemoteNetworkDevice;
pub const Speakers = EndpointFormFactor.Speakers;
pub const LineLevel = EndpointFormFactor.LineLevel;
pub const Headphones = EndpointFormFactor.Headphones;
pub const Microphone = EndpointFormFactor.Microphone;
pub const Headset = EndpointFormFactor.Headset;
pub const Handset = EndpointFormFactor.Handset;
pub const UnknownDigitalPassthrough = EndpointFormFactor.UnknownDigitalPassthrough;
pub const SPDIF = EndpointFormFactor.SPDIF;
pub const DigitalAudioDisplayDevice = EndpointFormFactor.DigitalAudioDisplayDevice;
pub const UnknownFormFactor = EndpointFormFactor.UnknownFormFactor;
pub const EndpointFormFactor_enum_count = EndpointFormFactor.EndpointFormFactor_enum_count;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMNotificationClient_Value = Guid.initString("7991eec9-7e89-4d85-8390-6c703cec60c0");
pub const IID_IMMNotificationClient = &IID_IMMNotificationClient_Value;
pub const IMMNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDeviceStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
                dwNewState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
                dwNewState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDeviceAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDeviceRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDefaultDeviceChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMNotificationClient,
                flow: EDataFlow,
                role: ERole,
                pwstrDefaultDeviceId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMNotificationClient,
                flow: EDataFlow,
                role: ERole,
                pwstrDefaultDeviceId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPropertyValueChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
                key: PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMNotificationClient,
                pwstrDeviceId: ?[*:0]const u16,
                key: PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMNotificationClient_OnDeviceStateChanged(self: *const T, pwstrDeviceId: ?[*:0]const u16, dwNewState: u32) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDeviceStateChanged(@as(*const IMMNotificationClient, @ptrCast(self)), pwstrDeviceId, dwNewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMNotificationClient_OnDeviceAdded(self: *const T, pwstrDeviceId: ?[*:0]const u16) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDeviceAdded(@as(*const IMMNotificationClient, @ptrCast(self)), pwstrDeviceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMNotificationClient_OnDeviceRemoved(self: *const T, pwstrDeviceId: ?[*:0]const u16) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDeviceRemoved(@as(*const IMMNotificationClient, @ptrCast(self)), pwstrDeviceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMNotificationClient_OnDefaultDeviceChanged(self: *const T, flow: EDataFlow, role: ERole, pwstrDefaultDeviceId: ?[*:0]const u16) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnDefaultDeviceChanged(@as(*const IMMNotificationClient, @ptrCast(self)), flow, role, pwstrDefaultDeviceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMNotificationClient_OnPropertyValueChanged(self: *const T, pwstrDeviceId: ?[*:0]const u16, key: PROPERTYKEY) HRESULT {
                return @as(*const IMMNotificationClient.VTable, @ptrCast(self.vtable)).OnPropertyValueChanged(@as(*const IMMNotificationClient, @ptrCast(self)), pwstrDeviceId, key);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDevice_Value = Guid.initString("d666063f-1587-4e43-81f1-b948e807363f");
pub const IID_IMMDevice = &IID_IMMDevice_Value;
pub const IMMDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDevice,
                iid: ?*const Guid,
                dwClsCtx: u32,
                pActivationParams: ?*PROPVARIANT,
                ppInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDevice,
                iid: ?*const Guid,
                dwClsCtx: u32,
                pActivationParams: ?*PROPVARIANT,
                ppInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDevice,
                stgmAccess: u32,
                ppProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDevice,
                stgmAccess: u32,
                ppProperties: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDevice,
                ppstrId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDevice,
                ppstrId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDevice,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDevice,
                pdwState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDevice_Activate(self: *const T, iid: ?*const Guid, dwClsCtx: u32, pActivationParams: ?*PROPVARIANT, ppInterface: ?*?*anyopaque) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).Activate(@as(*const IMMDevice, @ptrCast(self)), iid, dwClsCtx, pActivationParams, ppInterface);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDevice_OpenPropertyStore(self: *const T, stgmAccess: u32, ppProperties: ?*?*IPropertyStore) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).OpenPropertyStore(@as(*const IMMDevice, @ptrCast(self)), stgmAccess, ppProperties);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDevice_GetId(self: *const T, ppstrId: ?*?PWSTR) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).GetId(@as(*const IMMDevice, @ptrCast(self)), ppstrId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDevice_GetState(self: *const T, pdwState: ?*u32) HRESULT {
                return @as(*const IMMDevice.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMMDevice, @ptrCast(self)), pdwState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDeviceCollection_Value = Guid.initString("0bd7a1be-7a1a-44db-8397-cc5392387b5e");
pub const IID_IMMDeviceCollection = &IID_IMMDeviceCollection_Value;
pub const IMMDeviceCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceCollection,
                pcDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceCollection,
                pcDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceCollection,
                nDevice: u32,
                ppDevice: ?*?*IMMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceCollection,
                nDevice: u32,
                ppDevice: ?*?*IMMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceCollection_GetCount(self: *const T, pcDevices: ?*u32) HRESULT {
                return @as(*const IMMDeviceCollection.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IMMDeviceCollection, @ptrCast(self)), pcDevices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceCollection_Item(self: *const T, nDevice: u32, ppDevice: ?*?*IMMDevice) HRESULT {
                return @as(*const IMMDeviceCollection.VTable, @ptrCast(self.vtable)).Item(@as(*const IMMDeviceCollection, @ptrCast(self)), nDevice, ppDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMEndpoint_Value = Guid.initString("1be09788-6894-4089-8586-9a2a6c265ac5");
pub const IID_IMMEndpoint = &IID_IMMEndpoint_Value;
pub const IMMEndpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataFlow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMEndpoint,
                pDataFlow: ?*EDataFlow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMEndpoint,
                pDataFlow: ?*EDataFlow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMEndpoint_GetDataFlow(self: *const T, pDataFlow: ?*EDataFlow) HRESULT {
                return @as(*const IMMEndpoint.VTable, @ptrCast(self.vtable)).GetDataFlow(@as(*const IMMEndpoint, @ptrCast(self)), pDataFlow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMDeviceEnumerator_Value = Guid.initString("a95664d2-9614-4f35-a746-de8db63617e6");
pub const IID_IMMDeviceEnumerator = &IID_IMMDeviceEnumerator_Value;
pub const IMMDeviceEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumAudioEndpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceEnumerator,
                dataFlow: EDataFlow,
                dwStateMask: u32,
                ppDevices: ?*?*IMMDeviceCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceEnumerator,
                dataFlow: EDataFlow,
                dwStateMask: u32,
                ppDevices: ?*?*IMMDeviceCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultAudioEndpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceEnumerator,
                dataFlow: EDataFlow,
                role: ERole,
                ppEndpoint: ?*?*IMMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceEnumerator,
                dataFlow: EDataFlow,
                role: ERole,
                ppEndpoint: ?*?*IMMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceEnumerator,
                pwstrId: ?[*:0]const u16,
                ppDevice: ?*?*IMMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceEnumerator,
                pwstrId: ?[*:0]const u16,
                ppDevice: ?*?*IMMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterEndpointNotificationCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceEnumerator,
                pClient: ?*IMMNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceEnumerator,
                pClient: ?*IMMNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterEndpointNotificationCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceEnumerator,
                pClient: ?*IMMNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceEnumerator,
                pClient: ?*IMMNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceEnumerator_EnumAudioEndpoints(self: *const T, dataFlow: EDataFlow, dwStateMask: u32, ppDevices: ?*?*IMMDeviceCollection) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).EnumAudioEndpoints(@as(*const IMMDeviceEnumerator, @ptrCast(self)), dataFlow, dwStateMask, ppDevices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceEnumerator_GetDefaultAudioEndpoint(self: *const T, dataFlow: EDataFlow, role: ERole, ppEndpoint: ?*?*IMMDevice) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).GetDefaultAudioEndpoint(@as(*const IMMDeviceEnumerator, @ptrCast(self)), dataFlow, role, ppEndpoint);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceEnumerator_GetDevice(self: *const T, pwstrId: ?[*:0]const u16, ppDevice: ?*?*IMMDevice) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IMMDeviceEnumerator, @ptrCast(self)), pwstrId, ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceEnumerator_RegisterEndpointNotificationCallback(self: *const T, pClient: ?*IMMNotificationClient) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).RegisterEndpointNotificationCallback(@as(*const IMMDeviceEnumerator, @ptrCast(self)), pClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(self: *const T, pClient: ?*IMMNotificationClient) HRESULT {
                return @as(*const IMMDeviceEnumerator.VTable, @ptrCast(self.vtable)).UnregisterEndpointNotificationCallback(@as(*const IMMDeviceEnumerator, @ptrCast(self)), pClient);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMMDeviceActivator_Value = Guid.initString("3b0d0ea4-d0a9-4b0e-935b-09516746fac0");
pub const IID_IMMDeviceActivator = &IID_IMMDeviceActivator_Value;
pub const IMMDeviceActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMMDeviceActivator,
                iid: ?*const Guid,
                pDevice: ?*IMMDevice,
                pActivationParams: ?*PROPVARIANT,
                ppInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMMDeviceActivator,
                iid: ?*const Guid,
                pDevice: ?*IMMDevice,
                pActivationParams: ?*PROPVARIANT,
                ppInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMMDeviceActivator_Activate(self: *const T, iid: ?*const Guid, pDevice: ?*IMMDevice, pActivationParams: ?*PROPVARIANT, ppInterface: ?*?*anyopaque) HRESULT {
                return @as(*const IMMDeviceActivator.VTable, @ptrCast(self.vtable)).Activate(@as(*const IMMDeviceActivator, @ptrCast(self)), iid, pDevice, pActivationParams, ppInterface);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivateAudioInterfaceCompletionHandler_Value = Guid.initString("41d949ab-9862-444a-80f6-c261334da5eb");
pub const IID_IActivateAudioInterfaceCompletionHandler = &IID_IActivateAudioInterfaceCompletionHandler_Value;
pub const IActivateAudioInterfaceCompletionHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActivateAudioInterfaceCompletionHandler,
                activateOperation: ?*IActivateAudioInterfaceAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActivateAudioInterfaceCompletionHandler,
                activateOperation: ?*IActivateAudioInterfaceAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActivateAudioInterfaceCompletionHandler_ActivateCompleted(self: *const T, activateOperation: ?*IActivateAudioInterfaceAsyncOperation) HRESULT {
                return @as(*const IActivateAudioInterfaceCompletionHandler.VTable, @ptrCast(self.vtable)).ActivateCompleted(@as(*const IActivateAudioInterfaceCompletionHandler, @ptrCast(self)), activateOperation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IActivateAudioInterfaceAsyncOperation_Value = Guid.initString("72a22d78-cde4-431d-b8cc-843a71199b6d");
pub const IID_IActivateAudioInterfaceAsyncOperation = &IID_IActivateAudioInterfaceAsyncOperation_Value;
pub const IActivateAudioInterfaceAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActivateResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActivateAudioInterfaceAsyncOperation,
                activateResult: ?*HRESULT,
                activatedInterface: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActivateAudioInterfaceAsyncOperation,
                activateResult: ?*HRESULT,
                activatedInterface: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActivateAudioInterfaceAsyncOperation_GetActivateResult(self: *const T, activateResult: ?*HRESULT, activatedInterface: ?*?*IUnknown) HRESULT {
                return @as(*const IActivateAudioInterfaceAsyncOperation.VTable, @ptrCast(self.vtable)).GetActivateResult(@as(*const IActivateAudioInterfaceAsyncOperation, @ptrCast(self)), activateResult, activatedInterface);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioExtensionParams = extern struct {
    AddPageParam: LPARAM,
    pEndpoint: ?*IMMDevice,
    pPnpInterface: ?*IMMDevice,
    pPnpDevnode: ?*IMMDevice,
};

pub const __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002 = enum(i32) {
    DEFAULT = 0,
    USER = 1,
    VOLATILE = 2,
    ENUM_COUNT = 3,
};
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_DEFAULT = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.DEFAULT;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_USER = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.USER;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_VOLATILE = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.VOLATILE;
pub const AUDIO_SYSTEMEFFECTS_PROPERTYSTORE_TYPE_ENUM_COUNT = __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002.ENUM_COUNT;

const IID_IAudioSystemEffectsPropertyChangeNotificationClient_Value = Guid.initString("20049d40-56d5-400e-a2ef-385599feed49");
pub const IID_IAudioSystemEffectsPropertyChangeNotificationClient = &IID_IAudioSystemEffectsPropertyChangeNotificationClient_Value;
pub const IAudioSystemEffectsPropertyChangeNotificationClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPropertyChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyChangeNotificationClient,
                type: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002,
                key: PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyChangeNotificationClient,
                type: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002,
                key: PROPERTYKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyChangeNotificationClient_OnPropertyChanged(self: *const T, type_: __MIDL___MIDL_itf_mmdeviceapi_0000_0008_0002, key: PROPERTYKEY) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyChangeNotificationClient.VTable, @ptrCast(self.vtable)).OnPropertyChanged(@as(*const IAudioSystemEffectsPropertyChangeNotificationClient, @ptrCast(self)), type_, key);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSystemEffectsPropertyStore_Value = Guid.initString("302ae7f9-d7e0-43e4-971b-1f8293613d2a");
pub const IID_IAudioSystemEffectsPropertyStore = &IID_IAudioSystemEffectsPropertyStore_Value;
pub const IAudioSystemEffectsPropertyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDefaultPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
                stgmAccess: u32,
                propStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
                stgmAccess: u32,
                propStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenUserPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
                stgmAccess: u32,
                propStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
                stgmAccess: u32,
                propStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenVolatilePropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
                stgmAccess: u32,
                propStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
                stgmAccess: u32,
                propStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetUserPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetVolatilePropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterPropertyChangeNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
                callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
                callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterPropertyChangeNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSystemEffectsPropertyStore,
                callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSystemEffectsPropertyStore,
                callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_OpenDefaultPropertyStore(self: *const T, stgmAccess: u32, propStore: ?*?*IPropertyStore) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).OpenDefaultPropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), stgmAccess, propStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_OpenUserPropertyStore(self: *const T, stgmAccess: u32, propStore: ?*?*IPropertyStore) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).OpenUserPropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), stgmAccess, propStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_OpenVolatilePropertyStore(self: *const T, stgmAccess: u32, propStore: ?*?*IPropertyStore) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).OpenVolatilePropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), stgmAccess, propStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_ResetUserPropertyStore(self: *const T) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).ResetUserPropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_ResetVolatilePropertyStore(self: *const T) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).ResetVolatilePropertyStore(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_RegisterPropertyChangeNotification(self: *const T, callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).RegisterPropertyChangeNotification(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), callback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSystemEffectsPropertyStore_UnregisterPropertyChangeNotification(self: *const T, callback: ?*IAudioSystemEffectsPropertyChangeNotificationClient) HRESULT {
                return @as(*const IAudioSystemEffectsPropertyStore.VTable, @ptrCast(self.vtable)).UnregisterPropertyChangeNotification(@as(*const IAudioSystemEffectsPropertyStore, @ptrCast(self)), callback);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DeviceTopology_Value = Guid.initString("1df639d0-5ec1-47aa-9379-828dc1aa8c59");
pub const CLSID_DeviceTopology = &CLSID_DeviceTopology_Value;

pub const DataFlow = enum(i32) {
    In = 0,
    Out = 1,
};
pub const In = DataFlow.In;
pub const Out = DataFlow.Out;

pub const PartType = enum(i32) {
    Connector = 0,
    Subunit = 1,
};
pub const Connector = PartType.Connector;
pub const Subunit = PartType.Subunit;

pub const ConnectorType = enum(i32) {
    Unknown_Connector = 0,
    Physical_Internal = 1,
    Physical_External = 2,
    Software_IO = 3,
    Software_Fixed = 4,
    Network = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPerChannelDbLevel_Value = Guid.initString("c2f8e001-f205-4bc9-99bc-c13b1e048ccb");
pub const IID_IPerChannelDbLevel = &IID_IPerChannelDbLevel_Value;
pub const IPerChannelDbLevel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerChannelDbLevel,
                pcChannels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerChannelDbLevel,
                pcChannels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLevelRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerChannelDbLevel,
                nChannel: u32,
                pfMinLevelDB: ?*f32,
                pfMaxLevelDB: ?*f32,
                pfStepping: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerChannelDbLevel,
                nChannel: u32,
                pfMinLevelDB: ?*f32,
                pfMaxLevelDB: ?*f32,
                pfStepping: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerChannelDbLevel,
                nChannel: u32,
                pfLevelDB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerChannelDbLevel,
                nChannel: u32,
                pfLevelDB: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerChannelDbLevel,
                nChannel: u32,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerChannelDbLevel,
                nChannel: u32,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLevelUniform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerChannelDbLevel,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerChannelDbLevel,
                fLevelDB: f32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLevelAllChannels: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerChannelDbLevel,
                aLevelsDB: [*]f32,
                cChannels: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerChannelDbLevel,
                aLevelsDB: [*]f32,
                cChannels: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerChannelDbLevel_GetChannelCount(self: *const T, pcChannels: ?*u32) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IPerChannelDbLevel, @ptrCast(self)), pcChannels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerChannelDbLevel_GetLevelRange(self: *const T, nChannel: u32, pfMinLevelDB: ?*f32, pfMaxLevelDB: ?*f32, pfStepping: ?*f32) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).GetLevelRange(@as(*const IPerChannelDbLevel, @ptrCast(self)), nChannel, pfMinLevelDB, pfMaxLevelDB, pfStepping);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerChannelDbLevel_GetLevel(self: *const T, nChannel: u32, pfLevelDB: ?*f32) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).GetLevel(@as(*const IPerChannelDbLevel, @ptrCast(self)), nChannel, pfLevelDB);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerChannelDbLevel_SetLevel(self: *const T, nChannel: u32, fLevelDB: f32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).SetLevel(@as(*const IPerChannelDbLevel, @ptrCast(self)), nChannel, fLevelDB, pguidEventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerChannelDbLevel_SetLevelUniform(self: *const T, fLevelDB: f32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).SetLevelUniform(@as(*const IPerChannelDbLevel, @ptrCast(self)), fLevelDB, pguidEventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerChannelDbLevel_SetLevelAllChannels(self: *const T, aLevelsDB: [*]f32, cChannels: u32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IPerChannelDbLevel.VTable, @ptrCast(self.vtable)).SetLevelAllChannels(@as(*const IPerChannelDbLevel, @ptrCast(self)), aLevelsDB, cChannels, pguidEventContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioVolumeLevel_Value = Guid.initString("7fb7b48f-531d-44a2-bcb3-5ad5a134b3dc");
pub const IID_IAudioVolumeLevel = &IID_IAudioVolumeLevel_Value;
pub const IAudioVolumeLevel = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioChannelConfig_Value = Guid.initString("bb11c46f-ec28-493c-b88a-5db88062ce98");
pub const IID_IAudioChannelConfig = &IID_IAudioChannelConfig_Value;
pub const IAudioChannelConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetChannelConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioChannelConfig,
                dwConfig: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioChannelConfig,
                dwConfig: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioChannelConfig,
                pdwConfig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioChannelConfig,
                pdwConfig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioChannelConfig_SetChannelConfig(self: *const T, dwConfig: u32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioChannelConfig.VTable, @ptrCast(self.vtable)).SetChannelConfig(@as(*const IAudioChannelConfig, @ptrCast(self)), dwConfig, pguidEventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioChannelConfig_GetChannelConfig(self: *const T, pdwConfig: ?*u32) HRESULT {
                return @as(*const IAudioChannelConfig.VTable, @ptrCast(self.vtable)).GetChannelConfig(@as(*const IAudioChannelConfig, @ptrCast(self)), pdwConfig);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioLoudness_Value = Guid.initString("7d8b1437-dd53-4350-9c1b-1ee2890bd938");
pub const IID_IAudioLoudness = &IID_IAudioLoudness_Value;
pub const IAudioLoudness = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioLoudness,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioLoudness,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioLoudness,
                bEnable: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioLoudness,
                bEnable: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioLoudness_GetEnabled(self: *const T, pbEnabled: ?*BOOL) HRESULT {
                return @as(*const IAudioLoudness.VTable, @ptrCast(self.vtable)).GetEnabled(@as(*const IAudioLoudness, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioLoudness_SetEnabled(self: *const T, bEnable: BOOL, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioLoudness.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IAudioLoudness, @ptrCast(self)), bEnable, pguidEventContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioInputSelector_Value = Guid.initString("4f03dc02-5e6e-4653-8f72-a030c123d598");
pub const IID_IAudioInputSelector = &IID_IAudioInputSelector_Value;
pub const IAudioInputSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioInputSelector,
                pnIdSelected: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioInputSelector,
                pnIdSelected: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioInputSelector,
                nIdSelect: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioInputSelector,
                nIdSelect: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioInputSelector_GetSelection(self: *const T, pnIdSelected: ?*u32) HRESULT {
                return @as(*const IAudioInputSelector.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const IAudioInputSelector, @ptrCast(self)), pnIdSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioInputSelector_SetSelection(self: *const T, nIdSelect: u32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioInputSelector.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const IAudioInputSelector, @ptrCast(self)), nIdSelect, pguidEventContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioOutputSelector_Value = Guid.initString("bb515f69-94a7-429e-8b9c-271b3f11a3ab");
pub const IID_IAudioOutputSelector = &IID_IAudioOutputSelector_Value;
pub const IAudioOutputSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioOutputSelector,
                pnIdSelected: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioOutputSelector,
                pnIdSelected: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioOutputSelector,
                nIdSelect: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioOutputSelector,
                nIdSelect: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioOutputSelector_GetSelection(self: *const T, pnIdSelected: ?*u32) HRESULT {
                return @as(*const IAudioOutputSelector.VTable, @ptrCast(self.vtable)).GetSelection(@as(*const IAudioOutputSelector, @ptrCast(self)), pnIdSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioOutputSelector_SetSelection(self: *const T, nIdSelect: u32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioOutputSelector.VTable, @ptrCast(self.vtable)).SetSelection(@as(*const IAudioOutputSelector, @ptrCast(self)), nIdSelect, pguidEventContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMute_Value = Guid.initString("df45aeea-b74a-4b6b-afad-2366b6aa012e");
pub const IID_IAudioMute = &IID_IAudioMute_Value;
pub const IAudioMute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioMute,
                bMuted: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioMute,
                bMuted: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioMute,
                pbMuted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioMute,
                pbMuted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioMute_SetMute(self: *const T, bMuted: BOOL, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioMute.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IAudioMute, @ptrCast(self)), bMuted, pguidEventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioMute_GetMute(self: *const T, pbMuted: ?*BOOL) HRESULT {
                return @as(*const IAudioMute.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IAudioMute, @ptrCast(self)), pbMuted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioBass_Value = Guid.initString("a2b1a1d9-4db3-425d-a2b2-bd335cb3e2e5");
pub const IID_IAudioBass = &IID_IAudioBass_Value;
pub const IAudioBass = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioMidrange_Value = Guid.initString("5e54b6d7-b44b-40d9-9a9e-e691d9ce6edf");
pub const IID_IAudioMidrange = &IID_IAudioMidrange_Value;
pub const IAudioMidrange = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioTreble_Value = Guid.initString("0a717812-694e-4907-b74b-bafa5cfdca7b");
pub const IID_IAudioTreble = &IID_IAudioTreble_Value;
pub const IAudioTreble = extern struct {
    pub const VTable = extern struct {
        base: IPerChannelDbLevel.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPerChannelDbLevel.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioAutoGainControl_Value = Guid.initString("85401fd4-6de4-4b9d-9869-2d6753a82f3c");
pub const IID_IAudioAutoGainControl = &IID_IAudioAutoGainControl_Value;
pub const IAudioAutoGainControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioAutoGainControl,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioAutoGainControl,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioAutoGainControl,
                bEnable: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioAutoGainControl,
                bEnable: BOOL,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioAutoGainControl_GetEnabled(self: *const T, pbEnabled: ?*BOOL) HRESULT {
                return @as(*const IAudioAutoGainControl.VTable, @ptrCast(self.vtable)).GetEnabled(@as(*const IAudioAutoGainControl, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioAutoGainControl_SetEnabled(self: *const T, bEnable: BOOL, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioAutoGainControl.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IAudioAutoGainControl, @ptrCast(self)), bEnable, pguidEventContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioPeakMeter_Value = Guid.initString("dd79923c-0599-45e0-b8b6-c8df7db6e796");
pub const IID_IAudioPeakMeter = &IID_IAudioPeakMeter_Value;
pub const IAudioPeakMeter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioPeakMeter,
                pcChannels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioPeakMeter,
                pcChannels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioPeakMeter,
                nChannel: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioPeakMeter,
                nChannel: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioPeakMeter_GetChannelCount(self: *const T, pcChannels: ?*u32) HRESULT {
                return @as(*const IAudioPeakMeter.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IAudioPeakMeter, @ptrCast(self)), pcChannels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioPeakMeter_GetLevel(self: *const T, nChannel: u32, pfLevel: ?*f32) HRESULT {
                return @as(*const IAudioPeakMeter.VTable, @ptrCast(self.vtable)).GetLevel(@as(*const IAudioPeakMeter, @ptrCast(self)), nChannel, pfLevel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeviceSpecificProperty_Value = Guid.initString("3b22bcbf-2586-4af0-8583-205d391b807c");
pub const IID_IDeviceSpecificProperty = &IID_IDeviceSpecificProperty_Value;
pub const IDeviceSpecificProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceSpecificProperty,
                pVType: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceSpecificProperty,
                pVType: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceSpecificProperty,
                pvValue: ?*anyopaque,
                pcbValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceSpecificProperty,
                pvValue: ?*anyopaque,
                pcbValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceSpecificProperty,
                pvValue: ?*anyopaque,
                cbValue: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceSpecificProperty,
                pvValue: ?*anyopaque,
                cbValue: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Get4BRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceSpecificProperty,
                plMin: ?*i32,
                plMax: ?*i32,
                plStepping: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceSpecificProperty,
                plMin: ?*i32,
                plMax: ?*i32,
                plStepping: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceSpecificProperty_GetType(self: *const T, pVType: ?*u16) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDeviceSpecificProperty, @ptrCast(self)), pVType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceSpecificProperty_GetValue(self: *const T, pvValue: ?*anyopaque, pcbValue: ?*u32) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDeviceSpecificProperty, @ptrCast(self)), pvValue, pcbValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceSpecificProperty_SetValue(self: *const T, pvValue: ?*anyopaque, cbValue: u32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IDeviceSpecificProperty, @ptrCast(self)), pvValue, cbValue, pguidEventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceSpecificProperty_Get4BRange(self: *const T, plMin: ?*i32, plMax: ?*i32, plStepping: ?*i32) HRESULT {
                return @as(*const IDeviceSpecificProperty.VTable, @ptrCast(self.vtable)).Get4BRange(@as(*const IDeviceSpecificProperty, @ptrCast(self)), plMin, plMax, plStepping);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPartsList_Value = Guid.initString("6daa848c-5eb0-45cc-aea5-998a2cda1ffb");
pub const IID_IPartsList = &IID_IPartsList_Value;
pub const IPartsList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPartsList,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPartsList,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPartsList,
                nIndex: u32,
                ppPart: ?*?*IPart,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPartsList,
                nIndex: u32,
                ppPart: ?*?*IPart,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPartsList_GetCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const IPartsList.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IPartsList, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPartsList_GetPart(self: *const T, nIndex: u32, ppPart: ?*?*IPart) HRESULT {
                return @as(*const IPartsList.VTable, @ptrCast(self.vtable)).GetPart(@as(*const IPartsList, @ptrCast(self)), nIndex, ppPart);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPart_Value = Guid.initString("ae2de0e4-5bca-4f2d-aa46-5d13f8fdb3a9");
pub const IID_IPart = &IID_IPart_Value;
pub const IPart = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                ppwstrName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                ppwstrName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocalId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                pnId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                pnId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGlobalId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                ppwstrGlobalId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                ppwstrGlobalId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPartType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                pPartType: ?*PartType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                pPartType: ?*PartType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                pSubType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                pSubType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlInterfaceCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                nIndex: u32,
                ppInterfaceDesc: ?*?*IControlInterface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                nIndex: u32,
                ppInterfaceDesc: ?*?*IControlInterface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumPartsIncoming: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                ppParts: ?*?*IPartsList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                ppParts: ?*?*IPartsList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumPartsOutgoing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                ppParts: ?*?*IPartsList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                ppParts: ?*?*IPartsList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTopologyObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                ppTopology: ?*?*IDeviceTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                ppTopology: ?*?*IDeviceTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                dwClsContext: u32,
                refiid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                dwClsContext: u32,
                refiid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterControlChangeCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                riid: ?*const Guid,
                pNotify: ?*IControlChangeNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                riid: ?*const Guid,
                pNotify: ?*IControlChangeNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterControlChangeCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPart,
                pNotify: ?*IControlChangeNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPart,
                pNotify: ?*IControlChangeNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetName(self: *const T, ppwstrName: ?*?PWSTR) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetName(@as(*const IPart, @ptrCast(self)), ppwstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetLocalId(self: *const T, pnId: ?*u32) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetLocalId(@as(*const IPart, @ptrCast(self)), pnId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetGlobalId(self: *const T, ppwstrGlobalId: ?*?PWSTR) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetGlobalId(@as(*const IPart, @ptrCast(self)), ppwstrGlobalId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetPartType(self: *const T, pPartType: ?*PartType) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetPartType(@as(*const IPart, @ptrCast(self)), pPartType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetSubType(self: *const T, pSubType: ?*Guid) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetSubType(@as(*const IPart, @ptrCast(self)), pSubType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetControlInterfaceCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetControlInterfaceCount(@as(*const IPart, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetControlInterface(self: *const T, nIndex: u32, ppInterfaceDesc: ?*?*IControlInterface) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetControlInterface(@as(*const IPart, @ptrCast(self)), nIndex, ppInterfaceDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_EnumPartsIncoming(self: *const T, ppParts: ?*?*IPartsList) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).EnumPartsIncoming(@as(*const IPart, @ptrCast(self)), ppParts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_EnumPartsOutgoing(self: *const T, ppParts: ?*?*IPartsList) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).EnumPartsOutgoing(@as(*const IPart, @ptrCast(self)), ppParts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_GetTopologyObject(self: *const T, ppTopology: ?*?*IDeviceTopology) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).GetTopologyObject(@as(*const IPart, @ptrCast(self)), ppTopology);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_Activate(self: *const T, dwClsContext: u32, refiid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).Activate(@as(*const IPart, @ptrCast(self)), dwClsContext, refiid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_RegisterControlChangeCallback(self: *const T, riid: ?*const Guid, pNotify: ?*IControlChangeNotify) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).RegisterControlChangeCallback(@as(*const IPart, @ptrCast(self)), riid, pNotify);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPart_UnregisterControlChangeCallback(self: *const T, pNotify: ?*IControlChangeNotify) HRESULT {
                return @as(*const IPart.VTable, @ptrCast(self.vtable)).UnregisterControlChangeCallback(@as(*const IPart, @ptrCast(self)), pNotify);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConnector_Value = Guid.initString("9c2c4058-23f5-41de-877a-df3af236a09e");
pub const IID_IConnector = &IID_IConnector_Value;
pub const IConnector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                pType: ?*ConnectorType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                pType: ?*ConnectorType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataFlow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                pFlow: ?*DataFlow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                pFlow: ?*DataFlow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                pConnectTo: ?*IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                pConnectTo: ?*IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                pbConnected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                pbConnected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                ppConTo: ?*?*IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                ppConTo: ?*?*IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectorIdConnectedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                ppwstrConnectorId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                ppwstrConnectorId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceIdConnectedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnector,
                ppwstrDeviceId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnector,
                ppwstrDeviceId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_GetType(self: *const T, pType: ?*ConnectorType) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetType(@as(*const IConnector, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_GetDataFlow(self: *const T, pFlow: ?*DataFlow) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetDataFlow(@as(*const IConnector, @ptrCast(self)), pFlow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_ConnectTo(self: *const T, pConnectTo: ?*IConnector) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).ConnectTo(@as(*const IConnector, @ptrCast(self)), pConnectTo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_Disconnect(self: *const T) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IConnector, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_IsConnected(self: *const T, pbConnected: ?*BOOL) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).IsConnected(@as(*const IConnector, @ptrCast(self)), pbConnected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_GetConnectedTo(self: *const T, ppConTo: ?*?*IConnector) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetConnectedTo(@as(*const IConnector, @ptrCast(self)), ppConTo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_GetConnectorIdConnectedTo(self: *const T, ppwstrConnectorId: ?*?PWSTR) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetConnectorIdConnectedTo(@as(*const IConnector, @ptrCast(self)), ppwstrConnectorId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnector_GetDeviceIdConnectedTo(self: *const T, ppwstrDeviceId: ?*?PWSTR) HRESULT {
                return @as(*const IConnector.VTable, @ptrCast(self.vtable)).GetDeviceIdConnectedTo(@as(*const IConnector, @ptrCast(self)), ppwstrDeviceId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISubunit_Value = Guid.initString("82149a85-dba6-4487-86bb-ea8f7fefcc71");
pub const IID_ISubunit = &IID_ISubunit_Value;
pub const ISubunit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlInterface_Value = Guid.initString("45d37c3f-5140-444a-ae24-400789f3cbf3");
pub const IID_IControlInterface = &IID_IControlInterface_Value;
pub const IControlInterface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IControlInterface,
                ppwstrName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IControlInterface,
                ppwstrName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IControlInterface,
                pIID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IControlInterface,
                pIID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IControlInterface_GetName(self: *const T, ppwstrName: ?*?PWSTR) HRESULT {
                return @as(*const IControlInterface.VTable, @ptrCast(self.vtable)).GetName(@as(*const IControlInterface, @ptrCast(self)), ppwstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IControlInterface_GetIID(self: *const T, pIID: ?*Guid) HRESULT {
                return @as(*const IControlInterface.VTable, @ptrCast(self.vtable)).GetIID(@as(*const IControlInterface, @ptrCast(self)), pIID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlChangeNotify_Value = Guid.initString("a09513ed-c709-4d21-bd7b-5f34c47f3947");
pub const IID_IControlChangeNotify = &IID_IControlChangeNotify_Value;
pub const IControlChangeNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IControlChangeNotify,
                dwSenderProcessId: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IControlChangeNotify,
                dwSenderProcessId: u32,
                pguidEventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IControlChangeNotify_OnNotify(self: *const T, dwSenderProcessId: u32, pguidEventContext: ?*const Guid) HRESULT {
                return @as(*const IControlChangeNotify.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IControlChangeNotify, @ptrCast(self)), dwSenderProcessId, pguidEventContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDeviceTopology_Value = Guid.initString("2a07407e-6497-4a18-9787-32f79bd0d98f");
pub const IID_IDeviceTopology = &IID_IDeviceTopology_Value;
pub const IDeviceTopology = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectorCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnector: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                nIndex: u32,
                ppConnector: ?*?*IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                nIndex: u32,
                ppConnector: ?*?*IConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubunitCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubunit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                nIndex: u32,
                ppSubunit: ?*?*ISubunit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                nIndex: u32,
                ppSubunit: ?*?*ISubunit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPartById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                nId: u32,
                ppPart: ?*?*IPart,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                nId: u32,
                ppPart: ?*?*IPart,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                ppwstrDeviceId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                ppwstrDeviceId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSignalPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDeviceTopology,
                pIPartFrom: ?*IPart,
                pIPartTo: ?*IPart,
                bRejectMixedPaths: BOOL,
                ppParts: ?*?*IPartsList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDeviceTopology,
                pIPartFrom: ?*IPart,
                pIPartTo: ?*IPart,
                bRejectMixedPaths: BOOL,
                ppParts: ?*?*IPartsList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetConnectorCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetConnectorCount(@as(*const IDeviceTopology, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetConnector(self: *const T, nIndex: u32, ppConnector: ?*?*IConnector) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetConnector(@as(*const IDeviceTopology, @ptrCast(self)), nIndex, ppConnector);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetSubunitCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetSubunitCount(@as(*const IDeviceTopology, @ptrCast(self)), pCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetSubunit(self: *const T, nIndex: u32, ppSubunit: ?*?*ISubunit) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetSubunit(@as(*const IDeviceTopology, @ptrCast(self)), nIndex, ppSubunit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetPartById(self: *const T, nId: u32, ppPart: ?*?*IPart) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetPartById(@as(*const IDeviceTopology, @ptrCast(self)), nId, ppPart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetDeviceId(self: *const T, ppwstrDeviceId: ?*?PWSTR) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetDeviceId(@as(*const IDeviceTopology, @ptrCast(self)), ppwstrDeviceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDeviceTopology_GetSignalPath(self: *const T, pIPartFrom: ?*IPart, pIPartTo: ?*IPart, bRejectMixedPaths: BOOL, ppParts: ?*?*IPartsList) HRESULT {
                return @as(*const IDeviceTopology.VTable, @ptrCast(self.vtable)).GetSignalPath(@as(*const IDeviceTopology, @ptrCast(self)), pIPartFrom, pIPartTo, bRejectMixedPaths, ppParts);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AudioSessionDisconnectReason = enum(i32) {
    DeviceRemoval = 0,
    ServerShutdown = 1,
    FormatChanged = 2,
    SessionLogoff = 3,
    SessionDisconnected = 4,
    ExclusiveModeOverride = 5,
};
pub const DisconnectReasonDeviceRemoval = AudioSessionDisconnectReason.DeviceRemoval;
pub const DisconnectReasonServerShutdown = AudioSessionDisconnectReason.ServerShutdown;
pub const DisconnectReasonFormatChanged = AudioSessionDisconnectReason.FormatChanged;
pub const DisconnectReasonSessionLogoff = AudioSessionDisconnectReason.SessionLogoff;
pub const DisconnectReasonSessionDisconnected = AudioSessionDisconnectReason.SessionDisconnected;
pub const DisconnectReasonExclusiveModeOverride = AudioSessionDisconnectReason.ExclusiveModeOverride;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionEvents_Value = Guid.initString("24918acc-64b3-37c1-8ca9-74a66e9957a8");
pub const IID_IAudioSessionEvents = &IID_IAudioSessionEvents_Value;
pub const IAudioSessionEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDisplayNameChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                NewDisplayName: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                NewDisplayName: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnIconPathChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                NewIconPath: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                NewIconPath: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSimpleVolumeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                NewVolume: f32,
                NewMute: BOOL,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                NewVolume: f32,
                NewMute: BOOL,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChannelVolumeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                ChannelCount: u32,
                NewChannelVolumeArray: [*]f32,
                ChangedChannel: u32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                ChannelCount: u32,
                NewChannelVolumeArray: [*]f32,
                ChangedChannel: u32,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnGroupingParamChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                NewGroupingParam: ?*const Guid,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                NewGroupingParam: ?*const Guid,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                NewState: AudioSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                NewState: AudioSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSessionDisconnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEvents,
                DisconnectReason: AudioSessionDisconnectReason,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEvents,
                DisconnectReason: AudioSessionDisconnectReason,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnDisplayNameChanged(self: *const T, NewDisplayName: ?[*:0]const u16, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnDisplayNameChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), NewDisplayName, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnIconPathChanged(self: *const T, NewIconPath: ?[*:0]const u16, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnIconPathChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), NewIconPath, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnSimpleVolumeChanged(self: *const T, NewVolume: f32, NewMute: BOOL, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnSimpleVolumeChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), NewVolume, NewMute, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnChannelVolumeChanged(self: *const T, ChannelCount: u32, NewChannelVolumeArray: [*]f32, ChangedChannel: u32, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnChannelVolumeChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), ChannelCount, NewChannelVolumeArray, ChangedChannel, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnGroupingParamChanged(self: *const T, NewGroupingParam: ?*const Guid, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnGroupingParamChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), NewGroupingParam, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnStateChanged(self: *const T, NewState: AudioSessionState) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnStateChanged(@as(*const IAudioSessionEvents, @ptrCast(self)), NewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEvents_OnSessionDisconnected(self: *const T, DisconnectReason: AudioSessionDisconnectReason) HRESULT {
                return @as(*const IAudioSessionEvents.VTable, @ptrCast(self.vtable)).OnSessionDisconnected(@as(*const IAudioSessionEvents, @ptrCast(self)), DisconnectReason);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionControl_Value = Guid.initString("f4b1a599-7266-4319-a8ca-e70acb11e8cd");
pub const IID_IAudioSessionControl = &IID_IAudioSessionControl_Value;
pub const IAudioSessionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*AudioSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*AudioSessionState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                Value: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                Value: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                Value: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                Value: ?[*:0]const u16,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupingParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                pRetVal: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGroupingParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                Override: ?*const Guid,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                Override: ?*const Guid,
                EventContext: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterAudioSessionNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                NewNotifications: ?*IAudioSessionEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                NewNotifications: ?*IAudioSessionEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterAudioSessionNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl,
                NewNotifications: ?*IAudioSessionEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl,
                NewNotifications: ?*IAudioSessionEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_GetState(self: *const T, pRetVal: ?*AudioSessionState) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetState(@as(*const IAudioSessionControl, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_GetDisplayName(self: *const T, pRetVal: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IAudioSessionControl, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_SetDisplayName(self: *const T, Value: ?[*:0]const u16, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).SetDisplayName(@as(*const IAudioSessionControl, @ptrCast(self)), Value, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_GetIconPath(self: *const T, pRetVal: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetIconPath(@as(*const IAudioSessionControl, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_SetIconPath(self: *const T, Value: ?[*:0]const u16, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).SetIconPath(@as(*const IAudioSessionControl, @ptrCast(self)), Value, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_GetGroupingParam(self: *const T, pRetVal: ?*Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).GetGroupingParam(@as(*const IAudioSessionControl, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_SetGroupingParam(self: *const T, Override: ?*const Guid, EventContext: ?*const Guid) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).SetGroupingParam(@as(*const IAudioSessionControl, @ptrCast(self)), Override, EventContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_RegisterAudioSessionNotification(self: *const T, NewNotifications: ?*IAudioSessionEvents) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).RegisterAudioSessionNotification(@as(*const IAudioSessionControl, @ptrCast(self)), NewNotifications);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl_UnregisterAudioSessionNotification(self: *const T, NewNotifications: ?*IAudioSessionEvents) HRESULT {
                return @as(*const IAudioSessionControl.VTable, @ptrCast(self.vtable)).UnregisterAudioSessionNotification(@as(*const IAudioSessionControl, @ptrCast(self)), NewNotifications);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionControl2_Value = Guid.initString("bfb7ff88-7239-4fc9-8fa2-07c950be9c6d");
pub const IID_IAudioSessionControl2 = &IID_IAudioSessionControl2_Value;
pub const IAudioSessionControl2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSessionControl.VTable,
        GetSessionIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl2,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl2,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSessionInstanceIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl2,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl2,
                pRetVal: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl2,
                pRetVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl2,
                pRetVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSystemSoundsSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDuckingPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionControl2,
                optOut: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionControl2,
                optOut: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioSessionControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl2_GetSessionIdentifier(self: *const T, pRetVal: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).GetSessionIdentifier(@as(*const IAudioSessionControl2, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl2_GetSessionInstanceIdentifier(self: *const T, pRetVal: ?*?PWSTR) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).GetSessionInstanceIdentifier(@as(*const IAudioSessionControl2, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl2_GetProcessId(self: *const T, pRetVal: ?*u32) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).GetProcessId(@as(*const IAudioSessionControl2, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl2_IsSystemSoundsSession(self: *const T) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).IsSystemSoundsSession(@as(*const IAudioSessionControl2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionControl2_SetDuckingPreference(self: *const T, optOut: BOOL) HRESULT {
                return @as(*const IAudioSessionControl2.VTable, @ptrCast(self.vtable)).SetDuckingPreference(@as(*const IAudioSessionControl2, @ptrCast(self)), optOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAudioSessionManager_Value = Guid.initString("bfa971f1-4d5e-40bb-935e-967039bfbee4");
pub const IID_IAudioSessionManager = &IID_IAudioSessionManager_Value;
pub const IAudioSessionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAudioSessionControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager,
                AudioSessionGuid: ?*const Guid,
                StreamFlags: u32,
                SessionControl: ?*?*IAudioSessionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager,
                AudioSessionGuid: ?*const Guid,
                StreamFlags: u32,
                SessionControl: ?*?*IAudioSessionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSimpleAudioVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager,
                AudioSessionGuid: ?*const Guid,
                StreamFlags: u32,
                AudioVolume: ?*?*ISimpleAudioVolume,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager,
                AudioSessionGuid: ?*const Guid,
                StreamFlags: u32,
                AudioVolume: ?*?*ISimpleAudioVolume,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager_GetAudioSessionControl(self: *const T, AudioSessionGuid: ?*const Guid, StreamFlags: u32, SessionControl: ?*?*IAudioSessionControl) HRESULT {
                return @as(*const IAudioSessionManager.VTable, @ptrCast(self.vtable)).GetAudioSessionControl(@as(*const IAudioSessionManager, @ptrCast(self)), AudioSessionGuid, StreamFlags, SessionControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager_GetSimpleAudioVolume(self: *const T, AudioSessionGuid: ?*const Guid, StreamFlags: u32, AudioVolume: ?*?*ISimpleAudioVolume) HRESULT {
                return @as(*const IAudioSessionManager.VTable, @ptrCast(self.vtable)).GetSimpleAudioVolume(@as(*const IAudioSessionManager, @ptrCast(self)), AudioSessionGuid, StreamFlags, AudioVolume);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioVolumeDuckNotification_Value = Guid.initString("c3b284d4-6d39-4359-b3cf-b56ddb3bb39c");
pub const IID_IAudioVolumeDuckNotification = &IID_IAudioVolumeDuckNotification_Value;
pub const IAudioVolumeDuckNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnVolumeDuckNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioVolumeDuckNotification,
                sessionID: ?[*:0]const u16,
                countCommunicationSessions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioVolumeDuckNotification,
                sessionID: ?[*:0]const u16,
                countCommunicationSessions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnVolumeUnduckNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioVolumeDuckNotification,
                sessionID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioVolumeDuckNotification,
                sessionID: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioVolumeDuckNotification_OnVolumeDuckNotification(self: *const T, sessionID: ?[*:0]const u16, countCommunicationSessions: u32) HRESULT {
                return @as(*const IAudioVolumeDuckNotification.VTable, @ptrCast(self.vtable)).OnVolumeDuckNotification(@as(*const IAudioVolumeDuckNotification, @ptrCast(self)), sessionID, countCommunicationSessions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioVolumeDuckNotification_OnVolumeUnduckNotification(self: *const T, sessionID: ?[*:0]const u16) HRESULT {
                return @as(*const IAudioVolumeDuckNotification.VTable, @ptrCast(self.vtable)).OnVolumeUnduckNotification(@as(*const IAudioVolumeDuckNotification, @ptrCast(self)), sessionID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionNotification_Value = Guid.initString("641dd20b-4d41-49cc-aba3-174b9477bb08");
pub const IID_IAudioSessionNotification = &IID_IAudioSessionNotification_Value;
pub const IAudioSessionNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSessionCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionNotification,
                NewSession: ?*IAudioSessionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionNotification,
                NewSession: ?*IAudioSessionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionNotification_OnSessionCreated(self: *const T, NewSession: ?*IAudioSessionControl) HRESULT {
                return @as(*const IAudioSessionNotification.VTable, @ptrCast(self.vtable)).OnSessionCreated(@as(*const IAudioSessionNotification, @ptrCast(self)), NewSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionEnumerator_Value = Guid.initString("e2f5bb11-0570-40ca-acdd-3aa01277dee8");
pub const IID_IAudioSessionEnumerator = &IID_IAudioSessionEnumerator_Value;
pub const IAudioSessionEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEnumerator,
                SessionCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEnumerator,
                SessionCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionEnumerator,
                SessionCount: i32,
                Session: ?*?*IAudioSessionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionEnumerator,
                SessionCount: i32,
                Session: ?*?*IAudioSessionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEnumerator_GetCount(self: *const T, SessionCount: ?*i32) HRESULT {
                return @as(*const IAudioSessionEnumerator.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IAudioSessionEnumerator, @ptrCast(self)), SessionCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionEnumerator_GetSession(self: *const T, SessionCount: i32, Session: ?*?*IAudioSessionControl) HRESULT {
                return @as(*const IAudioSessionEnumerator.VTable, @ptrCast(self.vtable)).GetSession(@as(*const IAudioSessionEnumerator, @ptrCast(self)), SessionCount, Session);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAudioSessionManager2_Value = Guid.initString("77aa99a0-1bd6-484f-8bc7-2c654c9a9b6f");
pub const IID_IAudioSessionManager2 = &IID_IAudioSessionManager2_Value;
pub const IAudioSessionManager2 = extern struct {
    pub const VTable = extern struct {
        base: IAudioSessionManager.VTable,
        GetSessionEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager2,
                SessionEnum: ?*?*IAudioSessionEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager2,
                SessionEnum: ?*?*IAudioSessionEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterSessionNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager2,
                SessionNotification: ?*IAudioSessionNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager2,
                SessionNotification: ?*IAudioSessionNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterSessionNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager2,
                SessionNotification: ?*IAudioSessionNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager2,
                SessionNotification: ?*IAudioSessionNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterDuckNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager2,
                sessionID: ?[*:0]const u16,
                duckNotification: ?*IAudioVolumeDuckNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager2,
                sessionID: ?[*:0]const u16,
                duckNotification: ?*IAudioVolumeDuckNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterDuckNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSessionManager2,
                duckNotification: ?*IAudioVolumeDuckNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSessionManager2,
                duckNotification: ?*IAudioVolumeDuckNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAudioSessionManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager2_GetSessionEnumerator(self: *const T, SessionEnum: ?*?*IAudioSessionEnumerator) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).GetSessionEnumerator(@as(*const IAudioSessionManager2, @ptrCast(self)), SessionEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager2_RegisterSessionNotification(self: *const T, SessionNotification: ?*IAudioSessionNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).RegisterSessionNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), SessionNotification);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager2_UnregisterSessionNotification(self: *const T, SessionNotification: ?*IAudioSessionNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).UnregisterSessionNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), SessionNotification);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager2_RegisterDuckNotification(self: *const T, sessionID: ?[*:0]const u16, duckNotification: ?*IAudioVolumeDuckNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).RegisterDuckNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), sessionID, duckNotification);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSessionManager2_UnregisterDuckNotification(self: *const T, duckNotification: ?*IAudioVolumeDuckNotification) HRESULT {
                return @as(*const IAudioSessionManager2.VTable, @ptrCast(self.vtable)).UnregisterDuckNotification(@as(*const IAudioSessionManager2, @ptrCast(self)), duckNotification);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SpatialAudioMetadataWriterOverflowMode = enum(i32) {
    Fail = 0,
    MergeWithNew = 1,
    MergeWithLast = 2,
};
pub const SpatialAudioMetadataWriterOverflow_Fail = SpatialAudioMetadataWriterOverflowMode.Fail;
pub const SpatialAudioMetadataWriterOverflow_MergeWithNew = SpatialAudioMetadataWriterOverflowMode.MergeWithNew;
pub const SpatialAudioMetadataWriterOverflow_MergeWithLast = SpatialAudioMetadataWriterOverflowMode.MergeWithLast;

pub const SpatialAudioMetadataCopyMode = enum(i32) {
    Overwrite = 0,
    Append = 1,
    AppendMergeWithLast = 2,
    AppendMergeWithFirst = 3,
};
pub const SpatialAudioMetadataCopy_Overwrite = SpatialAudioMetadataCopyMode.Overwrite;
pub const SpatialAudioMetadataCopy_Append = SpatialAudioMetadataCopyMode.Append;
pub const SpatialAudioMetadataCopy_AppendMergeWithLast = SpatialAudioMetadataCopyMode.AppendMergeWithLast;
pub const SpatialAudioMetadataCopy_AppendMergeWithFirst = SpatialAudioMetadataCopyMode.AppendMergeWithFirst;

pub const SpatialAudioMetadataItemsInfo = extern struct {
    FrameCount: u16 align(1),
    ItemCount: u16 align(1),
    MaxItemCount: u16 align(1),
    MaxValueBufferLength: u32 align(1),
};

pub const SpatialAudioObjectRenderStreamForMetadataActivationParams = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    MetadataFormatId: Guid align(1),
    MaxMetadataItemCount: u16 align(1),
    MetadataActivationParams: ?*const PROPVARIANT align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
};

pub const SpatialAudioObjectRenderStreamForMetadataActivationParams2 = extern struct {
    ObjectFormat: ?*const WAVEFORMATEX align(1),
    StaticObjectTypeMask: AudioObjectType align(1),
    MinDynamicObjectCount: u32 align(1),
    MaxDynamicObjectCount: u32 align(1),
    Category: AUDIO_STREAM_CATEGORY align(1),
    EventHandle: ?HANDLE align(1),
    MetadataFormatId: Guid align(1),
    MaxMetadataItemCount: u32 align(1),
    MetadataActivationParams: ?*const PROPVARIANT align(1),
    NotifyObject: ?*ISpatialAudioObjectRenderStreamNotify align(1),
    Options: SPATIAL_AUDIO_STREAM_OPTIONS align(1),
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataItems_Value = Guid.initString("bcd7c78f-3098-4f22-b547-a2f25a381269");
pub const IID_ISpatialAudioMetadataItems = &IID_ISpatialAudioMetadataItems_Value;
pub const ISpatialAudioMetadataItems = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItems,
                frameCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItems,
                frameCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItems,
                itemCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItems,
                itemCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItems,
                maxItemCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItems,
                maxItemCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxValueBufferLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItems,
                maxValueBufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItems,
                maxValueBufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItems,
                info: ?*SpatialAudioMetadataItemsInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItems,
                info: ?*SpatialAudioMetadataItemsInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItems_GetFrameCount(self: *const T, frameCount: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetFrameCount(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), frameCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItems_GetItemCount(self: *const T, itemCount: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetItemCount(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), itemCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItems_GetMaxItemCount(self: *const T, maxItemCount: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetMaxItemCount(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), maxItemCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItems_GetMaxValueBufferLength(self: *const T, maxValueBufferLength: ?*u32) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetMaxValueBufferLength(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), maxValueBufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItems_GetInfo(self: *const T, info: ?*SpatialAudioMetadataItemsInfo) HRESULT {
                return @as(*const ISpatialAudioMetadataItems.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const ISpatialAudioMetadataItems, @ptrCast(self)), info);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataWriter_Value = Guid.initString("1b17ca01-2955-444d-a430-537dc589a844");
pub const IID_ISpatialAudioMetadataWriter = &IID_ISpatialAudioMetadataWriter_Value;
pub const ISpatialAudioMetadataWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataWriter,
                metadataItems: ?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataWriter,
                metadataItems: ?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteNextItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataWriter,
                frameOffset: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataWriter,
                frameOffset: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteNextItemCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataWriter,
                commandID: u8,
                // TODO: what to do with BytesParamIndex 2?
                valueBuffer: ?*const anyopaque,
                valueBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataWriter,
                commandID: u8,
                // TODO: what to do with BytesParamIndex 2?
                valueBuffer: ?*const anyopaque,
                valueBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataWriter_Open(self: *const T, metadataItems: ?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)), metadataItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataWriter_WriteNextItem(self: *const T, frameOffset: u16) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).WriteNextItem(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)), frameOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataWriter_WriteNextItemCommand(self: *const T, commandID: u8, valueBuffer: ?*const anyopaque, valueBufferLength: u32) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).WriteNextItemCommand(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)), commandID, valueBuffer, valueBufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataWriter_Close(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataWriter.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpatialAudioMetadataWriter, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataReader_Value = Guid.initString("b78e86a2-31d9-4c32-94d2-7df40fc7ebec");
pub const IID_ISpatialAudioMetadataReader = &IID_ISpatialAudioMetadataReader_Value;
pub const ISpatialAudioMetadataReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataReader,
                metadataItems: ?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataReader,
                metadataItems: ?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadNextItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataReader,
                commandCount: ?*u8,
                frameOffset: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataReader,
                commandCount: ?*u8,
                frameOffset: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadNextItemCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataReader,
                commandID: ?*u8,
                // TODO: what to do with BytesParamIndex 2?
                valueBuffer: ?*anyopaque,
                maxValueBufferLength: u32,
                valueBufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataReader,
                commandID: ?*u8,
                // TODO: what to do with BytesParamIndex 2?
                valueBuffer: ?*anyopaque,
                maxValueBufferLength: u32,
                valueBufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataReader_Open(self: *const T, metadataItems: ?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)), metadataItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataReader_ReadNextItem(self: *const T, commandCount: ?*u8, frameOffset: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).ReadNextItem(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)), commandCount, frameOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataReader_ReadNextItemCommand(self: *const T, commandID: ?*u8, valueBuffer: ?*anyopaque, maxValueBufferLength: u32, valueBufferLength: ?*u32) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).ReadNextItemCommand(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)), commandID, valueBuffer, maxValueBufferLength, valueBufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataReader_Close(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataReader.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpatialAudioMetadataReader, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataCopier_Value = Guid.initString("d224b233-e251-4fd0-9ca2-d5ecf9a68404");
pub const IID_ISpatialAudioMetadataCopier = &IID_ISpatialAudioMetadataCopier_Value;
pub const ISpatialAudioMetadataCopier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataCopier,
                metadataItems: ?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataCopier,
                metadataItems: ?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyMetadataForFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataCopier,
                copyFrameCount: u16,
                copyMode: SpatialAudioMetadataCopyMode,
                dstMetadataItems: ?*ISpatialAudioMetadataItems,
                itemsCopied: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataCopier,
                copyFrameCount: u16,
                copyMode: SpatialAudioMetadataCopyMode,
                dstMetadataItems: ?*ISpatialAudioMetadataItems,
                itemsCopied: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataCopier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataCopier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataCopier_Open(self: *const T, metadataItems: ?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataCopier.VTable, @ptrCast(self.vtable)).Open(@as(*const ISpatialAudioMetadataCopier, @ptrCast(self)), metadataItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataCopier_CopyMetadataForFrames(self: *const T, copyFrameCount: u16, copyMode: SpatialAudioMetadataCopyMode, dstMetadataItems: ?*ISpatialAudioMetadataItems, itemsCopied: ?*u16) HRESULT {
                return @as(*const ISpatialAudioMetadataCopier.VTable, @ptrCast(self.vtable)).CopyMetadataForFrames(@as(*const ISpatialAudioMetadataCopier, @ptrCast(self)), copyFrameCount, copyMode, dstMetadataItems, itemsCopied);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataCopier_Close(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataCopier.VTable, @ptrCast(self.vtable)).Close(@as(*const ISpatialAudioMetadataCopier, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataItemsBuffer_Value = Guid.initString("42640a16-e1bd-42d9-9ff6-031ab71a2dba");
pub const IID_ISpatialAudioMetadataItemsBuffer = &IID_ISpatialAudioMetadataItemsBuffer_Value;
pub const ISpatialAudioMetadataItemsBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachToBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItemsBuffer,
                // TODO: what to do with BytesParamIndex 1?
                buffer: ?*u8,
                bufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItemsBuffer,
                // TODO: what to do with BytesParamIndex 1?
                buffer: ?*u8,
                bufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachToPopulatedBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItemsBuffer,
                // TODO: what to do with BytesParamIndex 1?
                buffer: ?*u8,
                bufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItemsBuffer,
                // TODO: what to do with BytesParamIndex 1?
                buffer: ?*u8,
                bufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataItemsBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataItemsBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItemsBuffer_AttachToBuffer(self: *const T, buffer: ?*u8, bufferLength: u32) HRESULT {
                return @as(*const ISpatialAudioMetadataItemsBuffer.VTable, @ptrCast(self.vtable)).AttachToBuffer(@as(*const ISpatialAudioMetadataItemsBuffer, @ptrCast(self)), buffer, bufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItemsBuffer_AttachToPopulatedBuffer(self: *const T, buffer: ?*u8, bufferLength: u32) HRESULT {
                return @as(*const ISpatialAudioMetadataItemsBuffer.VTable, @ptrCast(self.vtable)).AttachToPopulatedBuffer(@as(*const ISpatialAudioMetadataItemsBuffer, @ptrCast(self)), buffer, bufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataItemsBuffer_DetachBuffer(self: *const T) HRESULT {
                return @as(*const ISpatialAudioMetadataItemsBuffer.VTable, @ptrCast(self.vtable)).DetachBuffer(@as(*const ISpatialAudioMetadataItemsBuffer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioMetadataClient_Value = Guid.initString("777d4a3b-f6ff-4a26-85dc-68d7cdeda1d4");
pub const IID_ISpatialAudioMetadataClient = &IID_ISpatialAudioMetadataClient_Value;
pub const ISpatialAudioMetadataClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ActivateSpatialAudioMetadataItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataClient,
                maxItemCount: u16,
                frameCount: u16,
                metadataItemsBuffer: ?*?*ISpatialAudioMetadataItemsBuffer,
                metadataItems: ?*?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataClient,
                maxItemCount: u16,
                frameCount: u16,
                metadataItemsBuffer: ?*?*ISpatialAudioMetadataItemsBuffer,
                metadataItems: ?*?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpatialAudioMetadataItemsBufferLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataClient,
                maxItemCount: u16,
                bufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataClient,
                maxItemCount: u16,
                bufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateSpatialAudioMetadataWriter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataClient,
                overflowMode: SpatialAudioMetadataWriterOverflowMode,
                metadataWriter: ?*?*ISpatialAudioMetadataWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataClient,
                overflowMode: SpatialAudioMetadataWriterOverflowMode,
                metadataWriter: ?*?*ISpatialAudioMetadataWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateSpatialAudioMetadataCopier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataClient,
                metadataCopier: ?*?*ISpatialAudioMetadataCopier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataClient,
                metadataCopier: ?*?*ISpatialAudioMetadataCopier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateSpatialAudioMetadataReader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioMetadataClient,
                metadataReader: ?*?*ISpatialAudioMetadataReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioMetadataClient,
                metadataReader: ?*?*ISpatialAudioMetadataReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataItems(self: *const T, maxItemCount: u16, frameCount: u16, metadataItemsBuffer: ?*?*ISpatialAudioMetadataItemsBuffer, metadataItems: ?*?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataItems(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), maxItemCount, frameCount, metadataItemsBuffer, metadataItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataClient_GetSpatialAudioMetadataItemsBufferLength(self: *const T, maxItemCount: u16, bufferLength: ?*u32) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).GetSpatialAudioMetadataItemsBufferLength(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), maxItemCount, bufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataWriter(self: *const T, overflowMode: SpatialAudioMetadataWriterOverflowMode, metadataWriter: ?*?*ISpatialAudioMetadataWriter) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataWriter(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), overflowMode, metadataWriter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataCopier(self: *const T, metadataCopier: ?*?*ISpatialAudioMetadataCopier) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataCopier(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), metadataCopier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioMetadataClient_ActivateSpatialAudioMetadataReader(self: *const T, metadataReader: ?*?*ISpatialAudioMetadataReader) HRESULT {
                return @as(*const ISpatialAudioMetadataClient.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioMetadataReader(@as(*const ISpatialAudioMetadataClient, @ptrCast(self)), metadataReader);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForMetadataCommands_Value = Guid.initString("0df2c94b-f5f9-472d-af6b-c46e0ac9cd05");
pub const IID_ISpatialAudioObjectForMetadataCommands = &IID_ISpatialAudioObjectForMetadataCommands_Value;
pub const ISpatialAudioObjectForMetadataCommands = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        WriteNextMetadataCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForMetadataCommands,
                commandID: u8,
                // TODO: what to do with BytesParamIndex 2?
                valueBuffer: ?*anyopaque,
                valueBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForMetadataCommands,
                commandID: u8,
                // TODO: what to do with BytesParamIndex 2?
                valueBuffer: ?*anyopaque,
                valueBufferLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForMetadataCommands_WriteNextMetadataCommand(self: *const T, commandID: u8, valueBuffer: ?*anyopaque, valueBufferLength: u32) HRESULT {
                return @as(*const ISpatialAudioObjectForMetadataCommands.VTable, @ptrCast(self.vtable)).WriteNextMetadataCommand(@as(*const ISpatialAudioObjectForMetadataCommands, @ptrCast(self)), commandID, valueBuffer, valueBufferLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectForMetadataItems_Value = Guid.initString("ddea49ff-3bc0-4377-8aad-9fbcfd808566");
pub const IID_ISpatialAudioObjectForMetadataItems = &IID_ISpatialAudioObjectForMetadataItems_Value;
pub const ISpatialAudioObjectForMetadataItems = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectBase.VTable,
        GetSpatialAudioMetadataItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectForMetadataItems,
                metadataItems: ?*?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectForMetadataItems,
                metadataItems: ?*?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectForMetadataItems_GetSpatialAudioMetadataItems(self: *const T, metadataItems: ?*?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const ISpatialAudioObjectForMetadataItems.VTable, @ptrCast(self.vtable)).GetSpatialAudioMetadataItems(@as(*const ISpatialAudioObjectForMetadataItems, @ptrCast(self)), metadataItems);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_ISpatialAudioObjectRenderStreamForMetadata_Value = Guid.initString("bbc9c907-48d5-4a2e-a0c7-f7f0d67c1fb1");
pub const IID_ISpatialAudioObjectRenderStreamForMetadata = &IID_ISpatialAudioObjectRenderStreamForMetadata_Value;
pub const ISpatialAudioObjectRenderStreamForMetadata = extern struct {
    pub const VTable = extern struct {
        base: ISpatialAudioObjectRenderStreamBase.VTable,
        ActivateSpatialAudioObjectForMetadataCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamForMetadata,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObjectForMetadataCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamForMetadata,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObjectForMetadataCommands,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateSpatialAudioObjectForMetadataItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISpatialAudioObjectRenderStreamForMetadata,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObjectForMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISpatialAudioObjectRenderStreamForMetadata,
                type: AudioObjectType,
                audioObject: ?*?*ISpatialAudioObjectForMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISpatialAudioObjectRenderStreamBase.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamForMetadata_ActivateSpatialAudioObjectForMetadataCommands(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObjectForMetadataCommands) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamForMetadata.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObjectForMetadataCommands(@as(*const ISpatialAudioObjectRenderStreamForMetadata, @ptrCast(self)), type_, audioObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISpatialAudioObjectRenderStreamForMetadata_ActivateSpatialAudioObjectForMetadataItems(self: *const T, type_: AudioObjectType, audioObject: ?*?*ISpatialAudioObjectForMetadataItems) HRESULT {
                return @as(*const ISpatialAudioObjectRenderStreamForMetadata.VTable, @ptrCast(self.vtable)).ActivateSpatialAudioObjectForMetadataItems(@as(*const ISpatialAudioObjectRenderStreamForMetadata, @ptrCast(self)), type_, audioObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROCESS_LOOPBACK_MODE = enum(i32) {
    INCLUDE_TARGET_PROCESS_TREE = 0,
    EXCLUDE_TARGET_PROCESS_TREE = 1,
};
pub const PROCESS_LOOPBACK_MODE_INCLUDE_TARGET_PROCESS_TREE = PROCESS_LOOPBACK_MODE.INCLUDE_TARGET_PROCESS_TREE;
pub const PROCESS_LOOPBACK_MODE_EXCLUDE_TARGET_PROCESS_TREE = PROCESS_LOOPBACK_MODE.EXCLUDE_TARGET_PROCESS_TREE;

pub const AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS = extern struct {
    TargetProcessId: u32,
    ProcessLoopbackMode: PROCESS_LOOPBACK_MODE,
};

pub const AUDIOCLIENT_ACTIVATION_TYPE = enum(i32) {
    DEFAULT = 0,
    PROCESS_LOOPBACK = 1,
};
pub const AUDIOCLIENT_ACTIVATION_TYPE_DEFAULT = AUDIOCLIENT_ACTIVATION_TYPE.DEFAULT;
pub const AUDIOCLIENT_ACTIVATION_TYPE_PROCESS_LOOPBACK = AUDIOCLIENT_ACTIVATION_TYPE.PROCESS_LOOPBACK;

pub const AUDIOCLIENT_ACTIVATION_PARAMS = extern struct {
    ActivationType: AUDIOCLIENT_ACTIVATION_TYPE,
    Anonymous: extern union {
        ProcessLoopbackParams: AUDIOCLIENT_PROCESS_LOOPBACK_PARAMS,
    },
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const PAudioStateMonitorCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const AudioStateMonitorSoundLevel = enum(i32) {
    Muted = 0,
    Low = 1,
    Full = 2,
};
pub const Muted = AudioStateMonitorSoundLevel.Muted;
pub const Low = AudioStateMonitorSoundLevel.Low;
pub const Full = AudioStateMonitorSoundLevel.Full;

const IID_IAudioStateMonitor_Value = Guid.initString("63bd8738-e30d-4c77-bf5c-834e87c657e2");
pub const IID_IAudioStateMonitor = &IID_IAudioStateMonitor_Value;
pub const IAudioStateMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStateMonitor,
                callback: ?PAudioStateMonitorCallback,
                context: ?*anyopaque,
                registration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioStateMonitor,
                callback: ?PAudioStateMonitorCallback,
                context: ?*anyopaque,
                registration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStateMonitor,
                registration: i64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAudioStateMonitor,
                registration: i64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetSoundLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) AudioStateMonitorSoundLevel,
            else => *const fn (
                self: *const IAudioStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) AudioStateMonitorSoundLevel,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStateMonitor_RegisterCallback(self: *const T, callback: ?PAudioStateMonitorCallback, context: ?*anyopaque, registration: ?*i64) HRESULT {
                return @as(*const IAudioStateMonitor.VTable, @ptrCast(self.vtable)).RegisterCallback(@as(*const IAudioStateMonitor, @ptrCast(self)), callback, context, registration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStateMonitor_UnregisterCallback(self: *const T, registration: i64) void {
                return @as(*const IAudioStateMonitor.VTable, @ptrCast(self.vtable)).UnregisterCallback(@as(*const IAudioStateMonitor, @ptrCast(self)), registration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioStateMonitor_GetSoundLevel(self: *const T) AudioStateMonitorSoundLevel {
                return @as(*const IAudioStateMonitor.VTable, @ptrCast(self.vtable)).GetSoundLevel(@as(*const IAudioStateMonitor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ACMDRIVERENUMCB = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const LPACMDRIVERPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: usize,
        param1: ?HACMDRIVERID,
        param2: u32,
        param3: LPARAM,
        param4: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) LRESULT,
    else => *const fn (
        param0: usize,
        param1: ?HACMDRIVERID,
        param2: u32,
        param3: LPARAM,
        param4: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) LRESULT,
};

pub const ACMDRIVERDETAILSA = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    wMid: u16 align(1),
    wPid: u16 align(1),
    vdwACM: u32 align(1),
    vdwDriver: u32 align(1),
    fdwSupport: u32 align(1),
    cFormatTags: u32 align(1),
    cFilterTags: u32 align(1),
    hicon: ?HICON align(1),
    szShortName: [32]CHAR align(1),
    szLongName: [128]CHAR align(1),
    szCopyright: [80]CHAR align(1),
    szLicensing: [128]CHAR align(1),
    szFeatures: [512]CHAR align(1),
};

pub const ACMDRIVERDETAILSW = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    wMid: u16 align(1),
    wPid: u16 align(1),
    vdwACM: u32 align(1),
    vdwDriver: u32 align(1),
    fdwSupport: u32 align(1),
    cFormatTags: u32 align(1),
    cFilterTags: u32 align(1),
    hicon: ?HICON align(1),
    szShortName: [32]u16 align(1),
    szLongName: [128]u16 align(1),
    szCopyright: [80]u16 align(1),
    szLicensing: [128]u16 align(1),
    szFeatures: [512]u16 align(1),
};

pub const ACMFORMATTAGDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFormatTagIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    cbFormatSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFormats: u32 align(1),
    szFormatTag: [48]CHAR align(1),
};

pub const ACMFORMATTAGDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFormatTagIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    cbFormatSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFormats: u32 align(1),
    szFormatTag: [48]u16 align(1),
};

pub const ACMFORMATTAGENUMCBA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFORMATTAGDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFORMATTAGDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFORMATTAGENUMCBW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFORMATTAGDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFORMATTAGDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFORMATDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFormatIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    szFormat: [128]CHAR align(1),
};

pub const tACMFORMATDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFormatIndex: u32 align(1),
    dwFormatTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    szFormat: [128]u16 align(1),
};

pub const ACMFORMATENUMCBA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*ACMFORMATDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*ACMFORMATDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFORMATENUMCBW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*tACMFORMATDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*tACMFORMATDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFORMATCHOOSEHOOKPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const ACMFORMATCHOOSEHOOKPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const ACMFORMATCHOOSEA = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    pszTitle: ?[*:0]const u8 align(1),
    szFormatTag: [48]CHAR align(1),
    szFormat: [128]CHAR align(1),
    pszName: ?PSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfxEnum: ?*WAVEFORMATEX align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u8 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFORMATCHOOSEHOOKPROCA align(1),
};

pub const ACMFORMATCHOOSEW = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfx: ?*WAVEFORMATEX align(1),
    cbwfx: u32 align(1),
    pszTitle: ?[*:0]const u16 align(1),
    szFormatTag: [48]u16 align(1),
    szFormat: [128]u16 align(1),
    pszName: ?PWSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfxEnum: ?*WAVEFORMATEX align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u16 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFORMATCHOOSEHOOKPROCW align(1),
};

pub const ACMFILTERTAGDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFilterTagIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    cbFilterSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFilters: u32 align(1),
    szFilterTag: [48]CHAR align(1),
};

pub const ACMFILTERTAGDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFilterTagIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    cbFilterSize: u32 align(1),
    fdwSupport: u32 align(1),
    cStandardFilters: u32 align(1),
    szFilterTag: [48]u16 align(1),
};

pub const ACMFILTERTAGENUMCBA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFILTERTAGDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFILTERTAGDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFILTERTAGENUMCBW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFILTERTAGDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        paftd: ?*ACMFILTERTAGDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFILTERDETAILSA = extern struct {
    cbStruct: u32 align(1),
    dwFilterIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    szFilter: [128]CHAR align(1),
};

pub const ACMFILTERDETAILSW = extern struct {
    cbStruct: u32 align(1),
    dwFilterIndex: u32 align(1),
    dwFilterTag: u32 align(1),
    fdwSupport: u32 align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    szFilter: [128]u16 align(1),
};

pub const ACMFILTERENUMCBA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*ACMFILTERDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*ACMFILTERDETAILSA,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFILTERENUMCBW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*ACMFILTERDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hadid: ?HACMDRIVERID,
        pafd: ?*ACMFILTERDETAILSW,
        dwInstance: usize,
        fdwSupport: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const ACMFILTERCHOOSEHOOKPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const ACMFILTERCHOOSEHOOKPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        hwnd: ?HWND,
        uMsg: u32,
        wParam: WPARAM,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const ACMFILTERCHOOSEA = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    pszTitle: ?[*:0]const u8 align(1),
    szFilterTag: [48]CHAR align(1),
    szFilter: [128]CHAR align(1),
    pszName: ?PSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfltrEnum: ?*WAVEFILTER align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u8 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFILTERCHOOSEHOOKPROCA align(1),
};

pub const ACMFILTERCHOOSEW = extern struct {
    cbStruct: u32 align(1),
    fdwStyle: u32 align(1),
    hwndOwner: ?HWND align(1),
    pwfltr: ?*WAVEFILTER align(1),
    cbwfltr: u32 align(1),
    pszTitle: ?[*:0]const u16 align(1),
    szFilterTag: [48]u16 align(1),
    szFilter: [128]u16 align(1),
    pszName: ?PWSTR align(1),
    cchName: u32 align(1),
    fdwEnum: u32 align(1),
    pwfltrEnum: ?*WAVEFILTER align(1),
    hInstance: ?HINSTANCE align(1),
    pszTemplateName: ?[*:0]const u16 align(1),
    lCustData: LPARAM align(1),
    pfnHook: ?ACMFILTERCHOOSEHOOKPROCW align(1),
};

pub const tACMDRVOPENDESCA = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    dwVersion: u32 align(1),
    dwFlags: u32 align(1),
    dwError: u32 align(1),
    pszSectionName: ?[*:0]const u8 align(1),
    pszAliasName: ?[*:0]const u8 align(1),
    dnDevNode: u32 align(1),
};

pub const tACMDRVOPENDESCW = extern struct {
    cbStruct: u32 align(1),
    fccType: u32 align(1),
    fccComp: u32 align(1),
    dwVersion: u32 align(1),
    dwFlags: u32 align(1),
    dwError: u32 align(1),
    pszSectionName: ?[*:0]const u16 align(1),
    pszAliasName: ?[*:0]const u16 align(1),
    dnDevNode: u32 align(1),
};

pub const ACMDRVSTREAMINSTANCE = extern struct {
    cbStruct: u32 align(1),
    pwfxSrc: ?*WAVEFORMATEX align(1),
    pwfxDst: ?*WAVEFORMATEX align(1),
    pwfltr: ?*WAVEFILTER align(1),
    dwCallback: usize align(1),
    dwInstance: usize align(1),
    fdwOpen: u32 align(1),
    fdwDriver: u32 align(1),
    dwDriver: usize align(1),
    has: ?HACMSTREAM align(1),
};

pub const ACMDRVSTREAMHEADER = extern struct {
    cbStruct: u32 align(1),
    fdwStatus: u32 align(1),
    dwUser: usize align(1),
    pbSrc: ?*u8 align(1),
    cbSrcLength: u32 align(1),
    cbSrcLengthUsed: u32 align(1),
    dwSrcUser: usize align(1),
    pbDst: ?*u8 align(1),
    cbDstLength: u32 align(1),
    cbDstLengthUsed: u32 align(1),
    dwDstUser: usize align(1),
    fdwConvert: u32 align(1),
    padshNext: ?*ACMDRVSTREAMHEADER align(1),
    fdwDriver: u32 align(1),
    dwDriver: usize align(1),
    fdwPrepared: u32 align(1),
    dwPrepared: usize align(1),
    pbPreparedSrc: ?*u8 align(1),
    cbPreparedSrcLength: u32 align(1),
    pbPreparedDst: ?*u8 align(1),
    cbPreparedDstLength: u32 align(1),
};

pub const ACMDRVSTREAMSIZE = extern struct {
    cbStruct: u32 align(1),
    fdwSize: u32 align(1),
    cbSrcLength: u32 align(1),
    cbDstLength: u32 align(1),
};

pub const ACMDRVFORMATSUGGEST = extern struct {
    cbStruct: u32 align(1),
    fdwSuggest: u32 align(1),
    pwfxSrc: ?*WAVEFORMATEX align(1),
    cbwfxSrc: u32 align(1),
    pwfxDst: ?*WAVEFORMATEX align(1),
    cbwfxDst: u32 align(1),
};

pub const ACMSTREAMHEADER = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        cbStruct: u32 align(1),
        fdwStatus: u32 align(1),
        dwUser: usize align(1),
        pbSrc: ?*u8 align(1),
        cbSrcLength: u32 align(1),
        cbSrcLengthUsed: u32 align(1),
        dwSrcUser: usize align(1),
        pbDst: ?*u8 align(1),
        cbDstLength: u32 align(1),
        cbDstLengthUsed: u32 align(1),
        dwDstUser: usize align(1),
        dwReservedDriver: [15]u32 align(1),
    },
    .X86 => extern struct {
        cbStruct: u32 align(1),
        fdwStatus: u32 align(1),
        dwUser: usize align(1),
        pbSrc: ?*u8 align(1),
        cbSrcLength: u32 align(1),
        cbSrcLengthUsed: u32 align(1),
        dwSrcUser: usize align(1),
        pbDst: ?*u8 align(1),
        cbDstLength: u32 align(1),
        cbDstLengthUsed: u32 align(1),
        dwDstUser: usize align(1),
        dwReservedDriver: [10]u32 align(1),
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (158)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterMessageFilter(
    lpMessageFilter: ?*IMessageFilter,
    lplpMessageFilter: ?*?*IMessageFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "winmm" fn sndPlaySoundA(
    pszSound: ?[*:0]const u8,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winmm" fn sndPlaySoundW(
    pszSound: ?[*:0]const u16,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winmm" fn PlaySoundA(
    pszSound: ?[*:0]const u8,
    hmod: ?HINSTANCE,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "winmm" fn PlaySoundW(
    pszSound: ?[*:0]const u16,
    hmod: ?HINSTANCE,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetDevCapsA(
    uDeviceID: usize,
    pwoc: ?*WAVEOUTCAPSA,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetDevCapsW(
    uDeviceID: usize,
    pwoc: ?*WAVEOUTCAPSW,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetVolume(
    hwo: ?HWAVEOUT,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutSetVolume(
    hwo: ?HWAVEOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutOpen(
    phwo: ?*?HWAVEOUT,
    uDeviceID: u32,
    pwfx: ?*WAVEFORMATEX,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutClose(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutPrepareHeader(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutUnprepareHeader(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutWrite(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutPause(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutRestart(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutReset(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutBreakLoop(
    hwo: ?HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetPosition(
    hwo: ?HWAVEOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetPitch(
    hwo: ?HWAVEOUT,
    pdwPitch: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutSetPitch(
    hwo: ?HWAVEOUT,
    dwPitch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetPlaybackRate(
    hwo: ?HWAVEOUT,
    pdwRate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutSetPlaybackRate(
    hwo: ?HWAVEOUT,
    dwRate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutGetID(
    hwo: ?HWAVEOUT,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveOutMessage(
    hwo: ?HWAVEOUT,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: ?*WAVEINCAPSA,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pwic: ?*WAVEINCAPSW,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "winmm" fn waveInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInOpen(
    phwi: ?*?HWAVEIN,
    uDeviceID: u32,
    pwfx: ?*WAVEFORMATEX,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInClose(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInPrepareHeader(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInUnprepareHeader(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInAddBuffer(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pwh: ?*WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInStart(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInStop(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInReset(
    hwi: ?HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInGetPosition(
    hwi: ?HWAVEIN,
    // TODO: what to do with BytesParamIndex 2?
    pmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInGetID(
    hwi: ?HWAVEIN,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn waveInMessage(
    hwi: ?HWAVEIN,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamOpen(
    phms: ?*?HMIDISTRM,
    puDeviceID: [*]u32,
    cMidi: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamClose(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamProperty(
    hms: ?HMIDISTRM,
    lppropdata: ?*u8,
    dwProperty: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamPosition(
    hms: ?HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    lpmmt: ?*MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamOut(
    hms: ?HMIDISTRM,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamPause(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamRestart(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiStreamStop(
    hms: ?HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiConnect(
    hmi: ?HMIDI,
    hmo: ?HMIDIOUT,
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiDisconnect(
    hmi: ?HMIDI,
    hmo: ?HMIDIOUT,
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: ?*MIDIOUTCAPSA,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmoc: ?*MIDIOUTCAPSW,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetVolume(
    hmo: ?HMIDIOUT,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutSetVolume(
    hmo: ?HMIDIOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutOpen(
    phmo: ?*?HMIDIOUT,
    uDeviceID: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutClose(
    hmo: ?HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutPrepareHeader(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutUnprepareHeader(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutShortMsg(
    hmo: ?HMIDIOUT,
    dwMsg: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutLongMsg(
    hmo: ?HMIDIOUT,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutReset(
    hmo: ?HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutCachePatches(
    hmo: ?HMIDIOUT,
    uBank: u32,
    pwpa: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutCacheDrumPatches(
    hmo: ?HMIDIOUT,
    uPatch: u32,
    pwkya: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutGetID(
    hmo: ?HMIDIOUT,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiOutMessage(
    hmo: ?HMIDIOUT,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: ?*MIDIINCAPSA,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmic: ?*MIDIINCAPSW,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInOpen(
    phmi: ?*?HMIDIIN,
    uDeviceID: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: MIDI_WAVE_OPEN_TYPE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInClose(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInPrepareHeader(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInUnprepareHeader(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInAddBuffer(
    hmi: ?HMIDIIN,
    // TODO: what to do with BytesParamIndex 2?
    pmh: ?*MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInStart(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInStop(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInReset(
    hmi: ?HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInGetID(
    hmi: ?HMIDIIN,
    puDeviceID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn midiInMessage(
    hmi: ?HMIDIIN,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetDevCapsA(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: ?*AUXCAPSA,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetDevCapsW(
    uDeviceID: usize,
    // TODO: what to do with BytesParamIndex 2?
    pac: ?*AUXCAPSW,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxSetVolume(
    uDeviceID: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxGetVolume(
    uDeviceID: u32,
    pdwVolume: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn auxOutMessage(
    uDeviceID: u32,
    uMsg: u32,
    dw1: usize,
    dw2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetNumDevs() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetDevCapsA(
    uMxId: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: ?*MIXERCAPSA,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetDevCapsW(
    uMxId: usize,
    // TODO: what to do with BytesParamIndex 2?
    pmxcaps: ?*MIXERCAPSW,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerOpen(
    phmx: ?*isize,
    uMxId: u32,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerClose(
    hmx: ?HMIXER,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerMessage(
    hmx: ?HMIXER,
    uMsg: u32,
    dwParam1: usize,
    dwParam2: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineInfoA(
    hmxobj: ?HMIXEROBJ,
    pmxl: ?*MIXERLINEA,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineInfoW(
    hmxobj: ?HMIXEROBJ,
    pmxl: ?*MIXERLINEW,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetID(
    hmxobj: ?HMIXEROBJ,
    puMxId: ?*u32,
    fdwId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineControlsA(
    hmxobj: ?HMIXEROBJ,
    pmxlc: ?*MIXERLINECONTROLSA,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetLineControlsW(
    hmxobj: ?HMIXEROBJ,
    pmxlc: ?*MIXERLINECONTROLSW,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetControlDetailsA(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerGetControlDetailsW(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "winmm" fn mixerSetControlDetails(
    hmxobj: ?HMIXEROBJ,
    pmxcd: ?*MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mmdevapi" fn ActivateAudioInterfaceAsync(
    deviceInterfacePath: ?[*:0]const u16,
    riid: ?*const Guid,
    activationParams: ?*PROPVARIANT,
    completionHandler: ?*IActivateAudioInterfaceCompletionHandler,
    activationOperation: ?*?*IActivateAudioInterfaceAsyncOperation,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitor(
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitorForCategory(
    category: AUDIO_STREAM_CATEGORY,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitorForCategoryAndDeviceRole(
    category: AUDIO_STREAM_CATEGORY,
    role: ERole,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateRenderAudioStateMonitorForCategoryAndDeviceId(
    category: AUDIO_STREAM_CATEGORY,
    deviceId: ?[*:0]const u16,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitor(
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitorForCategory(
    category: AUDIO_STREAM_CATEGORY,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitorForCategoryAndDeviceRole(
    category: AUDIO_STREAM_CATEGORY,
    role: ERole,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "windows.media.mediacontrol" fn CreateCaptureAudioStateMonitorForCategoryAndDeviceId(
    category: AUDIO_STREAM_CATEGORY,
    deviceId: ?[*:0]const u16,
    audioStateMonitor: ?*?*IAudioStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmGetVersion() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmMetrics(
    hao: ?HACMOBJ,
    uMetric: u32,
    pMetric: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverEnum(
    fnCallback: ?ACMDRIVERENUMCB,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverID(
    hao: ?HACMOBJ,
    phadid: ?*isize,
    fdwDriverID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverAddA(
    phadid: ?*isize,
    hinstModule: ?HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverAddW(
    phadid: ?*isize,
    hinstModule: ?HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverRemove(
    hadid: ?HACMDRIVERID,
    fdwRemove: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverOpen(
    phad: ?*isize,
    hadid: ?HACMDRIVERID,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverClose(
    had: ?HACMDRIVER,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverMessage(
    had: ?HACMDRIVER,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverPriority(
    hadid: ?HACMDRIVERID,
    dwPriority: u32,
    fdwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverDetailsA(
    hadid: ?HACMDRIVERID,
    padd: ?*ACMDRIVERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmDriverDetailsW(
    hadid: ?HACMDRIVERID,
    padd: ?*ACMDRIVERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagDetailsA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagDetailsW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagEnumA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSA,
    fnCallback: ?ACMFORMATTAGENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatTagEnumW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFORMATTAGDETAILSW,
    fnCallback: ?ACMFORMATTAGENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatDetailsA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFORMATDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatDetailsW(
    had: ?HACMDRIVER,
    pafd: ?*tACMFORMATDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatEnumA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFORMATDETAILSA,
    fnCallback: ?ACMFORMATENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatEnumW(
    had: ?HACMDRIVER,
    pafd: ?*tACMFORMATDETAILSW,
    fnCallback: ?ACMFORMATENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatSuggest(
    had: ?HACMDRIVER,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    cbwfxDst: u32,
    fdwSuggest: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatChooseA(
    pafmtc: ?*ACMFORMATCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFormatChooseW(
    pafmtc: ?*ACMFORMATCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagDetailsA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagDetailsW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagEnumA(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSA,
    fnCallback: ?ACMFILTERTAGENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterTagEnumW(
    had: ?HACMDRIVER,
    paftd: ?*ACMFILTERTAGDETAILSW,
    fnCallback: ?ACMFILTERTAGENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterDetailsA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterDetailsW(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterEnumA(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSA,
    fnCallback: ?ACMFILTERENUMCBA,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterEnumW(
    had: ?HACMDRIVER,
    pafd: ?*ACMFILTERDETAILSW,
    fnCallback: ?ACMFILTERENUMCBW,
    dwInstance: usize,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterChooseA(
    pafltrc: ?*ACMFILTERCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmFilterChooseW(
    pafltrc: ?*ACMFILTERCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamOpen(
    phas: ?*isize,
    had: ?HACMDRIVER,
    pwfxSrc: ?*WAVEFORMATEX,
    pwfxDst: ?*WAVEFORMATEX,
    pwfltr: ?*WAVEFILTER,
    dwCallback: usize,
    dwInstance: usize,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamClose(
    has: ?HACMSTREAM,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamSize(
    has: ?HACMSTREAM,
    cbInput: u32,
    pdwOutputBytes: ?*u32,
    fdwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamReset(
    has: ?HACMSTREAM,
    fdwReset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamMessage(
    has: ?HACMSTREAM,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamConvert(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdwConvert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamPrepareHeader(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdwPrepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "msacm32" fn acmStreamUnprepareHeader(
    has: ?HACMSTREAM,
    pash: ?*ACMSTREAMHEADER,
    fdwUnprepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (56)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WAVEOUTCAPS = thismodule.WAVEOUTCAPSA;
        pub const WAVEOUTCAPS2 = thismodule.WAVEOUTCAPS2A;
        pub const WAVEINCAPS = thismodule.WAVEINCAPSA;
        pub const WAVEINCAPS2 = thismodule.WAVEINCAPS2A;
        pub const MIDIOUTCAPS = thismodule.MIDIOUTCAPSA;
        pub const MIDIOUTCAPS2 = thismodule.MIDIOUTCAPS2A;
        pub const MIDIINCAPS = thismodule.MIDIINCAPSA;
        pub const MIDIINCAPS2 = thismodule.MIDIINCAPS2A;
        pub const AUXCAPS = thismodule.AUXCAPSA;
        pub const AUXCAPS2 = thismodule.AUXCAPS2A;
        pub const MIXERCAPS = thismodule.MIXERCAPSA;
        pub const MIXERCAPS2 = thismodule.MIXERCAPS2A;
        pub const MIXERLINE = thismodule.MIXERLINEA;
        pub const MIXERCONTROL = thismodule.MIXERCONTROLA;
        pub const MIXERLINECONTROLS = thismodule.MIXERLINECONTROLSA;
        pub const MIXERCONTROLDETAILS_LISTTEXT = thismodule.MIXERCONTROLDETAILS_LISTTEXTA;
        pub const ACMDRIVERDETAILS = thismodule.ACMDRIVERDETAILSA;
        pub const ACMFORMATTAGDETAILS = thismodule.ACMFORMATTAGDETAILSA;
        pub const ACMFORMATTAGENUMCB = thismodule.ACMFORMATTAGENUMCBA;
        pub const ACMFORMATENUMCB = thismodule.ACMFORMATENUMCBA;
        pub const ACMFORMATCHOOSEHOOKPROC = thismodule.ACMFORMATCHOOSEHOOKPROCA;
        pub const ACMFORMATCHOOSE = thismodule.ACMFORMATCHOOSEA;
        pub const ACMFILTERTAGDETAILS = thismodule.ACMFILTERTAGDETAILSA;
        pub const ACMFILTERTAGENUMCB = thismodule.ACMFILTERTAGENUMCBA;
        pub const ACMFILTERDETAILS = thismodule.ACMFILTERDETAILSA;
        pub const ACMFILTERENUMCB = thismodule.ACMFILTERENUMCBA;
        pub const ACMFILTERCHOOSEHOOKPROC = thismodule.ACMFILTERCHOOSEHOOKPROCA;
        pub const ACMFILTERCHOOSE = thismodule.ACMFILTERCHOOSEA;
        pub const tACMDRVOPENDESC = thismodule.tACMDRVOPENDESCA;
        pub const sndPlaySound = thismodule.sndPlaySoundA;
        pub const PlaySound = thismodule.PlaySoundA;
        pub const waveOutGetDevCaps = thismodule.waveOutGetDevCapsA;
        pub const waveOutGetErrorText = thismodule.waveOutGetErrorTextA;
        pub const waveInGetDevCaps = thismodule.waveInGetDevCapsA;
        pub const waveInGetErrorText = thismodule.waveInGetErrorTextA;
        pub const midiOutGetDevCaps = thismodule.midiOutGetDevCapsA;
        pub const midiOutGetErrorText = thismodule.midiOutGetErrorTextA;
        pub const midiInGetDevCaps = thismodule.midiInGetDevCapsA;
        pub const midiInGetErrorText = thismodule.midiInGetErrorTextA;
        pub const auxGetDevCaps = thismodule.auxGetDevCapsA;
        pub const mixerGetDevCaps = thismodule.mixerGetDevCapsA;
        pub const mixerGetLineInfo = thismodule.mixerGetLineInfoA;
        pub const mixerGetLineControls = thismodule.mixerGetLineControlsA;
        pub const mixerGetControlDetails = thismodule.mixerGetControlDetailsA;
        pub const acmDriverAdd = thismodule.acmDriverAddA;
        pub const acmDriverDetails = thismodule.acmDriverDetailsA;
        pub const acmFormatTagDetails = thismodule.acmFormatTagDetailsA;
        pub const acmFormatTagEnum = thismodule.acmFormatTagEnumA;
        pub const acmFormatDetails = thismodule.acmFormatDetailsA;
        pub const acmFormatEnum = thismodule.acmFormatEnumA;
        pub const acmFormatChoose = thismodule.acmFormatChooseA;
        pub const acmFilterTagDetails = thismodule.acmFilterTagDetailsA;
        pub const acmFilterTagEnum = thismodule.acmFilterTagEnumA;
        pub const acmFilterDetails = thismodule.acmFilterDetailsA;
        pub const acmFilterEnum = thismodule.acmFilterEnumA;
        pub const acmFilterChoose = thismodule.acmFilterChooseA;
    },
    .wide => struct {
        pub const WAVEOUTCAPS = thismodule.WAVEOUTCAPSW;
        pub const WAVEOUTCAPS2 = thismodule.WAVEOUTCAPS2W;
        pub const WAVEINCAPS = thismodule.WAVEINCAPSW;
        pub const WAVEINCAPS2 = thismodule.WAVEINCAPS2W;
        pub const MIDIOUTCAPS = thismodule.MIDIOUTCAPSW;
        pub const MIDIOUTCAPS2 = thismodule.MIDIOUTCAPS2W;
        pub const MIDIINCAPS = thismodule.MIDIINCAPSW;
        pub const MIDIINCAPS2 = thismodule.MIDIINCAPS2W;
        pub const AUXCAPS = thismodule.AUXCAPSW;
        pub const AUXCAPS2 = thismodule.AUXCAPS2W;
        pub const MIXERCAPS = thismodule.MIXERCAPSW;
        pub const MIXERCAPS2 = thismodule.MIXERCAPS2W;
        pub const MIXERLINE = thismodule.MIXERLINEW;
        pub const MIXERCONTROL = thismodule.MIXERCONTROLW;
        pub const MIXERLINECONTROLS = thismodule.MIXERLINECONTROLSW;
        pub const MIXERCONTROLDETAILS_LISTTEXT = thismodule.MIXERCONTROLDETAILS_LISTTEXTW;
        pub const ACMDRIVERDETAILS = thismodule.ACMDRIVERDETAILSW;
        pub const ACMFORMATTAGDETAILS = thismodule.ACMFORMATTAGDETAILSW;
        pub const ACMFORMATTAGENUMCB = thismodule.ACMFORMATTAGENUMCBW;
        pub const ACMFORMATENUMCB = thismodule.ACMFORMATENUMCBW;
        pub const ACMFORMATCHOOSEHOOKPROC = thismodule.ACMFORMATCHOOSEHOOKPROCW;
        pub const ACMFORMATCHOOSE = thismodule.ACMFORMATCHOOSEW;
        pub const ACMFILTERTAGDETAILS = thismodule.ACMFILTERTAGDETAILSW;
        pub const ACMFILTERTAGENUMCB = thismodule.ACMFILTERTAGENUMCBW;
        pub const ACMFILTERDETAILS = thismodule.ACMFILTERDETAILSW;
        pub const ACMFILTERENUMCB = thismodule.ACMFILTERENUMCBW;
        pub const ACMFILTERCHOOSEHOOKPROC = thismodule.ACMFILTERCHOOSEHOOKPROCW;
        pub const ACMFILTERCHOOSE = thismodule.ACMFILTERCHOOSEW;
        pub const tACMDRVOPENDESC = thismodule.tACMDRVOPENDESCW;
        pub const sndPlaySound = thismodule.sndPlaySoundW;
        pub const PlaySound = thismodule.PlaySoundW;
        pub const waveOutGetDevCaps = thismodule.waveOutGetDevCapsW;
        pub const waveOutGetErrorText = thismodule.waveOutGetErrorTextW;
        pub const waveInGetDevCaps = thismodule.waveInGetDevCapsW;
        pub const waveInGetErrorText = thismodule.waveInGetErrorTextW;
        pub const midiOutGetDevCaps = thismodule.midiOutGetDevCapsW;
        pub const midiOutGetErrorText = thismodule.midiOutGetErrorTextW;
        pub const midiInGetDevCaps = thismodule.midiInGetDevCapsW;
        pub const midiInGetErrorText = thismodule.midiInGetErrorTextW;
        pub const auxGetDevCaps = thismodule.auxGetDevCapsW;
        pub const mixerGetDevCaps = thismodule.mixerGetDevCapsW;
        pub const mixerGetLineInfo = thismodule.mixerGetLineInfoW;
        pub const mixerGetLineControls = thismodule.mixerGetLineControlsW;
        pub const mixerGetControlDetails = thismodule.mixerGetControlDetailsW;
        pub const acmDriverAdd = thismodule.acmDriverAddW;
        pub const acmDriverDetails = thismodule.acmDriverDetailsW;
        pub const acmFormatTagDetails = thismodule.acmFormatTagDetailsW;
        pub const acmFormatTagEnum = thismodule.acmFormatTagEnumW;
        pub const acmFormatDetails = thismodule.acmFormatDetailsW;
        pub const acmFormatEnum = thismodule.acmFormatEnumW;
        pub const acmFormatChoose = thismodule.acmFormatChooseW;
        pub const acmFilterTagDetails = thismodule.acmFilterTagDetailsW;
        pub const acmFilterTagEnum = thismodule.acmFilterTagEnumW;
        pub const acmFilterDetails = thismodule.acmFilterDetailsW;
        pub const acmFilterEnum = thismodule.acmFilterEnumW;
        pub const acmFilterChoose = thismodule.acmFilterChooseW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WAVEOUTCAPS = *opaque {};
        pub const WAVEOUTCAPS2 = *opaque {};
        pub const WAVEINCAPS = *opaque {};
        pub const WAVEINCAPS2 = *opaque {};
        pub const MIDIOUTCAPS = *opaque {};
        pub const MIDIOUTCAPS2 = *opaque {};
        pub const MIDIINCAPS = *opaque {};
        pub const MIDIINCAPS2 = *opaque {};
        pub const AUXCAPS = *opaque {};
        pub const AUXCAPS2 = *opaque {};
        pub const MIXERCAPS = *opaque {};
        pub const MIXERCAPS2 = *opaque {};
        pub const MIXERLINE = *opaque {};
        pub const MIXERCONTROL = *opaque {};
        pub const MIXERLINECONTROLS = *opaque {};
        pub const MIXERCONTROLDETAILS_LISTTEXT = *opaque {};
        pub const ACMDRIVERDETAILS = *opaque {};
        pub const ACMFORMATTAGDETAILS = *opaque {};
        pub const ACMFORMATTAGENUMCB = *opaque {};
        pub const ACMFORMATENUMCB = *opaque {};
        pub const ACMFORMATCHOOSEHOOKPROC = *opaque {};
        pub const ACMFORMATCHOOSE = *opaque {};
        pub const ACMFILTERTAGDETAILS = *opaque {};
        pub const ACMFILTERTAGENUMCB = *opaque {};
        pub const ACMFILTERDETAILS = *opaque {};
        pub const ACMFILTERENUMCB = *opaque {};
        pub const ACMFILTERCHOOSEHOOKPROC = *opaque {};
        pub const ACMFILTERCHOOSE = *opaque {};
        pub const tACMDRVOPENDESC = *opaque {};
        pub const sndPlaySound = *opaque {};
        pub const PlaySound = *opaque {};
        pub const waveOutGetDevCaps = *opaque {};
        pub const waveOutGetErrorText = *opaque {};
        pub const waveInGetDevCaps = *opaque {};
        pub const waveInGetErrorText = *opaque {};
        pub const midiOutGetDevCaps = *opaque {};
        pub const midiOutGetErrorText = *opaque {};
        pub const midiInGetDevCaps = *opaque {};
        pub const midiInGetErrorText = *opaque {};
        pub const auxGetDevCaps = *opaque {};
        pub const mixerGetDevCaps = *opaque {};
        pub const mixerGetLineInfo = *opaque {};
        pub const mixerGetLineControls = *opaque {};
        pub const mixerGetControlDetails = *opaque {};
        pub const acmDriverAdd = *opaque {};
        pub const acmDriverDetails = *opaque {};
        pub const acmFormatTagDetails = *opaque {};
        pub const acmFormatTagEnum = *opaque {};
        pub const acmFormatDetails = *opaque {};
        pub const acmFormatEnum = *opaque {};
        pub const acmFormatChoose = *opaque {};
        pub const acmFilterTagDetails = *opaque {};
        pub const acmFilterTagEnum = *opaque {};
        pub const acmFilterDetails = *opaque {};
        pub const acmFilterEnum = *opaque {};
        pub const acmFilterChoose = *opaque {};
    } else struct {
        pub const WAVEOUTCAPS = @compileError("'WAVEOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEOUTCAPS2 = @compileError("'WAVEOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS = @compileError("'WAVEINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS2 = @compileError("'WAVEINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS = @compileError("'MIDIOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS2 = @compileError("'MIDIOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS = @compileError("'MIDIINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS2 = @compileError("'MIDIINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS = @compileError("'AUXCAPS' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS2 = @compileError("'AUXCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS = @compileError("'MIXERCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS2 = @compileError("'MIXERCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINE = @compileError("'MIXERLINE' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROL = @compileError("'MIXERCONTROL' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINECONTROLS = @compileError("'MIXERLINECONTROLS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROLDETAILS_LISTTEXT = @compileError("'MIXERCONTROLDETAILS_LISTTEXT' requires that UNICODE be set to true or false in the root module");
        pub const ACMDRIVERDETAILS = @compileError("'ACMDRIVERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGDETAILS = @compileError("'ACMFORMATTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGENUMCB = @compileError("'ACMFORMATTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATENUMCB = @compileError("'ACMFORMATENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSEHOOKPROC = @compileError("'ACMFORMATCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSE = @compileError("'ACMFORMATCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGDETAILS = @compileError("'ACMFILTERTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGENUMCB = @compileError("'ACMFILTERTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERDETAILS = @compileError("'ACMFILTERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERENUMCB = @compileError("'ACMFILTERENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSEHOOKPROC = @compileError("'ACMFILTERCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSE = @compileError("'ACMFILTERCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const tACMDRVOPENDESC = @compileError("'tACMDRVOPENDESC' requires that UNICODE be set to true or false in the root module");
        pub const sndPlaySound = @compileError("'sndPlaySound' requires that UNICODE be set to true or false in the root module");
        pub const PlaySound = @compileError("'PlaySound' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetDevCaps = @compileError("'waveOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetErrorText = @compileError("'waveOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetDevCaps = @compileError("'waveInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetErrorText = @compileError("'waveInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetDevCaps = @compileError("'midiOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetErrorText = @compileError("'midiOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetDevCaps = @compileError("'midiInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetErrorText = @compileError("'midiInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const auxGetDevCaps = @compileError("'auxGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetDevCaps = @compileError("'mixerGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineInfo = @compileError("'mixerGetLineInfo' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineControls = @compileError("'mixerGetLineControls' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetControlDetails = @compileError("'mixerGetControlDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverAdd = @compileError("'acmDriverAdd' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverDetails = @compileError("'acmDriverDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagDetails = @compileError("'acmFormatTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagEnum = @compileError("'acmFormatTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatDetails = @compileError("'acmFormatDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatEnum = @compileError("'acmFormatEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatChoose = @compileError("'acmFormatChoose' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagDetails = @compileError("'acmFilterTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagEnum = @compileError("'acmFilterTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterDetails = @compileError("'acmFilterDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterEnum = @compileError("'acmFilterEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterChoose = @compileError("'acmFilterChoose' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (21)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CHAR = @import("../foundation.zig").CHAR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDRVR = @import("../media/multimedia.zig").HDRVR;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HTASK = @import("../media.zig").HTASK;
const HWND = @import("../foundation.zig").HWND;
const INTERFACEINFO = @import("../system/com.zig").INTERFACEINFO;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const MMTIME = @import("../media.zig").MMTIME;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPWAVECALLBACK")) {
        _ = LPWAVECALLBACK;
    }
    if (@hasDecl(@This(), "LPMIDICALLBACK")) {
        _ = LPMIDICALLBACK;
    }
    if (@hasDecl(@This(), "ACMDRIVERENUMCB")) {
        _ = ACMDRIVERENUMCB;
    }
    if (@hasDecl(@This(), "LPACMDRIVERPROC")) {
        _ = LPACMDRIVERPROC;
    }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBA")) {
        _ = ACMFORMATTAGENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFORMATTAGENUMCBW")) {
        _ = ACMFORMATTAGENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFORMATENUMCBA")) {
        _ = ACMFORMATENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFORMATENUMCBW")) {
        _ = ACMFORMATENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCA")) {
        _ = ACMFORMATCHOOSEHOOKPROCA;
    }
    if (@hasDecl(@This(), "ACMFORMATCHOOSEHOOKPROCW")) {
        _ = ACMFORMATCHOOSEHOOKPROCW;
    }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBA")) {
        _ = ACMFILTERTAGENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFILTERTAGENUMCBW")) {
        _ = ACMFILTERTAGENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFILTERENUMCBA")) {
        _ = ACMFILTERENUMCBA;
    }
    if (@hasDecl(@This(), "ACMFILTERENUMCBW")) {
        _ = ACMFILTERENUMCBW;
    }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCA")) {
        _ = ACMFILTERCHOOSEHOOKPROCA;
    }
    if (@hasDecl(@This(), "ACMFILTERCHOOSEHOOKPROCW")) {
        _ = ACMFILTERCHOOSEHOOKPROCW;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (5)
//--------------------------------------------------------------------------------
pub const apo = @import("audio/apo.zig");
pub const direct_music = @import("audio/direct_music.zig");
pub const direct_sound = @import("audio/direct_sound.zig");
pub const endpoints = @import("audio/endpoints.zig");
pub const xaudio2 = @import("audio/xaudio2.zig");
