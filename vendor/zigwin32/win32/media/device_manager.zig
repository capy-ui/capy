//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (277)
//--------------------------------------------------------------------------------
pub const IOCTL_MTP_CUSTOM_COMMAND = @as(u32, 827348045);
pub const MTP_NEXTPHASE_READ_DATA = @as(u32, 1);
pub const MTP_NEXTPHASE_WRITE_DATA = @as(u32, 2);
pub const MTP_NEXTPHASE_NO_DATA = @as(u32, 3);
pub const RSA_KEY_LEN = @as(u32, 64);
pub const SAC_SESSION_KEYLEN = @as(u32, 8);
pub const SAC_PROTOCOL_WMDM = @as(u32, 1);
pub const SAC_PROTOCOL_V1 = @as(u32, 2);
pub const SAC_CERT_X509 = @as(u32, 1);
pub const SAC_CERT_V1 = @as(u32, 2);
pub const WMDM_DEVICE_PROTOCOL_MTP = Guid.initString("979e54e5-0afc-4604-8d93-dc798a4bcf45");
pub const WMDM_DEVICE_PROTOCOL_RAPI = Guid.initString("2a11ed91-8c8f-41e4-82d1-8386e003561c");
pub const WMDM_DEVICE_PROTOCOL_MSC = Guid.initString("a4d2c26c-a881-44bb-bd5d-1f703c71f7a9");
pub const WMDM_SERVICE_PROVIDER_VENDOR_MICROSOFT = Guid.initString("7de8686d-78ee-43ea-a496-c625ac91cc5d");
pub const WMDMID_LENGTH = @as(u32, 128);
pub const WMDM_MAC_LENGTH = @as(u32, 8);
pub const WMDM_S_NOT_ALL_PROPERTIES_APPLIED = @as(i32, 282625);
pub const WMDM_S_NOT_ALL_PROPERTIES_RETRIEVED = @as(i32, 282626);
pub const WMDM_E_BUSY = @as(i32, -2147201024);
pub const WMDM_E_INTERFACEDEAD = @as(i32, -2147201023);
pub const WMDM_E_INVALIDTYPE = @as(i32, -2147201022);
pub const WMDM_E_PROCESSFAILED = @as(i32, -2147201021);
pub const WMDM_E_NOTSUPPORTED = @as(i32, -2147201020);
pub const WMDM_E_NOTCERTIFIED = @as(i32, -2147201019);
pub const WMDM_E_NORIGHTS = @as(i32, -2147201018);
pub const WMDM_E_CALL_OUT_OF_SEQUENCE = @as(i32, -2147201017);
pub const WMDM_E_BUFFERTOOSMALL = @as(i32, -2147201016);
pub const WMDM_E_MOREDATA = @as(i32, -2147201015);
pub const WMDM_E_MAC_CHECK_FAILED = @as(i32, -2147201014);
pub const WMDM_E_USER_CANCELLED = @as(i32, -2147201013);
pub const WMDM_E_SDMI_TRIGGER = @as(i32, -2147201012);
pub const WMDM_E_SDMI_NOMORECOPIES = @as(i32, -2147201011);
pub const WMDM_E_REVOKED = @as(i32, -2147201010);
pub const WMDM_E_LICENSE_NOTEXIST = @as(i32, -2147201009);
pub const WMDM_E_INCORRECT_APPSEC = @as(i32, -2147201008);
pub const WMDM_E_INCORRECT_RIGHTS = @as(i32, -2147201007);
pub const WMDM_E_LICENSE_EXPIRED = @as(i32, -2147201006);
pub const WMDM_E_CANTOPEN_PMSN_SERVICE_PIPE = @as(i32, -2147201005);
pub const WMDM_E_TOO_MANY_SESSIONS = @as(i32, -2147201005);
pub const WMDM_WMDM_REVOKED = @as(u32, 1);
pub const WMDM_APP_REVOKED = @as(u32, 2);
pub const WMDM_SP_REVOKED = @as(u32, 4);
pub const WMDM_SCP_REVOKED = @as(u32, 8);
pub const WMDM_GET_FORMAT_SUPPORT_AUDIO = @as(u32, 1);
pub const WMDM_GET_FORMAT_SUPPORT_VIDEO = @as(u32, 2);
pub const WMDM_GET_FORMAT_SUPPORT_FILE = @as(u32, 4);
pub const WMDM_RIGHTS_PLAYBACKCOUNT = @as(u32, 1);
pub const WMDM_RIGHTS_EXPIRATIONDATE = @as(u32, 2);
pub const WMDM_RIGHTS_GROUPID = @as(u32, 4);
pub const WMDM_RIGHTS_FREESERIALIDS = @as(u32, 8);
pub const WMDM_RIGHTS_NAMEDSERIALIDS = @as(u32, 16);
pub const WMDM_DEVICE_TYPE_PLAYBACK = @as(u32, 1);
pub const WMDM_DEVICE_TYPE_RECORD = @as(u32, 2);
pub const WMDM_DEVICE_TYPE_DECODE = @as(u32, 4);
pub const WMDM_DEVICE_TYPE_ENCODE = @as(u32, 8);
pub const WMDM_DEVICE_TYPE_STORAGE = @as(u32, 16);
pub const WMDM_DEVICE_TYPE_VIRTUAL = @as(u32, 32);
pub const WMDM_DEVICE_TYPE_SDMI = @as(u32, 64);
pub const WMDM_DEVICE_TYPE_NONSDMI = @as(u32, 128);
pub const WMDM_DEVICE_TYPE_NONREENTRANT = @as(u32, 256);
pub const WMDM_DEVICE_TYPE_FILELISTRESYNC = @as(u32, 512);
pub const WMDM_DEVICE_TYPE_VIEW_PREF_METADATAVIEW = @as(u32, 1024);
pub const WMDM_POWER_CAP_BATTERY = @as(u32, 1);
pub const WMDM_POWER_CAP_EXTERNAL = @as(u32, 2);
pub const WMDM_POWER_IS_BATTERY = @as(u32, 4);
pub const WMDM_POWER_IS_EXTERNAL = @as(u32, 8);
pub const WMDM_POWER_PERCENT_AVAILABLE = @as(u32, 16);
pub const WMDM_STATUS_READY = @as(u32, 1);
pub const WMDM_STATUS_BUSY = @as(u32, 2);
pub const WMDM_STATUS_DEVICE_NOTPRESENT = @as(u32, 4);
pub const WMDM_STATUS_DEVICECONTROL_PLAYING = @as(u32, 8);
pub const WMDM_STATUS_DEVICECONTROL_RECORDING = @as(u32, 16);
pub const WMDM_STATUS_DEVICECONTROL_PAUSED = @as(u32, 32);
pub const WMDM_STATUS_DEVICECONTROL_REMOTE = @as(u32, 64);
pub const WMDM_STATUS_DEVICECONTROL_STREAM = @as(u32, 128);
pub const WMDM_STATUS_STORAGE_NOTPRESENT = @as(u32, 256);
pub const WMDM_STATUS_STORAGE_INITIALIZING = @as(u32, 512);
pub const WMDM_STATUS_STORAGE_BROKEN = @as(u32, 1024);
pub const WMDM_STATUS_STORAGE_NOTSUPPORTED = @as(u32, 2048);
pub const WMDM_STATUS_STORAGE_UNFORMATTED = @as(u32, 4096);
pub const WMDM_STATUS_STORAGECONTROL_INSERTING = @as(u32, 8192);
pub const WMDM_STATUS_STORAGECONTROL_DELETING = @as(u32, 16384);
pub const WMDM_STATUS_STORAGECONTROL_APPENDING = @as(u32, 32768);
pub const WMDM_STATUS_STORAGECONTROL_MOVING = @as(u32, 65536);
pub const WMDM_STATUS_STORAGECONTROL_READING = @as(u32, 131072);
pub const WMDM_DEVICECAP_CANPLAY = @as(u32, 1);
pub const WMDM_DEVICECAP_CANSTREAMPLAY = @as(u32, 2);
pub const WMDM_DEVICECAP_CANRECORD = @as(u32, 4);
pub const WMDM_DEVICECAP_CANSTREAMRECORD = @as(u32, 8);
pub const WMDM_DEVICECAP_CANPAUSE = @as(u32, 16);
pub const WMDM_DEVICECAP_CANRESUME = @as(u32, 32);
pub const WMDM_DEVICECAP_CANSTOP = @as(u32, 64);
pub const WMDM_DEVICECAP_CANSEEK = @as(u32, 128);
pub const WMDM_DEVICECAP_HASSECURECLOCK = @as(u32, 256);
pub const WMDM_SEEK_REMOTECONTROL = @as(u32, 1);
pub const WMDM_SEEK_STREAMINGAUDIO = @as(u32, 2);
pub const WMDM_STORAGE_ATTR_FILESYSTEM = @as(u32, 1);
pub const WMDM_STORAGE_ATTR_REMOVABLE = @as(u32, 2);
pub const WMDM_STORAGE_ATTR_NONREMOVABLE = @as(u32, 4);
pub const WMDM_FILE_ATTR_FOLDER = @as(u32, 8);
pub const WMDM_FILE_ATTR_LINK = @as(u32, 16);
pub const WMDM_FILE_ATTR_FILE = @as(u32, 32);
pub const WMDM_FILE_ATTR_VIDEO = @as(u32, 64);
pub const WMDM_STORAGE_ATTR_CANEDITMETADATA = @as(u32, 128);
pub const WMDM_STORAGE_ATTR_FOLDERS = @as(u32, 256);
pub const WMDM_FILE_ATTR_AUDIO = @as(u32, 4096);
pub const WMDM_FILE_ATTR_DATA = @as(u32, 8192);
pub const WMDM_FILE_ATTR_CANPLAY = @as(u32, 16384);
pub const WMDM_FILE_ATTR_CANDELETE = @as(u32, 32768);
pub const WMDM_FILE_ATTR_CANMOVE = @as(u32, 65536);
pub const WMDM_FILE_ATTR_CANRENAME = @as(u32, 131072);
pub const WMDM_FILE_ATTR_CANREAD = @as(u32, 262144);
pub const WMDM_FILE_ATTR_MUSIC = @as(u32, 524288);
pub const WMDM_FILE_CREATE_OVERWRITE = @as(u32, 1048576);
pub const WMDM_FILE_ATTR_AUDIOBOOK = @as(u32, 2097152);
pub const WMDM_FILE_ATTR_HIDDEN = @as(u32, 4194304);
pub const WMDM_FILE_ATTR_SYSTEM = @as(u32, 8388608);
pub const WMDM_FILE_ATTR_READONLY = @as(u32, 16777216);
pub const WMDM_STORAGE_ATTR_HAS_FOLDERS = @as(u32, 33554432);
pub const WMDM_STORAGE_ATTR_HAS_FILES = @as(u32, 67108864);
pub const WMDM_STORAGE_IS_DEFAULT = @as(u32, 134217728);
pub const WMDM_STORAGE_CONTAINS_DEFAULT = @as(u32, 268435456);
pub const WMDM_STORAGE_ATTR_VIRTUAL = @as(u32, 536870912);
pub const WMDM_STORAGECAP_FOLDERSINROOT = @as(u32, 1);
pub const WMDM_STORAGECAP_FILESINROOT = @as(u32, 2);
pub const WMDM_STORAGECAP_FOLDERSINFOLDERS = @as(u32, 4);
pub const WMDM_STORAGECAP_FILESINFOLDERS = @as(u32, 8);
pub const WMDM_STORAGECAP_FOLDERLIMITEXISTS = @as(u32, 16);
pub const WMDM_STORAGECAP_FILELIMITEXISTS = @as(u32, 32);
pub const WMDM_STORAGECAP_NOT_INITIALIZABLE = @as(u32, 64);
pub const WMDM_MODE_BLOCK = @as(u32, 1);
pub const WMDM_MODE_THREAD = @as(u32, 2);
pub const WMDM_CONTENT_FILE = @as(u32, 4);
pub const WMDM_CONTENT_FOLDER = @as(u32, 8);
pub const WMDM_CONTENT_OPERATIONINTERFACE = @as(u32, 16);
pub const WMDM_MODE_QUERY = @as(u32, 32);
pub const WMDM_MODE_PROGRESS = @as(u32, 64);
pub const WMDM_MODE_TRANSFER_PROTECTED = @as(u32, 128);
pub const WMDM_MODE_TRANSFER_UNPROTECTED = @as(u32, 256);
pub const WMDM_STORAGECONTROL_INSERTBEFORE = @as(u32, 512);
pub const WMDM_STORAGECONTROL_INSERTAFTER = @as(u32, 1024);
pub const WMDM_STORAGECONTROL_INSERTINTO = @as(u32, 2048);
pub const WMDM_MODE_RECURSIVE = @as(u32, 4096);
pub const WMDM_RIGHTS_PLAY_ON_PC = @as(u32, 1);
pub const WMDM_RIGHTS_COPY_TO_NON_SDMI_DEVICE = @as(u32, 2);
pub const WMDM_RIGHTS_COPY_TO_CD = @as(u32, 8);
pub const WMDM_RIGHTS_COPY_TO_SDMI_DEVICE = @as(u32, 16);
pub const WMDM_SEEK_BEGIN = @as(u32, 1);
pub const WMDM_SEEK_CURRENT = @as(u32, 2);
pub const WMDM_SEEK_END = @as(u32, 8);
pub const DO_NOT_VIRTUALIZE_STORAGES_AS_DEVICES = @as(u32, 1);
pub const ALLOW_OUTOFBAND_NOTIFICATION = @as(u32, 2);
pub const MDSP_READ = @as(u32, 1);
pub const MDSP_WRITE = @as(u32, 2);
pub const MDSP_SEEK_BOF = @as(u32, 1);
pub const MDSP_SEEK_CUR = @as(u32, 2);
pub const MDSP_SEEK_EOF = @as(u32, 4);
pub const WMDM_SCP_EXAMINE_EXTENSION = @as(i32, 1);
pub const WMDM_SCP_EXAMINE_DATA = @as(i32, 2);
pub const WMDM_SCP_DECIDE_DATA = @as(i32, 8);
pub const WMDM_SCP_PROTECTED_OUTPUT = @as(i32, 16);
pub const WMDM_SCP_UNPROTECTED_OUTPUT = @as(i32, 32);
pub const WMDM_SCP_RIGHTS_DATA = @as(i32, 64);
pub const WMDM_SCP_TRANSFER_OBJECTDATA = @as(i32, 32);
pub const WMDM_SCP_NO_MORE_CHANGES = @as(i32, 64);
pub const WMDM_SCP_DRMINFO_NOT_DRMPROTECTED = @as(i32, 0);
pub const WMDM_SCP_DRMINFO_V1HEADER = @as(i32, 1);
pub const WMDM_SCP_DRMINFO_V2HEADER = @as(i32, 2);
pub const SCP_EVENTID_ACQSECURECLOCK = Guid.initString("86248cc9-4a59-43e2-9146-48a7f3f4140c");
pub const SCP_EVENTID_NEEDTOINDIV = Guid.initString("87a507c7-b469-4386-b976-d5d1ce538a6f");
pub const SCP_EVENTID_DRMINFO = Guid.initString("213dd287-41d2-432b-9e3f-3b4f7b3581dd");
pub const SCP_PARAMID_DRMVERSION = Guid.initString("41d0155d-7cc7-4217-ada9-005074624da4");
pub const SAC_MAC_LEN = @as(u32, 8);
pub const WMDM_LOG_SEV_INFO = @as(u32, 1);
pub const WMDM_LOG_SEV_WARN = @as(u32, 2);
pub const WMDM_LOG_SEV_ERROR = @as(u32, 4);
pub const WMDM_LOG_NOTIMESTAMP = @as(u32, 16);
pub const g_wszWMDMFileName = "WMDM/FileName";
pub const g_wszWMDMFormatCode = "WMDM/FormatCode";
pub const g_wszWMDMLastModifiedDate = "WMDM/LastModifiedDate";
pub const g_wszWMDMFileCreationDate = "WMDM/FileCreationDate";
pub const g_wszWMDMFileSize = "WMDM/FileSize";
pub const g_wszWMDMFileAttributes = "WMDM/FileAttributes";
pub const g_wszAudioWAVECodec = "WMDM/AudioWAVECodec";
pub const g_wszVideoFourCCCodec = "WMDM/VideoFourCCCodec";
pub const g_wszWMDMTitle = "WMDM/Title";
pub const g_wszWMDMAuthor = "WMDM/Author";
pub const g_wszWMDMDescription = "WMDM/Description";
pub const g_wszWMDMIsProtected = "WMDM/IsProtected";
pub const g_wszWMDMAlbumTitle = "WMDM/AlbumTitle";
pub const g_wszWMDMAlbumArtist = "WMDM/AlbumArtist";
pub const g_wszWMDMTrack = "WMDM/Track";
pub const g_wszWMDMGenre = "WMDM/Genre";
pub const g_wszWMDMTrackMood = "WMDM/TrackMood";
pub const g_wszWMDMAlbumCoverFormat = "WMDM/AlbumCoverFormat";
pub const g_wszWMDMAlbumCoverSize = "WMDM/AlbumCoverSize";
pub const g_wszWMDMAlbumCoverHeight = "WMDM/AlbumCoverHeight";
pub const g_wszWMDMAlbumCoverWidth = "WMDM/AlbumCoverWidth";
pub const g_wszWMDMAlbumCoverDuration = "WMDM/AlbumCoverDuration";
pub const g_wszWMDMAlbumCoverData = "WMDM/AlbumCoverData";
pub const g_wszWMDMYear = "WMDM/Year";
pub const g_wszWMDMComposer = "WMDM/Composer";
pub const g_wszWMDMCodec = "WMDM/Codec";
pub const g_wszWMDMDRMId = "WMDM/DRMId";
pub const g_wszWMDMBitrate = "WMDM/Bitrate";
pub const g_wszWMDMBitRateType = "WMDM/BitRateType";
pub const g_wszWMDMSampleRate = "WMDM/SampleRate";
pub const g_wszWMDMNumChannels = "WMDM/NumChannels";
pub const g_wszWMDMBlockAlignment = "WMDM/BlockAlignment";
pub const g_wszWMDMAudioBitDepth = "WMDM/AudioBitDepth";
pub const g_wszWMDMTotalBitrate = "WMDM/TotalBitrate";
pub const g_wszWMDMVideoBitrate = "WMDM/VideoBitrate";
pub const g_wszWMDMFrameRate = "WMDM/FrameRate";
pub const g_wszWMDMScanType = "WMDM/ScanType";
pub const g_wszWMDMKeyFrameDistance = "WMDM/KeyFrameDistance";
pub const g_wszWMDMBufferSize = "WMDM/BufferSize";
pub const g_wszWMDMQualitySetting = "WMDM/QualitySetting";
pub const g_wszWMDMEncodingProfile = "WMDM/EncodingProfile";
pub const g_wszWMDMDuration = "WMDM/Duration";
pub const g_wszWMDMAlbumArt = "WMDM/AlbumArt";
pub const g_wszWMDMBuyNow = "WMDM/BuyNow";
pub const g_wszWMDMNonConsumable = "WMDM/NonConsumable";
pub const g_wszWMDMediaClassPrimaryID = "WMDM/MediaClassPrimaryID";
pub const g_wszWMDMMediaClassSecondaryID = "WMDM/MediaClassSecondaryID";
pub const g_wszWMDMUserEffectiveRating = "WMDM/UserEffectiveRating";
pub const g_wszWMDMUserRating = "WMDM/UserRating";
pub const g_wszWMDMUserRatingOnDevice = "WMDM/UserRatingOnDevice";
pub const g_wszWMDMPlayCount = "WMDM/PlayCount";
pub const g_wszWMDMDevicePlayCount = "WMDM/DevicePlayCount";
pub const g_wszWMDMAuthorDate = "WMDM/AuthorDate";
pub const g_wszWMDMUserLastPlayTime = "WMDM/UserLastPlayTime";
pub const g_wszWMDMSubTitle = "WMDM/SubTitle";
pub const g_wszWMDMSubTitleDescription = "WMDM/SubTitleDescription";
pub const g_wszWMDMMediaCredits = "WMDM/MediaCredits";
pub const g_wszWMDMMediaStationName = "WMDM/MediaStationName";
pub const g_wszWMDMMediaOriginalChannel = "WMDM/MediaOriginalChannel";
pub const g_wszWMDMMediaOriginalBroadcastDateTime = "WMDM/MediaOriginalBroadcastDateTime";
pub const g_wszWMDMProviderCopyright = "WMDM/ProviderCopyright";
pub const g_wszWMDMSyncID = "WMDM/SyncID";
pub const g_wszWMDMPersistentUniqueID = "WMDM/PersistentUniqueID";
pub const g_wszWMDMWidth = "WMDM/Width";
pub const g_wszWMDMHeight = "WMDM/Height";
pub const g_wszWMDMSyncTime = "WMDM/SyncTime";
pub const g_wszWMDMParentalRating = "WMDM/ParentalRating";
pub const g_wszWMDMMetaGenre = "WMDM/MetaGenre";
pub const g_wszWMDMIsRepeat = "WMDM/IsRepeat";
pub const g_wszWMDMSupportedDeviceProperties = "WMDM/SupportedDeviceProperties";
pub const g_wszWMDMDeviceFriendlyName = "WMDM/DeviceFriendlyName";
pub const g_wszWMDMFormatsSupported = "WMDM/FormatsSupported";
pub const g_wszWMDMFormatsSupportedAreOrdered = "WMDM/FormatsSupportedAreOrdered";
pub const g_wszWMDMSyncRelationshipID = "WMDM/SyncRelationshipID";
pub const g_wszWMDMDeviceModelName = "WMDM/DeviceModelName";
pub const g_wszWMDMDeviceFirmwareVersion = "WMDM/DeviceFirmwareVersion";
pub const g_wszWMDMDeviceVendorExtension = "WMDM/DeviceVendorExtension";
pub const g_wszWMDMDeviceProtocol = "WMDM/DeviceProtocol";
pub const g_wszWMDMDeviceServiceProviderVendor = "WMDM/DeviceServiceProviderVendor";
pub const g_wszWMDMDeviceRevocationInfo = "WMDM/DeviceRevocationInfo";
pub const g_wszWMDMCollectionID = "WMDM/CollectionID";
pub const g_wszWMDMOwner = "WMDM/Owner";
pub const g_wszWMDMEditor = "WMDM/Editor";
pub const g_wszWMDMWebmaster = "WMDM/Webmaster";
pub const g_wszWMDMSourceURL = "WMDM/SourceURL";
pub const g_wszWMDMDestinationURL = "WMDM/DestinationURL";
pub const g_wszWMDMCategory = "WMDM/Category";
pub const g_wszWMDMTimeBookmark = "WMDM/TimeBookmark";
pub const g_wszWMDMObjectBookmark = "WMDM/ObjectBookmark";
pub const g_wszWMDMByteBookmark = "WMDM/ByteBookmark";
pub const g_wszWMDMDataOffset = "WMDM/DataOffset";
pub const g_wszWMDMDataLength = "WMDM/DataLength";
pub const g_wszWMDMDataUnits = "WMDM/DataUnits";
pub const g_wszWMDMTimeToLive = "WMDM/TimeToLive";
pub const g_wszWMDMMediaGuid = "WMDM/MediaGuid";
pub const g_wszWPDPassthroughPropertyValues = "WPD/PassthroughPropertyValues";
pub const EVENT_WMDM_CONTENT_TRANSFER = Guid.initString("339c9bf4-bcfe-4ed8-94df-eaf8c26ab61b");
pub const MTP_COMMAND_MAX_PARAMS = @as(u32, 5);
pub const MTP_RESPONSE_MAX_PARAMS = @as(u32, 5);
pub const MTP_RESPONSE_OK = @as(u16, 8193);

//--------------------------------------------------------------------------------
// Section: Types (91)
//--------------------------------------------------------------------------------
pub const __MACINFO = extern struct {
    fUsed: BOOL,
    abMacState: [36]u8,
};

const CLSID_MediaDevMgrClassFactory_Value = Guid.initString("50040c1d-bdbf-4924-b873-f14d6c5bfd66");
pub const CLSID_MediaDevMgrClassFactory = &CLSID_MediaDevMgrClassFactory_Value;

const CLSID_MediaDevMgr_Value = Guid.initString("25baad81-3560-11d3-8471-00c04f79dbc0");
pub const CLSID_MediaDevMgr = &CLSID_MediaDevMgr_Value;

const CLSID_WMDMDevice_Value = Guid.initString("807b3cdf-357a-11d3-8471-00c04f79dbc0");
pub const CLSID_WMDMDevice = &CLSID_WMDMDevice_Value;

const CLSID_WMDMStorage_Value = Guid.initString("807b3ce0-357a-11d3-8471-00c04f79dbc0");
pub const CLSID_WMDMStorage = &CLSID_WMDMStorage_Value;

const CLSID_WMDMStorageGlobal_Value = Guid.initString("807b3ce1-357a-11d3-8471-00c04f79dbc0");
pub const CLSID_WMDMStorageGlobal = &CLSID_WMDMStorageGlobal_Value;

const CLSID_WMDMDeviceEnum_Value = Guid.initString("430e35af-3971-11d3-8474-00c04f79dbc0");
pub const CLSID_WMDMDeviceEnum = &CLSID_WMDMDeviceEnum_Value;

const CLSID_WMDMStorageEnum_Value = Guid.initString("eb401a3b-3af7-11d3-8474-00c04f79dbc0");
pub const CLSID_WMDMStorageEnum = &CLSID_WMDMStorageEnum_Value;

pub const WMDM_TAG_DATATYPE = enum(i32) {
    DWORD = 0,
    STRING = 1,
    BINARY = 2,
    BOOL = 3,
    QWORD = 4,
    WORD = 5,
    GUID = 6,
    DATE = 7,
};
pub const WMDM_TYPE_DWORD = WMDM_TAG_DATATYPE.DWORD;
pub const WMDM_TYPE_STRING = WMDM_TAG_DATATYPE.STRING;
pub const WMDM_TYPE_BINARY = WMDM_TAG_DATATYPE.BINARY;
pub const WMDM_TYPE_BOOL = WMDM_TAG_DATATYPE.BOOL;
pub const WMDM_TYPE_QWORD = WMDM_TAG_DATATYPE.QWORD;
pub const WMDM_TYPE_WORD = WMDM_TAG_DATATYPE.WORD;
pub const WMDM_TYPE_GUID = WMDM_TAG_DATATYPE.GUID;
pub const WMDM_TYPE_DATE = WMDM_TAG_DATATYPE.DATE;

pub const WMDM_SESSION_TYPE = enum(i32) {
    NONE = 0,
    TRANSFER_TO_DEVICE = 1,
    TRANSFER_FROM_DEVICE = 16,
    DELETE = 256,
    CUSTOM = 4096,
};
pub const WMDM_SESSION_NONE = WMDM_SESSION_TYPE.NONE;
pub const WMDM_SESSION_TRANSFER_TO_DEVICE = WMDM_SESSION_TYPE.TRANSFER_TO_DEVICE;
pub const WMDM_SESSION_TRANSFER_FROM_DEVICE = WMDM_SESSION_TYPE.TRANSFER_FROM_DEVICE;
pub const WMDM_SESSION_DELETE = WMDM_SESSION_TYPE.DELETE;
pub const WMDM_SESSION_CUSTOM = WMDM_SESSION_TYPE.CUSTOM;

pub const _WAVEFORMATEX = extern struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
    wBitsPerSample: u16,
    cbSize: u16,
};

pub const _BITMAPINFOHEADER = extern struct {
    biSize: u32,
    biWidth: i32,
    biHeight: i32,
    biPlanes: u16,
    biBitCount: u16,
    biCompression: u32,
    biSizeImage: u32,
    biXPelsPerMeter: i32,
    biYPelsPerMeter: i32,
    biClrUsed: u32,
    biClrImportant: u32,
};

pub const _VIDEOINFOHEADER = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: _BITMAPINFOHEADER,
};

pub const WMFILECAPABILITIES = extern struct {
    pwszMimeType: ?PWSTR,
    dwReserved: u32,
};

pub const OPAQUECOMMAND = extern struct {
    guidCommand: Guid,
    dwDataLen: u32,
    pData: ?*u8,
    abMAC: [20]u8,
};

pub const WMDMID = extern struct {
    cbSize: u32,
    dwVendorID: u32,
    pID: [128]u8,
    SerialNumberLength: u32,
};

pub const WMDMDATETIME = extern struct {
    wYear: u16,
    wMonth: u16,
    wDay: u16,
    wHour: u16,
    wMinute: u16,
    wSecond: u16,
};

pub const WMDMRIGHTS = extern struct {
    cbSize: u32,
    dwContentType: u32,
    fuFlags: u32,
    fuRights: u32,
    dwAppSec: u32,
    dwPlaybackCount: u32,
    ExpirationDate: WMDMDATETIME,
};

pub const WMDMMetadataView = extern struct {
    pwszViewName: ?PWSTR,
    nDepth: u32,
    ppwszTags: ?*?*u16,
};

pub const WMDM_STORAGE_ENUM_MODE = enum(i32) {
    RAW = 0,
    USE_DEVICE_PREF = 1,
    METADATA_VIEWS = 2,
};
pub const ENUM_MODE_RAW = WMDM_STORAGE_ENUM_MODE.RAW;
pub const ENUM_MODE_USE_DEVICE_PREF = WMDM_STORAGE_ENUM_MODE.USE_DEVICE_PREF;
pub const ENUM_MODE_METADATA_VIEWS = WMDM_STORAGE_ENUM_MODE.METADATA_VIEWS;

pub const WMDM_FORMATCODE = enum(i32) {
    NOTUSED = 0,
    ALLIMAGES = -1,
    UNDEFINED = 12288,
    ASSOCIATION = 12289,
    SCRIPT = 12290,
    EXECUTABLE = 12291,
    TEXT = 12292,
    HTML = 12293,
    DPOF = 12294,
    AIFF = 12295,
    WAVE = 12296,
    MP3 = 12297,
    AVI = 12298,
    MPEG = 12299,
    ASF = 12300,
    RESERVED_FIRST = 12301,
    RESERVED_LAST = 14335,
    IMAGE_UNDEFINED = 14336,
    IMAGE_EXIF = 14337,
    IMAGE_TIFFEP = 14338,
    IMAGE_FLASHPIX = 14339,
    IMAGE_BMP = 14340,
    IMAGE_CIFF = 14341,
    IMAGE_GIF = 14343,
    IMAGE_JFIF = 14344,
    IMAGE_PCD = 14345,
    IMAGE_PICT = 14346,
    IMAGE_PNG = 14347,
    IMAGE_TIFF = 14349,
    IMAGE_TIFFIT = 14350,
    IMAGE_JP2 = 14351,
    IMAGE_JPX = 14352,
    IMAGE_RESERVED_FIRST = 14353,
    IMAGE_RESERVED_LAST = 16383,
    UNDEFINEDFIRMWARE = 47106,
    WBMP = 47107,
    JPEGXR = 47108,
    WINDOWSIMAGEFORMAT = 47233,
    UNDEFINEDAUDIO = 47360,
    WMA = 47361,
    OGG = 47362,
    AAC = 47363,
    AUDIBLE = 47364,
    FLAC = 47366,
    QCELP = 47367,
    AMR = 47368,
    UNDEFINEDVIDEO = 47488,
    WMV = 47489,
    MP4 = 47490,
    MP2 = 47491,
    @"3GP" = 47492,
    @"3G2" = 47493,
    AVCHD = 47494,
    ATSCTS = 47495,
    DVBTS = 47496,
    MKV = 47497,
    MKA = 47498,
    MK3D = 47499,
    UNDEFINEDCOLLECTION = 47616,
    ABSTRACTMULTIMEDIAALBUM = 47617,
    ABSTRACTIMAGEALBUM = 47618,
    ABSTRACTAUDIOALBUM = 47619,
    ABSTRACTVIDEOALBUM = 47620,
    ABSTRACTAUDIOVIDEOPLAYLIST = 47621,
    ABSTRACTCONTACTGROUP = 47622,
    ABSTRACTMESSAGEFOLDER = 47623,
    ABSTRACTCHAPTEREDPRODUCTION = 47624,
    MEDIA_CAST = 47627,
    WPLPLAYLIST = 47632,
    M3UPLAYLIST = 47633,
    MPLPLAYLIST = 47634,
    ASXPLAYLIST = 47635,
    PLSPLAYLIST = 47636,
    UNDEFINEDDOCUMENT = 47744,
    ABSTRACTDOCUMENT = 47745,
    XMLDOCUMENT = 47746,
    MICROSOFTWORDDOCUMENT = 47747,
    MHTCOMPILEDHTMLDOCUMENT = 47748,
    MICROSOFTEXCELSPREADSHEET = 47749,
    MICROSOFTPOWERPOINTDOCUMENT = 47750,
    UNDEFINEDMESSAGE = 47872,
    ABSTRACTMESSAGE = 47873,
    UNDEFINEDCONTACT = 48000,
    ABSTRACTCONTACT = 48001,
    VCARD2 = 48002,
    VCARD3 = 48003,
    UNDEFINEDCALENDARITEM = 48640,
    ABSTRACTCALENDARITEM = 48641,
    VCALENDAR1 = 48642,
    VCALENDAR2 = 48643,
    UNDEFINEDWINDOWSEXECUTABLE = 48768,
    M4A = 1297101889,
    @"3GPA" = 860311617,
    @"3G2A" = 860303937,
    SECTION = 48770,
};
pub const WMDM_FORMATCODE_NOTUSED = WMDM_FORMATCODE.NOTUSED;
pub const WMDM_FORMATCODE_ALLIMAGES = WMDM_FORMATCODE.ALLIMAGES;
pub const WMDM_FORMATCODE_UNDEFINED = WMDM_FORMATCODE.UNDEFINED;
pub const WMDM_FORMATCODE_ASSOCIATION = WMDM_FORMATCODE.ASSOCIATION;
pub const WMDM_FORMATCODE_SCRIPT = WMDM_FORMATCODE.SCRIPT;
pub const WMDM_FORMATCODE_EXECUTABLE = WMDM_FORMATCODE.EXECUTABLE;
pub const WMDM_FORMATCODE_TEXT = WMDM_FORMATCODE.TEXT;
pub const WMDM_FORMATCODE_HTML = WMDM_FORMATCODE.HTML;
pub const WMDM_FORMATCODE_DPOF = WMDM_FORMATCODE.DPOF;
pub const WMDM_FORMATCODE_AIFF = WMDM_FORMATCODE.AIFF;
pub const WMDM_FORMATCODE_WAVE = WMDM_FORMATCODE.WAVE;
pub const WMDM_FORMATCODE_MP3 = WMDM_FORMATCODE.MP3;
pub const WMDM_FORMATCODE_AVI = WMDM_FORMATCODE.AVI;
pub const WMDM_FORMATCODE_MPEG = WMDM_FORMATCODE.MPEG;
pub const WMDM_FORMATCODE_ASF = WMDM_FORMATCODE.ASF;
pub const WMDM_FORMATCODE_RESERVED_FIRST = WMDM_FORMATCODE.RESERVED_FIRST;
pub const WMDM_FORMATCODE_RESERVED_LAST = WMDM_FORMATCODE.RESERVED_LAST;
pub const WMDM_FORMATCODE_IMAGE_UNDEFINED = WMDM_FORMATCODE.IMAGE_UNDEFINED;
pub const WMDM_FORMATCODE_IMAGE_EXIF = WMDM_FORMATCODE.IMAGE_EXIF;
pub const WMDM_FORMATCODE_IMAGE_TIFFEP = WMDM_FORMATCODE.IMAGE_TIFFEP;
pub const WMDM_FORMATCODE_IMAGE_FLASHPIX = WMDM_FORMATCODE.IMAGE_FLASHPIX;
pub const WMDM_FORMATCODE_IMAGE_BMP = WMDM_FORMATCODE.IMAGE_BMP;
pub const WMDM_FORMATCODE_IMAGE_CIFF = WMDM_FORMATCODE.IMAGE_CIFF;
pub const WMDM_FORMATCODE_IMAGE_GIF = WMDM_FORMATCODE.IMAGE_GIF;
pub const WMDM_FORMATCODE_IMAGE_JFIF = WMDM_FORMATCODE.IMAGE_JFIF;
pub const WMDM_FORMATCODE_IMAGE_PCD = WMDM_FORMATCODE.IMAGE_PCD;
pub const WMDM_FORMATCODE_IMAGE_PICT = WMDM_FORMATCODE.IMAGE_PICT;
pub const WMDM_FORMATCODE_IMAGE_PNG = WMDM_FORMATCODE.IMAGE_PNG;
pub const WMDM_FORMATCODE_IMAGE_TIFF = WMDM_FORMATCODE.IMAGE_TIFF;
pub const WMDM_FORMATCODE_IMAGE_TIFFIT = WMDM_FORMATCODE.IMAGE_TIFFIT;
pub const WMDM_FORMATCODE_IMAGE_JP2 = WMDM_FORMATCODE.IMAGE_JP2;
pub const WMDM_FORMATCODE_IMAGE_JPX = WMDM_FORMATCODE.IMAGE_JPX;
pub const WMDM_FORMATCODE_IMAGE_RESERVED_FIRST = WMDM_FORMATCODE.IMAGE_RESERVED_FIRST;
pub const WMDM_FORMATCODE_IMAGE_RESERVED_LAST = WMDM_FORMATCODE.IMAGE_RESERVED_LAST;
pub const WMDM_FORMATCODE_UNDEFINEDFIRMWARE = WMDM_FORMATCODE.UNDEFINEDFIRMWARE;
pub const WMDM_FORMATCODE_WBMP = WMDM_FORMATCODE.WBMP;
pub const WMDM_FORMATCODE_JPEGXR = WMDM_FORMATCODE.JPEGXR;
pub const WMDM_FORMATCODE_WINDOWSIMAGEFORMAT = WMDM_FORMATCODE.WINDOWSIMAGEFORMAT;
pub const WMDM_FORMATCODE_UNDEFINEDAUDIO = WMDM_FORMATCODE.UNDEFINEDAUDIO;
pub const WMDM_FORMATCODE_WMA = WMDM_FORMATCODE.WMA;
pub const WMDM_FORMATCODE_OGG = WMDM_FORMATCODE.OGG;
pub const WMDM_FORMATCODE_AAC = WMDM_FORMATCODE.AAC;
pub const WMDM_FORMATCODE_AUDIBLE = WMDM_FORMATCODE.AUDIBLE;
pub const WMDM_FORMATCODE_FLAC = WMDM_FORMATCODE.FLAC;
pub const WMDM_FORMATCODE_QCELP = WMDM_FORMATCODE.QCELP;
pub const WMDM_FORMATCODE_AMR = WMDM_FORMATCODE.AMR;
pub const WMDM_FORMATCODE_UNDEFINEDVIDEO = WMDM_FORMATCODE.UNDEFINEDVIDEO;
pub const WMDM_FORMATCODE_WMV = WMDM_FORMATCODE.WMV;
pub const WMDM_FORMATCODE_MP4 = WMDM_FORMATCODE.MP4;
pub const WMDM_FORMATCODE_MP2 = WMDM_FORMATCODE.MP2;
pub const WMDM_FORMATCODE_3GP = WMDM_FORMATCODE.@"3GP";
pub const WMDM_FORMATCODE_3G2 = WMDM_FORMATCODE.@"3G2";
pub const WMDM_FORMATCODE_AVCHD = WMDM_FORMATCODE.AVCHD;
pub const WMDM_FORMATCODE_ATSCTS = WMDM_FORMATCODE.ATSCTS;
pub const WMDM_FORMATCODE_DVBTS = WMDM_FORMATCODE.DVBTS;
pub const WMDM_FORMATCODE_MKV = WMDM_FORMATCODE.MKV;
pub const WMDM_FORMATCODE_MKA = WMDM_FORMATCODE.MKA;
pub const WMDM_FORMATCODE_MK3D = WMDM_FORMATCODE.MK3D;
pub const WMDM_FORMATCODE_UNDEFINEDCOLLECTION = WMDM_FORMATCODE.UNDEFINEDCOLLECTION;
pub const WMDM_FORMATCODE_ABSTRACTMULTIMEDIAALBUM = WMDM_FORMATCODE.ABSTRACTMULTIMEDIAALBUM;
pub const WMDM_FORMATCODE_ABSTRACTIMAGEALBUM = WMDM_FORMATCODE.ABSTRACTIMAGEALBUM;
pub const WMDM_FORMATCODE_ABSTRACTAUDIOALBUM = WMDM_FORMATCODE.ABSTRACTAUDIOALBUM;
pub const WMDM_FORMATCODE_ABSTRACTVIDEOALBUM = WMDM_FORMATCODE.ABSTRACTVIDEOALBUM;
pub const WMDM_FORMATCODE_ABSTRACTAUDIOVIDEOPLAYLIST = WMDM_FORMATCODE.ABSTRACTAUDIOVIDEOPLAYLIST;
pub const WMDM_FORMATCODE_ABSTRACTCONTACTGROUP = WMDM_FORMATCODE.ABSTRACTCONTACTGROUP;
pub const WMDM_FORMATCODE_ABSTRACTMESSAGEFOLDER = WMDM_FORMATCODE.ABSTRACTMESSAGEFOLDER;
pub const WMDM_FORMATCODE_ABSTRACTCHAPTEREDPRODUCTION = WMDM_FORMATCODE.ABSTRACTCHAPTEREDPRODUCTION;
pub const WMDM_FORMATCODE_MEDIA_CAST = WMDM_FORMATCODE.MEDIA_CAST;
pub const WMDM_FORMATCODE_WPLPLAYLIST = WMDM_FORMATCODE.WPLPLAYLIST;
pub const WMDM_FORMATCODE_M3UPLAYLIST = WMDM_FORMATCODE.M3UPLAYLIST;
pub const WMDM_FORMATCODE_MPLPLAYLIST = WMDM_FORMATCODE.MPLPLAYLIST;
pub const WMDM_FORMATCODE_ASXPLAYLIST = WMDM_FORMATCODE.ASXPLAYLIST;
pub const WMDM_FORMATCODE_PLSPLAYLIST = WMDM_FORMATCODE.PLSPLAYLIST;
pub const WMDM_FORMATCODE_UNDEFINEDDOCUMENT = WMDM_FORMATCODE.UNDEFINEDDOCUMENT;
pub const WMDM_FORMATCODE_ABSTRACTDOCUMENT = WMDM_FORMATCODE.ABSTRACTDOCUMENT;
pub const WMDM_FORMATCODE_XMLDOCUMENT = WMDM_FORMATCODE.XMLDOCUMENT;
pub const WMDM_FORMATCODE_MICROSOFTWORDDOCUMENT = WMDM_FORMATCODE.MICROSOFTWORDDOCUMENT;
pub const WMDM_FORMATCODE_MHTCOMPILEDHTMLDOCUMENT = WMDM_FORMATCODE.MHTCOMPILEDHTMLDOCUMENT;
pub const WMDM_FORMATCODE_MICROSOFTEXCELSPREADSHEET = WMDM_FORMATCODE.MICROSOFTEXCELSPREADSHEET;
pub const WMDM_FORMATCODE_MICROSOFTPOWERPOINTDOCUMENT = WMDM_FORMATCODE.MICROSOFTPOWERPOINTDOCUMENT;
pub const WMDM_FORMATCODE_UNDEFINEDMESSAGE = WMDM_FORMATCODE.UNDEFINEDMESSAGE;
pub const WMDM_FORMATCODE_ABSTRACTMESSAGE = WMDM_FORMATCODE.ABSTRACTMESSAGE;
pub const WMDM_FORMATCODE_UNDEFINEDCONTACT = WMDM_FORMATCODE.UNDEFINEDCONTACT;
pub const WMDM_FORMATCODE_ABSTRACTCONTACT = WMDM_FORMATCODE.ABSTRACTCONTACT;
pub const WMDM_FORMATCODE_VCARD2 = WMDM_FORMATCODE.VCARD2;
pub const WMDM_FORMATCODE_VCARD3 = WMDM_FORMATCODE.VCARD3;
pub const WMDM_FORMATCODE_UNDEFINEDCALENDARITEM = WMDM_FORMATCODE.UNDEFINEDCALENDARITEM;
pub const WMDM_FORMATCODE_ABSTRACTCALENDARITEM = WMDM_FORMATCODE.ABSTRACTCALENDARITEM;
pub const WMDM_FORMATCODE_VCALENDAR1 = WMDM_FORMATCODE.VCALENDAR1;
pub const WMDM_FORMATCODE_VCALENDAR2 = WMDM_FORMATCODE.VCALENDAR2;
pub const WMDM_FORMATCODE_UNDEFINEDWINDOWSEXECUTABLE = WMDM_FORMATCODE.UNDEFINEDWINDOWSEXECUTABLE;
pub const WMDM_FORMATCODE_M4A = WMDM_FORMATCODE.M4A;
pub const WMDM_FORMATCODE_3GPA = WMDM_FORMATCODE.@"3GPA";
pub const WMDM_FORMATCODE_3G2A = WMDM_FORMATCODE.@"3G2A";
pub const WMDM_FORMATCODE_SECTION = WMDM_FORMATCODE.SECTION;

pub const WMDM_ENUM_PROP_VALID_VALUES_FORM = enum(i32) {
    ANY = 0,
    RANGE = 1,
    ENUM = 2,
};
pub const WMDM_ENUM_PROP_VALID_VALUES_ANY = WMDM_ENUM_PROP_VALID_VALUES_FORM.ANY;
pub const WMDM_ENUM_PROP_VALID_VALUES_RANGE = WMDM_ENUM_PROP_VALID_VALUES_FORM.RANGE;
pub const WMDM_ENUM_PROP_VALID_VALUES_ENUM = WMDM_ENUM_PROP_VALID_VALUES_FORM.ENUM;

pub const WMDM_PROP_VALUES_RANGE = extern struct {
    rangeMin: PROPVARIANT,
    rangeMax: PROPVARIANT,
    rangeStep: PROPVARIANT,
};

pub const WMDM_PROP_VALUES_ENUM = extern struct {
    cEnumValues: u32,
    pValues: ?*PROPVARIANT,
};

pub const WMDM_PROP_DESC = extern struct {
    pwszPropName: ?PWSTR,
    ValidValuesForm: WMDM_ENUM_PROP_VALID_VALUES_FORM,
    ValidValues: extern union {
        ValidValuesRange: WMDM_PROP_VALUES_RANGE,
        EnumeratedValidValues: WMDM_PROP_VALUES_ENUM,
    },
};

pub const WMDM_PROP_CONFIG = extern struct {
    nPreference: u32,
    nPropDesc: u32,
    pPropDesc: ?*WMDM_PROP_DESC,
};

pub const WMDM_FORMAT_CAPABILITY = extern struct {
    nPropConfig: u32,
    pConfigs: ?*WMDM_PROP_CONFIG,
};

pub const WMDM_FIND_SCOPE = enum(i32) {
    GLOBAL = 0,
    IMMEDIATE_CHILDREN = 1,
};
pub const WMDM_FIND_SCOPE_GLOBAL = WMDM_FIND_SCOPE.GLOBAL;
pub const WMDM_FIND_SCOPE_IMMEDIATE_CHILDREN = WMDM_FIND_SCOPE.IMMEDIATE_CHILDREN;

pub const WMDMMessage = enum(i32) {
    DEVICE_ARRIVAL = 0,
    DEVICE_REMOVAL = 1,
    MEDIA_ARRIVAL = 2,
    MEDIA_REMOVAL = 3,
};
pub const WMDM_MSG_DEVICE_ARRIVAL = WMDMMessage.DEVICE_ARRIVAL;
pub const WMDM_MSG_DEVICE_REMOVAL = WMDMMessage.DEVICE_REMOVAL;
pub const WMDM_MSG_MEDIA_ARRIVAL = WMDMMessage.MEDIA_ARRIVAL;
pub const WMDM_MSG_MEDIA_REMOVAL = WMDMMessage.MEDIA_REMOVAL;

const IID_IWMDMMetaData_Value = Guid.initString("ec3b0663-0951-460a-9a80-0dceed3c043c");
pub const IID_IWMDMMetaData = &IID_IWMDMMetaData_Value;
pub const IWMDMMetaData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMMetaData,
                Type: WMDM_TAG_DATATYPE,
                pwszTagName: ?[*:0]const u16,
                pValue: ?[*:0]u8,
                iLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMMetaData,
                Type: WMDM_TAG_DATATYPE,
                pwszTagName: ?[*:0]const u16,
                pValue: ?[*:0]u8,
                iLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMMetaData,
                pwszTagName: ?[*:0]const u16,
                pType: ?*WMDM_TAG_DATATYPE,
                pValue: ?[*]?*u8,
                pcbLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMMetaData,
                pwszTagName: ?[*:0]const u16,
                pType: ?*WMDM_TAG_DATATYPE,
                pValue: ?[*]?*u8,
                pcbLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMMetaData,
                iIndex: u32,
                ppwszName: ?*?*u16,
                pType: ?*WMDM_TAG_DATATYPE,
                ppValue: ?[*]?*u8,
                pcbLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMMetaData,
                iIndex: u32,
                ppwszName: ?*?*u16,
                pType: ?*WMDM_TAG_DATATYPE,
                ppValue: ?[*]?*u8,
                pcbLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMMetaData,
                iCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMMetaData,
                iCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMMetaData_AddItem(self: *const T, Type: WMDM_TAG_DATATYPE, pwszTagName: ?[*:0]const u16, pValue: ?[*:0]u8, iLength: u32) HRESULT {
                return @as(*const IWMDMMetaData.VTable, @ptrCast(self.vtable)).AddItem(@as(*const IWMDMMetaData, @ptrCast(self)), Type, pwszTagName, pValue, iLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMMetaData_QueryByName(self: *const T, pwszTagName: ?[*:0]const u16, pType: ?*WMDM_TAG_DATATYPE, pValue: ?[*]?*u8, pcbLength: ?*u32) HRESULT {
                return @as(*const IWMDMMetaData.VTable, @ptrCast(self.vtable)).QueryByName(@as(*const IWMDMMetaData, @ptrCast(self)), pwszTagName, pType, pValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMMetaData_QueryByIndex(self: *const T, iIndex: u32, ppwszName: ?*?*u16, pType: ?*WMDM_TAG_DATATYPE, ppValue: ?[*]?*u8, pcbLength: ?*u32) HRESULT {
                return @as(*const IWMDMMetaData.VTable, @ptrCast(self.vtable)).QueryByIndex(@as(*const IWMDMMetaData, @ptrCast(self)), iIndex, ppwszName, pType, ppValue, pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMMetaData_GetItemCount(self: *const T, iCount: ?*u32) HRESULT {
                return @as(*const IWMDMMetaData.VTable, @ptrCast(self.vtable)).GetItemCount(@as(*const IWMDMMetaData, @ptrCast(self)), iCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDeviceManager_Value = Guid.initString("1dcb3a00-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDeviceManager = &IID_IWMDeviceManager_Value;
pub const IWMDeviceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRevision: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager,
                pdwRevision: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager,
                pdwRevision: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDevices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager,
                ppEnumDevice: ?*?*IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager,
                ppEnumDevice: ?*?*IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager_GetRevision(self: *const T, pdwRevision: ?*u32) HRESULT {
                return @as(*const IWMDeviceManager.VTable, @ptrCast(self.vtable)).GetRevision(@as(*const IWMDeviceManager, @ptrCast(self)), pdwRevision);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager_GetDeviceCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IWMDeviceManager.VTable, @ptrCast(self.vtable)).GetDeviceCount(@as(*const IWMDeviceManager, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager_EnumDevices(self: *const T, ppEnumDevice: ?*?*IWMDMEnumDevice) HRESULT {
                return @as(*const IWMDeviceManager.VTable, @ptrCast(self.vtable)).EnumDevices(@as(*const IWMDeviceManager, @ptrCast(self)), ppEnumDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDeviceManager2_Value = Guid.initString("923e5249-8731-4c5b-9b1c-b8b60b6e46af");
pub const IID_IWMDeviceManager2 = &IID_IWMDeviceManager2_Value;
pub const IWMDeviceManager2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDeviceManager.VTable,
        GetDeviceFromCanonicalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager2,
                pwszCanonicalName: ?[*:0]const u16,
                ppDevice: ?*?*IWMDMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager2,
                pwszCanonicalName: ?[*:0]const u16,
                ppDevice: ?*?*IWMDMDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDevices2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager2,
                ppEnumDevice: ?*?*IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager2,
                ppEnumDevice: ?*?*IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reinitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDeviceManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager2_GetDeviceFromCanonicalName(self: *const T, pwszCanonicalName: ?[*:0]const u16, ppDevice: ?*?*IWMDMDevice) HRESULT {
                return @as(*const IWMDeviceManager2.VTable, @ptrCast(self.vtable)).GetDeviceFromCanonicalName(@as(*const IWMDeviceManager2, @ptrCast(self)), pwszCanonicalName, ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager2_EnumDevices2(self: *const T, ppEnumDevice: ?*?*IWMDMEnumDevice) HRESULT {
                return @as(*const IWMDeviceManager2.VTable, @ptrCast(self.vtable)).EnumDevices2(@as(*const IWMDeviceManager2, @ptrCast(self)), ppEnumDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager2_Reinitialize(self: *const T) HRESULT {
                return @as(*const IWMDeviceManager2.VTable, @ptrCast(self.vtable)).Reinitialize(@as(*const IWMDeviceManager2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDeviceManager3_Value = Guid.initString("af185c41-100d-46ed-be2e-9ce8c44594ef");
pub const IID_IWMDeviceManager3 = &IID_IWMDeviceManager3_Value;
pub const IWMDeviceManager3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDeviceManager2.VTable,
        SetDeviceEnumPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDeviceManager3,
                dwEnumPref: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDeviceManager3,
                dwEnumPref: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDeviceManager2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDeviceManager3_SetDeviceEnumPreference(self: *const T, dwEnumPref: u32) HRESULT {
                return @as(*const IWMDeviceManager3.VTable, @ptrCast(self.vtable)).SetDeviceEnumPreference(@as(*const IWMDeviceManager3, @ptrCast(self)), dwEnumPref);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorageGlobals_Value = Guid.initString("1dcb3a07-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMStorageGlobals = &IID_IWMDMStorageGlobals_Value;
pub const IWMDMStorageGlobals = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSerialNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                pSerialNum: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                pSerialNum: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                pdwTotalSizeLow: ?*u32,
                pdwTotalSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                pdwTotalSizeLow: ?*u32,
                pdwTotalSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalFree: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                pdwFreeLow: ?*u32,
                pdwFreeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                pdwFreeLow: ?*u32,
                pdwFreeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalBad: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                pdwBadLow: ?*u32,
                pdwBadHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                pdwBadLow: ?*u32,
                pdwBadHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageGlobals,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageGlobals,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_GetCapabilities(self: *const T, pdwCapabilities: ?*u32) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IWMDMStorageGlobals, @ptrCast(self)), pdwCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_GetSerialNumber(self: *const T, pSerialNum: ?*WMDMID, abMac: ?*u8) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).GetSerialNumber(@as(*const IWMDMStorageGlobals, @ptrCast(self)), pSerialNum, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_GetTotalSize(self: *const T, pdwTotalSizeLow: ?*u32, pdwTotalSizeHigh: ?*u32) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).GetTotalSize(@as(*const IWMDMStorageGlobals, @ptrCast(self)), pdwTotalSizeLow, pdwTotalSizeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_GetTotalFree(self: *const T, pdwFreeLow: ?*u32, pdwFreeHigh: ?*u32) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).GetTotalFree(@as(*const IWMDMStorageGlobals, @ptrCast(self)), pdwFreeLow, pdwFreeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_GetTotalBad(self: *const T, pdwBadLow: ?*u32, pdwBadHigh: ?*u32) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).GetTotalBad(@as(*const IWMDMStorageGlobals, @ptrCast(self)), pdwBadLow, pdwBadHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IWMDMStorageGlobals, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageGlobals_Initialize(self: *const T, fuMode: u32, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IWMDMStorageGlobals.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWMDMStorageGlobals, @ptrCast(self)), fuMode, pProgress);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorage_Value = Guid.initString("1dcb3a06-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMStorage = &IID_IWMDMStorage_Value;
pub const IWMDMStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStorageGlobals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                ppStorageGlobals: ?*?*IWMDMStorageGlobals,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                ppStorageGlobals: ?*?*IWMDMStorageGlobals,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                pdwAttributes: ?*u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                pdwAttributes: ?*u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                pDateTimeUTC: ?*WMDMDATETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                pDateTimeUTC: ?*WMDMDATETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                pdwSizeLow: ?*u32,
                pdwSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                pdwSizeLow: ?*u32,
                pdwSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                pEnumStorage: ?*?*IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                pEnumStorage: ?*?*IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOpaqueCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_SetAttributes(self: *const T, dwAttributes: u32, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).SetAttributes(@as(*const IWMDMStorage, @ptrCast(self)), dwAttributes, pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_GetStorageGlobals(self: *const T, ppStorageGlobals: ?*?*IWMDMStorageGlobals) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).GetStorageGlobals(@as(*const IWMDMStorage, @ptrCast(self)), ppStorageGlobals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_GetAttributes(self: *const T, pdwAttributes: ?*u32, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IWMDMStorage, @ptrCast(self)), pdwAttributes, pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_GetName(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).GetName(@as(*const IWMDMStorage, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_GetDate(self: *const T, pDateTimeUTC: ?*WMDMDATETIME) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).GetDate(@as(*const IWMDMStorage, @ptrCast(self)), pDateTimeUTC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_GetSize(self: *const T, pdwSizeLow: ?*u32, pdwSizeHigh: ?*u32) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IWMDMStorage, @ptrCast(self)), pdwSizeLow, pdwSizeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_GetRights(self: *const T, ppRights: ?[*]?*WMDMRIGHTS, pnRightsCount: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).GetRights(@as(*const IWMDMStorage, @ptrCast(self)), ppRights, pnRightsCount, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_EnumStorage(self: *const T, pEnumStorage: ?*?*IWMDMEnumStorage) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).EnumStorage(@as(*const IWMDMStorage, @ptrCast(self)), pEnumStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage_SendOpaqueCommand(self: *const T, pCommand: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IWMDMStorage.VTable, @ptrCast(self.vtable)).SendOpaqueCommand(@as(*const IWMDMStorage, @ptrCast(self)), pCommand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorage2_Value = Guid.initString("1ed5a144-5cd5-4683-9eff-72cbdb2d9533");
pub const IID_IWMDMStorage2 = &IID_IWMDMStorage2_Value;
pub const IWMDMStorage2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMStorage.VTable,
        GetStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttributes2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage2,
                pdwAttributes: ?*u32,
                pdwAttributesEx: ?*u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage2,
                pdwAttributes: ?*u32,
                pdwAttributesEx: ?*u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMStorage.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage2_GetStorage(self: *const T, pszStorageName: ?[*:0]const u16, ppStorage: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorage2.VTable, @ptrCast(self.vtable)).GetStorage(@as(*const IWMDMStorage2, @ptrCast(self)), pszStorageName, ppStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage2_SetAttributes2(self: *const T, dwAttributes: u32, dwAttributesEx: u32, pFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER) HRESULT {
                return @as(*const IWMDMStorage2.VTable, @ptrCast(self.vtable)).SetAttributes2(@as(*const IWMDMStorage2, @ptrCast(self)), dwAttributes, dwAttributesEx, pFormat, pVideoFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage2_GetAttributes2(self: *const T, pdwAttributes: ?*u32, pdwAttributesEx: ?*u32, pAudioFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER) HRESULT {
                return @as(*const IWMDMStorage2.VTable, @ptrCast(self.vtable)).GetAttributes2(@as(*const IWMDMStorage2, @ptrCast(self)), pdwAttributes, pdwAttributesEx, pAudioFormat, pVideoFormat);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorage3_Value = Guid.initString("97717eea-926a-464e-96a4-247b0216026e");
pub const IID_IWMDMStorage3 = &IID_IWMDMStorage3_Value;
pub const IWMDMStorage3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMStorage2.VTable,
        GetMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage3,
                ppMetadata: ?*?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage3,
                ppMetadata: ?*?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage3,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage3,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEmptyMetadataObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage3,
                ppMetadata: ?*?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage3,
                ppMetadata: ?*?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnumPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage3,
                pMode: ?*WMDM_STORAGE_ENUM_MODE,
                nViews: u32,
                pViews: ?[*]WMDMMetadataView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage3,
                pMode: ?*WMDM_STORAGE_ENUM_MODE,
                nViews: u32,
                pViews: ?[*]WMDMMetadataView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMStorage2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage3_GetMetadata(self: *const T, ppMetadata: ?*?*IWMDMMetaData) HRESULT {
                return @as(*const IWMDMStorage3.VTable, @ptrCast(self.vtable)).GetMetadata(@as(*const IWMDMStorage3, @ptrCast(self)), ppMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage3_SetMetadata(self: *const T, pMetadata: ?*IWMDMMetaData) HRESULT {
                return @as(*const IWMDMStorage3.VTable, @ptrCast(self.vtable)).SetMetadata(@as(*const IWMDMStorage3, @ptrCast(self)), pMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage3_CreateEmptyMetadataObject(self: *const T, ppMetadata: ?*?*IWMDMMetaData) HRESULT {
                return @as(*const IWMDMStorage3.VTable, @ptrCast(self.vtable)).CreateEmptyMetadataObject(@as(*const IWMDMStorage3, @ptrCast(self)), ppMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage3_SetEnumPreference(self: *const T, pMode: ?*WMDM_STORAGE_ENUM_MODE, nViews: u32, pViews: ?[*]WMDMMetadataView) HRESULT {
                return @as(*const IWMDMStorage3.VTable, @ptrCast(self.vtable)).SetEnumPreference(@as(*const IWMDMStorage3, @ptrCast(self)), pMode, nViews, pViews);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorage4_Value = Guid.initString("c225bac5-a03a-40b8-9a23-91cf478c64a6");
pub const IID_IWMDMStorage4 = &IID_IWMDMStorage4_Value;
pub const IWMDMStorage4 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMStorage3.VTable,
        SetReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage4,
                dwRefs: u32,
                ppIWMDMStorage: ?[*]?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage4,
                dwRefs: u32,
                ppIWMDMStorage: ?[*]?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage4,
                pdwRefs: ?*u32,
                pppIWMDMStorage: ?[*]?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage4,
                pdwRefs: ?*u32,
                pppIWMDMStorage: ?[*]?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRightsWithProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage4,
                pIProgressCallback: ?*IWMDMProgress3,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage4,
                pIProgressCallback: ?*IWMDMProgress3,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecifiedMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage4,
                cProperties: u32,
                ppwszPropNames: [*]?PWSTR,
                ppMetadata: ?*?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage4,
                cProperties: u32,
                ppwszPropNames: [*]?PWSTR,
                ppMetadata: ?*?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage4,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage4,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorage4,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorage4,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMStorage3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage4_SetReferences(self: *const T, dwRefs: u32, ppIWMDMStorage: ?[*]?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorage4.VTable, @ptrCast(self.vtable)).SetReferences(@as(*const IWMDMStorage4, @ptrCast(self)), dwRefs, ppIWMDMStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage4_GetReferences(self: *const T, pdwRefs: ?*u32, pppIWMDMStorage: ?[*]?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorage4.VTable, @ptrCast(self.vtable)).GetReferences(@as(*const IWMDMStorage4, @ptrCast(self)), pdwRefs, pppIWMDMStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage4_GetRightsWithProgress(self: *const T, pIProgressCallback: ?*IWMDMProgress3, ppRights: ?[*]?*WMDMRIGHTS, pnRightsCount: ?*u32) HRESULT {
                return @as(*const IWMDMStorage4.VTable, @ptrCast(self.vtable)).GetRightsWithProgress(@as(*const IWMDMStorage4, @ptrCast(self)), pIProgressCallback, ppRights, pnRightsCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage4_GetSpecifiedMetadata(self: *const T, cProperties: u32, ppwszPropNames: [*]?PWSTR, ppMetadata: ?*?*IWMDMMetaData) HRESULT {
                return @as(*const IWMDMStorage4.VTable, @ptrCast(self.vtable)).GetSpecifiedMetadata(@as(*const IWMDMStorage4, @ptrCast(self)), cProperties, ppwszPropNames, ppMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage4_FindStorage(self: *const T, findScope: WMDM_FIND_SCOPE, pwszUniqueID: ?[*:0]const u16, ppStorage: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorage4.VTable, @ptrCast(self.vtable)).FindStorage(@as(*const IWMDMStorage4, @ptrCast(self)), findScope, pwszUniqueID, ppStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorage4_GetParent(self: *const T, ppStorage: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorage4.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IWMDMStorage4, @ptrCast(self)), ppStorage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMOperation_Value = Guid.initString("1dcb3a0b-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMOperation = &IID_IWMDMOperation_Value;
pub const IWMDMOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginWrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                pdwAttributes: ?*u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                pdwAttributes: ?*u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectTotalSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                pdwSize: ?*u32,
                pdwSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                pdwSize: ?*u32,
                pdwSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetObjectTotalSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                dwSize: u32,
                dwSizeHigh: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                dwSize: u32,
                dwSizeHigh: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransferObjectData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation,
                phCompletionCode: ?*HRESULT,
                pNewObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation,
                phCompletionCode: ?*HRESULT,
                pNewObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_BeginRead(self: *const T) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).BeginRead(@as(*const IWMDMOperation, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_BeginWrite(self: *const T) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).BeginWrite(@as(*const IWMDMOperation, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_GetObjectName(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).GetObjectName(@as(*const IWMDMOperation, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_SetObjectName(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).SetObjectName(@as(*const IWMDMOperation, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_GetObjectAttributes(self: *const T, pdwAttributes: ?*u32, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).GetObjectAttributes(@as(*const IWMDMOperation, @ptrCast(self)), pdwAttributes, pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_SetObjectAttributes(self: *const T, dwAttributes: u32, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).SetObjectAttributes(@as(*const IWMDMOperation, @ptrCast(self)), dwAttributes, pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_GetObjectTotalSize(self: *const T, pdwSize: ?*u32, pdwSizeHigh: ?*u32) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).GetObjectTotalSize(@as(*const IWMDMOperation, @ptrCast(self)), pdwSize, pdwSizeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_SetObjectTotalSize(self: *const T, dwSize: u32, dwSizeHigh: u32) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).SetObjectTotalSize(@as(*const IWMDMOperation, @ptrCast(self)), dwSize, dwSizeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_TransferObjectData(self: *const T, pData: [*:0]u8, pdwSize: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).TransferObjectData(@as(*const IWMDMOperation, @ptrCast(self)), pData, pdwSize, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation_End(self: *const T, phCompletionCode: ?*HRESULT, pNewObject: ?*IUnknown) HRESULT {
                return @as(*const IWMDMOperation.VTable, @ptrCast(self.vtable)).End(@as(*const IWMDMOperation, @ptrCast(self)), phCompletionCode, pNewObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMOperation2_Value = Guid.initString("33445b48-7df7-425c-ad8f-0fc6d82f9f75");
pub const IID_IWMDMOperation2 = &IID_IWMDMOperation2_Value;
pub const IWMDMOperation2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMOperation.VTable,
        SetObjectAttributes2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectAttributes2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation2,
                pdwAttributes: ?*u32,
                pdwAttributesEx: ?*u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation2,
                pdwAttributes: ?*u32,
                pdwAttributesEx: ?*u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMOperation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation2_SetObjectAttributes2(self: *const T, dwAttributes: u32, dwAttributesEx: u32, pFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER) HRESULT {
                return @as(*const IWMDMOperation2.VTable, @ptrCast(self.vtable)).SetObjectAttributes2(@as(*const IWMDMOperation2, @ptrCast(self)), dwAttributes, dwAttributesEx, pFormat, pVideoFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation2_GetObjectAttributes2(self: *const T, pdwAttributes: ?*u32, pdwAttributesEx: ?*u32, pAudioFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER) HRESULT {
                return @as(*const IWMDMOperation2.VTable, @ptrCast(self.vtable)).GetObjectAttributes2(@as(*const IWMDMOperation2, @ptrCast(self)), pdwAttributes, pdwAttributesEx, pAudioFormat, pVideoFormat);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMOperation3_Value = Guid.initString("d1f9b46a-9ca8-46d8-9d0f-1ec9bae54919");
pub const IID_IWMDMOperation3 = &IID_IWMDMOperation3_Value;
pub const IWMDMOperation3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMOperation.VTable,
        TransferObjectDataOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMOperation3,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMOperation3,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMOperation.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMOperation3_TransferObjectDataOnClearChannel(self: *const T, pData: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMDMOperation3.VTable, @ptrCast(self.vtable)).TransferObjectDataOnClearChannel(@as(*const IWMDMOperation3, @ptrCast(self)), pData, pdwSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMProgress_Value = Guid.initString("1dcb3a0c-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMProgress = &IID_IWMDMProgress_Value;
pub const IWMDMProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress,
                dwEstimatedTicks: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress,
                dwEstimatedTicks: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Progress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress,
                dwTranspiredTicks: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress,
                dwTranspiredTicks: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress_Begin(self: *const T, dwEstimatedTicks: u32) HRESULT {
                return @as(*const IWMDMProgress.VTable, @ptrCast(self.vtable)).Begin(@as(*const IWMDMProgress, @ptrCast(self)), dwEstimatedTicks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress_Progress(self: *const T, dwTranspiredTicks: u32) HRESULT {
                return @as(*const IWMDMProgress.VTable, @ptrCast(self.vtable)).Progress(@as(*const IWMDMProgress, @ptrCast(self)), dwTranspiredTicks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress_End(self: *const T) HRESULT {
                return @as(*const IWMDMProgress.VTable, @ptrCast(self.vtable)).End(@as(*const IWMDMProgress, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMProgress2_Value = Guid.initString("3a43f550-b383-4e92-b04a-e6bbc660fefc");
pub const IID_IWMDMProgress2 = &IID_IWMDMProgress2_Value;
pub const IWMDMProgress2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMProgress.VTable,
        End2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress2,
                hrCompletionCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress2,
                hrCompletionCode: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMProgress.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress2_End2(self: *const T, hrCompletionCode: HRESULT) HRESULT {
                return @as(*const IWMDMProgress2.VTable, @ptrCast(self.vtable)).End2(@as(*const IWMDMProgress2, @ptrCast(self)), hrCompletionCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMProgress3_Value = Guid.initString("21de01cb-3bb4-4929-b21a-17af3f80f658");
pub const IID_IWMDMProgress3 = &IID_IWMDMProgress3_Value;
pub const IWMDMProgress3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMProgress2.VTable,
        Begin3: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress3,
                EventId: Guid,
                dwEstimatedTicks: u32,
                pContext: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress3,
                EventId: Guid,
                dwEstimatedTicks: u32,
                pContext: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Progress3: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress3,
                EventId: Guid,
                dwTranspiredTicks: u32,
                pContext: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress3,
                EventId: Guid,
                dwTranspiredTicks: u32,
                pContext: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End3: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMProgress3,
                EventId: Guid,
                hrCompletionCode: HRESULT,
                pContext: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMProgress3,
                EventId: Guid,
                hrCompletionCode: HRESULT,
                pContext: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMProgress2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress3_Begin3(self: *const T, EventId: Guid, dwEstimatedTicks: u32, pContext: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IWMDMProgress3.VTable, @ptrCast(self.vtable)).Begin3(@as(*const IWMDMProgress3, @ptrCast(self)), EventId, dwEstimatedTicks, pContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress3_Progress3(self: *const T, EventId: Guid, dwTranspiredTicks: u32, pContext: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IWMDMProgress3.VTable, @ptrCast(self.vtable)).Progress3(@as(*const IWMDMProgress3, @ptrCast(self)), EventId, dwTranspiredTicks, pContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMProgress3_End3(self: *const T, EventId: Guid, hrCompletionCode: HRESULT, pContext: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IWMDMProgress3.VTable, @ptrCast(self.vtable)).End3(@as(*const IWMDMProgress3, @ptrCast(self)), EventId, hrCompletionCode, pContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMDevice_Value = Guid.initString("1dcb3a02-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMDevice = &IID_IWMDMDevice_Value;
pub const IWMDMDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManufacturer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pdwType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pdwType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSerialNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pSerialNumber: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pSerialNumber: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPowerSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pdwPowerSource: ?*u32,
                pdwPercentRemaining: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pdwPowerSource: ?*u32,
                pdwPercentRemaining: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                hIcon: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                hIcon: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                ppEnumStorage: ?*?*IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                ppEnumStorage: ?*?*IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                ppFormatEx: ?[*]?*_WAVEFORMATEX,
                pnFormatCount: ?*u32,
                pppwszMimeType: ?[*]?*?PWSTR,
                pnMimeTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                ppFormatEx: ?[*]?*_WAVEFORMATEX,
                pnFormatCount: ?*u32,
                pppwszMimeType: ?[*]?*?PWSTR,
                pnMimeTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOpaqueCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetName(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetName(@as(*const IWMDMDevice, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetManufacturer(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetManufacturer(@as(*const IWMDMDevice, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetVersion(self: *const T, pdwVersion: ?*u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IWMDMDevice, @ptrCast(self)), pdwVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetType(self: *const T, pdwType: ?*u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetType(@as(*const IWMDMDevice, @ptrCast(self)), pdwType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetSerialNumber(self: *const T, pSerialNumber: ?*WMDMID, abMac: ?*u8) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetSerialNumber(@as(*const IWMDMDevice, @ptrCast(self)), pSerialNumber, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetPowerSource(self: *const T, pdwPowerSource: ?*u32, pdwPercentRemaining: ?*u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetPowerSource(@as(*const IWMDMDevice, @ptrCast(self)), pdwPowerSource, pdwPercentRemaining);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IWMDMDevice, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetDeviceIcon(self: *const T, hIcon: ?*u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetDeviceIcon(@as(*const IWMDMDevice, @ptrCast(self)), hIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_EnumStorage(self: *const T, ppEnumStorage: ?*?*IWMDMEnumStorage) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).EnumStorage(@as(*const IWMDMDevice, @ptrCast(self)), ppEnumStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_GetFormatSupport(self: *const T, ppFormatEx: ?[*]?*_WAVEFORMATEX, pnFormatCount: ?*u32, pppwszMimeType: ?[*]?*?PWSTR, pnMimeTypeCount: ?*u32) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).GetFormatSupport(@as(*const IWMDMDevice, @ptrCast(self)), ppFormatEx, pnFormatCount, pppwszMimeType, pnMimeTypeCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice_SendOpaqueCommand(self: *const T, pCommand: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IWMDMDevice.VTable, @ptrCast(self.vtable)).SendOpaqueCommand(@as(*const IWMDMDevice, @ptrCast(self)), pCommand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMDevice2_Value = Guid.initString("e34f3d37-9d67-4fc1-9252-62d28b2f8b55");
pub const IID_IWMDMDevice2 = &IID_IWMDMDevice2_Value;
pub const IWMDMDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMDevice.VTable,
        GetStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatSupport2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice2,
                dwFlags: u32,
                ppAudioFormatEx: ?[*]?*_WAVEFORMATEX,
                pnAudioFormatCount: ?*u32,
                ppVideoFormatEx: ?[*]?*_VIDEOINFOHEADER,
                pnVideoFormatCount: ?*u32,
                ppFileType: ?[*]?*WMFILECAPABILITIES,
                pnFileTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice2,
                dwFlags: u32,
                ppAudioFormatEx: ?[*]?*_WAVEFORMATEX,
                pnAudioFormatCount: ?*u32,
                ppVideoFormatEx: ?[*]?*_VIDEOINFOHEADER,
                pnVideoFormatCount: ?*u32,
                ppFileType: ?[*]?*WMFILECAPABILITIES,
                pnFileTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecifyPropertyPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice2,
                ppSpecifyPropPages: ?*?*ISpecifyPropertyPages,
                pppUnknowns: ?[*]?*?*IUnknown,
                pcUnks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice2,
                ppSpecifyPropPages: ?*?*ISpecifyPropertyPages,
                pppUnknowns: ?[*]?*?*IUnknown,
                pcUnks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCanonicalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice2,
                pwszPnPName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice2,
                pwszPnPName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMDevice.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice2_GetStorage(self: *const T, pszStorageName: ?[*:0]const u16, ppStorage: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMDevice2.VTable, @ptrCast(self.vtable)).GetStorage(@as(*const IWMDMDevice2, @ptrCast(self)), pszStorageName, ppStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice2_GetFormatSupport2(self: *const T, dwFlags: u32, ppAudioFormatEx: ?[*]?*_WAVEFORMATEX, pnAudioFormatCount: ?*u32, ppVideoFormatEx: ?[*]?*_VIDEOINFOHEADER, pnVideoFormatCount: ?*u32, ppFileType: ?[*]?*WMFILECAPABILITIES, pnFileTypeCount: ?*u32) HRESULT {
                return @as(*const IWMDMDevice2.VTable, @ptrCast(self.vtable)).GetFormatSupport2(@as(*const IWMDMDevice2, @ptrCast(self)), dwFlags, ppAudioFormatEx, pnAudioFormatCount, ppVideoFormatEx, pnVideoFormatCount, ppFileType, pnFileTypeCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice2_GetSpecifyPropertyPages(self: *const T, ppSpecifyPropPages: ?*?*ISpecifyPropertyPages, pppUnknowns: ?[*]?*?*IUnknown, pcUnks: ?*u32) HRESULT {
                return @as(*const IWMDMDevice2.VTable, @ptrCast(self.vtable)).GetSpecifyPropertyPages(@as(*const IWMDMDevice2, @ptrCast(self)), ppSpecifyPropPages, pppUnknowns, pcUnks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice2_GetCanonicalName(self: *const T, pwszPnPName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMDevice2.VTable, @ptrCast(self.vtable)).GetCanonicalName(@as(*const IWMDMDevice2, @ptrCast(self)), pwszPnPName, nMaxChars);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMDevice3_Value = Guid.initString("6c03e4fe-05db-4dda-9e3c-06233a6d5d65");
pub const IID_IWMDMDevice3 = &IID_IWMDMDevice3_Value;
pub const IWMDMDevice3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMDevice2.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice3,
                format: WMDM_FORMATCODE,
                pFormatSupport: ?*WMDM_FORMAT_CAPABILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice3,
                format: WMDM_FORMATCODE,
                pFormatSupport: ?*WMDM_FORMAT_CAPABILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceIoControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice3,
                dwIoControlCode: u32,
                lpInBuffer: [*:0]u8,
                nInBufferSize: u32,
                lpOutBuffer: [*:0]u8,
                pnOutBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice3,
                dwIoControlCode: u32,
                lpInBuffer: [*:0]u8,
                nInBufferSize: u32,
                lpOutBuffer: [*:0]u8,
                pnOutBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDevice3,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDevice3,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMDevice2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice3_GetProperty(self: *const T, pwszPropName: ?[*:0]const u16, pValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IWMDMDevice3.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IWMDMDevice3, @ptrCast(self)), pwszPropName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice3_SetProperty(self: *const T, pwszPropName: ?[*:0]const u16, pValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IWMDMDevice3.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IWMDMDevice3, @ptrCast(self)), pwszPropName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice3_GetFormatCapability(self: *const T, format: WMDM_FORMATCODE, pFormatSupport: ?*WMDM_FORMAT_CAPABILITY) HRESULT {
                return @as(*const IWMDMDevice3.VTable, @ptrCast(self.vtable)).GetFormatCapability(@as(*const IWMDMDevice3, @ptrCast(self)), format, pFormatSupport);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice3_DeviceIoControl(self: *const T, dwIoControlCode: u32, lpInBuffer: [*:0]u8, nInBufferSize: u32, lpOutBuffer: [*:0]u8, pnOutBufferSize: ?*u32) HRESULT {
                return @as(*const IWMDMDevice3.VTable, @ptrCast(self.vtable)).DeviceIoControl(@as(*const IWMDMDevice3, @ptrCast(self)), dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, pnOutBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDevice3_FindStorage(self: *const T, findScope: WMDM_FIND_SCOPE, pwszUniqueID: ?[*:0]const u16, ppStorage: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMDevice3.VTable, @ptrCast(self.vtable)).FindStorage(@as(*const IWMDMDevice3, @ptrCast(self)), findScope, pwszUniqueID, ppStorage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMDeviceSession_Value = Guid.initString("82af0a65-9d96-412c-83e5-3c43e4b06cc7");
pub const IID_IWMDMDeviceSession = &IID_IWMDMDeviceSession_Value;
pub const IWMDMDeviceSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceSession,
                type: WMDM_SESSION_TYPE,
                pCtx: ?[*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceSession,
                type: WMDM_SESSION_TYPE,
                pCtx: ?[*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceSession,
                type: WMDM_SESSION_TYPE,
                pCtx: ?[*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceSession,
                type: WMDM_SESSION_TYPE,
                pCtx: ?[*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceSession_BeginSession(self: *const T, type_: WMDM_SESSION_TYPE, pCtx: ?[*:0]u8, dwSizeCtx: u32) HRESULT {
                return @as(*const IWMDMDeviceSession.VTable, @ptrCast(self.vtable)).BeginSession(@as(*const IWMDMDeviceSession, @ptrCast(self)), type_, pCtx, dwSizeCtx);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceSession_EndSession(self: *const T, type_: WMDM_SESSION_TYPE, pCtx: ?[*:0]u8, dwSizeCtx: u32) HRESULT {
                return @as(*const IWMDMDeviceSession.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IWMDMDeviceSession, @ptrCast(self)), type_, pCtx, dwSizeCtx);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMEnumDevice_Value = Guid.initString("1dcb3a01-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMEnumDevice = &IID_IWMDMEnumDevice_Value;
pub const IWMDMEnumDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumDevice,
                celt: u32,
                ppDevice: [*]?*IWMDMDevice,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumDevice,
                celt: u32,
                ppDevice: [*]?*IWMDMDevice,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumDevice,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumDevice,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumDevice,
                ppEnumDevice: ?*?*IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumDevice,
                ppEnumDevice: ?*?*IWMDMEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumDevice_Next(self: *const T, celt: u32, ppDevice: [*]?*IWMDMDevice, pceltFetched: ?*u32) HRESULT {
                return @as(*const IWMDMEnumDevice.VTable, @ptrCast(self.vtable)).Next(@as(*const IWMDMEnumDevice, @ptrCast(self)), celt, ppDevice, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumDevice_Skip(self: *const T, celt: u32, pceltFetched: ?*u32) HRESULT {
                return @as(*const IWMDMEnumDevice.VTable, @ptrCast(self.vtable)).Skip(@as(*const IWMDMEnumDevice, @ptrCast(self)), celt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumDevice_Reset(self: *const T) HRESULT {
                return @as(*const IWMDMEnumDevice.VTable, @ptrCast(self.vtable)).Reset(@as(*const IWMDMEnumDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumDevice_Clone(self: *const T, ppEnumDevice: ?*?*IWMDMEnumDevice) HRESULT {
                return @as(*const IWMDMEnumDevice.VTable, @ptrCast(self.vtable)).Clone(@as(*const IWMDMEnumDevice, @ptrCast(self)), ppEnumDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMDeviceControl_Value = Guid.initString("1dcb3a04-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMDeviceControl = &IID_IWMDMDeviceControl_Value;
pub const IWMDMDeviceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
                pdwCapabilitiesMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
                pdwCapabilitiesMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Play: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Record: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMDeviceControl,
                fuMode: u32,
                nOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMDeviceControl,
                fuMode: u32,
                nOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IWMDMDeviceControl, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_GetCapabilities(self: *const T, pdwCapabilitiesMask: ?*u32) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IWMDMDeviceControl, @ptrCast(self)), pdwCapabilitiesMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_Play(self: *const T) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).Play(@as(*const IWMDMDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_Record(self: *const T, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).Record(@as(*const IWMDMDeviceControl, @ptrCast(self)), pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_Pause(self: *const T) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).Pause(@as(*const IWMDMDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_Resume(self: *const T) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).Resume(@as(*const IWMDMDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_Stop(self: *const T) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IWMDMDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMDeviceControl_Seek(self: *const T, fuMode: u32, nOffset: i32) HRESULT {
                return @as(*const IWMDMDeviceControl.VTable, @ptrCast(self.vtable)).Seek(@as(*const IWMDMDeviceControl, @ptrCast(self)), fuMode, nOffset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMEnumStorage_Value = Guid.initString("1dcb3a05-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMEnumStorage = &IID_IWMDMEnumStorage_Value;
pub const IWMDMEnumStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumStorage,
                celt: u32,
                ppStorage: [*]?*IWMDMStorage,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumStorage,
                celt: u32,
                ppStorage: [*]?*IWMDMStorage,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumStorage,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumStorage,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMEnumStorage,
                ppEnumStorage: ?*?*IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMEnumStorage,
                ppEnumStorage: ?*?*IWMDMEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumStorage_Next(self: *const T, celt: u32, ppStorage: [*]?*IWMDMStorage, pceltFetched: ?*u32) HRESULT {
                return @as(*const IWMDMEnumStorage.VTable, @ptrCast(self.vtable)).Next(@as(*const IWMDMEnumStorage, @ptrCast(self)), celt, ppStorage, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumStorage_Skip(self: *const T, celt: u32, pceltFetched: ?*u32) HRESULT {
                return @as(*const IWMDMEnumStorage.VTable, @ptrCast(self.vtable)).Skip(@as(*const IWMDMEnumStorage, @ptrCast(self)), celt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumStorage_Reset(self: *const T) HRESULT {
                return @as(*const IWMDMEnumStorage.VTable, @ptrCast(self.vtable)).Reset(@as(*const IWMDMEnumStorage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMEnumStorage_Clone(self: *const T, ppEnumStorage: ?*?*IWMDMEnumStorage) HRESULT {
                return @as(*const IWMDMEnumStorage.VTable, @ptrCast(self.vtable)).Clone(@as(*const IWMDMEnumStorage, @ptrCast(self)), ppEnumStorage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorageControl_Value = Guid.initString("1dcb3a08-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMStorageControl = &IID_IWMDMStorageControl_Value;
pub const IWMDMStorageControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Insert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pwszFile: ?PWSTR,
                pOperation: ?*IWMDMOperation,
                pProgress: ?*IWMDMProgress,
                ppNewObject: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pwszFile: ?PWSTR,
                pOperation: ?*IWMDMOperation,
                pProgress: ?*IWMDMProgress,
                ppNewObject: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pwszNewName: ?PWSTR,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pwszNewName: ?PWSTR,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pwszFile: ?PWSTR,
                pProgress: ?*IWMDMProgress,
                pOperation: ?*IWMDMOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pwszFile: ?PWSTR,
                pProgress: ?*IWMDMProgress,
                pOperation: ?*IWMDMOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pTargetObject: ?*IWMDMStorage,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl,
                fuMode: u32,
                pTargetObject: ?*IWMDMStorage,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl_Insert(self: *const T, fuMode: u32, pwszFile: ?PWSTR, pOperation: ?*IWMDMOperation, pProgress: ?*IWMDMProgress, ppNewObject: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorageControl.VTable, @ptrCast(self.vtable)).Insert(@as(*const IWMDMStorageControl, @ptrCast(self)), fuMode, pwszFile, pOperation, pProgress, ppNewObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl_Delete(self: *const T, fuMode: u32, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IWMDMStorageControl.VTable, @ptrCast(self.vtable)).Delete(@as(*const IWMDMStorageControl, @ptrCast(self)), fuMode, pProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl_Rename(self: *const T, fuMode: u32, pwszNewName: ?PWSTR, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IWMDMStorageControl.VTable, @ptrCast(self.vtable)).Rename(@as(*const IWMDMStorageControl, @ptrCast(self)), fuMode, pwszNewName, pProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl_Read(self: *const T, fuMode: u32, pwszFile: ?PWSTR, pProgress: ?*IWMDMProgress, pOperation: ?*IWMDMOperation) HRESULT {
                return @as(*const IWMDMStorageControl.VTable, @ptrCast(self.vtable)).Read(@as(*const IWMDMStorageControl, @ptrCast(self)), fuMode, pwszFile, pProgress, pOperation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl_Move(self: *const T, fuMode: u32, pTargetObject: ?*IWMDMStorage, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IWMDMStorageControl.VTable, @ptrCast(self.vtable)).Move(@as(*const IWMDMStorageControl, @ptrCast(self)), fuMode, pTargetObject, pProgress);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorageControl2_Value = Guid.initString("972c2e88-bd6c-4125-8e09-84f837e637b6");
pub const IID_IWMDMStorageControl2 = &IID_IWMDMStorageControl2_Value;
pub const IWMDMStorageControl2 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMStorageControl.VTable,
        Insert2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl2,
                fuMode: u32,
                pwszFileSource: ?PWSTR,
                pwszFileDest: ?PWSTR,
                pOperation: ?*IWMDMOperation,
                pProgress: ?*IWMDMProgress,
                pUnknown: ?*IUnknown,
                ppNewObject: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl2,
                fuMode: u32,
                pwszFileSource: ?PWSTR,
                pwszFileDest: ?PWSTR,
                pOperation: ?*IWMDMOperation,
                pProgress: ?*IWMDMProgress,
                pUnknown: ?*IUnknown,
                ppNewObject: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMStorageControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl2_Insert2(self: *const T, fuMode: u32, pwszFileSource: ?PWSTR, pwszFileDest: ?PWSTR, pOperation: ?*IWMDMOperation, pProgress: ?*IWMDMProgress, pUnknown: ?*IUnknown, ppNewObject: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorageControl2.VTable, @ptrCast(self.vtable)).Insert2(@as(*const IWMDMStorageControl2, @ptrCast(self)), fuMode, pwszFileSource, pwszFileDest, pOperation, pProgress, pUnknown, ppNewObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMStorageControl3_Value = Guid.initString("b3266365-d4f3-4696-8d53-bd27ec60993a");
pub const IID_IWMDMStorageControl3 = &IID_IWMDMStorageControl3_Value;
pub const IWMDMStorageControl3 = extern struct {
    pub const VTable = extern struct {
        base: IWMDMStorageControl2.VTable,
        Insert3: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMStorageControl3,
                fuMode: u32,
                fuType: u32,
                pwszFileSource: ?PWSTR,
                pwszFileDest: ?PWSTR,
                pOperation: ?*IWMDMOperation,
                pProgress: ?*IWMDMProgress,
                pMetaData: ?*IWMDMMetaData,
                pUnknown: ?*IUnknown,
                ppNewObject: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMStorageControl3,
                fuMode: u32,
                fuType: u32,
                pwszFileSource: ?PWSTR,
                pwszFileDest: ?PWSTR,
                pOperation: ?*IWMDMOperation,
                pProgress: ?*IWMDMProgress,
                pMetaData: ?*IWMDMMetaData,
                pUnknown: ?*IUnknown,
                ppNewObject: ?*?*IWMDMStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMDMStorageControl2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMStorageControl3_Insert3(self: *const T, fuMode: u32, fuType: u32, pwszFileSource: ?PWSTR, pwszFileDest: ?PWSTR, pOperation: ?*IWMDMOperation, pProgress: ?*IWMDMProgress, pMetaData: ?*IWMDMMetaData, pUnknown: ?*IUnknown, ppNewObject: ?*?*IWMDMStorage) HRESULT {
                return @as(*const IWMDMStorageControl3.VTable, @ptrCast(self.vtable)).Insert3(@as(*const IWMDMStorageControl3, @ptrCast(self)), fuMode, fuType, pwszFileSource, pwszFileDest, pOperation, pProgress, pMetaData, pUnknown, ppNewObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMObjectInfo_Value = Guid.initString("1dcb3a09-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IWMDMObjectInfo = &IID_IWMDMObjectInfo_Value;
pub const IWMDMObjectInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPlayLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                pdwOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                pdwOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                dwOffset: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                dwOffset: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastPlayPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                pdwLastPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                pdwLastPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLongestPlayPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMObjectInfo,
                pdwLongestPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMObjectInfo,
                pdwLongestPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_GetPlayLength(self: *const T, pdwLength: ?*u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).GetPlayLength(@as(*const IWMDMObjectInfo, @ptrCast(self)), pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_SetPlayLength(self: *const T, dwLength: u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).SetPlayLength(@as(*const IWMDMObjectInfo, @ptrCast(self)), dwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_GetPlayOffset(self: *const T, pdwOffset: ?*u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).GetPlayOffset(@as(*const IWMDMObjectInfo, @ptrCast(self)), pdwOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_SetPlayOffset(self: *const T, dwOffset: u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).SetPlayOffset(@as(*const IWMDMObjectInfo, @ptrCast(self)), dwOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_GetTotalLength(self: *const T, pdwLength: ?*u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).GetTotalLength(@as(*const IWMDMObjectInfo, @ptrCast(self)), pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_GetLastPlayPosition(self: *const T, pdwLastPos: ?*u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).GetLastPlayPosition(@as(*const IWMDMObjectInfo, @ptrCast(self)), pdwLastPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMObjectInfo_GetLongestPlayPosition(self: *const T, pdwLongestPos: ?*u32) HRESULT {
                return @as(*const IWMDMObjectInfo.VTable, @ptrCast(self.vtable)).GetLongestPlayPosition(@as(*const IWMDMObjectInfo, @ptrCast(self)), pdwLongestPos);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMRevoked_Value = Guid.initString("ebeccedb-88ee-4e55-b6a4-8d9f07d696aa");
pub const IID_IWMDMRevoked = &IID_IWMDMRevoked_Value;
pub const IWMDMRevoked = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRevocationURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMRevoked,
                ppwszRevocationURL: ?[*]?PWSTR,
                pdwBufferLen: ?*u32,
                pdwRevokedBitFlag: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMRevoked,
                ppwszRevocationURL: ?[*]?PWSTR,
                pdwBufferLen: ?*u32,
                pdwRevokedBitFlag: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMRevoked_GetRevocationURL(self: *const T, ppwszRevocationURL: ?[*]?PWSTR, pdwBufferLen: ?*u32, pdwRevokedBitFlag: ?*u32) HRESULT {
                return @as(*const IWMDMRevoked.VTable, @ptrCast(self.vtable)).GetRevocationURL(@as(*const IWMDMRevoked, @ptrCast(self)), ppwszRevocationURL, pdwBufferLen, pdwRevokedBitFlag);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMDMNotification_Value = Guid.initString("3f5e95c0-0f43-4ed4-93d2-c89a45d59b81");
pub const IID_IWMDMNotification = &IID_IWMDMNotification_Value;
pub const IWMDMNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WMDMMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMNotification,
                dwMessageType: u32,
                pwszCanonicalName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMNotification,
                dwMessageType: u32,
                pwszCanonicalName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMNotification_WMDMMessage(self: *const T, dwMessageType: u32, pwszCanonicalName: ?[*:0]const u16) HRESULT {
                return @as(*const IWMDMNotification.VTable, @ptrCast(self.vtable)).WMDMMessage(@as(*const IWMDMNotification, @ptrCast(self)), dwMessageType, pwszCanonicalName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMDMDetermineMaxPropStringLen = extern union {
    sz001: [27]u16,
    sz002: [31]u16,
    sz003: [14]u16,
    sz004: [16]u16,
    sz005: [22]u16,
    sz006: [14]u16,
    sz007: [20]u16,
    sz008: [20]u16,
    sz009: [22]u16,
    sz010: [11]u16,
    sz011: [12]u16,
    sz012: [17]u16,
    sz013: [17]u16,
    sz014: [16]u16,
    sz015: [17]u16,
    sz016: [11]u16,
    sz017: [11]u16,
    sz018: [15]u16,
    sz019: [22]u16,
    sz020: [20]u16,
    sz021: [22]u16,
    sz022: [21]u16,
    sz023: [24]u16,
    sz024: [20]u16,
    sz025: [10]u16,
    sz026: [14]u16,
    sz027: [11]u16,
    sz028: [11]u16,
    sz029: [13]u16,
    sz030: [17]u16,
    sz031: [16]u16,
    sz032: [17]u16,
    sz033: [20]u16,
    sz034: [19]u16,
    sz035: [18]u16,
    sz036: [18]u16,
    sz037: [15]u16,
    sz041: [14]u16,
    sz043: [22]u16,
    sz044: [16]u16,
    sz045: [20]u16,
    sz046: [14]u16,
    sz047: [14]u16,
    sz048: [12]u16,
    sz049: [25]u16,
    sz050: [26]u16,
    sz051: [25]u16,
    sz052: [16]u16,
    sz053: [24]u16,
    sz054: [15]u16,
    sz055: [21]u16,
    sz056: [16]u16,
    sz057: [22]u16,
    sz058: [14]u16,
    sz059: [25]u16,
    sz060: [18]u16,
    sz061: [22]u16,
    sz062: [26]u16,
    sz063: [36]u16,
    sz064: [23]u16,
    sz065: [12]u16,
    sz066: [24]u16,
    sz067: [11]u16,
    sz068: [12]u16,
    sz069: [14]u16,
    sz070: [20]u16,
    sz071: [15]u16,
    sz072: [14]u16,
    sz073: [31]u16,
    sz074: [24]u16,
    sz075: [22]u16,
    sz076: [24]u16,
    sz077: [21]u16,
    sz078: [27]u16,
    sz079: [27]u16,
    sz080: [20]u16,
    sz081: [33]u16,
    sz082: [21]u16,
    sz083: [32]u16,
    sz084: [26]u16,
    sz085: [18]u16,
    sz086: [30]u16,
};

const IID_IMDServiceProvider_Value = Guid.initString("1dcb3a10-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDServiceProvider = &IID_IMDServiceProvider_Value;
pub const IMDServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDServiceProvider,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDServiceProvider,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDevices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDServiceProvider,
                ppEnumDevice: ?*?*IMDSPEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDServiceProvider,
                ppEnumDevice: ?*?*IMDSPEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDServiceProvider_GetDeviceCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMDServiceProvider.VTable, @ptrCast(self.vtable)).GetDeviceCount(@as(*const IMDServiceProvider, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDServiceProvider_EnumDevices(self: *const T, ppEnumDevice: ?*?*IMDSPEnumDevice) HRESULT {
                return @as(*const IMDServiceProvider.VTable, @ptrCast(self.vtable)).EnumDevices(@as(*const IMDServiceProvider, @ptrCast(self)), ppEnumDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDServiceProvider2_Value = Guid.initString("b2fa24b7-cda3-4694-9862-413ae1a34819");
pub const IID_IMDServiceProvider2 = &IID_IMDServiceProvider2_Value;
pub const IMDServiceProvider2 = extern struct {
    pub const VTable = extern struct {
        base: IMDServiceProvider.VTable,
        CreateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDServiceProvider2,
                pwszDevicePath: ?[*:0]const u16,
                pdwCount: ?*u32,
                pppDeviceArray: ?[*]?*?*IMDSPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDServiceProvider2,
                pwszDevicePath: ?[*:0]const u16,
                pdwCount: ?*u32,
                pppDeviceArray: ?[*]?*?*IMDSPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDServiceProvider.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDServiceProvider2_CreateDevice(self: *const T, pwszDevicePath: ?[*:0]const u16, pdwCount: ?*u32, pppDeviceArray: ?[*]?*?*IMDSPDevice) HRESULT {
                return @as(*const IMDServiceProvider2.VTable, @ptrCast(self.vtable)).CreateDevice(@as(*const IMDServiceProvider2, @ptrCast(self)), pwszDevicePath, pdwCount, pppDeviceArray);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDServiceProvider3_Value = Guid.initString("4ed13ef3-a971-4d19-9f51-0e1826b2da57");
pub const IID_IMDServiceProvider3 = &IID_IMDServiceProvider3_Value;
pub const IMDServiceProvider3 = extern struct {
    pub const VTable = extern struct {
        base: IMDServiceProvider2.VTable,
        SetDeviceEnumPreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDServiceProvider3,
                dwEnumPref: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDServiceProvider3,
                dwEnumPref: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDServiceProvider2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDServiceProvider3_SetDeviceEnumPreference(self: *const T, dwEnumPref: u32) HRESULT {
                return @as(*const IMDServiceProvider3.VTable, @ptrCast(self.vtable)).SetDeviceEnumPreference(@as(*const IMDServiceProvider3, @ptrCast(self)), dwEnumPref);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPEnumDevice_Value = Guid.initString("1dcb3a11-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPEnumDevice = &IID_IMDSPEnumDevice_Value;
pub const IMDSPEnumDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumDevice,
                celt: u32,
                ppDevice: [*]?*IMDSPDevice,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumDevice,
                celt: u32,
                ppDevice: [*]?*IMDSPDevice,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumDevice,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumDevice,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumDevice,
                ppEnumDevice: ?*?*IMDSPEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumDevice,
                ppEnumDevice: ?*?*IMDSPEnumDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumDevice_Next(self: *const T, celt: u32, ppDevice: [*]?*IMDSPDevice, pceltFetched: ?*u32) HRESULT {
                return @as(*const IMDSPEnumDevice.VTable, @ptrCast(self.vtable)).Next(@as(*const IMDSPEnumDevice, @ptrCast(self)), celt, ppDevice, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumDevice_Skip(self: *const T, celt: u32, pceltFetched: ?*u32) HRESULT {
                return @as(*const IMDSPEnumDevice.VTable, @ptrCast(self.vtable)).Skip(@as(*const IMDSPEnumDevice, @ptrCast(self)), celt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumDevice_Reset(self: *const T) HRESULT {
                return @as(*const IMDSPEnumDevice.VTable, @ptrCast(self.vtable)).Reset(@as(*const IMDSPEnumDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumDevice_Clone(self: *const T, ppEnumDevice: ?*?*IMDSPEnumDevice) HRESULT {
                return @as(*const IMDSPEnumDevice.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMDSPEnumDevice, @ptrCast(self)), ppEnumDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPDevice_Value = Guid.initString("1dcb3a12-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPDevice = &IID_IMDSPDevice_Value;
pub const IMDSPDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManufacturer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pdwType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pdwType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSerialNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pSerialNumber: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pSerialNumber: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPowerSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pdwPowerSource: ?*u32,
                pdwPercentRemaining: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pdwPowerSource: ?*u32,
                pdwPercentRemaining: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                hIcon: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                hIcon: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                ppEnumStorage: ?*?*IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                ppEnumStorage: ?*?*IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pFormatEx: ?[*]?*_WAVEFORMATEX,
                pnFormatCount: ?*u32,
                pppwszMimeType: ?[*]?*?PWSTR,
                pnMimeTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pFormatEx: ?[*]?*_WAVEFORMATEX,
                pnFormatCount: ?*u32,
                pppwszMimeType: ?[*]?*?PWSTR,
                pnMimeTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOpaqueCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetName(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetName(@as(*const IMDSPDevice, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetManufacturer(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetManufacturer(@as(*const IMDSPDevice, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetVersion(self: *const T, pdwVersion: ?*u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IMDSPDevice, @ptrCast(self)), pdwVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetType(self: *const T, pdwType: ?*u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetType(@as(*const IMDSPDevice, @ptrCast(self)), pdwType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetSerialNumber(self: *const T, pSerialNumber: ?*WMDMID, abMac: ?*u8) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetSerialNumber(@as(*const IMDSPDevice, @ptrCast(self)), pSerialNumber, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetPowerSource(self: *const T, pdwPowerSource: ?*u32, pdwPercentRemaining: ?*u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetPowerSource(@as(*const IMDSPDevice, @ptrCast(self)), pdwPowerSource, pdwPercentRemaining);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMDSPDevice, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetDeviceIcon(self: *const T, hIcon: ?*u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetDeviceIcon(@as(*const IMDSPDevice, @ptrCast(self)), hIcon);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_EnumStorage(self: *const T, ppEnumStorage: ?*?*IMDSPEnumStorage) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).EnumStorage(@as(*const IMDSPDevice, @ptrCast(self)), ppEnumStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_GetFormatSupport(self: *const T, pFormatEx: ?[*]?*_WAVEFORMATEX, pnFormatCount: ?*u32, pppwszMimeType: ?[*]?*?PWSTR, pnMimeTypeCount: ?*u32) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).GetFormatSupport(@as(*const IMDSPDevice, @ptrCast(self)), pFormatEx, pnFormatCount, pppwszMimeType, pnMimeTypeCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice_SendOpaqueCommand(self: *const T, pCommand: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IMDSPDevice.VTable, @ptrCast(self.vtable)).SendOpaqueCommand(@as(*const IMDSPDevice, @ptrCast(self)), pCommand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPDevice2_Value = Guid.initString("420d16ad-c97d-4e00-82aa-00e9f4335ddd");
pub const IID_IMDSPDevice2 = &IID_IMDSPDevice2_Value;
pub const IMDSPDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IMDSPDevice.VTable,
        GetStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatSupport2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice2,
                dwFlags: u32,
                ppAudioFormatEx: ?[*]?*_WAVEFORMATEX,
                pnAudioFormatCount: ?*u32,
                ppVideoFormatEx: ?[*]?*_VIDEOINFOHEADER,
                pnVideoFormatCount: ?*u32,
                ppFileType: ?[*]?*WMFILECAPABILITIES,
                pnFileTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice2,
                dwFlags: u32,
                ppAudioFormatEx: ?[*]?*_WAVEFORMATEX,
                pnAudioFormatCount: ?*u32,
                ppVideoFormatEx: ?[*]?*_VIDEOINFOHEADER,
                pnVideoFormatCount: ?*u32,
                ppFileType: ?[*]?*WMFILECAPABILITIES,
                pnFileTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecifyPropertyPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice2,
                ppSpecifyPropPages: ?*?*ISpecifyPropertyPages,
                pppUnknowns: ?[*]?*?*IUnknown,
                pcUnks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice2,
                ppSpecifyPropPages: ?*?*ISpecifyPropertyPages,
                pppUnknowns: ?[*]?*?*IUnknown,
                pcUnks: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCanonicalName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice2,
                pwszPnPName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice2,
                pwszPnPName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDSPDevice.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice2_GetStorage(self: *const T, pszStorageName: ?[*:0]const u16, ppStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPDevice2.VTable, @ptrCast(self.vtable)).GetStorage(@as(*const IMDSPDevice2, @ptrCast(self)), pszStorageName, ppStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice2_GetFormatSupport2(self: *const T, dwFlags: u32, ppAudioFormatEx: ?[*]?*_WAVEFORMATEX, pnAudioFormatCount: ?*u32, ppVideoFormatEx: ?[*]?*_VIDEOINFOHEADER, pnVideoFormatCount: ?*u32, ppFileType: ?[*]?*WMFILECAPABILITIES, pnFileTypeCount: ?*u32) HRESULT {
                return @as(*const IMDSPDevice2.VTable, @ptrCast(self.vtable)).GetFormatSupport2(@as(*const IMDSPDevice2, @ptrCast(self)), dwFlags, ppAudioFormatEx, pnAudioFormatCount, ppVideoFormatEx, pnVideoFormatCount, ppFileType, pnFileTypeCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice2_GetSpecifyPropertyPages(self: *const T, ppSpecifyPropPages: ?*?*ISpecifyPropertyPages, pppUnknowns: ?[*]?*?*IUnknown, pcUnks: ?*u32) HRESULT {
                return @as(*const IMDSPDevice2.VTable, @ptrCast(self.vtable)).GetSpecifyPropertyPages(@as(*const IMDSPDevice2, @ptrCast(self)), ppSpecifyPropPages, pppUnknowns, pcUnks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice2_GetCanonicalName(self: *const T, pwszPnPName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IMDSPDevice2.VTable, @ptrCast(self.vtable)).GetCanonicalName(@as(*const IMDSPDevice2, @ptrCast(self)), pwszPnPName, nMaxChars);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPDevice3_Value = Guid.initString("1a839845-fc55-487c-976f-ee38ac0e8c4e");
pub const IID_IMDSPDevice3 = &IID_IMDSPDevice3_Value;
pub const IMDSPDevice3 = extern struct {
    pub const VTable = extern struct {
        base: IMDSPDevice2.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice3,
                pwszPropName: ?[*:0]const u16,
                pValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormatCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice3,
                format: WMDM_FORMATCODE,
                pFormatSupport: ?*WMDM_FORMAT_CAPABILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice3,
                format: WMDM_FORMATCODE,
                pFormatSupport: ?*WMDM_FORMAT_CAPABILITY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeviceIoControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice3,
                dwIoControlCode: u32,
                lpInBuffer: [*:0]u8,
                nInBufferSize: u32,
                lpOutBuffer: [*:0]u8,
                pnOutBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice3,
                dwIoControlCode: u32,
                lpInBuffer: [*:0]u8,
                nInBufferSize: u32,
                lpOutBuffer: [*:0]u8,
                pnOutBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDevice3,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDevice3,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDSPDevice2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice3_GetProperty(self: *const T, pwszPropName: ?[*:0]const u16, pValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMDSPDevice3.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IMDSPDevice3, @ptrCast(self)), pwszPropName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice3_SetProperty(self: *const T, pwszPropName: ?[*:0]const u16, pValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMDSPDevice3.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IMDSPDevice3, @ptrCast(self)), pwszPropName, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice3_GetFormatCapability(self: *const T, format: WMDM_FORMATCODE, pFormatSupport: ?*WMDM_FORMAT_CAPABILITY) HRESULT {
                return @as(*const IMDSPDevice3.VTable, @ptrCast(self.vtable)).GetFormatCapability(@as(*const IMDSPDevice3, @ptrCast(self)), format, pFormatSupport);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice3_DeviceIoControl(self: *const T, dwIoControlCode: u32, lpInBuffer: [*:0]u8, nInBufferSize: u32, lpOutBuffer: [*:0]u8, pnOutBufferSize: ?*u32) HRESULT {
                return @as(*const IMDSPDevice3.VTable, @ptrCast(self.vtable)).DeviceIoControl(@as(*const IMDSPDevice3, @ptrCast(self)), dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, pnOutBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDevice3_FindStorage(self: *const T, findScope: WMDM_FIND_SCOPE, pwszUniqueID: ?[*:0]const u16, ppStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPDevice3.VTable, @ptrCast(self.vtable)).FindStorage(@as(*const IMDSPDevice3, @ptrCast(self)), findScope, pwszUniqueID, ppStorage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPDeviceControl_Value = Guid.initString("1dcb3a14-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPDeviceControl = &IID_IMDSPDeviceControl_Value;
pub const IMDSPDeviceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDCStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
                pdwCapabilitiesMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
                pdwCapabilitiesMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Play: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Record: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDeviceControl,
                fuMode: u32,
                nOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDeviceControl,
                fuMode: u32,
                nOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_GetDCStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).GetDCStatus(@as(*const IMDSPDeviceControl, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_GetCapabilities(self: *const T, pdwCapabilitiesMask: ?*u32) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IMDSPDeviceControl, @ptrCast(self)), pdwCapabilitiesMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_Play(self: *const T) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).Play(@as(*const IMDSPDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_Record(self: *const T, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).Record(@as(*const IMDSPDeviceControl, @ptrCast(self)), pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_Pause(self: *const T) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMDSPDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_Resume(self: *const T) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).Resume(@as(*const IMDSPDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_Stop(self: *const T) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMDSPDeviceControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDeviceControl_Seek(self: *const T, fuMode: u32, nOffset: i32) HRESULT {
                return @as(*const IMDSPDeviceControl.VTable, @ptrCast(self.vtable)).Seek(@as(*const IMDSPDeviceControl, @ptrCast(self)), fuMode, nOffset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPEnumStorage_Value = Guid.initString("1dcb3a15-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPEnumStorage = &IID_IMDSPEnumStorage_Value;
pub const IMDSPEnumStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumStorage,
                celt: u32,
                ppStorage: [*]?*IMDSPStorage,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumStorage,
                celt: u32,
                ppStorage: [*]?*IMDSPStorage,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumStorage,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumStorage,
                celt: u32,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPEnumStorage,
                ppEnumStorage: ?*?*IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPEnumStorage,
                ppEnumStorage: ?*?*IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumStorage_Next(self: *const T, celt: u32, ppStorage: [*]?*IMDSPStorage, pceltFetched: ?*u32) HRESULT {
                return @as(*const IMDSPEnumStorage.VTable, @ptrCast(self.vtable)).Next(@as(*const IMDSPEnumStorage, @ptrCast(self)), celt, ppStorage, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumStorage_Skip(self: *const T, celt: u32, pceltFetched: ?*u32) HRESULT {
                return @as(*const IMDSPEnumStorage.VTable, @ptrCast(self.vtable)).Skip(@as(*const IMDSPEnumStorage, @ptrCast(self)), celt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumStorage_Reset(self: *const T) HRESULT {
                return @as(*const IMDSPEnumStorage.VTable, @ptrCast(self.vtable)).Reset(@as(*const IMDSPEnumStorage, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPEnumStorage_Clone(self: *const T, ppEnumStorage: ?*?*IMDSPEnumStorage) HRESULT {
                return @as(*const IMDSPEnumStorage.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMDSPEnumStorage, @ptrCast(self)), ppEnumStorage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPStorage_Value = Guid.initString("1dcb3a16-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPStorage = &IID_IMDSPStorage_Value;
pub const IMDSPStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStorageGlobals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                ppStorageGlobals: ?*?*IMDSPStorageGlobals,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                ppStorageGlobals: ?*?*IMDSPStorageGlobals,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                pdwAttributes: ?*u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                pdwAttributes: ?*u32,
                pFormat: ?*_WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                pwszName: [*:0]u16,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                pDateTimeUTC: ?*WMDMDATETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                pDateTimeUTC: ?*WMDMDATETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                pdwSizeLow: ?*u32,
                pdwSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                pdwSizeLow: ?*u32,
                pdwSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
                pwszName: ?PWSTR,
                ppNewStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                dwAttributes: u32,
                pFormat: ?*_WAVEFORMATEX,
                pwszName: ?PWSTR,
                ppNewStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                ppEnumStorage: ?*?*IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                ppEnumStorage: ?*?*IMDSPEnumStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOpaqueCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage,
                pCommand: ?*OPAQUECOMMAND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_SetAttributes(self: *const T, dwAttributes: u32, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).SetAttributes(@as(*const IMDSPStorage, @ptrCast(self)), dwAttributes, pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_GetStorageGlobals(self: *const T, ppStorageGlobals: ?*?*IMDSPStorageGlobals) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).GetStorageGlobals(@as(*const IMDSPStorage, @ptrCast(self)), ppStorageGlobals);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_GetAttributes(self: *const T, pdwAttributes: ?*u32, pFormat: ?*_WAVEFORMATEX) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IMDSPStorage, @ptrCast(self)), pdwAttributes, pFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_GetName(self: *const T, pwszName: [*:0]u16, nMaxChars: u32) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).GetName(@as(*const IMDSPStorage, @ptrCast(self)), pwszName, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_GetDate(self: *const T, pDateTimeUTC: ?*WMDMDATETIME) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).GetDate(@as(*const IMDSPStorage, @ptrCast(self)), pDateTimeUTC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_GetSize(self: *const T, pdwSizeLow: ?*u32, pdwSizeHigh: ?*u32) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IMDSPStorage, @ptrCast(self)), pdwSizeLow, pdwSizeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_GetRights(self: *const T, ppRights: ?[*]?*WMDMRIGHTS, pnRightsCount: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).GetRights(@as(*const IMDSPStorage, @ptrCast(self)), ppRights, pnRightsCount, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_CreateStorage(self: *const T, dwAttributes: u32, pFormat: ?*_WAVEFORMATEX, pwszName: ?PWSTR, ppNewStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).CreateStorage(@as(*const IMDSPStorage, @ptrCast(self)), dwAttributes, pFormat, pwszName, ppNewStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_EnumStorage(self: *const T, ppEnumStorage: ?*?*IMDSPEnumStorage) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).EnumStorage(@as(*const IMDSPStorage, @ptrCast(self)), ppEnumStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage_SendOpaqueCommand(self: *const T, pCommand: ?*OPAQUECOMMAND) HRESULT {
                return @as(*const IMDSPStorage.VTable, @ptrCast(self.vtable)).SendOpaqueCommand(@as(*const IMDSPStorage, @ptrCast(self)), pCommand);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPStorage2_Value = Guid.initString("0a5e07a5-6454-4451-9c36-1c6ae7e2b1d6");
pub const IID_IMDSPStorage2 = &IID_IMDSPStorage2_Value;
pub const IMDSPStorage2 = extern struct {
    pub const VTable = extern struct {
        base: IMDSPStorage.VTable,
        GetStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage2,
                pszStorageName: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStorage2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
                pwszName: ?PWSTR,
                qwFileSize: u64,
                ppNewStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
                pwszName: ?PWSTR,
                qwFileSize: u64,
                ppNewStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAttributes2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage2,
                dwAttributes: u32,
                dwAttributesEx: u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage2,
                pdwAttributes: ?*u32,
                pdwAttributesEx: ?*u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage2,
                pdwAttributes: ?*u32,
                pdwAttributesEx: ?*u32,
                pAudioFormat: ?*_WAVEFORMATEX,
                pVideoFormat: ?*_VIDEOINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDSPStorage.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage2_GetStorage(self: *const T, pszStorageName: ?[*:0]const u16, ppStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage2.VTable, @ptrCast(self.vtable)).GetStorage(@as(*const IMDSPStorage2, @ptrCast(self)), pszStorageName, ppStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage2_CreateStorage2(self: *const T, dwAttributes: u32, dwAttributesEx: u32, pAudioFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER, pwszName: ?PWSTR, qwFileSize: u64, ppNewStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage2.VTable, @ptrCast(self.vtable)).CreateStorage2(@as(*const IMDSPStorage2, @ptrCast(self)), dwAttributes, dwAttributesEx, pAudioFormat, pVideoFormat, pwszName, qwFileSize, ppNewStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage2_SetAttributes2(self: *const T, dwAttributes: u32, dwAttributesEx: u32, pAudioFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER) HRESULT {
                return @as(*const IMDSPStorage2.VTable, @ptrCast(self.vtable)).SetAttributes2(@as(*const IMDSPStorage2, @ptrCast(self)), dwAttributes, dwAttributesEx, pAudioFormat, pVideoFormat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage2_GetAttributes2(self: *const T, pdwAttributes: ?*u32, pdwAttributesEx: ?*u32, pAudioFormat: ?*_WAVEFORMATEX, pVideoFormat: ?*_VIDEOINFOHEADER) HRESULT {
                return @as(*const IMDSPStorage2.VTable, @ptrCast(self.vtable)).GetAttributes2(@as(*const IMDSPStorage2, @ptrCast(self)), pdwAttributes, pdwAttributesEx, pAudioFormat, pVideoFormat);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPStorage3_Value = Guid.initString("6c669867-97ed-4a67-9706-1c5529d2a414");
pub const IID_IMDSPStorage3 = &IID_IMDSPStorage3_Value;
pub const IMDSPStorage3 = extern struct {
    pub const VTable = extern struct {
        base: IMDSPStorage2.VTable,
        GetMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage3,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage3,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage3,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage3,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDSPStorage2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage3_GetMetadata(self: *const T, pMetadata: ?*IWMDMMetaData) HRESULT {
                return @as(*const IMDSPStorage3.VTable, @ptrCast(self.vtable)).GetMetadata(@as(*const IMDSPStorage3, @ptrCast(self)), pMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage3_SetMetadata(self: *const T, pMetadata: ?*IWMDMMetaData) HRESULT {
                return @as(*const IMDSPStorage3.VTable, @ptrCast(self.vtable)).SetMetadata(@as(*const IMDSPStorage3, @ptrCast(self)), pMetadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPStorage4_Value = Guid.initString("3133b2c4-515c-481b-b1ce-39327ecb4f74");
pub const IID_IMDSPStorage4 = &IID_IMDSPStorage4_Value;
pub const IMDSPStorage4 = extern struct {
    pub const VTable = extern struct {
        base: IMDSPStorage3.VTable,
        SetReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage4,
                dwRefs: u32,
                ppISPStorage: ?[*]?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage4,
                dwRefs: u32,
                ppISPStorage: ?[*]?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage4,
                pdwRefs: ?*u32,
                pppISPStorage: ?[*]?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage4,
                pdwRefs: ?*u32,
                pppISPStorage: ?[*]?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStorageWithMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage4,
                dwAttributes: u32,
                pwszName: ?[*:0]const u16,
                pMetadata: ?*IWMDMMetaData,
                qwFileSize: u64,
                ppNewStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage4,
                dwAttributes: u32,
                pwszName: ?[*:0]const u16,
                pMetadata: ?*IWMDMMetaData,
                qwFileSize: u64,
                ppNewStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecifiedMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage4,
                cProperties: u32,
                ppwszPropNames: [*]?PWSTR,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage4,
                cProperties: u32,
                ppwszPropNames: [*]?PWSTR,
                pMetadata: ?*IWMDMMetaData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage4,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage4,
                findScope: WMDM_FIND_SCOPE,
                pwszUniqueID: ?[*:0]const u16,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorage4,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorage4,
                ppStorage: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDSPStorage3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage4_SetReferences(self: *const T, dwRefs: u32, ppISPStorage: ?[*]?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage4.VTable, @ptrCast(self.vtable)).SetReferences(@as(*const IMDSPStorage4, @ptrCast(self)), dwRefs, ppISPStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage4_GetReferences(self: *const T, pdwRefs: ?*u32, pppISPStorage: ?[*]?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage4.VTable, @ptrCast(self.vtable)).GetReferences(@as(*const IMDSPStorage4, @ptrCast(self)), pdwRefs, pppISPStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage4_CreateStorageWithMetadata(self: *const T, dwAttributes: u32, pwszName: ?[*:0]const u16, pMetadata: ?*IWMDMMetaData, qwFileSize: u64, ppNewStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage4.VTable, @ptrCast(self.vtable)).CreateStorageWithMetadata(@as(*const IMDSPStorage4, @ptrCast(self)), dwAttributes, pwszName, pMetadata, qwFileSize, ppNewStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage4_GetSpecifiedMetadata(self: *const T, cProperties: u32, ppwszPropNames: [*]?PWSTR, pMetadata: ?*IWMDMMetaData) HRESULT {
                return @as(*const IMDSPStorage4.VTable, @ptrCast(self.vtable)).GetSpecifiedMetadata(@as(*const IMDSPStorage4, @ptrCast(self)), cProperties, ppwszPropNames, pMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage4_FindStorage(self: *const T, findScope: WMDM_FIND_SCOPE, pwszUniqueID: ?[*:0]const u16, ppStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage4.VTable, @ptrCast(self.vtable)).FindStorage(@as(*const IMDSPStorage4, @ptrCast(self)), findScope, pwszUniqueID, ppStorage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorage4_GetParent(self: *const T, ppStorage: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorage4.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IMDSPStorage4, @ptrCast(self)), ppStorage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPStorageGlobals_Value = Guid.initString("1dcb3a17-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPStorageGlobals = &IID_IMDSPStorageGlobals_Value;
pub const IMDSPStorageGlobals = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSerialNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                pSerialNum: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                pSerialNum: ?*WMDMID,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                pdwTotalSizeLow: ?*u32,
                pdwTotalSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                pdwTotalSizeLow: ?*u32,
                pdwTotalSizeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalFree: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                pdwFreeLow: ?*u32,
                pdwFreeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                pdwFreeLow: ?*u32,
                pdwFreeHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalBad: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                pdwBadLow: ?*u32,
                pdwBadHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                pdwBadLow: ?*u32,
                pdwBadHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                ppDevice: ?*?*IMDSPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                ppDevice: ?*?*IMDSPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPStorageGlobals,
                ppRoot: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPStorageGlobals,
                ppRoot: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetCapabilities(self: *const T, pdwCapabilities: ?*u32) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IMDSPStorageGlobals, @ptrCast(self)), pdwCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetSerialNumber(self: *const T, pSerialNum: ?*WMDMID, abMac: ?*u8) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetSerialNumber(@as(*const IMDSPStorageGlobals, @ptrCast(self)), pSerialNum, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetTotalSize(self: *const T, pdwTotalSizeLow: ?*u32, pdwTotalSizeHigh: ?*u32) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetTotalSize(@as(*const IMDSPStorageGlobals, @ptrCast(self)), pdwTotalSizeLow, pdwTotalSizeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetTotalFree(self: *const T, pdwFreeLow: ?*u32, pdwFreeHigh: ?*u32) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetTotalFree(@as(*const IMDSPStorageGlobals, @ptrCast(self)), pdwFreeLow, pdwFreeHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetTotalBad(self: *const T, pdwBadLow: ?*u32, pdwBadHigh: ?*u32) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetTotalBad(@as(*const IMDSPStorageGlobals, @ptrCast(self)), pdwBadLow, pdwBadHigh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetStatus(self: *const T, pdwStatus: ?*u32) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMDSPStorageGlobals, @ptrCast(self)), pdwStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_Initialize(self: *const T, fuMode: u32, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMDSPStorageGlobals, @ptrCast(self)), fuMode, pProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetDevice(self: *const T, ppDevice: ?*?*IMDSPDevice) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IMDSPStorageGlobals, @ptrCast(self)), ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPStorageGlobals_GetRootStorage(self: *const T, ppRoot: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPStorageGlobals.VTable, @ptrCast(self.vtable)).GetRootStorage(@as(*const IMDSPStorageGlobals, @ptrCast(self)), ppRoot);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPObjectInfo_Value = Guid.initString("1dcb3a19-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPObjectInfo = &IID_IMDSPObjectInfo_Value;
pub const IMDSPObjectInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPlayLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                dwLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                pdwOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                pdwOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                dwOffset: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                dwOffset: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastPlayPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                pdwLastPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                pdwLastPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLongestPlayPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObjectInfo,
                pdwLongestPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObjectInfo,
                pdwLongestPos: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_GetPlayLength(self: *const T, pdwLength: ?*u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).GetPlayLength(@as(*const IMDSPObjectInfo, @ptrCast(self)), pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_SetPlayLength(self: *const T, dwLength: u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).SetPlayLength(@as(*const IMDSPObjectInfo, @ptrCast(self)), dwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_GetPlayOffset(self: *const T, pdwOffset: ?*u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).GetPlayOffset(@as(*const IMDSPObjectInfo, @ptrCast(self)), pdwOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_SetPlayOffset(self: *const T, dwOffset: u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).SetPlayOffset(@as(*const IMDSPObjectInfo, @ptrCast(self)), dwOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_GetTotalLength(self: *const T, pdwLength: ?*u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).GetTotalLength(@as(*const IMDSPObjectInfo, @ptrCast(self)), pdwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_GetLastPlayPosition(self: *const T, pdwLastPos: ?*u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).GetLastPlayPosition(@as(*const IMDSPObjectInfo, @ptrCast(self)), pdwLastPos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObjectInfo_GetLongestPlayPosition(self: *const T, pdwLongestPos: ?*u32) HRESULT {
                return @as(*const IMDSPObjectInfo.VTable, @ptrCast(self.vtable)).GetLongestPlayPosition(@as(*const IMDSPObjectInfo, @ptrCast(self)), pdwLongestPos);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPObject_Value = Guid.initString("1dcb3a18-33ed-11d3-8470-00c04f79dbc0");
pub const IID_IMDSPObject = &IID_IMDSPObject_Value;
pub const IMDSPObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                fuMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                fuMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                fuFlags: u32,
                dwOffset: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                fuFlags: u32,
                dwOffset: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                pwszNewName: ?PWSTR,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                pwszNewName: ?PWSTR,
                pProgress: ?*IWMDMProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
                pTarget: ?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
                fuMode: u32,
                pProgress: ?*IWMDMProgress,
                pTarget: ?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Open(self: *const T, fuMode: u32) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Open(@as(*const IMDSPObject, @ptrCast(self)), fuMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Read(self: *const T, pData: [*:0]u8, pdwSize: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Read(@as(*const IMDSPObject, @ptrCast(self)), pData, pdwSize, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Write(self: *const T, pData: [*:0]u8, pdwSize: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Write(@as(*const IMDSPObject, @ptrCast(self)), pData, pdwSize, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Delete(self: *const T, fuMode: u32, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Delete(@as(*const IMDSPObject, @ptrCast(self)), fuMode, pProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Seek(self: *const T, fuFlags: u32, dwOffset: u32) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Seek(@as(*const IMDSPObject, @ptrCast(self)), fuFlags, dwOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Rename(self: *const T, pwszNewName: ?PWSTR, pProgress: ?*IWMDMProgress) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Rename(@as(*const IMDSPObject, @ptrCast(self)), pwszNewName, pProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Move(self: *const T, fuMode: u32, pProgress: ?*IWMDMProgress, pTarget: ?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Move(@as(*const IMDSPObject, @ptrCast(self)), fuMode, pProgress, pTarget);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject_Close(self: *const T) HRESULT {
                return @as(*const IMDSPObject.VTable, @ptrCast(self.vtable)).Close(@as(*const IMDSPObject, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPObject2_Value = Guid.initString("3f34cd3e-5907-4341-9af9-97f4187c3aa5");
pub const IID_IMDSPObject2 = &IID_IMDSPObject2_Value;
pub const IMDSPObject2 = extern struct {
    pub const VTable = extern struct {
        base: IMDSPObject.VTable,
        ReadOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject2,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject2,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPObject2,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPObject2,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMDSPObject.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject2_ReadOnClearChannel(self: *const T, pData: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IMDSPObject2.VTable, @ptrCast(self.vtable)).ReadOnClearChannel(@as(*const IMDSPObject2, @ptrCast(self)), pData, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPObject2_WriteOnClearChannel(self: *const T, pData: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IMDSPObject2.VTable, @ptrCast(self.vtable)).WriteOnClearChannel(@as(*const IMDSPObject2, @ptrCast(self)), pData, pdwSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPDirectTransfer_Value = Guid.initString("c2fe57a8-9304-478c-9ee4-47e397b912d7");
pub const IID_IMDSPDirectTransfer = &IID_IMDSPDirectTransfer_Value;
pub const IMDSPDirectTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TransferToDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPDirectTransfer,
                pwszSourceFilePath: ?[*:0]const u16,
                pSourceOperation: ?*IWMDMOperation,
                fuFlags: u32,
                pwszDestinationName: ?PWSTR,
                pSourceMetaData: ?*IWMDMMetaData,
                pTransferProgress: ?*IWMDMProgress,
                ppNewObject: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPDirectTransfer,
                pwszSourceFilePath: ?[*:0]const u16,
                pSourceOperation: ?*IWMDMOperation,
                fuFlags: u32,
                pwszDestinationName: ?PWSTR,
                pSourceMetaData: ?*IWMDMMetaData,
                pTransferProgress: ?*IWMDMProgress,
                ppNewObject: ?*?*IMDSPStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPDirectTransfer_TransferToDevice(self: *const T, pwszSourceFilePath: ?[*:0]const u16, pSourceOperation: ?*IWMDMOperation, fuFlags: u32, pwszDestinationName: ?PWSTR, pSourceMetaData: ?*IWMDMMetaData, pTransferProgress: ?*IWMDMProgress, ppNewObject: ?*?*IMDSPStorage) HRESULT {
                return @as(*const IMDSPDirectTransfer.VTable, @ptrCast(self.vtable)).TransferToDevice(@as(*const IMDSPDirectTransfer, @ptrCast(self)), pwszSourceFilePath, pSourceOperation, fuFlags, pwszDestinationName, pSourceMetaData, pTransferProgress, ppNewObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDSPRevoked_Value = Guid.initString("a4e8f2d4-3f31-464d-b53d-4fc335998184");
pub const IID_IMDSPRevoked = &IID_IMDSPRevoked_Value;
pub const IMDSPRevoked = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRevocationURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMDSPRevoked,
                ppwszRevocationURL: ?[*]?PWSTR,
                pdwBufferLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMDSPRevoked,
                ppwszRevocationURL: ?[*]?PWSTR,
                pdwBufferLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMDSPRevoked_GetRevocationURL(self: *const T, ppwszRevocationURL: ?[*]?PWSTR, pdwBufferLen: ?*u32) HRESULT {
                return @as(*const IMDSPRevoked.VTable, @ptrCast(self.vtable)).GetRevocationURL(@as(*const IMDSPRevoked, @ptrCast(self)), ppwszRevocationURL, pdwBufferLen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureAuthenticate_Value = Guid.initString("1dcb3a0f-33ed-11d3-8470-00c04f79dbc0");
pub const IID_ISCPSecureAuthenticate = &IID_ISCPSecureAuthenticate_Value;
pub const ISCPSecureAuthenticate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureAuthenticate,
                ppSecureQuery: ?*?*ISCPSecureQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureAuthenticate,
                ppSecureQuery: ?*?*ISCPSecureQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureAuthenticate_GetSecureQuery(self: *const T, ppSecureQuery: ?*?*ISCPSecureQuery) HRESULT {
                return @as(*const ISCPSecureAuthenticate.VTable, @ptrCast(self.vtable)).GetSecureQuery(@as(*const ISCPSecureAuthenticate, @ptrCast(self)), ppSecureQuery);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureAuthenticate2_Value = Guid.initString("b580cfae-1672-47e2-acaa-44bbecbcae5b");
pub const IID_ISCPSecureAuthenticate2 = &IID_ISCPSecureAuthenticate2_Value;
pub const ISCPSecureAuthenticate2 = extern struct {
    pub const VTable = extern struct {
        base: ISCPSecureAuthenticate.VTable,
        GetSCPSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureAuthenticate2,
                ppSCPSession: ?*?*ISCPSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureAuthenticate2,
                ppSCPSession: ?*?*ISCPSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISCPSecureAuthenticate.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureAuthenticate2_GetSCPSession(self: *const T, ppSCPSession: ?*?*ISCPSession) HRESULT {
                return @as(*const ISCPSecureAuthenticate2.VTable, @ptrCast(self.vtable)).GetSCPSession(@as(*const ISCPSecureAuthenticate2, @ptrCast(self)), ppSCPSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureQuery_Value = Guid.initString("1dcb3a0d-33ed-11d3-8470-00c04f79dbc0");
pub const IID_ISCPSecureQuery = &IID_ISCPSecureQuery_Value;
pub const ISCPSecureQuery = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataDemands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery,
                pfuFlags: ?*u32,
                pdwMinRightsData: ?*u32,
                pdwMinExamineData: ?*u32,
                pdwMinDecideData: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery,
                pfuFlags: ?*u32,
                pdwMinRightsData: ?*u32,
                pdwMinExamineData: ?*u32,
                pdwMinDecideData: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExamineData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery,
                fuFlags: u32,
                pwszExtension: ?PWSTR,
                pData: [*:0]u8,
                dwSize: u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery,
                fuFlags: u32,
                pwszExtension: ?PWSTR,
                pData: [*:0]u8,
                dwSize: u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeDecision: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery,
                fuFlags: u32,
                pData: [*:0]u8,
                dwSize: u32,
                dwAppSec: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStorageGlobals: ?*IMDSPStorageGlobals,
                ppExchange: ?*?*ISCPSecureExchange,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery,
                fuFlags: u32,
                pData: [*:0]u8,
                dwSize: u32,
                dwAppSec: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStorageGlobals: ?*IMDSPStorageGlobals,
                ppExchange: ?*?*ISCPSecureExchange,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery,
                pData: [*:0]u8,
                dwSize: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStgGlobals: ?*IMDSPStorageGlobals,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery,
                pData: [*:0]u8,
                dwSize: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStgGlobals: ?*IMDSPStorageGlobals,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery_GetDataDemands(self: *const T, pfuFlags: ?*u32, pdwMinRightsData: ?*u32, pdwMinExamineData: ?*u32, pdwMinDecideData: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureQuery.VTable, @ptrCast(self.vtable)).GetDataDemands(@as(*const ISCPSecureQuery, @ptrCast(self)), pfuFlags, pdwMinRightsData, pdwMinExamineData, pdwMinDecideData, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery_ExamineData(self: *const T, fuFlags: u32, pwszExtension: ?PWSTR, pData: [*:0]u8, dwSize: u32, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureQuery.VTable, @ptrCast(self.vtable)).ExamineData(@as(*const ISCPSecureQuery, @ptrCast(self)), fuFlags, pwszExtension, pData, dwSize, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery_MakeDecision(self: *const T, fuFlags: u32, pData: [*:0]u8, dwSize: u32, dwAppSec: u32, pbSPSessionKey: [*:0]u8, dwSessionKeyLen: u32, pStorageGlobals: ?*IMDSPStorageGlobals, ppExchange: ?*?*ISCPSecureExchange, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureQuery.VTable, @ptrCast(self.vtable)).MakeDecision(@as(*const ISCPSecureQuery, @ptrCast(self)), fuFlags, pData, dwSize, dwAppSec, pbSPSessionKey, dwSessionKeyLen, pStorageGlobals, ppExchange, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery_GetRights(self: *const T, pData: [*:0]u8, dwSize: u32, pbSPSessionKey: [*:0]u8, dwSessionKeyLen: u32, pStgGlobals: ?*IMDSPStorageGlobals, ppRights: ?[*]?*WMDMRIGHTS, pnRightsCount: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureQuery.VTable, @ptrCast(self.vtable)).GetRights(@as(*const ISCPSecureQuery, @ptrCast(self)), pData, dwSize, pbSPSessionKey, dwSessionKeyLen, pStgGlobals, ppRights, pnRightsCount, abMac);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureQuery2_Value = Guid.initString("ebe17e25-4fd7-4632-af46-6d93d4fcc72e");
pub const IID_ISCPSecureQuery2 = &IID_ISCPSecureQuery2_Value;
pub const ISCPSecureQuery2 = extern struct {
    pub const VTable = extern struct {
        base: ISCPSecureQuery.VTable,
        MakeDecision2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery2,
                fuFlags: u32,
                pData: [*:0]u8,
                dwSize: u32,
                dwAppSec: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStorageGlobals: ?*IMDSPStorageGlobals,
                pAppCertApp: [*:0]u8,
                dwAppCertAppLen: u32,
                pAppCertSP: [*:0]u8,
                dwAppCertSPLen: u32,
                pszRevocationURL: ?[*]?PWSTR,
                pdwRevocationURLLen: ?*u32,
                pdwRevocationBitFlag: ?*u32,
                pqwFileSize: ?*u64,
                pUnknown: ?*IUnknown,
                ppExchange: ?*?*ISCPSecureExchange,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery2,
                fuFlags: u32,
                pData: [*:0]u8,
                dwSize: u32,
                dwAppSec: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStorageGlobals: ?*IMDSPStorageGlobals,
                pAppCertApp: [*:0]u8,
                dwAppCertAppLen: u32,
                pAppCertSP: [*:0]u8,
                dwAppCertSPLen: u32,
                pszRevocationURL: ?[*]?PWSTR,
                pdwRevocationURLLen: ?*u32,
                pdwRevocationBitFlag: ?*u32,
                pqwFileSize: ?*u64,
                pUnknown: ?*IUnknown,
                ppExchange: ?*?*ISCPSecureExchange,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISCPSecureQuery.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery2_MakeDecision2(self: *const T, fuFlags: u32, pData: [*:0]u8, dwSize: u32, dwAppSec: u32, pbSPSessionKey: [*:0]u8, dwSessionKeyLen: u32, pStorageGlobals: ?*IMDSPStorageGlobals, pAppCertApp: [*:0]u8, dwAppCertAppLen: u32, pAppCertSP: [*:0]u8, dwAppCertSPLen: u32, pszRevocationURL: ?[*]?PWSTR, pdwRevocationURLLen: ?*u32, pdwRevocationBitFlag: ?*u32, pqwFileSize: ?*u64, pUnknown: ?*IUnknown, ppExchange: ?*?*ISCPSecureExchange, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureQuery2.VTable, @ptrCast(self.vtable)).MakeDecision2(@as(*const ISCPSecureQuery2, @ptrCast(self)), fuFlags, pData, dwSize, dwAppSec, pbSPSessionKey, dwSessionKeyLen, pStorageGlobals, pAppCertApp, dwAppCertAppLen, pAppCertSP, dwAppCertSPLen, pszRevocationURL, pdwRevocationURLLen, pdwRevocationBitFlag, pqwFileSize, pUnknown, ppExchange, abMac);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureExchange_Value = Guid.initString("1dcb3a0e-33ed-11d3-8470-00c04f79dbc0");
pub const IID_ISCPSecureExchange = &IID_ISCPSecureExchange_Value;
pub const ISCPSecureExchange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TransferContainerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange,
                pData: [*:0]u8,
                dwSize: u32,
                pfuReadyFlags: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange,
                pData: [*:0]u8,
                dwSize: u32,
                pfuReadyFlags: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ObjectData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange,
                pData: [*:0]u8,
                pdwSize: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransferComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange_TransferContainerData(self: *const T, pData: [*:0]u8, dwSize: u32, pfuReadyFlags: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureExchange.VTable, @ptrCast(self.vtable)).TransferContainerData(@as(*const ISCPSecureExchange, @ptrCast(self)), pData, dwSize, pfuReadyFlags, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange_ObjectData(self: *const T, pData: [*:0]u8, pdwSize: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureExchange.VTable, @ptrCast(self.vtable)).ObjectData(@as(*const ISCPSecureExchange, @ptrCast(self)), pData, pdwSize, abMac);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange_TransferComplete(self: *const T) HRESULT {
                return @as(*const ISCPSecureExchange.VTable, @ptrCast(self.vtable)).TransferComplete(@as(*const ISCPSecureExchange, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureExchange2_Value = Guid.initString("6c62fc7b-2690-483f-9d44-0a20cb35577c");
pub const IID_ISCPSecureExchange2 = &IID_ISCPSecureExchange2_Value;
pub const ISCPSecureExchange2 = extern struct {
    pub const VTable = extern struct {
        base: ISCPSecureExchange.VTable,
        TransferContainerData2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange2,
                pData: [*:0]u8,
                dwSize: u32,
                pProgressCallback: ?*IWMDMProgress3,
                pfuReadyFlags: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange2,
                pData: [*:0]u8,
                dwSize: u32,
                pProgressCallback: ?*IWMDMProgress3,
                pfuReadyFlags: ?*u32,
                abMac: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISCPSecureExchange.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange2_TransferContainerData2(self: *const T, pData: [*:0]u8, dwSize: u32, pProgressCallback: ?*IWMDMProgress3, pfuReadyFlags: ?*u32, abMac: ?*u8) HRESULT {
                return @as(*const ISCPSecureExchange2.VTable, @ptrCast(self.vtable)).TransferContainerData2(@as(*const ISCPSecureExchange2, @ptrCast(self)), pData, dwSize, pProgressCallback, pfuReadyFlags, abMac);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureExchange3_Value = Guid.initString("ab4e77e4-8908-4b17-bd2a-b1dbe6dd69e1");
pub const IID_ISCPSecureExchange3 = &IID_ISCPSecureExchange3_Value;
pub const ISCPSecureExchange3 = extern struct {
    pub const VTable = extern struct {
        base: ISCPSecureExchange2.VTable,
        TransferContainerDataOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange3,
                pDevice: ?*IMDSPDevice,
                pData: [*:0]u8,
                dwSize: u32,
                pProgressCallback: ?*IWMDMProgress3,
                pfuReadyFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange3,
                pDevice: ?*IMDSPDevice,
                pData: [*:0]u8,
                dwSize: u32,
                pProgressCallback: ?*IWMDMProgress3,
                pfuReadyFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectDataOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange3,
                pDevice: ?*IMDSPDevice,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange3,
                pDevice: ?*IMDSPDevice,
                pData: [*:0]u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransferCompleteForDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureExchange3,
                pDevice: ?*IMDSPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureExchange3,
                pDevice: ?*IMDSPDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISCPSecureExchange2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange3_TransferContainerDataOnClearChannel(self: *const T, pDevice: ?*IMDSPDevice, pData: [*:0]u8, dwSize: u32, pProgressCallback: ?*IWMDMProgress3, pfuReadyFlags: ?*u32) HRESULT {
                return @as(*const ISCPSecureExchange3.VTable, @ptrCast(self.vtable)).TransferContainerDataOnClearChannel(@as(*const ISCPSecureExchange3, @ptrCast(self)), pDevice, pData, dwSize, pProgressCallback, pfuReadyFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange3_GetObjectDataOnClearChannel(self: *const T, pDevice: ?*IMDSPDevice, pData: [*:0]u8, pdwSize: ?*u32) HRESULT {
                return @as(*const ISCPSecureExchange3.VTable, @ptrCast(self.vtable)).GetObjectDataOnClearChannel(@as(*const ISCPSecureExchange3, @ptrCast(self)), pDevice, pData, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureExchange3_TransferCompleteForDevice(self: *const T, pDevice: ?*IMDSPDevice) HRESULT {
                return @as(*const ISCPSecureExchange3.VTable, @ptrCast(self.vtable)).TransferCompleteForDevice(@as(*const ISCPSecureExchange3, @ptrCast(self)), pDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSession_Value = Guid.initString("88a3e6ed-eee4-4619-bbb3-fd4fb62715d1");
pub const IID_ISCPSession = &IID_ISCPSession_Value;
pub const ISCPSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSession,
                pIDevice: ?*IMDSPDevice,
                pCtx: [*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSession,
                pIDevice: ?*IMDSPDevice,
                pCtx: [*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSession,
                pCtx: [*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSession,
                pCtx: [*:0]u8,
                dwSizeCtx: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecureQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSession,
                ppSecureQuery: ?*?*ISCPSecureQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSession,
                ppSecureQuery: ?*?*ISCPSecureQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSession_BeginSession(self: *const T, pIDevice: ?*IMDSPDevice, pCtx: [*:0]u8, dwSizeCtx: u32) HRESULT {
                return @as(*const ISCPSession.VTable, @ptrCast(self.vtable)).BeginSession(@as(*const ISCPSession, @ptrCast(self)), pIDevice, pCtx, dwSizeCtx);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSession_EndSession(self: *const T, pCtx: [*:0]u8, dwSizeCtx: u32) HRESULT {
                return @as(*const ISCPSession.VTable, @ptrCast(self.vtable)).EndSession(@as(*const ISCPSession, @ptrCast(self)), pCtx, dwSizeCtx);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSession_GetSecureQuery(self: *const T, ppSecureQuery: ?*?*ISCPSecureQuery) HRESULT {
                return @as(*const ISCPSession.VTable, @ptrCast(self.vtable)).GetSecureQuery(@as(*const ISCPSession, @ptrCast(self)), ppSecureQuery);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISCPSecureQuery3_Value = Guid.initString("b7edd1a2-4dab-484b-b3c5-ad39b8b4c0b1");
pub const IID_ISCPSecureQuery3 = &IID_ISCPSecureQuery3_Value;
pub const ISCPSecureQuery3 = extern struct {
    pub const VTable = extern struct {
        base: ISCPSecureQuery2.VTable,
        GetRightsOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery3,
                pData: [*:0]u8,
                dwSize: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStgGlobals: ?*IMDSPStorageGlobals,
                pProgressCallback: ?*IWMDMProgress3,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery3,
                pData: [*:0]u8,
                dwSize: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStgGlobals: ?*IMDSPStorageGlobals,
                pProgressCallback: ?*IWMDMProgress3,
                ppRights: ?[*]?*WMDMRIGHTS,
                pnRightsCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MakeDecisionOnClearChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISCPSecureQuery3,
                fuFlags: u32,
                pData: [*:0]u8,
                dwSize: u32,
                dwAppSec: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStorageGlobals: ?*IMDSPStorageGlobals,
                pProgressCallback: ?*IWMDMProgress3,
                pAppCertApp: [*:0]u8,
                dwAppCertAppLen: u32,
                pAppCertSP: [*:0]u8,
                dwAppCertSPLen: u32,
                pszRevocationURL: ?[*]?PWSTR,
                pdwRevocationURLLen: ?*u32,
                pdwRevocationBitFlag: ?*u32,
                pqwFileSize: ?*u64,
                pUnknown: ?*IUnknown,
                ppExchange: ?*?*ISCPSecureExchange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISCPSecureQuery3,
                fuFlags: u32,
                pData: [*:0]u8,
                dwSize: u32,
                dwAppSec: u32,
                pbSPSessionKey: [*:0]u8,
                dwSessionKeyLen: u32,
                pStorageGlobals: ?*IMDSPStorageGlobals,
                pProgressCallback: ?*IWMDMProgress3,
                pAppCertApp: [*:0]u8,
                dwAppCertAppLen: u32,
                pAppCertSP: [*:0]u8,
                dwAppCertSPLen: u32,
                pszRevocationURL: ?[*]?PWSTR,
                pdwRevocationURLLen: ?*u32,
                pdwRevocationBitFlag: ?*u32,
                pqwFileSize: ?*u64,
                pUnknown: ?*IUnknown,
                ppExchange: ?*?*ISCPSecureExchange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISCPSecureQuery2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery3_GetRightsOnClearChannel(self: *const T, pData: [*:0]u8, dwSize: u32, pbSPSessionKey: [*:0]u8, dwSessionKeyLen: u32, pStgGlobals: ?*IMDSPStorageGlobals, pProgressCallback: ?*IWMDMProgress3, ppRights: ?[*]?*WMDMRIGHTS, pnRightsCount: ?*u32) HRESULT {
                return @as(*const ISCPSecureQuery3.VTable, @ptrCast(self.vtable)).GetRightsOnClearChannel(@as(*const ISCPSecureQuery3, @ptrCast(self)), pData, dwSize, pbSPSessionKey, dwSessionKeyLen, pStgGlobals, pProgressCallback, ppRights, pnRightsCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISCPSecureQuery3_MakeDecisionOnClearChannel(self: *const T, fuFlags: u32, pData: [*:0]u8, dwSize: u32, dwAppSec: u32, pbSPSessionKey: [*:0]u8, dwSessionKeyLen: u32, pStorageGlobals: ?*IMDSPStorageGlobals, pProgressCallback: ?*IWMDMProgress3, pAppCertApp: [*:0]u8, dwAppCertAppLen: u32, pAppCertSP: [*:0]u8, dwAppCertSPLen: u32, pszRevocationURL: ?[*]?PWSTR, pdwRevocationURLLen: ?*u32, pdwRevocationBitFlag: ?*u32, pqwFileSize: ?*u64, pUnknown: ?*IUnknown, ppExchange: ?*?*ISCPSecureExchange) HRESULT {
                return @as(*const ISCPSecureQuery3.VTable, @ptrCast(self.vtable)).MakeDecisionOnClearChannel(@as(*const ISCPSecureQuery3, @ptrCast(self)), fuFlags, pData, dwSize, dwAppSec, pbSPSessionKey, dwSessionKeyLen, pStorageGlobals, pProgressCallback, pAppCertApp, dwAppCertAppLen, pAppCertSP, dwAppCertSPLen, pszRevocationURL, pdwRevocationURLLen, pdwRevocationBitFlag, pqwFileSize, pUnknown, ppExchange);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IComponentAuthenticate_Value = Guid.initString("a9889c00-6d2b-11d3-8496-00c04f79dbc0");
pub const IID_IComponentAuthenticate = &IID_IComponentAuthenticate_Value;
pub const IComponentAuthenticate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SACAuth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComponentAuthenticate,
                dwProtocolID: u32,
                dwPass: u32,
                pbDataIn: [*:0]u8,
                dwDataInLen: u32,
                ppbDataOut: ?[*]?*u8,
                pdwDataOutLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComponentAuthenticate,
                dwProtocolID: u32,
                dwPass: u32,
                pbDataIn: [*:0]u8,
                dwDataInLen: u32,
                ppbDataOut: ?[*]?*u8,
                pdwDataOutLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SACGetProtocols: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComponentAuthenticate,
                ppdwProtocols: ?[*]?*u32,
                pdwProtocolCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComponentAuthenticate,
                ppdwProtocols: ?[*]?*u32,
                pdwProtocolCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComponentAuthenticate_SACAuth(self: *const T, dwProtocolID: u32, dwPass: u32, pbDataIn: [*:0]u8, dwDataInLen: u32, ppbDataOut: ?[*]?*u8, pdwDataOutLen: ?*u32) HRESULT {
                return @as(*const IComponentAuthenticate.VTable, @ptrCast(self.vtable)).SACAuth(@as(*const IComponentAuthenticate, @ptrCast(self)), dwProtocolID, dwPass, pbDataIn, dwDataInLen, ppbDataOut, pdwDataOutLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComponentAuthenticate_SACGetProtocols(self: *const T, ppdwProtocols: ?[*]?*u32, pdwProtocolCount: ?*u32) HRESULT {
                return @as(*const IComponentAuthenticate.VTable, @ptrCast(self.vtable)).SACGetProtocols(@as(*const IComponentAuthenticate, @ptrCast(self)), ppdwProtocols, pdwProtocolCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_WMDMLogger_Value = Guid.initString("110a3202-5a79-11d3-8d78-444553540000");
pub const CLSID_WMDMLogger = &CLSID_WMDMLogger_Value;

const IID_IWMDMLogger_Value = Guid.initString("110a3200-5a79-11d3-8d78-444553540000");
pub const IID_IWMDMLogger = &IID_IWMDMLogger_Value;
pub const IWMDMLogger = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                pszFilename: ?PSTR,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                pszFilename: ?PSTR,
                nMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                pszFilename: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                pszFilename: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LogString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                dwFlags: u32,
                pszSrcName: ?PSTR,
                pszLog: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                dwFlags: u32,
                pszSrcName: ?PSTR,
                pszLog: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LogDword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                dwFlags: u32,
                pszSrcName: ?PSTR,
                pszLogFormat: ?PSTR,
                dwLog: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                dwFlags: u32,
                pszSrcName: ?PSTR,
                pszLogFormat: ?PSTR,
                dwLog: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSizeParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                pdwMaxSize: ?*u32,
                pdwShrinkToSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                pdwMaxSize: ?*u32,
                pdwShrinkToSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSizeParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMDMLogger,
                dwMaxSize: u32,
                dwShrinkToSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMDMLogger,
                dwMaxSize: u32,
                dwShrinkToSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_IsEnabled(self: *const T, pfEnabled: ?*BOOL) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IWMDMLogger, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_Enable(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).Enable(@as(*const IWMDMLogger, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_GetLogFileName(self: *const T, pszFilename: ?PSTR, nMaxChars: u32) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).GetLogFileName(@as(*const IWMDMLogger, @ptrCast(self)), pszFilename, nMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_SetLogFileName(self: *const T, pszFilename: ?PSTR) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).SetLogFileName(@as(*const IWMDMLogger, @ptrCast(self)), pszFilename);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_LogString(self: *const T, dwFlags: u32, pszSrcName: ?PSTR, pszLog: ?PSTR) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).LogString(@as(*const IWMDMLogger, @ptrCast(self)), dwFlags, pszSrcName, pszLog);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_LogDword(self: *const T, dwFlags: u32, pszSrcName: ?PSTR, pszLogFormat: ?PSTR, dwLog: u32) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).LogDword(@as(*const IWMDMLogger, @ptrCast(self)), dwFlags, pszSrcName, pszLogFormat, dwLog);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_Reset(self: *const T) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).Reset(@as(*const IWMDMLogger, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_GetSizeParams(self: *const T, pdwMaxSize: ?*u32, pdwShrinkToSize: ?*u32) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).GetSizeParams(@as(*const IWMDMLogger, @ptrCast(self)), pdwMaxSize, pdwShrinkToSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMDMLogger_SetSizeParams(self: *const T, dwMaxSize: u32, dwShrinkToSize: u32) HRESULT {
                return @as(*const IWMDMLogger.VTable, @ptrCast(self.vtable)).SetSizeParams(@as(*const IWMDMLogger, @ptrCast(self)), dwMaxSize, dwShrinkToSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MTP_COMMAND_DATA_IN = extern struct {
    OpCode: u16 align(1),
    NumParams: u32 align(1),
    Params: [5]u32 align(1),
    NextPhase: u32 align(1),
    CommandWriteDataSize: u32 align(1),
    CommandWriteData: [1]u8 align(1),
};

pub const MTP_COMMAND_DATA_OUT = extern struct {
    ResponseCode: u16 align(1),
    NumParams: u32 align(1),
    Params: [5]u32 align(1),
    CommandReadDataSize: u32 align(1),
    CommandReadData: [1]u8 align(1),
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const HRESULT = @import("../foundation.zig").HRESULT;
const ISpecifyPropertyPages = @import("../system/ole.zig").ISpecifyPropertyPages;
const IUnknown = @import("../system/com.zig").IUnknown;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
