//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1705)
//--------------------------------------------------------------------------------
pub const MEDIASUBTYPE_None = Guid.initString("e436eb8e-524f-11ce-9f53-0020af0ba770");
pub const AVENC_H263V_LEVELCOUNT = @as(u32, 8);
pub const AVENC_H264V_LEVELCOUNT = @as(u32, 16);
pub const AVENC_H264V_MAX_MBBITS = @as(u32, 3200);
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG2 = Guid.initString("ee27417f-5e28-4e65-beea-1d26b508adc9");
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG1_AND_MPEG2 = Guid.initString("86695f12-340e-4f04-9fd3-9253dd327460");
pub const D3D12_VIDEO_DECODE_PROFILE_H264 = Guid.initString("1b81be68-a0c7-11d3-b984-00c04f2e73c5");
pub const D3D12_VIDEO_DECODE_PROFILE_H264_STEREO_PROGRESSIVE = Guid.initString("d79be8da-0cf1-4c81-b82a-69a4e236f43d");
pub const D3D12_VIDEO_DECODE_PROFILE_H264_STEREO = Guid.initString("f9aaccbb-c2b6-4cfc-8779-5707b1760552");
pub const D3D12_VIDEO_DECODE_PROFILE_H264_MULTIVIEW = Guid.initString("705b9d82-76cf-49d6-b7e6-ac8872db013c");
pub const D3D12_VIDEO_DECODE_PROFILE_VC1 = Guid.initString("1b81bea3-a0c7-11d3-b984-00c04f2e73c5");
pub const D3D12_VIDEO_DECODE_PROFILE_VC1_D2010 = Guid.initString("1b81bea4-a0c7-11d3-b984-00c04f2e73c5");
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG4PT2_SIMPLE = Guid.initString("efd64d74-c9e8-41d7-a5e9-e9b0e39fa319");
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG4PT2_ADVSIMPLE_NOGMC = Guid.initString("ed418a9f-010d-4eda-9ae3-9a65358d8d2e");
pub const D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN = Guid.initString("5b11d51b-2f4c-4452-bcc3-09f2a1160cc0");
pub const D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN10 = Guid.initString("107af0e0-ef1a-4d19-aba8-67a163073d13");
pub const D3D12_VIDEO_DECODE_PROFILE_VP9 = Guid.initString("463707f8-a1d0-4585-876d-83aa6d60b89e");
pub const D3D12_VIDEO_DECODE_PROFILE_VP9_10BIT_PROFILE2 = Guid.initString("a4c749ef-6ecf-48aa-8448-50a7a1165ff7");
pub const D3D12_VIDEO_DECODE_PROFILE_VP8 = Guid.initString("90b899ea-3a62-4705-88b3-8df04b2744e7");
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE0 = Guid.initString("b8be4ccb-cf53-46ba-8d59-d6b8a6da5d2a");
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE1 = Guid.initString("6936ff0f-45b1-4163-9cc1-646ef6946108");
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE2 = Guid.initString("0c5f2aa1-e541-4089-bb7b-98110a19d7c8");
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_12BIT_PROFILE2 = Guid.initString("17127009-a00f-4ce1-994e-bf4081f6f3f0");
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_12BIT_PROFILE2_420 = Guid.initString("2d80bed6-9cac-4835-9e91-327bbc4f9ee8");
pub const DXVA2_ModeMPEG2_MoComp = Guid.initString("e6a9f44b-61b0-4563-9ea4-63d2a3c6fe66");
pub const DXVA2_ModeMPEG2_IDCT = Guid.initString("bf22ad00-03ea-4690-8077-473346209b7e");
pub const DXVA2_ModeMPEG2_VLD = Guid.initString("ee27417f-5e28-4e65-beea-1d26b508adc9");
pub const DXVA2_ModeMPEG1_VLD = Guid.initString("6f3ec719-3735-42cc-8063-65cc3cb36616");
pub const DXVA2_ModeMPEG2and1_VLD = Guid.initString("86695f12-340e-4f04-9fd3-9253dd327460");
pub const DXVA2_ModeH264_A = Guid.initString("1b81be64-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeH264_B = Guid.initString("1b81be65-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeH264_C = Guid.initString("1b81be66-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeH264_D = Guid.initString("1b81be67-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeH264_E = Guid.initString("1b81be68-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeH264_F = Guid.initString("1b81be69-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeH264_VLD_WithFMOASO_NoFGT = Guid.initString("d5f04ff9-3418-45d8-9561-32a76aae2ddd");
pub const DXVA2_ModeH264_VLD_Stereo_Progressive_NoFGT = Guid.initString("d79be8da-0cf1-4c81-b82a-69a4e236f43d");
pub const DXVA2_ModeH264_VLD_Stereo_NoFGT = Guid.initString("f9aaccbb-c2b6-4cfc-8779-5707b1760552");
pub const DXVA2_ModeH264_VLD_Multiview_NoFGT = Guid.initString("705b9d82-76cf-49d6-b7e6-ac8872db013c");
pub const DXVA2_ModeWMV8_A = Guid.initString("1b81be80-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeWMV8_B = Guid.initString("1b81be81-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeWMV9_A = Guid.initString("1b81be90-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeWMV9_B = Guid.initString("1b81be91-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeWMV9_C = Guid.initString("1b81be94-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeVC1_A = Guid.initString("1b81bea0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeVC1_B = Guid.initString("1b81bea1-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeVC1_C = Guid.initString("1b81bea2-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeVC1_D = Guid.initString("1b81bea3-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_ModeVC1_D2010 = Guid.initString("1b81bea4-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_NoEncrypt = Guid.initString("1b81bed0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA2_VideoProcProgressiveDevice = Guid.initString("5a54a0c9-c7ec-4bd9-8ede-f3c75dc4393b");
pub const DXVA2_VideoProcBobDevice = Guid.initString("335aa36e-7884-43a4-9c91-7f87faf3e37e");
pub const DXVA2_VideoProcSoftwareDevice = Guid.initString("4553d47f-ee7e-4e3f-9475-dbf1376c4810");
pub const DXVA2_ModeMPEG4pt2_VLD_Simple = Guid.initString("efd64d74-c9e8-41d7-a5e9-e9b0e39fa319");
pub const DXVA2_ModeMPEG4pt2_VLD_AdvSimple_NoGMC = Guid.initString("ed418a9f-010d-4eda-9ae3-9a65358d8d2e");
pub const DXVA2_ModeMPEG4pt2_VLD_AdvSimple_GMC = Guid.initString("ab998b5b-4258-44a9-9feb-94e597a6baae");
pub const DXVA2_ModeHEVC_VLD_Main = Guid.initString("5b11d51b-2f4c-4452-bcc3-09f2a1160cc0");
pub const DXVA2_ModeHEVC_VLD_Main10 = Guid.initString("107af0e0-ef1a-4d19-aba8-67a163073d13");
pub const DXVA2_ModeVP9_VLD_Profile0 = Guid.initString("463707f8-a1d0-4585-876d-83aa6d60b89e");
pub const DXVA2_ModeVP9_VLD_10bit_Profile2 = Guid.initString("a4c749ef-6ecf-48aa-8448-50a7a1165ff7");
pub const DXVA2_ModeVP8_VLD = Guid.initString("90b899ea-3a62-4705-88b3-8df04b2744e7");
pub const DXVA2_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217408));
pub const DXVA2_E_NEW_VIDEO_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217407));
pub const DXVA2_E_VIDEO_DEVICE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217406));
pub const DXVA2_E_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217405));
pub const MAX_SUBSTREAMS = @as(u32, 15);
pub const DXVA2_DECODE_GET_DRIVER_HANDLE = @as(u32, 1829);
pub const DXVA2_DECODE_SPECIFY_ENCRYPTED_BLOCKS = @as(u32, 1828);
pub const DXVAp_ModeMPEG2_A = Guid.initString("1b81be0a-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVAp_ModeMPEG2_C = Guid.initString("1b81be0c-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVAp_NoEncrypt = Guid.initString("1b81bed0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVAp_DeinterlaceBobDevice = Guid.initString("335aa36e-7884-43a4-9c91-7f87faf3e37e");
pub const DXVAp_DeinterlaceContainerDevice = Guid.initString("0e85cb93-3046-4ff0-aecc-d58cb5f035fd");
pub const DXVAHD_STREAM_STATE_PRIVATE_IVTC = Guid.initString("9c601e3c-0f33-414c-a739-99540ee42da5");
pub const DXVAHDControlGuid = Guid.initString("a0386e75-f70c-464c-a9ce-33c44e091623");
pub const DXVAHDETWGUID_CREATEVIDEOPROCESSOR = Guid.initString("681e3d1e-5674-4fb3-a503-2f2055e91f60");
pub const DXVAHDETWGUID_VIDEOPROCESSBLTSTATE = Guid.initString("76c94b5a-193f-4692-9484-a4d999da81a8");
pub const DXVAHDETWGUID_VIDEOPROCESSSTREAMSTATE = Guid.initString("262c0b02-209d-47ed-94d8-82ae02b84aa7");
pub const DXVAHDETWGUID_VIDEOPROCESSBLTHD = Guid.initString("bef3d435-78c7-4de3-9707-cd1b083b160a");
pub const DXVAHDETWGUID_VIDEOPROCESSBLTHD_STREAM = Guid.initString("27ae473e-a5fc-4be5-b4e3-f24994d3c495");
pub const DXVAHDETWGUID_DESTROYVIDEOPROCESSOR = Guid.initString("f943f0a0-3f16-43e0-8093-105a986aa5f1");
pub const MR_VIDEO_RENDER_SERVICE = Guid.initString("1092a86c-ab1a-459a-a336-831fbc4d11ff");
pub const MR_VIDEO_MIXER_SERVICE = Guid.initString("073cd2fc-6cf4-40b7-8859-e89552c841f8");
pub const MR_VIDEO_ACCELERATION_SERVICE = Guid.initString("efef5175-5c7d-4ce2-bbbd-34ff8bca6554");
pub const MR_BUFFER_SERVICE = Guid.initString("a562248c-9ac6-4ffc-9fba-3af8f8ad1a4d");
pub const VIDEO_ZOOM_RECT = Guid.initString("7aaa1638-1b7f-4c93-bd89-5b9c9fb6fcf0");
pub const MFEVRDLL = @as(u32, 0);
pub const MF_SDK_VERSION = @as(u32, 2);
pub const MF_API_VERSION = @as(u32, 112);
pub const MFSTARTUP_NOSOCKET = @as(u32, 1);
pub const MFSTARTUP_LITE = @as(u32, 1);
pub const MFSTARTUP_FULL = @as(u32, 0);
pub const MF_E_DXGI_DEVICE_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217408));
pub const MF_E_DXGI_NEW_VIDEO_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217407));
pub const MF_E_DXGI_VIDEO_DEVICE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2147217406));
pub const MF_1_BYTE_ALIGNMENT = @as(u32, 0);
pub const MF_2_BYTE_ALIGNMENT = @as(u32, 1);
pub const MF_4_BYTE_ALIGNMENT = @as(u32, 3);
pub const MF_8_BYTE_ALIGNMENT = @as(u32, 7);
pub const MF_16_BYTE_ALIGNMENT = @as(u32, 15);
pub const MF_32_BYTE_ALIGNMENT = @as(u32, 31);
pub const MF_64_BYTE_ALIGNMENT = @as(u32, 63);
pub const MF_128_BYTE_ALIGNMENT = @as(u32, 127);
pub const MF_256_BYTE_ALIGNMENT = @as(u32, 255);
pub const MF_512_BYTE_ALIGNMENT = @as(u32, 511);
pub const MF_1024_BYTE_ALIGNMENT = @as(u32, 1023);
pub const MF_2048_BYTE_ALIGNMENT = @as(u32, 2047);
pub const MF_4096_BYTE_ALIGNMENT = @as(u32, 4095);
pub const MF_8192_BYTE_ALIGNMENT = @as(u32, 8191);
pub const MF_EVENT_SESSIONCAPS = Guid.initString("7e5ebcd0-11b8-4abe-afad-10f6599a7f42");
pub const MF_EVENT_SESSIONCAPS_DELTA = Guid.initString("7e5ebcd1-11b8-4abe-afad-10f6599a7f42");
pub const MFSESSIONCAP_START = @as(u32, 1);
pub const MFSESSIONCAP_SEEK = @as(u32, 2);
pub const MFSESSIONCAP_PAUSE = @as(u32, 4);
pub const MFSESSIONCAP_RATE_FORWARD = @as(u32, 16);
pub const MFSESSIONCAP_RATE_REVERSE = @as(u32, 32);
pub const MFSESSIONCAP_DOES_NOT_USE_NETWORK = @as(u32, 64);
pub const MF_EVENT_TOPOLOGY_STATUS = Guid.initString("30c5018d-9a53-454b-ad9e-6d5f8fa7c43b");
pub const MF_EVENT_START_PRESENTATION_TIME = Guid.initString("5ad914d0-9b45-4a8d-a2c0-81d1e50bfb07");
pub const MF_EVENT_PRESENTATION_TIME_OFFSET = Guid.initString("5ad914d1-9b45-4a8d-a2c0-81d1e50bfb07");
pub const MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT = Guid.initString("5ad914d2-9b45-4a8d-a2c0-81d1e50bfb07");
pub const MF_EVENT_SOURCE_FAKE_START = Guid.initString("a8cc55a7-6b31-419f-845d-ffb351a2434b");
pub const MF_EVENT_SOURCE_PROJECTSTART = Guid.initString("a8cc55a8-6b31-419f-845d-ffb351a2434b");
pub const MF_EVENT_SOURCE_ACTUAL_START = Guid.initString("a8cc55a9-6b31-419f-845d-ffb351a2434b");
pub const MF_EVENT_SOURCE_TOPOLOGY_CANCELED = Guid.initString("db62f650-9a5e-4704-acf3-563bc6a73364");
pub const MF_EVENT_SOURCE_CHARACTERISTICS = Guid.initString("47db8490-8b22-4f52-afda-9ce1b2d3cfa8");
pub const MF_EVENT_SOURCE_CHARACTERISTICS_OLD = Guid.initString("47db8491-8b22-4f52-afda-9ce1b2d3cfa8");
pub const MF_EVENT_DO_THINNING = Guid.initString("321ea6fb-dad9-46e4-b31d-d2eae7090e30");
pub const MF_EVENT_SCRUBSAMPLE_TIME = Guid.initString("9ac712b3-dcb8-44d5-8d0c-37455a2782e3");
pub const MF_EVENT_OUTPUT_NODE = Guid.initString("830f1a8b-c060-46dd-a801-1c95dec9b107");
pub const MF_EVENT_MFT_INPUT_STREAM_ID = Guid.initString("f29c2cca-7ae6-42d2-b284-bf837cc874e2");
pub const MF_EVENT_MFT_CONTEXT = Guid.initString("b7cd31f1-899e-4b41-80c9-26a896d32977");
pub const MF_EVENT_STREAM_METADATA_KEYDATA = Guid.initString("cd59a4a1-4a3b-4bbd-8665-72a40fbea776");
pub const MF_EVENT_STREAM_METADATA_CONTENT_KEYIDS = Guid.initString("5063449d-cc29-4fc6-a75a-d247b35af85c");
pub const MF_EVENT_STREAM_METADATA_SYSTEMID = Guid.initString("1ea2ef64-ba16-4a36-8719-fe7560ba32ad");
pub const MFSampleExtension_MaxDecodeFrameSize = Guid.initString("d3cc654f-f9f3-4a13-889f-f04eb2b5b957");
pub const MFSampleExtension_AccumulatedNonRefPicPercent = Guid.initString("79ea74df-a740-445b-bc98-c9ed1f260eee");
pub const MFSampleExtension_Encryption_ProtectionScheme = Guid.initString("d054d096-28bb-45da-87ec-74f351871406");
pub const MFSampleExtension_Encryption_CryptByteBlock = Guid.initString("9d84289b-0c7f-4713-ab95-108ab42ad801");
pub const MFSampleExtension_Encryption_SkipByteBlock = Guid.initString("0d550548-8317-4ab1-845f-d06306e293e3");
pub const MFSampleExtension_Encryption_SubSample_Mapping = Guid.initString("8444f27a-69a1-48da-bd08-11cef36830d2");
pub const MFSampleExtension_Encryption_ClearSliceHeaderData = Guid.initString("5509a4f4-320d-4e6c-8d1a-94c66dd20cb0");
pub const MFSampleExtension_Encryption_HardwareProtection_KeyInfoID = Guid.initString("8cbfcceb-94a5-4de1-8231-a85e47cf81e7");
pub const MFSampleExtension_Encryption_HardwareProtection_KeyInfo = Guid.initString("b2372080-455b-4dd7-9989-1a955784b754");
pub const MFSampleExtension_Encryption_HardwareProtection_VideoDecryptorContext = Guid.initString("693470c8-e837-47a0-88cb-535b905e3582");
pub const MFSampleExtension_Encryption_Opaque_Data = Guid.initString("224d77e5-1391-4ffb-9f41-b432f68c611d");
pub const MFSampleExtension_NALULengthInfo = Guid.initString("19124e7c-ad4b-465f-bb18-20186287b6af");
pub const MFSampleExtension_Encryption_ResumeVideoOutput = Guid.initString("a435aba5-afde-4cf5-bc1c-f6acaf13949d");
pub const MFSampleExtension_Encryption_NALUTypes = Guid.initString("b0f067c7-714c-416c-8d59-5f4ddf8913b6");
pub const MFSampleExtension_Encryption_SPSPPSData = Guid.initString("aede0fa2-0e0c-453c-b7f3-de8693364d11");
pub const MFSampleExtension_Encryption_SEIData = Guid.initString("3cf0e972-4542-4687-9999-585f565fba7d");
pub const MFSampleExtension_Encryption_HardwareProtection = Guid.initString("9a2b2d2b-8270-43e3-8448-994f426e8886");
pub const MFSampleExtension_CleanPoint = Guid.initString("9cdf01d8-a0f0-43ba-b077-eaa06cbd728a");
pub const MFSampleExtension_Discontinuity = Guid.initString("9cdf01d9-a0f0-43ba-b077-eaa06cbd728a");
pub const MFSampleExtension_Token = Guid.initString("8294da66-f328-4805-b551-00deb4c57a61");
pub const MFSampleExtension_ClosedCaption_CEA708 = Guid.initString("26f09068-e744-47dc-aa03-dbf20403bde6");
pub const MFSampleExtension_ClosedCaption_CEA708_MAX_SIZE = @as(u32, 256);
pub const MFSampleExtension_DecodeTimestamp = Guid.initString("73a954d4-09e2-4861-befc-94bd97c08e6e");
pub const MFSampleExtension_VideoEncodeQP = Guid.initString("b2efe478-f979-4c66-b95e-ee2b82c82f36");
pub const MFSampleExtension_VideoEncodePictureType = Guid.initString("973704e6-cd14-483c-8f20-c9fc0928bad5");
pub const MFSampleExtension_FrameCorruption = Guid.initString("b4dd4a8c-0beb-44c4-8b75-b02b913b04f0");
pub const MFSampleExtension_DirtyRects = Guid.initString("9ba70225-b342-4e97-9126-0b566ab7ea7e");
pub const MFSampleExtension_MoveRegions = Guid.initString("e2a6c693-3a8b-4b8d-95d0-f60281a12fb7");
pub const MFSampleExtension_HDCP_OptionalHeader = Guid.initString("9a2e7390-121f-455f-8376-c97428e0b540");
pub const MFSampleExtension_HDCP_FrameCounter = Guid.initString("9d389c60-f507-4aa6-a40a-71027a02f3de");
pub const MFSampleExtension_HDCP_StreamID = Guid.initString("177e5d74-c370-4a7a-95a2-36833c01d0af");
pub const MFSampleExtension_Timestamp = Guid.initString("1e436999-69be-4c7a-9369-70068c0260cb");
pub const MFSampleExtension_RepeatFrame = Guid.initString("88be738f-0711-4f42-b458-344aed42ec2f");
pub const MFT_ENCODER_ERROR = Guid.initString("c8d1eda4-98e4-41d5-9297-44f53852f90e");
pub const MFT_GFX_DRIVER_VERSION_ID_Attribute = Guid.initString("f34b9093-05e0-4b16-993d-3e2a2cde6ad3");
pub const MFSampleExtension_DescrambleData = Guid.initString("43483be6-4903-4314-b032-2951365936fc");
pub const MFSampleExtension_SampleKeyID = Guid.initString("9ed713c8-9b87-4b26-8297-a93b0c5a8acc");
pub const MFSampleExtension_GenKeyFunc = Guid.initString("441ca1ee-6b1f-4501-903a-de87df42f6ed");
pub const MFSampleExtension_GenKeyCtx = Guid.initString("188120cb-d7da-4b59-9b3e-9252fd37301c");
pub const MFSampleExtension_PacketCrossOffsets = Guid.initString("2789671d-389f-40bb-90d9-c282f77f9abd");
pub const MFSampleExtension_Encryption_SampleID = Guid.initString("6698b84e-0afa-4330-aeb2-1c0a98d7a44d");
pub const MFSampleExtension_Encryption_KeyID = Guid.initString("76376591-795f-4da1-86ed-9d46eca109a9");
pub const MFSampleExtension_Content_KeyID = Guid.initString("c6c7f5b0-acca-415b-87d9-10441469efc6");
pub const MFSampleExtension_Encryption_SubSampleMappingSplit = Guid.initString("fe0254b9-2aa5-4edc-99f7-17e89dbf9174");
pub const MFSampleExtension_Interlaced = Guid.initString("b1d5830a-deb8-40e3-90fa-389943716461");
pub const MFSampleExtension_BottomFieldFirst = Guid.initString("941ce0a3-6ae3-4dda-9a08-a64298340617");
pub const MFSampleExtension_RepeatFirstField = Guid.initString("304d257c-7493-4fbd-b149-9228de8d9a99");
pub const MFSampleExtension_SingleField = Guid.initString("9d85f816-658b-455a-bde0-9fa7e15ab8f9");
pub const MFSampleExtension_DerivedFromTopField = Guid.initString("6852465a-ae1c-4553-8e9b-c3420fcb1637");
pub const MFSampleExtension_MeanAbsoluteDifference = Guid.initString("1cdbde11-08b4-4311-a6dd-0f9f371907aa");
pub const MFSampleExtension_LongTermReferenceFrameInfo = Guid.initString("9154733f-e1bd-41bf-81d3-fcd918f71332");
pub const MFSampleExtension_ROIRectangle = Guid.initString("3414a438-4998-4d2c-be82-be3ca0b24d43");
pub const MFSampleExtension_LastSlice = Guid.initString("2b5d5457-5547-4f07-b8c8-b4a3a9a1daac");
pub const MACROBLOCK_FLAG_SKIP = @as(u32, 1);
pub const MACROBLOCK_FLAG_DIRTY = @as(u32, 2);
pub const MACROBLOCK_FLAG_MOTION = @as(u32, 4);
pub const MACROBLOCK_FLAG_VIDEO = @as(u32, 8);
pub const MACROBLOCK_FLAG_HAS_MOTION_VECTOR = @as(u32, 16);
pub const MACROBLOCK_FLAG_HAS_QP = @as(u32, 32);
pub const MFSampleExtension_FeatureMap = Guid.initString("a032d165-46fc-400a-b449-49de53e62a6e");
pub const MFSampleExtension_ChromaOnly = Guid.initString("1eb9179c-a01f-4845-8c04-0e65a26eb04f");
pub const MFSampleExtension_PhotoThumbnail = Guid.initString("74bbc85c-c8bb-42dc-b586-da17ffd35dcc");
pub const MFSampleExtension_PhotoThumbnailMediaType = Guid.initString("61ad5420-ebf8-4143-89af-6bf25f672def");
pub const MFSampleExtension_CaptureMetadata = Guid.initString("2ebe23a8-faf5-444a-a6a2-eb810880ab5d");
pub const MFSampleExtension_MDLCacheCookie = Guid.initString("5f002af9-d8f9-41a3-b6c3-a2ad43f647ad");
pub const MF_CAPTURE_METADATA_PHOTO_FRAME_FLASH = Guid.initString("0f9dd6c6-6003-45d8-bd59-f1f53e3d04e8");
pub const MF_CAPTURE_METADATA_FRAME_RAWSTREAM = Guid.initString("9252077b-2680-49b9-ae02-b19075973b70");
pub const MF_CAPTURE_METADATA_FOCUSSTATE = Guid.initString("a87ee154-997f-465d-b91f-29d53b982b88");
pub const MF_CAPTURE_METADATA_REQUESTED_FRAME_SETTING_ID = Guid.initString("bb3716d9-8a61-47a4-8197-459c7ff174d5");
pub const MF_CAPTURE_METADATA_EXPOSURE_TIME = Guid.initString("16b9ae99-cd84-4063-879d-a28c7633729e");
pub const MF_CAPTURE_METADATA_EXPOSURE_COMPENSATION = Guid.initString("d198aa75-4b62-4345-abf3-3c31fa12c299");
pub const MF_CAPTURE_METADATA_ISO_SPEED = Guid.initString("e528a68f-b2e3-44fe-8b65-07bf4b5a13ff");
pub const MF_CAPTURE_METADATA_LENS_POSITION = Guid.initString("b5fc8e86-11d1-4e70-819b-723a89fa4520");
pub const MF_CAPTURE_METADATA_SCENE_MODE = Guid.initString("9cc3b54d-5ed3-4bae-b388-7670aef59e13");
pub const MF_CAPTURE_METADATA_FLASH = Guid.initString("4a51520b-fb36-446c-9df2-68171b9a0389");
pub const MF_CAPTURE_METADATA_FLASH_POWER = Guid.initString("9c0e0d49-0205-491a-bc9d-2d6e1f4d5684");
pub const MF_CAPTURE_METADATA_WHITEBALANCE = Guid.initString("c736fd77-0fb9-4e2e-97a2-fcd490739ee9");
pub const MF_CAPTURE_METADATA_ZOOMFACTOR = Guid.initString("e50b0b81-e501-42c2-abf2-857ecb13fa5c");
pub const MF_CAPTURE_METADATA_FACEROIS = Guid.initString("864f25a6-349f-46b1-a30e-54cc22928a47");
pub const MF_CAPTURE_METADATA_FACEROITIMESTAMPS = Guid.initString("e94d50cc-3da0-44d4-bb34-83198a741868");
pub const MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS = Guid.initString("b927a1a8-18ef-46d3-b3af-69372f94d9b2");
pub const MF_CAPTURE_METADATA_ISO_GAINS = Guid.initString("05802ac9-0e1d-41c7-a8c8-7e7369f84e1e");
pub const MF_CAPTURE_METADATA_SENSORFRAMERATE = Guid.initString("db51357e-9d3d-4962-b06d-07ce650d9a0a");
pub const MF_CAPTURE_METADATA_WHITEBALANCE_GAINS = Guid.initString("e7570c8f-2dcb-4c7c-aace-22ece7cce647");
pub const MF_CAPTURE_METADATA_HISTOGRAM = Guid.initString("85358432-2ef6-4ba9-a3fb-06d82974b895");
pub const MF_CAPTURE_METADATA_EXIF = Guid.initString("2e9575b8-8c31-4a02-8575-42b197b71592");
pub const MF_CAPTURE_METADATA_FRAME_ILLUMINATION = Guid.initString("6d688ffc-63d3-46fe-bada-5b947db0d080");
pub const MF_CAPTURE_METADATA_UVC_PAYLOADHEADER = Guid.initString("f9f88a87-e1dd-441e-95cb-42e21a64f1d9");
pub const MFSampleExtension_Depth_MinReliableDepth = Guid.initString("5f8582b2-e36b-47c8-9b87-fee1ca72c5b0");
pub const MFSampleExtension_Depth_MaxReliableDepth = Guid.initString("e45545d1-1f0f-4a32-a8a7-6101a24ea8be");
pub const MF_CAPTURE_METADATA_FIRST_SCANLINE_START_TIME_QPC = Guid.initString("6a2c49f1-e052-46b6-b2d9-73c1558709af");
pub const MF_CAPTURE_METADATA_LAST_SCANLINE_END_TIME_QPC = Guid.initString("dccadecb-c4d4-400d-b418-10e88525e1f6");
pub const MF_CAPTURE_METADATA_SCANLINE_TIME_QPC_ACCURACY = Guid.initString("4cd79c51-f765-4b09-b1e1-27d1f7ebea09");
pub const MF_CAPTURE_METADATA_SCANLINE_DIRECTION = Guid.initString("6496a3ba-1907-49e6-b0c3-123795f380a9");
pub const MFCAPTURE_METADATA_SCAN_RIGHT_LEFT = @as(u32, 1);
pub const MFCAPTURE_METADATA_SCAN_BOTTOM_TOP = @as(u32, 2);
pub const MFCAPTURE_METADATA_SCANLINE_VERTICAL = @as(u32, 4);
pub const MF_CAPTURE_METADATA_DIGITALWINDOW = Guid.initString("276f72a2-59c8-4f69-97b4-068b8c0ec044");
pub const MF_CAPTURE_METADATA_FRAME_BACKGROUND_MASK = Guid.initString("03f14dd3-75dd-433a-a8e2-1e3f5f2a50a0");
pub const MF_METADATAFACIALEXPRESSION_SMILE = @as(u32, 1);
pub const MF_METADATATIMESTAMPS_DEVICE = @as(u32, 1);
pub const MF_METADATATIMESTAMPS_PRESENTATION = @as(u32, 2);
pub const MF_HISTOGRAM_CHANNEL_Y = @as(u32, 1);
pub const MF_HISTOGRAM_CHANNEL_R = @as(u32, 2);
pub const MF_HISTOGRAM_CHANNEL_G = @as(u32, 4);
pub const MF_HISTOGRAM_CHANNEL_B = @as(u32, 8);
pub const MF_HISTOGRAM_CHANNEL_Cb = @as(u32, 16);
pub const MF_HISTOGRAM_CHANNEL_Cr = @as(u32, 32);
pub const MFT_CATEGORY_VIDEO_DECODER = Guid.initString("d6c02d4b-6833-45b4-971a-05a4b04bab91");
pub const MFT_CATEGORY_VIDEO_ENCODER = Guid.initString("f79eac7d-e545-4387-bdee-d647d7bde42a");
pub const MFT_CATEGORY_VIDEO_EFFECT = Guid.initString("12e17c21-532c-4a6e-8a1c-40825a736397");
pub const MFT_CATEGORY_MULTIPLEXER = Guid.initString("059c561e-05ae-4b61-b69d-55b61ee54a7b");
pub const MFT_CATEGORY_DEMULTIPLEXER = Guid.initString("a8700a7a-939b-44c5-99d7-76226b23b3f1");
pub const MFT_CATEGORY_AUDIO_DECODER = Guid.initString("9ea73fb4-ef7a-4559-8d5d-719d8f0426c7");
pub const MFT_CATEGORY_AUDIO_ENCODER = Guid.initString("91c64bd0-f91e-4d8c-9276-db248279d975");
pub const MFT_CATEGORY_AUDIO_EFFECT = Guid.initString("11064c48-3648-4ed0-932e-05ce8ac811b7");
pub const MFT_CATEGORY_VIDEO_PROCESSOR = Guid.initString("302ea3fc-aa5f-47f9-9f7a-c2188bb16302");
pub const MFT_CATEGORY_OTHER = Guid.initString("90175d57-b7ea-4901-aeb3-933a8747756f");
pub const MFT_CATEGORY_ENCRYPTOR = Guid.initString("b0c687be-01cd-44b5-b8b2-7c1d7e058b1f");
pub const MFT_CATEGORY_VIDEO_RENDERER_EFFECT = Guid.initString("145cd8b4-92f4-4b23-8ae7-e0df06c2da95");
pub const MFT_ENUM_VIDEO_RENDERER_EXTENSION_PROFILE = Guid.initString("62c56928-9a4e-443b-b9dc-cac830c24100");
pub const MFT_ENUM_ADAPTER_LUID = Guid.initString("1d39518c-e220-4da8-a07f-ba172552d6b1");
pub const MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE = Guid.initString("53476a11-3f13-49fb-ac42-ee2733c96741");
pub const LOCAL_D3DFMT_DEFINES = @as(u32, 1);
pub const MFVideoFormat_Base = Guid.initString("00000000-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_RGB32 = Guid.initString("00000016-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_ARGB32 = Guid.initString("00000015-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_RGB24 = Guid.initString("00000014-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_RGB555 = Guid.initString("00000018-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_RGB565 = Guid.initString("00000017-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_RGB8 = Guid.initString("00000029-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_L8 = Guid.initString("00000032-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_L16 = Guid.initString("00000051-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_D16 = Guid.initString("00000050-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_AI44 = Guid.initString("34344941-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_AYUV = Guid.initString("56555941-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_YUY2 = Guid.initString("32595559-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_YVYU = Guid.initString("55595659-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_YVU9 = Guid.initString("39555659-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_UYVY = Guid.initString("59565955-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_NV11 = Guid.initString("3131564e-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_NV12 = Guid.initString("3231564e-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_NV21 = Guid.initString("3132564e-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_YV12 = Guid.initString("32315659-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_I420 = Guid.initString("30323449-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_IYUV = Guid.initString("56555949-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y210 = Guid.initString("30313259-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y216 = Guid.initString("36313259-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y410 = Guid.initString("30313459-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y416 = Guid.initString("36313459-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y41P = Guid.initString("50313459-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y41T = Guid.initString("54313459-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Y42T = Guid.initString("54323459-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_P210 = Guid.initString("30313250-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_P216 = Guid.initString("36313250-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_P010 = Guid.initString("30313050-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_P016 = Guid.initString("36313050-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_v210 = Guid.initString("30313276-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_v216 = Guid.initString("36313276-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_v410 = Guid.initString("30313476-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MP43 = Guid.initString("3334504d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MP4S = Guid.initString("5334504d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_M4S2 = Guid.initString("3253344d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MP4V = Guid.initString("5634504d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_WMV1 = Guid.initString("31564d57-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_WMV2 = Guid.initString("32564d57-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_WMV3 = Guid.initString("33564d57-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_WVC1 = Guid.initString("31435657-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MSS1 = Guid.initString("3153534d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MSS2 = Guid.initString("3253534d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MPG1 = Guid.initString("3147504d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_DVSL = Guid.initString("6c737664-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_DVSD = Guid.initString("64737664-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_DVHD = Guid.initString("64687664-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_DV25 = Guid.initString("35327664-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_DV50 = Guid.initString("30357664-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_DVH1 = Guid.initString("31687664-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_H264 = Guid.initString("34363248-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_H265 = Guid.initString("35363248-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_MJPG = Guid.initString("47504a4d-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_420O = Guid.initString("4f303234-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_HEVC = Guid.initString("43564548-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_HEVC_ES = Guid.initString("53564548-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_VP80 = Guid.initString("30385056-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_VP90 = Guid.initString("30395056-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_ORAW = Guid.initString("5741524f-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_H263 = Guid.initString("33363248-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_A2R10G10B10 = Guid.initString("0000001f-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_A16B16G16R16F = Guid.initString("00000071-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_VP10 = Guid.initString("30315056-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_AV1 = Guid.initString("31305641-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_Theora = Guid.initString("6f656874-0000-0010-8000-00aa00389b71");
pub const MFVideoFormat_H264_ES = Guid.initString("3f40f4f0-5622-4ff8-b6d8-a17a584bee5e");
pub const MFVideoFormat_MPEG2 = Guid.initString("e06d8026-db46-11cf-b4d1-00805f6cbbea");
pub const MFAudioFormat_Base = Guid.initString("00000000-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_PCM = Guid.initString("00000001-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_Float = Guid.initString("00000003-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_DTS = Guid.initString("00000008-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_Dolby_AC3_SPDIF = Guid.initString("00000092-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_DRM = Guid.initString("00000009-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_WMAudioV8 = Guid.initString("00000161-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_WMAudioV9 = Guid.initString("00000162-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_WMAudio_Lossless = Guid.initString("00000163-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_WMASPDIF = Guid.initString("00000164-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_MSP1 = Guid.initString("0000000a-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_MP3 = Guid.initString("00000055-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_MPEG = Guid.initString("00000050-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_AAC = Guid.initString("00001610-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_ADTS = Guid.initString("00001600-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_AMR_NB = Guid.initString("00007361-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_AMR_WB = Guid.initString("00007362-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_AMR_WP = Guid.initString("00007363-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_FLAC = Guid.initString("0000f1ac-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_ALAC = Guid.initString("00006c61-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_Opus = Guid.initString("0000704f-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_Dolby_AC4 = Guid.initString("0000ac40-0000-0010-8000-00aa00389b71");
pub const MFAudioFormat_Dolby_AC3 = Guid.initString("e06d802c-db46-11cf-b4d1-00805f6cbbea");
pub const MFAudioFormat_Dolby_DDPlus = Guid.initString("a7fb87af-2d02-42fb-a4d4-05cd93843bdd");
pub const MFAudioFormat_Dolby_AC4_V1 = Guid.initString("36b7927c-3d87-4a2a-9196-a21ad9e935e6");
pub const MFAudioFormat_Dolby_AC4_V2 = Guid.initString("7998b2a0-17dd-49b6-8dfa-9b278552a2ac");
pub const MFAudioFormat_Dolby_AC4_V1_ES = Guid.initString("9d8dccc6-d156-4fb8-979c-a85be7d21dfa");
pub const MFAudioFormat_Dolby_AC4_V2_ES = Guid.initString("7e58c9f9-b070-45f4-8ccd-a99a0417c1ac");
pub const MFAudioFormat_Vorbis = Guid.initString("8d2fd10b-5841-4a6b-8905-588fec1aded9");
pub const MFAudioFormat_DTS_RAW = Guid.initString("e06d8033-db46-11cf-b4d1-00805f6cbbea");
pub const MFAudioFormat_DTS_HD = Guid.initString("a2e58eb7-0fa9-48bb-a40c-fa0e156d0645");
pub const MFAudioFormat_DTS_XLL = Guid.initString("45b37c1b-8c70-4e59-a7be-a1e42c81c80d");
pub const MFAudioFormat_DTS_LBR = Guid.initString("c2fe6f0a-4e3c-4df1-9b60-50863091e4b9");
pub const MFAudioFormat_DTS_UHD = Guid.initString("87020117-ace3-42de-b73e-c656706263f8");
pub const MFAudioFormat_DTS_UHDY = Guid.initString("9b9cca00-91b9-4ccc-883a-8f787ac3cc86");
pub const MFAudioFormat_Float_SpatialObjects = Guid.initString("fa39cd94-bc64-4ab1-9b71-dcd09d5a7e7a");
pub const MFAudioFormat_LPCM = Guid.initString("e06d8032-db46-11cf-b4d1-00805f6cbbea");
pub const MFAudioFormat_PCM_HDCP = Guid.initString("a5e7ff01-8411-4acc-a865-5f4941288d80");
pub const MFAudioFormat_Dolby_AC3_HDCP = Guid.initString("97663a80-8ffb-4445-a6ba-792d908f497f");
pub const MFAudioFormat_AAC_HDCP = Guid.initString("419bce76-8b72-400f-adeb-84b57d63484d");
pub const MFAudioFormat_ADTS_HDCP = Guid.initString("da4963a3-14d8-4dcf-92b7-193eb84363db");
pub const MFAudioFormat_Base_HDCP = Guid.initString("3884b5bc-e277-43fd-983d-038aa8d9b605");
pub const MFVideoFormat_H264_HDCP = Guid.initString("5d0ce9dd-9817-49da-bdfd-f5f5b98f18a6");
pub const MFVideoFormat_HEVC_HDCP = Guid.initString("3cfe0fe6-05c4-47dc-9d70-4bdb2959720f");
pub const MFVideoFormat_Base_HDCP = Guid.initString("eac3b9d5-bd14-4237-8f1f-bab428e49312");
pub const MFMPEG4Format_Base = Guid.initString("00000000-767a-494d-b478-f29d25dc9037");
pub const MFSubtitleFormat_XML = Guid.initString("2006f94f-29ca-4195-b8db-00ded8ff0c97");
pub const MFSubtitleFormat_TTML = Guid.initString("73e73992-9a10-4356-9557-7194e91e3e54");
pub const MFSubtitleFormat_ATSC = Guid.initString("7fa7faa3-feae-4e16-aedf-36b9acfbb099");
pub const MFSubtitleFormat_WebVTT = Guid.initString("c886d215-f485-40bb-8db6-fadbc619a45d");
pub const MFSubtitleFormat_SRT = Guid.initString("5e467f2e-77ca-4ca5-8391-d142ed4b76c8");
pub const MFSubtitleFormat_SSA = Guid.initString("57176a1b-1a9e-4eea-abef-c61760198ac4");
pub const MFSubtitleFormat_CustomUserData = Guid.initString("1bb3d849-6614-4d80-8882-ed24aa82da92");
pub const MFSubtitleFormat_PGS = Guid.initString("71f40e4a-1278-4442-b30d-39dd1d7722bc");
pub const MFSubtitleFormat_VobSub = Guid.initString("6b8e40f4-8d2c-4ced-ad91-5960e45b4433");
pub const MF_MT_MAJOR_TYPE = Guid.initString("48eba18e-f8c9-4687-bf11-0a74c9f96a8f");
pub const MF_MT_SUBTYPE = Guid.initString("f7e34c9a-42e8-4714-b74b-cb29d72c35e5");
pub const MF_MT_ALL_SAMPLES_INDEPENDENT = Guid.initString("c9173739-5e56-461c-b713-46fb995cb95f");
pub const MF_MT_FIXED_SIZE_SAMPLES = Guid.initString("b8ebefaf-b718-4e04-b0a9-116775e3321b");
pub const MF_MT_COMPRESSED = Guid.initString("3afd0cee-18f2-4ba5-a110-8bea502e1f92");
pub const MF_MT_SAMPLE_SIZE = Guid.initString("dad3ab78-1990-408b-bce2-eba673dacc10");
pub const MF_MT_WRAPPED_TYPE = Guid.initString("4d3f7b23-d02f-4e6c-9bee-e4bf2c6c695d");
pub const MF_MT_VIDEO_3D = Guid.initString("cb5e88cf-7b5b-476b-85aa-1ca5ae187555");
pub const MF_MT_VIDEO_3D_FORMAT = Guid.initString("5315d8a0-87c5-4697-b793-6606c67c049b");
pub const MF_MT_VIDEO_3D_NUM_VIEWS = Guid.initString("bb077e8a-dcbf-42eb-af60-418df98aa495");
pub const MF_MT_VIDEO_3D_LEFT_IS_BASE = Guid.initString("6d4b7bff-5629-4404-948c-c634f4ce26d4");
pub const MF_MT_VIDEO_3D_FIRST_IS_LEFT = Guid.initString("ec298493-0ada-4ea1-a4fe-cbbd36ce9331");
pub const MFSampleExtension_3DVideo = Guid.initString("f86f97a4-dd54-4e2e-9a5e-55fc2d74a005");
pub const MFSampleExtension_3DVideo_SampleFormat = Guid.initString("08671772-e36f-4cff-97b3-d72e20987a48");
pub const MF_MT_VIDEO_ROTATION = Guid.initString("c380465d-2271-428c-9b83-ecea3b4a85c1");
pub const MF_DEVICESTREAM_MULTIPLEXED_MANAGER = Guid.initString("6ea542b0-281f-4231-a464-fe2f5022501c");
pub const MF_MEDIATYPE_MULTIPLEXED_MANAGER = Guid.initString("13c78fb5-f275-4ea0-bb5f-0249832b0d6e");
pub const MFSampleExtension_MULTIPLEXED_MANAGER = Guid.initString("8dcdee79-6b5a-4c45-8db9-20b395f02fcf");
pub const MF_MT_SECURE = Guid.initString("c5acc4fd-0304-4ecf-809f-47bc97ff63bd");
pub const MF_DEVICESTREAM_ATTRIBUTE_FRAMESOURCE_TYPES = Guid.initString("17145fd1-1b2b-423c-8001-2b6833ed3588");
pub const MF_MT_ALPHA_MODE = Guid.initString("5d959b0d-4cbf-4d04-919f-3f5f7f284211");
pub const MF_MT_DEPTH_MEASUREMENT = Guid.initString("fd5ac489-0917-4bb6-9d54-3122bf70144b");
pub const MF_MT_DEPTH_VALUE_UNIT = Guid.initString("21a800f5-3189-4797-beba-f13cd9a31a5e");
pub const MF_MT_VIDEO_NO_FRAME_ORDERING = Guid.initString("3f5b106f-6bc2-4ee3-b7ed-8902c18f5351");
pub const MF_MT_VIDEO_H264_NO_FMOASO = Guid.initString("ed461cd6-ec9f-416a-a8a3-26d7d31018d7");
pub const MFSampleExtension_ForwardedDecodeUnits = Guid.initString("424c754c-97c8-48d6-8777-fc41f7b60879");
pub const MFSampleExtension_TargetGlobalLuminance = Guid.initString("3f60ef36-31ef-4daf-8360-940397e41ef3");
pub const MFSampleExtension_ForwardedDecodeUnitType = Guid.initString("089e57c7-47d3-4a26-bf9c-4b64fafb5d1e");
pub const MF_MT_FORWARD_CUSTOM_NALU = Guid.initString("ed336efd-244f-428d-9153-28f399458890");
pub const MF_MT_FORWARD_CUSTOM_SEI = Guid.initString("e27362f1-b136-41d1-9594-3a7e4febf2d1");
pub const MF_MT_VIDEO_RENDERER_EXTENSION_PROFILE = Guid.initString("8437d4b9-d448-4fcd-9b6b-839bf96c7798");
pub const MF_DECODER_FWD_CUSTOM_SEI_DECODE_ORDER = Guid.initString("f13bbe3c-36d4-410a-b985-7a951a1e6294");
pub const MF_VIDEO_RENDERER_EFFECT_APP_SERVICE_NAME = Guid.initString("c6052a80-6d9c-40a3-9db8-f027a25c9ab9");
pub const MF_MT_AUDIO_NUM_CHANNELS = Guid.initString("37e48bf5-645e-4c5b-89de-ada9e29b696a");
pub const MF_MT_AUDIO_SAMPLES_PER_SECOND = Guid.initString("5faeeae7-0290-4c31-9e8a-c534f68d9dba");
pub const MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND = Guid.initString("fb3b724a-cfb5-4319-aefe-6e42b2406132");
pub const MF_MT_AUDIO_AVG_BYTES_PER_SECOND = Guid.initString("1aab75c8-cfef-451c-ab95-ac034b8e1731");
pub const MF_MT_AUDIO_BLOCK_ALIGNMENT = Guid.initString("322de230-9eeb-43bd-ab7a-ff412251541d");
pub const MF_MT_AUDIO_BITS_PER_SAMPLE = Guid.initString("f2deb57f-40fa-4764-aa33-ed4f2d1ff669");
pub const MF_MT_AUDIO_VALID_BITS_PER_SAMPLE = Guid.initString("d9bf8d6a-9530-4b7c-9ddf-ff6fd58bbd06");
pub const MF_MT_AUDIO_SAMPLES_PER_BLOCK = Guid.initString("aab15aac-e13a-4995-9222-501ea15c6877");
pub const MF_MT_AUDIO_CHANNEL_MASK = Guid.initString("55fb5765-644a-4caf-8479-938983bb1588");
pub const MF_MT_AUDIO_FOLDDOWN_MATRIX = Guid.initString("9d62927c-36be-4cf2-b5c4-a3926e3e8711");
pub const MF_MT_AUDIO_WMADRC_PEAKREF = Guid.initString("9d62927d-36be-4cf2-b5c4-a3926e3e8711");
pub const MF_MT_AUDIO_WMADRC_PEAKTARGET = Guid.initString("9d62927e-36be-4cf2-b5c4-a3926e3e8711");
pub const MF_MT_AUDIO_WMADRC_AVGREF = Guid.initString("9d62927f-36be-4cf2-b5c4-a3926e3e8711");
pub const MF_MT_AUDIO_WMADRC_AVGTARGET = Guid.initString("9d629280-36be-4cf2-b5c4-a3926e3e8711");
pub const MF_MT_AUDIO_PREFER_WAVEFORMATEX = Guid.initString("a901aaba-e037-458a-bdf6-545be2074042");
pub const MF_MT_AAC_PAYLOAD_TYPE = Guid.initString("bfbabe79-7434-4d1c-94f0-72a3b9e17188");
pub const MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION = Guid.initString("7632f0e6-9538-4d61-acda-ea29c8c14456");
pub const MF_MT_AUDIO_FLAC_MAX_BLOCK_SIZE = Guid.initString("8b81adae-4b5a-4d40-8022-f38d09ca3c5c");
pub const MF_MT_SPATIAL_AUDIO_MAX_DYNAMIC_OBJECTS = Guid.initString("dcfba24a-2609-4240-a721-3faea76a4df9");
pub const MF_MT_SPATIAL_AUDIO_OBJECT_METADATA_FORMAT_ID = Guid.initString("2ab71bc0-6223-4ba7-ad64-7b94b47ae792");
pub const MF_MT_SPATIAL_AUDIO_OBJECT_METADATA_LENGTH = Guid.initString("094ba8be-d723-489f-92fa-766777b34726");
pub const MF_MT_SPATIAL_AUDIO_MAX_METADATA_ITEMS = Guid.initString("11aa80b4-e0da-47c6-8060-96c1259ae50d");
pub const MF_MT_SPATIAL_AUDIO_MIN_METADATA_ITEM_OFFSET_SPACING = Guid.initString("83e96ec9-1184-417e-8254-9f269158fc06");
pub const MF_MT_SPATIAL_AUDIO_DATA_PRESENT = Guid.initString("6842f6e7-d43e-4ebb-9c9c-c96f41784863");
pub const MF_MT_FRAME_SIZE = Guid.initString("1652c33d-d6b2-4012-b834-72030849a37d");
pub const MF_MT_FRAME_RATE = Guid.initString("c459a2e8-3d2c-4e44-b132-fee5156c7bb0");
pub const MF_MT_PIXEL_ASPECT_RATIO = Guid.initString("c6376a1e-8d0a-4027-be45-6d9a0ad39bb6");
pub const MF_MT_DRM_FLAGS = Guid.initString("8772f323-355a-4cc7-bb78-6d61a048ae82");
pub const MF_MT_TIMESTAMP_CAN_BE_DTS = Guid.initString("24974215-1b7b-41e4-8625-ac469f2dedaa");
pub const MF_MT_PAD_CONTROL_FLAGS = Guid.initString("4d0e73e5-80ea-4354-a9d0-1176ceb028ea");
pub const MF_MT_SOURCE_CONTENT_HINT = Guid.initString("68aca3cc-22d0-44e6-85f8-28167197fa38");
pub const MF_MT_VIDEO_CHROMA_SITING = Guid.initString("65df2370-c773-4c33-aa64-843e068efb0c");
pub const MF_MT_INTERLACE_MODE = Guid.initString("e2724bb8-e676-4806-b4b2-a8d6efb44ccd");
pub const MF_MT_TRANSFER_FUNCTION = Guid.initString("5fb0fce9-be5c-4935-a811-ec838f8eed93");
pub const MF_MT_VIDEO_PRIMARIES = Guid.initString("dbfbe4d7-0740-4ee0-8192-850ab0e21935");
pub const MF_MT_MAX_LUMINANCE_LEVEL = Guid.initString("50253128-c110-4de4-98ae-46a324fae6da");
pub const MF_MT_MAX_FRAME_AVERAGE_LUMINANCE_LEVEL = Guid.initString("58d4bf57-6f52-4733-a195-a9e29ecf9e27");
pub const MF_MT_MAX_MASTERING_LUMINANCE = Guid.initString("d6c6b997-272f-4ca1-8d00-8042111a0ff6");
pub const MF_MT_MIN_MASTERING_LUMINANCE = Guid.initString("839a4460-4e7e-4b4f-ae79-cc08905c7b27");
pub const MF_MT_DECODER_USE_MAX_RESOLUTION = Guid.initString("4c547c24-af9a-4f38-96ad-978773cf53e7");
pub const MF_MT_DECODER_MAX_DPB_COUNT = Guid.initString("67be144c-88b7-4ca9-9628-c808d5262217");
pub const MF_MT_CUSTOM_VIDEO_PRIMARIES = Guid.initString("47537213-8cfb-4722-aa34-fbc9e24d77b8");
pub const MF_MT_YUV_MATRIX = Guid.initString("3e23d450-2c75-4d25-a00e-b91670d12327");
pub const MF_MT_VIDEO_LIGHTING = Guid.initString("53a0529c-890b-4216-8bf9-599367ad6d20");
pub const MF_MT_VIDEO_NOMINAL_RANGE = Guid.initString("c21b8ee5-b956-4071-8daf-325edf5cab11");
pub const MF_MT_GEOMETRIC_APERTURE = Guid.initString("66758743-7e5f-400d-980a-aa8596c85696");
pub const MF_MT_MINIMUM_DISPLAY_APERTURE = Guid.initString("d7388766-18fe-48c6-a177-ee894867c8c4");
pub const MF_MT_PAN_SCAN_APERTURE = Guid.initString("79614dde-9187-48fb-b8c7-4d52689de649");
pub const MF_MT_PAN_SCAN_ENABLED = Guid.initString("4b7f6bc3-8b13-40b2-a993-abf630b8204e");
pub const MF_MT_AVG_BITRATE = Guid.initString("20332624-fb0d-4d9e-bd0d-cbf6786c102e");
pub const MF_MT_AVG_BIT_ERROR_RATE = Guid.initString("799cabd6-3508-4db4-a3c7-569cd533deb1");
pub const MF_MT_MAX_KEYFRAME_SPACING = Guid.initString("c16eb52b-73a1-476f-8d62-839d6a020652");
pub const MF_MT_USER_DATA = Guid.initString("b6bc765f-4c3b-40a4-bd51-2535b66fe09d");
pub const MF_MT_OUTPUT_BUFFER_NUM = Guid.initString("a505d3ac-f930-436e-8ede-93a509ce23b2");
pub const MF_MT_REALTIME_CONTENT = Guid.initString("bb12d222-2bdb-425e-91ec-2308e189a58f");
pub const MF_MT_DEFAULT_STRIDE = Guid.initString("644b4e48-1e02-4516-b0eb-c01ca9d49ac6");
pub const MF_MT_PALETTE = Guid.initString("6d283f42-9846-4410-afd9-654d503b1a54");
pub const MF_MT_AM_FORMAT_TYPE = Guid.initString("73d1072d-1870-4174-a063-29ff4ff6c11e");
pub const MF_MT_VIDEO_PROFILE = Guid.initString("ad76a80b-2d5c-4e0b-b375-64e520137036");
pub const MF_MT_VIDEO_LEVEL = Guid.initString("96f66574-11c5-4015-8666-bff516436da7");
pub const MF_MT_MPEG_START_TIME_CODE = Guid.initString("91f67885-4333-4280-97cd-bd5a6c03a06e");
pub const MF_MT_MPEG2_PROFILE = Guid.initString("ad76a80b-2d5c-4e0b-b375-64e520137036");
pub const MF_MT_MPEG2_LEVEL = Guid.initString("96f66574-11c5-4015-8666-bff516436da7");
pub const MF_MT_MPEG2_FLAGS = Guid.initString("31e3991d-f701-4b2f-b426-8ae3bda9e04b");
pub const MF_MT_MPEG_SEQUENCE_HEADER = Guid.initString("3c036de7-3ad0-4c9e-9216-ee6d6ac21cb3");
pub const MF_MT_MPEG2_STANDARD = Guid.initString("a20af9e8-928a-4b26-aaa9-f05c74cac47c");
pub const MF_MT_MPEG2_TIMECODE = Guid.initString("5229ba10-e29d-4f80-a59c-df4f180207d2");
pub const MF_MT_MPEG2_CONTENT_PACKET = Guid.initString("825d55e4-4f12-4197-9eb3-59b6e4710f06");
pub const MF_MT_MPEG2_ONE_FRAME_PER_PACKET = Guid.initString("91a49eb5-1d20-4b42-ace8-804269bf95ed");
pub const MF_MT_MPEG2_HDCP = Guid.initString("168f1b4a-3e91-450f-aea7-e4baeadae5ba");
pub const MF_MT_H264_MAX_CODEC_CONFIG_DELAY = Guid.initString("f5929986-4c45-4fbb-bb49-6cc534d05b9b");
pub const MF_MT_H264_SUPPORTED_SLICE_MODES = Guid.initString("c8be1937-4d64-4549-8343-a8086c0bfda5");
pub const MF_MT_H264_SUPPORTED_SYNC_FRAME_TYPES = Guid.initString("89a52c01-f282-48d2-b522-22e6ae633199");
pub const MF_MT_H264_RESOLUTION_SCALING = Guid.initString("e3854272-f715-4757-ba90-1b696c773457");
pub const MF_MT_H264_SIMULCAST_SUPPORT = Guid.initString("9ea2d63d-53f0-4a34-b94e-9de49a078cb3");
pub const MF_MT_H264_SUPPORTED_RATE_CONTROL_MODES = Guid.initString("6a8ac47e-519c-4f18-9bb3-7eeaaea5594d");
pub const MF_MT_H264_MAX_MB_PER_SEC = Guid.initString("45256d30-7215-4576-9336-b0f1bcd59bb2");
pub const MF_MT_H264_SUPPORTED_USAGES = Guid.initString("60b1a998-dc01-40ce-9736-aba845a2dbdc");
pub const MF_MT_H264_CAPABILITIES = Guid.initString("bb3bd508-490a-11e0-99e4-1316dfd72085");
pub const MF_MT_H264_SVC_CAPABILITIES = Guid.initString("f8993abe-d937-4a8f-bbca-6966fe9e1152");
pub const MF_MT_H264_USAGE = Guid.initString("359ce3a5-af00-49ca-a2f4-2ac94ca82b61");
pub const MF_MT_H264_RATE_CONTROL_MODES = Guid.initString("705177d8-45cb-11e0-ac7d-b91ce0d72085");
pub const MF_MT_H264_LAYOUT_PER_STREAM = Guid.initString("85e299b2-90e3-4fe8-b2f5-c067e0bfe57a");
pub const MF_MT_IN_BAND_PARAMETER_SET = Guid.initString("75da5090-910b-4a03-896c-7b898feea5af");
pub const MF_MT_MPEG4_TRACK_TYPE = Guid.initString("54f486dd-9327-4f6d-80ab-6f709ebb4cce");
pub const MF_MT_CONTAINER_RATE_SCALING = Guid.initString("83877f5e-0444-4e28-8479-6db0989b8c09");
pub const MF_MT_DV_AAUX_SRC_PACK_0 = Guid.initString("84bd5d88-0fb8-4ac8-be4b-a8848bef98f3");
pub const MF_MT_DV_AAUX_CTRL_PACK_0 = Guid.initString("f731004e-1dd1-4515-aabe-f0c06aa536ac");
pub const MF_MT_DV_AAUX_SRC_PACK_1 = Guid.initString("720e6544-0225-4003-a651-0196563a958e");
pub const MF_MT_DV_AAUX_CTRL_PACK_1 = Guid.initString("cd1f470d-1f04-4fe0-bfb9-d07ae0386ad8");
pub const MF_MT_DV_VAUX_SRC_PACK = Guid.initString("41402d9d-7b57-43c6-b129-2cb997f15009");
pub const MF_MT_DV_VAUX_CTRL_PACK = Guid.initString("2f84e1c4-0da1-4788-938e-0dfbfbb34b48");
pub const MF_MT_ARBITRARY_HEADER = Guid.initString("9e6bd6f5-0109-4f95-84ac-9309153a19fc");
pub const MF_MT_ARBITRARY_FORMAT = Guid.initString("5a75b249-0d7d-49a1-a1c3-e0d87f0cade5");
pub const MF_MT_IMAGE_LOSS_TOLERANT = Guid.initString("ed062cf4-e34e-4922-be99-934032133d7c");
pub const MF_MT_MPEG4_SAMPLE_DESCRIPTION = Guid.initString("261e9d83-9529-4b8f-a111-8b9c950a81a9");
pub const MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY = Guid.initString("9aa7e155-b64a-4c1d-a500-455d600b6560");
pub const MF_SD_AMBISONICS_SAMPLE3D_DESCRIPTION = Guid.initString("f715cf3e-a964-4c3f-94ae-9d6ba7264641");
pub const MF_MT_ORIGINAL_4CC = Guid.initString("d7be3fe0-2bc7-492d-b843-61a1919b70c3");
pub const MF_MT_ORIGINAL_WAVE_FORMAT_TAG = Guid.initString("8cbbc843-9fd9-49c2-882f-a72586c408ad");
pub const MF_MT_FRAME_RATE_RANGE_MIN = Guid.initString("d2e7558c-dc1f-403f-9a72-d28bb1eb3b5e");
pub const MF_MT_FRAME_RATE_RANGE_MAX = Guid.initString("e3371d41-b4cf-4a05-bd4e-20b88bb2c4d6");
pub const MF_LOW_LATENCY = Guid.initString("9c27891a-ed7a-40e1-88e8-b22727a024ee");
pub const MF_VIDEO_MAX_MB_PER_SEC = Guid.initString("e3f2e203-d445-4b8c-9211-ae390d3ba017");
pub const MF_DISABLE_FRAME_CORRUPTION_INFO = Guid.initString("7086e16c-49c5-4201-882a-8538f38cf13a");
pub const MFStreamExtension_CameraExtrinsics = Guid.initString("686196d0-13e2-41d9-9638-ef032c272a52");
pub const MFSampleExtension_CameraExtrinsics = Guid.initString("6b761658-b7ec-4c3b-8225-8623cabec31d");
pub const MFStreamExtension_PinholeCameraIntrinsics = Guid.initString("dbac0455-0ec8-4aef-9c32-7a3ee3456f53");
pub const MFSampleExtension_PinholeCameraIntrinsics = Guid.initString("4ee3b6c5-6a15-4e72-9761-70c1db8b9fe3");
pub const MFMediaType_Default = Guid.initString("81a412e6-8103-4b06-857f-1862781024ac");
pub const MFMediaType_Audio = Guid.initString("73647561-0000-0010-8000-00aa00389b71");
pub const MFMediaType_Video = Guid.initString("73646976-0000-0010-8000-00aa00389b71");
pub const MFMediaType_Protected = Guid.initString("7b4b6fe6-9d04-4494-be14-7e0bd076c8e4");
pub const MFMediaType_SAMI = Guid.initString("e69669a0-3dcd-40cb-9e2e-3708387c0616");
pub const MFMediaType_Script = Guid.initString("72178c22-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFMediaType_Image = Guid.initString("72178c23-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFMediaType_HTML = Guid.initString("72178c24-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFMediaType_Binary = Guid.initString("72178c25-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFMediaType_FileTransfer = Guid.initString("72178c26-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFMediaType_Stream = Guid.initString("e436eb83-524f-11ce-9f53-0020af0ba770");
pub const MFMediaType_MultiplexedFrames = Guid.initString("6ea542b0-281f-4231-a464-fe2f5022501c");
pub const MFMediaType_Subtitle = Guid.initString("a6d13581-ed50-4e65-ae08-26065576aacc");
pub const MFMediaType_Perception = Guid.initString("597ff6f9-6ea2-4670-85b4-ea84073fe940");
pub const MFImageFormat_JPEG = Guid.initString("19e4a5aa-5662-4fc5-a0c0-1758028e1057");
pub const MFImageFormat_RGB32 = Guid.initString("00000016-0000-0010-8000-00aa00389b71");
pub const MFStreamFormat_MPEG2Transport = Guid.initString("e06d8023-db46-11cf-b4d1-00805f6cbbea");
pub const MFStreamFormat_MPEG2Program = Guid.initString("263067d1-d330-45dc-b669-34d986e4e3e1");
pub const AM_MEDIA_TYPE_REPRESENTATION = Guid.initString("e2e42ad2-132c-491e-a268-3c7c2dca181f");
pub const FORMAT_MFVideoFormat = Guid.initString("aed4ab2d-7326-43cb-9464-c879cab9c43d");
pub const MFMediaType_Metadata = Guid.initString("2c8fa20c-82bb-4782-90a0-98a2a5bd8ef8");
pub const CLSID_MFSourceResolver = Guid.initString("90eab60f-e43a-4188-bcc4-e47fdf04868c");
pub const MF_DEVICESTREAM_ATTRIBUTE_FACEAUTH_CAPABILITY = Guid.initString("cb6fd12a-2248-4e41-ad46-e78bb90ab9fc");
pub const MF_DEVICESTREAM_ATTRIBUTE_SECURE_CAPABILITY = Guid.initString("940fd626-ea6e-4684-9840-36bd6ec9fbef");
pub const MEDIASINK_FIXED_STREAMS = @as(u32, 1);
pub const MEDIASINK_CANNOT_MATCH_CLOCK = @as(u32, 2);
pub const MEDIASINK_RATELESS = @as(u32, 4);
pub const MEDIASINK_CLOCK_REQUIRED = @as(u32, 8);
pub const MEDIASINK_CAN_PREROLL = @as(u32, 16);
pub const MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE = @as(u32, 32);
pub const MFCLOCK_FREQUENCY_HNS = @as(u32, 10000000);
pub const MFCLOCK_TOLERANCE_UNKNOWN = @as(u32, 50000);
pub const MFCLOCK_JITTER_ISR = @as(u32, 1000);
pub const MFCLOCK_JITTER_DPC = @as(u32, 4000);
pub const MFCLOCK_JITTER_PASSIVE = @as(u32, 10000);
pub const PRESENTATION_CURRENT_POSITION = @as(u64, 9223372036854775807);
pub const MF_PD_ADAPTIVE_STREAMING = Guid.initString("ea0d5d97-29f9-488b-ae6b-7d6b4136112b");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_CROSSPROCESS = @as(u32, 1);
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_NOPERSIST = @as(u32, 2);
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_DONT_ALLOW_FORMAT_CHANGES = @as(u32, 4);
pub const MFRR_INFO_VERSION = @as(u32, 0);
pub const MF_USER_MODE_COMPONENT_LOAD = @as(u32, 1);
pub const MF_KERNEL_MODE_COMPONENT_LOAD = @as(u32, 2);
pub const MF_GRL_LOAD_FAILED = @as(u32, 16);
pub const MF_INVALID_GRL_SIGNATURE = @as(u32, 32);
pub const MF_GRL_ABSENT = @as(u32, 4096);
pub const MF_COMPONENT_REVOKED = @as(u32, 8192);
pub const MF_COMPONENT_INVALID_EKU = @as(u32, 16384);
pub const MF_COMPONENT_CERT_REVOKED = @as(u32, 32768);
pub const MF_COMPONENT_INVALID_ROOT = @as(u32, 65536);
pub const MF_COMPONENT_HS_CERT_REVOKED = @as(u32, 131072);
pub const MF_COMPONENT_LS_CERT_REVOKED = @as(u32, 262144);
pub const MF_BOOT_DRIVER_VERIFICATION_FAILED = @as(u32, 1048576);
pub const MF_TEST_SIGNED_COMPONENT_LOADING = @as(u32, 16777216);
pub const MF_MINCRYPT_FAILURE = @as(u32, 268435456);
pub const SHA_HASH_LEN = @as(u32, 20);
pub const MFSEQUENCER_INVALID_ELEMENT_ID = @as(u32, 4294967295);
pub const MF_WRAPPED_BUFFER_SERVICE = Guid.initString("ab544072-c269-4ebc-a552-1c3b32bed5ca");
pub const CLSID_MPEG2ByteStreamPlugin = Guid.initString("40871c59-ab40-471f-8dc3-1f259d862479");
pub const MFCONTENTPROTECTIONDEVICE_FUNCTIONID_START = @as(u32, 67108864);
pub const MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA_FUNCTIONID = @as(u32, 67108864);
pub const MF_UNKNOWN_DURATION = @as(u32, 0);
pub const MFStreamExtension_ExtendedCameraIntrinsics = Guid.initString("aa74b3df-9a2c-48d6-8393-5bd1c1a81e6e");
pub const MFSampleExtension_ExtendedCameraIntrinsics = Guid.initString("560bc4a5-4de0-4113-9cdc-832db9740f3d");
pub const MF_INVALID_PRESENTATION_TIME = @as(u64, 9223372036854775808);
pub const MF_MEDIATYPE_EQUAL_MAJOR_TYPES = @as(u32, 1);
pub const MF_MEDIATYPE_EQUAL_FORMAT_TYPES = @as(u32, 2);
pub const MF_MEDIATYPE_EQUAL_FORMAT_DATA = @as(u32, 4);
pub const MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA = @as(u32, 8);
pub const MFASYNC_FAST_IO_PROCESSING_CALLBACK = @as(u32, 1);
pub const MFASYNC_SIGNAL_CALLBACK = @as(u32, 2);
pub const MFASYNC_BLOCKING_CALLBACK = @as(u32, 4);
pub const MFASYNC_REPLY_CALLBACK = @as(u32, 8);
pub const MFASYNC_LOCALIZE_REMOTE_CALLBACK = @as(u32, 16);
pub const MFASYNC_CALLBACK_QUEUE_UNDEFINED = @as(u32, 0);
pub const MFASYNC_CALLBACK_QUEUE_STANDARD = @as(u32, 1);
pub const MFASYNC_CALLBACK_QUEUE_RT = @as(u32, 2);
pub const MFASYNC_CALLBACK_QUEUE_IO = @as(u32, 3);
pub const MFASYNC_CALLBACK_QUEUE_TIMER = @as(u32, 4);
pub const MFASYNC_CALLBACK_QUEUE_MULTITHREADED = @as(u32, 5);
pub const MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION = @as(u32, 7);
pub const MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK = @as(u32, 4294901760);
pub const MFASYNC_CALLBACK_QUEUE_ALL = @as(u32, 4294967295);
pub const MFBYTESTREAM_IS_READABLE = @as(u32, 1);
pub const MFBYTESTREAM_IS_WRITABLE = @as(u32, 2);
pub const MFBYTESTREAM_IS_SEEKABLE = @as(u32, 4);
pub const MFBYTESTREAM_IS_REMOTE = @as(u32, 8);
pub const MFBYTESTREAM_IS_DIRECTORY = @as(u32, 128);
pub const MFBYTESTREAM_HAS_SLOW_SEEK = @as(u32, 256);
pub const MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED = @as(u32, 512);
pub const MFBYTESTREAM_SHARE_WRITE = @as(u32, 1024);
pub const MFBYTESTREAM_DOES_NOT_USE_NETWORK = @as(u32, 2048);
pub const MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO = @as(u32, 1);
pub const MF_MEDIA_SHARING_ENGINE_INITIAL_SEEK_TIME = Guid.initString("6f3497f5-d528-4a4f-8dd7-db36657ec4c9");
pub const MF_SHUTDOWN_RENDERER_ON_ENGINE_SHUTDOWN = Guid.initString("c112d94d-6b9c-48f8-b6f9-7950ff9ab71e");
pub const MF_PREFERRED_SOURCE_URI = Guid.initString("5fc85488-436a-4db8-90af-4db402ae5c57");
pub const MF_SHARING_ENGINE_SHAREDRENDERER = Guid.initString("efa446a0-73e7-404e-8ae2-fef60af5a32b");
pub const MF_SHARING_ENGINE_CALLBACK = Guid.initString("57dc1e95-d252-43fa-9bbc-180070eefe6d");
pub const MFT_STREAMS_UNLIMITED = @as(u32, 4294967295);
pub const MFT_OUTPUT_BOUND_UPPER_UNBOUNDED = @as(u64, 9223372036854775807);
pub const OPM_GET_CURRENT_HDCP_SRM_VERSION = Guid.initString("99c5ceff-5f1d-4879-81c1-c52443c9482b");
pub const OPM_GET_CONNECTED_HDCP_DEVICE_INFORMATION = Guid.initString("0db59d74-a992-492e-a0bd-c23fda564e00");
pub const OPM_GET_ACP_AND_CGMSA_SIGNALING = Guid.initString("6629a591-3b79-4cf3-924a-11e8e7811671");
pub const OPM_GET_CONNECTOR_TYPE = Guid.initString("81d0bfd5-6afe-48c2-99c0-95a08f97c5da");
pub const OPM_GET_SUPPORTED_PROTECTION_TYPES = Guid.initString("38f2a801-9a6c-48bb-9107-b6696e6f1797");
pub const OPM_GET_VIRTUAL_PROTECTION_LEVEL = Guid.initString("b2075857-3eda-4d5d-88db-748f8c1a0549");
pub const OPM_GET_ACTUAL_PROTECTION_LEVEL = Guid.initString("1957210a-7766-452a-b99a-d27aed54f03a");
pub const OPM_GET_ACTUAL_OUTPUT_FORMAT = Guid.initString("d7bf1ba3-ad13-4f8e-af98-0dcb3ca204cc");
pub const OPM_GET_ADAPTER_BUS_TYPE = Guid.initString("c6f4d673-6174-4184-8e35-f6db5200bcba");
pub const OPM_GET_OUTPUT_ID = Guid.initString("72cb6df3-244f-40ce-b09e-20506af6302f");
pub const OPM_GET_DVI_CHARACTERISTICS = Guid.initString("a470b3bb-5dd7-4172-839c-3d3776e0ebf5");
pub const OPM_GET_CODEC_INFO = Guid.initString("4f374491-8f5f-4445-9dba-95588f6b58b4");
pub const OPM_GET_OUTPUT_HARDWARE_PROTECTION_SUPPORT = Guid.initString("3b129589-2af8-4ef0-96a2-704a845a218e");
pub const OPM_SET_PROTECTION_LEVEL = Guid.initString("9bb9327c-4eb5-4727-9f00-b42b0919c0da");
pub const OPM_SET_ACP_AND_CGMSA_SIGNALING = Guid.initString("09a631a5-d684-4c60-8e4d-d3bb0f0be3ee");
pub const OPM_SET_HDCP_SRM = Guid.initString("8b5ef5d1-c30d-44ff-84a5-ea71dce78f13");
pub const OPM_SET_PROTECTION_LEVEL_ACCORDING_TO_CSS_DVD = Guid.initString("39ce333e-4cc0-44ae-bfcc-da50b5f82e72");
pub const WM_CODEC_ONEPASS_CBR = @as(u32, 1);
pub const WM_CODEC_ONEPASS_VBR = @as(u32, 2);
pub const WM_CODEC_TWOPASS_CBR = @as(u32, 4);
pub const WM_CODEC_TWOPASS_VBR_UNCONSTRAINED = @as(u32, 8);
pub const WM_CODEC_TWOPASS_VBR_PEAKCONSTRAINED = @as(u32, 16);
pub const SYSFXUI_DONOTSHOW_LOUDNESSEQUALIZATION = @as(u32, 1);
pub const SYSFXUI_DONOTSHOW_ROOMCORRECTION = @as(u32, 2);
pub const SYSFXUI_DONOTSHOW_BASSMANAGEMENT = @as(u32, 4);
pub const SYSFXUI_DONOTSHOW_BASSBOOST = @as(u32, 8);
pub const SYSFXUI_DONOTSHOW_HEADPHONEVIRTUALIZATION = @as(u32, 16);
pub const SYSFXUI_DONOTSHOW_VIRTUALSURROUND = @as(u32, 32);
pub const SYSFXUI_DONOTSHOW_SPEAKERFILLING = @as(u32, 64);
pub const SYSFXUI_DONOTSHOW_CHANNELPHANTOMING = @as(u32, 128);
pub const AEC_MAX_SYSTEM_MODES = @as(u32, 6);
pub const WMAAECMA_E_NO_ACTIVE_RENDER_STREAM = @as(u32, 2278293514);
pub const MEDIASUBTYPE_Y41T = Guid.initString("54313459-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_Y42T = Guid.initString("54323459-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_NV11 = Guid.initString("3131564e-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_V216 = Guid.initString("36313256-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_V410 = Guid.initString("30313456-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_v210 = Guid.initString("30313276-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_I420 = Guid.initString("30323449-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WVC1 = Guid.initString("31435657-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wvc1 = Guid.initString("31637677-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMVA = Guid.initString("41564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmva = Guid.initString("61766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMVB = Guid.initString("42564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmvb = Guid.initString("62766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMVR = Guid.initString("52564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmvr = Guid.initString("72766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMVP = Guid.initString("50564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmvp = Guid.initString("70766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WVP2 = Guid.initString("32505657-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wvp2 = Guid.initString("32707677-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMV3 = Guid.initString("33564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmv3 = Guid.initString("33766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMV2 = Guid.initString("32564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmv2 = Guid.initString("32766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMV1 = Guid.initString("31564d57-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_wmv1 = Guid.initString("31766d77-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MPG4 = Guid.initString("3447504d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_mpg4 = Guid.initString("3467706d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MP42 = Guid.initString("3234504d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_mp42 = Guid.initString("3234706d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MP43 = Guid.initString("3334504d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_mp43 = Guid.initString("3334706d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MP4S = Guid.initString("5334504d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_mp4s = Guid.initString("7334706d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_M4S2 = Guid.initString("3253344d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_m4s2 = Guid.initString("3273346d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MSS1 = Guid.initString("3153534d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MSS2 = Guid.initString("3253534d-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MSAUDIO1 = Guid.initString("00000160-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMAUDIO2 = Guid.initString("00000161-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMAUDIO3 = Guid.initString("00000162-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMAUDIO_LOSSLESS = Guid.initString("00000163-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMASPDIF = Guid.initString("00000164-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_WMAUDIO4 = Guid.initString("00000168-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MPEG_ADTS_AAC = Guid.initString("00001600-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MPEG_RAW_AAC = Guid.initString("00001601-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MPEG_LOAS = Guid.initString("00001602-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_NOKIA_MPEG_ADTS_AAC = Guid.initString("00001608-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_NOKIA_MPEG_RAW_AAC = Guid.initString("00001609-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_VODAFONE_MPEG_ADTS_AAC = Guid.initString("0000160a-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_VODAFONE_MPEG_RAW_AAC = Guid.initString("0000160b-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_MPEG_HEAAC = Guid.initString("00001610-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_RAW_AAC1 = Guid.initString("000000ff-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_DVM = Guid.initString("00002000-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_DTS2 = Guid.initString("00002001-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_DOLBY_DDPLUS = Guid.initString("a7fb87af-2d02-42fb-a4d4-05cd93843bdd");
pub const MEDIASUBTYPE_DOLBY_TRUEHD = Guid.initString("eb27cec4-163e-4ca3-8b74-8e25f91b517e");
pub const MEDIASUBTYPE_DTS_HD = Guid.initString("a2e58eb7-0fa9-48bb-a40c-fa0e156d0645");
pub const MEDIASUBTYPE_DTS_HD_HRA = Guid.initString("a61ac364-ad0e-4744-89ff-213ce0df8804");
pub const MEDIASUBTYPE_h264 = Guid.initString("34363268-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_AVC1 = Guid.initString("31435641-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_X264 = Guid.initString("34363258-0000-0010-8000-00aa00389b71");
pub const MEDIASUBTYPE_x264 = Guid.initString("34363278-0000-0010-8000-00aa00389b71");
pub const MF_VIDEODSP_MODE = Guid.initString("16d720f0-768c-11de-8a39-0800200c9a66");
pub const MFSampleExtension_VideoDSPMode = Guid.initString("c12d55cb-d7d9-476d-81f3-69117f163ea0");
pub const CLSID_CTocEntry = Guid.initString("f22f5e05-585c-4def-8523-6555cfbc0cb3");
pub const CLSID_CTocEntryList = Guid.initString("3a8cccbc-0efd-43a3-b838-f38a552ba237");
pub const CLSID_CToc = Guid.initString("4fe24495-28ce-4920-a4c4-e556e1f0df2a");
pub const CLSID_CTocCollection = Guid.initString("5058292d-a244-4840-ab44-480975c4ffe4");
pub const CLSID_CTocParser = Guid.initString("499eaeea-2737-4849-8bb6-47f107eaf358");
pub const CLSID_CAsfTocParser = Guid.initString("9b77c0f2-8735-46c5-b90f-5f0b303ef6ab");
pub const CLSID_CAviTocParser = Guid.initString("3adce5cc-13c8-4573-b328-ed438eb694f9");
pub const CLSID_CFileIo = Guid.initString("11993195-1244-4840-ab44-480975c4ffe4");
pub const CLSID_CFileClient = Guid.initString("bfccd195-1244-4840-ab44-480975c4ffe4");
pub const CLSID_CClusterDetectorEx = Guid.initString("47354492-827e-4b8a-b318-c80eba1381f0");
pub const E_TOCPARSER_INVALIDASFFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1728053247));
pub const E_TOCPARSER_INVALIDRIFFFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1728053246));
pub const TOC_MAX_DESCRIPTION_SIZE = @as(u32, 65535);
pub const TOC_ENTRY_MAX_TITLE_SIZE = @as(u32, 65535);
pub const MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC = @as(u32, 65535);
pub const MFASFINDEXER_NO_FIXED_INTERVAL = @as(u32, 4294967295);
pub const MFASFINDEXER_READ_FOR_REVERSEPLAYBACK_OUTOFDATASEGMENT = @as(u64, 18446744073709551615);
pub const MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN = @as(u64, 18446744073709551615);
pub const MFASF_MAX_STREAM_NUMBER = @as(u32, 127);
pub const MFASF_INVALID_STREAM_NUMBER = @as(u32, 128);
pub const MFASF_PAYLOADEXTENSION_MAX_SIZE = @as(u32, 255);
pub const MFASF_PAYLOADEXTENSION_VARIABLE_SIZE = @as(u32, 65535);
pub const MFASF_DEFAULT_BUFFER_WINDOW_MS = @as(u32, 3000);
pub const FACILITY_MF = @as(u32, 13);
pub const FACILITY_MF_WIN32 = @as(u32, 7);
pub const MF_E_PLATFORM_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875856));
pub const MF_E_BUFFERTOOSMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875855));
pub const MF_E_INVALIDREQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875854));
pub const MF_E_INVALIDSTREAMNUMBER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875853));
pub const MF_E_INVALIDMEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875852));
pub const MF_E_NOTACCEPTING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875851));
pub const MF_E_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875850));
pub const MF_E_UNSUPPORTED_REPRESENTATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875849));
pub const MF_E_NO_MORE_TYPES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875847));
pub const MF_E_UNSUPPORTED_SERVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875846));
pub const MF_E_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875845));
pub const MF_E_INVALIDNAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875844));
pub const MF_E_INVALIDTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875843));
pub const MF_E_INVALID_FILE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875842));
pub const MF_E_INVALIDINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875841));
pub const MF_E_INVALID_TIMESTAMP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875840));
pub const MF_E_UNSUPPORTED_SCHEME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875837));
pub const MF_E_UNSUPPORTED_BYTESTREAM_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875836));
pub const MF_E_UNSUPPORTED_TIME_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875835));
pub const MF_E_NO_SAMPLE_TIMESTAMP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875832));
pub const MF_E_NO_SAMPLE_DURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875831));
pub const MF_E_INVALID_STREAM_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875829));
pub const MF_E_RT_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875825));
pub const MF_E_UNSUPPORTED_RATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875824));
pub const MF_E_THINNING_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875823));
pub const MF_E_REVERSE_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875822));
pub const MF_E_UNSUPPORTED_RATE_TRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875821));
pub const MF_E_RATE_CHANGE_PREEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875820));
pub const MF_E_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875819));
pub const MF_E_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875818));
pub const MF_E_NO_CLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875817));
pub const MF_S_MULTIPLE_BEGIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, 866008));
pub const MF_E_MULTIPLE_BEGIN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875815));
pub const MF_E_MULTIPLE_SUBSCRIBERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875814));
pub const MF_E_TIMER_ORPHANED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875813));
pub const MF_E_STATE_TRANSITION_PENDING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875812));
pub const MF_E_UNSUPPORTED_STATE_TRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875811));
pub const MF_E_UNRECOVERABLE_ERROR_OCCURRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875810));
pub const MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875809));
pub const MF_E_SAMPLE_NOT_WRITABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875808));
pub const MF_E_INVALID_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875806));
pub const MF_E_BAD_STARTUP_VERSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875805));
pub const MF_E_UNSUPPORTED_CAPTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875804));
pub const MF_E_INVALID_POSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875803));
pub const MF_E_ATTRIBUTENOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875802));
pub const MF_E_PROPERTY_TYPE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875801));
pub const MF_E_PROPERTY_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875800));
pub const MF_E_PROPERTY_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875799));
pub const MF_E_PROPERTY_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875798));
pub const MF_E_PROPERTY_VECTOR_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875797));
pub const MF_E_PROPERTY_VECTOR_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875796));
pub const MF_E_OPERATION_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875795));
pub const MF_E_BYTESTREAM_NOT_SEEKABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875794));
pub const MF_E_DISABLED_IN_SAFEMODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875793));
pub const MF_E_CANNOT_PARSE_BYTESTREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875792));
pub const MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875791));
pub const MF_E_MEDIAPROC_WRONGSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875790));
pub const MF_E_RT_THROUGHPUT_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875789));
pub const MF_E_RT_TOO_MANY_CLASSES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875788));
pub const MF_E_RT_WOULDBLOCK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875787));
pub const MF_E_NO_BITPUMP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875786));
pub const MF_E_RT_OUTOFMEMORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875785));
pub const MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875784));
pub const MF_E_INSUFFICIENT_BUFFER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860816));
pub const MF_E_CANNOT_CREATE_SINK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875782));
pub const MF_E_BYTESTREAM_UNKNOWN_LENGTH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875781));
pub const MF_E_SESSION_PAUSEWHILESTOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875780));
pub const MF_S_ACTIVATE_REPLACED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 866045));
pub const MF_E_FORMAT_CHANGE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875778));
pub const MF_E_INVALID_WORKQUEUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875777));
pub const MF_E_DRM_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875776));
pub const MF_E_UNAUTHORIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875775));
pub const MF_E_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875774));
pub const MF_E_INVALID_CODEC_MERIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875773));
pub const MF_E_HW_MFT_FAILED_START_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875772));
pub const MF_E_OPERATION_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875771));
pub const MF_E_HARDWARE_DRM_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875770));
pub const MF_E_DURATION_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875769));
pub const MF_E_OPERATION_UNSUPPORTED_AT_D3D_FEATURE_LEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875768));
pub const MF_E_UNSUPPORTED_MEDIATYPE_AT_D3D_FEATURE_LEVEL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072875767));
pub const MF_S_ASF_PARSEINPROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074608792));
pub const MF_E_ASF_PARSINGINCOMPLETE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874856));
pub const MF_E_ASF_MISSINGDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874855));
pub const MF_E_ASF_INVALIDDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874854));
pub const MF_E_ASF_OPAQUEPACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874853));
pub const MF_E_ASF_NOINDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874852));
pub const MF_E_ASF_OUTOFRANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874851));
pub const MF_E_ASF_INDEXNOTLOADED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874850));
pub const MF_E_ASF_TOO_MANY_PAYLOADS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874849));
pub const MF_E_ASF_UNSUPPORTED_STREAM_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874848));
pub const MF_E_ASF_DROPPED_PACKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072874847));
pub const MF_E_NO_EVENTS_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873856));
pub const MF_E_INVALID_STATE_TRANSITION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873854));
pub const MF_E_END_OF_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873852));
pub const MF_E_SHUTDOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873851));
pub const MF_E_MP3_NOTFOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873850));
pub const MF_E_MP3_OUTOFDATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873849));
pub const MF_E_MP3_NOTMP3 = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873848));
pub const MF_E_MP3_NOTSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873847));
pub const MF_E_NO_DURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873846));
pub const MF_E_INVALID_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873844));
pub const MF_E_PROPERTY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873843));
pub const MF_E_PROPERTY_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873842));
pub const MF_E_PROPERTY_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873841));
pub const MF_E_MEDIA_SOURCE_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873839));
pub const MF_E_UNSUPPORTED_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873832));
pub const MF_E_MP3_BAD_CRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873831));
pub const MF_E_NOT_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873830));
pub const MF_E_MEDIA_SOURCE_WRONGSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873829));
pub const MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873828));
pub const MF_E_CANNOT_FIND_KEYFRAME_SAMPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873827));
pub const MF_E_UNSUPPORTED_CHARACTERISTICS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873826));
pub const MF_E_NO_AUDIO_RECORDING_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873825));
pub const MF_E_AUDIO_RECORDING_DEVICE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873824));
pub const MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873823));
pub const MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873822));
pub const MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072873821));
pub const MF_E_NETWORK_RESOURCE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872856));
pub const MF_E_NET_WRITE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872855));
pub const MF_E_NET_READ = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872854));
pub const MF_E_NET_REQUIRE_NETWORK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872853));
pub const MF_E_NET_REQUIRE_ASYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872852));
pub const MF_E_NET_BWLEVEL_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872851));
pub const MF_E_NET_STREAMGROUPS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872850));
pub const MF_E_NET_MANUALSS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872849));
pub const MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872848));
pub const MF_E_NET_CACHESTREAM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872847));
pub const MF_I_MANUAL_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, 1074610802));
pub const MF_E_NET_REQUIRE_INPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872844));
pub const MF_E_NET_REDIRECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872843));
pub const MF_E_NET_REDIRECT_TO_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872842));
pub const MF_E_NET_TOO_MANY_REDIRECTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872841));
pub const MF_E_NET_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872840));
pub const MF_E_NET_CLIENT_CLOSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872839));
pub const MF_E_NET_BAD_CONTROL_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872838));
pub const MF_E_NET_INCOMPATIBLE_SERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872837));
pub const MF_E_NET_UNSAFE_URL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872836));
pub const MF_E_NET_CACHE_NO_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872835));
pub const MF_E_NET_EOL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872834));
pub const MF_E_NET_BAD_REQUEST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872833));
pub const MF_E_NET_INTERNAL_SERVER_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872832));
pub const MF_E_NET_SESSION_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872831));
pub const MF_E_NET_NOCONNECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872830));
pub const MF_E_NET_CONNECTION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872829));
pub const MF_E_NET_INCOMPATIBLE_PUSHSERVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872828));
pub const MF_E_NET_SERVER_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872827));
pub const MF_E_NET_PROXY_ACCESSDENIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872826));
pub const MF_E_NET_CANNOTCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872825));
pub const MF_E_NET_INVALID_PUSH_TEMPLATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872824));
pub const MF_E_NET_INVALID_PUSH_PUBLISHING_POINT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872823));
pub const MF_E_NET_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872822));
pub const MF_E_NET_RESOURCE_GONE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872821));
pub const MF_E_NET_ERROR_FROM_PROXY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872820));
pub const MF_E_NET_PROXY_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872819));
pub const MF_E_NET_SERVER_UNAVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872818));
pub const MF_E_NET_TOO_MUCH_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872817));
pub const MF_E_NET_SESSION_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872816));
pub const MF_E_OFFLINE_MODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872815));
pub const MF_E_NET_UDP_BLOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872814));
pub const MF_E_NET_UNSUPPORTED_CONFIGURATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872813));
pub const MF_E_NET_PROTOCOL_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872812));
pub const MF_E_NET_COMPANION_DRIVER_DISCONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072872811));
pub const MF_E_ALREADY_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871856));
pub const MF_E_BANDWIDTH_OVERRUN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871855));
pub const MF_E_LATE_SAMPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871854));
pub const MF_E_FLUSH_NEEDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871853));
pub const MF_E_INVALID_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871852));
pub const MF_E_INDEX_NOT_COMMITTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871851));
pub const MF_E_NO_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871850));
pub const MF_E_CANNOT_INDEX_IN_PLACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871849));
pub const MF_E_MISSING_ASF_LEAKYBUCKET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871848));
pub const MF_E_INVALID_ASF_STREAMID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072871847));
pub const MF_E_STREAMSINK_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870856));
pub const MF_E_STREAMSINKS_OUT_OF_SYNC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870854));
pub const MF_E_STREAMSINKS_FIXED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870853));
pub const MF_E_STREAMSINK_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870852));
pub const MF_E_SAMPLEALLOCATOR_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870851));
pub const MF_E_SAMPLEALLOCATOR_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870850));
pub const MF_E_SINK_ALREADYSTOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870849));
pub const MF_E_ASF_FILESINK_BITRATE_UNKNOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870848));
pub const MF_E_SINK_NO_STREAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870847));
pub const MF_S_SINK_NOT_FINALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 870978));
pub const MF_E_METADATA_TOO_LONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870845));
pub const MF_E_SINK_NO_SAMPLES_PROCESSED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870844));
pub const MF_E_SINK_HEADERS_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072870843));
pub const MF_E_VIDEO_REN_NO_PROCAMP_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869856));
pub const MF_E_VIDEO_REN_NO_DEINTERLACE_HW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869855));
pub const MF_E_VIDEO_REN_COPYPROT_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869854));
pub const MF_E_VIDEO_REN_SURFACE_NOT_SHARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869853));
pub const MF_E_VIDEO_DEVICE_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869852));
pub const MF_E_NEW_VIDEO_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869851));
pub const MF_E_NO_VIDEO_SAMPLE_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869850));
pub const MF_E_NO_AUDIO_PLAYBACK_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869756));
pub const MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869755));
pub const MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869754));
pub const MF_E_AUDIO_SERVICE_NOT_RUNNING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869753));
pub const MF_E_AUDIO_BUFFER_SIZE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869752));
pub const MF_E_AUDIO_CLIENT_WRAPPER_SPOOF_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072869751));
pub const MF_E_TOPO_INVALID_OPTIONAL_NODE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868850));
pub const MF_E_TOPO_CANNOT_FIND_DECRYPTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868847));
pub const MF_E_TOPO_CODEC_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868846));
pub const MF_E_TOPO_CANNOT_CONNECT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868845));
pub const MF_E_TOPO_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868844));
pub const MF_E_TOPO_INVALID_TIME_ATTRIBUTES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868843));
pub const MF_E_TOPO_LOOPS_IN_TOPOLOGY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868842));
pub const MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868841));
pub const MF_E_TOPO_MISSING_STREAM_DESCRIPTOR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868840));
pub const MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868839));
pub const MF_E_TOPO_MISSING_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868838));
pub const MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072868837));
pub const MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072864852));
pub const MF_S_SEQUENCER_CONTEXT_CANCELED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 876973));
pub const MF_E_NO_SOURCE_IN_CACHE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072864850));
pub const MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, 876975));
pub const MF_E_TRANSFORM_TYPE_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861856));
pub const MF_E_TRANSFORM_STREAM_CHANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861855));
pub const MF_E_TRANSFORM_INPUT_REMAINING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861854));
pub const MF_E_TRANSFORM_PROFILE_MISSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861853));
pub const MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861852));
pub const MF_E_TRANSFORM_PROFILE_TRUNCATED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861851));
pub const MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861850));
pub const MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861849));
pub const MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861848));
pub const MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861847));
pub const MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861846));
pub const MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861845));
pub const MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861844));
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861843));
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861842));
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861841));
pub const MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861840));
pub const MF_E_TRANSFORM_NEED_MORE_INPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861838));
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861837));
pub const MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861836));
pub const MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 879989));
pub const MF_E_UNSUPPORTED_D3D_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861834));
pub const MF_E_TRANSFORM_ASYNC_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861833));
pub const MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861832));
pub const MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861831));
pub const MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861830));
pub const MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072861828));
pub const MF_E_LICENSE_INCORRECT_RIGHTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860856));
pub const MF_E_LICENSE_OUTOFDATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860855));
pub const MF_E_LICENSE_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860854));
pub const MF_E_DRM_HARDWARE_INCONSISTENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860853));
pub const MF_E_NO_CONTENT_PROTECTION_MANAGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860852));
pub const MF_E_LICENSE_RESTORE_NO_RIGHTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860851));
pub const MF_E_BACKUP_RESTRICTED_LICENSE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860850));
pub const MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860849));
pub const MF_S_PROTECTION_NOT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 880976));
pub const MF_E_COMPONENT_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860847));
pub const MF_E_TRUST_DISABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860846));
pub const MF_E_WMDRMOTA_NO_ACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860845));
pub const MF_E_WMDRMOTA_ACTION_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860844));
pub const MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860843));
pub const MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860842));
pub const MF_E_WMDRMOTA_ACTION_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860841));
pub const MF_E_WMDRMOTA_INVALID_POLICY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860840));
pub const MF_E_POLICY_UNSUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860839));
pub const MF_E_OPL_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860838));
pub const MF_E_TOPOLOGY_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860837));
pub const MF_E_SIGNATURE_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860836));
pub const MF_E_DEBUGGING_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860835));
pub const MF_E_CODE_EXPIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860834));
pub const MF_E_GRL_VERSION_TOO_LOW = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860833));
pub const MF_E_GRL_RENEWAL_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860832));
pub const MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860831));
pub const MF_E_KERNEL_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860830));
pub const MF_E_PEAUTH_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860829));
pub const MF_E_NON_PE_PROCESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860827));
pub const MF_E_REBOOT_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860825));
pub const MF_S_WAIT_FOR_POLICY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, 881000));
pub const MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, 881001));
pub const MF_E_GRL_INVALID_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860822));
pub const MF_E_GRL_UNRECOGNIZED_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860821));
pub const MF_E_ALL_PROCESS_RESTART_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860820));
pub const MF_E_PROCESS_RESTART_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860819));
pub const MF_E_USERMODE_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860818));
pub const MF_E_PEAUTH_SESSION_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860817));
pub const MF_E_PEAUTH_PUBLICKEY_REVOKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860815));
pub const MF_E_GRL_ABSENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860814));
pub const MF_S_PE_TRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 881011));
pub const MF_E_PE_UNTRUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860812));
pub const MF_E_PEAUTH_NOT_STARTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860811));
pub const MF_E_INCOMPATIBLE_SAMPLE_PROTECTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860810));
pub const MF_E_PE_SESSIONS_MAXED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860809));
pub const MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860808));
pub const MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860807));
pub const MF_E_ITA_UNSUPPORTED_ACTION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860806));
pub const MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860805));
pub const MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860804));
pub const MF_E_BAD_OPL_STRUCTURE_FORMAT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860803));
pub const MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860802));
pub const MF_E_NO_PMP_HOST = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860801));
pub const MF_E_ITA_OPL_DATA_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860800));
pub const MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860799));
pub const MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860798));
pub const MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860797));
pub const MF_E_INVALID_AKE_CHANNEL_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860796));
pub const MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860795));
pub const MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860794));
pub const MF_E_DRM_MIGRATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860793));
pub const MF_E_HDCP_AUTHENTICATION_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860792));
pub const MF_E_HDCP_LINK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072860791));
pub const MF_E_CLOCK_INVALID_CONTINUITY_KEY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072849856));
pub const MF_E_CLOCK_NO_TIME_SOURCE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072849855));
pub const MF_E_CLOCK_STATE_ALREADY_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072849854));
pub const MF_E_CLOCK_NOT_SIMPLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072849853));
pub const MF_S_CLOCK_STOPPED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 891972));
pub const MF_E_CLOCK_AUDIO_DEVICE_POSITION_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 891973));
pub const MF_E_CLOCK_AUDIO_RENDER_POSITION_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 891974));
pub const MF_E_CLOCK_AUDIO_RENDER_TIME_UNEXPECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 891975));
pub const MF_E_NO_MORE_DROP_MODES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072848856));
pub const MF_E_NO_MORE_QUALITY_LEVELS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072848855));
pub const MF_E_DROPTIME_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072848854));
pub const MF_E_QUALITYKNOB_WAIT_LONGER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072848853));
pub const MF_E_QM_INVALIDSTATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072848852));
pub const MF_E_TRANSCODE_NO_CONTAINERTYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072847856));
pub const MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072847855));
pub const MF_E_TRANSCODE_NO_MATCHING_ENCODER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072847854));
pub const MF_E_TRANSCODE_INVALID_PROFILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072847853));
pub const MF_E_ALLOCATOR_NOT_INITIALIZED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072846856));
pub const MF_E_ALLOCATOR_NOT_COMMITED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072846855));
pub const MF_E_ALLOCATOR_ALREADY_COMMITED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072846854));
pub const MF_E_STREAM_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072846853));
pub const MF_E_INVALID_STREAM_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072846852));
pub const MF_E_HW_STREAM_NOT_CONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072846851));
pub const MF_E_NO_CAPTURE_DEVICES_AVAILABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845856));
pub const MF_E_CAPTURE_SINK_OUTPUT_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845855));
pub const MF_E_CAPTURE_SINK_MIRROR_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845854));
pub const MF_E_CAPTURE_SINK_ROTATE_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845853));
pub const MF_E_CAPTURE_ENGINE_INVALID_OP = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845852));
pub const MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845851));
pub const MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845850));
pub const MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845849));
pub const MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845848));
pub const MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845847));
pub const MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845846));
pub const MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845845));
pub const MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845844));
pub const MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072845843));
pub const MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072844856));
pub const MF_E_TIMELINECONTROLLER_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072844855));
pub const MF_E_TIMELINECONTROLLER_CANNOT_ATTACH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072844854));
pub const MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072843856));
pub const MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072843855));
pub const MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072843854));
pub const MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1072843853));
pub const MF_INDEX_SIZE_ERR = @as(u32, 2154823681);
pub const MF_NOT_FOUND_ERR = @as(u32, 2154823688);
pub const MF_NOT_SUPPORTED_ERR = @as(u32, 2154823689);
pub const MF_INVALID_STATE_ERR = @as(u32, 2154823691);
pub const MF_SYNTAX_ERR = @as(u32, 2154823692);
pub const MF_INVALID_ACCESS_ERR = @as(u32, 2154823695);
pub const MF_QUOTA_EXCEEDED_ERR = @as(u32, 2154823702);
pub const MF_PARSE_ERR = @as(u32, 2154823761);
pub const MF_TYPE_ERR = @as(u32, 2154840069);
pub const DEVPKEY_DeviceInterface_IsVirtualCamera = PROPERTYKEY{ .fmtid = Guid.initString("6edc630d-c2e3-43b7-b2d1-20525a1af120"), .pid = 3 };
pub const g_wszSpeechFormatCaps = "SpeechFormatCap";
pub const g_wszWMCPCodecName = "_CODECNAME";
pub const g_wszWMCPSupportedVBRModes = "_SUPPORTEDVBRMODES";
pub const g_wszWMCPAudioVBRSupported = "_VBRENABLED";
pub const g_wszWMCPAudioVBRQuality = "_VBRQUALITY";
pub const g_wszWMCPMaxPasses = "_PASSESRECOMMENDED";
pub const g_wszWMCPDefaultCrisp = "_DEFAULTCRISP";
pub const COPP_ProtectionType_Unknown = @as(i32, -2147483648);
pub const COPP_ProtectionType_None = @as(i32, 0);
pub const COPP_ProtectionType_HDCP = @as(i32, 1);
pub const COPP_ProtectionType_ACP = @as(i32, 2);
pub const COPP_ProtectionType_CGMSA = @as(i32, 4);
pub const COPP_ProtectionType_Mask = @as(i32, -2147483641);
pub const COPP_ProtectionType_Reserved = @as(i32, 2147483640);
pub const MF_BYTESTREAM_ORIGIN_NAME = Guid.initString("fc358288-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_CONTENT_TYPE = Guid.initString("fc358289-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_DURATION = Guid.initString("fc35828a-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_LAST_MODIFIED_TIME = Guid.initString("fc35828b-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_IFO_FILE_URI = Guid.initString("fc35828c-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_DLNA_PROFILE_ID = Guid.initString("fc35828d-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_EFFECTIVE_URL = Guid.initString("9afa0209-89d1-42af-8456-1de6b562d691");
pub const MF_BYTESTREAM_TRANSCODED = Guid.initString("b6c5c282-4dc9-4db9-ab48-cf3b6d8bc5e0");
pub const CLSID_MFByteStreamProxyClassFactory = Guid.initString("770e8e77-4916-441c-a9a7-b342d0eebc71");
pub const MEDeviceStreamCreated = Guid.initString("0252a1cf-3540-43b4-9164-d72eb405fa40");
pub const MF_SA_D3D_AWARE = Guid.initString("eaa35c29-775e-488e-9b61-b3283e49583b");
pub const MF_SA_REQUIRED_SAMPLE_COUNT = Guid.initString("18802c61-324b-4952-abd0-176ff5c696ff");
pub const MFT_END_STREAMING_AWARE = Guid.initString("70fbc845-b07e-4089-b064-399dc6110f29");
pub const MF_SA_AUDIO_ENDPOINT_AWARE = Guid.initString("c0381701-805c-42b2-ac8d-e2b4bf21f4f8");
pub const MFT_AUDIO_DECODER_AUDIO_ENDPOINT_ID = Guid.initString("c7ccdd6e-5398-4695-8be7-51b3e95111bd");
pub const MFT_AUDIO_DECODER_SPATIAL_METADATA_CLIENT = Guid.initString("05987df4-1270-4999-925f-8e939a7c0af7");
pub const MF_DMFT_FRAME_BUFFER_INFO = Guid.initString("396ce1c9-67a9-454c-8797-95a45799d804");
pub const MF_SA_REQUIRED_SAMPLE_COUNT_PROGRESSIVE = Guid.initString("b172d58e-fa77-4e48-8d2a-1df2d850eac2");
pub const MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT = Guid.initString("851745d5-c3d6-476d-9527-498ef2d10d18");
pub const MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT_PROGRESSIVE = Guid.initString("0f5523a5-1cb2-47c5-a550-2eeb84b4d14a");
pub const MFT_SUPPORT_3DVIDEO = Guid.initString("093f81b1-4f2e-4631-8168-7934032a01d3");
pub const MF_ENABLE_3DVIDEO_OUTPUT = Guid.initString("bdad7bca-0e5f-4b10-ab16-26de381b6293");
pub const MF_SA_D3D11_BINDFLAGS = Guid.initString("eacf97ad-065c-4408-bee3-fdcbfd128be2");
pub const MF_SA_D3D11_USAGE = Guid.initString("e85fe442-2ca3-486e-a9c7-109dda609880");
pub const MF_SA_D3D11_AWARE = Guid.initString("206b4fc8-fcf9-4c51-afe3-9764369e33a0");
pub const MF_SA_D3D11_SHARED = Guid.initString("7b8f32c3-6d96-4b89-9203-dd38b61414f3");
pub const MF_SA_D3D11_SHARED_WITHOUT_MUTEX = Guid.initString("39dbd44d-2e44-4931-a4c8-352d3dc42115");
pub const MF_SA_D3D11_ALLOW_DYNAMIC_YUV_TEXTURE = Guid.initString("ce06d49f-0613-4b9d-86a6-d8c4f9c10075");
pub const MF_SA_D3D11_HW_PROTECTED = Guid.initString("3a8ba9d9-92ca-4307-a391-6999dbf3b6ce");
pub const MF_SA_BUFFERS_PER_SAMPLE = Guid.initString("873c5171-1e3d-4e25-988d-b433ce041983");
pub const MF_SA_D3D11_ALLOCATE_DISPLAYABLE_RESOURCES = Guid.initString("eeface6d-2ea9-4adf-bbdf-7bbc482a1b6d");
pub const MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER = Guid.initString("ef80833f-f8fa-44d9-80d8-41ed6232670c");
pub const MFT_DECODER_QUALITY_MANAGEMENT_CUSTOM_CONTROL = Guid.initString("a24e30d7-de25-4558-bbfb-71070a2d332e");
pub const MFT_DECODER_QUALITY_MANAGEMENT_RECOVERY_WITHOUT_ARTIFACTS = Guid.initString("d8980deb-0a48-425f-8623-611db41d3810");
pub const MFT_REMUX_MARK_I_PICTURE_AS_CLEAN_POINT = Guid.initString("364e8f85-3f2e-436c-b2a2-4440a012a9e8");
pub const MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT = Guid.initString("dc2f8496-15c4-407a-b6f0-1b66ab5fbf53");
pub const MFT_ENCODER_SUPPORTS_CONFIG_EVENT = Guid.initString("86a355ae-3a77-4ec4-9f31-01149a4e92de");
pub const MFT_ENUM_HARDWARE_VENDOR_ID_Attribute = Guid.initString("3aecb0cc-035b-4bcc-8185-2b8d551ef3af");
pub const MF_TRANSFORM_ASYNC = Guid.initString("f81a699a-649a-497d-8c73-29f8fed6ad7a");
pub const MF_TRANSFORM_ASYNC_UNLOCK = Guid.initString("e5666d6b-3422-4eb6-a421-da7db1f8e207");
pub const MF_TRANSFORM_FLAGS_Attribute = Guid.initString("9359bb7e-6275-46c4-a025-1c01e45f1a86");
pub const MF_TRANSFORM_CATEGORY_Attribute = Guid.initString("ceabba49-506d-4757-a6ff-66c184987e4e");
pub const MFT_TRANSFORM_CLSID_Attribute = Guid.initString("6821c42b-65a4-4e82-99bc-9a88205ecd0c");
pub const MFT_INPUT_TYPES_Attributes = Guid.initString("4276c9b1-759d-4bf3-9cd0-0d723d138f96");
pub const MFT_OUTPUT_TYPES_Attributes = Guid.initString("8eae8cf3-a44f-4306-ba5c-bf5dda242818");
pub const MFT_ENUM_HARDWARE_URL_Attribute = Guid.initString("2fb866ac-b078-4942-ab6c-003d05cda674");
pub const MFT_FRIENDLY_NAME_Attribute = Guid.initString("314ffbae-5b41-4c95-9c19-4e7d586face3");
pub const MFT_CONNECTED_STREAM_ATTRIBUTE = Guid.initString("71eeb820-a59f-4de2-bcec-38db1dd611a4");
pub const MFT_CONNECTED_TO_HW_STREAM = Guid.initString("34e6e728-06d6-4491-a553-4795650db912");
pub const MFT_PREFERRED_OUTPUTTYPE_Attribute = Guid.initString("7e700499-396a-49ee-b1b4-f628021e8c9d");
pub const MFT_PROCESS_LOCAL_Attribute = Guid.initString("543186e4-4649-4e65-b588-4aa352aff379");
pub const MFT_PREFERRED_ENCODER_PROFILE = Guid.initString("53004909-1ef5-46d7-a18e-5a75f8b5905f");
pub const MFT_HW_TIMESTAMP_WITH_QPC_Attribute = Guid.initString("8d030fb8-cc43-4258-a22e-9210bef89be4");
pub const MFT_FIELDOFUSE_UNLOCK_Attribute = Guid.initString("8ec2e9fd-9148-410d-831e-702439461a8e");
pub const MFT_CODEC_MERIT_Attribute = Guid.initString("88a7cb15-7b07-4a34-9128-e64c6703c4d3");
pub const MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE = Guid.initString("111ea8cd-b62a-4bdb-89f6-67ffcdc2458b");
pub const MFT_AUDIO_DECODER_DEGRADATION_INFO_ATTRIBUTE = Guid.initString("6c3386ad-ec20-430d-b2a5-505c7178d9c4");
pub const MFT_POLICY_SET_AWARE = Guid.initString("5a633b19-cc39-4fa8-8ca5-59981b7a0018");
pub const MFT_USING_HARDWARE_DRM = Guid.initString("34faa77d-d79e-4957-b8ce-362b2684996c");
pub const MF_WVC1_PROG_SINGLE_SLICE_CONTENT = Guid.initString("67ec2559-0f2f-4420-a4dd-2f8ee7a5738b");
pub const MF_PROGRESSIVE_CODING_CONTENT = Guid.initString("8f020eea-1508-471f-9da6-507d7cfa40db");
pub const MF_NALU_LENGTH_SET = Guid.initString("a7911d53-12a4-4965-ae70-6eadd6ff0551");
pub const MF_NALU_LENGTH_INFORMATION = Guid.initString("19124e7c-ad4b-465f-bb18-20186287b6af");
pub const MF_USER_DATA_PAYLOAD = Guid.initString("d1d4985d-dc92-457a-b3a0-651a33a31047");
pub const MF_MPEG4SINK_SPSPPS_PASSTHROUGH = Guid.initString("5601a134-2005-4ad2-b37d-22a6c554deb2");
pub const MF_MPEG4SINK_MOOV_BEFORE_MDAT = Guid.initString("f672e3ac-e1e6-4f10-b5ec-5f3b30828816");
pub const MF_MPEG4SINK_MINIMUM_PROPERTIES_SIZE = Guid.initString("dca1ed52-450e-4a22-8c62-4ed452f7a187");
pub const MF_MPEG4SINK_MIN_FRAGMENT_DURATION = Guid.initString("a30b570c-8efd-45e8-94fe-27c84b5bdff6");
pub const MF_MPEG4SINK_MAX_CODED_SEQUENCES_PER_FRAGMENT = Guid.initString("fc1b3bd6-692d-4ce5-9299-738aa5463e9a");
pub const MF_SESSION_TOPOLOADER = Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f71");
pub const MF_SESSION_GLOBAL_TIME = Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f72");
pub const MF_SESSION_QUALITY_MANAGER = Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f73");
pub const MF_SESSION_CONTENT_PROTECTION_MANAGER = Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f74");
pub const MF_SESSION_SERVER_CONTEXT = Guid.initString("afe5b291-50fa-46e8-b9be-0c0c3ce4b3a5");
pub const MF_SESSION_REMOTE_SOURCE_MODE = Guid.initString("f4033ef4-9bb3-4378-941f-85a0856bc244");
pub const MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME = Guid.initString("190e852f-6238-42d1-b5af-69ea338ef850");
pub const MF_PMP_SERVER_CONTEXT = Guid.initString("2f00c910-d2cf-4278-8b6a-d077fac3a25f");
pub const MF_TIME_FORMAT_ENTRY_RELATIVE = Guid.initString("4399f178-46d3-4504-afda-20d32e9ba360");
pub const MF_SOURCE_STREAM_SUPPORTS_HW_CONNECTION = Guid.initString("a38253aa-6314-42fd-a3ce-bb27b6859946");
pub const MF_STREAM_SINK_SUPPORTS_HW_CONNECTION = Guid.initString("9b465cbf-0597-4f9e-9f3c-b97eeef90359");
pub const MF_STREAM_SINK_SUPPORTS_ROTATION = Guid.initString("b3e96280-bd05-41a5-97ad-8a7fee24b912");
pub const MF_SINK_VIDEO_PTS = Guid.initString("2162bde7-421e-4b90-9b33-e58fbf1d58b6");
pub const MF_SINK_VIDEO_NATIVE_WIDTH = Guid.initString("e6d6a707-1505-4747-9b10-72d2d158cb3a");
pub const MF_SINK_VIDEO_NATIVE_HEIGHT = Guid.initString("f0ca6705-490c-43e8-941c-c0b3206b9a65");
pub const MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_NUMERATOR = Guid.initString("d0f33b22-b78a-4879-b455-f03ef3fa82cd");
pub const MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_DENOMINATOR = Guid.initString("6ea1eb97-1fe0-4f10-a6e4-1f4f661564e0");
pub const MF_BD_MVC_PLANE_OFFSET_METADATA = Guid.initString("62a654e4-b76c-4901-9823-2cb615d47318");
pub const MF_LUMA_KEY_ENABLE = Guid.initString("7369820f-76de-43ca-9284-47b8f37e0649");
pub const MF_LUMA_KEY_LOWER = Guid.initString("93d7b8d5-0b81-4715-aea0-8725871621e9");
pub const MF_LUMA_KEY_UPPER = Guid.initString("d09f39bb-4602-4c31-a706-a12171a5110a");
pub const MF_USER_EXTENDED_ATTRIBUTES = Guid.initString("c02abac6-feb2-4541-922f-920b43702722");
pub const MF_INDEPENDENT_STILL_IMAGE = Guid.initString("ea12af41-0710-42c9-a127-daa3e78483a5");
pub const MF_XVP_SAMPLE_LOCK_TIMEOUT = Guid.initString("aa4ddb29-5134-4363-ac72-83ec4bc10426");
pub const MF_TOPOLOGY_PROJECTSTART = Guid.initString("7ed3f802-86bb-4b3f-b7e4-7cb43afd4b80");
pub const MF_TOPOLOGY_PROJECTSTOP = Guid.initString("7ed3f803-86bb-4b3f-b7e4-7cb43afd4b80");
pub const MF_TOPOLOGY_NO_MARKIN_MARKOUT = Guid.initString("7ed3f804-86bb-4b3f-b7e4-7cb43afd4b80");
pub const MF_TOPOLOGY_DXVA_MODE = Guid.initString("1e8d34f6-f5ab-4e23-bb88-874aa3a1a74d");
pub const MF_TOPOLOGY_ENABLE_XVP_FOR_PLAYBACK = Guid.initString("1967731f-cd78-42fc-b026-0992a56e5693");
pub const MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS = Guid.initString("b86cac42-41a6-4b79-897a-1ab0e52b4a1b");
pub const MF_TOPOLOGY_PLAYBACK_MAX_DIMS = Guid.initString("5715cf19-5768-44aa-ad6e-8721f1b0f9bb");
pub const MF_TOPOLOGY_HARDWARE_MODE = Guid.initString("d2d362fd-4e4f-4191-a579-c618b66706af");
pub const MF_TOPOLOGY_PLAYBACK_FRAMERATE = Guid.initString("c164737a-c2b1-4553-83bb-5a526072448f");
pub const MF_TOPOLOGY_DYNAMIC_CHANGE_NOT_ALLOWED = Guid.initString("d529950b-d484-4527-a9cd-b1909532b5b0");
pub const MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES = Guid.initString("6248c36d-5d0b-4f40-a0bb-b0b305f77698");
pub const MF_TOPOLOGY_START_TIME_ON_PRESENTATION_SWITCH = Guid.initString("c8cc113f-7951-4548-aad6-9ed6202e62b3");
pub const MF_DISABLE_LOCALLY_REGISTERED_PLUGINS = Guid.initString("66b16da9-add4-47e0-a16b-5af1fb483634");
pub const MF_LOCAL_PLUGIN_CONTROL_POLICY = Guid.initString("d91b0085-c86d-4f81-8822-8c68e1d7fa04");
pub const MF_TOPONODE_FLUSH = Guid.initString("494bbce8-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DRAIN = Guid.initString("494bbce9-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_D3DAWARE = Guid.initString("494bbced-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPOLOGY_RESOLUTION_STATUS = Guid.initString("494bbcde-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_ERRORCODE = Guid.initString("494bbcee-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_CONNECT_METHOD = Guid.initString("494bbcf1-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_LOCKED = Guid.initString("494bbcf7-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_ID = Guid.initString("494bbcf8-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_MMCSS_CLASS = Guid.initString("494bbcf9-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DECRYPTOR = Guid.initString("494bbcfa-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DISCARDABLE = Guid.initString("494bbcfb-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_ERROR_MAJORTYPE = Guid.initString("494bbcfd-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_ERROR_SUBTYPE = Guid.initString("494bbcfe-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_MMCSS_TASKID = Guid.initString("494bbcff-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_MMCSS_PRIORITY = Guid.initString("5001f840-2816-48f4-9364-ad1ef661a123");
pub const MF_TOPONODE_WORKQUEUE_ITEM_PRIORITY = Guid.initString("a1ff99be-5e97-4a53-b494-568c642c0ff3");
pub const MF_TOPONODE_MARKIN_HERE = Guid.initString("494bbd00-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_MARKOUT_HERE = Guid.initString("494bbd01-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DECODER = Guid.initString("494bbd02-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_MEDIASTART = Guid.initString("835c58ea-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_MEDIASTOP = Guid.initString("835c58eb-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_SOURCE = Guid.initString("835c58ec-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_PRESENTATION_DESCRIPTOR = Guid.initString("835c58ed-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_STREAM_DESCRIPTOR = Guid.initString("835c58ee-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_SEQUENCE_ELEMENTID = Guid.initString("835c58ef-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_TRANSFORM_OBJECTID = Guid.initString("88dcc0c9-293e-4e8b-9aeb-0ad64cc016b0");
pub const MF_TOPONODE_STREAMID = Guid.initString("14932f9b-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_NOSHUTDOWN_ON_REMOVE = Guid.initString("14932f9c-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_RATELESS = Guid.initString("14932f9d-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_DISABLE_PREROLL = Guid.initString("14932f9e-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_PRIMARYOUTPUT = Guid.initString("6304ef99-16b2-4ebe-9d67-e4c539b3a259");
pub const MF_PD_PMPHOST_CONTEXT = Guid.initString("6c990d31-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_APP_CONTEXT = Guid.initString("6c990d32-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_DURATION = Guid.initString("6c990d33-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_TOTAL_FILE_SIZE = Guid.initString("6c990d34-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_AUDIO_ENCODING_BITRATE = Guid.initString("6c990d35-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_VIDEO_ENCODING_BITRATE = Guid.initString("6c990d36-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_MIME_TYPE = Guid.initString("6c990d37-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_LAST_MODIFIED_TIME = Guid.initString("6c990d38-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_PLAYBACK_ELEMENT_ID = Guid.initString("6c990d39-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_PREFERRED_LANGUAGE = Guid.initString("6c990d3a-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_PLAYBACK_BOUNDARY_TIME = Guid.initString("6c990d3b-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_AUDIO_ISVARIABLEBITRATE = Guid.initString("33026ee0-e387-4582-ae0a-34a2ad3baa18");
pub const MF_SD_LANGUAGE = Guid.initString("00af2180-bdc2-423c-abca-f503593bc121");
pub const MF_SD_PROTECTED = Guid.initString("00af2181-bdc2-423c-abca-f503593bc121");
pub const MF_SD_STREAM_NAME = Guid.initString("4f1b099d-d314-41e5-a781-7fefaa4c501f");
pub const MF_SD_MUTUALLY_EXCLUSIVE = Guid.initString("023ef79c-388d-487f-ac17-696cd6e3c6f5");
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID = Guid.initString("ba491360-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE = Guid.initString("ba491361-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS = Guid.initString("ba491362-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID = Guid.initString("ba491364-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE = Guid.initString("ba491365-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS = Guid.initString("ba491366-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_MFT_LOCKED = Guid.initString("c1f6093c-7f65-4fbd-9e39-5faec3c4fbd7");
pub const MF_ACTIVATE_VIDEO_WINDOW = Guid.initString("9a2dbbdd-f57e-4162-82b9-6831377682d3");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS = Guid.initString("ede4b5e0-f805-4d6c-99b3-db01bf95dfab");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID = Guid.initString("ede4b5e3-f805-4d6c-99b3-db01bf95dfab");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID = Guid.initString("b10aaec3-ef71-4cc3-b873-05a9a08b9f8e");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE = Guid.initString("6ba644ff-27c5-4d02-9887-c28619fdb91b");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY = Guid.initString("a9770471-92ec-4df4-94fe-81c36f0c3a7a");
pub const MFENABLETYPE_WMDRMV1_LicenseAcquisition = Guid.initString("4ff6eeaf-0b43-4797-9b85-abf31815e7b0");
pub const MFENABLETYPE_WMDRMV7_LicenseAcquisition = Guid.initString("003306df-4a06-4884-a097-ef6d22ec84a3");
pub const MFENABLETYPE_WMDRMV7_Individualization = Guid.initString("acd2c84a-b303-4f65-bc2c-2c848d01a989");
pub const MFENABLETYPE_MF_UpdateRevocationInformation = Guid.initString("e558b0b5-b3c4-44a0-924c-50d178932385");
pub const MFENABLETYPE_MF_UpdateUntrustedComponent = Guid.initString("9879f3d6-cee2-48e6-b573-9767ab172f16");
pub const MFENABLETYPE_MF_RebootRequired = Guid.initString("6d4d3d4b-0ece-4652-8b3a-f2d24260d887");
pub const MF_METADATA_PROVIDER_SERVICE = Guid.initString("db214084-58a4-4d2e-b84f-6f755b2f7a0d");
pub const MF_PROPERTY_HANDLER_SERVICE = Guid.initString("a3face02-32b8-41dd-90e7-5fef7c8991b5");
pub const MF_RATE_CONTROL_SERVICE = Guid.initString("866fa297-b802-4bf8-9dc9-5e3b6a9f53c9");
pub const MF_TIMECODE_SERVICE = Guid.initString("a0d502a7-0eb3-4885-b1b9-9feb0d083454");
pub const MR_POLICY_VOLUME_SERVICE = Guid.initString("1abaa2ac-9d3b-47c6-ab48-c59506de784d");
pub const MR_CAPTURE_POLICY_VOLUME_SERVICE = Guid.initString("24030acd-107a-4265-975c-414e33e65f2a");
pub const MR_STREAM_VOLUME_SERVICE = Guid.initString("f8b5fa2f-32ef-46f5-b172-1321212fb2c4");
pub const MR_AUDIO_POLICY_SERVICE = Guid.initString("911fd737-6775-4ab0-a614-297862fdac88");
pub const MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET = Guid.initString("62e3d776-8100-4e03-a6e8-bd3857ac9c47");
pub const MF_SAMPLEGRABBERSINK_IGNORE_CLOCK = Guid.initString("0efda2c0-2b69-4e2e-ab8d-46dcbff7d25d");
pub const MF_QUALITY_SERVICES = Guid.initString("b7e2be11-2f96-4640-b52c-282365bdf16c");
pub const MF_WORKQUEUE_SERVICES = Guid.initString("8e37d489-41e0-413a-9068-287c886d8dda");
pub const MF_QUALITY_NOTIFY_PROCESSING_LATENCY = Guid.initString("f6b44af8-604d-46fe-a95d-45479b10c9bc");
pub const MF_QUALITY_NOTIFY_SAMPLE_LAG = Guid.initString("30d15206-ed2a-4760-be17-eb4a9f12295c");
pub const MF_TIME_FORMAT_SEGMENT_OFFSET = Guid.initString("c8b8be77-869c-431d-812e-169693f65a39");
pub const MF_SOURCE_PRESENTATION_PROVIDER_SERVICE = Guid.initString("e002aadc-f4af-4ee5-9847-053edf840426");
pub const MF_TOPONODE_ATTRIBUTE_EDITOR_SERVICE = Guid.initString("65656e1a-077f-4472-83ef-316f11d5087a");
pub const MFNETSOURCE_SSLCERTIFICATE_MANAGER = Guid.initString("55e6cb27-e69b-4267-940c-2d7ec5bb8a0f");
pub const MFNETSOURCE_RESOURCE_FILTER = Guid.initString("815d0ff6-265a-4477-9e46-7b80ad80b5fb");
pub const MFNET_SAVEJOB_SERVICE = Guid.initString("b85a587f-3d02-4e52-9565-55d3ec1e7ff7");
pub const MFNETSOURCE_STATISTICS_SERVICE = Guid.initString("3cb1f275-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_STATISTICS = Guid.initString("3cb1f274-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_BUFFERINGTIME = Guid.initString("3cb1f276-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ACCELERATEDSTREAMINGDURATION = Guid.initString("3cb1f277-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_MAXUDPACCELERATEDSTREAMINGDURATION = Guid.initString("4aab2879-bbe1-4994-9ff0-5495bd250129");
pub const MFNETSOURCE_MAXBUFFERTIMEMS = Guid.initString("408b24e6-4038-4401-b5b2-fe701a9ebf10");
pub const MFNETSOURCE_CONNECTIONBANDWIDTH = Guid.initString("3cb1f278-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_CACHEENABLED = Guid.initString("3cb1f279-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_AUTORECONNECTLIMIT = Guid.initString("3cb1f27a-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_RESENDSENABLED = Guid.initString("3cb1f27b-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_THINNINGENABLED = Guid.initString("3cb1f27c-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROTOCOL = Guid.initString("3cb1f27d-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_TRANSPORT = Guid.initString("3cb1f27e-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PREVIEWMODEENABLED = Guid.initString("3cb1f27f-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_CREDENTIAL_MANAGER = Guid.initString("3cb1f280-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PPBANDWIDTH = Guid.initString("3cb1f281-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_AUTORECONNECTPROGRESS = Guid.initString("3cb1f282-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYLOCATORFACTORY = Guid.initString("3cb1f283-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_BROWSERUSERAGENT = Guid.initString("3cb1f28b-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_BROWSERWEBPAGE = Guid.initString("3cb1f28c-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PLAYERVERSION = Guid.initString("3cb1f28d-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PLAYERID = Guid.initString("3cb1f28e-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_HOSTEXE = Guid.initString("3cb1f28f-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_HOSTVERSION = Guid.initString("3cb1f291-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PLAYERUSERAGENT = Guid.initString("3cb1f292-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_CLIENTGUID = Guid.initString("60a2c4a6-f197-4c14-a5bf-88830d2458af");
pub const MFNETSOURCE_LOGURL = Guid.initString("3cb1f293-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_UDP = Guid.initString("3cb1f294-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_TCP = Guid.initString("3cb1f295-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_MSB = Guid.initString("3cb1f296-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_RTSP = Guid.initString("3cb1f298-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_HTTP = Guid.initString("3cb1f299-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_STREAMING = Guid.initString("3cb1f29c-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_DOWNLOAD = Guid.initString("3cb1f29d-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_PRIVATEMODE = Guid.initString("824779d8-f18b-4405-8cf1-464fb5aa8f71");
pub const MFNETSOURCE_UDP_PORT_RANGE = Guid.initString("3cb1f29a-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYINFO = Guid.initString("3cb1f29b-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_DRMNET_LICENSE_REPRESENTATION = Guid.initString("47eae1bd-bdfe-42e2-82f3-54a48c17962d");
pub const MFNETSOURCE_PROXYSETTINGS = Guid.initString("3cb1f287-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYHOSTNAME = Guid.initString("3cb1f284-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYPORT = Guid.initString("3cb1f288-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYEXCEPTIONLIST = Guid.initString("3cb1f285-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYBYPASSFORLOCAL = Guid.initString("3cb1f286-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYRERUNAUTODETECTION = Guid.initString("3cb1f289-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_STREAM_LANGUAGE = Guid.initString("9ab44318-f7cd-4f2d-8d6d-fa35b492cecb");
pub const MFNETSOURCE_LOGPARAMS = Guid.initString("64936ae8-9418-453a-8cda-3e0a668b353b");
pub const MFNETSOURCE_PEERMANAGER = Guid.initString("48b29adb-febf-45ee-a9bf-efb81c492efc");
pub const MFNETSOURCE_FRIENDLYNAME = Guid.initString("5b2a7757-bc6b-447e-aa06-0dda1c646e2f");
pub const MF_BYTESTREAMHANDLER_ACCEPTS_SHARE_WRITE = Guid.initString("a6e1f733-3001-4915-8150-1558a2180ec8");
pub const MF_BYTESTREAM_SERVICE = Guid.initString("ab025e2b-16d9-4180-a127-ba6c70156161");
pub const MF_MEDIA_PROTECTION_MANAGER_PROPERTIES = Guid.initString("38bd81a9-acea-4c73-89b2-5532c0aeca79");
pub const MFCONNECTOR_SPDIF = Guid.initString("0b94a712-ad3e-4cee-83ce-ce32e3db6522");
pub const MFCONNECTOR_UNKNOWN = Guid.initString("ac3aef5c-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_PCI = Guid.initString("ac3aef5d-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_PCIX = Guid.initString("ac3aef5e-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_PCI_Express = Guid.initString("ac3aef5f-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_AGP = Guid.initString("ac3aef60-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_VGA = Guid.initString("57cd5968-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_SVIDEO = Guid.initString("57cd5969-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_COMPOSITE = Guid.initString("57cd596a-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_COMPONENT = Guid.initString("57cd596b-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_DVI = Guid.initString("57cd596c-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_HDMI = Guid.initString("57cd596d-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_LVDS = Guid.initString("57cd596e-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_D_JPN = Guid.initString("57cd5970-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_SDI = Guid.initString("57cd5971-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_DISPLAYPORT_EXTERNAL = Guid.initString("57cd5972-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_DISPLAYPORT_EMBEDDED = Guid.initString("57cd5973-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_UDI_EXTERNAL = Guid.initString("57cd5974-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_UDI_EMBEDDED = Guid.initString("57cd5975-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_MIRACAST = Guid.initString("57cd5977-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = Guid.initString("57cd5978-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = Guid.initString("57cd5979-ce47-11d9-92db-000bdb28ff98");
pub const MF_POLICY_ID = Guid.initString("b160c24d-c059-48f1-a901-9ee298a9a8c3");
pub const MFPROTECTION_DISABLE = Guid.initString("8cc6d81b-fec6-4d8f-964b-cfba0b0dad0d");
pub const MFPROTECTION_CONSTRICTVIDEO = Guid.initString("193370ce-c5e4-4c3a-8a66-6959b4da4442");
pub const MFPROTECTION_CONSTRICTVIDEO_NOOPM = Guid.initString("a580e8cd-c247-4957-b983-3c2eebd1ff59");
pub const MFPROTECTION_CONSTRICTAUDIO = Guid.initString("ffc99b44-df48-4e16-8e66-096892c1578a");
pub const MFPROTECTION_TRUSTEDAUDIODRIVERS = Guid.initString("65bdf3d2-0168-4816-a533-55d47b027101");
pub const MFPROTECTION_HDCP = Guid.initString("ae7cc03d-c828-4021-acb7-d578d27aaf13");
pub const MFPROTECTION_CGMSA = Guid.initString("e57e69e9-226b-4d31-b4e3-d3db008736dd");
pub const MFPROTECTION_ACP = Guid.initString("c3fd11c6-f8b7-4d20-b008-1db17d61f2da");
pub const MFPROTECTION_WMDRMOTA = Guid.initString("a267a6a1-362e-47d0-8805-4628598a23e4");
pub const MFPROTECTION_FFT = Guid.initString("462a56b2-2866-4bb6-980d-6d8d9edb1a8c");
pub const MFPROTECTION_PROTECTED_SURFACE = Guid.initString("4f5d9566-e742-4a25-8d1f-d287b5fa0ade");
pub const MFPROTECTION_DISABLE_SCREEN_SCRAPE = Guid.initString("a21179a4-b7cd-40d8-9614-8ef2371ba78d");
pub const MFPROTECTION_VIDEO_FRAMES = Guid.initString("36a59cbc-7401-4a8c-bc20-46a7c9e597f0");
pub const MFPROTECTION_HARDWARE = Guid.initString("4ee7f0c1-9ed7-424f-b6be-996b33528856");
pub const MFPROTECTION_HDCP_WITH_TYPE_ENFORCEMENT = Guid.initString("a4a585e8-ed60-442d-814d-db4d4220a06d");
pub const MFPROTECTIONATTRIBUTE_BEST_EFFORT = Guid.initString("c8e06331-75f0-4ec1-8e77-17578f773b46");
pub const MFPROTECTIONATTRIBUTE_FAIL_OVER = Guid.initString("8536abc5-38f1-4151-9cce-f55d941229ac");
pub const MFPROTECTION_GRAPHICS_TRANSFER_AES_ENCRYPTION = Guid.initString("c873de64-d8a5-49e6-88bb-fb963fd3d4ce");
pub const MFPROTECTIONATTRIBUTE_CONSTRICTVIDEO_IMAGESIZE = Guid.initString("008476fc-4b58-4d80-a790-e7297673161d");
pub const MFPROTECTIONATTRIBUTE_HDCP_SRM = Guid.initString("6f302107-3477-4468-8a08-eef9db10e20f");
pub const MF_SampleProtectionSalt = Guid.initString("5403deee-b9ee-438f-aa83-3804997e569d");
pub const MF_REMOTE_PROXY = Guid.initString("2f00c90e-d2cf-4278-8b6a-d077fac3a25f");
pub const CLSID_CreateMediaExtensionObject = Guid.initString("ef65a54d-0788-45b8-8b14-bc0f6a6b5137");
pub const MF_SAMI_SERVICE = Guid.initString("49a89ae7-b4d9-4ef2-aa5c-f65a3e05ae4e");
pub const MF_PD_SAMI_STYLELIST = Guid.initString("e0b73c7f-486d-484e-9872-4de5192a7bf8");
pub const MF_SD_SAMI_LANGUAGE = Guid.initString("36fcb98a-6cd0-44cb-acb9-a8f5600dd0bb");
pub const MF_TRANSCODE_CONTAINERTYPE = Guid.initString("150ff23f-4abc-478b-ac4f-e1916fba1cca");
pub const MFTranscodeContainerType_ASF = Guid.initString("430f6f6e-b6bf-4fc1-a0bd-9ee46eee2afb");
pub const MFTranscodeContainerType_MPEG4 = Guid.initString("dc6cd05d-b9d0-40ef-bd35-fa622c1ab28a");
pub const MFTranscodeContainerType_MP3 = Guid.initString("e438b912-83f1-4de6-9e3a-9ffbc6dd24d1");
pub const MFTranscodeContainerType_FLAC = Guid.initString("31344aa3-05a9-42b5-901b-8e9d4257f75e");
pub const MFTranscodeContainerType_3GP = Guid.initString("34c50167-4472-4f34-9ea0-c49fbacf037d");
pub const MFTranscodeContainerType_AC3 = Guid.initString("6d8d91c3-8c91-4ed1-8742-8c347d5b44d0");
pub const MFTranscodeContainerType_ADTS = Guid.initString("132fd27d-0f02-43de-a301-38fbbbb3834e");
pub const MFTranscodeContainerType_MPEG2 = Guid.initString("bfc2dbf9-7bb4-4f8f-afde-e112c44ba882");
pub const MFTranscodeContainerType_WAVE = Guid.initString("64c3453c-0f26-4741-be63-87bdf8bb935b");
pub const MFTranscodeContainerType_AVI = Guid.initString("7edfe8af-402f-4d76-a33c-619fd157d0f1");
pub const MFTranscodeContainerType_FMPEG4 = Guid.initString("9ba876f1-419f-4b77-a1e0-35959d9d4004");
pub const MFTranscodeContainerType_AMR = Guid.initString("025d5ad3-621a-475b-964d-66b1c824f079");
pub const MF_TRANSCODE_SKIP_METADATA_TRANSFER = Guid.initString("4e4469ef-b571-4959-8f83-3dcfba33a393");
pub const MF_TRANSCODE_TOPOLOGYMODE = Guid.initString("3e3df610-394a-40b2-9dea-3bab650bebf2");
pub const MF_TRANSCODE_ADJUST_PROFILE = Guid.initString("9c37c21b-060f-487c-a690-80d7f50d1c72");
pub const MF_TRANSCODE_ENCODINGPROFILE = Guid.initString("6947787c-f508-4ea9-b1e9-a1fe3a49fbc9");
pub const MF_TRANSCODE_QUALITYVSSPEED = Guid.initString("98332df8-03cd-476b-89fa-3f9e442dec9f");
pub const MF_TRANSCODE_DONOT_INSERT_ENCODER = Guid.initString("f45aa7ce-ab24-4012-a11b-dc8220201410");
pub const MF_VIDEO_PROCESSOR_ALGORITHM = Guid.initString("4a0a1e1f-272c-4fb6-9eb1-db330cbc97ca");
pub const MF_XVP_DISABLE_FRC = Guid.initString("2c0afa19-7a97-4d5a-9ee8-16d4fc518d8c");
pub const MF_XVP_CALLER_ALLOCATES_OUTPUT = Guid.initString("04a2cabc-0cab-40b1-a1b9-75bc3658f000");
pub const MF_LOCAL_MFT_REGISTRATION_SERVICE = Guid.initString("ddf5cf9c-4506-45aa-abf0-6d5d94dd1b4a");
pub const MF_WRAPPED_SAMPLE_SERVICE = Guid.initString("31f52bf2-d03e-4048-80d0-9c1046d87c61");
pub const MF_WRAPPED_OBJECT = Guid.initString("2b182c4c-d6ac-49f4-8915-f71887db70cd");
pub const CLSID_HttpSchemePlugin = Guid.initString("44cb442b-9da9-49df-b3fd-023777b16e50");
pub const CLSID_UrlmonSchemePlugin = Guid.initString("9ec4b4f9-3029-45ad-947b-344de2a249e2");
pub const CLSID_NetSchemePlugin = Guid.initString("e9f4ebab-d97b-463e-a2b1-c54ee3f9414d");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE = Guid.initString("c60ac5fe-252a-478f-a0ef-bc8fa5f7cad3");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE = Guid.initString("de7046ba-54d6-4487-a2a4-ec7c0d1bd163");
pub const MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME = Guid.initString("60d0e559-52f8-4fa2-bbce-acdb34a8ec01");
pub const MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE = Guid.initString("56a819ca-0c78-4de4-a0a7-3ddaba0f24d4");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY = Guid.initString("77f0ae69-c3bd-4509-941d-467e4d24899e");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK = Guid.initString("58f0aad8-22bf-4f8a-bb3d-d2c4978c6e2f");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_SYMBOLIC_LINK = Guid.initString("98d24b5e-5930-4614-b5a1-f600f9355a78");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS = Guid.initString("7dd9b730-4f2d-41d5-8f95-0cc9a912ba26");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ENDPOINT_ID = Guid.initString("30da9258-feb9-47a7-a453-763a7a8e1c5f");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE = Guid.initString("bc9d118e-8c67-4a18-85d4-12d300400552");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_PROVIDER_DEVICE_ID = Guid.initString("36689d42-a06c-40ae-84cf-f5a034067cc4");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_XADDRESS = Guid.initString("bca0be52-c327-44c7-9b7d-7fa8d9b5bcda");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_STREAM_URL = Guid.initString("9d7b40d2-3617-4043-93e3-8d6da9bb3492");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_USERNAME = Guid.initString("05d01add-949f-46eb-bc8e-8b0d2b32d79d");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_PASSWORD = Guid.initString("a0fd7e16-42d9-49df-84c0-e82c5eab8874");
pub const CLSID_FrameServerNetworkCameraSource = Guid.initString("7a213aa7-866f-414a-8c1a-275c7283a395");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_GUID = Guid.initString("14dd9a1c-7cff-41be-b1b9-ba1ac6ecb571");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID = Guid.initString("8ac3587a-4ae7-42d8-99e0-0a6013eef90f");
pub const MF_DEVICESTREAM_IMAGE_STREAM = Guid.initString("a7ffb865-e7b2-43b0-9f6f-9af2a0e50fc0");
pub const MF_DEVICESTREAM_INDEPENDENT_IMAGE_STREAM = Guid.initString("03eeec7e-d605-4576-8b29-6580b490d7d3");
pub const MF_DEVICESTREAM_STREAM_ID = Guid.initString("11bd5120-d124-446b-88e6-17060257fff9");
pub const MF_DEVICESTREAM_STREAM_CATEGORY = Guid.initString("2939e7b8-a62e-4579-b674-d4073dfabbba");
pub const MF_DEVICESTREAM_FRAMESERVER_SHARED = Guid.initString("1cb378e9-b279-41d4-af97-34a243e68320");
pub const MF_DEVICESTREAM_TRANSFORM_STREAM_ID = Guid.initString("e63937b7-daaf-4d49-815f-d826f8ad31e7");
pub const MF_DEVICESTREAM_EXTENSION_PLUGIN_CLSID = Guid.initString("048e6558-60c4-4173-bd5b-6a3ca2896aee");
pub const MF_DEVICEMFT_EXTENSION_PLUGIN_CLSID = Guid.initString("0844dbae-34fa-48a0-a783-8e696fb1c9a8");
pub const MF_DEVICESTREAM_EXTENSION_PLUGIN_CONNECTION_POINT = Guid.initString("37f9375c-e664-4ea4-aae4-cb6d1daca1f4");
pub const MF_DEVICESTREAM_TAKEPHOTO_TRIGGER = Guid.initString("1d180e34-538c-4fbb-a75a-859af7d261a6");
pub const MF_DEVICESTREAM_MAX_FRAME_BUFFERS = Guid.initString("1684cebe-3175-4985-882c-0efd3e8ac11e");
pub const MF_DEVICEMFT_CONNECTED_FILTER_KSCONTROL = Guid.initString("6a2c4fa6-d179-41cd-9523-822371ea40e5");
pub const MF_DEVICEMFT_CONNECTED_PIN_KSCONTROL = Guid.initString("e63310f7-b244-4ef8-9a7d-24c74e32ebd0");
pub const MF_DEVICE_THERMAL_STATE_CHANGED = Guid.initString("70ccd0af-fc9f-4deb-a875-9fecd16c5bd4");
pub const MFSampleExtension_DeviceTimestamp = Guid.initString("8f3e35e7-2dcd-4887-8622-2a58baa652b0");
pub const MFSampleExtension_Spatial_CameraViewTransform = Guid.initString("4e251fa4-830f-4770-859a-4b8d99aa809b");
pub const MFSampleExtension_Spatial_CameraCoordinateSystem = Guid.initString("9d13c82f-2199-4e67-91cd-d1a4181f2534");
pub const MFSampleExtension_Spatial_CameraProjectionTransform = Guid.initString("47f9fcb5-2a02-4f26-a477-792fdf95886a");
pub const MF_MEDIASOURCE_SERVICE = Guid.initString("f09992f7-9fba-4c4a-a37f-8c47b4e1dfe7");
pub const MF_ACCESS_CONTROLLED_MEDIASOURCE_SERVICE = Guid.initString("014a5031-2f05-4c6a-9f9c-7d0dc4eda5f4");
pub const MF_CONTENT_DECRYPTOR_SERVICE = Guid.initString("68a72927-fc7b-44ee-85f4-7c51bd55a659");
pub const MF_CONTENT_PROTECTION_DEVICE_SERVICE = Guid.initString("ff58436f-76a0-41fe-b566-10cc53962edd");
pub const MF_SD_AUDIO_ENCODER_DELAY = Guid.initString("8e85422c-73de-403f-9a35-550ad6e8b951");
pub const MF_SD_AUDIO_ENCODER_PADDING = Guid.initString("529c7f2c-ac4b-4e3f-bfc3-0902194982cb");
pub const CLSID_MSH264DecoderMFT = Guid.initString("62ce7e72-4c71-4d20-b15d-452831a87d9d");
pub const CLSID_MSH264EncoderMFT = Guid.initString("6ca50344-051a-4ded-9779-a43305165e35");
pub const CLSID_MSDDPlusDecMFT = Guid.initString("177c0afe-900b-48d4-9e4c-57add250b3d4");
pub const CLSID_MP3DecMediaObject = Guid.initString("bbeea841-0a63-4f52-a7ab-a9b3a84ed38a");
pub const CLSID_MSAACDecMFT = Guid.initString("32d186a7-218f-4c75-8876-dd77273a8999");
pub const CLSID_MSH265DecoderMFT = Guid.initString("420a51a3-d605-430c-b4fc-45274fa6c562");
pub const CLSID_WMVDecoderMFT = Guid.initString("82d353df-90bd-4382-8bc2-3f6192b76e34");
pub const CLSID_WMADecMediaObject = Guid.initString("2eeb4adf-4578-4d10-bca7-bb955f56320a");
pub const CLSID_MSMPEGAudDecMFT = Guid.initString("70707b39-b2ca-4015-abea-f8447d22d88b");
pub const CLSID_MSMPEGDecoderMFT = Guid.initString("2d709e52-123f-49b5-9cbc-9af5cde28fb9");
pub const CLSID_AudioResamplerMediaObject = Guid.initString("f447b69e-1884-4a7e-8055-346f74d6edb3");
pub const CLSID_MSVPxDecoder = Guid.initString("e3aaf548-c9a4-4c6e-234d-5ada374b0000");
pub const CLSID_MSOpusDecoder = Guid.initString("63e17c10-2d43-4c42-8fe3-8d8b63e46a6a");
pub const CLSID_VideoProcessorMFT = Guid.initString("88753b26-5b24-49bd-b2e7-0c445c78c982");
pub const MFNETSOURCE_CROSS_ORIGIN_SUPPORT = Guid.initString("9842207c-b02c-4271-a2fc-72e49308e5c2");
pub const MFNETSOURCE_HTTP_DOWNLOAD_SESSION_PROVIDER = Guid.initString("7d55081e-307d-4d6d-a663-a93be97c4b5c");
pub const MF_SD_MEDIASOURCE_STATUS = Guid.initString("1913678b-fc0f-44da-8f43-1ba3b526f4ae");
pub const MF_SD_VIDEO_SPHERICAL = Guid.initString("a51da449-3fdc-478c-bcb5-30be76595f55");
pub const MF_SD_VIDEO_SPHERICAL_FORMAT = Guid.initString("4a8fc407-6ea1-46c8-b567-6971d4a139c3");
pub const MF_SD_VIDEO_SPHERICAL_INITIAL_VIEWDIRECTION = Guid.initString("11d25a49-bb62-467f-9db1-c17165716c49");
pub const MF_MEDIASOURCE_EXPOSE_ALL_STREAMS = Guid.initString("e7f250b8-8fd9-4a09-b6c1-6a315c7c720e");
pub const MF_ST_MEDIASOURCE_COLLECTION = Guid.initString("616de972-83ad-4950-8170-630d19cbe307");
pub const MF_DEVICESTREAM_FILTER_KSCONTROL = Guid.initString("46783cca-3df5-4923-a9ef-36b7223edde0");
pub const MF_DEVICESTREAM_PIN_KSCONTROL = Guid.initString("ef3ef9a7-87f2-48ca-be02-674878918e98");
pub const MF_DEVICESTREAM_SOURCE_ATTRIBUTES = Guid.initString("2f8cb617-361b-434f-85ea-99a03e1ce4e0");
pub const MF_DEVICESTREAM_FRAMESERVER_HIDDEN = Guid.initString("f402567b-4d91-4179-96d1-74c8480c2034");
pub const MF_STF_VERSION_INFO = Guid.initString("6770bd39-ef82-44ee-a49b-934beb24aef7");
pub const MF_STF_VERSION_DATE = Guid.initString("31a165d5-df67-4095-8e44-8868fc20dbfd");
pub const MF_DEVICESTREAM_REQUIRED_CAPABILITIES = Guid.initString("6d8b957e-7cf6-43f4-af56-9c0e1e4fcbe1");
pub const MF_DEVICESTREAM_REQUIRED_SDDL = Guid.initString("331ae85d-c0d3-49ba-83ba-82a12d63cdd6");
pub const MF_DEVICEMFT_SENSORPROFILE_COLLECTION = Guid.initString("36ebdc44-b12c-441b-89f4-08b2f41a9cfc");
pub const MF_DEVICESTREAM_SENSORSTREAM_ID = Guid.initString("e35b9fe4-0659-4cad-bb51-33160be7e413");
pub const MF_PD_ASF_FILEPROPERTIES_FILE_ID = Guid.initString("3de649b4-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_CREATION_TIME = Guid.initString("3de649b6-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_PACKETS = Guid.initString("3de649b7-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION = Guid.initString("3de649b8-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_SEND_DURATION = Guid.initString("3de649b9-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_PREROLL = Guid.initString("3de649ba-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_FLAGS = Guid.initString("3de649bb-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE = Guid.initString("3de649bc-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE = Guid.initString("3de649bd-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE = Guid.initString("3de649be-d76d-4e66-9ec9-78120fb4c7e3");
pub const CLSID_WMDRMSystemID = Guid.initString("8948bb22-11bd-4796-93e3-974d1b575678");
pub const MF_PD_ASF_CONTENTENCRYPTION_TYPE = Guid.initString("8520fe3d-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTION_KEYID = Guid.initString("8520fe3e-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA = Guid.initString("8520fe3f-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL = Guid.initString("8520fe40-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA = Guid.initString("62508be5-ecdf-4924-a359-72bab3397b9d");
pub const MF_PD_ASF_LANGLIST = Guid.initString("f23de43c-9977-460d-a6ec-32937f160f7d");
pub const MF_PD_ASF_LANGLIST_LEGACYORDER = Guid.initString("f23de43d-9977-460d-a6ec-32937f160f7d");
pub const MF_PD_ASF_MARKER = Guid.initString("5134330e-83a6-475e-a9d5-4fb875fb2e31");
pub const MF_PD_ASF_SCRIPT = Guid.initString("e29cd0d7-d602-4923-a7fe-73fd97ecc650");
pub const MF_PD_ASF_CODECLIST = Guid.initString("e4bb3509-c18d-4df1-bb99-7a36b3cc4119");
pub const MF_PD_ASF_METADATA_IS_VBR = Guid.initString("5fc6947a-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_METADATA_V8_VBRPEAK = Guid.initString("5fc6947b-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_METADATA_V8_BUFFERAVERAGE = Guid.initString("5fc6947c-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS = Guid.initString("5fc6947d-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_DATA_START_OFFSET = Guid.initString("e7d5b3e7-1f29-45d3-8822-3e78fae272ed");
pub const MF_PD_ASF_DATA_LENGTH = Guid.initString("e7d5b3e8-1f29-45d3-8822-3e78fae272ed");
pub const MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX = Guid.initString("48f8a522-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE = Guid.initString("48f8a523-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE = Guid.initString("48f8a524-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE = Guid.initString("48f8a525-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE = Guid.initString("48f8a526-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_STREAMBITRATES_BITRATE = Guid.initString("a8e182ed-afc8-43d0-b0d1-f65bad9da558");
pub const MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE = Guid.initString("245e929d-c44e-4f7e-bb3c-77d4dfd27f8a");
pub const MF_PD_ASF_INFO_HAS_AUDIO = Guid.initString("80e62295-2296-4a44-b31c-d103c6fed23c");
pub const MF_PD_ASF_INFO_HAS_VIDEO = Guid.initString("80e62296-2296-4a44-b31c-d103c6fed23c");
pub const MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO = Guid.initString("80e62297-2296-4a44-b31c-d103c6fed23c");
pub const MF_ASFPROFILE_MINPACKETSIZE = Guid.initString("22587626-47de-4168-87f5-b5aa9b12a8f0");
pub const MF_ASFPROFILE_MAXPACKETSIZE = Guid.initString("22587627-47de-4168-87f5-b5aa9b12a8f0");
pub const MF_ASFSTREAMCONFIG_LEAKYBUCKET1 = Guid.initString("c69b5901-ea1a-4c9b-b692-e2a0d29a8add");
pub const MF_ASFSTREAMCONFIG_LEAKYBUCKET2 = Guid.initString("c69b5902-ea1a-4c9b-b692-e2a0d29a8add");
pub const MFASFSampleExtension_SampleDuration = Guid.initString("c6bd9450-867f-4907-83a3-c77921b733ad");
pub const MFASFSampleExtension_OutputCleanPoint = Guid.initString("f72a3c6f-6eb4-4ebc-b192-09ad9759e828");
pub const MFASFSampleExtension_SMPTE = Guid.initString("399595ec-8667-4e2d-8fdb-98814ce76c1e");
pub const MFASFSampleExtension_FileName = Guid.initString("e165ec0e-19ed-45d7-b4a7-25cbd1e28e9b");
pub const MFASFSampleExtension_ContentType = Guid.initString("d590dc20-07bc-436c-9cf7-f3bbfbf1a4dc");
pub const MFASFSampleExtension_PixelAspectRatio = Guid.initString("1b1ee554-f9ea-4bc8-821a-376b74e4c4b8");
pub const MFASFSampleExtension_Encryption_SampleID = Guid.initString("6698b84e-0afa-4330-aeb2-1c0a98d7a44d");
pub const MFASFSampleExtension_Encryption_KeyID = Guid.initString("76376591-795f-4da1-86ed-9d46eca109a9");
pub const MFASFMutexType_Language = Guid.initString("72178c2b-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFMutexType_Bitrate = Guid.initString("72178c2c-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFMutexType_Presentation = Guid.initString("72178c2d-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFMutexType_Unknown = Guid.initString("72178c2e-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFSPLITTER_PACKET_BOUNDARY = Guid.initString("fe584a05-e8d6-42e3-b176-f1211705fb6f");
pub const MFASFINDEXER_TYPE_TIMECODE = Guid.initString("49815231-6bad-44fd-810a-3f60984ec7fd");
pub const MF_CAPTURE_ENGINE_INITIALIZED = Guid.initString("219992bc-cf92-4531-a1ae-96e1e886c8f1");
pub const MF_CAPTURE_ENGINE_PREVIEW_STARTED = Guid.initString("a416df21-f9d3-4a74-991b-b817298952c4");
pub const MF_CAPTURE_ENGINE_PREVIEW_STOPPED = Guid.initString("13d5143c-1edd-4e50-a2ef-350a47678060");
pub const MF_CAPTURE_ENGINE_RECORD_STARTED = Guid.initString("ac2b027b-ddf9-48a0-89be-38ab35ef45c0");
pub const MF_CAPTURE_ENGINE_RECORD_STOPPED = Guid.initString("55e5200a-f98f-4c0d-a9ec-9eb25ed3d773");
pub const MF_CAPTURE_ENGINE_PHOTO_TAKEN = Guid.initString("3c50c445-7304-48eb-865d-bba19ba3af5c");
pub const MF_CAPTURE_SOURCE_CURRENT_DEVICE_MEDIA_TYPE_SET = Guid.initString("e7e75e4c-039c-4410-815b-8741307b63aa");
pub const MF_CAPTURE_ENGINE_ERROR = Guid.initString("46b89fc6-33cc-4399-9dad-784de77d587c");
pub const MF_CAPTURE_ENGINE_EFFECT_ADDED = Guid.initString("aa8dc7b5-a048-4e13-8ebe-f23c46c830c1");
pub const MF_CAPTURE_ENGINE_EFFECT_REMOVED = Guid.initString("c6e8db07-fb09-4a48-89c6-bf92a04222c9");
pub const MF_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED = Guid.initString("fded7521-8ed8-431a-a96b-f3e2565e981c");
pub const MF_CAPTURE_SINK_PREPARED = Guid.initString("7bfce257-12b1-4409-8c34-d445daab7578");
pub const MF_CAPTURE_ENGINE_OUTPUT_MEDIA_TYPE_SET = Guid.initString("caaad994-83ec-45e9-a30a-1f20aadb9831");
pub const MF_CAPTURE_ENGINE_CAMERA_STREAM_BLOCKED = Guid.initString("a4209417-8d39-46f3-b759-5912528f4207");
pub const MF_CAPTURE_ENGINE_CAMERA_STREAM_UNBLOCKED = Guid.initString("9be9eef0-cdaf-4717-8564-834aae66415c");
pub const MF_CAPTURE_ENGINE_D3D_MANAGER = Guid.initString("76e25e7b-d595-4283-962c-c594afd78ddf");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES = Guid.initString("b467f705-7913-4894-9d42-a215fea23da9");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES = Guid.initString("1cddb141-a7f4-4d58-9896-4d15a53c4efe");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES = Guid.initString("e7b4a49e-382c-4aef-a946-aed5490b7111");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES = Guid.initString("9896e12a-f707-4500-b6bd-db8eb810b50f");
pub const MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY = Guid.initString("1c8077da-8466-4dc4-8b8e-276b3f85923b");
pub const MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY = Guid.initString("7e025171-cf32-4f2e-8f19-410577b73a66");
pub const MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS = Guid.initString("b7c42a6b-3207-4495-b4e7-81f9c35d5991");
pub const MF_CAPTURE_ENGINE_DISABLE_DXVA = Guid.initString("f9818862-179d-433f-a32f-74cbcf74466d");
pub const MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG = Guid.initString("bc6989d2-0fc1-46e1-a74f-efd36bc788de");
pub const MF_CAPTURE_ENGINE_DECODER_MFT_FIELDOFUSE_UNLOCK_Attribute = Guid.initString("2b8ad2e8-7acb-4321-a606-325c4249f4fc");
pub const MF_CAPTURE_ENGINE_ENCODER_MFT_FIELDOFUSE_UNLOCK_Attribute = Guid.initString("54c63a00-78d5-422f-aa3e-5e99ac649269");
pub const MF_CAPTURE_ENGINE_ENABLE_CAMERA_STREAMSTATE_NOTIFICATION = Guid.initString("4c808e9d-aaed-4713-90fb-cb24064ab8da");
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY = Guid.initString("8e3f5bd5-dbbf-42f0-8542-d07a3971762a");
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING = Guid.initString("10f1be5e-7e11-410b-973d-f4b6109000fe");
pub const MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID = Guid.initString("abfa8ad5-fc6d-4911-87e0-961945f8f7ce");
pub const MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX = Guid.initString("82697f44-b1cf-42eb-9753-f86d649c8865");
pub const MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE = Guid.initString("03160b7e-1c6f-4db2-ad56-a7c430f82392");
pub const MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE_INDEX = Guid.initString("3ce88613-2214-46c3-b417-82f8a313c9c3");
pub const CLSID_MFCaptureEngine = Guid.initString("efce38d3-8914-4674-a7df-ae1b3d654b8a");
pub const CLSID_MFCaptureEngineClassFactory = Guid.initString("efce38d3-8914-4674-a7df-ae1b3d654b8a");
pub const MFSampleExtension_DeviceReferenceSystemTime = Guid.initString("6523775a-ba2d-405f-b2c5-01ff88e2e8f6");
pub const MF_D3D12_SYNCHRONIZATION_OBJECT = Guid.initString("2a7c8d6a-85a6-494d-a046-06ea1a138f4b");
pub const MF_MT_D3D_RESOURCE_VERSION = Guid.initString("174f1e85-fe26-453d-b52e-5bdd4e55b944");
pub const MF_MT_D3D12_CPU_READBACK = Guid.initString("28ee9fe3-d481-46a6-b98a-7f69d5280e82");
pub const MF_MT_D3D12_TEXTURE_LAYOUT = Guid.initString("97c85caa-0beb-4ee1-9715-f22fad8c10f5");
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET = Guid.initString("eeac2585-3430-498c-84a2-77b1bba570f6");
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL = Guid.initString("b1138dc3-01d5-4c14-9bdc-cdc9336f55b9");
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS = Guid.initString("82c85647-5057-4960-9559-f45b8e271427");
pub const MF_MT_D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE = Guid.initString("ba06bfac-ffe3-474a-ab55-161ee4417a2e");
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER = Guid.initString("a6a1e439-2f96-4ab5-98dc-adf74973505d");
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS = Guid.initString("0a4940b2-cfd6-4738-9d02-98113734015a");
pub const MF_SA_D3D12_HEAP_FLAGS = Guid.initString("496b3266-d28f-4f8c-93a7-4a596b1a31a1");
pub const MF_SA_D3D12_HEAP_TYPE = Guid.initString("56f26a76-bbc1-4ce0-bb11-e22368d874ed");
pub const MF_SA_D3D12_CLEAR_VALUE = Guid.initString("86ba9a39-0526-495d-9ab5-54ec9fad6fc3");
pub const MF_MSE_CALLBACK = Guid.initString("9063a7c0-42c5-4ffd-a8a8-6fcf9ea3d00c");
pub const MF_MSE_ACTIVELIST_CALLBACK = Guid.initString("949bda0f-4549-46d5-ad7f-b846e1ab1652");
pub const MF_MSE_BUFFERLIST_CALLBACK = Guid.initString("42e669b0-d60e-4afb-a85b-d8e5fe6bdab5");
pub const MF_MSE_VP9_SUPPORT = Guid.initString("92d78429-d88b-4ff0-8322-803efa6e9626");
pub const MF_MSE_OPUS_SUPPORT = Guid.initString("4d224cc1-8cc4-48a3-a7a7-e4c16ce6388a");
pub const MF_MEDIA_ENGINE_NEEDKEY_CALLBACK = Guid.initString("7ea80843-b6e4-432c-8ea4-7848ffe4220e");
pub const MF_MEDIA_ENGINE_CALLBACK = Guid.initString("c60381b8-83a4-41f8-a3d0-de05076849a9");
pub const MF_MEDIA_ENGINE_DXGI_MANAGER = Guid.initString("065702da-1094-486d-8617-ee7cc4ee4648");
pub const MF_MEDIA_ENGINE_EXTENSION = Guid.initString("3109fd46-060d-4b62-8dcf-faff811318d2");
pub const MF_MEDIA_ENGINE_PLAYBACK_HWND = Guid.initString("d988879b-67c9-4d92-baa7-6eadd446039d");
pub const MF_MEDIA_ENGINE_OPM_HWND = Guid.initString("a0be8ee7-0572-4f2c-a801-2a151bd3e726");
pub const MF_MEDIA_ENGINE_PLAYBACK_VISUAL = Guid.initString("6debd26f-6ab9-4d7e-b0ee-c61a73ffad15");
pub const MF_MEDIA_ENGINE_COREWINDOW = Guid.initString("fccae4dc-0b7f-41c2-9f96-4659948acddc");
pub const MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT = Guid.initString("5066893c-8cf9-42bc-8b8a-472212e52726");
pub const MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS = Guid.initString("e0350223-5aaf-4d76-a7c3-06de70894db4");
pub const MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER = Guid.initString("fdd6dfaa-bd85-4af3-9e0f-a01d539d876a");
pub const MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE = Guid.initString("d2cb93d1-116a-44f2-9385-f7d0fda2fb46");
pub const MF_MEDIA_ENGINE_AUDIO_CATEGORY = Guid.initString("c8d4c51d-350e-41f2-ba46-faebbb0857f6");
pub const MF_MEDIA_ENGINE_STREAM_CONTAINS_ALPHA_CHANNEL = Guid.initString("5cbfaf44-d2b2-4cfb-80a7-d429c74c789d");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE = Guid.initString("4e0212e2-e18f-41e1-95e5-c0e7e9235bc3");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE9 = Guid.initString("052c2d39-40c0-4188-ab86-f828273b7522");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE10 = Guid.initString("11a47afd-6589-4124-b312-6158ec517fc3");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE11 = Guid.initString("1cf1315f-ce3f-4035-9391-16142f775189");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE_EDGE = Guid.initString("a6f3e465-3aca-442c-a3f0-ad6ddad839ae");
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE = Guid.initString("3ef26ad4-dc54-45de-b9af-76c8c66bfa8e");
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WWA_EDGE = Guid.initString("15b29098-9f01-4e4d-b65a-c06c6c89da2a");
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WIN10 = Guid.initString("5b25e089-6ca7-4139-a2cb-fcaab39552a3");
pub const MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE = Guid.initString("0ac0c497-b3c4-48c9-9cde-bb8ca2442ca3");
pub const MF_MEDIA_ENGINE_TRACK_ID = Guid.initString("65bea312-4043-4815-8eab-44dce2ef8f2a");
pub const MF_MEDIA_ENGINE_TELEMETRY_APPLICATION_ID = Guid.initString("1e7b273b-a7e4-402a-8f51-c48e88a2cabc");
pub const MF_MEDIA_ENGINE_SYNCHRONOUS_CLOSE = Guid.initString("c3c2e12f-7e0e-4e43-b91c-dc992ccdfa5e");
pub const MF_MEDIA_ENGINE_MEDIA_PLAYER_MODE = Guid.initString("3ddd8d45-5aa1-4112-82e5-36f6a2197e6e");
pub const CLSID_MFMediaEngineClassFactory = Guid.initString("b44392da-499b-446b-a4cb-005fead0e6d5");
pub const MF_MEDIA_ENGINE_TIMEDTEXT = Guid.initString("805ea411-92e0-4e59-9b6e-5c7d7915e64f");
pub const MF_MEDIA_ENGINE_CONTINUE_ON_CODEC_ERROR = Guid.initString("dbcdb7f9-48e4-4295-b70d-d518234eeb38");
pub const MF_MEDIA_ENGINE_EME_CALLBACK = Guid.initString("494553a7-a481-4cb7-bec5-380903513731");
pub const CLSID_MPEG2DLNASink = Guid.initString("fa5fe7c5-6a1d-4b11-b41f-f959d6c76500");
pub const MF_MP2DLNA_USE_MMCSS = Guid.initString("54f3e2ee-a2a2-497d-9834-973afde521eb");
pub const MF_MP2DLNA_VIDEO_BIT_RATE = Guid.initString("e88548de-73b4-42d7-9c75-adfa0a2a6e4c");
pub const MF_MP2DLNA_AUDIO_BIT_RATE = Guid.initString("2d1c070e-2b5f-4ab3-a7e6-8d943ba8d00a");
pub const MF_MP2DLNA_ENCODE_QUALITY = Guid.initString("b52379d7-1d46-4fb6-a317-a4a5f60959f8");
pub const MF_MP2DLNA_STATISTICS = Guid.initString("75e488a3-d5ad-4898-85e0-bcce24a722d7");
pub const CLSID_MFReadWriteClassFactory = Guid.initString("48e2ed0f-98c2-4a37-bed5-166312ddd83f");
pub const CLSID_MFSourceReader = Guid.initString("1777133c-0881-411b-a577-ad545f0714c4");
pub const MF_SOURCE_READER_ASYNC_CALLBACK = Guid.initString("1e3dbeac-bb43-4c35-b507-cd644464c965");
pub const MF_SOURCE_READER_D3D_MANAGER = Guid.initString("ec822da2-e1e9-4b29-a0d8-563c719f5269");
pub const MF_SOURCE_READER_DISABLE_DXVA = Guid.initString("aa456cfd-3943-4a1e-a77d-1838c0ea2e35");
pub const MF_SOURCE_READER_MEDIASOURCE_CONFIG = Guid.initString("9085abeb-0354-48f9-abb5-200df838c68e");
pub const MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS = Guid.initString("6d23f5c8-c5d7-4a9b-9971-5d11f8bca880");
pub const MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING = Guid.initString("fb394f3d-ccf1-42ee-bbb3-f9b845d5681d");
pub const MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING = Guid.initString("0f81da2c-b537-4672-a8b2-a681b17307a3");
pub const MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS = Guid.initString("9d3365dd-058f-4cfb-9f97-b314cc99c8ad");
pub const MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN = Guid.initString("56b67165-219e-456d-a22e-2d3004c7fe56");
pub const MF_SOURCE_READER_ENABLE_TRANSCODE_ONLY_TRANSFORMS = Guid.initString("dfd4f008-b5fd-4e78-ae44-62a1e67bbe27");
pub const MF_SOURCE_READER_D3D11_BIND_FLAGS = Guid.initString("33f3197b-f73a-4e14-8d85-0e4c4368788d");
pub const CLSID_MFSinkWriter = Guid.initString("a3bbfb17-8273-4e52-9e0e-9739dc887990");
pub const MF_SINK_WRITER_ASYNC_CALLBACK = Guid.initString("48cb183e-7b0b-46f4-822e-5e1d2dda4354");
pub const MF_SINK_WRITER_DISABLE_THROTTLING = Guid.initString("08b845d8-2b74-4afe-9d53-be16d2d5ae4f");
pub const MF_SINK_WRITER_D3D_MANAGER = Guid.initString("ec822da2-e1e9-4b29-a0d8-563c719f5269");
pub const MF_SINK_WRITER_ENCODER_CONFIG = Guid.initString("ad91cd04-a7cc-4ac7-99b6-a57b9a4a7c70");
pub const MF_READWRITE_DISABLE_CONVERTERS = Guid.initString("98d5b065-1374-4847-8d5d-31520fee7156");
pub const MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS = Guid.initString("a634a91c-822b-41b9-a494-4de4643612b0");
pub const MF_READWRITE_MMCSS_CLASS = Guid.initString("39384300-d0eb-40b1-87a0-3318871b5a53");
pub const MF_READWRITE_MMCSS_PRIORITY = Guid.initString("43ad19ce-f33f-4ba9-a580-e4cd12f2d144");
pub const MF_READWRITE_MMCSS_CLASS_AUDIO = Guid.initString("430847da-0890-4b0e-938c-054332c547e1");
pub const MF_READWRITE_MMCSS_PRIORITY_AUDIO = Guid.initString("273db885-2de2-4db2-a6a7-fdb66fb40b61");
pub const MF_READWRITE_D3D_OPTIONAL = Guid.initString("216479d9-3071-42ca-bb6c-4c22102e1d18");
pub const MF_MEDIASINK_AUTOFINALIZE_SUPPORTED = Guid.initString("48c131be-135a-41cb-8290-03652509c999");
pub const MF_MEDIASINK_ENABLE_AUTOFINALIZE = Guid.initString("34014265-cb7e-4cde-ac7c-effd3b3c2530");
pub const MF_READWRITE_ENABLE_AUTOFINALIZE = Guid.initString("dd7ca129-8cd1-4dc5-9dde-ce168675de61");
pub const MFP_POSITIONTYPE_100NS = Guid.initString("00000000-0000-0000-0000-000000000000");
pub const MF_MEDIA_SHARING_ENGINE_DEVICE_NAME = Guid.initString("771e05d1-862f-4299-95ac-ae81fd14f3e7");
pub const MF_MEDIA_SHARING_ENGINE_DEVICE = Guid.initString("b461c58a-7a08-4b98-99a8-70fd5f3badfd");
pub const CLSID_MFMediaSharingEngineClassFactory = Guid.initString("f8e307fb-6d45-4ad3-9993-66cd5a529659");
pub const CLSID_MFImageSharingEngineClassFactory = Guid.initString("b22c3339-87f3-4059-a0c5-037aa9707eaf");
pub const CLSID_PlayToSourceClassFactory = Guid.initString("da17539a-3dc3-42c1-a749-a183b51f085e");
pub const GUID_PlayToService = Guid.initString("f6a8ff9d-9e14-41c9-bf0f-120a2b3ce120");
pub const GUID_NativeDeviceService = Guid.initString("ef71e53c-52f4-43c5-b86a-ad6cb216a61e");
pub const MF_CONTENTDECRYPTIONMODULE_SERVICE = Guid.initString("15320c45-ff80-484a-9dcb-0df894e69a01");
pub const MF_VIRTUALCAMERA_CONFIGURATION_APP_PACKAGE_FAMILY_NAME = Guid.initString("658abe51-8044-462e-97ea-e676fd72055f");
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_INITIALIZE = Guid.initString("e52c4dff-e46d-4d0b-bc75-ddd4c8723f96");
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_START = Guid.initString("b1eeb989-b456-4f4a-ae40-079c28e24af8");
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_STOP = Guid.initString("b7fe7a61-fe91-415e-8608-d37dedb1a58b");
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_UNINITIALIZE = Guid.initString("a0ebaba7-a422-4e33-8401-b37d2800aa67");
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_PIPELINE_SHUTDOWN = Guid.initString("45a81b31-43f8-4e5d-8ce2-22dce026996d");
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_CUSTOM_EVENT = Guid.initString("6e59489c-47d3-4467-83ef-12d34e871665");

//--------------------------------------------------------------------------------
// Section: Types (1492)
//--------------------------------------------------------------------------------
pub const MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS = enum(u32) {
    NE = 0,
    _WAIT = 1,
};
pub const MF_EVENT_FLAG_NONE = MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS.NE;
pub const MF_EVENT_FLAG_NO_WAIT = MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS._WAIT;

pub const MF_Plugin_Type = enum(i32) {
    MFT = 0,
    MediaSource = 1,
    MFT_MatchOutputType = 2,
    Other = -1,
};
pub const MF_Plugin_Type_MFT = MF_Plugin_Type.MFT;
pub const MF_Plugin_Type_MediaSource = MF_Plugin_Type.MediaSource;
pub const MF_Plugin_Type_MFT_MatchOutputType = MF_Plugin_Type.MFT_MatchOutputType;
pub const MF_Plugin_Type_Other = MF_Plugin_Type.Other;

pub const CodecAPIEventData = extern struct {
    guid: Guid,
    dataLength: u32,
    reserved: [3]u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICodecAPI_Value = Guid.initString("901db4c7-31ce-41a2-85dc-8fa0bf41b8da");
pub const IID_ICodecAPI = &IID_ICodecAPI_Value;
pub const ICodecAPI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsModifiable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameterRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                ValueMin: ?*VARIANT,
                ValueMax: ?*VARIANT,
                SteppingDelta: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                ValueMin: ?*VARIANT,
                ValueMax: ?*VARIANT,
                SteppingDelta: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameterValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Values: [*]?*VARIANT,
                ValuesCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Values: [*]?*VARIANT,
                ValuesCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                userData: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                userData: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllDefaults: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValueWithNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
                ChangedParam: [*]?*Guid,
                ChangedParamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
                ChangedParam: [*]?*Guid,
                ChangedParamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllDefaultsWithNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                ChangedParam: [*]?*Guid,
                ChangedParamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                ChangedParam: [*]?*Guid,
                ChangedParamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                __MIDL__ICodecAPI0000: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                __MIDL__ICodecAPI0000: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                __MIDL__ICodecAPI0001: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                __MIDL__ICodecAPI0001: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllSettingsWithNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodecAPI,
                __MIDL__ICodecAPI0002: ?*IStream,
                ChangedParam: [*]?*Guid,
                ChangedParamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodecAPI,
                __MIDL__ICodecAPI0002: ?*IStream,
                ChangedParam: [*]?*Guid,
                ChangedParamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_IsSupported(self: *const T, Api: ?*const Guid) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).IsSupported(@as(*const ICodecAPI, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_IsModifiable(self: *const T, Api: ?*const Guid) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).IsModifiable(@as(*const ICodecAPI, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_GetParameterRange(self: *const T, Api: ?*const Guid, ValueMin: ?*VARIANT, ValueMax: ?*VARIANT, SteppingDelta: ?*VARIANT) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).GetParameterRange(@as(*const ICodecAPI, @ptrCast(self)), Api, ValueMin, ValueMax, SteppingDelta);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_GetParameterValues(self: *const T, Api: ?*const Guid, Values: [*]?*VARIANT, ValuesCount: ?*u32) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).GetParameterValues(@as(*const ICodecAPI, @ptrCast(self)), Api, Values, ValuesCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_GetDefaultValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).GetDefaultValue(@as(*const ICodecAPI, @ptrCast(self)), Api, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_GetValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).GetValue(@as(*const ICodecAPI, @ptrCast(self)), Api, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_SetValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).SetValue(@as(*const ICodecAPI, @ptrCast(self)), Api, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_RegisterForEvent(self: *const T, Api: ?*const Guid, userData: isize) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).RegisterForEvent(@as(*const ICodecAPI, @ptrCast(self)), Api, userData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_UnregisterForEvent(self: *const T, Api: ?*const Guid) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).UnregisterForEvent(@as(*const ICodecAPI, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_SetAllDefaults(self: *const T) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).SetAllDefaults(@as(*const ICodecAPI, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_SetValueWithNotify(self: *const T, Api: ?*const Guid, Value: ?*VARIANT, ChangedParam: [*]?*Guid, ChangedParamCount: ?*u32) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).SetValueWithNotify(@as(*const ICodecAPI, @ptrCast(self)), Api, Value, ChangedParam, ChangedParamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_SetAllDefaultsWithNotify(self: *const T, ChangedParam: [*]?*Guid, ChangedParamCount: ?*u32) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).SetAllDefaultsWithNotify(@as(*const ICodecAPI, @ptrCast(self)), ChangedParam, ChangedParamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_GetAllSettings(self: *const T, __MIDL__ICodecAPI0000: ?*IStream) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).GetAllSettings(@as(*const ICodecAPI, @ptrCast(self)), __MIDL__ICodecAPI0000);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_SetAllSettings(self: *const T, __MIDL__ICodecAPI0001: ?*IStream) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).SetAllSettings(@as(*const ICodecAPI, @ptrCast(self)), __MIDL__ICodecAPI0001);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodecAPI_SetAllSettingsWithNotify(self: *const T, __MIDL__ICodecAPI0002: ?*IStream, ChangedParam: [*]?*Guid, ChangedParamCount: ?*u32) HRESULT {
                return @as(*const ICodecAPI.VTable, @ptrCast(self.vtable)).SetAllSettingsWithNotify(@as(*const ICodecAPI, @ptrCast(self)), __MIDL__ICodecAPI0002, ChangedParam, ChangedParamCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3DOVERLAYCAPS = extern struct {
    Caps: u32,
    MaxOverlayDisplayWidth: u32,
    MaxOverlayDisplayHeight: u32,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDirect3D9ExOverlayExtension_Value = Guid.initString("187aeb13-aaf5-4c59-876d-e059088c0df8");
pub const IID_IDirect3D9ExOverlayExtension = &IID_IDirect3D9ExOverlayExtension_Value;
pub const IDirect3D9ExOverlayExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckDeviceOverlayType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3D9ExOverlayExtension,
                Adapter: u32,
                DevType: D3DDEVTYPE,
                OverlayWidth: u32,
                OverlayHeight: u32,
                OverlayFormat: D3DFORMAT,
                pDisplayMode: ?*D3DDISPLAYMODEEX,
                DisplayRotation: D3DDISPLAYROTATION,
                pOverlayCaps: ?*D3DOVERLAYCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3D9ExOverlayExtension,
                Adapter: u32,
                DevType: D3DDEVTYPE,
                OverlayWidth: u32,
                OverlayHeight: u32,
                OverlayFormat: D3DFORMAT,
                pDisplayMode: ?*D3DDISPLAYMODEEX,
                DisplayRotation: D3DDISPLAYROTATION,
                pOverlayCaps: ?*D3DOVERLAYCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3D9ExOverlayExtension_CheckDeviceOverlayType(self: *const T, Adapter: u32, DevType: D3DDEVTYPE, OverlayWidth: u32, OverlayHeight: u32, OverlayFormat: D3DFORMAT, pDisplayMode: ?*D3DDISPLAYMODEEX, DisplayRotation: D3DDISPLAYROTATION, pOverlayCaps: ?*D3DOVERLAYCAPS) HRESULT {
                return @as(*const IDirect3D9ExOverlayExtension.VTable, @ptrCast(self.vtable)).CheckDeviceOverlayType(@as(*const IDirect3D9ExOverlayExtension, @ptrCast(self)), Adapter, DevType, OverlayWidth, OverlayHeight, OverlayFormat, pDisplayMode, DisplayRotation, pOverlayCaps);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDirect3DDevice9Video_Value = Guid.initString("26dc4561-a1ee-4ae7-96da-118a36c0ec95");
pub const IID_IDirect3DDevice9Video = &IID_IDirect3DDevice9Video_Value;
pub const IDirect3DDevice9Video = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContentProtectionCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDevice9Video,
                pCryptoType: ?*const Guid,
                pDecodeProfile: ?*const Guid,
                pCaps: ?*D3DCONTENTPROTECTIONCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDevice9Video,
                pCryptoType: ?*const Guid,
                pDecodeProfile: ?*const Guid,
                pCaps: ?*D3DCONTENTPROTECTIONCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAuthenticatedChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDevice9Video,
                ChannelType: D3DAUTHENTICATEDCHANNELTYPE,
                ppAuthenticatedChannel: ?*?*IDirect3DAuthenticatedChannel9,
                pChannelHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDevice9Video,
                ChannelType: D3DAUTHENTICATEDCHANNELTYPE,
                ppAuthenticatedChannel: ?*?*IDirect3DAuthenticatedChannel9,
                pChannelHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCryptoSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDevice9Video,
                pCryptoType: ?*const Guid,
                pDecodeProfile: ?*const Guid,
                ppCryptoSession: ?*?*IDirect3DCryptoSession9,
                pCryptoHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDevice9Video,
                pCryptoType: ?*const Guid,
                pDecodeProfile: ?*const Guid,
                ppCryptoSession: ?*?*IDirect3DCryptoSession9,
                pCryptoHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDevice9Video_GetContentProtectionCaps(self: *const T, pCryptoType: ?*const Guid, pDecodeProfile: ?*const Guid, pCaps: ?*D3DCONTENTPROTECTIONCAPS) HRESULT {
                return @as(*const IDirect3DDevice9Video.VTable, @ptrCast(self.vtable)).GetContentProtectionCaps(@as(*const IDirect3DDevice9Video, @ptrCast(self)), pCryptoType, pDecodeProfile, pCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDevice9Video_CreateAuthenticatedChannel(self: *const T, ChannelType: D3DAUTHENTICATEDCHANNELTYPE, ppAuthenticatedChannel: ?*?*IDirect3DAuthenticatedChannel9, pChannelHandle: ?*?HANDLE) HRESULT {
                return @as(*const IDirect3DDevice9Video.VTable, @ptrCast(self.vtable)).CreateAuthenticatedChannel(@as(*const IDirect3DDevice9Video, @ptrCast(self)), ChannelType, ppAuthenticatedChannel, pChannelHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDevice9Video_CreateCryptoSession(self: *const T, pCryptoType: ?*const Guid, pDecodeProfile: ?*const Guid, ppCryptoSession: ?*?*IDirect3DCryptoSession9, pCryptoHandle: ?*?HANDLE) HRESULT {
                return @as(*const IDirect3DDevice9Video.VTable, @ptrCast(self.vtable)).CreateCryptoSession(@as(*const IDirect3DDevice9Video, @ptrCast(self)), pCryptoType, pDecodeProfile, ppCryptoSession, pCryptoHandle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDirect3DAuthenticatedChannel9_Value = Guid.initString("ff24beee-da21-4beb-98b5-d2f899f98af9");
pub const IID_IDirect3DAuthenticatedChannel9 = &IID_IDirect3DAuthenticatedChannel9_Value;
pub const IDirect3DAuthenticatedChannel9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertificateSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DAuthenticatedChannel9,
                pCertificateSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DAuthenticatedChannel9,
                pCertificateSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DAuthenticatedChannel9,
                CertifacteSize: u32,
                ppCertificate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DAuthenticatedChannel9,
                CertifacteSize: u32,
                ppCertificate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NegotiateKeyExchange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DAuthenticatedChannel9,
                DataSize: u32,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DAuthenticatedChannel9,
                DataSize: u32,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Query: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DAuthenticatedChannel9,
                InputSize: u32,
                pInput: ?*const anyopaque,
                OutputSize: u32,
                pOutput: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DAuthenticatedChannel9,
                InputSize: u32,
                pInput: ?*const anyopaque,
                OutputSize: u32,
                pOutput: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Configure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DAuthenticatedChannel9,
                InputSize: u32,
                pInput: ?*const anyopaque,
                pOutput: ?*D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DAuthenticatedChannel9,
                InputSize: u32,
                pInput: ?*const anyopaque,
                pOutput: ?*D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DAuthenticatedChannel9_GetCertificateSize(self: *const T, pCertificateSize: ?*u32) HRESULT {
                return @as(*const IDirect3DAuthenticatedChannel9.VTable, @ptrCast(self.vtable)).GetCertificateSize(@as(*const IDirect3DAuthenticatedChannel9, @ptrCast(self)), pCertificateSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DAuthenticatedChannel9_GetCertificate(self: *const T, CertifacteSize: u32, ppCertificate: ?*u8) HRESULT {
                return @as(*const IDirect3DAuthenticatedChannel9.VTable, @ptrCast(self.vtable)).GetCertificate(@as(*const IDirect3DAuthenticatedChannel9, @ptrCast(self)), CertifacteSize, ppCertificate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DAuthenticatedChannel9_NegotiateKeyExchange(self: *const T, DataSize: u32, pData: ?*anyopaque) HRESULT {
                return @as(*const IDirect3DAuthenticatedChannel9.VTable, @ptrCast(self.vtable)).NegotiateKeyExchange(@as(*const IDirect3DAuthenticatedChannel9, @ptrCast(self)), DataSize, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DAuthenticatedChannel9_Query(self: *const T, InputSize: u32, pInput: ?*const anyopaque, OutputSize: u32, pOutput: ?*anyopaque) HRESULT {
                return @as(*const IDirect3DAuthenticatedChannel9.VTable, @ptrCast(self.vtable)).Query(@as(*const IDirect3DAuthenticatedChannel9, @ptrCast(self)), InputSize, pInput, OutputSize, pOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DAuthenticatedChannel9_Configure(self: *const T, InputSize: u32, pInput: ?*const anyopaque, pOutput: ?*D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) HRESULT {
                return @as(*const IDirect3DAuthenticatedChannel9.VTable, @ptrCast(self.vtable)).Configure(@as(*const IDirect3DAuthenticatedChannel9, @ptrCast(self)), InputSize, pInput, pOutput);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDirect3DCryptoSession9_Value = Guid.initString("fa0ab799-7a9c-48ca-8c5b-237e71a54434");
pub const IID_IDirect3DCryptoSession9 = &IID_IDirect3DCryptoSession9_Value;
pub const IDirect3DCryptoSession9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertificateSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                pCertificateSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                pCertificateSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                CertifacteSize: u32,
                ppCertificate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                CertifacteSize: u32,
                ppCertificate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NegotiateKeyExchange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                DataSize: u32,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                DataSize: u32,
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EncryptionBlt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                pSrcSurface: ?*IDirect3DSurface9,
                pDstSurface: ?*IDirect3DSurface9,
                DstSurfaceSize: u32,
                pIV: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                pSrcSurface: ?*IDirect3DSurface9,
                pDstSurface: ?*IDirect3DSurface9,
                DstSurfaceSize: u32,
                pIV: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DecryptionBlt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                pSrcSurface: ?*IDirect3DSurface9,
                pDstSurface: ?*IDirect3DSurface9,
                SrcSurfaceSize: u32,
                pEncryptedBlockInfo: ?*D3DENCRYPTED_BLOCK_INFO,
                pContentKey: ?*anyopaque,
                pIV: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                pSrcSurface: ?*IDirect3DSurface9,
                pDstSurface: ?*IDirect3DSurface9,
                SrcSurfaceSize: u32,
                pEncryptedBlockInfo: ?*D3DENCRYPTED_BLOCK_INFO,
                pContentKey: ?*anyopaque,
                pIV: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSurfacePitch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                pSrcSurface: ?*IDirect3DSurface9,
                pSurfacePitch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                pSrcSurface: ?*IDirect3DSurface9,
                pSurfacePitch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSessionKeyRefresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                pRandomNumber: ?*anyopaque,
                RandomNumberSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                pRandomNumber: ?*anyopaque,
                RandomNumberSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishSessionKeyRefresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEncryptionBltKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DCryptoSession9,
                pReadbackKey: ?*anyopaque,
                KeySize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DCryptoSession9,
                pReadbackKey: ?*anyopaque,
                KeySize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_GetCertificateSize(self: *const T, pCertificateSize: ?*u32) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).GetCertificateSize(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), pCertificateSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_GetCertificate(self: *const T, CertifacteSize: u32, ppCertificate: ?*u8) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).GetCertificate(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), CertifacteSize, ppCertificate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_NegotiateKeyExchange(self: *const T, DataSize: u32, pData: ?*anyopaque) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).NegotiateKeyExchange(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), DataSize, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_EncryptionBlt(self: *const T, pSrcSurface: ?*IDirect3DSurface9, pDstSurface: ?*IDirect3DSurface9, DstSurfaceSize: u32, pIV: ?*anyopaque) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).EncryptionBlt(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), pSrcSurface, pDstSurface, DstSurfaceSize, pIV);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_DecryptionBlt(self: *const T, pSrcSurface: ?*IDirect3DSurface9, pDstSurface: ?*IDirect3DSurface9, SrcSurfaceSize: u32, pEncryptedBlockInfo: ?*D3DENCRYPTED_BLOCK_INFO, pContentKey: ?*anyopaque, pIV: ?*anyopaque) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).DecryptionBlt(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), pSrcSurface, pDstSurface, SrcSurfaceSize, pEncryptedBlockInfo, pContentKey, pIV);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_GetSurfacePitch(self: *const T, pSrcSurface: ?*IDirect3DSurface9, pSurfacePitch: ?*u32) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).GetSurfacePitch(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), pSrcSurface, pSurfacePitch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_StartSessionKeyRefresh(self: *const T, pRandomNumber: ?*anyopaque, RandomNumberSize: u32) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).StartSessionKeyRefresh(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), pRandomNumber, RandomNumberSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_FinishSessionKeyRefresh(self: *const T) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).FinishSessionKeyRefresh(@as(*const IDirect3DCryptoSession9, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DCryptoSession9_GetEncryptionBltKey(self: *const T, pReadbackKey: ?*anyopaque, KeySize: u32) HRESULT {
                return @as(*const IDirect3DCryptoSession9.VTable, @ptrCast(self.vtable)).GetEncryptionBltKey(@as(*const IDirect3DCryptoSession9, @ptrCast(self)), pReadbackKey, KeySize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_FIELD_TYPE = enum(i32) {
    NONE = 0,
    INTERLACED_TOP_FIELD_FIRST = 1,
    INTERLACED_BOTTOM_FIELD_FIRST = 2,
};
pub const D3D12_VIDEO_FIELD_TYPE_NONE = D3D12_VIDEO_FIELD_TYPE.NONE;
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST = D3D12_VIDEO_FIELD_TYPE.INTERLACED_TOP_FIELD_FIRST;
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST = D3D12_VIDEO_FIELD_TYPE.INTERLACED_BOTTOM_FIELD_FIRST;

pub const D3D12_VIDEO_FRAME_STEREO_FORMAT = enum(i32) {
    NONE = 0,
    MONO = 1,
    HORIZONTAL = 2,
    VERTICAL = 3,
    SEPARATE = 4,
};
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_NONE = D3D12_VIDEO_FRAME_STEREO_FORMAT.NONE;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_MONO = D3D12_VIDEO_FRAME_STEREO_FORMAT.MONO;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_HORIZONTAL = D3D12_VIDEO_FRAME_STEREO_FORMAT.HORIZONTAL;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_VERTICAL = D3D12_VIDEO_FRAME_STEREO_FORMAT.VERTICAL;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_SEPARATE = D3D12_VIDEO_FRAME_STEREO_FORMAT.SEPARATE;

pub const D3D12_VIDEO_FORMAT = extern struct {
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
};

pub const D3D12_VIDEO_SAMPLE = extern struct {
    Width: u32,
    Height: u32,
    Format: D3D12_VIDEO_FORMAT,
};

pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE = enum(i32) {
    NONE = 0,
    FIELD_BASED = 1,
};
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_NONE = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE.NONE;
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_FIELD_BASED = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE.FIELD_BASED;

pub const D3D12_FEATURE_VIDEO = enum(i32) {
    DECODE_SUPPORT = 0,
    DECODE_PROFILES = 1,
    DECODE_FORMATS = 2,
    DECODE_CONVERSION_SUPPORT = 3,
    PROCESS_SUPPORT = 5,
    PROCESS_MAX_INPUT_STREAMS = 6,
    PROCESS_REFERENCE_INFO = 7,
    DECODER_HEAP_SIZE = 8,
    PROCESSOR_SIZE = 9,
    DECODE_PROFILE_COUNT = 10,
    DECODE_FORMAT_COUNT = 11,
    ARCHITECTURE = 17,
    DECODE_HISTOGRAM = 18,
    FEATURE_AREA_SUPPORT = 19,
    MOTION_ESTIMATOR = 20,
    MOTION_ESTIMATOR_SIZE = 21,
    EXTENSION_COMMAND_COUNT = 22,
    EXTENSION_COMMANDS = 23,
    EXTENSION_COMMAND_PARAMETER_COUNT = 24,
    EXTENSION_COMMAND_PARAMETERS = 25,
    EXTENSION_COMMAND_SUPPORT = 26,
    EXTENSION_COMMAND_SIZE = 27,
    DECODE_PROTECTED_RESOURCES = 28,
    PROCESS_PROTECTED_RESOURCES = 29,
    MOTION_ESTIMATOR_PROTECTED_RESOURCES = 30,
    DECODER_HEAP_SIZE1 = 31,
    PROCESSOR_SIZE1 = 32,
};
pub const D3D12_FEATURE_VIDEO_DECODE_SUPPORT = D3D12_FEATURE_VIDEO.DECODE_SUPPORT;
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILES = D3D12_FEATURE_VIDEO.DECODE_PROFILES;
pub const D3D12_FEATURE_VIDEO_DECODE_FORMATS = D3D12_FEATURE_VIDEO.DECODE_FORMATS;
pub const D3D12_FEATURE_VIDEO_DECODE_CONVERSION_SUPPORT = D3D12_FEATURE_VIDEO.DECODE_CONVERSION_SUPPORT;
pub const D3D12_FEATURE_VIDEO_PROCESS_SUPPORT = D3D12_FEATURE_VIDEO.PROCESS_SUPPORT;
pub const D3D12_FEATURE_VIDEO_PROCESS_MAX_INPUT_STREAMS = D3D12_FEATURE_VIDEO.PROCESS_MAX_INPUT_STREAMS;
pub const D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO = D3D12_FEATURE_VIDEO.PROCESS_REFERENCE_INFO;
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE = D3D12_FEATURE_VIDEO.DECODER_HEAP_SIZE;
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE = D3D12_FEATURE_VIDEO.PROCESSOR_SIZE;
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILE_COUNT = D3D12_FEATURE_VIDEO.DECODE_PROFILE_COUNT;
pub const D3D12_FEATURE_VIDEO_DECODE_FORMAT_COUNT = D3D12_FEATURE_VIDEO.DECODE_FORMAT_COUNT;
pub const D3D12_FEATURE_VIDEO_ARCHITECTURE = D3D12_FEATURE_VIDEO.ARCHITECTURE;
pub const D3D12_FEATURE_VIDEO_DECODE_HISTOGRAM = D3D12_FEATURE_VIDEO.DECODE_HISTOGRAM;
pub const D3D12_FEATURE_VIDEO_FEATURE_AREA_SUPPORT = D3D12_FEATURE_VIDEO.FEATURE_AREA_SUPPORT;
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR = D3D12_FEATURE_VIDEO.MOTION_ESTIMATOR;
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_SIZE = D3D12_FEATURE_VIDEO.MOTION_ESTIMATOR_SIZE;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_COUNT;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMANDS = D3D12_FEATURE_VIDEO.EXTENSION_COMMANDS;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_PARAMETER_COUNT;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_PARAMETERS;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SUPPORT = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_SUPPORT;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SIZE = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_SIZE;
pub const D3D12_FEATURE_VIDEO_DECODE_PROTECTED_RESOURCES = D3D12_FEATURE_VIDEO.DECODE_PROTECTED_RESOURCES;
pub const D3D12_FEATURE_VIDEO_PROCESS_PROTECTED_RESOURCES = D3D12_FEATURE_VIDEO.PROCESS_PROTECTED_RESOURCES;
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES = D3D12_FEATURE_VIDEO.MOTION_ESTIMATOR_PROTECTED_RESOURCES;
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE1 = D3D12_FEATURE_VIDEO.DECODER_HEAP_SIZE1;
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE1 = D3D12_FEATURE_VIDEO.PROCESSOR_SIZE1;

pub const D3D12_BITSTREAM_ENCRYPTION_TYPE = enum(i32) {
    E = 0,
};
pub const D3D12_BITSTREAM_ENCRYPTION_TYPE_NONE = D3D12_BITSTREAM_ENCRYPTION_TYPE.E;

pub const D3D12_VIDEO_DECODE_CONFIGURATION = extern struct {
    DecodeProfile: Guid,
    BitstreamEncryption: D3D12_BITSTREAM_ENCRYPTION_TYPE,
    InterlaceType: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE,
};

pub const D3D12_VIDEO_DECODER_DESC = extern struct {
    NodeMask: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
};

pub const D3D12_VIDEO_DECODER_HEAP_DESC = extern struct {
    NodeMask: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    DecodeWidth: u32,
    DecodeHeight: u32,
    Format: DXGI_FORMAT,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
    MaxDecodePictureBufferCount: u32,
};

pub const D3D12_VIDEO_SIZE_RANGE = extern struct {
    MaxWidth: u32,
    MaxHeight: u32,
    MinWidth: u32,
    MinHeight: u32,
};

pub const D3D12_VIDEO_PROCESS_FILTER = enum(i32) {
    BRIGHTNESS = 0,
    CONTRAST = 1,
    HUE = 2,
    SATURATION = 3,
    NOISE_REDUCTION = 4,
    EDGE_ENHANCEMENT = 5,
    ANAMORPHIC_SCALING = 6,
    STEREO_ADJUSTMENT = 7,
};
pub const D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS = D3D12_VIDEO_PROCESS_FILTER.BRIGHTNESS;
pub const D3D12_VIDEO_PROCESS_FILTER_CONTRAST = D3D12_VIDEO_PROCESS_FILTER.CONTRAST;
pub const D3D12_VIDEO_PROCESS_FILTER_HUE = D3D12_VIDEO_PROCESS_FILTER.HUE;
pub const D3D12_VIDEO_PROCESS_FILTER_SATURATION = D3D12_VIDEO_PROCESS_FILTER.SATURATION;
pub const D3D12_VIDEO_PROCESS_FILTER_NOISE_REDUCTION = D3D12_VIDEO_PROCESS_FILTER.NOISE_REDUCTION;
pub const D3D12_VIDEO_PROCESS_FILTER_EDGE_ENHANCEMENT = D3D12_VIDEO_PROCESS_FILTER.EDGE_ENHANCEMENT;
pub const D3D12_VIDEO_PROCESS_FILTER_ANAMORPHIC_SCALING = D3D12_VIDEO_PROCESS_FILTER.ANAMORPHIC_SCALING;
pub const D3D12_VIDEO_PROCESS_FILTER_STEREO_ADJUSTMENT = D3D12_VIDEO_PROCESS_FILTER.STEREO_ADJUSTMENT;

pub const D3D12_VIDEO_PROCESS_FILTER_FLAGS = enum(u32) {
    NONE = 0,
    BRIGHTNESS = 1,
    CONTRAST = 2,
    HUE = 4,
    SATURATION = 8,
    NOISE_REDUCTION = 16,
    EDGE_ENHANCEMENT = 32,
    ANAMORPHIC_SCALING = 64,
    STEREO_ADJUSTMENT = 128,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        BRIGHTNESS: u1 = 0,
        CONTRAST: u1 = 0,
        HUE: u1 = 0,
        SATURATION: u1 = 0,
        NOISE_REDUCTION: u1 = 0,
        EDGE_ENHANCEMENT: u1 = 0,
        ANAMORPHIC_SCALING: u1 = 0,
        STEREO_ADJUSTMENT: u1 = 0,
    }) D3D12_VIDEO_PROCESS_FILTER_FLAGS {
        return @as(D3D12_VIDEO_PROCESS_FILTER_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.NONE) else 0) | (if (o.BRIGHTNESS == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.BRIGHTNESS) else 0) | (if (o.CONTRAST == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.CONTRAST) else 0) | (if (o.HUE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.HUE) else 0) | (if (o.SATURATION == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.SATURATION) else 0) | (if (o.NOISE_REDUCTION == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.NOISE_REDUCTION) else 0) | (if (o.EDGE_ENHANCEMENT == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.EDGE_ENHANCEMENT) else 0) | (if (o.ANAMORPHIC_SCALING == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.ANAMORPHIC_SCALING) else 0) | (if (o.STEREO_ADJUSTMENT == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FILTER_FLAGS.STEREO_ADJUSTMENT) else 0)));
    }
};
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE = D3D12_VIDEO_PROCESS_FILTER_FLAGS.NONE;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS = D3D12_VIDEO_PROCESS_FILTER_FLAGS.BRIGHTNESS;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST = D3D12_VIDEO_PROCESS_FILTER_FLAGS.CONTRAST;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE = D3D12_VIDEO_PROCESS_FILTER_FLAGS.HUE;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION = D3D12_VIDEO_PROCESS_FILTER_FLAGS.SATURATION;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION = D3D12_VIDEO_PROCESS_FILTER_FLAGS.NOISE_REDUCTION;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT = D3D12_VIDEO_PROCESS_FILTER_FLAGS.EDGE_ENHANCEMENT;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING = D3D12_VIDEO_PROCESS_FILTER_FLAGS.ANAMORPHIC_SCALING;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT = D3D12_VIDEO_PROCESS_FILTER_FLAGS.STEREO_ADJUSTMENT;

pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS = enum(u32) {
    NONE = 0,
    BOB = 1,
    CUSTOM = 2147483648,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        BOB: u1 = 0,
        CUSTOM: u1 = 0,
    }) D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
        return @as(D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.NONE) else 0) | (if (o.BOB == 1) @intFromEnum(D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.BOB) else 0) | (if (o.CUSTOM == 1) @intFromEnum(D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.CUSTOM) else 0)));
    }
};
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.NONE;
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.BOB;
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.CUSTOM;

pub const D3D12_VIDEO_PROCESS_ALPHA_BLENDING = extern struct {
    Enable: BOOL,
    Alpha: f32,
};

pub const D3D12_VIDEO_PROCESS_LUMA_KEY = extern struct {
    Enable: BOOL,
    Lower: f32,
    Upper: f32,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC = extern struct {
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    SourceAspectRatio: DXGI_RATIONAL,
    DestinationAspectRatio: DXGI_RATIONAL,
    FrameRate: DXGI_RATIONAL,
    SourceSizeRange: D3D12_VIDEO_SIZE_RANGE,
    DestinationSizeRange: D3D12_VIDEO_SIZE_RANGE,
    EnableOrientation: BOOL,
    FilterFlags: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    StereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    FieldType: D3D12_VIDEO_FIELD_TYPE,
    DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    EnableAlphaBlending: BOOL,
    LumaKey: D3D12_VIDEO_PROCESS_LUMA_KEY,
    NumPastFrames: u32,
    NumFutureFrames: u32,
    EnableAutoProcessing: BOOL,
};

pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = enum(i32) {
    OPAQUE = 0,
    BACKGROUND = 1,
    DESTINATION = 2,
    SOURCE_STREAM = 3,
};
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.OPAQUE;
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.BACKGROUND;
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_DESTINATION = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.DESTINATION;
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.SOURCE_STREAM;

pub const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC = extern struct {
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    AlphaFillMode: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE,
    AlphaFillModeSourceStreamIndex: u32,
    BackgroundColor: [4]f32,
    FrameRate: DXGI_RATIONAL,
    EnableStereo: BOOL,
};

const IID_ID3D12VideoDecoderHeap_Value = Guid.initString("0946b7c9-ebf6-4047-bb73-8683e27dbb1f");
pub const IID_ID3D12VideoDecoderHeap = &IID_ID3D12VideoDecoderHeap_Value;
pub const ID3D12VideoDecoderHeap = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_DECODER_HEAP_DESC,
            else => *const fn (
                self: *const ID3D12VideoDecoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_DECODER_HEAP_DESC,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecoderHeap_GetDesc(self: *const T) D3D12_VIDEO_DECODER_HEAP_DESC {
                return @as(*const ID3D12VideoDecoderHeap.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const ID3D12VideoDecoderHeap, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice_Value = Guid.initString("1f052807-0b46-4acc-8a89-364f793718a4");
pub const IID_ID3D12VideoDevice = &IID_ID3D12VideoDevice_Value;
pub const ID3D12VideoDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckFeatureSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice,
                FeatureVideo: D3D12_FEATURE_VIDEO,
                // TODO: what to do with BytesParamIndex 2?
                pFeatureSupportData: ?*anyopaque,
                FeatureSupportDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice,
                FeatureVideo: D3D12_FEATURE_VIDEO,
                // TODO: what to do with BytesParamIndex 2?
                pFeatureSupportData: ?*anyopaque,
                FeatureSupportDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoDecoder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice,
                pDesc: ?*const D3D12_VIDEO_DECODER_DESC,
                riid: ?*const Guid,
                ppVideoDecoder: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice,
                pDesc: ?*const D3D12_VIDEO_DECODER_DESC,
                riid: ?*const Guid,
                ppVideoDecoder: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoDecoderHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice,
                pVideoDecoderHeapDesc: ?*const D3D12_VIDEO_DECODER_HEAP_DESC,
                riid: ?*const Guid,
                ppVideoDecoderHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice,
                pVideoDecoderHeapDesc: ?*const D3D12_VIDEO_DECODER_HEAP_DESC,
                riid: ?*const Guid,
                ppVideoDecoderHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice,
                NodeMask: u32,
                pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
                NumInputStreamDescs: u32,
                pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
                riid: ?*const Guid,
                ppVideoProcessor: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice,
                NodeMask: u32,
                pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
                NumInputStreamDescs: u32,
                pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
                riid: ?*const Guid,
                ppVideoProcessor: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice_CheckFeatureSupport(self: *const T, FeatureVideo: D3D12_FEATURE_VIDEO, pFeatureSupportData: ?*anyopaque, FeatureSupportDataSize: u32) HRESULT {
                return @as(*const ID3D12VideoDevice.VTable, @ptrCast(self.vtable)).CheckFeatureSupport(@as(*const ID3D12VideoDevice, @ptrCast(self)), FeatureVideo, pFeatureSupportData, FeatureSupportDataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice_CreateVideoDecoder(self: *const T, pDesc: ?*const D3D12_VIDEO_DECODER_DESC, riid: ?*const Guid, ppVideoDecoder: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice.VTable, @ptrCast(self.vtable)).CreateVideoDecoder(@as(*const ID3D12VideoDevice, @ptrCast(self)), pDesc, riid, ppVideoDecoder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice_CreateVideoDecoderHeap(self: *const T, pVideoDecoderHeapDesc: ?*const D3D12_VIDEO_DECODER_HEAP_DESC, riid: ?*const Guid, ppVideoDecoderHeap: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice.VTable, @ptrCast(self.vtable)).CreateVideoDecoderHeap(@as(*const ID3D12VideoDevice, @ptrCast(self)), pVideoDecoderHeapDesc, riid, ppVideoDecoderHeap);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice_CreateVideoProcessor(self: *const T, NodeMask: u32, pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, NumInputStreamDescs: u32, pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: ?*const Guid, ppVideoProcessor: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice.VTable, @ptrCast(self.vtable)).CreateVideoProcessor(@as(*const ID3D12VideoDevice, @ptrCast(self)), NodeMask, pOutputStreamDesc, NumInputStreamDescs, pInputStreamDescs, riid, ppVideoProcessor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDecoder_Value = Guid.initString("c59b6bdc-7720-4074-a136-17a156037470");
pub const IID_ID3D12VideoDecoder = &IID_ID3D12VideoDecoder_Value;
pub const ID3D12VideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_DECODER_DESC,
            else => *const fn (
                self: *const ID3D12VideoDecoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_DECODER_DESC,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecoder_GetDesc(self: *const T) D3D12_VIDEO_DECODER_DESC {
                return @as(*const ID3D12VideoDecoder.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const ID3D12VideoDecoder, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_DECODE_TIER = enum(i32) {
    NOT_SUPPORTED = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
};
pub const D3D12_VIDEO_DECODE_TIER_NOT_SUPPORTED = D3D12_VIDEO_DECODE_TIER.NOT_SUPPORTED;
pub const D3D12_VIDEO_DECODE_TIER_1 = D3D12_VIDEO_DECODE_TIER.@"1";
pub const D3D12_VIDEO_DECODE_TIER_2 = D3D12_VIDEO_DECODE_TIER.@"2";
pub const D3D12_VIDEO_DECODE_TIER_3 = D3D12_VIDEO_DECODE_TIER.@"3";

pub const D3D12_VIDEO_DECODE_SUPPORT_FLAGS = enum(u32) {
    NONE = 0,
    SUPPORTED = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SUPPORTED: u1 = 0,
    }) D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
        return @as(D3D12_VIDEO_DECODE_SUPPORT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_DECODE_SUPPORT_FLAGS.NONE) else 0) | (if (o.SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_DECODE_SUPPORT_FLAGS.SUPPORTED) else 0)));
    }
};
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE = D3D12_VIDEO_DECODE_SUPPORT_FLAGS.NONE;
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_DECODE_SUPPORT_FLAGS.SUPPORTED;

pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = enum(u32) {
    NONE = 0,
    HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED = 1,
    POST_PROCESSING_SUPPORTED = 2,
    REFERENCE_ONLY_ALLOCATIONS_REQUIRED = 4,
    ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME = 8,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED: u1 = 0,
        POST_PROCESSING_SUPPORTED: u1 = 0,
        REFERENCE_ONLY_ALLOCATIONS_REQUIRED: u1 = 0,
        ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME: u1 = 0,
    }) D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
        return @as(D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.NONE) else 0) | (if (o.HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED) else 0) | (if (o.POST_PROCESSING_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.POST_PROCESSING_SUPPORTED) else 0) | (if (o.REFERENCE_ONLY_ALLOCATIONS_REQUIRED == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.REFERENCE_ONLY_ALLOCATIONS_REQUIRED) else 0) | (if (o.ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME) else 0)));
    }
};
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.NONE;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.POST_PROCESSING_SUPPORTED;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.REFERENCE_ONLY_ALLOCATIONS_REQUIRED;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME;

pub const D3D12_VIDEO_DECODE_STATUS = enum(i32) {
    OK = 0,
    CONTINUE = 1,
    CONTINUE_SKIP_DISPLAY = 2,
    RESTART = 3,
    RATE_EXCEEDED = 4,
};
pub const D3D12_VIDEO_DECODE_STATUS_OK = D3D12_VIDEO_DECODE_STATUS.OK;
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE = D3D12_VIDEO_DECODE_STATUS.CONTINUE;
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE_SKIP_DISPLAY = D3D12_VIDEO_DECODE_STATUS.CONTINUE_SKIP_DISPLAY;
pub const D3D12_VIDEO_DECODE_STATUS_RESTART = D3D12_VIDEO_DECODE_STATUS.RESTART;
pub const D3D12_VIDEO_DECODE_STATUS_RATE_EXCEEDED = D3D12_VIDEO_DECODE_STATUS.RATE_EXCEEDED;

pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE = enum(i32) {
    PICTURE_PARAMETERS = 0,
    INVERSE_QUANTIZATION_MATRIX = 1,
    SLICE_CONTROL = 2,
    MAX_VALID = 3,
};
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_PICTURE_PARAMETERS = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.PICTURE_PARAMETERS;
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_INVERSE_QUANTIZATION_MATRIX = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.INVERSE_QUANTIZATION_MATRIX;
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_SLICE_CONTROL = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.SLICE_CONTROL;
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_MAX_VALID = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.MAX_VALID;

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    Width: u32,
    Height: u32,
    DecodeFormat: DXGI_FORMAT,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
    SupportFlags: D3D12_VIDEO_DECODE_SUPPORT_FLAGS,
    ConfigurationFlags: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS,
    DecodeTier: D3D12_VIDEO_DECODE_TIER,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT = extern struct {
    NodeIndex: u32,
    ProfileCount: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES = extern struct {
    NodeIndex: u32,
    ProfileCount: u32,
    pProfiles: ?*Guid,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    FormatCount: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    FormatCount: u32,
    pOutputFormats: ?*DXGI_FORMAT,
};

pub const D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE = extern struct {
    IOCoherent: BOOL,
};

pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = enum(i32) {
    Y = 0,
    U = 1,
    V = 2,
    // R = 0, this enum value conflicts with Y
    // G = 1, this enum value conflicts with U
    // B = 2, this enum value conflicts with V
    A = 3,
};
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_Y = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.Y;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_U = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.U;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_V = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.V;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_R = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.Y;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_G = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.U;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_B = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.V;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_A = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.A;

pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = enum(u32) {
    NONE = 0,
    Y = 1,
    U = 2,
    V = 4,
    // R = 1, this enum value conflicts with Y
    // G = 2, this enum value conflicts with U
    // B = 4, this enum value conflicts with V
    A = 8,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        Y: u1 = 0,
        U: u1 = 0,
        V: u1 = 0,
        A: u1 = 0,
    }) D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
        return @as(D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.NONE) else 0) | (if (o.Y == 1) @intFromEnum(D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.Y) else 0) | (if (o.U == 1) @intFromEnum(D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.U) else 0) | (if (o.V == 1) @intFromEnum(D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.V) else 0) | (if (o.A == 1) @intFromEnum(D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.A) else 0)));
    }
};
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.NONE;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.Y;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.U;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.V;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.Y;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.U;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.V;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.A;

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM = extern struct {
    NodeIndex: u32,
    DecodeProfile: Guid,
    Width: u32,
    Height: u32,
    DecodeFormat: DXGI_FORMAT,
    Components: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS,
    BinCount: u32,
    CounterBitDepth: u32,
};

pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = enum(u32) {
    NONE = 0,
    SUPPORTED = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SUPPORTED: u1 = 0,
    }) D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
        return @as(D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS.NONE) else 0) | (if (o.SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS.SUPPORTED) else 0)));
    }
};
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS.NONE;
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS.SUPPORTED;

pub const D3D12_VIDEO_SCALE_SUPPORT_FLAGS = enum(u32) {
    NONE = 0,
    POW2_ONLY = 1,
    EVEN_DIMENSIONS_ONLY = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        POW2_ONLY: u1 = 0,
        EVEN_DIMENSIONS_ONLY: u1 = 0,
    }) D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
        return @as(D3D12_VIDEO_SCALE_SUPPORT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_SCALE_SUPPORT_FLAGS.NONE) else 0) | (if (o.POW2_ONLY == 1) @intFromEnum(D3D12_VIDEO_SCALE_SUPPORT_FLAGS.POW2_ONLY) else 0) | (if (o.EVEN_DIMENSIONS_ONLY == 1) @intFromEnum(D3D12_VIDEO_SCALE_SUPPORT_FLAGS.EVEN_DIMENSIONS_ONLY) else 0)));
    }
};
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE = D3D12_VIDEO_SCALE_SUPPORT_FLAGS.NONE;
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY = D3D12_VIDEO_SCALE_SUPPORT_FLAGS.POW2_ONLY;
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY = D3D12_VIDEO_SCALE_SUPPORT_FLAGS.EVEN_DIMENSIONS_ONLY;

pub const D3D12_VIDEO_SCALE_SUPPORT = extern struct {
    OutputSizeRange: D3D12_VIDEO_SIZE_RANGE,
    Flags: D3D12_VIDEO_SCALE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    DecodeSample: D3D12_VIDEO_SAMPLE,
    OutputFormat: D3D12_VIDEO_FORMAT,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
    SupportFlags: D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS,
    ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE = extern struct {
    VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE = extern struct {
    NodeMask: u32,
    pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    NumInputStreamDescs: u32,
    pInputStreamDescs: ?*const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS = extern struct {
    Status: u64,
    NumMacroblocksAffected: u64,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
};

pub const D3D12_VIDEO_DECODE_FRAME_ARGUMENT = extern struct {
    Type: D3D12_VIDEO_DECODE_ARGUMENT_TYPE,
    Size: u32,
    pData: ?*anyopaque,
};

pub const D3D12_VIDEO_DECODE_REFERENCE_FRAMES = extern struct {
    NumTexture2Ds: u32,
    ppTexture2Ds: ?*?*ID3D12Resource,
    pSubresources: ?*u32,
    ppHeaps: ?*?*ID3D12VideoDecoderHeap,
};

pub const D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM = extern struct {
    pBuffer: ?*ID3D12Resource,
    Offset: u64,
    Size: u64,
};

pub const D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS = extern struct {
    Enable: BOOL,
    pReferenceTexture2D: ?*ID3D12Resource,
    ReferenceSubresource: u32,
    OutputColorSpace: DXGI_COLOR_SPACE_TYPE,
    DecodeColorSpace: DXGI_COLOR_SPACE_TYPE,
};

pub const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS = extern struct {
    NumFrameArguments: u32,
    FrameArguments: [10]D3D12_VIDEO_DECODE_FRAME_ARGUMENT,
    ReferenceFrames: D3D12_VIDEO_DECODE_REFERENCE_FRAMES,
    CompressedBitstream: D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM,
    pHeap: ?*ID3D12VideoDecoderHeap,
};

pub const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS = extern struct {
    pOutputTexture2D: ?*ID3D12Resource,
    OutputSubresource: u32,
    ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS,
};

const IID_ID3D12VideoProcessor_Value = Guid.initString("304fdb32-bede-410a-8545-943ac6a46138");
pub const IID_ID3D12VideoProcessor = &IID_ID3D12VideoProcessor_Value;
pub const ID3D12VideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetNodeMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ID3D12VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetNumInputStreamDescs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ID3D12VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetInputStreamDescs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessor,
                NumInputStreamDescs: u32,
                pInputStreamDescs: [*]D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoProcessor,
                NumInputStreamDescs: u32,
                pInputStreamDescs: [*]D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
            else => *const fn (
                self: *const ID3D12VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessor_GetNodeMask(self: *const T) u32 {
                return @as(*const ID3D12VideoProcessor.VTable, @ptrCast(self.vtable)).GetNodeMask(@as(*const ID3D12VideoProcessor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessor_GetNumInputStreamDescs(self: *const T) u32 {
                return @as(*const ID3D12VideoProcessor.VTable, @ptrCast(self.vtable)).GetNumInputStreamDescs(@as(*const ID3D12VideoProcessor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessor_GetInputStreamDescs(self: *const T, NumInputStreamDescs: u32, pInputStreamDescs: [*]D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) HRESULT {
                return @as(*const ID3D12VideoProcessor.VTable, @ptrCast(self.vtable)).GetInputStreamDescs(@as(*const ID3D12VideoProcessor, @ptrCast(self)), NumInputStreamDescs, pInputStreamDescs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessor_GetOutputStreamDesc(self: *const T) D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
                return @as(*const ID3D12VideoProcessor.VTable, @ptrCast(self.vtable)).GetOutputStreamDesc(@as(*const ID3D12VideoProcessor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_PROCESS_FEATURE_FLAGS = enum(u32) {
    NONE = 0,
    ALPHA_FILL = 1,
    LUMA_KEY = 2,
    STEREO = 4,
    ROTATION = 8,
    FLIP = 16,
    ALPHA_BLENDING = 32,
    PIXEL_ASPECT_RATIO = 64,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        ALPHA_FILL: u1 = 0,
        LUMA_KEY: u1 = 0,
        STEREO: u1 = 0,
        ROTATION: u1 = 0,
        FLIP: u1 = 0,
        ALPHA_BLENDING: u1 = 0,
        PIXEL_ASPECT_RATIO: u1 = 0,
    }) D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
        return @as(D3D12_VIDEO_PROCESS_FEATURE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.NONE) else 0) | (if (o.ALPHA_FILL == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.ALPHA_FILL) else 0) | (if (o.LUMA_KEY == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.LUMA_KEY) else 0) | (if (o.STEREO == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.STEREO) else 0) | (if (o.ROTATION == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.ROTATION) else 0) | (if (o.FLIP == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.FLIP) else 0) | (if (o.ALPHA_BLENDING == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.ALPHA_BLENDING) else 0) | (if (o.PIXEL_ASPECT_RATIO == 1) @intFromEnum(D3D12_VIDEO_PROCESS_FEATURE_FLAGS.PIXEL_ASPECT_RATIO) else 0)));
    }
};
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.NONE;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.ALPHA_FILL;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.LUMA_KEY;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.STEREO;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.ROTATION;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.FLIP;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.ALPHA_BLENDING;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.PIXEL_ASPECT_RATIO;

pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = enum(u32) {
    NONE = 0,
    DENOISE = 1,
    DERINGING = 2,
    EDGE_ENHANCEMENT = 4,
    COLOR_CORRECTION = 8,
    FLESH_TONE_MAPPING = 16,
    IMAGE_STABILIZATION = 32,
    SUPER_RESOLUTION = 64,
    ANAMORPHIC_SCALING = 128,
    CUSTOM = 2147483648,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DENOISE: u1 = 0,
        DERINGING: u1 = 0,
        EDGE_ENHANCEMENT: u1 = 0,
        COLOR_CORRECTION: u1 = 0,
        FLESH_TONE_MAPPING: u1 = 0,
        IMAGE_STABILIZATION: u1 = 0,
        SUPER_RESOLUTION: u1 = 0,
        ANAMORPHIC_SCALING: u1 = 0,
        CUSTOM: u1 = 0,
    }) D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
        return @as(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.NONE) else 0) | (if (o.DENOISE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.DENOISE) else 0) | (if (o.DERINGING == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.DERINGING) else 0) | (if (o.EDGE_ENHANCEMENT == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.EDGE_ENHANCEMENT) else 0) | (if (o.COLOR_CORRECTION == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.COLOR_CORRECTION) else 0) | (if (o.FLESH_TONE_MAPPING == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.FLESH_TONE_MAPPING) else 0) | (if (o.IMAGE_STABILIZATION == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.IMAGE_STABILIZATION) else 0) | (if (o.SUPER_RESOLUTION == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.SUPER_RESOLUTION) else 0) | (if (o.ANAMORPHIC_SCALING == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.ANAMORPHIC_SCALING) else 0) | (if (o.CUSTOM == 1) @intFromEnum(D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.CUSTOM) else 0)));
    }
};
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.NONE;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.DENOISE;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.DERINGING;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.EDGE_ENHANCEMENT;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.COLOR_CORRECTION;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.FLESH_TONE_MAPPING;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.IMAGE_STABILIZATION;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.SUPER_RESOLUTION;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.ANAMORPHIC_SCALING;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.CUSTOM;

pub const D3D12_VIDEO_PROCESS_ORIENTATION = enum(i32) {
    DEFAULT = 0,
    FLIP_HORIZONTAL = 1,
    CLOCKWISE_90 = 2,
    CLOCKWISE_90_FLIP_HORIZONTAL = 3,
    CLOCKWISE_180 = 4,
    FLIP_VERTICAL = 5,
    CLOCKWISE_270 = 6,
    CLOCKWISE_270_FLIP_HORIZONTAL = 7,
};
pub const D3D12_VIDEO_PROCESS_ORIENTATION_DEFAULT = D3D12_VIDEO_PROCESS_ORIENTATION.DEFAULT;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_HORIZONTAL = D3D12_VIDEO_PROCESS_ORIENTATION.FLIP_HORIZONTAL;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90 = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_90;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90_FLIP_HORIZONTAL = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_90_FLIP_HORIZONTAL;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_180 = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_180;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_VERTICAL = D3D12_VIDEO_PROCESS_ORIENTATION.FLIP_VERTICAL;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270 = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_270;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270_FLIP_HORIZONTAL = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_270_FLIP_HORIZONTAL;

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = enum(u32) {
    NONE = 0,
    FRAME_DISCONTINUITY = 1,
    FRAME_REPEAT = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        FRAME_DISCONTINUITY: u1 = 0,
        FRAME_REPEAT: u1 = 0,
    }) D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
        return @as(D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.NONE) else 0) | (if (o.FRAME_DISCONTINUITY == 1) @intFromEnum(D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.FRAME_DISCONTINUITY) else 0) | (if (o.FRAME_REPEAT == 1) @intFromEnum(D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.FRAME_REPEAT) else 0)));
    }
};
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.NONE;
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.FRAME_DISCONTINUITY;
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.FRAME_REPEAT;

pub const D3D12_VIDEO_PROCESS_FILTER_RANGE = extern struct {
    Minimum: i32,
    Maximum: i32,
    Default: i32,
    Multiplier: f32,
};

pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAGS = enum(u32) {
    NONE = 0,
    SUPPORTED = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SUPPORTED: u1 = 0,
    }) D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
        return @as(D3D12_VIDEO_PROCESS_SUPPORT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROCESS_SUPPORT_FLAGS.NONE) else 0) | (if (o.SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_PROCESS_SUPPORT_FLAGS.SUPPORTED) else 0)));
    }
};
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE = D3D12_VIDEO_PROCESS_SUPPORT_FLAGS.NONE;
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_PROCESS_SUPPORT_FLAGS.SUPPORTED;

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT = extern struct {
    NodeIndex: u32,
    InputSample: D3D12_VIDEO_SAMPLE,
    InputFieldType: D3D12_VIDEO_FIELD_TYPE,
    InputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    InputFrameRate: DXGI_RATIONAL,
    OutputFormat: D3D12_VIDEO_FORMAT,
    OutputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    OutputFrameRate: DXGI_RATIONAL,
    SupportFlags: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS,
    ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
    FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    DeinterlaceSupport: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    AutoProcessingSupport: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS,
    FilterSupport: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    FilterRangeSupport: [32]D3D12_VIDEO_PROCESS_FILTER_RANGE,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS = extern struct {
    NodeIndex: u32,
    MaxInputStreams: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO = extern struct {
    NodeIndex: u32,
    DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    Filters: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    InputFrameRate: DXGI_RATIONAL,
    OutputFrameRate: DXGI_RATIONAL,
    EnableAutoProcessing: BOOL,
    PastFrames: u32,
    FutureFrames: u32,
};

pub const D3D12_VIDEO_PROCESS_REFERENCE_SET = extern struct {
    NumPastFrames: u32,
    ppPastFrames: ?*?*ID3D12Resource,
    pPastSubresources: ?*u32,
    NumFutureFrames: u32,
    ppFutureFrames: ?*?*ID3D12Resource,
    pFutureSubresources: ?*u32,
};

pub const D3D12_VIDEO_PROCESS_TRANSFORM = extern struct {
    SourceRectangle: RECT,
    DestinationRectangle: RECT,
    Orientation: D3D12_VIDEO_PROCESS_ORIENTATION,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE = extern struct {
    OutputIndex: u32,
    InputFrameOrField: u32,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM = extern struct {
    pTexture2D: ?*ID3D12Resource,
    Subresource: u32,
    ReferenceSet: D3D12_VIDEO_PROCESS_REFERENCE_SET,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS = extern struct {
    InputStream: [2]D3D12_VIDEO_PROCESS_INPUT_STREAM,
    Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    FilterLevels: [32]i32,
    AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
};

pub const D3D12_VIDEO_PROCESS_OUTPUT_STREAM = extern struct {
    pTexture2D: ?*ID3D12Resource,
    Subresource: u32,
};

pub const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS = extern struct {
    OutputStream: [2]D3D12_VIDEO_PROCESS_OUTPUT_STREAM,
    TargetRectangle: RECT,
};

const IID_ID3D12VideoDecodeCommandList_Value = Guid.initString("3b60536e-ad29-4e64-a269-f853837e5e53");
pub const IID_ID3D12VideoDecodeCommandList = &IID_ID3D12VideoDecodeCommandList_Value;
pub const ID3D12VideoDecodeCommandList = extern struct {
    pub const VTable = extern struct {
        base: ID3D12CommandList.VTable,
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pAllocator: ?*ID3D12CommandAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pAllocator: ?*ID3D12CommandAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResourceBarrier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                NumBarriers: u32,
                pBarriers: [*]const D3D12_RESOURCE_BARRIER,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                NumBarriers: u32,
                pBarriers: [*]const D3D12_RESOURCE_BARRIER,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DiscardResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pResource: ?*ID3D12Resource,
                pRegion: ?*const D3D12_DISCARD_REGION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pResource: ?*ID3D12Resource,
                pRegion: ?*const D3D12_DISCARD_REGION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResolveQueryData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                StartIndex: u32,
                NumQueries: u32,
                pDestinationBuffer: ?*ID3D12Resource,
                AlignedDestinationBufferOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                StartIndex: u32,
                NumQueries: u32,
                pDestinationBuffer: ?*ID3D12Resource,
                AlignedDestinationBufferOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPredication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pBuffer: ?*ID3D12Resource,
                AlignedBufferOffset: u64,
                Operation: D3D12_PREDICATION_OP,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pBuffer: ?*ID3D12Resource,
                AlignedBufferOffset: u64,
                Operation: D3D12_PREDICATION_OP,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DecodeFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                pDecoder: ?*ID3D12VideoDecoder,
                pOutputArguments: ?*const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
                pInputArguments: ?*const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                pDecoder: ?*ID3D12VideoDecoder,
                pOutputArguments: ?*const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
                pInputArguments: ?*const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        WriteBufferImmediate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList,
                Count: u32,
                pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList,
                Count: u32,
                pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12CommandList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_Close(self: *const T) HRESULT {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).Close(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_Reset(self: *const T, pAllocator: ?*ID3D12CommandAllocator) HRESULT {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).Reset(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_ClearState(self: *const T) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).ClearState(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_ResourceBarrier(self: *const T, NumBarriers: u32, pBarriers: [*]const D3D12_RESOURCE_BARRIER) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).ResourceBarrier(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), NumBarriers, pBarriers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_DiscardResource(self: *const T, pResource: ?*ID3D12Resource, pRegion: ?*const D3D12_DISCARD_REGION) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).DiscardResource(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pResource, pRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_BeginQuery(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).BeginQuery(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pQueryHeap, Type, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_EndQuery(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).EndQuery(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pQueryHeap, Type, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_ResolveQueryData(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, StartIndex: u32, NumQueries: u32, pDestinationBuffer: ?*ID3D12Resource, AlignedDestinationBufferOffset: u64) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).ResolveQueryData(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_SetPredication(self: *const T, pBuffer: ?*ID3D12Resource, AlignedBufferOffset: u64, Operation: D3D12_PREDICATION_OP) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).SetPredication(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pBuffer, AlignedBufferOffset, Operation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_SetMarker(self: *const T, Metadata: u32, pData: ?*const anyopaque, Size: u32) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).SetMarker(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), Metadata, pData, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_BeginEvent(self: *const T, Metadata: u32, pData: ?*const anyopaque, Size: u32) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).BeginEvent(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), Metadata, pData, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_EndEvent(self: *const T) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).EndEvent(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_DecodeFrame(self: *const T, pDecoder: ?*ID3D12VideoDecoder, pOutputArguments: ?*const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pInputArguments: ?*const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).DecodeFrame(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), pDecoder, pOutputArguments, pInputArguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList_WriteBufferImmediate(self: *const T, Count: u32, pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE) void {
                return @as(*const ID3D12VideoDecodeCommandList.VTable, @ptrCast(self.vtable)).WriteBufferImmediate(@as(*const ID3D12VideoDecodeCommandList, @ptrCast(self)), Count, pParams, pModes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoProcessCommandList_Value = Guid.initString("aeb2543a-167f-4682-acc8-d159ed4a6209");
pub const IID_ID3D12VideoProcessCommandList = &IID_ID3D12VideoProcessCommandList_Value;
pub const ID3D12VideoProcessCommandList = extern struct {
    pub const VTable = extern struct {
        base: ID3D12CommandList.VTable,
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pAllocator: ?*ID3D12CommandAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pAllocator: ?*ID3D12CommandAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResourceBarrier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                NumBarriers: u32,
                pBarriers: [*]const D3D12_RESOURCE_BARRIER,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                NumBarriers: u32,
                pBarriers: [*]const D3D12_RESOURCE_BARRIER,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DiscardResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pResource: ?*ID3D12Resource,
                pRegion: ?*const D3D12_DISCARD_REGION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pResource: ?*ID3D12Resource,
                pRegion: ?*const D3D12_DISCARD_REGION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResolveQueryData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                StartIndex: u32,
                NumQueries: u32,
                pDestinationBuffer: ?*ID3D12Resource,
                AlignedDestinationBufferOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                StartIndex: u32,
                NumQueries: u32,
                pDestinationBuffer: ?*ID3D12Resource,
                AlignedDestinationBufferOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPredication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pBuffer: ?*ID3D12Resource,
                AlignedBufferOffset: u64,
                Operation: D3D12_PREDICATION_OP,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pBuffer: ?*ID3D12Resource,
                AlignedBufferOffset: u64,
                Operation: D3D12_PREDICATION_OP,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ProcessFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                pVideoProcessor: ?*ID3D12VideoProcessor,
                pOutputArguments: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
                NumInputStreams: u32,
                pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                pVideoProcessor: ?*ID3D12VideoProcessor,
                pOutputArguments: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
                NumInputStreams: u32,
                pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        WriteBufferImmediate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList,
                Count: u32,
                pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList,
                Count: u32,
                pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12CommandList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_Close(self: *const T) HRESULT {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).Close(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_Reset(self: *const T, pAllocator: ?*ID3D12CommandAllocator) HRESULT {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).Reset(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_ClearState(self: *const T) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).ClearState(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_ResourceBarrier(self: *const T, NumBarriers: u32, pBarriers: [*]const D3D12_RESOURCE_BARRIER) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).ResourceBarrier(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), NumBarriers, pBarriers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_DiscardResource(self: *const T, pResource: ?*ID3D12Resource, pRegion: ?*const D3D12_DISCARD_REGION) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).DiscardResource(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pResource, pRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_BeginQuery(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).BeginQuery(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pQueryHeap, Type, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_EndQuery(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).EndQuery(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pQueryHeap, Type, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_ResolveQueryData(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, StartIndex: u32, NumQueries: u32, pDestinationBuffer: ?*ID3D12Resource, AlignedDestinationBufferOffset: u64) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).ResolveQueryData(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_SetPredication(self: *const T, pBuffer: ?*ID3D12Resource, AlignedBufferOffset: u64, Operation: D3D12_PREDICATION_OP) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).SetPredication(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pBuffer, AlignedBufferOffset, Operation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_SetMarker(self: *const T, Metadata: u32, pData: ?*const anyopaque, Size: u32) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).SetMarker(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), Metadata, pData, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_BeginEvent(self: *const T, Metadata: u32, pData: ?*const anyopaque, Size: u32) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).BeginEvent(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), Metadata, pData, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_EndEvent(self: *const T) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).EndEvent(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_ProcessFrames(self: *const T, pVideoProcessor: ?*ID3D12VideoProcessor, pOutputArguments: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, NumInputStreams: u32, pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).ProcessFrames(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), pVideoProcessor, pOutputArguments, NumInputStreams, pInputArguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList_WriteBufferImmediate(self: *const T, Count: u32, pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE) void {
                return @as(*const ID3D12VideoProcessCommandList.VTable, @ptrCast(self.vtable)).WriteBufferImmediate(@as(*const ID3D12VideoProcessCommandList, @ptrCast(self)), Count, pParams, pModes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM = extern struct {
    Offset: u64,
    pBuffer: ?*ID3D12Resource,
};

pub const D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 = extern struct {
    Enable: BOOL,
    pReferenceTexture2D: ?*ID3D12Resource,
    ReferenceSubresource: u32,
    OutputColorSpace: DXGI_COLOR_SPACE_TYPE,
    DecodeColorSpace: DXGI_COLOR_SPACE_TYPE,
    OutputWidth: u32,
    OutputHeight: u32,
};

pub const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 = extern struct {
    pOutputTexture2D: ?*ID3D12Resource,
    OutputSubresource: u32,
    ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1,
    Histograms: [4]D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM,
};

const IID_ID3D12VideoDecodeCommandList1_Value = Guid.initString("d52f011b-b56e-453c-a05a-a7f311c8f472");
pub const IID_ID3D12VideoDecodeCommandList1 = &IID_ID3D12VideoDecodeCommandList1_Value;
pub const ID3D12VideoDecodeCommandList1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecodeCommandList.VTable,
        DecodeFrame1: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList1,
                pDecoder: ?*ID3D12VideoDecoder,
                pOutputArguments: ?*const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
                pInputArguments: ?*const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList1,
                pDecoder: ?*ID3D12VideoDecoder,
                pOutputArguments: ?*const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
                pInputArguments: ?*const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDecodeCommandList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList1_DecodeFrame1(self: *const T, pDecoder: ?*ID3D12VideoDecoder, pOutputArguments: ?*const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pInputArguments: ?*const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) void {
                return @as(*const ID3D12VideoDecodeCommandList1.VTable, @ptrCast(self.vtable)).DecodeFrame1(@as(*const ID3D12VideoDecodeCommandList1, @ptrCast(self)), pDecoder, pOutputArguments, pInputArguments);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 = extern struct {
    InputStream: [2]D3D12_VIDEO_PROCESS_INPUT_STREAM,
    Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    FilterLevels: [32]i32,
    AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
    FieldType: D3D12_VIDEO_FIELD_TYPE,
};

const IID_ID3D12VideoProcessCommandList1_Value = Guid.initString("542c5c4d-7596-434f-8c93-4efa6766f267");
pub const IID_ID3D12VideoProcessCommandList1 = &IID_ID3D12VideoProcessCommandList1_Value;
pub const ID3D12VideoProcessCommandList1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoProcessCommandList.VTable,
        ProcessFrames1: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList1,
                pVideoProcessor: ?*ID3D12VideoProcessor,
                pOutputArguments: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
                NumInputStreams: u32,
                pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList1,
                pVideoProcessor: ?*ID3D12VideoProcessor,
                pOutputArguments: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
                NumInputStreams: u32,
                pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoProcessCommandList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList1_ProcessFrames1(self: *const T, pVideoProcessor: ?*ID3D12VideoProcessor, pOutputArguments: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, NumInputStreams: u32, pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1) void {
                return @as(*const ID3D12VideoProcessCommandList1.VTable, @ptrCast(self.vtable)).ProcessFrames1(@as(*const ID3D12VideoProcessCommandList1, @ptrCast(self)), pVideoProcessor, pOutputArguments, NumInputStreams, pInputArguments);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE = enum(i32) {
    @"8X8" = 0,
    @"16X16" = 1,
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_8X8 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE.@"8X8";
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_16X16 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE.@"16X16";

pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS = enum(u32) {
    NONE = 0,
    @"8X8" = 1,
    @"16X16" = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        @"8X8": u1 = 0,
        @"16X16": u1 = 0,
    }) D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
        return @as(D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.NONE) else 0) | (if (o.@"8X8" == 1) @intFromEnum(D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.@"8X8") else 0) | (if (o.@"16X16" == 1) @intFromEnum(D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.@"16X16") else 0)));
    }
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.NONE;
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.@"8X8";
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.@"16X16";

pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION = enum(i32) {
    L = 0,
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_QUARTER_PEL = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION.L;

pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS = enum(u32) {
    NONE = 0,
    QUARTER_PEL = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        QUARTER_PEL: u1 = 0,
    }) D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
        return @as(D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS.NONE) else 0) | (if (o.QUARTER_PEL == 1) @intFromEnum(D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS.QUARTER_PEL) else 0)));
    }
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS.NONE;
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS.QUARTER_PEL;

pub const D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT = extern struct {
    NodeIndex: u32,
    VideoDecodeSupport: BOOL,
    VideoProcessSupport: BOOL,
    VideoEncodeSupport: BOOL,
};

pub const D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR = extern struct {
    NodeIndex: u32,
    InputFormat: DXGI_FORMAT,
    BlockSizeFlags: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS,
    PrecisionFlags: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
};

pub const D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE = extern struct {
    NodeIndex: u32,
    InputFormat: DXGI_FORMAT,
    BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
    Protected: BOOL,
    MotionVectorHeapMemoryPoolL0Size: u64,
    MotionVectorHeapMemoryPoolL1Size: u64,
    MotionEstimatorMemoryPoolL0Size: u64,
    MotionEstimatorMemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_DESC = extern struct {
    NodeMask: u32,
    InputFormat: DXGI_FORMAT,
    BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_ID3D12VideoMotionEstimator_Value = Guid.initString("33fdae0e-098b-428f-87bb-34b695de08f8");
pub const IID_ID3D12VideoMotionEstimator = &IID_ID3D12VideoMotionEstimator_Value;
pub const ID3D12VideoMotionEstimator = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoMotionEstimator,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
            else => *const fn (
                self: *const ID3D12VideoMotionEstimator,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        },
        GetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoMotionEstimator,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoMotionEstimator,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoMotionEstimator_GetDesc(self: *const T) D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
                return @as(*const ID3D12VideoMotionEstimator.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const ID3D12VideoMotionEstimator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoMotionEstimator_GetProtectedResourceSession(self: *const T, riid: ?*const Guid, ppProtectedSession: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoMotionEstimator.VTable, @ptrCast(self.vtable)).GetProtectedResourceSession(@as(*const ID3D12VideoMotionEstimator, @ptrCast(self)), riid, ppProtectedSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC = extern struct {
    NodeMask: u32,
    InputFormat: DXGI_FORMAT,
    BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_ID3D12VideoMotionVectorHeap_Value = Guid.initString("5be17987-743a-4061-834b-23d22daea505");
pub const IID_ID3D12VideoMotionVectorHeap = &IID_ID3D12VideoMotionVectorHeap_Value;
pub const ID3D12VideoMotionVectorHeap = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoMotionVectorHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
            else => *const fn (
                self: *const ID3D12VideoMotionVectorHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        },
        GetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoMotionVectorHeap,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoMotionVectorHeap,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoMotionVectorHeap_GetDesc(self: *const T) D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
                return @as(*const ID3D12VideoMotionVectorHeap.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const ID3D12VideoMotionVectorHeap, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoMotionVectorHeap_GetProtectedResourceSession(self: *const T, riid: ?*const Guid, ppProtectedSession: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoMotionVectorHeap.VTable, @ptrCast(self.vtable)).GetProtectedResourceSession(@as(*const ID3D12VideoMotionVectorHeap, @ptrCast(self)), riid, ppProtectedSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice1_Value = Guid.initString("981611ad-a144-4c83-9890-f30e26d658ab");
pub const IID_ID3D12VideoDevice1 = &IID_ID3D12VideoDevice1_Value;
pub const ID3D12VideoDevice1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDevice.VTable,
        CreateVideoMotionEstimator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice1,
                pDesc: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoMotionEstimator: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice1,
                pDesc: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoMotionEstimator: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoMotionVectorHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice1,
                pDesc: ?*const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoMotionVectorHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice1,
                pDesc: ?*const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoMotionVectorHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDevice.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice1_CreateVideoMotionEstimator(self: *const T, pDesc: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: ?*const Guid, ppVideoMotionEstimator: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice1.VTable, @ptrCast(self.vtable)).CreateVideoMotionEstimator(@as(*const ID3D12VideoDevice1, @ptrCast(self)), pDesc, pProtectedResourceSession, riid, ppVideoMotionEstimator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice1_CreateVideoMotionVectorHeap(self: *const T, pDesc: ?*const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: ?*const Guid, ppVideoMotionVectorHeap: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice1.VTable, @ptrCast(self.vtable)).CreateVideoMotionVectorHeap(@as(*const ID3D12VideoDevice1, @ptrCast(self)), pDesc, pProtectedResourceSession, riid, ppVideoMotionVectorHeap);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_RESOURCE_COORDINATE = extern struct {
    X: u64,
    Y: u32,
    Z: u32,
    SubresourceIndex: u32,
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT = extern struct {
    pMotionVectorHeap: ?*ID3D12VideoMotionVectorHeap,
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT = extern struct {
    pInputTexture2D: ?*ID3D12Resource,
    InputSubresourceIndex: u32,
    pReferenceTexture2D: ?*ID3D12Resource,
    ReferenceSubresourceIndex: u32,
    pHintMotionVectorHeap: ?*ID3D12VideoMotionVectorHeap,
};

pub const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT = extern struct {
    pMotionVectorTexture2D: ?*ID3D12Resource,
    MotionVectorCoordinate: D3D12_RESOURCE_COORDINATE,
};

pub const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT = extern struct {
    pMotionVectorHeap: ?*ID3D12VideoMotionVectorHeap,
    PixelWidth: u32,
    PixelHeight: u32,
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_ID3D12VideoEncodeCommandList_Value = Guid.initString("8455293a-0cbd-4831-9b39-fbdbab724723");
pub const IID_ID3D12VideoEncodeCommandList = &IID_ID3D12VideoEncodeCommandList_Value;
pub const ID3D12VideoEncodeCommandList = extern struct {
    pub const VTable = extern struct {
        base: ID3D12CommandList.VTable,
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pAllocator: ?*ID3D12CommandAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pAllocator: ?*ID3D12CommandAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResourceBarrier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                NumBarriers: u32,
                pBarriers: [*]const D3D12_RESOURCE_BARRIER,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                NumBarriers: u32,
                pBarriers: [*]const D3D12_RESOURCE_BARRIER,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DiscardResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pResource: ?*ID3D12Resource,
                pRegion: ?*const D3D12_DISCARD_REGION,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pResource: ?*ID3D12Resource,
                pRegion: ?*const D3D12_DISCARD_REGION,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResolveQueryData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                StartIndex: u32,
                NumQueries: u32,
                pDestinationBuffer: ?*ID3D12Resource,
                AlignedDestinationBufferOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pQueryHeap: ?*ID3D12QueryHeap,
                Type: D3D12_QUERY_TYPE,
                StartIndex: u32,
                NumQueries: u32,
                pDestinationBuffer: ?*ID3D12Resource,
                AlignedDestinationBufferOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetPredication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pBuffer: ?*ID3D12Resource,
                AlignedBufferOffset: u64,
                Operation: D3D12_PREDICATION_OP,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pBuffer: ?*ID3D12Resource,
                AlignedBufferOffset: u64,
                Operation: D3D12_PREDICATION_OP,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        BeginEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                Metadata: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EstimateMotion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pMotionEstimator: ?*ID3D12VideoMotionEstimator,
                pOutputArguments: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
                pInputArguments: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pMotionEstimator: ?*ID3D12VideoMotionEstimator,
                pOutputArguments: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
                pInputArguments: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResolveMotionVectorHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pOutputArguments: ?*const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
                pInputArguments: ?*const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pOutputArguments: ?*const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
                pInputArguments: ?*const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        WriteBufferImmediate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                Count: u32,
                pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                Count: u32,
                pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
                pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12CommandList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_Close(self: *const T) HRESULT {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).Close(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_Reset(self: *const T, pAllocator: ?*ID3D12CommandAllocator) HRESULT {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).Reset(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_ClearState(self: *const T) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).ClearState(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_ResourceBarrier(self: *const T, NumBarriers: u32, pBarriers: [*]const D3D12_RESOURCE_BARRIER) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).ResourceBarrier(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), NumBarriers, pBarriers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_DiscardResource(self: *const T, pResource: ?*ID3D12Resource, pRegion: ?*const D3D12_DISCARD_REGION) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).DiscardResource(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pResource, pRegion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_BeginQuery(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).BeginQuery(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pQueryHeap, Type, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_EndQuery(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).EndQuery(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pQueryHeap, Type, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_ResolveQueryData(self: *const T, pQueryHeap: ?*ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, StartIndex: u32, NumQueries: u32, pDestinationBuffer: ?*ID3D12Resource, AlignedDestinationBufferOffset: u64) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).ResolveQueryData(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_SetPredication(self: *const T, pBuffer: ?*ID3D12Resource, AlignedBufferOffset: u64, Operation: D3D12_PREDICATION_OP) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).SetPredication(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pBuffer, AlignedBufferOffset, Operation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_SetMarker(self: *const T, Metadata: u32, pData: ?*const anyopaque, Size: u32) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).SetMarker(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), Metadata, pData, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_BeginEvent(self: *const T, Metadata: u32, pData: ?*const anyopaque, Size: u32) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).BeginEvent(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), Metadata, pData, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_EndEvent(self: *const T) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).EndEvent(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_EstimateMotion(self: *const T, pMotionEstimator: ?*ID3D12VideoMotionEstimator, pOutputArguments: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pInputArguments: ?*const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).EstimateMotion(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pMotionEstimator, pOutputArguments, pInputArguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_ResolveMotionVectorHeap(self: *const T, pOutputArguments: ?*const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pInputArguments: ?*const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).ResolveMotionVectorHeap(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pOutputArguments, pInputArguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_WriteBufferImmediate(self: *const T, Count: u32, pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).WriteBufferImmediate(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), Count, pParams, pModes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList_SetProtectedResourceSession(self: *const T, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession) void {
                return @as(*const ID3D12VideoEncodeCommandList.VTable, @ptrCast(self.vtable)).SetProtectedResourceSession(@as(*const ID3D12VideoEncodeCommandList, @ptrCast(self)), pProtectedResourceSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS = enum(u32) {
    NONE = 0,
    SUPPORTED = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        SUPPORTED: u1 = 0,
    }) D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
        return @as(D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS.NONE) else 0) | (if (o.SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS.SUPPORTED) else 0)));
    }
};
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE = D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS.NONE;
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS.SUPPORTED;

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES = extern struct {
    NodeIndex: u32,
    SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES = extern struct {
    NodeIndex: u32,
    SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 = extern struct {
    VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    Protected: BOOL,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 = extern struct {
    NodeMask: u32,
    pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    NumInputStreamDescs: u32,
    pInputStreamDescs: ?*const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    Protected: BOOL,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = enum(i32) {
    CREATION = 0,
    INITIALIZATION = 1,
    EXECUTION = 2,
    CAPS_INPUT = 3,
    CAPS_OUTPUT = 4,
    DEVICE_EXECUTE_INPUT = 5,
    DEVICE_EXECUTE_OUTPUT = 6,
};
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.CREATION;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.INITIALIZATION;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.EXECUTION;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_INPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.CAPS_INPUT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_OUTPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.CAPS_OUTPUT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_INPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.DEVICE_EXECUTE_INPUT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_OUTPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.DEVICE_EXECUTE_OUTPUT;

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = enum(i32) {
    UINT8 = 0,
    UINT16 = 1,
    UINT32 = 2,
    UINT64 = 3,
    SINT8 = 4,
    SINT16 = 5,
    SINT32 = 6,
    SINT64 = 7,
    FLOAT = 8,
    DOUBLE = 9,
    RESOURCE = 10,
};
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT8 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT8;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT16 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT16;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT32 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT32;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT64 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT64;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT8 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT8;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT16 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT16;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT32 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT32;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT64 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT64;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_FLOAT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.FLOAT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_DOUBLE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.DOUBLE;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_RESOURCE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.RESOURCE;

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS = enum(u32) {
    NONE = 0,
    READ = 1,
    WRITE = 2,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        READ: u1 = 0,
        WRITE: u1 = 0,
    }) D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
        return @as(D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.NONE) else 0) | (if (o.READ == 1) @intFromEnum(D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.READ) else 0) | (if (o.WRITE == 1) @intFromEnum(D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.WRITE) else 0)));
    }
};
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.NONE;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.READ;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.WRITE;

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT = extern struct {
    NodeIndex: u32,
    CommandCount: u32,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_INFO = extern struct {
    CommandId: Guid,
    Name: ?[*:0]const u16,
    CommandListSupportFlags: D3D12_COMMAND_LIST_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS = extern struct {
    NodeIndex: u32,
    CommandCount: u32,
    pCommandInfos: ?*D3D12_VIDEO_EXTENSION_COMMAND_INFO,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT = extern struct {
    CommandId: Guid,
    Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    ParameterCount: u32,
    ParameterPacking: u32,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO = extern struct {
    Name: ?[*:0]const u16,
    Type: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE,
    Flags: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS = extern struct {
    CommandId: Guid,
    Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    ParameterCount: u32,
    pParameterInfos: ?*D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT = extern struct {
    NodeIndex: u32,
    CommandId: Guid,
    pInputData: ?*const anyopaque,
    InputDataSizeInBytes: usize,
    pOutputData: ?*anyopaque,
    OutputDataSizeInBytes: usize,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE = extern struct {
    NodeIndex: u32,
    CommandId: Guid,
    pCreationParameters: ?*const anyopaque,
    CreationParametersSizeInBytes: usize,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_DESC = extern struct {
    NodeMask: u32,
    CommandId: Guid,
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_ID3D12VideoDecoder1_Value = Guid.initString("79a2e5fb-ccd2-469a-9fde-195d10951f7e");
pub const IID_ID3D12VideoDecoder1 = &IID_ID3D12VideoDecoder1_Value;
pub const ID3D12VideoDecoder1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecoder.VTable,
        GetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecoder1,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDecoder1,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDecoder.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecoder1_GetProtectedResourceSession(self: *const T, riid: ?*const Guid, ppProtectedSession: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDecoder1.VTable, @ptrCast(self.vtable)).GetProtectedResourceSession(@as(*const ID3D12VideoDecoder1, @ptrCast(self)), riid, ppProtectedSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDecoderHeap1_Value = Guid.initString("da1d98c5-539f-41b2-bf6b-1198a03b6d26");
pub const IID_ID3D12VideoDecoderHeap1 = &IID_ID3D12VideoDecoderHeap1_Value;
pub const ID3D12VideoDecoderHeap1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecoderHeap.VTable,
        GetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecoderHeap1,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDecoderHeap1,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDecoderHeap.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecoderHeap1_GetProtectedResourceSession(self: *const T, riid: ?*const Guid, ppProtectedSession: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDecoderHeap1.VTable, @ptrCast(self.vtable)).GetProtectedResourceSession(@as(*const ID3D12VideoDecoderHeap1, @ptrCast(self)), riid, ppProtectedSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoProcessor1_Value = Guid.initString("f3cfe615-553f-425c-86d8-ee8c1b1fb01c");
pub const IID_ID3D12VideoProcessor1 = &IID_ID3D12VideoProcessor1_Value;
pub const ID3D12VideoProcessor1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoProcessor.VTable,
        GetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessor1,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoProcessor1,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoProcessor.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessor1_GetProtectedResourceSession(self: *const T, riid: ?*const Guid, ppProtectedSession: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoProcessor1.VTable, @ptrCast(self.vtable)).GetProtectedResourceSession(@as(*const ID3D12VideoProcessor1, @ptrCast(self)), riid, ppProtectedSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_ID3D12VideoExtensionCommand_Value = Guid.initString("554e41e8-ae8e-4a8c-b7d2-5b4f274a30e4");
pub const IID_ID3D12VideoExtensionCommand = &IID_ID3D12VideoExtensionCommand_Value;
pub const ID3D12VideoExtensionCommand = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoExtensionCommand,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_EXTENSION_COMMAND_DESC,
            else => *const fn (
                self: *const ID3D12VideoExtensionCommand,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        },
        GetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoExtensionCommand,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoExtensionCommand,
                riid: ?*const Guid,
                ppProtectedSession: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoExtensionCommand_GetDesc(self: *const T) D3D12_VIDEO_EXTENSION_COMMAND_DESC {
                return @as(*const ID3D12VideoExtensionCommand.VTable, @ptrCast(self.vtable)).GetDesc(@as(*const ID3D12VideoExtensionCommand, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoExtensionCommand_GetProtectedResourceSession(self: *const T, riid: ?*const Guid, ppProtectedSession: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoExtensionCommand.VTable, @ptrCast(self.vtable)).GetProtectedResourceSession(@as(*const ID3D12VideoExtensionCommand, @ptrCast(self)), riid, ppProtectedSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice2_Value = Guid.initString("f019ac49-f838-4a95-9b17-579437c8f513");
pub const IID_ID3D12VideoDevice2 = &IID_ID3D12VideoDevice2_Value;
pub const ID3D12VideoDevice2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDevice1.VTable,
        CreateVideoDecoder1: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice2,
                pDesc: ?*const D3D12_VIDEO_DECODER_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoDecoder: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice2,
                pDesc: ?*const D3D12_VIDEO_DECODER_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoDecoder: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoDecoderHeap1: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice2,
                pVideoDecoderHeapDesc: ?*const D3D12_VIDEO_DECODER_HEAP_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoDecoderHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice2,
                pVideoDecoderHeapDesc: ?*const D3D12_VIDEO_DECODER_HEAP_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoDecoderHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoProcessor1: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice2,
                NodeMask: u32,
                pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
                NumInputStreamDescs: u32,
                pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoProcessor: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice2,
                NodeMask: u32,
                pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
                NumInputStreamDescs: u32,
                pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoProcessor: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice2,
                pDesc: ?*const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
                // TODO: what to do with BytesParamIndex 2?
                pCreationParameters: ?*const anyopaque,
                CreationParametersDataSizeInBytes: usize,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoExtensionCommand: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice2,
                pDesc: ?*const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
                // TODO: what to do with BytesParamIndex 2?
                pCreationParameters: ?*const anyopaque,
                CreationParametersDataSizeInBytes: usize,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
                riid: ?*const Guid,
                ppVideoExtensionCommand: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
                // TODO: what to do with BytesParamIndex 4?
                pOutputData: ?*anyopaque,
                OutputDataSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
                // TODO: what to do with BytesParamIndex 4?
                pOutputData: ?*anyopaque,
                OutputDataSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDevice1.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice2_CreateVideoDecoder1(self: *const T, pDesc: ?*const D3D12_VIDEO_DECODER_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: ?*const Guid, ppVideoDecoder: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice2.VTable, @ptrCast(self.vtable)).CreateVideoDecoder1(@as(*const ID3D12VideoDevice2, @ptrCast(self)), pDesc, pProtectedResourceSession, riid, ppVideoDecoder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice2_CreateVideoDecoderHeap1(self: *const T, pVideoDecoderHeapDesc: ?*const D3D12_VIDEO_DECODER_HEAP_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: ?*const Guid, ppVideoDecoderHeap: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice2.VTable, @ptrCast(self.vtable)).CreateVideoDecoderHeap1(@as(*const ID3D12VideoDevice2, @ptrCast(self)), pVideoDecoderHeapDesc, pProtectedResourceSession, riid, ppVideoDecoderHeap);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice2_CreateVideoProcessor1(self: *const T, NodeMask: u32, pOutputStreamDesc: ?*const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, NumInputStreamDescs: u32, pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: ?*const Guid, ppVideoProcessor: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice2.VTable, @ptrCast(self.vtable)).CreateVideoProcessor1(@as(*const ID3D12VideoDevice2, @ptrCast(self)), NodeMask, pOutputStreamDesc, NumInputStreamDescs, pInputStreamDescs, pProtectedResourceSession, riid, ppVideoProcessor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice2_CreateVideoExtensionCommand(self: *const T, pDesc: ?*const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pCreationParameters: ?*const anyopaque, CreationParametersDataSizeInBytes: usize, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: ?*const Guid, ppVideoExtensionCommand: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice2.VTable, @ptrCast(self.vtable)).CreateVideoExtensionCommand(@as(*const ID3D12VideoDevice2, @ptrCast(self)), pDesc, pCreationParameters, CreationParametersDataSizeInBytes, pProtectedResourceSession, riid, ppVideoExtensionCommand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice2_ExecuteExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pExecutionParameters: ?*const anyopaque, ExecutionParametersSizeInBytes: usize, pOutputData: ?*anyopaque, OutputDataSizeInBytes: usize) HRESULT {
                return @as(*const ID3D12VideoDevice2.VTable, @ptrCast(self.vtable)).ExecuteExtensionCommand(@as(*const ID3D12VideoDevice2, @ptrCast(self)), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes, pOutputData, OutputDataSizeInBytes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDecodeCommandList2_Value = Guid.initString("6e120880-c114-4153-8036-d247051e1729");
pub const IID_ID3D12VideoDecodeCommandList2 = &IID_ID3D12VideoDecodeCommandList2_Value;
pub const ID3D12VideoDecodeCommandList2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecodeCommandList1.VTable,
        SetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList2,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList2,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        InitializeExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pInitializationParameters: ?*const anyopaque,
                InitializationParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pInitializationParameters: ?*const anyopaque,
                InitializationParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ExecuteExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDecodeCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoDecodeCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDecodeCommandList1.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList2_SetProtectedResourceSession(self: *const T, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession) void {
                return @as(*const ID3D12VideoDecodeCommandList2.VTable, @ptrCast(self.vtable)).SetProtectedResourceSession(@as(*const ID3D12VideoDecodeCommandList2, @ptrCast(self)), pProtectedResourceSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList2_InitializeExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pInitializationParameters: ?*const anyopaque, InitializationParametersSizeInBytes: usize) void {
                return @as(*const ID3D12VideoDecodeCommandList2.VTable, @ptrCast(self.vtable)).InitializeExtensionCommand(@as(*const ID3D12VideoDecodeCommandList2, @ptrCast(self)), pExtensionCommand, pInitializationParameters, InitializationParametersSizeInBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDecodeCommandList2_ExecuteExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pExecutionParameters: ?*const anyopaque, ExecutionParametersSizeInBytes: usize) void {
                return @as(*const ID3D12VideoDecodeCommandList2.VTable, @ptrCast(self.vtable)).ExecuteExtensionCommand(@as(*const ID3D12VideoDecodeCommandList2, @ptrCast(self)), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoProcessCommandList2_Value = Guid.initString("db525ae4-6ad6-473c-baa7-59b2e37082e4");
pub const IID_ID3D12VideoProcessCommandList2 = &IID_ID3D12VideoProcessCommandList2_Value;
pub const ID3D12VideoProcessCommandList2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoProcessCommandList1.VTable,
        SetProtectedResourceSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList2,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList2,
                pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        InitializeExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pInitializationParameters: ?*const anyopaque,
                InitializationParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pInitializationParameters: ?*const anyopaque,
                InitializationParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ExecuteExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoProcessCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoProcessCommandList2,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoProcessCommandList1.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList2_SetProtectedResourceSession(self: *const T, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession) void {
                return @as(*const ID3D12VideoProcessCommandList2.VTable, @ptrCast(self.vtable)).SetProtectedResourceSession(@as(*const ID3D12VideoProcessCommandList2, @ptrCast(self)), pProtectedResourceSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList2_InitializeExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pInitializationParameters: ?*const anyopaque, InitializationParametersSizeInBytes: usize) void {
                return @as(*const ID3D12VideoProcessCommandList2.VTable, @ptrCast(self.vtable)).InitializeExtensionCommand(@as(*const ID3D12VideoProcessCommandList2, @ptrCast(self)), pExtensionCommand, pInitializationParameters, InitializationParametersSizeInBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoProcessCommandList2_ExecuteExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pExecutionParameters: ?*const anyopaque, ExecutionParametersSizeInBytes: usize) void {
                return @as(*const ID3D12VideoProcessCommandList2.VTable, @ptrCast(self.vtable)).ExecuteExtensionCommand(@as(*const ID3D12VideoProcessCommandList2, @ptrCast(self)), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoEncodeCommandList1_Value = Guid.initString("94971eca-2bdb-4769-88cf-3675ea757ebc");
pub const IID_ID3D12VideoEncodeCommandList1 = &IID_ID3D12VideoEncodeCommandList1_Value;
pub const ID3D12VideoEncodeCommandList1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoEncodeCommandList.VTable,
        InitializeExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList1,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pInitializationParameters: ?*const anyopaque,
                InitializationParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList1,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pInitializationParameters: ?*const anyopaque,
                InitializationParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ExecuteExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList1,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList1,
                pExtensionCommand: ?*ID3D12VideoExtensionCommand,
                // TODO: what to do with BytesParamIndex 2?
                pExecutionParameters: ?*const anyopaque,
                ExecutionParametersSizeInBytes: usize,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoEncodeCommandList.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList1_InitializeExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pInitializationParameters: ?*const anyopaque, InitializationParametersSizeInBytes: usize) void {
                return @as(*const ID3D12VideoEncodeCommandList1.VTable, @ptrCast(self.vtable)).InitializeExtensionCommand(@as(*const ID3D12VideoEncodeCommandList1, @ptrCast(self)), pExtensionCommand, pInitializationParameters, InitializationParametersSizeInBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList1_ExecuteExtensionCommand(self: *const T, pExtensionCommand: ?*ID3D12VideoExtensionCommand, pExecutionParameters: ?*const anyopaque, ExecutionParametersSizeInBytes: usize) void {
                return @as(*const ID3D12VideoEncodeCommandList1.VTable, @ptrCast(self.vtable)).ExecuteExtensionCommand(@as(*const ID3D12VideoEncodeCommandList1, @ptrCast(self)), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = enum(i32) {
    ABSOLUTE_QP_MAP = 0,
    CQP = 1,
    CBR = 2,
    VBR = 3,
    QVBR = 4,
};
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_ABSOLUTE_QP_MAP = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE.ABSOLUTE_QP_MAP;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_CQP = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE.CQP;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_CBR = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE.CBR;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_VBR = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE.VBR;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_QVBR = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE.QVBR;

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = enum(u32) {
    NONE = 0,
    ENABLE_DELTA_QP = 1,
    ENABLE_FRAME_ANALYSIS = 2,
    ENABLE_QP_RANGE = 4,
    ENABLE_INITIAL_QP = 8,
    ENABLE_MAX_FRAME_SIZE = 16,
    ENABLE_VBV_SIZES = 32,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        ENABLE_DELTA_QP: u1 = 0,
        ENABLE_FRAME_ANALYSIS: u1 = 0,
        ENABLE_QP_RANGE: u1 = 0,
        ENABLE_INITIAL_QP: u1 = 0,
        ENABLE_MAX_FRAME_SIZE: u1 = 0,
        ENABLE_VBV_SIZES: u1 = 0,
    }) D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.NONE) else 0) | (if (o.ENABLE_DELTA_QP == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_DELTA_QP) else 0) | (if (o.ENABLE_FRAME_ANALYSIS == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_FRAME_ANALYSIS) else 0) | (if (o.ENABLE_QP_RANGE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_QP_RANGE) else 0) | (if (o.ENABLE_INITIAL_QP == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_INITIAL_QP) else 0) | (if (o.ENABLE_MAX_FRAME_SIZE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_MAX_FRAME_SIZE) else 0) | (if (o.ENABLE_VBV_SIZES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_VBV_SIZES) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_NONE = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_DELTA_QP = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_DELTA_QP;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_FRAME_ANALYSIS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_FRAME_ANALYSIS;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_QP_RANGE = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_QP_RANGE;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_INITIAL_QP = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_INITIAL_QP;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_MAX_FRAME_SIZE = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_MAX_FRAME_SIZE;
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_VBV_SIZES = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS.ENABLE_VBV_SIZES;

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP = extern struct {
    ConstantQP_FullIntracodedFrame: u32,
    ConstantQP_InterPredictedFrame_PrevRefOnly: u32,
    ConstantQP_InterPredictedFrame_BiDirectionalRef: u32,
};

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR = extern struct {
    InitialQP: u32,
    MinQP: u32,
    MaxQP: u32,
    MaxFrameBitSize: u64,
    TargetBitRate: u64,
    VBVCapacity: u64,
    InitialVBVFullness: u64,
};

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR = extern struct {
    InitialQP: u32,
    MinQP: u32,
    MaxQP: u32,
    MaxFrameBitSize: u64,
    TargetAvgBitRate: u64,
    PeakBitRate: u64,
    VBVCapacity: u64,
    InitialVBVFullness: u64,
};

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR = extern struct {
    InitialQP: u32,
    MinQP: u32,
    MaxQP: u32,
    MaxFrameBitSize: u64,
    TargetAvgBitRate: u64,
    PeakBitRate: u64,
    ConstantQualityTarget: u32,
};

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pConfiguration_CQP: ?*const D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP,
        pConfiguration_CBR: ?*const D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR,
        pConfiguration_VBR: ?*const D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR,
        pConfiguration_QVBR: ?*const D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR,
    },
};

pub const D3D12_VIDEO_ENCODER_RATE_CONTROL = extern struct {
    Mode: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE,
    Flags: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS,
    ConfigParams: D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS,
    TargetFrameRate: DXGI_RATIONAL,
};

pub const D3D12_VIDEO_ENCODER_CODEC = enum(i32) {
    @"264" = 0,
    EVC = 1,
};
pub const D3D12_VIDEO_ENCODER_CODEC_H264 = D3D12_VIDEO_ENCODER_CODEC.@"264";
pub const D3D12_VIDEO_ENCODER_CODEC_HEVC = D3D12_VIDEO_ENCODER_CODEC.EVC;

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    IsSupported: BOOL,
};

pub const D3D12_VIDEO_ENCODER_PROFILE_H264 = enum(i32) {
    MAIN = 0,
    HIGH = 1,
    HIGH_10 = 2,
};
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_MAIN = D3D12_VIDEO_ENCODER_PROFILE_H264.MAIN;
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_HIGH = D3D12_VIDEO_ENCODER_PROFILE_H264.HIGH;
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_HIGH_10 = D3D12_VIDEO_ENCODER_PROFILE_H264.HIGH_10;

pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC = enum(i32) {
    N = 0,
    @"10" = 1,
};
pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC_MAIN = D3D12_VIDEO_ENCODER_PROFILE_HEVC.N;
pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC_MAIN10 = D3D12_VIDEO_ENCODER_PROFILE_HEVC.@"10";

pub const D3D12_VIDEO_ENCODER_PROFILE_DESC = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264Profile: ?*D3D12_VIDEO_ENCODER_PROFILE_H264,
        pHEVCProfile: ?*D3D12_VIDEO_ENCODER_PROFILE_HEVC,
    },
};

pub const D3D12_VIDEO_ENCODER_LEVELS_H264 = enum(i32) {
    @"1" = 0,
    @"1b" = 1,
    @"11" = 2,
    @"12" = 3,
    @"13" = 4,
    @"2" = 5,
    @"21" = 6,
    @"22" = 7,
    @"3" = 8,
    @"31" = 9,
    @"32" = 10,
    @"4" = 11,
    @"41" = 12,
    @"42" = 13,
    @"5" = 14,
    @"51" = 15,
    @"52" = 16,
    @"6" = 17,
    @"61" = 18,
    @"62" = 19,
};
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_1 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"1";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_1b = D3D12_VIDEO_ENCODER_LEVELS_H264.@"1b";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_11 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"11";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_12 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"12";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_13 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"13";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_2 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"2";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_21 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"21";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_22 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"22";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_3 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"3";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_31 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"31";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_32 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"32";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_4 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"4";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_41 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"41";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_42 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"42";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_5 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"5";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_51 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"51";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_52 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"52";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_6 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"6";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_61 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"61";
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_62 = D3D12_VIDEO_ENCODER_LEVELS_H264.@"62";

pub const D3D12_VIDEO_ENCODER_TIER_HEVC = enum(i32) {
    MAIN = 0,
    HIGH = 1,
};
pub const D3D12_VIDEO_ENCODER_TIER_HEVC_MAIN = D3D12_VIDEO_ENCODER_TIER_HEVC.MAIN;
pub const D3D12_VIDEO_ENCODER_TIER_HEVC_HIGH = D3D12_VIDEO_ENCODER_TIER_HEVC.HIGH;

pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC = enum(i32) {
    @"1" = 0,
    @"2" = 1,
    @"21" = 2,
    @"3" = 3,
    @"31" = 4,
    @"4" = 5,
    @"41" = 6,
    @"5" = 7,
    @"51" = 8,
    @"52" = 9,
    @"6" = 10,
    @"61" = 11,
    @"62" = 12,
};
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_1 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"1";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_2 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"2";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_21 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"21";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_3 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"3";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_31 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"31";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_4 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"4";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_41 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"41";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_5 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"5";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_51 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"51";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_52 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"52";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_6 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"6";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_61 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"61";
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_62 = D3D12_VIDEO_ENCODER_LEVELS_HEVC.@"62";

pub const D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC = extern struct {
    Level: D3D12_VIDEO_ENCODER_LEVELS_HEVC,
    Tier: D3D12_VIDEO_ENCODER_TIER_HEVC,
};

pub const D3D12_VIDEO_ENCODER_LEVEL_SETTING = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264LevelSetting: ?*D3D12_VIDEO_ENCODER_LEVELS_H264,
        pHEVCLevelSetting: ?*D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC,
    },
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    IsSupported: BOOL,
    MinSupportedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    MaxSupportedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC = extern struct {
    Width: u32,
    Height: u32,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC = extern struct {
    WidthRatio: u32,
    HeightRatio: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    ResolutionRatiosCount: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    ResolutionRatiosCount: u32,
    IsSupported: BOOL,
    MinResolutionSupported: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    MaxResolutionSupported: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    ResolutionWidthMultipleRequirement: u32,
    ResolutionHeightMultipleRequirement: u32,
    pResolutionRatios: ?*D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC,
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    Format: DXGI_FORMAT,
    IsSupported: BOOL,
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    RateControlMode: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE,
    IsSupported: BOOL,
};

pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE = enum(i32) {
    NONE = 0,
    ROW_BASED = 1,
};
pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE_NONE = D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE.NONE;
pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE_ROW_BASED = D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE.ROW_BASED;

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    IntraRefreshMode: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    IsSupported: BOOL,
};

pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = enum(i32) {
    FULL_FRAME = 0,
    BYTES_PER_SUBREGION = 1,
    SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED = 2,
    UNIFORM_PARTITIONING_ROWS_PER_SUBREGION = 3,
    UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME = 4,
};
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_FULL_FRAME = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE.FULL_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_BYTES_PER_SUBREGION = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE.BYTES_PER_SUBREGION;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE.SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_ROWS_PER_SUBREGION = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE.UNIFORM_PARTITIONING_ROWS_PER_SUBREGION;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE.UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME;

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    SubregionMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    IsSupported: BOOL,
};

pub const D3D12_VIDEO_ENCODER_HEAP_FLAGS = enum(u32) {
    E = 0,
    _,
    pub fn initFlags(o: struct {
        E: u1 = 0,
    }) D3D12_VIDEO_ENCODER_HEAP_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_HEAP_FLAGS, @enumFromInt((if (o.E == 1) @intFromEnum(D3D12_VIDEO_ENCODER_HEAP_FLAGS.E) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_HEAP_FLAG_NONE = D3D12_VIDEO_ENCODER_HEAP_FLAGS.E;

pub const D3D12_VIDEO_ENCODER_HEAP_DESC = extern struct {
    NodeMask: u32,
    Flags: D3D12_VIDEO_ENCODER_HEAP_FLAGS,
    EncodeCodec: D3D12_VIDEO_ENCODER_CODEC,
    EncodeProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    EncodeLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    ResolutionsListCount: u32,
    pResolutionList: ?*const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE = extern struct {
    HeapDesc: D3D12_VIDEO_ENCODER_HEAP_DESC,
    IsSupported: BOOL,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = enum(u32) {
    NONE = 0,
    CABAC_ENCODING_SUPPORT = 1,
    INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT = 2,
    BFRAME_LTR_COMBINED_SUPPORT = 4,
    ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT = 8,
    DIRECT_SPATIAL_ENCODING_SUPPORT = 16,
    DIRECT_TEMPORAL_ENCODING_SUPPORT = 32,
    CONSTRAINED_INTRAPREDICTION_SUPPORT = 64,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CABAC_ENCODING_SUPPORT: u1 = 0,
        INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT: u1 = 0,
        BFRAME_LTR_COMBINED_SUPPORT: u1 = 0,
        ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT: u1 = 0,
        DIRECT_SPATIAL_ENCODING_SUPPORT: u1 = 0,
        DIRECT_TEMPORAL_ENCODING_SUPPORT: u1 = 0,
        CONSTRAINED_INTRAPREDICTION_SUPPORT: u1 = 0,
    }) D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.NONE) else 0) | (if (o.CABAC_ENCODING_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.CABAC_ENCODING_SUPPORT) else 0) | (if (o.INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT) else 0) | (if (o.BFRAME_LTR_COMBINED_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.BFRAME_LTR_COMBINED_SUPPORT) else 0) | (if (o.ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT) else 0) | (if (o.DIRECT_SPATIAL_ENCODING_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.DIRECT_SPATIAL_ENCODING_SUPPORT) else 0) | (if (o.DIRECT_TEMPORAL_ENCODING_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.DIRECT_TEMPORAL_ENCODING_SUPPORT) else 0) | (if (o.CONSTRAINED_INTRAPREDICTION_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.CONSTRAINED_INTRAPREDICTION_SUPPORT) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_NONE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_CABAC_ENCODING_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.CABAC_ENCODING_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_BFRAME_LTR_COMBINED_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.BFRAME_LTR_COMBINED_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_DIRECT_SPATIAL_ENCODING_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.DIRECT_SPATIAL_ENCODING_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_DIRECT_TEMPORAL_ENCODING_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.DIRECT_TEMPORAL_ENCODING_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_CONSTRAINED_INTRAPREDICTION_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS.CONSTRAINED_INTRAPREDICTION_SUPPORT;

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = enum(i32) {
    @"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED" = 0,
    @"1_DISABLE_ALL_SLICE_BLOCK_EDGES" = 1,
    @"2_DISABLE_SLICE_BOUNDARIES_BLOCKS" = 2,
    @"3_USE_TWO_STAGE_DEBLOCKING" = 3,
    @"4_DISABLE_CHROMA_BLOCK_EDGES" = 4,
    @"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES" = 5,
    @"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING" = 6,
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_1_DISABLE_ALL_SLICE_BLOCK_EDGES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"1_DISABLE_ALL_SLICE_BLOCK_EDGES";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_2_DISABLE_SLICE_BOUNDARIES_BLOCKS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"2_DISABLE_SLICE_BOUNDARIES_BLOCKS";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_3_USE_TWO_STAGE_DEBLOCKING = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"3_USE_TWO_STAGE_DEBLOCKING";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_4_DISABLE_CHROMA_BLOCK_EDGES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"4_DISABLE_CHROMA_BLOCK_EDGES";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES.@"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING";

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = enum(u32) {
    NONE = 0,
    @"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED" = 1,
    @"1_DISABLE_ALL_SLICE_BLOCK_EDGES" = 2,
    @"2_DISABLE_SLICE_BOUNDARIES_BLOCKS" = 4,
    @"3_USE_TWO_STAGE_DEBLOCKING" = 8,
    @"4_DISABLE_CHROMA_BLOCK_EDGES" = 16,
    @"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES" = 32,
    @"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING" = 64,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        @"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED": u1 = 0,
        @"1_DISABLE_ALL_SLICE_BLOCK_EDGES": u1 = 0,
        @"2_DISABLE_SLICE_BOUNDARIES_BLOCKS": u1 = 0,
        @"3_USE_TWO_STAGE_DEBLOCKING": u1 = 0,
        @"4_DISABLE_CHROMA_BLOCK_EDGES": u1 = 0,
        @"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES": u1 = 0,
        @"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING": u1 = 0,
    }) D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.NONE) else 0) | (if (o.@"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED") else 0) | (if (o.@"1_DISABLE_ALL_SLICE_BLOCK_EDGES" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"1_DISABLE_ALL_SLICE_BLOCK_EDGES") else 0) | (if (o.@"2_DISABLE_SLICE_BOUNDARIES_BLOCKS" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"2_DISABLE_SLICE_BOUNDARIES_BLOCKS") else 0) | (if (o.@"3_USE_TWO_STAGE_DEBLOCKING" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"3_USE_TWO_STAGE_DEBLOCKING") else 0) | (if (o.@"4_DISABLE_CHROMA_BLOCK_EDGES" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"4_DISABLE_CHROMA_BLOCK_EDGES") else 0) | (if (o.@"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES") else 0) | (if (o.@"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING" == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING") else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_NONE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_1_DISABLE_ALL_SLICE_BLOCK_EDGES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"1_DISABLE_ALL_SLICE_BLOCK_EDGES";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_2_DISABLE_SLICE_BOUNDARIES_BLOCKS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"2_DISABLE_SLICE_BOUNDARIES_BLOCKS";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_3_USE_TWO_STAGE_DEBLOCKING = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"3_USE_TWO_STAGE_DEBLOCKING";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_4_DISABLE_CHROMA_BLOCK_EDGES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"4_DISABLE_CHROMA_BLOCK_EDGES";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS.@"6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING";

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 = extern struct {
    SupportFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS,
    DisableDeblockingFilterSupportedModes: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS,
};

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = enum(u32) {
    NONE = 0,
    BFRAME_LTR_COMBINED_SUPPORT = 1,
    INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT = 2,
    CONSTRAINED_INTRAPREDICTION_SUPPORT = 4,
    SAO_FILTER_SUPPORT = 8,
    ASYMETRIC_MOTION_PARTITION_SUPPORT = 16,
    ASYMETRIC_MOTION_PARTITION_REQUIRED = 32,
    TRANSFORM_SKIP_SUPPORT = 64,
    DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT = 128,
    P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES = 256,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        BFRAME_LTR_COMBINED_SUPPORT: u1 = 0,
        INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT: u1 = 0,
        CONSTRAINED_INTRAPREDICTION_SUPPORT: u1 = 0,
        SAO_FILTER_SUPPORT: u1 = 0,
        ASYMETRIC_MOTION_PARTITION_SUPPORT: u1 = 0,
        ASYMETRIC_MOTION_PARTITION_REQUIRED: u1 = 0,
        TRANSFORM_SKIP_SUPPORT: u1 = 0,
        DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT: u1 = 0,
        P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES: u1 = 0,
    }) D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.NONE) else 0) | (if (o.BFRAME_LTR_COMBINED_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.BFRAME_LTR_COMBINED_SUPPORT) else 0) | (if (o.INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT) else 0) | (if (o.CONSTRAINED_INTRAPREDICTION_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.CONSTRAINED_INTRAPREDICTION_SUPPORT) else 0) | (if (o.SAO_FILTER_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.SAO_FILTER_SUPPORT) else 0) | (if (o.ASYMETRIC_MOTION_PARTITION_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.ASYMETRIC_MOTION_PARTITION_SUPPORT) else 0) | (if (o.ASYMETRIC_MOTION_PARTITION_REQUIRED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.ASYMETRIC_MOTION_PARTITION_REQUIRED) else 0) | (if (o.TRANSFORM_SKIP_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.TRANSFORM_SKIP_SUPPORT) else 0) | (if (o.DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT) else 0) | (if (o.P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_NONE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_BFRAME_LTR_COMBINED_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.BFRAME_LTR_COMBINED_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_CONSTRAINED_INTRAPREDICTION_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.CONSTRAINED_INTRAPREDICTION_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_SAO_FILTER_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.SAO_FILTER_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_ASYMETRIC_MOTION_PARTITION_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.ASYMETRIC_MOTION_PARTITION_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_ASYMETRIC_MOTION_PARTITION_REQUIRED = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.ASYMETRIC_MOTION_PARTITION_REQUIRED;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_TRANSFORM_SKIP_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.TRANSFORM_SKIP_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS.P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES;

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE = enum(i32) {
    @"8x8" = 0,
    @"16x16" = 1,
    @"32x32" = 2,
    @"64x64" = 3,
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_8x8 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE.@"8x8";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_16x16 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE.@"16x16";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_32x32 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE.@"32x32";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_64x64 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE.@"64x64";

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE = enum(i32) {
    @"4x4" = 0,
    @"8x8" = 1,
    @"16x16" = 2,
    @"32x32" = 3,
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_4x4 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE.@"4x4";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_8x8 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE.@"8x8";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_16x16 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE.@"16x16";
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_32x32 = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE.@"32x32";

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC = extern struct {
    SupportFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS,
    MinLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    MaxLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    MinLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    MaxLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    max_transform_hierarchy_depth_inter: u8,
    max_transform_hierarchy_depth_intra: u8,
};

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264Support: ?*D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264,
        pHEVCSupport: ?*D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC,
    },
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    IsSupported: BOOL,
    CodecSupportLimits: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT,
};

pub const D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 = extern struct {
    MaxL0ReferencesForP: u32,
    MaxL0ReferencesForB: u32,
    MaxL1ReferencesForB: u32,
    MaxLongTermReferences: u32,
    MaxDPBCapacity: u32,
};

pub const D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC = extern struct {
    MaxL0ReferencesForP: u32,
    MaxL0ReferencesForB: u32,
    MaxL1ReferencesForB: u32,
    MaxLongTermReferences: u32,
    MaxDPBCapacity: u32,
};

pub const D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264Support: ?*D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264,
        pHEVCSupport: ?*D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC,
    },
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    IsSupported: BOOL,
    PictureSupport: D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT,
};

pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = enum(u32) {
    NONE = 0,
    GENERAL_SUPPORT_OK = 1,
    RATE_CONTROL_RECONFIGURATION_AVAILABLE = 2,
    RESOLUTION_RECONFIGURATION_AVAILABLE = 4,
    RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE = 8,
    RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE = 16,
    RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS = 32,
    RATE_CONTROL_DELTA_QP_AVAILABLE = 64,
    SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE = 128,
    RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE = 256,
    RATE_CONTROL_INITIAL_QP_AVAILABLE = 512,
    RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE = 1024,
    SEQUENCE_GOP_RECONFIGURATION_AVAILABLE = 2048,
    MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE = 4096,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        GENERAL_SUPPORT_OK: u1 = 0,
        RATE_CONTROL_RECONFIGURATION_AVAILABLE: u1 = 0,
        RESOLUTION_RECONFIGURATION_AVAILABLE: u1 = 0,
        RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE: u1 = 0,
        RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE: u1 = 0,
        RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS: u1 = 0,
        RATE_CONTROL_DELTA_QP_AVAILABLE: u1 = 0,
        SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE: u1 = 0,
        RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE: u1 = 0,
        RATE_CONTROL_INITIAL_QP_AVAILABLE: u1 = 0,
        RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE: u1 = 0,
        SEQUENCE_GOP_RECONFIGURATION_AVAILABLE: u1 = 0,
        MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE: u1 = 0,
    }) D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.NONE) else 0) | (if (o.GENERAL_SUPPORT_OK == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.GENERAL_SUPPORT_OK) else 0) | (if (o.RATE_CONTROL_RECONFIGURATION_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_RECONFIGURATION_AVAILABLE) else 0) | (if (o.RESOLUTION_RECONFIGURATION_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RESOLUTION_RECONFIGURATION_AVAILABLE) else 0) | (if (o.RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE) else 0) | (if (o.RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE) else 0) | (if (o.RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS) else 0) | (if (o.RATE_CONTROL_DELTA_QP_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_DELTA_QP_AVAILABLE) else 0) | (if (o.SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE) else 0) | (if (o.RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE) else 0) | (if (o.RATE_CONTROL_INITIAL_QP_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_INITIAL_QP_AVAILABLE) else 0) | (if (o.RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE) else 0) | (if (o.SEQUENCE_GOP_RECONFIGURATION_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.SEQUENCE_GOP_RECONFIGURATION_AVAILABLE) else 0) | (if (o.MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_NONE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_GENERAL_SUPPORT_OK = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.GENERAL_SUPPORT_OK;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_RECONFIGURATION_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_RECONFIGURATION_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RESOLUTION_RECONFIGURATION_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RESOLUTION_RECONFIGURATION_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_DELTA_QP_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_DELTA_QP_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_INITIAL_QP_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_INITIAL_QP_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_SEQUENCE_GOP_RECONFIGURATION_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.SEQUENCE_GOP_RECONFIGURATION_AVAILABLE;
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS.MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE;

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = enum(u32) {
    NONE = 0,
    USE_CONSTRAINED_INTRAPREDICTION = 1,
    USE_ADAPTIVE_8x8_TRANSFORM = 2,
    ENABLE_CABAC_ENCODING = 4,
    ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES = 8,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        USE_CONSTRAINED_INTRAPREDICTION: u1 = 0,
        USE_ADAPTIVE_8x8_TRANSFORM: u1 = 0,
        ENABLE_CABAC_ENCODING: u1 = 0,
        ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES: u1 = 0,
    }) D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.NONE) else 0) | (if (o.USE_CONSTRAINED_INTRAPREDICTION == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.USE_CONSTRAINED_INTRAPREDICTION) else 0) | (if (o.USE_ADAPTIVE_8x8_TRANSFORM == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.USE_ADAPTIVE_8x8_TRANSFORM) else 0) | (if (o.ENABLE_CABAC_ENCODING == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.ENABLE_CABAC_ENCODING) else 0) | (if (o.ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_NONE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_USE_CONSTRAINED_INTRAPREDICTION = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.USE_CONSTRAINED_INTRAPREDICTION;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_USE_ADAPTIVE_8x8_TRANSFORM = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.USE_ADAPTIVE_8x8_TRANSFORM;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_ENABLE_CABAC_ENCODING = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.ENABLE_CABAC_ENCODING;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS.ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES;

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES = enum(i32) {
    DISABLED = 0,
    TEMPORAL = 1,
    SPATIAL = 2,
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_DISABLED = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES.DISABLED;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_TEMPORAL = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES.TEMPORAL;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_SPATIAL = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES.SPATIAL;

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 = extern struct {
    ConfigurationFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS,
    DirectModeConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES,
    DisableDeblockingFilterConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES,
};

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = enum(u32) {
    NONE = 0,
    DISABLE_LOOP_FILTER_ACROSS_SLICES = 1,
    ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES = 2,
    ENABLE_SAO_FILTER = 4,
    ENABLE_LONG_TERM_REFERENCES = 8,
    USE_ASYMETRIC_MOTION_PARTITION = 16,
    ENABLE_TRANSFORM_SKIPPING = 32,
    USE_CONSTRAINED_INTRAPREDICTION = 64,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        DISABLE_LOOP_FILTER_ACROSS_SLICES: u1 = 0,
        ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES: u1 = 0,
        ENABLE_SAO_FILTER: u1 = 0,
        ENABLE_LONG_TERM_REFERENCES: u1 = 0,
        USE_ASYMETRIC_MOTION_PARTITION: u1 = 0,
        ENABLE_TRANSFORM_SKIPPING: u1 = 0,
        USE_CONSTRAINED_INTRAPREDICTION: u1 = 0,
    }) D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.NONE) else 0) | (if (o.DISABLE_LOOP_FILTER_ACROSS_SLICES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.DISABLE_LOOP_FILTER_ACROSS_SLICES) else 0) | (if (o.ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES) else 0) | (if (o.ENABLE_SAO_FILTER == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ENABLE_SAO_FILTER) else 0) | (if (o.ENABLE_LONG_TERM_REFERENCES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ENABLE_LONG_TERM_REFERENCES) else 0) | (if (o.USE_ASYMETRIC_MOTION_PARTITION == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.USE_ASYMETRIC_MOTION_PARTITION) else 0) | (if (o.ENABLE_TRANSFORM_SKIPPING == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ENABLE_TRANSFORM_SKIPPING) else 0) | (if (o.USE_CONSTRAINED_INTRAPREDICTION == 1) @intFromEnum(D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.USE_CONSTRAINED_INTRAPREDICTION) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_NONE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_DISABLE_LOOP_FILTER_ACROSS_SLICES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.DISABLE_LOOP_FILTER_ACROSS_SLICES;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_SAO_FILTER = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ENABLE_SAO_FILTER;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_LONG_TERM_REFERENCES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ENABLE_LONG_TERM_REFERENCES;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_USE_ASYMETRIC_MOTION_PARTITION = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.USE_ASYMETRIC_MOTION_PARTITION;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_TRANSFORM_SKIPPING = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.ENABLE_TRANSFORM_SKIPPING;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_USE_CONSTRAINED_INTRAPREDICTION = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS.USE_CONSTRAINED_INTRAPREDICTION;

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC = extern struct {
    ConfigurationFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS,
    MinLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    MaxLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    MinLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    MaxLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    max_transform_hierarchy_depth_inter: u8,
    max_transform_hierarchy_depth_intra: u8,
};

pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264Config: ?*D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264,
        pHEVCConfig: ?*D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC,
    },
};

pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH = extern struct {
    Mode: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    IntraRefreshDuration: u32,
};

pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE = enum(i32) {
    MAXIMUM = 0,
    FULL_PIXEL = 1,
    HALF_PIXEL = 2,
    QUARTER_PIXEL = 3,
};
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_MAXIMUM = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE.MAXIMUM;
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_FULL_PIXEL = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE.FULL_PIXEL;
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_HALF_PIXEL = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE.HALF_PIXEL;
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_QUARTER_PIXEL = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE.QUARTER_PIXEL;

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS = extern struct {
    MaxSubregionsNumber: u32,
    MaxIntraRefreshFrameDuration: u32,
    SubregionBlockPixelsSize: u32,
    QPMapRegionPixelsSize: u32,
};

pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = enum(u32) {
    NONE = 0,
    CODEC_NOT_SUPPORTED = 1,
    INPUT_FORMAT_NOT_SUPPORTED = 8,
    CODEC_CONFIGURATION_NOT_SUPPORTED = 16,
    RATE_CONTROL_MODE_NOT_SUPPORTED = 32,
    RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED = 64,
    INTRA_REFRESH_MODE_NOT_SUPPORTED = 128,
    SUBREGION_LAYOUT_MODE_NOT_SUPPORTED = 256,
    RESOLUTION_NOT_SUPPORTED_IN_LIST = 512,
    GOP_STRUCTURE_NOT_SUPPORTED = 2048,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CODEC_NOT_SUPPORTED: u1 = 0,
        INPUT_FORMAT_NOT_SUPPORTED: u1 = 0,
        CODEC_CONFIGURATION_NOT_SUPPORTED: u1 = 0,
        RATE_CONTROL_MODE_NOT_SUPPORTED: u1 = 0,
        RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED: u1 = 0,
        INTRA_REFRESH_MODE_NOT_SUPPORTED: u1 = 0,
        SUBREGION_LAYOUT_MODE_NOT_SUPPORTED: u1 = 0,
        RESOLUTION_NOT_SUPPORTED_IN_LIST: u1 = 0,
        GOP_STRUCTURE_NOT_SUPPORTED: u1 = 0,
    }) D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.NONE) else 0) | (if (o.CODEC_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.CODEC_NOT_SUPPORTED) else 0) | (if (o.INPUT_FORMAT_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.INPUT_FORMAT_NOT_SUPPORTED) else 0) | (if (o.CODEC_CONFIGURATION_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.CODEC_CONFIGURATION_NOT_SUPPORTED) else 0) | (if (o.RATE_CONTROL_MODE_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.RATE_CONTROL_MODE_NOT_SUPPORTED) else 0) | (if (o.RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED) else 0) | (if (o.INTRA_REFRESH_MODE_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.INTRA_REFRESH_MODE_NOT_SUPPORTED) else 0) | (if (o.SUBREGION_LAYOUT_MODE_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.SUBREGION_LAYOUT_MODE_NOT_SUPPORTED) else 0) | (if (o.RESOLUTION_NOT_SUPPORTED_IN_LIST == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.RESOLUTION_NOT_SUPPORTED_IN_LIST) else 0) | (if (o.GOP_STRUCTURE_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.GOP_STRUCTURE_NOT_SUPPORTED) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_NONE = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_CODEC_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.CODEC_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_INPUT_FORMAT_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.INPUT_FORMAT_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_CODEC_CONFIGURATION_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.CODEC_CONFIGURATION_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RATE_CONTROL_MODE_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.RATE_CONTROL_MODE_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_INTRA_REFRESH_MODE_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.INTRA_REFRESH_MODE_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_SUBREGION_LAYOUT_MODE_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.SUBREGION_LAYOUT_MODE_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RESOLUTION_NOT_SUPPORTED_IN_LIST = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.RESOLUTION_NOT_SUPPORTED_IN_LIST;
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_GOP_STRUCTURE_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS.GOP_STRUCTURE_NOT_SUPPORTED;

pub const D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 = extern struct {
    GOPLength: u32,
    PPicturePeriod: u32,
    pic_order_cnt_type: u8,
    log2_max_frame_num_minus4: u8,
    log2_max_pic_order_cnt_lsb_minus4: u8,
};

pub const D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC = extern struct {
    GOPLength: u32,
    PPicturePeriod: u32,
    log2_max_pic_order_cnt_lsb_minus4: u8,
};

pub const D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264GroupOfPictures: ?*D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264,
        pHEVCGroupOfPictures: ?*D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC,
    },
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    InputFormat: DXGI_FORMAT,
    CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
    RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    IntraRefresh: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    SubregionFrameEncoding: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    ResolutionsListCount: u32,
    pResolutionList: ?*const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    MaxReferenceFramesInDPB: u32,
    ValidationFlags: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS,
    SupportFlags: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS,
    SuggestedProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    SuggestedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pResolutionDependentSupport: ?*D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS,
};

pub const D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS = extern struct {
    NodeIndex: u32,
    Codec: D3D12_VIDEO_ENCODER_CODEC,
    Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    InputFormat: DXGI_FORMAT,
    PictureTargetResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    IsSupported: BOOL,
    CompressedBitstreamBufferAccessAlignment: u32,
    EncoderMetadataBufferAccessAlignment: u32,
    MaxEncoderOutputMetadataBufferSize: u32,
};

pub const D3D12_VIDEO_ENCODER_FLAGS = enum(u32) {
    E = 0,
    _,
    pub fn initFlags(o: struct {
        E: u1 = 0,
    }) D3D12_VIDEO_ENCODER_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_FLAGS, @enumFromInt((if (o.E == 1) @intFromEnum(D3D12_VIDEO_ENCODER_FLAGS.E) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_FLAG_NONE = D3D12_VIDEO_ENCODER_FLAGS.E;

pub const D3D12_VIDEO_ENCODER_DESC = extern struct {
    NodeMask: u32,
    Flags: D3D12_VIDEO_ENCODER_FLAGS,
    EncodeCodec: D3D12_VIDEO_ENCODER_CODEC,
    EncodeProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    InputFormat: DXGI_FORMAT,
    CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    MaxMotionEstimationPrecision: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
};

const IID_ID3D12VideoEncoder_Value = Guid.initString("2e0d212d-8df9-44a6-a770-bb289b182737");
pub const IID_ID3D12VideoEncoder = &IID_ID3D12VideoEncoder_Value;
pub const ID3D12VideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetNodeMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetEncoderFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_FLAGS,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_FLAGS,
        },
        GetCodec: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_CODEC,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_CODEC,
        },
        GetCodecProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
                dstProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
                dstProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
                dstCodecConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
                dstCodecConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) DXGI_FORMAT,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) DXGI_FORMAT,
        },
        GetMaxMotionEstimationPrecision: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
            else => *const fn (
                self: *const ID3D12VideoEncoder,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetNodeMask(self: *const T) u32 {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetNodeMask(@as(*const ID3D12VideoEncoder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetEncoderFlags(self: *const T) D3D12_VIDEO_ENCODER_FLAGS {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetEncoderFlags(@as(*const ID3D12VideoEncoder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetCodec(self: *const T) D3D12_VIDEO_ENCODER_CODEC {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetCodec(@as(*const ID3D12VideoEncoder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetCodecProfile(self: *const T, dstProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC) HRESULT {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetCodecProfile(@as(*const ID3D12VideoEncoder, @ptrCast(self)), dstProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetCodecConfiguration(self: *const T, dstCodecConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) HRESULT {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetCodecConfiguration(@as(*const ID3D12VideoEncoder, @ptrCast(self)), dstCodecConfig);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetInputFormat(self: *const T) DXGI_FORMAT {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetInputFormat(@as(*const ID3D12VideoEncoder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoder_GetMaxMotionEstimationPrecision(self: *const T) D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
                return @as(*const ID3D12VideoEncoder.VTable, @ptrCast(self.vtable)).GetMaxMotionEstimationPrecision(@as(*const ID3D12VideoEncoder, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoEncoderHeap_Value = Guid.initString("22b35d96-876a-44c0-b25e-fb8c9c7f1c4a");
pub const IID_ID3D12VideoEncoderHeap = &IID_ID3D12VideoEncoderHeap_Value;
pub const ID3D12VideoEncoderHeap = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetNodeMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetEncoderHeapFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_HEAP_FLAGS,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_HEAP_FLAGS,
        },
        GetCodec: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_CODEC,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_ENCODER_CODEC,
        },
        GetCodecProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
                dstProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
                dstProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
                dstLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
                dstLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResolutionListCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetResolutionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncoderHeap,
                ResolutionsListCount: u32,
                pResolutionList: [*]D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoEncoderHeap,
                ResolutionsListCount: u32,
                pResolutionList: [*]D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12Pageable.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetNodeMask(self: *const T) u32 {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetNodeMask(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetEncoderHeapFlags(self: *const T) D3D12_VIDEO_ENCODER_HEAP_FLAGS {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetEncoderHeapFlags(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetCodec(self: *const T) D3D12_VIDEO_ENCODER_CODEC {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetCodec(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetCodecProfile(self: *const T, dstProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC) HRESULT {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetCodecProfile(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)), dstProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetCodecLevel(self: *const T, dstLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) HRESULT {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetCodecLevel(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)), dstLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetResolutionListCount(self: *const T) u32 {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetResolutionListCount(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncoderHeap_GetResolutionList(self: *const T, ResolutionsListCount: u32, pResolutionList: [*]D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) HRESULT {
                return @as(*const ID3D12VideoEncoderHeap.VTable, @ptrCast(self.vtable)).GetResolutionList(@as(*const ID3D12VideoEncoderHeap, @ptrCast(self)), ResolutionsListCount, pResolutionList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice3_Value = Guid.initString("4243adb4-3a32-4666-973c-0ccc5625dc44");
pub const IID_ID3D12VideoDevice3 = &IID_ID3D12VideoDevice3_Value;
pub const ID3D12VideoDevice3 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDevice2.VTable,
        CreateVideoEncoder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice3,
                pDesc: ?*const D3D12_VIDEO_ENCODER_DESC,
                riid: ?*const Guid,
                ppVideoEncoder: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice3,
                pDesc: ?*const D3D12_VIDEO_ENCODER_DESC,
                riid: ?*const Guid,
                ppVideoEncoder: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoEncoderHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoDevice3,
                pDesc: ?*const D3D12_VIDEO_ENCODER_HEAP_DESC,
                riid: ?*const Guid,
                ppVideoEncoderHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ID3D12VideoDevice3,
                pDesc: ?*const D3D12_VIDEO_ENCODER_HEAP_DESC,
                riid: ?*const Guid,
                ppVideoEncoderHeap: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoDevice2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice3_CreateVideoEncoder(self: *const T, pDesc: ?*const D3D12_VIDEO_ENCODER_DESC, riid: ?*const Guid, ppVideoEncoder: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice3.VTable, @ptrCast(self.vtable)).CreateVideoEncoder(@as(*const ID3D12VideoDevice3, @ptrCast(self)), pDesc, riid, ppVideoEncoder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoDevice3_CreateVideoEncoderHeap(self: *const T, pDesc: ?*const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: ?*const Guid, ppVideoEncoderHeap: ?*?*anyopaque) HRESULT {
                return @as(*const ID3D12VideoDevice3.VTable, @ptrCast(self.vtable)).CreateVideoEncoderHeap(@as(*const ID3D12VideoDevice3, @ptrCast(self)), pDesc, riid, ppVideoEncoderHeap);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 = enum(i32) {
    I_FRAME = 0,
    P_FRAME = 1,
    B_FRAME = 2,
    IDR_FRAME = 3,
};
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_I_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264.I_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_P_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264.P_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_B_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264.B_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_IDR_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264.IDR_FRAME;

pub const D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 = extern struct {
    ReconstructedPictureResourceIndex: u32,
    IsLongTermReference: BOOL,
    LongTermPictureIdx: u32,
    PictureOrderCountNumber: u32,
    FrameDecodingOrderNumber: u32,
    TemporalLayerIndex: u32,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS = enum(u32) {
    NONE = 0,
    REQUEST_INTRA_CONSTRAINED_SLICES = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REQUEST_INTRA_CONSTRAINED_SLICES: u1 = 0,
    }) D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS.NONE) else 0) | (if (o.REQUEST_INTRA_CONSTRAINED_SLICES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS.REQUEST_INTRA_CONSTRAINED_SLICES) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAG_NONE = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAG_REQUEST_INTRA_CONSTRAINED_SLICES = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS.REQUEST_INTRA_CONSTRAINED_SLICES;

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION = extern struct {
    memory_management_control_operation: u8,
    difference_of_pic_nums_minus1: u32,
    long_term_pic_num: u32,
    long_term_frame_idx: u32,
    max_long_term_frame_idx_plus1: u32,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION = extern struct {
    modification_of_pic_nums_idc: u8,
    abs_diff_pic_num_minus1: u32,
    long_term_pic_num: u32,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 = extern struct {
    Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS,
    FrameType: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264,
    pic_parameter_set_id: u32,
    idr_pic_id: u32,
    PictureOrderCountNumber: u32,
    FrameDecodingOrderNumber: u32,
    TemporalLayerIndex: u32,
    List0ReferenceFramesCount: u32,
    pList0ReferenceFrames: ?*u32,
    List1ReferenceFramesCount: u32,
    pList1ReferenceFrames: ?*u32,
    ReferenceFramesReconPictureDescriptorsCount: u32,
    pReferenceFramesReconPictureDescriptors: ?*D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264,
    adaptive_ref_pic_marking_mode_flag: u8,
    RefPicMarkingOperationsCommandsCount: u32,
    pRefPicMarkingOperationsCommands: ?*D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION,
    List0RefPicModificationsCount: u32,
    pList0RefPicModifications: ?*D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION,
    List1RefPicModificationsCount: u32,
    pList1RefPicModifications: ?*D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION,
    QPMapValuesCount: u32,
    pRateControlQPMap: ?*i8,
};

pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC = enum(i32) {
    I_FRAME = 0,
    P_FRAME = 1,
    B_FRAME = 2,
    IDR_FRAME = 3,
};
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_I_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC.I_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_P_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC.P_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_B_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC.B_FRAME;
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_IDR_FRAME = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC.IDR_FRAME;

pub const D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC = extern struct {
    ReconstructedPictureResourceIndex: u32,
    IsRefUsedByCurrentPic: BOOL,
    IsLongTermReference: BOOL,
    PictureOrderCountNumber: u32,
    TemporalLayerIndex: u32,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS = enum(u32) {
    NONE = 0,
    REQUEST_INTRA_CONSTRAINED_SLICES = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REQUEST_INTRA_CONSTRAINED_SLICES: u1 = 0,
    }) D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS.NONE) else 0) | (if (o.REQUEST_INTRA_CONSTRAINED_SLICES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS.REQUEST_INTRA_CONSTRAINED_SLICES) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAG_NONE = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAG_REQUEST_INTRA_CONSTRAINED_SLICES = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS.REQUEST_INTRA_CONSTRAINED_SLICES;

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC = extern struct {
    Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS,
    FrameType: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC,
    slice_pic_parameter_set_id: u32,
    PictureOrderCountNumber: u32,
    TemporalLayerIndex: u32,
    List0ReferenceFramesCount: u32,
    pList0ReferenceFrames: ?*u32,
    List1ReferenceFramesCount: u32,
    pList1ReferenceFrames: ?*u32,
    ReferenceFramesReconPictureDescriptorsCount: u32,
    pReferenceFramesReconPictureDescriptors: ?*D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC,
    List0RefPicModificationsCount: u32,
    pList0RefPicModifications: ?*u32,
    List1RefPicModificationsCount: u32,
    pList1RefPicModifications: ?*u32,
    QPMapValuesCount: u32,
    pRateControlQPMap: ?*i8,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pH264PicData: ?*D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264,
        pHEVCPicData: ?*D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC,
    },
};

pub const D3D12_VIDEO_ENCODE_REFERENCE_FRAMES = extern struct {
    NumTexture2Ds: u32,
    ppTexture2Ds: ?*?*ID3D12Resource,
    pSubresources: ?*u32,
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS = enum(u32) {
    NONE = 0,
    USED_AS_REFERENCE_PICTURE = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        USED_AS_REFERENCE_PICTURE: u1 = 0,
    }) D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS.NONE) else 0) | (if (o.USED_AS_REFERENCE_PICTURE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS.USED_AS_REFERENCE_PICTURE) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAG_NONE = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAG_USED_AS_REFERENCE_PICTURE = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS.USED_AS_REFERENCE_PICTURE;

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC = extern struct {
    IntraRefreshFrameIndex: u32,
    Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS,
    PictureControlCodecData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA,
    ReferenceFrames: D3D12_VIDEO_ENCODE_REFERENCE_FRAMES,
};

pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = enum(u32) {
    NONE = 0,
    RESOLUTION_CHANGE = 1,
    RATE_CONTROL_CHANGE = 2,
    SUBREGION_LAYOUT_CHANGE = 4,
    REQUEST_INTRA_REFRESH = 8,
    GOP_SEQUENCE_CHANGE = 16,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        RESOLUTION_CHANGE: u1 = 0,
        RATE_CONTROL_CHANGE: u1 = 0,
        SUBREGION_LAYOUT_CHANGE: u1 = 0,
        REQUEST_INTRA_REFRESH: u1 = 0,
        GOP_SEQUENCE_CHANGE: u1 = 0,
    }) D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.NONE) else 0) | (if (o.RESOLUTION_CHANGE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.RESOLUTION_CHANGE) else 0) | (if (o.RATE_CONTROL_CHANGE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.RATE_CONTROL_CHANGE) else 0) | (if (o.SUBREGION_LAYOUT_CHANGE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.SUBREGION_LAYOUT_CHANGE) else 0) | (if (o.REQUEST_INTRA_REFRESH == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.REQUEST_INTRA_REFRESH) else 0) | (if (o.GOP_SEQUENCE_CHANGE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.GOP_SEQUENCE_CHANGE) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_NONE = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.NONE;
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_RESOLUTION_CHANGE = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.RESOLUTION_CHANGE;
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_RATE_CONTROL_CHANGE = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.RATE_CONTROL_CHANGE;
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_SUBREGION_LAYOUT_CHANGE = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.SUBREGION_LAYOUT_CHANGE;
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_REQUEST_INTRA_REFRESH = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.REQUEST_INTRA_REFRESH;
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_GOP_SEQUENCE_CHANGE = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS.GOP_SEQUENCE_CHANGE;

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES = extern struct {
    Anonymous: extern union {
        MaxBytesPerSlice: u32,
        NumberOfCodingUnitsPerSlice: u32,
        NumberOfRowsPerSlice: u32,
        NumberOfSlicesPerFrame: u32,
    },
};

pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA = extern struct {
    DataSize: u32,
    Anonymous: extern union {
        pSlicesPartition_H264: ?*const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES,
        pSlicesPartition_HEVC: ?*const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES,
    },
};

pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC = extern struct {
    Flags: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS,
    IntraRefreshConfig: D3D12_VIDEO_ENCODER_INTRA_REFRESH,
    RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    PictureTargetResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    SelectedLayoutMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    FrameSubregionsLayoutData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA,
    CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
};

pub const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS = extern struct {
    SequenceControlDesc: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC,
    PictureControlDesc: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC,
    pInputFrame: ?*ID3D12Resource,
    InputFrameSubresource: u32,
    CurrentFrameBitstreamMetadataSize: u32,
};

pub const D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM = extern struct {
    pBuffer: ?*ID3D12Resource,
    FrameStartOffset: u64,
};

pub const D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE = extern struct {
    pReconstructedPicture: ?*ID3D12Resource,
    ReconstructedPictureSubresource: u32,
};

pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA = extern struct {
    bSize: u64,
    bStartOffset: u64,
    bHeaderSize: u64,
};

pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = enum(u32) {
    NO_ERROR = 0,
    CODEC_PICTURE_CONTROL_NOT_SUPPORTED = 1,
    SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED = 2,
    INVALID_REFERENCE_PICTURES = 4,
    RECONFIGURATION_REQUEST_NOT_SUPPORTED = 8,
    INVALID_METADATA_BUFFER_SOURCE = 16,
    _,
    pub fn initFlags(o: struct {
        NO_ERROR: u1 = 0,
        CODEC_PICTURE_CONTROL_NOT_SUPPORTED: u1 = 0,
        SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED: u1 = 0,
        INVALID_REFERENCE_PICTURES: u1 = 0,
        RECONFIGURATION_REQUEST_NOT_SUPPORTED: u1 = 0,
        INVALID_METADATA_BUFFER_SOURCE: u1 = 0,
    }) D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
        return @as(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS, @enumFromInt((if (o.NO_ERROR == 1) @intFromEnum(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.NO_ERROR) else 0) | (if (o.CODEC_PICTURE_CONTROL_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.CODEC_PICTURE_CONTROL_NOT_SUPPORTED) else 0) | (if (o.SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED) else 0) | (if (o.INVALID_REFERENCE_PICTURES == 1) @intFromEnum(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.INVALID_REFERENCE_PICTURES) else 0) | (if (o.RECONFIGURATION_REQUEST_NOT_SUPPORTED == 1) @intFromEnum(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.RECONFIGURATION_REQUEST_NOT_SUPPORTED) else 0) | (if (o.INVALID_METADATA_BUFFER_SOURCE == 1) @intFromEnum(D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.INVALID_METADATA_BUFFER_SOURCE) else 0)));
    }
};
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_NO_ERROR = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.NO_ERROR;
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_CODEC_PICTURE_CONTROL_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.CODEC_PICTURE_CONTROL_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_INVALID_REFERENCE_PICTURES = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.INVALID_REFERENCE_PICTURES;
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_RECONFIGURATION_REQUEST_NOT_SUPPORTED = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.RECONFIGURATION_REQUEST_NOT_SUPPORTED;
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_INVALID_METADATA_BUFFER_SOURCE = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS.INVALID_METADATA_BUFFER_SOURCE;

pub const D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS = extern struct {
    AverageQP: u64,
    IntraCodingUnitsCount: u64,
    InterCodingUnitsCount: u64,
    SkipCodingUnitsCount: u64,
    AverageMotionEstimationXDirection: u64,
    AverageMotionEstimationYDirection: u64,
};

pub const D3D12_VIDEO_ENCODER_OUTPUT_METADATA = extern struct {
    EncodeErrorFlags: u64,
    EncodeStats: D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS,
    EncodedBitstreamWrittenBytesCount: u64,
    WrittenSubregionsCount: u64,
};

pub const D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER = extern struct {
    pBuffer: ?*ID3D12Resource,
    Offset: u64,
};

pub const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS = extern struct {
    EncoderCodec: D3D12_VIDEO_ENCODER_CODEC,
    EncoderProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    EncoderInputFormat: DXGI_FORMAT,
    EncodedPictureEffectiveResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    HWLayoutMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
};

pub const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS = extern struct {
    ResolvedLayoutMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
};

pub const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS = extern struct {
    Bitstream: D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM,
    ReconstructedPicture: D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE,
    EncoderOutputMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
};

const IID_ID3D12VideoEncodeCommandList2_Value = Guid.initString("895491e2-e701-46a9-9a1f-8d3480ed867a");
pub const IID_ID3D12VideoEncodeCommandList2 = &IID_ID3D12VideoEncodeCommandList2_Value;
pub const ID3D12VideoEncodeCommandList2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoEncodeCommandList1.VTable,
        EncodeFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList2,
                pEncoder: ?*ID3D12VideoEncoder,
                pHeap: ?*ID3D12VideoEncoderHeap,
                pInputArguments: ?*const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
                pOutputArguments: ?*const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList2,
                pEncoder: ?*ID3D12VideoEncoder,
                pHeap: ?*ID3D12VideoEncoderHeap,
                pInputArguments: ?*const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
                pOutputArguments: ?*const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ResolveEncoderOutputMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ID3D12VideoEncodeCommandList2,
                pInputArguments: ?*const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
                pOutputArguments: ?*const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ID3D12VideoEncodeCommandList2,
                pInputArguments: ?*const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
                pOutputArguments: ?*const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ID3D12VideoEncodeCommandList1.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList2_EncodeFrame(self: *const T, pEncoder: ?*ID3D12VideoEncoder, pHeap: ?*ID3D12VideoEncoderHeap, pInputArguments: ?*const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, pOutputArguments: ?*const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS) void {
                return @as(*const ID3D12VideoEncodeCommandList2.VTable, @ptrCast(self.vtable)).EncodeFrame(@as(*const ID3D12VideoEncodeCommandList2, @ptrCast(self)), pEncoder, pHeap, pInputArguments, pOutputArguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ID3D12VideoEncodeCommandList2_ResolveEncoderOutputMetadata(self: *const T, pInputArguments: ?*const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, pOutputArguments: ?*const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS) void {
                return @as(*const ID3D12VideoEncodeCommandList2.VTable, @ptrCast(self.vtable)).ResolveEncoderOutputMetadata(@as(*const ID3D12VideoEncodeCommandList2, @ptrCast(self)), pInputArguments, pOutputArguments);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CMpeg4DecMediaObject_Value = Guid.initString("f371728a-6052-4d47-827c-d039335dfe0a");
pub const CLSID_CMpeg4DecMediaObject = &CLSID_CMpeg4DecMediaObject_Value;

const CLSID_CMpeg43DecMediaObject_Value = Guid.initString("cba9e78b-49a3-49ea-93d4-6bcba8c4de07");
pub const CLSID_CMpeg43DecMediaObject = &CLSID_CMpeg43DecMediaObject_Value;

const CLSID_CMpeg4sDecMediaObject_Value = Guid.initString("2a11bae2-fe6e-4249-864b-9e9ed6e8dbc2");
pub const CLSID_CMpeg4sDecMediaObject = &CLSID_CMpeg4sDecMediaObject_Value;

const CLSID_CMpeg4sDecMFT_Value = Guid.initString("5686a0d9-fe39-409f-9dff-3fdbc849f9f5");
pub const CLSID_CMpeg4sDecMFT = &CLSID_CMpeg4sDecMFT_Value;

const CLSID_CZuneM4S2DecMediaObject_Value = Guid.initString("c56fc25c-0fc6-404a-9503-b10bf51a8ab9");
pub const CLSID_CZuneM4S2DecMediaObject = &CLSID_CZuneM4S2DecMediaObject_Value;

const CLSID_CMpeg4EncMediaObject_Value = Guid.initString("24f258d8-c651-4042-93e4-ca654abb682c");
pub const CLSID_CMpeg4EncMediaObject = &CLSID_CMpeg4EncMediaObject_Value;

const CLSID_CMpeg4sEncMediaObject_Value = Guid.initString("6ec5a7be-d81e-4f9e-ada3-cd1bf262b6d8");
pub const CLSID_CMpeg4sEncMediaObject = &CLSID_CMpeg4sEncMediaObject_Value;

const CLSID_CMSSCDecMediaObject_Value = Guid.initString("7bafb3b1-d8f4-4279-9253-27da423108de");
pub const CLSID_CMSSCDecMediaObject = &CLSID_CMSSCDecMediaObject_Value;

const CLSID_CMSSCEncMediaObject_Value = Guid.initString("8cb9cc06-d139-4ae6-8bb4-41e612e141d5");
pub const CLSID_CMSSCEncMediaObject = &CLSID_CMSSCEncMediaObject_Value;

const CLSID_CMSSCEncMediaObject2_Value = Guid.initString("f7ffe0a0-a4f5-44b5-949e-15ed2bc66f9d");
pub const CLSID_CMSSCEncMediaObject2 = &CLSID_CMSSCEncMediaObject2_Value;

const CLSID_CWMADecMediaObject_Value = Guid.initString("2eeb4adf-4578-4d10-bca7-bb955f56320a");
pub const CLSID_CWMADecMediaObject = &CLSID_CWMADecMediaObject_Value;

const CLSID_CWMAEncMediaObject_Value = Guid.initString("70f598e9-f4ab-495a-99e2-a7c4d3d89abf");
pub const CLSID_CWMAEncMediaObject = &CLSID_CWMAEncMediaObject_Value;

const CLSID_CWMATransMediaObject_Value = Guid.initString("edcad9cb-3127-40df-b527-0152ccb3f6f5");
pub const CLSID_CWMATransMediaObject = &CLSID_CWMATransMediaObject_Value;

const CLSID_CWMSPDecMediaObject_Value = Guid.initString("874131cb-4ecc-443b-8948-746b89595d20");
pub const CLSID_CWMSPDecMediaObject = &CLSID_CWMSPDecMediaObject_Value;

const CLSID_CWMSPEncMediaObject_Value = Guid.initString("67841b03-c689-4188-ad3f-4c9ebeec710b");
pub const CLSID_CWMSPEncMediaObject = &CLSID_CWMSPEncMediaObject_Value;

const CLSID_CWMSPEncMediaObject2_Value = Guid.initString("1f1f4e1a-2252-4063-84bb-eee75f8856d5");
pub const CLSID_CWMSPEncMediaObject2 = &CLSID_CWMSPEncMediaObject2_Value;

const CLSID_CWMTDecMediaObject_Value = Guid.initString("f9dbc64e-2dd0-45dd-9b52-66642ef94431");
pub const CLSID_CWMTDecMediaObject = &CLSID_CWMTDecMediaObject_Value;

const CLSID_CWMTEncMediaObject_Value = Guid.initString("60b67652-e46b-4e44-8609-f74bffdc083c");
pub const CLSID_CWMTEncMediaObject = &CLSID_CWMTEncMediaObject_Value;

const CLSID_CWMVDecMediaObject_Value = Guid.initString("82d353df-90bd-4382-8bc2-3f6192b76e34");
pub const CLSID_CWMVDecMediaObject = &CLSID_CWMVDecMediaObject_Value;

const CLSID_CWMVEncMediaObject2_Value = Guid.initString("96b57cdd-8966-410c-bb1f-c97eea765c04");
pub const CLSID_CWMVEncMediaObject2 = &CLSID_CWMVEncMediaObject2_Value;

const CLSID_CWMVXEncMediaObject_Value = Guid.initString("7e320092-596a-41b2-bbeb-175d10504eb6");
pub const CLSID_CWMVXEncMediaObject = &CLSID_CWMVXEncMediaObject_Value;

const CLSID_CWMV9EncMediaObject_Value = Guid.initString("d23b90d0-144f-46bd-841d-59e4eb19dc59");
pub const CLSID_CWMV9EncMediaObject = &CLSID_CWMV9EncMediaObject_Value;

const CLSID_CWVC1DecMediaObject_Value = Guid.initString("c9bfbccf-e60e-4588-a3df-5a03b1fd9585");
pub const CLSID_CWVC1DecMediaObject = &CLSID_CWVC1DecMediaObject_Value;

const CLSID_CWVC1EncMediaObject_Value = Guid.initString("44653d0d-8cca-41e7-baca-884337b747ac");
pub const CLSID_CWVC1EncMediaObject = &CLSID_CWVC1EncMediaObject_Value;

const CLSID_CDeColorConvMediaObject_Value = Guid.initString("49034c05-f43c-400f-84c1-90a683195a3a");
pub const CLSID_CDeColorConvMediaObject = &CLSID_CDeColorConvMediaObject_Value;

const CLSID_CDVDecoderMediaObject_Value = Guid.initString("e54709c5-1e17-4c8d-94e7-478940433584");
pub const CLSID_CDVDecoderMediaObject = &CLSID_CDVDecoderMediaObject_Value;

const CLSID_CDVEncoderMediaObject_Value = Guid.initString("c82ae729-c327-4cce-914d-8171fefebefb");
pub const CLSID_CDVEncoderMediaObject = &CLSID_CDVEncoderMediaObject_Value;

const CLSID_CMpeg2DecMediaObject_Value = Guid.initString("863d66cd-cdce-4617-b47f-c8929cfc28a6");
pub const CLSID_CMpeg2DecMediaObject = &CLSID_CMpeg2DecMediaObject_Value;

const CLSID_CPK_DS_MPEG2Decoder_Value = Guid.initString("9910c5cd-95c9-4e06-865a-efa1c8016bf4");
pub const CLSID_CPK_DS_MPEG2Decoder = &CLSID_CPK_DS_MPEG2Decoder_Value;

const CLSID_CAC3DecMediaObject_Value = Guid.initString("03d7c802-ecfa-47d9-b268-5fb3e310dee4");
pub const CLSID_CAC3DecMediaObject = &CLSID_CAC3DecMediaObject_Value;

const CLSID_CPK_DS_AC3Decoder_Value = Guid.initString("6c9c69d6-0ffc-4481-afdb-cdf1c79c6f3e");
pub const CLSID_CPK_DS_AC3Decoder = &CLSID_CPK_DS_AC3Decoder_Value;

const CLSID_CMP3DecMediaObject_Value = Guid.initString("bbeea841-0a63-4f52-a7ab-a9b3a84ed38a");
pub const CLSID_CMP3DecMediaObject = &CLSID_CMP3DecMediaObject_Value;

const CLSID_CResamplerMediaObject_Value = Guid.initString("f447b69e-1884-4a7e-8055-346f74d6edb3");
pub const CLSID_CResamplerMediaObject = &CLSID_CResamplerMediaObject_Value;

const CLSID_CResizerMediaObject_Value = Guid.initString("d3ec8b8b-7728-4fd8-9fe0-7b67d19f73a3");
pub const CLSID_CResizerMediaObject = &CLSID_CResizerMediaObject_Value;

const CLSID_CInterlaceMediaObject_Value = Guid.initString("b5a89c80-4901-407b-9abc-90d9a644bb46");
pub const CLSID_CInterlaceMediaObject = &CLSID_CInterlaceMediaObject_Value;

const CLSID_CWMAudioLFXAPO_Value = Guid.initString("62dc1a93-ae24-464c-a43e-452f824c4250");
pub const CLSID_CWMAudioLFXAPO = &CLSID_CWMAudioLFXAPO_Value;

const CLSID_CWMAudioGFXAPO_Value = Guid.initString("637c490d-eee3-4c0a-973f-371958802da2");
pub const CLSID_CWMAudioGFXAPO = &CLSID_CWMAudioGFXAPO_Value;

const CLSID_CWMAudioCAPXLFXAPO_Value = Guid.initString("c9453e73-8c5c-4463-9984-af8bab2f5447");
pub const CLSID_CWMAudioCAPXLFXAPO = &CLSID_CWMAudioCAPXLFXAPO_Value;

const CLSID_CWMAudioCAPXGFXAPO_Value = Guid.initString("13ab3ebd-137e-4903-9d89-60be8277fd17");
pub const CLSID_CWMAudioCAPXGFXAPO = &CLSID_CWMAudioCAPXGFXAPO_Value;

const CLSID_CWMAudioSpdTxDMO_Value = Guid.initString("5210f8e4-b0bb-47c3-a8d9-7b2282cc79ed");
pub const CLSID_CWMAudioSpdTxDMO = &CLSID_CWMAudioSpdTxDMO_Value;

const CLSID_CWMAudioAEC_Value = Guid.initString("745057c7-f353-4f2d-a7ee-58434477730e");
pub const CLSID_CWMAudioAEC = &CLSID_CWMAudioAEC_Value;

const CLSID_CClusterDetectorDmo_Value = Guid.initString("36e820c4-165a-4521-863c-619e1160d4d4");
pub const CLSID_CClusterDetectorDmo = &CLSID_CClusterDetectorDmo_Value;

const CLSID_CColorControlDmo_Value = Guid.initString("798059f0-89ca-4160-b325-aeb48efe4f9a");
pub const CLSID_CColorControlDmo = &CLSID_CColorControlDmo_Value;

const CLSID_CColorConvertDMO_Value = Guid.initString("98230571-0087-4204-b020-3282538e57d3");
pub const CLSID_CColorConvertDMO = &CLSID_CColorConvertDMO_Value;

const CLSID_CColorLegalizerDmo_Value = Guid.initString("fdfaa753-e48e-4e33-9c74-98a27fc6726a");
pub const CLSID_CColorLegalizerDmo = &CLSID_CColorLegalizerDmo_Value;

const CLSID_CFrameInterpDMO_Value = Guid.initString("0a7cfe1b-6ab5-4334-9ed8-3f97cb37daa1");
pub const CLSID_CFrameInterpDMO = &CLSID_CFrameInterpDMO_Value;

const CLSID_CFrameRateConvertDmo_Value = Guid.initString("01f36ce2-0907-4d8b-979d-f151be91c883");
pub const CLSID_CFrameRateConvertDmo = &CLSID_CFrameRateConvertDmo_Value;

const CLSID_CResizerDMO_Value = Guid.initString("1ea1ea14-48f4-4054-ad1a-e8aee10ac805");
pub const CLSID_CResizerDMO = &CLSID_CResizerDMO_Value;

const CLSID_CShotDetectorDmo_Value = Guid.initString("56aefacd-110c-4397-9292-b0a0c61b6750");
pub const CLSID_CShotDetectorDmo = &CLSID_CShotDetectorDmo_Value;

const CLSID_CSmpteTransformsDmo_Value = Guid.initString("bde6388b-da25-485d-ba7f-fabc28b20318");
pub const CLSID_CSmpteTransformsDmo = &CLSID_CSmpteTransformsDmo_Value;

const CLSID_CThumbnailGeneratorDmo_Value = Guid.initString("559c6bad-1ea8-4963-a087-8a6810f9218b");
pub const CLSID_CThumbnailGeneratorDmo = &CLSID_CThumbnailGeneratorDmo_Value;

const CLSID_CTocGeneratorDmo_Value = Guid.initString("4dda1941-77a0-4fb1-a518-e2185041d70c");
pub const CLSID_CTocGeneratorDmo = &CLSID_CTocGeneratorDmo_Value;

const CLSID_CMPEGAACDecMediaObject_Value = Guid.initString("8dde1772-edad-41c3-b4be-1f30fb4ee0d6");
pub const CLSID_CMPEGAACDecMediaObject = &CLSID_CMPEGAACDecMediaObject_Value;

const CLSID_CNokiaAACDecMediaObject_Value = Guid.initString("3cb2bde4-4e29-4c44-a73e-2d7c2c46d6ec");
pub const CLSID_CNokiaAACDecMediaObject = &CLSID_CNokiaAACDecMediaObject_Value;

const CLSID_CVodafoneAACDecMediaObject_Value = Guid.initString("7f36f942-dcf3-4d82-9289-5b1820278f7c");
pub const CLSID_CVodafoneAACDecMediaObject = &CLSID_CVodafoneAACDecMediaObject_Value;

const CLSID_CZuneAACCCDecMediaObject_Value = Guid.initString("a74e98f2-52d6-4b4e-885b-e0a6ca4f187a");
pub const CLSID_CZuneAACCCDecMediaObject = &CLSID_CZuneAACCCDecMediaObject_Value;

const CLSID_CNokiaAACCCDecMediaObject_Value = Guid.initString("eabf7a6f-ccba-4d60-8620-b152cc977263");
pub const CLSID_CNokiaAACCCDecMediaObject = &CLSID_CNokiaAACCCDecMediaObject_Value;

const CLSID_CVodafoneAACCCDecMediaObject_Value = Guid.initString("7e76bf7f-c993-4e26-8fab-470a70c0d59c");
pub const CLSID_CVodafoneAACCCDecMediaObject = &CLSID_CVodafoneAACCCDecMediaObject_Value;

const CLSID_CMPEG2EncoderDS_Value = Guid.initString("5f5aff4a-2f7f-4279-88c2-cd88eb39d144");
pub const CLSID_CMPEG2EncoderDS = &CLSID_CMPEG2EncoderDS_Value;

const CLSID_CMPEG2EncoderVideoDS_Value = Guid.initString("42150cd9-ca9a-4ea5-9939-30ee037f6e74");
pub const CLSID_CMPEG2EncoderVideoDS = &CLSID_CMPEG2EncoderVideoDS_Value;

const CLSID_CMPEG2EncoderAudioDS_Value = Guid.initString("acd453bc-c58a-44d1-bbf5-bfb325be2d78");
pub const CLSID_CMPEG2EncoderAudioDS = &CLSID_CMPEG2EncoderAudioDS_Value;

const CLSID_CMPEG2AudDecoderDS_Value = Guid.initString("e1f1a0b8-beee-490d-ba7c-066c40b5e2b9");
pub const CLSID_CMPEG2AudDecoderDS = &CLSID_CMPEG2AudDecoderDS_Value;

const CLSID_CMPEG2VidDecoderDS_Value = Guid.initString("212690fb-83e5-4526-8fd7-74478b7939cd");
pub const CLSID_CMPEG2VidDecoderDS = &CLSID_CMPEG2VidDecoderDS_Value;

const CLSID_CDTVAudDecoderDS_Value = Guid.initString("8e269032-fe03-4753-9b17-18253c21722e");
pub const CLSID_CDTVAudDecoderDS = &CLSID_CDTVAudDecoderDS_Value;

const CLSID_CDTVVidDecoderDS_Value = Guid.initString("64777dc8-4e24-4beb-9d19-60a35be1daaf");
pub const CLSID_CDTVVidDecoderDS = &CLSID_CDTVVidDecoderDS_Value;

const CLSID_CMSAC3Enc_Value = Guid.initString("c6b400e2-20a7-4e58-a2fe-24619682ce6c");
pub const CLSID_CMSAC3Enc = &CLSID_CMSAC3Enc_Value;

const CLSID_CMSH264DecoderMFT_Value = Guid.initString("62ce7e72-4c71-4d20-b15d-452831a87d9d");
pub const CLSID_CMSH264DecoderMFT = &CLSID_CMSH264DecoderMFT_Value;

const CLSID_CMSH263EncoderMFT_Value = Guid.initString("bc47fcfe-98a0-4f27-bb07-698af24f2b38");
pub const CLSID_CMSH263EncoderMFT = &CLSID_CMSH263EncoderMFT_Value;

const CLSID_CMSH264EncoderMFT_Value = Guid.initString("6ca50344-051a-4ded-9779-a43305165e35");
pub const CLSID_CMSH264EncoderMFT = &CLSID_CMSH264EncoderMFT_Value;

const CLSID_CMSH265EncoderMFT_Value = Guid.initString("f2f84074-8bca-40bd-9159-e880f673dd3b");
pub const CLSID_CMSH265EncoderMFT = &CLSID_CMSH265EncoderMFT_Value;

const CLSID_CMSVPXEncoderMFT_Value = Guid.initString("aeb6c755-2546-4881-82cc-e15ae5ebff3d");
pub const CLSID_CMSVPXEncoderMFT = &CLSID_CMSVPXEncoderMFT_Value;

const CLSID_CMSH264RemuxMFT_Value = Guid.initString("05a47ebb-8bf0-4cbf-ad2f-3b71d75866f5");
pub const CLSID_CMSH264RemuxMFT = &CLSID_CMSH264RemuxMFT_Value;

const CLSID_CMSAACDecMFT_Value = Guid.initString("32d186a7-218f-4c75-8876-dd77273a8999");
pub const CLSID_CMSAACDecMFT = &CLSID_CMSAACDecMFT_Value;

const CLSID_AACMFTEncoder_Value = Guid.initString("93af0c51-2275-45d2-a35b-f2ba21caed00");
pub const CLSID_AACMFTEncoder = &CLSID_AACMFTEncoder_Value;

const CLSID_CMSDDPlusDecMFT_Value = Guid.initString("177c0afe-900b-48d4-9e4c-57add250b3d4");
pub const CLSID_CMSDDPlusDecMFT = &CLSID_CMSDDPlusDecMFT_Value;

const CLSID_CMPEG2VideoEncoderMFT_Value = Guid.initString("e6335f02-80b7-4dc4-adfa-dfe7210d20d5");
pub const CLSID_CMPEG2VideoEncoderMFT = &CLSID_CMPEG2VideoEncoderMFT_Value;

const CLSID_CMPEG2AudioEncoderMFT_Value = Guid.initString("46a4dd5c-73f8-4304-94df-308f760974f4");
pub const CLSID_CMPEG2AudioEncoderMFT = &CLSID_CMPEG2AudioEncoderMFT_Value;

const CLSID_CMSMPEGDecoderMFT_Value = Guid.initString("2d709e52-123f-49b5-9cbc-9af5cde28fb9");
pub const CLSID_CMSMPEGDecoderMFT = &CLSID_CMSMPEGDecoderMFT_Value;

const CLSID_CMSMPEGAudDecMFT_Value = Guid.initString("70707b39-b2ca-4015-abea-f8447d22d88b");
pub const CLSID_CMSMPEGAudDecMFT = &CLSID_CMSMPEGAudDecMFT_Value;

const CLSID_CMSDolbyDigitalEncMFT_Value = Guid.initString("ac3315c9-f481-45d7-826c-0b406c1f64b8");
pub const CLSID_CMSDolbyDigitalEncMFT = &CLSID_CMSDolbyDigitalEncMFT_Value;

const CLSID_MP3ACMCodecWrapper_Value = Guid.initString("11103421-354c-4cca-a7a3-1aff9a5b6701");
pub const CLSID_MP3ACMCodecWrapper = &CLSID_MP3ACMCodecWrapper_Value;

const CLSID_ALawCodecWrapper_Value = Guid.initString("36cb6e0c-78c1-42b2-9943-846262f31786");
pub const CLSID_ALawCodecWrapper = &CLSID_ALawCodecWrapper_Value;

const CLSID_MULawCodecWrapper_Value = Guid.initString("92b66080-5e2d-449e-90c4-c41f268e5514");
pub const CLSID_MULawCodecWrapper = &CLSID_MULawCodecWrapper_Value;

const CLSID_CMSVideoDSPMFT_Value = Guid.initString("51571744-7fe4-4ff2-a498-2dc34ff74f1b");
pub const CLSID_CMSVideoDSPMFT = &CLSID_CMSVideoDSPMFT_Value;

const CLSID_VorbisDecoderMFT_Value = Guid.initString("1a198ef2-60e5-4ea8-90d8-da1f2832c288");
pub const CLSID_VorbisDecoderMFT = &CLSID_VorbisDecoderMFT_Value;

const CLSID_CMSFLACDecMFT_Value = Guid.initString("6b0b3e6b-a2c5-4514-8055-afe8a95242d9");
pub const CLSID_CMSFLACDecMFT = &CLSID_CMSFLACDecMFT_Value;

const CLSID_CMSFLACEncMFT_Value = Guid.initString("128509e9-c44e-45dc-95e9-c255b8f466a6");
pub const CLSID_CMSFLACEncMFT = &CLSID_CMSFLACEncMFT_Value;

const CLSID_MFFLACBytestreamHandler_Value = Guid.initString("0e41cfb8-0506-40f4-a516-77cc23642d91");
pub const CLSID_MFFLACBytestreamHandler = &CLSID_MFFLACBytestreamHandler_Value;

const CLSID_MFFLACSinkClassFactory_Value = Guid.initString("7d39c56f-6075-47c9-9bae-8cf9e531b5f5");
pub const CLSID_MFFLACSinkClassFactory = &CLSID_MFFLACSinkClassFactory_Value;

const CLSID_CMSALACDecMFT_Value = Guid.initString("c0cd7d12-31fc-4bbc-b363-7322ee3e1879");
pub const CLSID_CMSALACDecMFT = &CLSID_CMSALACDecMFT_Value;

const CLSID_CMSALACEncMFT_Value = Guid.initString("9ab6a28c-748e-4b6a-bfff-cc443b8e8fb4");
pub const CLSID_CMSALACEncMFT = &CLSID_CMSALACEncMFT_Value;

const CLSID_CMSOpusDecMFT_Value = Guid.initString("63e17c10-2d43-4c42-8fe3-8d8b63e46a6a");
pub const CLSID_CMSOpusDecMFT = &CLSID_CMSOpusDecMFT_Value;

const CLSID_MSAMRNBDecoder_Value = Guid.initString("265011ae-5481-4f77-a295-abb6ffe8d63e");
pub const CLSID_MSAMRNBDecoder = &CLSID_MSAMRNBDecoder_Value;

const CLSID_MSAMRNBEncoder_Value = Guid.initString("2fae8afe-04a3-423a-a814-85db454712b0");
pub const CLSID_MSAMRNBEncoder = &CLSID_MSAMRNBEncoder_Value;

const CLSID_MFAMRNBByteStreamHandler_Value = Guid.initString("efe6208a-0a2c-49fa-8a01-3768b559b6da");
pub const CLSID_MFAMRNBByteStreamHandler = &CLSID_MFAMRNBByteStreamHandler_Value;

const CLSID_MFAMRNBSinkClassFactory_Value = Guid.initString("b0271158-70d2-4c5b-9f94-76f549d90fdf");
pub const CLSID_MFAMRNBSinkClassFactory = &CLSID_MFAMRNBSinkClassFactory_Value;

pub const WMT_PROP_DATATYPE = enum(i32) {
    DWORD = 0,
    STRING = 1,
    BINARY = 2,
    BOOL = 3,
    QWORD = 4,
    WORD = 5,
    GUID = 6,
};
pub const WMT_PROP_TYPE_DWORD = WMT_PROP_DATATYPE.DWORD;
pub const WMT_PROP_TYPE_STRING = WMT_PROP_DATATYPE.STRING;
pub const WMT_PROP_TYPE_BINARY = WMT_PROP_DATATYPE.BINARY;
pub const WMT_PROP_TYPE_BOOL = WMT_PROP_DATATYPE.BOOL;
pub const WMT_PROP_TYPE_QWORD = WMT_PROP_DATATYPE.QWORD;
pub const WMT_PROP_TYPE_WORD = WMT_PROP_DATATYPE.WORD;
pub const WMT_PROP_TYPE_GUID = WMT_PROP_DATATYPE.GUID;

const IID_IWMValidate_Value = Guid.initString("cee3def2-3808-414d-be66-fafd472210bc");
pub const IID_IWMValidate = &IID_IWMValidate_Value;
pub const IWMValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMValidate,
                guidValidationID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMValidate,
                guidValidationID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMValidate_SetIdentifier(self: *const T, guidValidationID: Guid) HRESULT {
                return @as(*const IWMValidate.VTable, @ptrCast(self.vtable)).SetIdentifier(@as(*const IWMValidate, @ptrCast(self)), guidValidationID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IValidateBinding_Value = Guid.initString("04a578b2-e778-422a-a805-b3ee54d90bd9");
pub const IID_IValidateBinding = &IID_IValidateBinding_Value;
pub const IValidateBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IValidateBinding,
                guidLicensorID: Guid,
                pbEphemeron: [*:0]u8,
                cbEphemeron: u32,
                ppbBlobValidationID: ?[*]?*u8,
                pcbBlobSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IValidateBinding,
                guidLicensorID: Guid,
                pbEphemeron: [*:0]u8,
                cbEphemeron: u32,
                ppbBlobValidationID: ?[*]?*u8,
                pcbBlobSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IValidateBinding_GetIdentifier(self: *const T, guidLicensorID: Guid, pbEphemeron: [*:0]u8, cbEphemeron: u32, ppbBlobValidationID: ?[*]?*u8, pcbBlobSize: ?*u32) HRESULT {
                return @as(*const IValidateBinding.VTable, @ptrCast(self.vtable)).GetIdentifier(@as(*const IValidateBinding, @ptrCast(self)), guidLicensorID, pbEphemeron, cbEphemeron, ppbBlobValidationID, pcbBlobSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMVideoDecoderHurryup_Value = Guid.initString("352bb3bd-2d4d-4323-9e71-dcdcfbd53ca6");
pub const IID_IWMVideoDecoderHurryup = &IID_IWMVideoDecoderHurryup_Value;
pub const IWMVideoDecoderHurryup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHurryup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoDecoderHurryup,
                lHurryup: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoDecoderHurryup,
                lHurryup: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHurryup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoDecoderHurryup,
                plHurryup: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoDecoderHurryup,
                plHurryup: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoDecoderHurryup_SetHurryup(self: *const T, lHurryup: i32) HRESULT {
                return @as(*const IWMVideoDecoderHurryup.VTable, @ptrCast(self.vtable)).SetHurryup(@as(*const IWMVideoDecoderHurryup, @ptrCast(self)), lHurryup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoDecoderHurryup_GetHurryup(self: *const T, plHurryup: ?*i32) HRESULT {
                return @as(*const IWMVideoDecoderHurryup.VTable, @ptrCast(self.vtable)).GetHurryup(@as(*const IWMVideoDecoderHurryup, @ptrCast(self)), plHurryup);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMVideoForceKeyFrame_Value = Guid.initString("9f8496be-5b9a-41b9-a9e8-f21cd80596c2");
pub const IID_IWMVideoForceKeyFrame = &IID_IWMVideoForceKeyFrame_Value;
pub const IWMVideoForceKeyFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetKeyFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoForceKeyFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoForceKeyFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoForceKeyFrame_SetKeyFrame(self: *const T) HRESULT {
                return @as(*const IWMVideoForceKeyFrame.VTable, @ptrCast(self.vtable)).SetKeyFrame(@as(*const IWMVideoForceKeyFrame, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMCodecStrings_Value = Guid.initString("a7b2504b-e58a-47fb-958b-cac7165a057d");
pub const IID_IWMCodecStrings = &IID_IWMCodecStrings_Value;
pub const IWMCodecStrings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecStrings,
                pmt: ?*DMO_MEDIA_TYPE,
                cchLength: u32,
                szName: ?[*:0]u16,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecStrings,
                pmt: ?*DMO_MEDIA_TYPE,
                cchLength: u32,
                szName: ?[*:0]u16,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecStrings,
                pmt: ?*DMO_MEDIA_TYPE,
                cchLength: u32,
                szDescription: ?[*:0]u16,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecStrings,
                pmt: ?*DMO_MEDIA_TYPE,
                cchLength: u32,
                szDescription: ?[*:0]u16,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecStrings_GetName(self: *const T, pmt: ?*DMO_MEDIA_TYPE, cchLength: u32, szName: ?[*:0]u16, pcchLength: ?*u32) HRESULT {
                return @as(*const IWMCodecStrings.VTable, @ptrCast(self.vtable)).GetName(@as(*const IWMCodecStrings, @ptrCast(self)), pmt, cchLength, szName, pcchLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecStrings_GetDescription(self: *const T, pmt: ?*DMO_MEDIA_TYPE, cchLength: u32, szDescription: ?[*:0]u16, pcchLength: ?*u32) HRESULT {
                return @as(*const IWMCodecStrings.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IWMCodecStrings, @ptrCast(self)), pmt, cchLength, szDescription, pcchLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMCodecProps_Value = Guid.initString("2573e11a-f01a-4fdd-a98d-63b8e0ba9589");
pub const IID_IWMCodecProps = &IID_IWMCodecProps_Value;
pub const IWMCodecProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFormatProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecProps,
                pmt: ?*DMO_MEDIA_TYPE,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_PROP_DATATYPE,
                pValue: ?*u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecProps,
                pmt: ?*DMO_MEDIA_TYPE,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_PROP_DATATYPE,
                pValue: ?*u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecProp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecProps,
                dwFormat: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_PROP_DATATYPE,
                pValue: ?*u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecProps,
                dwFormat: u32,
                pszName: ?[*:0]const u16,
                pType: ?*WMT_PROP_DATATYPE,
                pValue: ?*u8,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecProps_GetFormatProp(self: *const T, pmt: ?*DMO_MEDIA_TYPE, pszName: ?[*:0]const u16, pType: ?*WMT_PROP_DATATYPE, pValue: ?*u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMCodecProps.VTable, @ptrCast(self.vtable)).GetFormatProp(@as(*const IWMCodecProps, @ptrCast(self)), pmt, pszName, pType, pValue, pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecProps_GetCodecProp(self: *const T, dwFormat: u32, pszName: ?[*:0]const u16, pType: ?*WMT_PROP_DATATYPE, pValue: ?*u8, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMCodecProps.VTable, @ptrCast(self.vtable)).GetCodecProp(@as(*const IWMCodecProps, @ptrCast(self)), dwFormat, pszName, pType, pValue, pdwSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMCodecLeakyBucket_Value = Guid.initString("a81ba647-6227-43b7-b231-c7b15135dd7d");
pub const IID_IWMCodecLeakyBucket = &IID_IWMCodecLeakyBucket_Value;
pub const IWMCodecLeakyBucket = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBufferSizeBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecLeakyBucket,
                ulBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecLeakyBucket,
                ulBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferSizeBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecLeakyBucket,
                pulBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecLeakyBucket,
                pulBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferFullnessBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecLeakyBucket,
                ulBufferFullness: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecLeakyBucket,
                ulBufferFullness: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferFullnessBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecLeakyBucket,
                pulBufferFullness: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecLeakyBucket,
                pulBufferFullness: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecLeakyBucket_SetBufferSizeBits(self: *const T, ulBufferSize: u32) HRESULT {
                return @as(*const IWMCodecLeakyBucket.VTable, @ptrCast(self.vtable)).SetBufferSizeBits(@as(*const IWMCodecLeakyBucket, @ptrCast(self)), ulBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecLeakyBucket_GetBufferSizeBits(self: *const T, pulBufferSize: ?*u32) HRESULT {
                return @as(*const IWMCodecLeakyBucket.VTable, @ptrCast(self.vtable)).GetBufferSizeBits(@as(*const IWMCodecLeakyBucket, @ptrCast(self)), pulBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecLeakyBucket_SetBufferFullnessBits(self: *const T, ulBufferFullness: u32) HRESULT {
                return @as(*const IWMCodecLeakyBucket.VTable, @ptrCast(self.vtable)).SetBufferFullnessBits(@as(*const IWMCodecLeakyBucket, @ptrCast(self)), ulBufferFullness);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecLeakyBucket_GetBufferFullnessBits(self: *const T, pulBufferFullness: ?*u32) HRESULT {
                return @as(*const IWMCodecLeakyBucket.VTable, @ptrCast(self.vtable)).GetBufferFullnessBits(@as(*const IWMCodecLeakyBucket, @ptrCast(self)), pulBufferFullness);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMCodecOutputTimestamp_Value = Guid.initString("b72adf95-7adc-4a72-bc05-577d8ea6bf68");
pub const IID_IWMCodecOutputTimestamp = &IID_IWMCodecOutputTimestamp_Value;
pub const IWMCodecOutputTimestamp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextOutputTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecOutputTimestamp,
                prtTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecOutputTimestamp,
                prtTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecOutputTimestamp_GetNextOutputTime(self: *const T, prtTime: ?*i64) HRESULT {
                return @as(*const IWMCodecOutputTimestamp.VTable, @ptrCast(self.vtable)).GetNextOutputTime(@as(*const IWMCodecOutputTimestamp, @ptrCast(self)), prtTime);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMVideoDecoderReconBuffer_Value = Guid.initString("45bda2ac-88e2-4923-98ba-3949080711a3");
pub const IID_IWMVideoDecoderReconBuffer = &IID_IWMVideoDecoderReconBuffer_Value;
pub const IWMVideoDecoderReconBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetReconstructedVideoFrameSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoDecoderReconBuffer,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoDecoderReconBuffer,
                pdwSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReconstructedVideoFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoDecoderReconBuffer,
                pBuf: ?*IMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoDecoderReconBuffer,
                pBuf: ?*IMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReconstructedVideoFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMVideoDecoderReconBuffer,
                pBuf: ?*IMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMVideoDecoderReconBuffer,
                pBuf: ?*IMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoDecoderReconBuffer_GetReconstructedVideoFrameSize(self: *const T, pdwSize: ?*u32) HRESULT {
                return @as(*const IWMVideoDecoderReconBuffer.VTable, @ptrCast(self.vtable)).GetReconstructedVideoFrameSize(@as(*const IWMVideoDecoderReconBuffer, @ptrCast(self)), pdwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoDecoderReconBuffer_GetReconstructedVideoFrame(self: *const T, pBuf: ?*IMediaBuffer) HRESULT {
                return @as(*const IWMVideoDecoderReconBuffer.VTable, @ptrCast(self.vtable)).GetReconstructedVideoFrame(@as(*const IWMVideoDecoderReconBuffer, @ptrCast(self)), pBuf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMVideoDecoderReconBuffer_SetReconstructedVideoFrame(self: *const T, pBuf: ?*IMediaBuffer) HRESULT {
                return @as(*const IWMVideoDecoderReconBuffer.VTable, @ptrCast(self.vtable)).SetReconstructedVideoFrame(@as(*const IWMVideoDecoderReconBuffer, @ptrCast(self)), pBuf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMCodecPrivateData_Value = Guid.initString("73f0be8e-57f7-4f01-aa66-9f57340cfe0e");
pub const IID_IWMCodecPrivateData = &IID_IWMCodecPrivateData_Value;
pub const IWMCodecPrivateData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPartialOutputType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecPrivateData,
                pmt: ?*DMO_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecPrivateData,
                pmt: ?*DMO_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMCodecPrivateData,
                pbData: ?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMCodecPrivateData,
                pbData: ?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecPrivateData_SetPartialOutputType(self: *const T, pmt: ?*DMO_MEDIA_TYPE) HRESULT {
                return @as(*const IWMCodecPrivateData.VTable, @ptrCast(self.vtable)).SetPartialOutputType(@as(*const IWMCodecPrivateData, @ptrCast(self)), pmt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMCodecPrivateData_GetPrivateData(self: *const T, pbData: ?*u8, pcbData: ?*u32) HRESULT {
                return @as(*const IWMCodecPrivateData.VTable, @ptrCast(self.vtable)).GetPrivateData(@as(*const IWMCodecPrivateData, @ptrCast(self)), pbData, pcbData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMSampleExtensionSupport_Value = Guid.initString("9bca9884-0604-4c2a-87da-793ff4d586c3");
pub const IID_IWMSampleExtensionSupport = &IID_IWMSampleExtensionSupport_Value;
pub const IWMSampleExtensionSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUseSampleExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMSampleExtensionSupport,
                fUseExtensions: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMSampleExtensionSupport,
                fUseExtensions: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMSampleExtensionSupport_SetUseSampleExtensions(self: *const T, fUseExtensions: BOOL) HRESULT {
                return @as(*const IWMSampleExtensionSupport.VTable, @ptrCast(self.vtable)).SetUseSampleExtensions(@as(*const IWMSampleExtensionSupport, @ptrCast(self)), fUseExtensions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMResamplerProps_Value = Guid.initString("e7e9984f-f09f-4da4-903f-6e2e0efe56b5");
pub const IID_IWMResamplerProps = &IID_IWMResamplerProps_Value;
pub const IWMResamplerProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHalfFilterLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResamplerProps,
                lhalfFilterLen: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResamplerProps,
                lhalfFilterLen: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUserChannelMtx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResamplerProps,
                userChannelMtx: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResamplerProps,
                userChannelMtx: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResamplerProps_SetHalfFilterLength(self: *const T, lhalfFilterLen: i32) HRESULT {
                return @as(*const IWMResamplerProps.VTable, @ptrCast(self.vtable)).SetHalfFilterLength(@as(*const IWMResamplerProps, @ptrCast(self)), lhalfFilterLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResamplerProps_SetUserChannelMtx(self: *const T, userChannelMtx: ?*f32) HRESULT {
                return @as(*const IWMResamplerProps.VTable, @ptrCast(self.vtable)).SetUserChannelMtx(@as(*const IWMResamplerProps, @ptrCast(self)), userChannelMtx);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMResizerProps_Value = Guid.initString("57665d4c-0414-4faa-905b-10e546f81c33");
pub const IID_IWMResizerProps = &IID_IWMResizerProps_Value;
pub const IWMResizerProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetResizerQuality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResizerProps,
                lquality: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResizerProps,
                lquality: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResizerProps,
                lmode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResizerProps,
                lmode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClipRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResizerProps,
                lClipOriXSrc: i32,
                lClipOriYSrc: i32,
                lClipWidthSrc: i32,
                lClipHeightSrc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResizerProps,
                lClipOriXSrc: i32,
                lClipOriYSrc: i32,
                lClipWidthSrc: i32,
                lClipHeightSrc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFullCropRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResizerProps,
                lClipOriXSrc: i32,
                lClipOriYSrc: i32,
                lClipWidthSrc: i32,
                lClipHeightSrc: i32,
                lClipOriXDst: i32,
                lClipOriYDst: i32,
                lClipWidthDst: i32,
                lClipHeightDst: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResizerProps,
                lClipOriXSrc: i32,
                lClipOriYSrc: i32,
                lClipWidthSrc: i32,
                lClipHeightSrc: i32,
                lClipOriXDst: i32,
                lClipOriYDst: i32,
                lClipWidthDst: i32,
                lClipHeightDst: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullCropRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMResizerProps,
                lClipOriXSrc: ?*i32,
                lClipOriYSrc: ?*i32,
                lClipWidthSrc: ?*i32,
                lClipHeightSrc: ?*i32,
                lClipOriXDst: ?*i32,
                lClipOriYDst: ?*i32,
                lClipWidthDst: ?*i32,
                lClipHeightDst: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMResizerProps,
                lClipOriXSrc: ?*i32,
                lClipOriYSrc: ?*i32,
                lClipWidthSrc: ?*i32,
                lClipHeightSrc: ?*i32,
                lClipOriXDst: ?*i32,
                lClipOriYDst: ?*i32,
                lClipWidthDst: ?*i32,
                lClipHeightDst: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResizerProps_SetResizerQuality(self: *const T, lquality: i32) HRESULT {
                return @as(*const IWMResizerProps.VTable, @ptrCast(self.vtable)).SetResizerQuality(@as(*const IWMResizerProps, @ptrCast(self)), lquality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResizerProps_SetInterlaceMode(self: *const T, lmode: i32) HRESULT {
                return @as(*const IWMResizerProps.VTable, @ptrCast(self.vtable)).SetInterlaceMode(@as(*const IWMResizerProps, @ptrCast(self)), lmode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResizerProps_SetClipRegion(self: *const T, lClipOriXSrc: i32, lClipOriYSrc: i32, lClipWidthSrc: i32, lClipHeightSrc: i32) HRESULT {
                return @as(*const IWMResizerProps.VTable, @ptrCast(self.vtable)).SetClipRegion(@as(*const IWMResizerProps, @ptrCast(self)), lClipOriXSrc, lClipOriYSrc, lClipWidthSrc, lClipHeightSrc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResizerProps_SetFullCropRegion(self: *const T, lClipOriXSrc: i32, lClipOriYSrc: i32, lClipWidthSrc: i32, lClipHeightSrc: i32, lClipOriXDst: i32, lClipOriYDst: i32, lClipWidthDst: i32, lClipHeightDst: i32) HRESULT {
                return @as(*const IWMResizerProps.VTable, @ptrCast(self.vtable)).SetFullCropRegion(@as(*const IWMResizerProps, @ptrCast(self)), lClipOriXSrc, lClipOriYSrc, lClipWidthSrc, lClipHeightSrc, lClipOriXDst, lClipOriYDst, lClipWidthDst, lClipHeightDst);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMResizerProps_GetFullCropRegion(self: *const T, lClipOriXSrc: ?*i32, lClipOriYSrc: ?*i32, lClipWidthSrc: ?*i32, lClipHeightSrc: ?*i32, lClipOriXDst: ?*i32, lClipOriYDst: ?*i32, lClipWidthDst: ?*i32, lClipHeightDst: ?*i32) HRESULT {
                return @as(*const IWMResizerProps.VTable, @ptrCast(self.vtable)).GetFullCropRegion(@as(*const IWMResizerProps, @ptrCast(self)), lClipOriXSrc, lClipOriYSrc, lClipWidthSrc, lClipHeightSrc, lClipOriXDst, lClipOriYDst, lClipWidthDst, lClipHeightDst);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMColorLegalizerProps_Value = Guid.initString("776c93b3-b72d-4508-b6d0-208785f553e7");
pub const IID_IWMColorLegalizerProps = &IID_IWMColorLegalizerProps_Value;
pub const IWMColorLegalizerProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColorLegalizerQuality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMColorLegalizerProps,
                lquality: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMColorLegalizerProps,
                lquality: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMColorLegalizerProps_SetColorLegalizerQuality(self: *const T, lquality: i32) HRESULT {
                return @as(*const IWMColorLegalizerProps.VTable, @ptrCast(self.vtable)).SetColorLegalizerQuality(@as(*const IWMColorLegalizerProps, @ptrCast(self)), lquality);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMInterlaceProps_Value = Guid.initString("7b12e5d1-bd22-48ea-bc06-98e893221c89");
pub const IID_IWMInterlaceProps = &IID_IWMInterlaceProps_Value;
pub const IWMInterlaceProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProcessType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMInterlaceProps,
                iProcessType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMInterlaceProps,
                iProcessType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInitInverseTeleCinePattern: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMInterlaceProps,
                iInitPattern: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMInterlaceProps,
                iInitPattern: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLastFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMInterlaceProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMInterlaceProps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMInterlaceProps_SetProcessType(self: *const T, iProcessType: i32) HRESULT {
                return @as(*const IWMInterlaceProps.VTable, @ptrCast(self.vtable)).SetProcessType(@as(*const IWMInterlaceProps, @ptrCast(self)), iProcessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMInterlaceProps_SetInitInverseTeleCinePattern(self: *const T, iInitPattern: i32) HRESULT {
                return @as(*const IWMInterlaceProps.VTable, @ptrCast(self.vtable)).SetInitInverseTeleCinePattern(@as(*const IWMInterlaceProps, @ptrCast(self)), iInitPattern);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMInterlaceProps_SetLastFrame(self: *const T) HRESULT {
                return @as(*const IWMInterlaceProps.VTable, @ptrCast(self.vtable)).SetLastFrame(@as(*const IWMInterlaceProps, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMFrameInterpProps_Value = Guid.initString("4c06bb9b-626c-4614-8329-cc6a21b93fa0");
pub const IID_IWMFrameInterpProps = &IID_IWMFrameInterpProps_Value;
pub const IWMFrameInterpProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFrameRateIn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMFrameInterpProps,
                lFrameRate: i32,
                lScale: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMFrameInterpProps,
                lFrameRate: i32,
                lScale: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameRateOut: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMFrameInterpProps,
                lFrameRate: i32,
                lScale: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMFrameInterpProps,
                lFrameRate: i32,
                lScale: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameInterpEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMFrameInterpProps,
                bFIEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMFrameInterpProps,
                bFIEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetComplexityLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMFrameInterpProps,
                iComplexity: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMFrameInterpProps,
                iComplexity: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMFrameInterpProps_SetFrameRateIn(self: *const T, lFrameRate: i32, lScale: i32) HRESULT {
                return @as(*const IWMFrameInterpProps.VTable, @ptrCast(self.vtable)).SetFrameRateIn(@as(*const IWMFrameInterpProps, @ptrCast(self)), lFrameRate, lScale);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMFrameInterpProps_SetFrameRateOut(self: *const T, lFrameRate: i32, lScale: i32) HRESULT {
                return @as(*const IWMFrameInterpProps.VTable, @ptrCast(self.vtable)).SetFrameRateOut(@as(*const IWMFrameInterpProps, @ptrCast(self)), lFrameRate, lScale);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMFrameInterpProps_SetFrameInterpEnabled(self: *const T, bFIEnabled: BOOL) HRESULT {
                return @as(*const IWMFrameInterpProps.VTable, @ptrCast(self.vtable)).SetFrameInterpEnabled(@as(*const IWMFrameInterpProps, @ptrCast(self)), bFIEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMFrameInterpProps_SetComplexityLevel(self: *const T, iComplexity: i32) HRESULT {
                return @as(*const IWMFrameInterpProps.VTable, @ptrCast(self.vtable)).SetComplexityLevel(@as(*const IWMFrameInterpProps, @ptrCast(self)), iComplexity);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IWMColorConvProps_Value = Guid.initString("e6a49e22-c099-421d-aad3-c061fb4ae85b");
pub const IID_IWMColorConvProps = &IID_IWMColorConvProps_Value;
pub const IWMColorConvProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMColorConvProps,
                lMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMColorConvProps,
                lMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFullCroppingParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMColorConvProps,
                lSrcCropLeft: i32,
                lSrcCropTop: i32,
                lDstCropLeft: i32,
                lDstCropTop: i32,
                lCropWidth: i32,
                lCropHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMColorConvProps,
                lSrcCropLeft: i32,
                lSrcCropTop: i32,
                lDstCropLeft: i32,
                lDstCropTop: i32,
                lCropWidth: i32,
                lCropHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMColorConvProps_SetMode(self: *const T, lMode: i32) HRESULT {
                return @as(*const IWMColorConvProps.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IWMColorConvProps, @ptrCast(self)), lMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMColorConvProps_SetFullCroppingParam(self: *const T, lSrcCropLeft: i32, lSrcCropTop: i32, lDstCropLeft: i32, lDstCropTop: i32, lCropWidth: i32, lCropHeight: i32) HRESULT {
                return @as(*const IWMColorConvProps.VTable, @ptrCast(self.vtable)).SetFullCroppingParam(@as(*const IWMColorConvProps, @ptrCast(self)), lSrcCropLeft, lSrcCropTop, lDstCropLeft, lDstCropTop, lCropWidth, lCropHeight);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMV_DYNAMIC_FLAGS = enum(i32) {
    BITRATE = 1,
    RESOLUTION = 2,
    COMPLEXITY = 4,
};
pub const WMV_DYNAMIC_BITRATE = WMV_DYNAMIC_FLAGS.BITRATE;
pub const WMV_DYNAMIC_RESOLUTION = WMV_DYNAMIC_FLAGS.RESOLUTION;
pub const WMV_DYNAMIC_COMPLEXITY = WMV_DYNAMIC_FLAGS.COMPLEXITY;

pub const MF_AUVRHP_ROOMMODEL = enum(i32) {
    SMALLROOM = 0,
    MEDIUMROOM = 1,
    BIGROOM = 2,
    CUSTUMIZEDROOM = 3,
};
pub const VRHP_SMALLROOM = MF_AUVRHP_ROOMMODEL.SMALLROOM;
pub const VRHP_MEDIUMROOM = MF_AUVRHP_ROOMMODEL.MEDIUMROOM;
pub const VRHP_BIGROOM = MF_AUVRHP_ROOMMODEL.BIGROOM;
pub const VRHP_CUSTUMIZEDROOM = MF_AUVRHP_ROOMMODEL.CUSTUMIZEDROOM;

pub const AEC_SYSTEM_MODE = enum(i32) {
    SINGLE_CHANNEL_AEC = 0,
    ADAPTIVE_ARRAY_ONLY = 1,
    OPTIBEAM_ARRAY_ONLY = 2,
    ADAPTIVE_ARRAY_AND_AEC = 3,
    OPTIBEAM_ARRAY_AND_AEC = 4,
    SINGLE_CHANNEL_NSAGC = 5,
    MODE_NOT_SET = 6,
};
pub const SINGLE_CHANNEL_AEC = AEC_SYSTEM_MODE.SINGLE_CHANNEL_AEC;
pub const ADAPTIVE_ARRAY_ONLY = AEC_SYSTEM_MODE.ADAPTIVE_ARRAY_ONLY;
pub const OPTIBEAM_ARRAY_ONLY = AEC_SYSTEM_MODE.OPTIBEAM_ARRAY_ONLY;
pub const ADAPTIVE_ARRAY_AND_AEC = AEC_SYSTEM_MODE.ADAPTIVE_ARRAY_AND_AEC;
pub const OPTIBEAM_ARRAY_AND_AEC = AEC_SYSTEM_MODE.OPTIBEAM_ARRAY_AND_AEC;
pub const SINGLE_CHANNEL_NSAGC = AEC_SYSTEM_MODE.SINGLE_CHANNEL_NSAGC;
pub const MODE_NOT_SET = AEC_SYSTEM_MODE.MODE_NOT_SET;

pub const AecQualityMetrics_Struct = extern struct {
    i64Timestamp: i64,
    ConvergenceFlag: u8,
    MicClippedFlag: u8,
    MicSilenceFlag: u8,
    PstvFeadbackFlag: u8,
    SpkClippedFlag: u8,
    SpkMuteFlag: u8,
    GlitchFlag: u8,
    DoubleTalkFlag: u8,
    uGlitchCount: u32,
    uMicClipCount: u32,
    fDuration: f32,
    fTSVariance: f32,
    fTSDriftRate: f32,
    fVoiceLevel: f32,
    fNoiseLevel: f32,
    fERLE: f32,
    fAvgERLE: f32,
    dwReserved: u32,
};

pub const AEC_VAD_MODE = enum(i32) {
    DISABLED = 0,
    NORMAL = 1,
    FOR_AGC = 2,
    FOR_SILENCE_SUPPRESSION = 3,
};
pub const AEC_VAD_DISABLED = AEC_VAD_MODE.DISABLED;
pub const AEC_VAD_NORMAL = AEC_VAD_MODE.NORMAL;
pub const AEC_VAD_FOR_AGC = AEC_VAD_MODE.FOR_AGC;
pub const AEC_VAD_FOR_SILENCE_SUPPRESSION = AEC_VAD_MODE.FOR_SILENCE_SUPPRESSION;

pub const AEC_INPUT_STREAM = enum(i32) {
    CAPTURE_STREAM = 0,
    REFERENCE_STREAM = 1,
};
pub const AEC_CAPTURE_STREAM = AEC_INPUT_STREAM.CAPTURE_STREAM;
pub const AEC_REFERENCE_STREAM = AEC_INPUT_STREAM.REFERENCE_STREAM;

pub const MIC_ARRAY_MODE = enum(i32) {
    SINGLE_CHAN = 0,
    SIMPLE_SUM = 256,
    SINGLE_BEAM = 512,
    FIXED_BEAM = 1024,
    EXTERN_BEAM = 2048,
};
pub const MICARRAY_SINGLE_CHAN = MIC_ARRAY_MODE.SINGLE_CHAN;
pub const MICARRAY_SIMPLE_SUM = MIC_ARRAY_MODE.SIMPLE_SUM;
pub const MICARRAY_SINGLE_BEAM = MIC_ARRAY_MODE.SINGLE_BEAM;
pub const MICARRAY_FIXED_BEAM = MIC_ARRAY_MODE.FIXED_BEAM;
pub const MICARRAY_EXTERN_BEAM = MIC_ARRAY_MODE.EXTERN_BEAM;

pub const MFVideoDSPMode = enum(i32) {
    Passthrough = 1,
    Stabilization = 4,
};
pub const MFVideoDSPMode_Passthrough = MFVideoDSPMode.Passthrough;
pub const MFVideoDSPMode_Stabilization = MFVideoDSPMode.Stabilization;

pub const TOC_DESCRIPTOR = extern struct {
    guidID: Guid,
    wStreamNumber: u16,
    guidType: Guid,
    wLanguageIndex: u16,
};

pub const TOC_ENTRY_DESCRIPTOR = extern struct {
    qwStartTime: u64,
    qwEndTime: u64,
    qwStartPacketOffset: u64,
    qwEndPacketOffset: u64,
    qwRepresentativeFrameTime: u64,
};

pub const TOC_POS_TYPE = enum(i32) {
    INHEADER = 0,
    TOPLEVELOBJECT = 1,
};
pub const TOC_POS_INHEADER = TOC_POS_TYPE.INHEADER;
pub const TOC_POS_TOPLEVELOBJECT = TOC_POS_TYPE.TOPLEVELOBJECT;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITocEntry_Value = Guid.initString("f22f5e06-585c-4def-8523-6555cfbc0cb3");
pub const IID_ITocEntry = &IID_ITocEntry_Value;
pub const ITocEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                pwszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                pwszTitle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                pwTitleSize: ?*u16,
                pwszTitle: ?[*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                pwTitleSize: ?*u16,
                pwszTitle: ?[*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                pDescriptor: ?*TOC_ENTRY_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                pDescriptor: ?*TOC_ENTRY_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                pDescriptor: ?*TOC_ENTRY_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                pDescriptor: ?*TOC_ENTRY_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                dwNumSubEntries: u32,
                pwSubEntryIndices: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                dwNumSubEntries: u32,
                pwSubEntryIndices: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                pdwNumSubEntries: ?*u32,
                pwSubEntryIndices: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                pdwNumSubEntries: ?*u32,
                pwSubEntryIndices: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescriptionData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                dwDescriptionDataSize: u32,
                pbtDescriptionData: ?*u8,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                dwDescriptionDataSize: u32,
                pbtDescriptionData: ?*u8,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntry,
                pdwDescriptionDataSize: ?*u32,
                pbtDescriptionData: ?*u8,
                pGuidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntry,
                pdwDescriptionDataSize: ?*u32,
                pbtDescriptionData: ?*u8,
                pGuidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_SetTitle(self: *const T, pwszTitle: ?[*:0]const u16) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).SetTitle(@as(*const ITocEntry, @ptrCast(self)), pwszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_GetTitle(self: *const T, pwTitleSize: ?*u16, pwszTitle: ?[*:0]u16) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).GetTitle(@as(*const ITocEntry, @ptrCast(self)), pwTitleSize, pwszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_SetDescriptor(self: *const T, pDescriptor: ?*TOC_ENTRY_DESCRIPTOR) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).SetDescriptor(@as(*const ITocEntry, @ptrCast(self)), pDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_GetDescriptor(self: *const T, pDescriptor: ?*TOC_ENTRY_DESCRIPTOR) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).GetDescriptor(@as(*const ITocEntry, @ptrCast(self)), pDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_SetSubEntries(self: *const T, dwNumSubEntries: u32, pwSubEntryIndices: ?*u16) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).SetSubEntries(@as(*const ITocEntry, @ptrCast(self)), dwNumSubEntries, pwSubEntryIndices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_GetSubEntries(self: *const T, pdwNumSubEntries: ?*u32, pwSubEntryIndices: ?*u16) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).GetSubEntries(@as(*const ITocEntry, @ptrCast(self)), pdwNumSubEntries, pwSubEntryIndices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_SetDescriptionData(self: *const T, dwDescriptionDataSize: u32, pbtDescriptionData: ?*u8, pguidType: ?*Guid) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).SetDescriptionData(@as(*const ITocEntry, @ptrCast(self)), dwDescriptionDataSize, pbtDescriptionData, pguidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntry_GetDescriptionData(self: *const T, pdwDescriptionDataSize: ?*u32, pbtDescriptionData: ?*u8, pGuidType: ?*Guid) HRESULT {
                return @as(*const ITocEntry.VTable, @ptrCast(self.vtable)).GetDescriptionData(@as(*const ITocEntry, @ptrCast(self)), pdwDescriptionDataSize, pbtDescriptionData, pGuidType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITocEntryList_Value = Guid.initString("3a8cccbd-0efd-43a3-b838-f38a552ba237");
pub const IID_ITocEntryList = &IID_ITocEntryList_Value;
pub const ITocEntryList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEntryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntryList,
                pdwEntryCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntryList,
                pdwEntryCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntryList,
                dwEntryIndex: u32,
                ppEntry: ?*?*ITocEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntryList,
                dwEntryIndex: u32,
                ppEntry: ?*?*ITocEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntryList,
                pEntry: ?*ITocEntry,
                pdwEntryIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntryList,
                pEntry: ?*ITocEntry,
                pdwEntryIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEntryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntryList,
                dwEntryIndex: u32,
                pEntry: ?*ITocEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntryList,
                dwEntryIndex: u32,
                pEntry: ?*ITocEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEntryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocEntryList,
                dwEntryIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocEntryList,
                dwEntryIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntryList_GetEntryCount(self: *const T, pdwEntryCount: ?*u32) HRESULT {
                return @as(*const ITocEntryList.VTable, @ptrCast(self.vtable)).GetEntryCount(@as(*const ITocEntryList, @ptrCast(self)), pdwEntryCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntryList_GetEntryByIndex(self: *const T, dwEntryIndex: u32, ppEntry: ?*?*ITocEntry) HRESULT {
                return @as(*const ITocEntryList.VTable, @ptrCast(self.vtable)).GetEntryByIndex(@as(*const ITocEntryList, @ptrCast(self)), dwEntryIndex, ppEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntryList_AddEntry(self: *const T, pEntry: ?*ITocEntry, pdwEntryIndex: ?*u32) HRESULT {
                return @as(*const ITocEntryList.VTable, @ptrCast(self.vtable)).AddEntry(@as(*const ITocEntryList, @ptrCast(self)), pEntry, pdwEntryIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntryList_AddEntryByIndex(self: *const T, dwEntryIndex: u32, pEntry: ?*ITocEntry) HRESULT {
                return @as(*const ITocEntryList.VTable, @ptrCast(self.vtable)).AddEntryByIndex(@as(*const ITocEntryList, @ptrCast(self)), dwEntryIndex, pEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocEntryList_RemoveEntryByIndex(self: *const T, dwEntryIndex: u32) HRESULT {
                return @as(*const ITocEntryList.VTable, @ptrCast(self.vtable)).RemoveEntryByIndex(@as(*const ITocEntryList, @ptrCast(self)), dwEntryIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IToc_Value = Guid.initString("d6f05441-a919-423b-91a0-89d5b4a8ab77");
pub const IID_IToc = &IID_IToc_Value;
pub const IToc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pDescriptor: ?*TOC_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pDescriptor: ?*TOC_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pDescriptor: ?*TOC_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pDescriptor: ?*TOC_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pwszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pwszDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pwDescriptionSize: ?*u16,
                pwszDescription: ?[*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pwDescriptionSize: ?*u16,
                pwszDescription: ?[*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                dwContextSize: u32,
                pbtContext: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                dwContextSize: u32,
                pbtContext: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pdwContextSize: ?*u32,
                pbtContext: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pdwContextSize: ?*u32,
                pbtContext: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntryListCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pwCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pwCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntryListByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                wEntryListIndex: u16,
                ppEntryList: ?*?*ITocEntryList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                wEntryListIndex: u16,
                ppEntryList: ?*?*ITocEntryList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEntryList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                pEntryList: ?*ITocEntryList,
                pwEntryListIndex: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                pEntryList: ?*ITocEntryList,
                pwEntryListIndex: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEntryListByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                wEntryListIndex: u16,
                pEntryList: ?*ITocEntryList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                wEntryListIndex: u16,
                pEntryList: ?*ITocEntryList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEntryListByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IToc,
                wEntryListIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IToc,
                wEntryListIndex: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_SetDescriptor(self: *const T, pDescriptor: ?*TOC_DESCRIPTOR) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).SetDescriptor(@as(*const IToc, @ptrCast(self)), pDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_GetDescriptor(self: *const T, pDescriptor: ?*TOC_DESCRIPTOR) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).GetDescriptor(@as(*const IToc, @ptrCast(self)), pDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_SetDescription(self: *const T, pwszDescription: ?[*:0]const u16) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const IToc, @ptrCast(self)), pwszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_GetDescription(self: *const T, pwDescriptionSize: ?*u16, pwszDescription: ?[*:0]u16) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IToc, @ptrCast(self)), pwDescriptionSize, pwszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_SetContext(self: *const T, dwContextSize: u32, pbtContext: ?*u8) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).SetContext(@as(*const IToc, @ptrCast(self)), dwContextSize, pbtContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_GetContext(self: *const T, pdwContextSize: ?*u32, pbtContext: ?*u8) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IToc, @ptrCast(self)), pdwContextSize, pbtContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_GetEntryListCount(self: *const T, pwCount: ?*u16) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).GetEntryListCount(@as(*const IToc, @ptrCast(self)), pwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_GetEntryListByIndex(self: *const T, wEntryListIndex: u16, ppEntryList: ?*?*ITocEntryList) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).GetEntryListByIndex(@as(*const IToc, @ptrCast(self)), wEntryListIndex, ppEntryList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_AddEntryList(self: *const T, pEntryList: ?*ITocEntryList, pwEntryListIndex: ?*u16) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).AddEntryList(@as(*const IToc, @ptrCast(self)), pEntryList, pwEntryListIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_AddEntryListByIndex(self: *const T, wEntryListIndex: u16, pEntryList: ?*ITocEntryList) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).AddEntryListByIndex(@as(*const IToc, @ptrCast(self)), wEntryListIndex, pEntryList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IToc_RemoveEntryListByIndex(self: *const T, wEntryListIndex: u16) HRESULT {
                return @as(*const IToc.VTable, @ptrCast(self.vtable)).RemoveEntryListByIndex(@as(*const IToc, @ptrCast(self)), wEntryListIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITocCollection_Value = Guid.initString("23fee831-ae96-42df-b170-25a04847a3ca");
pub const IID_ITocCollection = &IID_ITocCollection_Value;
pub const ITocCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEntryCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocCollection,
                pdwEntryCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocCollection,
                pdwEntryCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocCollection,
                dwEntryIndex: u32,
                ppToc: ?*?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocCollection,
                dwEntryIndex: u32,
                ppToc: ?*?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocCollection,
                pToc: ?*IToc,
                pdwEntryIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocCollection,
                pToc: ?*IToc,
                pdwEntryIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEntryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocCollection,
                dwEntryIndex: u32,
                pToc: ?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocCollection,
                dwEntryIndex: u32,
                pToc: ?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEntryByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocCollection,
                dwEntryIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocCollection,
                dwEntryIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocCollection_GetEntryCount(self: *const T, pdwEntryCount: ?*u32) HRESULT {
                return @as(*const ITocCollection.VTable, @ptrCast(self.vtable)).GetEntryCount(@as(*const ITocCollection, @ptrCast(self)), pdwEntryCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocCollection_GetEntryByIndex(self: *const T, dwEntryIndex: u32, ppToc: ?*?*IToc) HRESULT {
                return @as(*const ITocCollection.VTable, @ptrCast(self.vtable)).GetEntryByIndex(@as(*const ITocCollection, @ptrCast(self)), dwEntryIndex, ppToc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocCollection_AddEntry(self: *const T, pToc: ?*IToc, pdwEntryIndex: ?*u32) HRESULT {
                return @as(*const ITocCollection.VTable, @ptrCast(self.vtable)).AddEntry(@as(*const ITocCollection, @ptrCast(self)), pToc, pdwEntryIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocCollection_AddEntryByIndex(self: *const T, dwEntryIndex: u32, pToc: ?*IToc) HRESULT {
                return @as(*const ITocCollection.VTable, @ptrCast(self.vtable)).AddEntryByIndex(@as(*const ITocCollection, @ptrCast(self)), dwEntryIndex, pToc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocCollection_RemoveEntryByIndex(self: *const T, dwEntryIndex: u32) HRESULT {
                return @as(*const ITocCollection.VTable, @ptrCast(self.vtable)).RemoveEntryByIndex(@as(*const ITocCollection, @ptrCast(self)), dwEntryIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ITocParser_Value = Guid.initString("ecfb9a55-9298-4f49-887f-0b36206599d2");
pub const IID_ITocParser = &IID_ITocParser_Value;
pub const ITocParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                pwszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                pwszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTocCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                pdwTocCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                pdwTocCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTocByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                dwTocIndex: u32,
                ppToc: ?*?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                dwTocIndex: u32,
                ppToc: ?*?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTocByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                guidTocType: Guid,
                ppTocs: ?*?*ITocCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                guidTocType: Guid,
                ppTocs: ?*?*ITocCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddToc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                pToc: ?*IToc,
                pdwTocIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                pToc: ?*IToc,
                pdwTocIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTocByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                dwTocIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                dwTocIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTocByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                guidTocType: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
                enumTocPosType: TOC_POS_TYPE,
                guidTocType: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITocParser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITocParser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_Init(self: *const T, pwszFileName: ?[*:0]const u16) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).Init(@as(*const ITocParser, @ptrCast(self)), pwszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_GetTocCount(self: *const T, enumTocPosType: TOC_POS_TYPE, pdwTocCount: ?*u32) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).GetTocCount(@as(*const ITocParser, @ptrCast(self)), enumTocPosType, pdwTocCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_GetTocByIndex(self: *const T, enumTocPosType: TOC_POS_TYPE, dwTocIndex: u32, ppToc: ?*?*IToc) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).GetTocByIndex(@as(*const ITocParser, @ptrCast(self)), enumTocPosType, dwTocIndex, ppToc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_GetTocByType(self: *const T, enumTocPosType: TOC_POS_TYPE, guidTocType: Guid, ppTocs: ?*?*ITocCollection) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).GetTocByType(@as(*const ITocParser, @ptrCast(self)), enumTocPosType, guidTocType, ppTocs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_AddToc(self: *const T, enumTocPosType: TOC_POS_TYPE, pToc: ?*IToc, pdwTocIndex: ?*u32) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).AddToc(@as(*const ITocParser, @ptrCast(self)), enumTocPosType, pToc, pdwTocIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_RemoveTocByIndex(self: *const T, enumTocPosType: TOC_POS_TYPE, dwTocIndex: u32) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).RemoveTocByIndex(@as(*const ITocParser, @ptrCast(self)), enumTocPosType, dwTocIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_RemoveTocByType(self: *const T, enumTocPosType: TOC_POS_TYPE, guidTocType: Guid) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).RemoveTocByType(@as(*const ITocParser, @ptrCast(self)), enumTocPosType, guidTocType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITocParser_Commit(self: *const T) HRESULT {
                return @as(*const ITocParser.VTable, @ptrCast(self.vtable)).Commit(@as(*const ITocParser, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FILE_OPENMODE = enum(i32) {
    FAIL_IF_NOT_EXIST = 0,
    FAIL_IF_EXIST = 1,
    RESET_IF_EXIST = 2,
    APPEND_IF_EXIST = 3,
    DELETE_IF_EXIST = 4,
};
pub const OPENMODE_FAIL_IF_NOT_EXIST = FILE_OPENMODE.FAIL_IF_NOT_EXIST;
pub const OPENMODE_FAIL_IF_EXIST = FILE_OPENMODE.FAIL_IF_EXIST;
pub const OPENMODE_RESET_IF_EXIST = FILE_OPENMODE.RESET_IF_EXIST;
pub const OPENMODE_APPEND_IF_EXIST = FILE_OPENMODE.APPEND_IF_EXIST;
pub const OPENMODE_DELETE_IF_EXIST = FILE_OPENMODE.DELETE_IF_EXIST;

pub const SEEK_ORIGIN = enum(i32) {
    Begin = 0,
    Current = 1,
};
pub const _msoBegin = SEEK_ORIGIN.Begin;
pub const _msoCurrent = SEEK_ORIGIN.Current;

pub const FILE_ACCESSMODE = enum(i32) {
    READ = 1,
    WRITE = 2,
    READWRITE = 3,
    WRITE_EXCLUSIVE = 4,
};
pub const ACCESSMODE_READ = FILE_ACCESSMODE.READ;
pub const ACCESSMODE_WRITE = FILE_ACCESSMODE.WRITE;
pub const ACCESSMODE_READWRITE = FILE_ACCESSMODE.READWRITE;
pub const ACCESSMODE_WRITE_EXCLUSIVE = FILE_ACCESSMODE.WRITE_EXCLUSIVE;

const IID_IFileIo_Value = Guid.initString("11993196-1244-4840-ab44-480975c4ffe4");
pub const IID_IFileIo = &IID_IFileIo_Value;
pub const IFileIo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                eAccessMode: FILE_ACCESSMODE,
                eOpenMode: FILE_OPENMODE,
                pwszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                eAccessMode: FILE_ACCESSMODE,
                eOpenMode: FILE_OPENMODE,
                pwszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                pqwLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                pqwLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                qwLength: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                qwLength: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                pqwPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                pqwPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                qwPosition: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                qwPosition: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                pbEndOfStream: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                pbEndOfStream: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                pbt: ?*u8,
                ul: u32,
                pulRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                pbt: ?*u8,
                ul: u32,
                pulRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                pbt: ?*u8,
                ul: u32,
                pulWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                pbt: ?*u8,
                ul: u32,
                pulWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
                eSeekOrigin: SEEK_ORIGIN,
                qwSeekOffset: u64,
                dwSeekFlags: u32,
                pqwCurrentPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
                eSeekOrigin: SEEK_ORIGIN,
                qwSeekOffset: u64,
                dwSeekFlags: u32,
                pqwCurrentPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileIo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileIo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_Initialize(self: *const T, eAccessMode: FILE_ACCESSMODE, eOpenMode: FILE_OPENMODE, pwszFileName: ?[*:0]const u16) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IFileIo, @ptrCast(self)), eAccessMode, eOpenMode, pwszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_GetLength(self: *const T, pqwLength: ?*u64) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IFileIo, @ptrCast(self)), pqwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_SetLength(self: *const T, qwLength: u64) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).SetLength(@as(*const IFileIo, @ptrCast(self)), qwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_GetCurrentPosition(self: *const T, pqwPosition: ?*u64) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).GetCurrentPosition(@as(*const IFileIo, @ptrCast(self)), pqwPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_SetCurrentPosition(self: *const T, qwPosition: u64) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).SetCurrentPosition(@as(*const IFileIo, @ptrCast(self)), qwPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_IsEndOfStream(self: *const T, pbEndOfStream: ?*BOOL) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).IsEndOfStream(@as(*const IFileIo, @ptrCast(self)), pbEndOfStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_Read(self: *const T, pbt: ?*u8, ul: u32, pulRead: ?*u32) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).Read(@as(*const IFileIo, @ptrCast(self)), pbt, ul, pulRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_Write(self: *const T, pbt: ?*u8, ul: u32, pulWritten: ?*u32) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).Write(@as(*const IFileIo, @ptrCast(self)), pbt, ul, pulWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_Seek(self: *const T, eSeekOrigin: SEEK_ORIGIN, qwSeekOffset: u64, dwSeekFlags: u32, pqwCurrentPosition: ?*u64) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).Seek(@as(*const IFileIo, @ptrCast(self)), eSeekOrigin, qwSeekOffset, dwSeekFlags, pqwCurrentPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileIo_Close(self: *const T) HRESULT {
                return @as(*const IFileIo.VTable, @ptrCast(self.vtable)).Close(@as(*const IFileIo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFileClient_Value = Guid.initString("bfccd196-1244-4840-ab44-480975c4ffe4");
pub const IID_IFileClient = &IID_IFileClient_Value;
pub const IFileClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectDiskSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileClient,
                pqwSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileClient,
                pqwSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileClient,
                pFio: ?*IFileIo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileClient,
                pFio: ?*IFileIo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFileClient,
                pFio: ?*IFileIo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFileClient,
                pFio: ?*IFileIo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileClient_GetObjectDiskSize(self: *const T, pqwSize: ?*u64) HRESULT {
                return @as(*const IFileClient.VTable, @ptrCast(self.vtable)).GetObjectDiskSize(@as(*const IFileClient, @ptrCast(self)), pqwSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileClient_Write(self: *const T, pFio: ?*IFileIo) HRESULT {
                return @as(*const IFileClient.VTable, @ptrCast(self.vtable)).Write(@as(*const IFileClient, @ptrCast(self)), pFio);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFileClient_Read(self: *const T, pFio: ?*IFileIo) HRESULT {
                return @as(*const IFileClient.VTable, @ptrCast(self.vtable)).Read(@as(*const IFileClient, @ptrCast(self)), pFio);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IClusterDetector_Value = Guid.initString("3f07f7b7-c680-41d9-9423-915107ec9ff9");
pub const IID_IClusterDetector = &IID_IClusterDetector_Value;
pub const IClusterDetector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClusterDetector,
                wBaseEntryLevel: u16,
                wClusterEntryLevel: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClusterDetector,
                wBaseEntryLevel: u16,
                wClusterEntryLevel: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClusterDetector,
                dwMaxNumClusters: u32,
                fMinClusterDuration: f32,
                fMaxClusterDuration: f32,
                pSrcToc: ?*IToc,
                ppDstToc: ?*?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClusterDetector,
                dwMaxNumClusters: u32,
                fMinClusterDuration: f32,
                fMaxClusterDuration: f32,
                pSrcToc: ?*IToc,
                ppDstToc: ?*?*IToc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClusterDetector_Initialize(self: *const T, wBaseEntryLevel: u16, wClusterEntryLevel: u16) HRESULT {
                return @as(*const IClusterDetector.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IClusterDetector, @ptrCast(self)), wBaseEntryLevel, wClusterEntryLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClusterDetector_Detect(self: *const T, dwMaxNumClusters: u32, fMinClusterDuration: f32, fMaxClusterDuration: f32, pSrcToc: ?*IToc, ppDstToc: ?*?*IToc) HRESULT {
                return @as(*const IClusterDetector.VTable, @ptrCast(self.vtable)).Detect(@as(*const IClusterDetector, @ptrCast(self)), dwMaxNumClusters, fMinClusterDuration, fMaxClusterDuration, pSrcToc, ppDstToc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXVA_AYUVsample2 = extern struct {
    bCrValue: u8,
    bCbValue: u8,
    bY_Value: u8,
    bSampleAlpha8: u8,
};

pub const DXVA_BufferDescription = extern struct {
    dwTypeIndex: u32 align(1),
    dwBufferIndex: u32 align(1),
    dwDataOffset: u32 align(1),
    dwDataSize: u32 align(1),
    dwFirstMBaddress: u32 align(1),
    dwNumMBsInBuffer: u32 align(1),
    dwWidth: u32 align(1),
    dwHeight: u32 align(1),
    dwStride: u32 align(1),
    dwReservedBits: u32 align(1),
};

pub const DXVA_ConfigPictureDecode = extern struct {
    dwFunction: u32 align(1),
    dwReservedBits: [3]u32 align(1),
    guidConfigBitstreamEncryption: Guid align(1),
    guidConfigMBcontrolEncryption: Guid align(1),
    guidConfigResidDiffEncryption: Guid align(1),
    bConfigBitstreamRaw: u8 align(1),
    bConfigMBcontrolRasterOrder: u8 align(1),
    bConfigResidDiffHost: u8 align(1),
    bConfigSpatialResid8: u8 align(1),
    bConfigResid8Subtraction: u8 align(1),
    bConfigSpatialHost8or9Clipping: u8 align(1),
    bConfigSpatialResidInterleaved: u8 align(1),
    bConfigIntraResidUnsigned: u8 align(1),
    bConfigResidDiffAccelerator: u8 align(1),
    bConfigHostInverseScan: u8 align(1),
    bConfigSpecificIDCT: u8 align(1),
    bConfig4GroupedCoefs: u8 align(1),
};

pub const DXVA_PictureParameters = extern struct {
    wDecodedPictureIndex: u16 align(1),
    wDeblockedPictureIndex: u16 align(1),
    wForwardRefPictureIndex: u16 align(1),
    wBackwardRefPictureIndex: u16 align(1),
    wPicWidthInMBminus1: u16 align(1),
    wPicHeightInMBminus1: u16 align(1),
    bMacroblockWidthMinus1: u8 align(1),
    bMacroblockHeightMinus1: u8 align(1),
    bBlockWidthMinus1: u8 align(1),
    bBlockHeightMinus1: u8 align(1),
    bBPPminus1: u8 align(1),
    bPicStructure: u8 align(1),
    bSecondField: u8 align(1),
    bPicIntra: u8 align(1),
    bPicBackwardPrediction: u8 align(1),
    bBidirectionalAveragingMode: u8 align(1),
    bMVprecisionAndChromaRelation: u8 align(1),
    bChromaFormat: u8 align(1),
    bPicScanFixed: u8 align(1),
    bPicScanMethod: u8 align(1),
    bPicReadbackRequests: u8 align(1),
    bRcontrol: u8 align(1),
    bPicSpatialResid8: u8 align(1),
    bPicOverflowBlocks: u8 align(1),
    bPicExtrapolation: u8 align(1),
    bPicDeblocked: u8 align(1),
    bPicDeblockConfined: u8 align(1),
    bPic4MVallowed: u8 align(1),
    bPicOBMC: u8 align(1),
    bPicBinPB: u8 align(1),
    bMV_RPS: u8 align(1),
    bReservedBits: u8 align(1),
    wBitstreamFcodes: u16 align(1),
    wBitstreamPCEelements: u16 align(1),
    bBitstreamConcealmentNeed: u8 align(1),
    bBitstreamConcealmentMethod: u8 align(1),
};

pub const DXVAUncompDataInfo = extern struct {
    UncompWidth: u32,
    UncompHeight: u32,
    UncompFormat: D3DFORMAT,
};

pub const DXVACompBufferInfo = extern struct {
    NumCompBuffers: u32,
    WidthToCreate: u32,
    HeightToCreate: u32,
    BytesToAllocate: u32,
    Usage: u32,
    Pool: D3DPOOL,
    Format: D3DFORMAT,
};

pub const DXVABufferInfo = extern struct {
    pCompSurface: ?*anyopaque,
    DataOffset: u32,
    DataSize: u32,
};

pub const DXVA_SampleFormat = enum(i32) {
    FormatMask = 255,
    Unknown = 0,
    PreviousFrame = 1,
    ProgressiveFrame = 2,
    FieldInterleavedEvenFirst = 3,
    FieldInterleavedOddFirst = 4,
    FieldSingleEven = 5,
    FieldSingleOdd = 6,
    SubStream = 7,
};
pub const DXVA_SampleFormatMask = DXVA_SampleFormat.FormatMask;
pub const DXVA_SampleUnknown = DXVA_SampleFormat.Unknown;
pub const DXVA_SamplePreviousFrame = DXVA_SampleFormat.PreviousFrame;
pub const DXVA_SampleProgressiveFrame = DXVA_SampleFormat.ProgressiveFrame;
pub const DXVA_SampleFieldInterleavedEvenFirst = DXVA_SampleFormat.FieldInterleavedEvenFirst;
pub const DXVA_SampleFieldInterleavedOddFirst = DXVA_SampleFormat.FieldInterleavedOddFirst;
pub const DXVA_SampleFieldSingleEven = DXVA_SampleFormat.FieldSingleEven;
pub const DXVA_SampleFieldSingleOdd = DXVA_SampleFormat.FieldSingleOdd;
pub const DXVA_SampleSubStream = DXVA_SampleFormat.SubStream;

pub const DXVA_VideoTransferFunction = enum(i32) {
    Shift = 27,
    Mask = -134217728,
    _Unknown = 0,
    _10 = 1,
    _18 = 2,
    _20 = 3,
    _22 = 4,
    _22_709 = 5,
    _22_240M = 6,
    _22_8bit_sRGB = 7,
    _28 = 8,
};
pub const DXVA_VideoTransFuncShift = DXVA_VideoTransferFunction.Shift;
pub const DXVA_VideoTransFuncMask = DXVA_VideoTransferFunction.Mask;
pub const DXVA_VideoTransFunc_Unknown = DXVA_VideoTransferFunction._Unknown;
pub const DXVA_VideoTransFunc_10 = DXVA_VideoTransferFunction._10;
pub const DXVA_VideoTransFunc_18 = DXVA_VideoTransferFunction._18;
pub const DXVA_VideoTransFunc_20 = DXVA_VideoTransferFunction._20;
pub const DXVA_VideoTransFunc_22 = DXVA_VideoTransferFunction._22;
pub const DXVA_VideoTransFunc_22_709 = DXVA_VideoTransferFunction._22_709;
pub const DXVA_VideoTransFunc_22_240M = DXVA_VideoTransferFunction._22_240M;
pub const DXVA_VideoTransFunc_22_8bit_sRGB = DXVA_VideoTransferFunction._22_8bit_sRGB;
pub const DXVA_VideoTransFunc_28 = DXVA_VideoTransferFunction._28;

pub const DXVA_VideoPrimaries = enum(i32) {
    Shift = 22,
    Mask = 130023424,
    _Unknown = 0,
    _reserved = 1,
    _BT709 = 2,
    _BT470_2_SysM = 3,
    _BT470_2_SysBG = 4,
    _SMPTE170M = 5,
    _SMPTE240M = 6,
    _EBU3213 = 7,
    _SMPTE_C = 8,
};
pub const DXVA_VideoPrimariesShift = DXVA_VideoPrimaries.Shift;
pub const DXVA_VideoPrimariesMask = DXVA_VideoPrimaries.Mask;
pub const DXVA_VideoPrimaries_Unknown = DXVA_VideoPrimaries._Unknown;
pub const DXVA_VideoPrimaries_reserved = DXVA_VideoPrimaries._reserved;
pub const DXVA_VideoPrimaries_BT709 = DXVA_VideoPrimaries._BT709;
pub const DXVA_VideoPrimaries_BT470_2_SysM = DXVA_VideoPrimaries._BT470_2_SysM;
pub const DXVA_VideoPrimaries_BT470_2_SysBG = DXVA_VideoPrimaries._BT470_2_SysBG;
pub const DXVA_VideoPrimaries_SMPTE170M = DXVA_VideoPrimaries._SMPTE170M;
pub const DXVA_VideoPrimaries_SMPTE240M = DXVA_VideoPrimaries._SMPTE240M;
pub const DXVA_VideoPrimaries_EBU3213 = DXVA_VideoPrimaries._EBU3213;
pub const DXVA_VideoPrimaries_SMPTE_C = DXVA_VideoPrimaries._SMPTE_C;

pub const DXVA_VideoLighting = enum(i32) {
    Shift = 18,
    Mask = 3932160,
    _Unknown = 0,
    _bright = 1,
    _office = 2,
    _dim = 3,
    _dark = 4,
};
pub const DXVA_VideoLightingShift = DXVA_VideoLighting.Shift;
pub const DXVA_VideoLightingMask = DXVA_VideoLighting.Mask;
pub const DXVA_VideoLighting_Unknown = DXVA_VideoLighting._Unknown;
pub const DXVA_VideoLighting_bright = DXVA_VideoLighting._bright;
pub const DXVA_VideoLighting_office = DXVA_VideoLighting._office;
pub const DXVA_VideoLighting_dim = DXVA_VideoLighting._dim;
pub const DXVA_VideoLighting_dark = DXVA_VideoLighting._dark;

pub const DXVA_VideoTransferMatrix = enum(i32) {
    Shift = 15,
    Mask = 229376,
    _Unknown = 0,
    _BT709 = 1,
    _BT601 = 2,
    _SMPTE240M = 3,
};
pub const DXVA_VideoTransferMatrixShift = DXVA_VideoTransferMatrix.Shift;
pub const DXVA_VideoTransferMatrixMask = DXVA_VideoTransferMatrix.Mask;
pub const DXVA_VideoTransferMatrix_Unknown = DXVA_VideoTransferMatrix._Unknown;
pub const DXVA_VideoTransferMatrix_BT709 = DXVA_VideoTransferMatrix._BT709;
pub const DXVA_VideoTransferMatrix_BT601 = DXVA_VideoTransferMatrix._BT601;
pub const DXVA_VideoTransferMatrix_SMPTE240M = DXVA_VideoTransferMatrix._SMPTE240M;

pub const DXVA_NominalRange = enum(i32) {
    Shift = 12,
    Mask = 28672,
    _Unknown = 0,
    _Normal = 1,
    _Wide = 2,
    // _0_255 = 1, this enum value conflicts with _Normal
    // _16_235 = 2, this enum value conflicts with _Wide
    _48_208 = 3,
};
pub const DXVA_NominalRangeShift = DXVA_NominalRange.Shift;
pub const DXVA_NominalRangeMask = DXVA_NominalRange.Mask;
pub const DXVA_NominalRange_Unknown = DXVA_NominalRange._Unknown;
pub const DXVA_NominalRange_Normal = DXVA_NominalRange._Normal;
pub const DXVA_NominalRange_Wide = DXVA_NominalRange._Wide;
pub const DXVA_NominalRange_0_255 = DXVA_NominalRange._Normal;
pub const DXVA_NominalRange_16_235 = DXVA_NominalRange._Wide;
pub const DXVA_NominalRange_48_208 = DXVA_NominalRange._48_208;

pub const DXVA_VideoChromaSubsampling = enum(i32) {
    Shift = 8,
    Mask = 3840,
    _Unknown = 0,
    // _ProgressiveChroma = 8, this enum value conflicts with Shift
    _Horizontally_Cosited = 4,
    _Vertically_Cosited = 2,
    _Vertically_AlignedChromaPlanes = 1,
    _MPEG2 = 5,
    // _MPEG1 = 1, this enum value conflicts with _Vertically_AlignedChromaPlanes
    _DV_PAL = 6,
    _Cosited = 7,
};
pub const DXVA_VideoChromaSubsamplingShift = DXVA_VideoChromaSubsampling.Shift;
pub const DXVA_VideoChromaSubsamplingMask = DXVA_VideoChromaSubsampling.Mask;
pub const DXVA_VideoChromaSubsampling_Unknown = DXVA_VideoChromaSubsampling._Unknown;
pub const DXVA_VideoChromaSubsampling_ProgressiveChroma = DXVA_VideoChromaSubsampling.Shift;
pub const DXVA_VideoChromaSubsampling_Horizontally_Cosited = DXVA_VideoChromaSubsampling._Horizontally_Cosited;
pub const DXVA_VideoChromaSubsampling_Vertically_Cosited = DXVA_VideoChromaSubsampling._Vertically_Cosited;
pub const DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = DXVA_VideoChromaSubsampling._Vertically_AlignedChromaPlanes;
pub const DXVA_VideoChromaSubsampling_MPEG2 = DXVA_VideoChromaSubsampling._MPEG2;
pub const DXVA_VideoChromaSubsampling_MPEG1 = DXVA_VideoChromaSubsampling._Vertically_AlignedChromaPlanes;
pub const DXVA_VideoChromaSubsampling_DV_PAL = DXVA_VideoChromaSubsampling._DV_PAL;
pub const DXVA_VideoChromaSubsampling_Cosited = DXVA_VideoChromaSubsampling._Cosited;

pub const DXVA_ExtendedFormat = extern struct {
    _bitfield: u32,
};

pub const DXVA_Frequency = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXVA_VideoDesc = extern struct {
    Size: u32,
    SampleWidth: u32,
    SampleHeight: u32,
    SampleFormat: u32,
    d3dFormat: D3DFORMAT,
    InputSampleFreq: DXVA_Frequency,
    OutputFrameFreq: DXVA_Frequency,
};

pub const DXVA_VideoProcessCaps = enum(i32) {
    None = 0,
    YUV2RGB = 1,
    StretchX = 2,
    StretchY = 4,
    AlphaBlend = 8,
    SubRects = 16,
    SubStreams = 32,
    SubStreamsExtended = 64,
    YUV2RGBExtended = 128,
    AlphaBlendExtended = 256,
};
pub const DXVA_VideoProcess_None = DXVA_VideoProcessCaps.None;
pub const DXVA_VideoProcess_YUV2RGB = DXVA_VideoProcessCaps.YUV2RGB;
pub const DXVA_VideoProcess_StretchX = DXVA_VideoProcessCaps.StretchX;
pub const DXVA_VideoProcess_StretchY = DXVA_VideoProcessCaps.StretchY;
pub const DXVA_VideoProcess_AlphaBlend = DXVA_VideoProcessCaps.AlphaBlend;
pub const DXVA_VideoProcess_SubRects = DXVA_VideoProcessCaps.SubRects;
pub const DXVA_VideoProcess_SubStreams = DXVA_VideoProcessCaps.SubStreams;
pub const DXVA_VideoProcess_SubStreamsExtended = DXVA_VideoProcessCaps.SubStreamsExtended;
pub const DXVA_VideoProcess_YUV2RGBExtended = DXVA_VideoProcessCaps.YUV2RGBExtended;
pub const DXVA_VideoProcess_AlphaBlendExtended = DXVA_VideoProcessCaps.AlphaBlendExtended;

pub const DXVA_DeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    BOBVerticalStretch4Tap = 256,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DXVA_DeinterlaceTech_Unknown = DXVA_DeinterlaceTech.Unknown;
pub const DXVA_DeinterlaceTech_BOBLineReplicate = DXVA_DeinterlaceTech.BOBLineReplicate;
pub const DXVA_DeinterlaceTech_BOBVerticalStretch = DXVA_DeinterlaceTech.BOBVerticalStretch;
pub const DXVA_DeinterlaceTech_BOBVerticalStretch4Tap = DXVA_DeinterlaceTech.BOBVerticalStretch4Tap;
pub const DXVA_DeinterlaceTech_MedianFiltering = DXVA_DeinterlaceTech.MedianFiltering;
pub const DXVA_DeinterlaceTech_EdgeFiltering = DXVA_DeinterlaceTech.EdgeFiltering;
pub const DXVA_DeinterlaceTech_FieldAdaptive = DXVA_DeinterlaceTech.FieldAdaptive;
pub const DXVA_DeinterlaceTech_PixelAdaptive = DXVA_DeinterlaceTech.PixelAdaptive;
pub const DXVA_DeinterlaceTech_MotionVectorSteered = DXVA_DeinterlaceTech.MotionVectorSteered;

pub const DXVA_VideoSample = extern struct {
    rtStart: i64,
    rtEnd: i64,
    SampleFormat: DXVA_SampleFormat,
    lpDDSSrcSurface: ?*anyopaque,
};

pub const DXVA_SampleFlags = enum(i32) {
    sMask = 15,
    _Palette_Changed = 1,
    _SrcRect_Changed = 2,
    _DstRect_Changed = 4,
    _ColorData_Changed = 8,
};
pub const DXVA_SampleFlagsMask = DXVA_SampleFlags.sMask;
pub const DXVA_SampleFlag_Palette_Changed = DXVA_SampleFlags._Palette_Changed;
pub const DXVA_SampleFlag_SrcRect_Changed = DXVA_SampleFlags._SrcRect_Changed;
pub const DXVA_SampleFlag_DstRect_Changed = DXVA_SampleFlags._DstRect_Changed;
pub const DXVA_SampleFlag_ColorData_Changed = DXVA_SampleFlags._ColorData_Changed;

pub const DXVA_DestinationFlags = enum(i32) {
    Mask = 15,
    _Background_Changed = 1,
    _TargetRect_Changed = 2,
    _ColorData_Changed = 4,
    _Alpha_Changed = 8,
};
pub const DXVA_DestinationFlagMask = DXVA_DestinationFlags.Mask;
pub const DXVA_DestinationFlag_Background_Changed = DXVA_DestinationFlags._Background_Changed;
pub const DXVA_DestinationFlag_TargetRect_Changed = DXVA_DestinationFlags._TargetRect_Changed;
pub const DXVA_DestinationFlag_ColorData_Changed = DXVA_DestinationFlags._ColorData_Changed;
pub const DXVA_DestinationFlag_Alpha_Changed = DXVA_DestinationFlags._Alpha_Changed;

pub const DXVA_DeinterlaceCaps = extern struct {
    Size: u32,
    NumPreviousOutputFrames: u32,
    InputPool: u32,
    NumForwardRefSamples: u32,
    NumBackwardRefSamples: u32,
    d3dOutputFormat: D3DFORMAT,
    VideoProcessingCaps: DXVA_VideoProcessCaps,
    DeinterlaceTechnology: DXVA_DeinterlaceTech,
};

pub const DXVA_DeinterlaceBlt = extern struct {
    Size: u32,
    Reserved: u32,
    rtTarget: i64,
    DstRect: RECT,
    SrcRect: RECT,
    NumSourceSurfaces: u32,
    Alpha: f32,
    Source: [32]DXVA_VideoSample,
};

pub const DXVA_DeinterlaceBltEx = extern struct {
    Size: u32,
    BackgroundColor: DXVA_AYUVsample2,
    rcTarget: RECT,
    rtTarget: i64,
    NumSourceSurfaces: u32,
    Alpha: f32,
    Source: [32]DXVA_VideoSample2,
    DestinationFormat: u32,
    DestinationFlags: u32,
};

pub const DXVA_DeinterlaceQueryAvailableModes = extern struct {
    Size: u32,
    NumGuids: u32,
    Guids: [32]Guid,
};

pub const DXVA_DeinterlaceQueryModeCaps = extern struct {
    Size: u32,
    Guid: Guid,
    VideoDesc: DXVA_VideoDesc,
};

pub const DXVA_ProcAmpControlProp = enum(i32) {
    None = 0,
    Brightness = 1,
    Contrast = 2,
    Hue = 4,
    Saturation = 8,
};
pub const DXVA_ProcAmp_None = DXVA_ProcAmpControlProp.None;
pub const DXVA_ProcAmp_Brightness = DXVA_ProcAmpControlProp.Brightness;
pub const DXVA_ProcAmp_Contrast = DXVA_ProcAmpControlProp.Contrast;
pub const DXVA_ProcAmp_Hue = DXVA_ProcAmpControlProp.Hue;
pub const DXVA_ProcAmp_Saturation = DXVA_ProcAmpControlProp.Saturation;

pub const DXVA_ProcAmpControlCaps = extern struct {
    Size: u32,
    InputPool: u32,
    d3dOutputFormat: D3DFORMAT,
    ProcAmpControlProps: u32,
    VideoProcessingCaps: u32,
};

pub const DXVA_ProcAmpControlQueryRange = extern struct {
    Size: u32,
    ProcAmpControlProp: DXVA_ProcAmpControlProp,
    VideoDesc: DXVA_VideoDesc,
};

pub const DXVA_VideoPropertyRange = extern struct {
    MinValue: f32,
    MaxValue: f32,
    DefaultValue: f32,
    StepSize: f32,
};

pub const DXVA_ProcAmpControlBlt = extern struct {
    Size: u32,
    DstRect: RECT,
    SrcRect: RECT,
    Alpha: f32,
    Brightness: f32,
    Contrast: f32,
    Hue: f32,
    Saturation: f32,
};

pub const DXVA_COPPSignature = extern struct {
    Signature: [256]u8,
};

pub const DXVA_COPPCommand = extern struct {
    macKDI: Guid,
    guidCommandID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    CommandData: [4056]u8,
};

pub const DXVA_COPPStatusInput = extern struct {
    rApp: Guid,
    guidStatusRequestID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    StatusData: [4056]u8,
};

pub const DXVA_COPPStatusOutput = extern struct {
    macKDI: Guid,
    cbSizeData: u32,
    COPPStatus: [4076]u8,
};

const CLSID_CODECAPI_AVEncCommonFormatConstraint_Value = Guid.initString("57cbb9b8-116f-4951-b40c-c2a035ed8f17");
pub const CLSID_CODECAPI_AVEncCommonFormatConstraint = &CLSID_CODECAPI_AVEncCommonFormatConstraint_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatUnSpecified_Value = Guid.initString("af46a35a-6024-4525-a48a-094b97f5b3c2");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatUnSpecified = &CLSID_CODECAPI_GUID_AVEncCommonFormatUnSpecified_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_V_Value = Guid.initString("cc9598c4-e7fe-451d-b1ca-761bc840b7f3");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_V = &CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_V_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_DashVR_Value = Guid.initString("e55199d6-044c-4dae-a488-531ed306235b");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_DashVR = &CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_DashVR_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR_Value = Guid.initString("e74c6f2e-ec37-478d-9af4-a5e135b6271c");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR = &CLSID_CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatVCD_Value = Guid.initString("95035bf7-9d90-40ff-ad5c-5cf8cf71ca1d");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatVCD = &CLSID_CODECAPI_GUID_AVEncCommonFormatVCD_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatSVCD_Value = Guid.initString("51d85818-8220-448c-8066-d69bed16c9ad");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatSVCD = &CLSID_CODECAPI_GUID_AVEncCommonFormatSVCD_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatATSC_Value = Guid.initString("8d7b897c-a019-4670-aa76-2edcac7ac296");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatATSC = &CLSID_CODECAPI_GUID_AVEncCommonFormatATSC_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatDVB_Value = Guid.initString("71830d8f-6c33-430d-844b-c2705baae6db");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatDVB = &CLSID_CODECAPI_GUID_AVEncCommonFormatDVB_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatMP3_Value = Guid.initString("349733cd-eb08-4dc2-8197-e49835ef828b");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatMP3 = &CLSID_CODECAPI_GUID_AVEncCommonFormatMP3_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatHighMAT_Value = Guid.initString("1eabe760-fb2b-4928-90d1-78db88eee889");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatHighMAT = &CLSID_CODECAPI_GUID_AVEncCommonFormatHighMAT_Value;

const CLSID_CODECAPI_GUID_AVEncCommonFormatHighMPV_Value = Guid.initString("a2d25db8-b8f9-42c2-8bc7-0b93cf604788");
pub const CLSID_CODECAPI_GUID_AVEncCommonFormatHighMPV = &CLSID_CODECAPI_GUID_AVEncCommonFormatHighMPV_Value;

const CLSID_CODECAPI_AVEncCodecType_Value = Guid.initString("08af4ac1-f3f2-4c74-9dcf-37f2ec79f826");
pub const CLSID_CODECAPI_AVEncCodecType = &CLSID_CODECAPI_AVEncCodecType_Value;

const CLSID_CODECAPI_GUID_AVEncMPEG1Video_Value = Guid.initString("c8dafefe-da1e-4774-b27d-11830c16b1fe");
pub const CLSID_CODECAPI_GUID_AVEncMPEG1Video = &CLSID_CODECAPI_GUID_AVEncMPEG1Video_Value;

const CLSID_CODECAPI_GUID_AVEncMPEG2Video_Value = Guid.initString("046dc19a-6677-4aaa-a31d-c1ab716f4560");
pub const CLSID_CODECAPI_GUID_AVEncMPEG2Video = &CLSID_CODECAPI_GUID_AVEncMPEG2Video_Value;

const CLSID_CODECAPI_GUID_AVEncMPEG1Audio_Value = Guid.initString("d4dd1362-cd4a-4cd6-8138-b94db4542b04");
pub const CLSID_CODECAPI_GUID_AVEncMPEG1Audio = &CLSID_CODECAPI_GUID_AVEncMPEG1Audio_Value;

const CLSID_CODECAPI_GUID_AVEncMPEG2Audio_Value = Guid.initString("ee4cbb1f-9c3f-4770-92b5-fcb7c2a8d381");
pub const CLSID_CODECAPI_GUID_AVEncMPEG2Audio = &CLSID_CODECAPI_GUID_AVEncMPEG2Audio_Value;

const CLSID_CODECAPI_GUID_AVEncWMV_Value = Guid.initString("4e0fef9b-1d43-41bd-b8bd-4d7bf7457a2a");
pub const CLSID_CODECAPI_GUID_AVEncWMV = &CLSID_CODECAPI_GUID_AVEncWMV_Value;

const CLSID_CODECAPI_GUID_AVEndMPEG4Video_Value = Guid.initString("dd37b12a-9503-4f8b-b8d0-324a00c0a1cf");
pub const CLSID_CODECAPI_GUID_AVEndMPEG4Video = &CLSID_CODECAPI_GUID_AVEndMPEG4Video_Value;

const CLSID_CODECAPI_GUID_AVEncH264Video_Value = Guid.initString("95044eab-31b3-47de-8e75-38a42bb03e28");
pub const CLSID_CODECAPI_GUID_AVEncH264Video = &CLSID_CODECAPI_GUID_AVEncH264Video_Value;

const CLSID_CODECAPI_GUID_AVEncDV_Value = Guid.initString("09b769c7-3329-44fb-8954-fa30937d3d5a");
pub const CLSID_CODECAPI_GUID_AVEncDV = &CLSID_CODECAPI_GUID_AVEncDV_Value;

const CLSID_CODECAPI_GUID_AVEncWMAPro_Value = Guid.initString("1955f90c-33f7-4a68-ab81-53f5657125c4");
pub const CLSID_CODECAPI_GUID_AVEncWMAPro = &CLSID_CODECAPI_GUID_AVEncWMAPro_Value;

const CLSID_CODECAPI_GUID_AVEncWMALossless_Value = Guid.initString("55ca7265-23d8-4761-9031-b74fbe12f4c1");
pub const CLSID_CODECAPI_GUID_AVEncWMALossless = &CLSID_CODECAPI_GUID_AVEncWMALossless_Value;

const CLSID_CODECAPI_GUID_AVEncWMAVoice_Value = Guid.initString("13ed18cb-50e8-4276-a288-a6aa228382d9");
pub const CLSID_CODECAPI_GUID_AVEncWMAVoice = &CLSID_CODECAPI_GUID_AVEncWMAVoice_Value;

const CLSID_CODECAPI_GUID_AVEncDolbyDigitalPro_Value = Guid.initString("f5be76cc-0ff8-40eb-9cb1-bba94004d44f");
pub const CLSID_CODECAPI_GUID_AVEncDolbyDigitalPro = &CLSID_CODECAPI_GUID_AVEncDolbyDigitalPro_Value;

const CLSID_CODECAPI_GUID_AVEncDolbyDigitalConsumer_Value = Guid.initString("c1a7bf6c-0059-4bfa-94ef-ef747a768d52");
pub const CLSID_CODECAPI_GUID_AVEncDolbyDigitalConsumer = &CLSID_CODECAPI_GUID_AVEncDolbyDigitalConsumer_Value;

const CLSID_CODECAPI_GUID_AVEncDolbyDigitalPlus_Value = Guid.initString("698d1b80-f7dd-415c-971c-42492a2056c6");
pub const CLSID_CODECAPI_GUID_AVEncDolbyDigitalPlus = &CLSID_CODECAPI_GUID_AVEncDolbyDigitalPlus_Value;

const CLSID_CODECAPI_GUID_AVEncDTSHD_Value = Guid.initString("2052e630-469d-4bfb-80ca-1d656e7e918f");
pub const CLSID_CODECAPI_GUID_AVEncDTSHD = &CLSID_CODECAPI_GUID_AVEncDTSHD_Value;

const CLSID_CODECAPI_GUID_AVEncDTS_Value = Guid.initString("45fbcaa2-5e6e-4ab0-8893-5903bee93acf");
pub const CLSID_CODECAPI_GUID_AVEncDTS = &CLSID_CODECAPI_GUID_AVEncDTS_Value;

const CLSID_CODECAPI_GUID_AVEncMLP_Value = Guid.initString("05f73e29-f0d1-431e-a41c-a47432ec5a66");
pub const CLSID_CODECAPI_GUID_AVEncMLP = &CLSID_CODECAPI_GUID_AVEncMLP_Value;

const CLSID_CODECAPI_GUID_AVEncPCM_Value = Guid.initString("844be7f4-26cf-4779-b386-cc05d187990c");
pub const CLSID_CODECAPI_GUID_AVEncPCM = &CLSID_CODECAPI_GUID_AVEncPCM_Value;

const CLSID_CODECAPI_GUID_AVEncSDDS_Value = Guid.initString("1dc1b82f-11c8-4c71-b7b6-ee3eb9bc2b94");
pub const CLSID_CODECAPI_GUID_AVEncSDDS = &CLSID_CODECAPI_GUID_AVEncSDDS_Value;

const CLSID_CODECAPI_AVEncCommonRateControlMode_Value = Guid.initString("1c0608e9-370c-4710-8a58-cb6181c42423");
pub const CLSID_CODECAPI_AVEncCommonRateControlMode = &CLSID_CODECAPI_AVEncCommonRateControlMode_Value;

pub const eAVEncCommonRateControlMode = enum(i32) {
    CBR = 0,
    PeakConstrainedVBR = 1,
    UnconstrainedVBR = 2,
    Quality = 3,
    LowDelayVBR = 4,
    GlobalVBR = 5,
    GlobalLowDelayVBR = 6,
};
pub const eAVEncCommonRateControlMode_CBR = eAVEncCommonRateControlMode.CBR;
pub const eAVEncCommonRateControlMode_PeakConstrainedVBR = eAVEncCommonRateControlMode.PeakConstrainedVBR;
pub const eAVEncCommonRateControlMode_UnconstrainedVBR = eAVEncCommonRateControlMode.UnconstrainedVBR;
pub const eAVEncCommonRateControlMode_Quality = eAVEncCommonRateControlMode.Quality;
pub const eAVEncCommonRateControlMode_LowDelayVBR = eAVEncCommonRateControlMode.LowDelayVBR;
pub const eAVEncCommonRateControlMode_GlobalVBR = eAVEncCommonRateControlMode.GlobalVBR;
pub const eAVEncCommonRateControlMode_GlobalLowDelayVBR = eAVEncCommonRateControlMode.GlobalLowDelayVBR;

const CLSID_CODECAPI_AVEncCommonLowLatency_Value = Guid.initString("9d3ecd55-89e8-490a-970a-0c9548d5a56e");
pub const CLSID_CODECAPI_AVEncCommonLowLatency = &CLSID_CODECAPI_AVEncCommonLowLatency_Value;

const CLSID_CODECAPI_AVEncCommonMultipassMode_Value = Guid.initString("22533d4c-47e1-41b5-9352-a2b7780e7ac4");
pub const CLSID_CODECAPI_AVEncCommonMultipassMode = &CLSID_CODECAPI_AVEncCommonMultipassMode_Value;

const CLSID_CODECAPI_AVEncCommonPassStart_Value = Guid.initString("6a67739f-4eb5-4385-9928-f276a939ef95");
pub const CLSID_CODECAPI_AVEncCommonPassStart = &CLSID_CODECAPI_AVEncCommonPassStart_Value;

const CLSID_CODECAPI_AVEncCommonPassEnd_Value = Guid.initString("0e3d01bc-c85c-467d-8b60-c41012ee3bf6");
pub const CLSID_CODECAPI_AVEncCommonPassEnd = &CLSID_CODECAPI_AVEncCommonPassEnd_Value;

const CLSID_CODECAPI_AVEncCommonRealTime_Value = Guid.initString("143a0ff6-a131-43da-b81e-98fbb8ec378e");
pub const CLSID_CODECAPI_AVEncCommonRealTime = &CLSID_CODECAPI_AVEncCommonRealTime_Value;

const CLSID_CODECAPI_AVEncCommonQuality_Value = Guid.initString("fcbf57a3-7ea5-4b0c-9644-69b40c39c391");
pub const CLSID_CODECAPI_AVEncCommonQuality = &CLSID_CODECAPI_AVEncCommonQuality_Value;

const CLSID_CODECAPI_AVEncCommonQualityVsSpeed_Value = Guid.initString("98332df8-03cd-476b-89fa-3f9e442dec9f");
pub const CLSID_CODECAPI_AVEncCommonQualityVsSpeed = &CLSID_CODECAPI_AVEncCommonQualityVsSpeed_Value;

const CLSID_CODECAPI_AVEncCommonTranscodeEncodingProfile_Value = Guid.initString("6947787c-f508-4ea9-b1e9-a1fe3a49fbc9");
pub const CLSID_CODECAPI_AVEncCommonTranscodeEncodingProfile = &CLSID_CODECAPI_AVEncCommonTranscodeEncodingProfile_Value;

const CLSID_CODECAPI_AVEncCommonMeanBitRate_Value = Guid.initString("f7222374-2144-4815-b550-a37f8e12ee52");
pub const CLSID_CODECAPI_AVEncCommonMeanBitRate = &CLSID_CODECAPI_AVEncCommonMeanBitRate_Value;

const CLSID_CODECAPI_AVEncCommonMeanBitRateInterval_Value = Guid.initString("bfaa2f0c-cb82-4bc0-8474-f06a8a0d0258");
pub const CLSID_CODECAPI_AVEncCommonMeanBitRateInterval = &CLSID_CODECAPI_AVEncCommonMeanBitRateInterval_Value;

const CLSID_CODECAPI_AVEncCommonMaxBitRate_Value = Guid.initString("9651eae4-39b9-4ebf-85ef-d7f444ec7465");
pub const CLSID_CODECAPI_AVEncCommonMaxBitRate = &CLSID_CODECAPI_AVEncCommonMaxBitRate_Value;

const CLSID_CODECAPI_AVEncCommonMinBitRate_Value = Guid.initString("101405b2-2083-4034-a806-efbeddd7c9ff");
pub const CLSID_CODECAPI_AVEncCommonMinBitRate = &CLSID_CODECAPI_AVEncCommonMinBitRate_Value;

const CLSID_CODECAPI_AVEncCommonBufferSize_Value = Guid.initString("0db96574-b6a4-4c8b-8106-3773de0310cd");
pub const CLSID_CODECAPI_AVEncCommonBufferSize = &CLSID_CODECAPI_AVEncCommonBufferSize_Value;

const CLSID_CODECAPI_AVEncCommonBufferInLevel_Value = Guid.initString("d9c5c8db-fc74-4064-94e9-cd19f947ed45");
pub const CLSID_CODECAPI_AVEncCommonBufferInLevel = &CLSID_CODECAPI_AVEncCommonBufferInLevel_Value;

const CLSID_CODECAPI_AVEncCommonBufferOutLevel_Value = Guid.initString("ccae7f49-d0bc-4e3d-a57e-fb5740140069");
pub const CLSID_CODECAPI_AVEncCommonBufferOutLevel = &CLSID_CODECAPI_AVEncCommonBufferOutLevel_Value;

const CLSID_CODECAPI_AVEncCommonStreamEndHandling_Value = Guid.initString("6aad30af-6ba8-4ccc-8fca-18d19beaeb1c");
pub const CLSID_CODECAPI_AVEncCommonStreamEndHandling = &CLSID_CODECAPI_AVEncCommonStreamEndHandling_Value;

pub const eAVEncCommonStreamEndHandling = enum(i32) {
    DiscardPartial = 0,
    EnsureComplete = 1,
};
pub const eAVEncCommonStreamEndHandling_DiscardPartial = eAVEncCommonStreamEndHandling.DiscardPartial;
pub const eAVEncCommonStreamEndHandling_EnsureComplete = eAVEncCommonStreamEndHandling.EnsureComplete;

const CLSID_CODECAPI_AVEncStatCommonCompletedPasses_Value = Guid.initString("3e5de533-9df7-438c-854f-9f7dd3683d34");
pub const CLSID_CODECAPI_AVEncStatCommonCompletedPasses = &CLSID_CODECAPI_AVEncStatCommonCompletedPasses_Value;

const CLSID_CODECAPI_AVEncVideoOutputFrameRate_Value = Guid.initString("ea85e7c3-9567-4d99-87c4-02c1c278ca7c");
pub const CLSID_CODECAPI_AVEncVideoOutputFrameRate = &CLSID_CODECAPI_AVEncVideoOutputFrameRate_Value;

const CLSID_CODECAPI_AVEncVideoOutputFrameRateConversion_Value = Guid.initString("8c068bf4-369a-4ba3-82fd-b2518fb3396e");
pub const CLSID_CODECAPI_AVEncVideoOutputFrameRateConversion = &CLSID_CODECAPI_AVEncVideoOutputFrameRateConversion_Value;

pub const eAVEncVideoOutputFrameRateConversion = enum(i32) {
    Disable = 0,
    Enable = 1,
    Alias = 2,
};
pub const eAVEncVideoOutputFrameRateConversion_Disable = eAVEncVideoOutputFrameRateConversion.Disable;
pub const eAVEncVideoOutputFrameRateConversion_Enable = eAVEncVideoOutputFrameRateConversion.Enable;
pub const eAVEncVideoOutputFrameRateConversion_Alias = eAVEncVideoOutputFrameRateConversion.Alias;

const CLSID_CODECAPI_AVEncVideoPixelAspectRatio_Value = Guid.initString("3cdc718f-b3e9-4eb6-a57f-cf1f1b321b87");
pub const CLSID_CODECAPI_AVEncVideoPixelAspectRatio = &CLSID_CODECAPI_AVEncVideoPixelAspectRatio_Value;

const CLSID_CODECAPI_AVDecVideoAcceleration_MPEG2_Value = Guid.initString("f7db8a2e-4f48-4ee8-ae31-8b6ebe558ae2");
pub const CLSID_CODECAPI_AVDecVideoAcceleration_MPEG2 = &CLSID_CODECAPI_AVDecVideoAcceleration_MPEG2_Value;

const CLSID_CODECAPI_AVDecVideoAcceleration_H264_Value = Guid.initString("f7db8a2f-4f48-4ee8-ae31-8b6ebe558ae2");
pub const CLSID_CODECAPI_AVDecVideoAcceleration_H264 = &CLSID_CODECAPI_AVDecVideoAcceleration_H264_Value;

const CLSID_CODECAPI_AVDecVideoAcceleration_VC1_Value = Guid.initString("f7db8a30-4f48-4ee8-ae31-8b6ebe558ae2");
pub const CLSID_CODECAPI_AVDecVideoAcceleration_VC1 = &CLSID_CODECAPI_AVDecVideoAcceleration_VC1_Value;

const CLSID_CODECAPI_AVDecVideoProcDeinterlaceCSC_Value = Guid.initString("f7db8a31-4f48-4ee8-ae31-8b6ebe558ae2");
pub const CLSID_CODECAPI_AVDecVideoProcDeinterlaceCSC = &CLSID_CODECAPI_AVDecVideoProcDeinterlaceCSC_Value;

const CLSID_CODECAPI_AVDecVideoThumbnailGenerationMode_Value = Guid.initString("2efd8eee-1150-4328-9cf5-66dce933fcf4");
pub const CLSID_CODECAPI_AVDecVideoThumbnailGenerationMode = &CLSID_CODECAPI_AVDecVideoThumbnailGenerationMode_Value;

const CLSID_CODECAPI_AVDecVideoMaxCodedWidth_Value = Guid.initString("5ae557b8-77af-41f5-9fa6-4db2fe1d4bca");
pub const CLSID_CODECAPI_AVDecVideoMaxCodedWidth = &CLSID_CODECAPI_AVDecVideoMaxCodedWidth_Value;

const CLSID_CODECAPI_AVDecVideoMaxCodedHeight_Value = Guid.initString("7262a16a-d2dc-4e75-9ba8-65c0c6d32b13");
pub const CLSID_CODECAPI_AVDecVideoMaxCodedHeight = &CLSID_CODECAPI_AVDecVideoMaxCodedHeight_Value;

const CLSID_CODECAPI_AVDecNumWorkerThreads_Value = Guid.initString("9561c3e8-ea9e-4435-9b1e-a93e691894d8");
pub const CLSID_CODECAPI_AVDecNumWorkerThreads = &CLSID_CODECAPI_AVDecNumWorkerThreads_Value;

const CLSID_CODECAPI_AVDecSoftwareDynamicFormatChange_Value = Guid.initString("862e2f0a-507b-47ff-af47-01e2624298b7");
pub const CLSID_CODECAPI_AVDecSoftwareDynamicFormatChange = &CLSID_CODECAPI_AVDecSoftwareDynamicFormatChange_Value;

const CLSID_CODECAPI_AVDecDisableVideoPostProcessing_Value = Guid.initString("f8749193-667a-4f2c-a9e8-5d4af924f08f");
pub const CLSID_CODECAPI_AVDecDisableVideoPostProcessing = &CLSID_CODECAPI_AVDecDisableVideoPostProcessing_Value;

const CLSID_CODECAPI_AVDecVideoDropPicWithMissingRef_Value = Guid.initString("f8226383-14c2-4567-9734-5004e96ff887");
pub const CLSID_CODECAPI_AVDecVideoDropPicWithMissingRef = &CLSID_CODECAPI_AVDecVideoDropPicWithMissingRef_Value;

const CLSID_CODECAPI_AVDecVideoSoftwareDeinterlaceMode_Value = Guid.initString("0c08d1ce-9ced-4540-bae3-ceb380141109");
pub const CLSID_CODECAPI_AVDecVideoSoftwareDeinterlaceMode = &CLSID_CODECAPI_AVDecVideoSoftwareDeinterlaceMode_Value;

pub const eAVDecVideoSoftwareDeinterlaceMode = enum(i32) {
    NoDeinterlacing = 0,
    ProgressiveDeinterlacing = 1,
    BOBDeinterlacing = 2,
    SmartBOBDeinterlacing = 3,
};
pub const eAVDecVideoSoftwareDeinterlaceMode_NoDeinterlacing = eAVDecVideoSoftwareDeinterlaceMode.NoDeinterlacing;
pub const eAVDecVideoSoftwareDeinterlaceMode_ProgressiveDeinterlacing = eAVDecVideoSoftwareDeinterlaceMode.ProgressiveDeinterlacing;
pub const eAVDecVideoSoftwareDeinterlaceMode_BOBDeinterlacing = eAVDecVideoSoftwareDeinterlaceMode.BOBDeinterlacing;
pub const eAVDecVideoSoftwareDeinterlaceMode_SmartBOBDeinterlacing = eAVDecVideoSoftwareDeinterlaceMode.SmartBOBDeinterlacing;

const CLSID_CODECAPI_AVDecVideoFastDecodeMode_Value = Guid.initString("6b529f7d-d3b1-49c6-a999-9ec6911bedbf");
pub const CLSID_CODECAPI_AVDecVideoFastDecodeMode = &CLSID_CODECAPI_AVDecVideoFastDecodeMode_Value;

pub const eAVFastDecodeMode = enum(i32) {
    Compliant = 0,
    OptimalLF = 1,
    DisableLF = 2,
    Fastest = 32,
};
pub const eVideoDecodeCompliant = eAVFastDecodeMode.Compliant;
pub const eVideoDecodeOptimalLF = eAVFastDecodeMode.OptimalLF;
pub const eVideoDecodeDisableLF = eAVFastDecodeMode.DisableLF;
pub const eVideoDecodeFastest = eAVFastDecodeMode.Fastest;

const CLSID_CODECAPI_AVLowLatencyMode_Value = Guid.initString("9c27891a-ed7a-40e1-88e8-b22727a024ee");
pub const CLSID_CODECAPI_AVLowLatencyMode = &CLSID_CODECAPI_AVLowLatencyMode_Value;

const CLSID_CODECAPI_AVDecVideoH264ErrorConcealment_Value = Guid.initString("ececace8-3436-462c-9294-cd7bacd758a9");
pub const CLSID_CODECAPI_AVDecVideoH264ErrorConcealment = &CLSID_CODECAPI_AVDecVideoH264ErrorConcealment_Value;

pub const eAVDecVideoH264ErrorConcealment = enum(i32) {
    Drop = 0,
    Basic = 1,
    Advanced = 2,
    DXVASetBlack = 3,
};
pub const eErrorConcealmentTypeDrop = eAVDecVideoH264ErrorConcealment.Drop;
pub const eErrorConcealmentTypeBasic = eAVDecVideoH264ErrorConcealment.Basic;
pub const eErrorConcealmentTypeAdvanced = eAVDecVideoH264ErrorConcealment.Advanced;
pub const eErrorConcealmentTypeDXVASetBlack = eAVDecVideoH264ErrorConcealment.DXVASetBlack;

const CLSID_CODECAPI_AVDecVideoMPEG2ErrorConcealment_Value = Guid.initString("9d2bfe18-728d-48d2-b358-bc7e436c6674");
pub const CLSID_CODECAPI_AVDecVideoMPEG2ErrorConcealment = &CLSID_CODECAPI_AVDecVideoMPEG2ErrorConcealment_Value;

pub const eAVDecVideoMPEG2ErrorConcealment = enum(i32) {
    ff = 0,
    n = 1,
};
pub const eErrorConcealmentOff = eAVDecVideoMPEG2ErrorConcealment.ff;
pub const eErrorConcealmentOn = eAVDecVideoMPEG2ErrorConcealment.n;

const CLSID_CODECAPI_AVDecVideoCodecType_Value = Guid.initString("434528e5-21f0-46b6-b62c-9b1b6b658cd1");
pub const CLSID_CODECAPI_AVDecVideoCodecType = &CLSID_CODECAPI_AVDecVideoCodecType_Value;

pub const eAVDecVideoCodecType = enum(i32) {
    NOTPLAYING = 0,
    MPEG2 = 1,
    H264 = 2,
};
pub const eAVDecVideoCodecType_NOTPLAYING = eAVDecVideoCodecType.NOTPLAYING;
pub const eAVDecVideoCodecType_MPEG2 = eAVDecVideoCodecType.MPEG2;
pub const eAVDecVideoCodecType_H264 = eAVDecVideoCodecType.H264;

const CLSID_CODECAPI_AVDecVideoDXVAMode_Value = Guid.initString("f758f09e-7337-4ae7-8387-73dc2d54e67d");
pub const CLSID_CODECAPI_AVDecVideoDXVAMode = &CLSID_CODECAPI_AVDecVideoDXVAMode_Value;

pub const eAVDecVideoDXVAMode = enum(i32) {
    NOTPLAYING = 0,
    SW = 1,
    MC = 2,
    IDCT = 3,
    VLD = 4,
};
pub const eAVDecVideoDXVAMode_NOTPLAYING = eAVDecVideoDXVAMode.NOTPLAYING;
pub const eAVDecVideoDXVAMode_SW = eAVDecVideoDXVAMode.SW;
pub const eAVDecVideoDXVAMode_MC = eAVDecVideoDXVAMode.MC;
pub const eAVDecVideoDXVAMode_IDCT = eAVDecVideoDXVAMode.IDCT;
pub const eAVDecVideoDXVAMode_VLD = eAVDecVideoDXVAMode.VLD;

const CLSID_CODECAPI_AVDecVideoDXVABusEncryption_Value = Guid.initString("42153c8b-fd0b-4765-a462-ddd9e8bcc388");
pub const CLSID_CODECAPI_AVDecVideoDXVABusEncryption = &CLSID_CODECAPI_AVDecVideoDXVABusEncryption_Value;

pub const eAVDecVideoDXVABusEncryption = enum(i32) {
    NONE = 0,
    PRIVATE = 1,
    AES = 2,
};
pub const eAVDecVideoDXVABusEncryption_NONE = eAVDecVideoDXVABusEncryption.NONE;
pub const eAVDecVideoDXVABusEncryption_PRIVATE = eAVDecVideoDXVABusEncryption.PRIVATE;
pub const eAVDecVideoDXVABusEncryption_AES = eAVDecVideoDXVABusEncryption.AES;

const CLSID_CODECAPI_AVEncVideoForceSourceScanType_Value = Guid.initString("1ef2065f-058a-4765-a4fc-8a864c103012");
pub const CLSID_CODECAPI_AVEncVideoForceSourceScanType = &CLSID_CODECAPI_AVEncVideoForceSourceScanType_Value;

pub const eAVEncVideoSourceScanType = enum(i32) {
    Automatic = 0,
    Interlaced = 1,
    Progressive = 2,
};
pub const eAVEncVideoSourceScan_Automatic = eAVEncVideoSourceScanType.Automatic;
pub const eAVEncVideoSourceScan_Interlaced = eAVEncVideoSourceScanType.Interlaced;
pub const eAVEncVideoSourceScan_Progressive = eAVEncVideoSourceScanType.Progressive;

const CLSID_CODECAPI_AVEncVideoNoOfFieldsToEncode_Value = Guid.initString("61e4bbe2-4ee0-40e7-80ab-51ddeebe6291");
pub const CLSID_CODECAPI_AVEncVideoNoOfFieldsToEncode = &CLSID_CODECAPI_AVEncVideoNoOfFieldsToEncode_Value;

const CLSID_CODECAPI_AVEncVideoNoOfFieldsToSkip_Value = Guid.initString("a97e1240-1427-4c16-a7f7-3dcfd8ba4cc5");
pub const CLSID_CODECAPI_AVEncVideoNoOfFieldsToSkip = &CLSID_CODECAPI_AVEncVideoNoOfFieldsToSkip_Value;

const CLSID_CODECAPI_AVEncVideoEncodeDimension_Value = Guid.initString("1074df28-7e0f-47a4-a453-cdd73870f5ce");
pub const CLSID_CODECAPI_AVEncVideoEncodeDimension = &CLSID_CODECAPI_AVEncVideoEncodeDimension_Value;

const CLSID_CODECAPI_AVEncVideoEncodeOffsetOrigin_Value = Guid.initString("6bc098fe-a71a-4454-852e-4d2ddeb2cd24");
pub const CLSID_CODECAPI_AVEncVideoEncodeOffsetOrigin = &CLSID_CODECAPI_AVEncVideoEncodeOffsetOrigin_Value;

const CLSID_CODECAPI_AVEncVideoDisplayDimension_Value = Guid.initString("de053668-f4ec-47a9-86d0-836770f0c1d5");
pub const CLSID_CODECAPI_AVEncVideoDisplayDimension = &CLSID_CODECAPI_AVEncVideoDisplayDimension_Value;

const CLSID_CODECAPI_AVEncVideoOutputScanType_Value = Guid.initString("460b5576-842e-49ab-a62d-b36f7312c9db");
pub const CLSID_CODECAPI_AVEncVideoOutputScanType = &CLSID_CODECAPI_AVEncVideoOutputScanType_Value;

pub const eAVEncVideoOutputScanType = enum(i32) {
    Progressive = 0,
    Interlaced = 1,
    SameAsInput = 2,
    Automatic = 3,
};
pub const eAVEncVideoOutputScan_Progressive = eAVEncVideoOutputScanType.Progressive;
pub const eAVEncVideoOutputScan_Interlaced = eAVEncVideoOutputScanType.Interlaced;
pub const eAVEncVideoOutputScan_SameAsInput = eAVEncVideoOutputScanType.SameAsInput;
pub const eAVEncVideoOutputScan_Automatic = eAVEncVideoOutputScanType.Automatic;

const CLSID_CODECAPI_AVEncVideoInverseTelecineEnable_Value = Guid.initString("2ea9098b-e76d-4ccd-a030-d3b889c1b64c");
pub const CLSID_CODECAPI_AVEncVideoInverseTelecineEnable = &CLSID_CODECAPI_AVEncVideoInverseTelecineEnable_Value;

const CLSID_CODECAPI_AVEncVideoInverseTelecineThreshold_Value = Guid.initString("40247d84-e895-497f-b44c-b74560acfe27");
pub const CLSID_CODECAPI_AVEncVideoInverseTelecineThreshold = &CLSID_CODECAPI_AVEncVideoInverseTelecineThreshold_Value;

const CLSID_CODECAPI_AVEncVideoSourceFilmContent_Value = Guid.initString("1791c64b-ccfc-4827-a0ed-2557793b2b1c");
pub const CLSID_CODECAPI_AVEncVideoSourceFilmContent = &CLSID_CODECAPI_AVEncVideoSourceFilmContent_Value;

pub const eAVEncVideoFilmContent = enum(i32) {
    VideoOnly = 0,
    FilmOnly = 1,
    Mixed = 2,
};
pub const eAVEncVideoFilmContent_VideoOnly = eAVEncVideoFilmContent.VideoOnly;
pub const eAVEncVideoFilmContent_FilmOnly = eAVEncVideoFilmContent.FilmOnly;
pub const eAVEncVideoFilmContent_Mixed = eAVEncVideoFilmContent.Mixed;

const CLSID_CODECAPI_AVEncVideoSourceIsBW_Value = Guid.initString("42ffc49b-1812-4fdc-8d24-7054c521e6eb");
pub const CLSID_CODECAPI_AVEncVideoSourceIsBW = &CLSID_CODECAPI_AVEncVideoSourceIsBW_Value;

const CLSID_CODECAPI_AVEncVideoFieldSwap_Value = Guid.initString("fefd7569-4e0a-49f2-9f2b-360ea48c19a2");
pub const CLSID_CODECAPI_AVEncVideoFieldSwap = &CLSID_CODECAPI_AVEncVideoFieldSwap_Value;

const CLSID_CODECAPI_AVEncVideoInputChromaResolution_Value = Guid.initString("bb0cec33-16f1-47b0-8a88-37815bee1739");
pub const CLSID_CODECAPI_AVEncVideoInputChromaResolution = &CLSID_CODECAPI_AVEncVideoInputChromaResolution_Value;

const CLSID_CODECAPI_AVEncVideoOutputChromaResolution_Value = Guid.initString("6097b4c9-7c1d-4e64-bfcc-9e9765318ae7");
pub const CLSID_CODECAPI_AVEncVideoOutputChromaResolution = &CLSID_CODECAPI_AVEncVideoOutputChromaResolution_Value;

pub const eAVEncVideoChromaResolution = enum(i32) {
    SameAsSource = 0,
    @"444" = 1,
    @"422" = 2,
    @"420" = 3,
    @"411" = 4,
};
pub const eAVEncVideoChromaResolution_SameAsSource = eAVEncVideoChromaResolution.SameAsSource;
pub const eAVEncVideoChromaResolution_444 = eAVEncVideoChromaResolution.@"444";
pub const eAVEncVideoChromaResolution_422 = eAVEncVideoChromaResolution.@"422";
pub const eAVEncVideoChromaResolution_420 = eAVEncVideoChromaResolution.@"420";
pub const eAVEncVideoChromaResolution_411 = eAVEncVideoChromaResolution.@"411";

const CLSID_CODECAPI_AVEncVideoInputChromaSubsampling_Value = Guid.initString("a8e73a39-4435-4ec3-a6ea-98300f4b36f7");
pub const CLSID_CODECAPI_AVEncVideoInputChromaSubsampling = &CLSID_CODECAPI_AVEncVideoInputChromaSubsampling_Value;

const CLSID_CODECAPI_AVEncVideoOutputChromaSubsampling_Value = Guid.initString("fa561c6c-7d17-44f0-83c9-32ed12e96343");
pub const CLSID_CODECAPI_AVEncVideoOutputChromaSubsampling = &CLSID_CODECAPI_AVEncVideoOutputChromaSubsampling_Value;

pub const eAVEncVideoChromaSubsampling = enum(i32) {
    SameAsSource = 0,
    ProgressiveChroma = 8,
    Horizontally_Cosited = 4,
    Vertically_Cosited = 2,
    Vertically_AlignedChromaPlanes = 1,
};
pub const eAVEncVideoChromaSubsamplingFormat_SameAsSource = eAVEncVideoChromaSubsampling.SameAsSource;
pub const eAVEncVideoChromaSubsamplingFormat_ProgressiveChroma = eAVEncVideoChromaSubsampling.ProgressiveChroma;
pub const eAVEncVideoChromaSubsamplingFormat_Horizontally_Cosited = eAVEncVideoChromaSubsampling.Horizontally_Cosited;
pub const eAVEncVideoChromaSubsamplingFormat_Vertically_Cosited = eAVEncVideoChromaSubsampling.Vertically_Cosited;
pub const eAVEncVideoChromaSubsamplingFormat_Vertically_AlignedChromaPlanes = eAVEncVideoChromaSubsampling.Vertically_AlignedChromaPlanes;

const CLSID_CODECAPI_AVEncVideoInputColorPrimaries_Value = Guid.initString("c24d783f-7ce6-4278-90ab-28a4f1e5f86c");
pub const CLSID_CODECAPI_AVEncVideoInputColorPrimaries = &CLSID_CODECAPI_AVEncVideoInputColorPrimaries_Value;

const CLSID_CODECAPI_AVEncVideoOutputColorPrimaries_Value = Guid.initString("be95907c-9d04-4921-8985-a6d6d87d1a6c");
pub const CLSID_CODECAPI_AVEncVideoOutputColorPrimaries = &CLSID_CODECAPI_AVEncVideoOutputColorPrimaries_Value;

pub const eAVEncVideoColorPrimaries = enum(i32) {
    SameAsSource = 0,
    Reserved = 1,
    BT709 = 2,
    BT470_2_SysM = 3,
    BT470_2_SysBG = 4,
    SMPTE170M = 5,
    SMPTE240M = 6,
    EBU3231 = 7,
    SMPTE_C = 8,
};
pub const eAVEncVideoColorPrimaries_SameAsSource = eAVEncVideoColorPrimaries.SameAsSource;
pub const eAVEncVideoColorPrimaries_Reserved = eAVEncVideoColorPrimaries.Reserved;
pub const eAVEncVideoColorPrimaries_BT709 = eAVEncVideoColorPrimaries.BT709;
pub const eAVEncVideoColorPrimaries_BT470_2_SysM = eAVEncVideoColorPrimaries.BT470_2_SysM;
pub const eAVEncVideoColorPrimaries_BT470_2_SysBG = eAVEncVideoColorPrimaries.BT470_2_SysBG;
pub const eAVEncVideoColorPrimaries_SMPTE170M = eAVEncVideoColorPrimaries.SMPTE170M;
pub const eAVEncVideoColorPrimaries_SMPTE240M = eAVEncVideoColorPrimaries.SMPTE240M;
pub const eAVEncVideoColorPrimaries_EBU3231 = eAVEncVideoColorPrimaries.EBU3231;
pub const eAVEncVideoColorPrimaries_SMPTE_C = eAVEncVideoColorPrimaries.SMPTE_C;

const CLSID_CODECAPI_AVEncVideoInputColorTransferFunction_Value = Guid.initString("8c056111-a9c3-4b08-a0a0-ce13f8a27c75");
pub const CLSID_CODECAPI_AVEncVideoInputColorTransferFunction = &CLSID_CODECAPI_AVEncVideoInputColorTransferFunction_Value;

const CLSID_CODECAPI_AVEncVideoOutputColorTransferFunction_Value = Guid.initString("4a7f884a-ea11-460d-bf57-b88bc75900de");
pub const CLSID_CODECAPI_AVEncVideoOutputColorTransferFunction = &CLSID_CODECAPI_AVEncVideoOutputColorTransferFunction_Value;

pub const eAVEncVideoColorTransferFunction = enum(i32) {
    SameAsSource = 0,
    @"10" = 1,
    @"18" = 2,
    @"20" = 3,
    @"22" = 4,
    @"22_709" = 5,
    @"22_240M" = 6,
    @"22_8bit_sRGB" = 7,
    @"28" = 8,
};
pub const eAVEncVideoColorTransferFunction_SameAsSource = eAVEncVideoColorTransferFunction.SameAsSource;
pub const eAVEncVideoColorTransferFunction_10 = eAVEncVideoColorTransferFunction.@"10";
pub const eAVEncVideoColorTransferFunction_18 = eAVEncVideoColorTransferFunction.@"18";
pub const eAVEncVideoColorTransferFunction_20 = eAVEncVideoColorTransferFunction.@"20";
pub const eAVEncVideoColorTransferFunction_22 = eAVEncVideoColorTransferFunction.@"22";
pub const eAVEncVideoColorTransferFunction_22_709 = eAVEncVideoColorTransferFunction.@"22_709";
pub const eAVEncVideoColorTransferFunction_22_240M = eAVEncVideoColorTransferFunction.@"22_240M";
pub const eAVEncVideoColorTransferFunction_22_8bit_sRGB = eAVEncVideoColorTransferFunction.@"22_8bit_sRGB";
pub const eAVEncVideoColorTransferFunction_28 = eAVEncVideoColorTransferFunction.@"28";

const CLSID_CODECAPI_AVEncVideoInputColorTransferMatrix_Value = Guid.initString("52ed68b9-72d5-4089-958d-f5405d55081c");
pub const CLSID_CODECAPI_AVEncVideoInputColorTransferMatrix = &CLSID_CODECAPI_AVEncVideoInputColorTransferMatrix_Value;

const CLSID_CODECAPI_AVEncVideoOutputColorTransferMatrix_Value = Guid.initString("a9b90444-af40-4310-8fbe-ed6d933f892b");
pub const CLSID_CODECAPI_AVEncVideoOutputColorTransferMatrix = &CLSID_CODECAPI_AVEncVideoOutputColorTransferMatrix_Value;

pub const eAVEncVideoColorTransferMatrix = enum(i32) {
    SameAsSource = 0,
    BT709 = 1,
    BT601 = 2,
    SMPTE240M = 3,
};
pub const eAVEncVideoColorTransferMatrix_SameAsSource = eAVEncVideoColorTransferMatrix.SameAsSource;
pub const eAVEncVideoColorTransferMatrix_BT709 = eAVEncVideoColorTransferMatrix.BT709;
pub const eAVEncVideoColorTransferMatrix_BT601 = eAVEncVideoColorTransferMatrix.BT601;
pub const eAVEncVideoColorTransferMatrix_SMPTE240M = eAVEncVideoColorTransferMatrix.SMPTE240M;

const CLSID_CODECAPI_AVEncVideoInputColorLighting_Value = Guid.initString("46a99549-0015-4a45-9c30-1d5cfa258316");
pub const CLSID_CODECAPI_AVEncVideoInputColorLighting = &CLSID_CODECAPI_AVEncVideoInputColorLighting_Value;

const CLSID_CODECAPI_AVEncVideoOutputColorLighting_Value = Guid.initString("0e5aaac6-ace6-4c5c-998e-1a8c9c6c0f89");
pub const CLSID_CODECAPI_AVEncVideoOutputColorLighting = &CLSID_CODECAPI_AVEncVideoOutputColorLighting_Value;

pub const eAVEncVideoColorLighting = enum(i32) {
    SameAsSource = 0,
    Unknown = 1,
    Bright = 2,
    Office = 3,
    Dim = 4,
    Dark = 5,
};
pub const eAVEncVideoColorLighting_SameAsSource = eAVEncVideoColorLighting.SameAsSource;
pub const eAVEncVideoColorLighting_Unknown = eAVEncVideoColorLighting.Unknown;
pub const eAVEncVideoColorLighting_Bright = eAVEncVideoColorLighting.Bright;
pub const eAVEncVideoColorLighting_Office = eAVEncVideoColorLighting.Office;
pub const eAVEncVideoColorLighting_Dim = eAVEncVideoColorLighting.Dim;
pub const eAVEncVideoColorLighting_Dark = eAVEncVideoColorLighting.Dark;

const CLSID_CODECAPI_AVEncVideoInputColorNominalRange_Value = Guid.initString("16cf25c6-a2a6-48e9-ae80-21aec41d427e");
pub const CLSID_CODECAPI_AVEncVideoInputColorNominalRange = &CLSID_CODECAPI_AVEncVideoInputColorNominalRange_Value;

const CLSID_CODECAPI_AVEncVideoOutputColorNominalRange_Value = Guid.initString("972835ed-87b5-4e95-9500-c73958566e54");
pub const CLSID_CODECAPI_AVEncVideoOutputColorNominalRange = &CLSID_CODECAPI_AVEncVideoOutputColorNominalRange_Value;

pub const eAVEncVideoColorNominalRange = enum(i32) {
    SameAsSource = 0,
    @"0_255" = 1,
    @"16_235" = 2,
    @"48_208" = 3,
};
pub const eAVEncVideoColorNominalRange_SameAsSource = eAVEncVideoColorNominalRange.SameAsSource;
pub const eAVEncVideoColorNominalRange_0_255 = eAVEncVideoColorNominalRange.@"0_255";
pub const eAVEncVideoColorNominalRange_16_235 = eAVEncVideoColorNominalRange.@"16_235";
pub const eAVEncVideoColorNominalRange_48_208 = eAVEncVideoColorNominalRange.@"48_208";

const CLSID_CODECAPI_AVEncInputVideoSystem_Value = Guid.initString("bede146d-b616-4dc7-92b2-f5d9fa9298f7");
pub const CLSID_CODECAPI_AVEncInputVideoSystem = &CLSID_CODECAPI_AVEncInputVideoSystem_Value;

pub const eAVEncInputVideoSystem = enum(i32) {
    Unspecified = 0,
    PAL = 1,
    NTSC = 2,
    SECAM = 3,
    MAC = 4,
    HDV = 5,
    Component = 6,
};
pub const eAVEncInputVideoSystem_Unspecified = eAVEncInputVideoSystem.Unspecified;
pub const eAVEncInputVideoSystem_PAL = eAVEncInputVideoSystem.PAL;
pub const eAVEncInputVideoSystem_NTSC = eAVEncInputVideoSystem.NTSC;
pub const eAVEncInputVideoSystem_SECAM = eAVEncInputVideoSystem.SECAM;
pub const eAVEncInputVideoSystem_MAC = eAVEncInputVideoSystem.MAC;
pub const eAVEncInputVideoSystem_HDV = eAVEncInputVideoSystem.HDV;
pub const eAVEncInputVideoSystem_Component = eAVEncInputVideoSystem.Component;

const CLSID_CODECAPI_AVEncVideoHeaderDropFrame_Value = Guid.initString("6ed9e124-7925-43fe-971b-e019f62222b4");
pub const CLSID_CODECAPI_AVEncVideoHeaderDropFrame = &CLSID_CODECAPI_AVEncVideoHeaderDropFrame_Value;

const CLSID_CODECAPI_AVEncVideoHeaderHours_Value = Guid.initString("2acc7702-e2da-4158-bf9b-88880129d740");
pub const CLSID_CODECAPI_AVEncVideoHeaderHours = &CLSID_CODECAPI_AVEncVideoHeaderHours_Value;

const CLSID_CODECAPI_AVEncVideoHeaderMinutes_Value = Guid.initString("dc1a99ce-0307-408b-880b-b8348ee8ca7f");
pub const CLSID_CODECAPI_AVEncVideoHeaderMinutes = &CLSID_CODECAPI_AVEncVideoHeaderMinutes_Value;

const CLSID_CODECAPI_AVEncVideoHeaderSeconds_Value = Guid.initString("4a2e1a05-a780-4f58-8120-9a449d69656b");
pub const CLSID_CODECAPI_AVEncVideoHeaderSeconds = &CLSID_CODECAPI_AVEncVideoHeaderSeconds_Value;

const CLSID_CODECAPI_AVEncVideoHeaderFrames_Value = Guid.initString("afd5f567-5c1b-4adc-bdaf-735610381436");
pub const CLSID_CODECAPI_AVEncVideoHeaderFrames = &CLSID_CODECAPI_AVEncVideoHeaderFrames_Value;

const CLSID_CODECAPI_AVEncVideoDefaultUpperFieldDominant_Value = Guid.initString("810167c4-0bc1-47ca-8fc2-57055a1474a5");
pub const CLSID_CODECAPI_AVEncVideoDefaultUpperFieldDominant = &CLSID_CODECAPI_AVEncVideoDefaultUpperFieldDominant_Value;

const CLSID_CODECAPI_AVEncVideoCBRMotionTradeoff_Value = Guid.initString("0d49451e-18d5-4367-a4ef-3240df1693c4");
pub const CLSID_CODECAPI_AVEncVideoCBRMotionTradeoff = &CLSID_CODECAPI_AVEncVideoCBRMotionTradeoff_Value;

const CLSID_CODECAPI_AVEncVideoCodedVideoAccessUnitSize_Value = Guid.initString("b4b10c15-14a7-4ce8-b173-dc90a0b4fcdb");
pub const CLSID_CODECAPI_AVEncVideoCodedVideoAccessUnitSize = &CLSID_CODECAPI_AVEncVideoCodedVideoAccessUnitSize_Value;

const CLSID_CODECAPI_AVEncVideoMaxKeyframeDistance_Value = Guid.initString("2987123a-ba93-4704-b489-ec1e5f25292c");
pub const CLSID_CODECAPI_AVEncVideoMaxKeyframeDistance = &CLSID_CODECAPI_AVEncVideoMaxKeyframeDistance_Value;

const CLSID_CODECAPI_AVEncH264CABACEnable_Value = Guid.initString("ee6cad62-d305-4248-a50e-e1b255f7caf8");
pub const CLSID_CODECAPI_AVEncH264CABACEnable = &CLSID_CODECAPI_AVEncH264CABACEnable_Value;

const CLSID_CODECAPI_AVEncVideoContentType_Value = Guid.initString("66117aca-eb77-459d-930c-a48d9d0683fc");
pub const CLSID_CODECAPI_AVEncVideoContentType = &CLSID_CODECAPI_AVEncVideoContentType_Value;

pub const eAVEncVideoContentType = enum(i32) {
    Unknown = 0,
    FixedCameraAngle = 1,
};
pub const eAVEncVideoContentType_Unknown = eAVEncVideoContentType.Unknown;
pub const eAVEncVideoContentType_FixedCameraAngle = eAVEncVideoContentType.FixedCameraAngle;

const CLSID_CODECAPI_AVEncNumWorkerThreads_Value = Guid.initString("b0c8bf60-16f7-4951-a30b-1db1609293d6");
pub const CLSID_CODECAPI_AVEncNumWorkerThreads = &CLSID_CODECAPI_AVEncNumWorkerThreads_Value;

const CLSID_CODECAPI_AVEncVideoEncodeQP_Value = Guid.initString("2cb5696b-23fb-4ce1-a0f9-ef5b90fd55ca");
pub const CLSID_CODECAPI_AVEncVideoEncodeQP = &CLSID_CODECAPI_AVEncVideoEncodeQP_Value;

const CLSID_CODECAPI_AVEncVideoMinQP_Value = Guid.initString("0ee22c6a-a37c-4568-b5f1-9d4c2b3ab886");
pub const CLSID_CODECAPI_AVEncVideoMinQP = &CLSID_CODECAPI_AVEncVideoMinQP_Value;

const CLSID_CODECAPI_AVEncVideoForceKeyFrame_Value = Guid.initString("398c1b98-8353-475a-9ef2-8f265d260345");
pub const CLSID_CODECAPI_AVEncVideoForceKeyFrame = &CLSID_CODECAPI_AVEncVideoForceKeyFrame_Value;

const CLSID_CODECAPI_AVEncH264SPSID_Value = Guid.initString("50f38f51-2b79-40e3-b39c-7e9fa0770501");
pub const CLSID_CODECAPI_AVEncH264SPSID = &CLSID_CODECAPI_AVEncH264SPSID_Value;

const CLSID_CODECAPI_AVEncH264PPSID_Value = Guid.initString("bfe29ec2-056c-4d68-a38d-ae5944c8582e");
pub const CLSID_CODECAPI_AVEncH264PPSID = &CLSID_CODECAPI_AVEncH264PPSID_Value;

const CLSID_CODECAPI_AVEncAdaptiveMode_Value = Guid.initString("4419b185-da1f-4f53-bc76-097d0c1efb1e");
pub const CLSID_CODECAPI_AVEncAdaptiveMode = &CLSID_CODECAPI_AVEncAdaptiveMode_Value;

const CLSID_CODECAPI_AVScenarioInfo_Value = Guid.initString("b28a6e64-3ff9-446a-8a4b-0d7a53413236");
pub const CLSID_CODECAPI_AVScenarioInfo = &CLSID_CODECAPI_AVScenarioInfo_Value;

const CLSID_CODECAPI_AVEncMPVGOPSizeMin_Value = Guid.initString("7155cf20-d440-4852-ad0f-9c4abfe37a6a");
pub const CLSID_CODECAPI_AVEncMPVGOPSizeMin = &CLSID_CODECAPI_AVEncMPVGOPSizeMin_Value;

const CLSID_CODECAPI_AVEncMPVGOPSizeMax_Value = Guid.initString("fe7de4c4-1936-4fe2-bdf7-1f18ca1d001f");
pub const CLSID_CODECAPI_AVEncMPVGOPSizeMax = &CLSID_CODECAPI_AVEncMPVGOPSizeMax_Value;

const CLSID_CODECAPI_AVEncVideoMaxCTBSize_Value = Guid.initString("822363ff-cec8-43e5-92fd-e097488485e9");
pub const CLSID_CODECAPI_AVEncVideoMaxCTBSize = &CLSID_CODECAPI_AVEncVideoMaxCTBSize_Value;

const CLSID_CODECAPI_AVEncVideoCTBSize_Value = Guid.initString("d47db8b2-e73b-4cb9-8c3e-bd877d06d77b");
pub const CLSID_CODECAPI_AVEncVideoCTBSize = &CLSID_CODECAPI_AVEncVideoCTBSize_Value;

const CLSID_CODECAPI_VideoEncoderDisplayContentType_Value = Guid.initString("79b90b27-f4b1-42dc-9dd7-cdaf8135c400");
pub const CLSID_CODECAPI_VideoEncoderDisplayContentType = &CLSID_CODECAPI_VideoEncoderDisplayContentType_Value;

const CLSID_CODECAPI_AVEncEnableVideoProcessing_Value = Guid.initString("006f4bf6-0ea3-4d42-8702-b5d8be0f7a92");
pub const CLSID_CODECAPI_AVEncEnableVideoProcessing = &CLSID_CODECAPI_AVEncEnableVideoProcessing_Value;

const CLSID_CODECAPI_AVEncVideoGradualIntraRefresh_Value = Guid.initString("8f347dee-cb0d-49ba-b462-db6927ee2101");
pub const CLSID_CODECAPI_AVEncVideoGradualIntraRefresh = &CLSID_CODECAPI_AVEncVideoGradualIntraRefresh_Value;

const CLSID_CODECAPI_GetOPMContext_Value = Guid.initString("2f036c05-4c14-4689-8839-294c6d73e053");
pub const CLSID_CODECAPI_GetOPMContext = &CLSID_CODECAPI_GetOPMContext_Value;

const CLSID_CODECAPI_SetHDCPManagerContext_Value = Guid.initString("6d2d1fc8-3dc9-47eb-a1a2-471c80cd60d0");
pub const CLSID_CODECAPI_SetHDCPManagerContext = &CLSID_CODECAPI_SetHDCPManagerContext_Value;

const CLSID_CODECAPI_AVEncVideoMaxTemporalLayers_Value = Guid.initString("9c668cfe-08e1-424a-934e-b764b064802a");
pub const CLSID_CODECAPI_AVEncVideoMaxTemporalLayers = &CLSID_CODECAPI_AVEncVideoMaxTemporalLayers_Value;

const CLSID_CODECAPI_AVEncVideoNumGOPsPerIDR_Value = Guid.initString("83bc5bdb-5b89-4521-8f66-33151c373176");
pub const CLSID_CODECAPI_AVEncVideoNumGOPsPerIDR = &CLSID_CODECAPI_AVEncVideoNumGOPsPerIDR_Value;

const CLSID_CODECAPI_AVEncCommonAllowFrameDrops_Value = Guid.initString("d8477dcb-9598-48e3-8d0c-752bf206093e");
pub const CLSID_CODECAPI_AVEncCommonAllowFrameDrops = &CLSID_CODECAPI_AVEncCommonAllowFrameDrops_Value;

const CLSID_CODECAPI_AVEncVideoIntraLayerPrediction_Value = Guid.initString("d3af46b8-bf47-44bb-a283-69f0b0228ff9");
pub const CLSID_CODECAPI_AVEncVideoIntraLayerPrediction = &CLSID_CODECAPI_AVEncVideoIntraLayerPrediction_Value;

const CLSID_CODECAPI_AVEncVideoInstantTemporalUpSwitching_Value = Guid.initString("a3308307-0d96-4ba4-b1f0-b91a5e49df10");
pub const CLSID_CODECAPI_AVEncVideoInstantTemporalUpSwitching = &CLSID_CODECAPI_AVEncVideoInstantTemporalUpSwitching_Value;

const CLSID_CODECAPI_AVEncLowPowerEncoder_Value = Guid.initString("b668d582-8bad-4f6a-9141-375a95358b6d");
pub const CLSID_CODECAPI_AVEncLowPowerEncoder = &CLSID_CODECAPI_AVEncLowPowerEncoder_Value;

const CLSID_CODECAPI_AVEnableInLoopDeblockFilter_Value = Guid.initString("d2e8e399-0623-4bf3-92a8-4d1818529ded");
pub const CLSID_CODECAPI_AVEnableInLoopDeblockFilter = &CLSID_CODECAPI_AVEnableInLoopDeblockFilter_Value;

pub const eAVEncAdaptiveMode = enum(i32) {
    None = 0,
    Resolution = 1,
    FrameRate = 2,
};
pub const eAVEncAdaptiveMode_None = eAVEncAdaptiveMode.None;
pub const eAVEncAdaptiveMode_Resolution = eAVEncAdaptiveMode.Resolution;
pub const eAVEncAdaptiveMode_FrameRate = eAVEncAdaptiveMode.FrameRate;

pub const eAVScenarioInfo = enum(i32) {
    Unknown = 0,
    DisplayRemoting = 1,
    VideoConference = 2,
    Archive = 3,
    LiveStreaming = 4,
    CameraRecord = 5,
    DisplayRemotingWithFeatureMap = 6,
};
pub const eAVScenarioInfo_Unknown = eAVScenarioInfo.Unknown;
pub const eAVScenarioInfo_DisplayRemoting = eAVScenarioInfo.DisplayRemoting;
pub const eAVScenarioInfo_VideoConference = eAVScenarioInfo.VideoConference;
pub const eAVScenarioInfo_Archive = eAVScenarioInfo.Archive;
pub const eAVScenarioInfo_LiveStreaming = eAVScenarioInfo.LiveStreaming;
pub const eAVScenarioInfo_CameraRecord = eAVScenarioInfo.CameraRecord;
pub const eAVScenarioInfo_DisplayRemotingWithFeatureMap = eAVScenarioInfo.DisplayRemotingWithFeatureMap;

pub const eVideoEncoderDisplayContentType = enum(i32) {
    Unknown = 0,
    FullScreenVideo = 1,
};
pub const eVideoEncoderDisplayContent_Unknown = eVideoEncoderDisplayContentType.Unknown;
pub const eVideoEncoderDisplayContent_FullScreenVideo = eVideoEncoderDisplayContentType.FullScreenVideo;

const CLSID_CODECAPI_AVEncVideoSelectLayer_Value = Guid.initString("eb1084f5-6aaa-4914-bb2f-6147227f12e7");
pub const CLSID_CODECAPI_AVEncVideoSelectLayer = &CLSID_CODECAPI_AVEncVideoSelectLayer_Value;

const CLSID_CODECAPI_AVEncVideoTemporalLayerCount_Value = Guid.initString("19caebff-b74d-4cfd-8c27-c2f9d97d5f52");
pub const CLSID_CODECAPI_AVEncVideoTemporalLayerCount = &CLSID_CODECAPI_AVEncVideoTemporalLayerCount_Value;

const CLSID_CODECAPI_AVEncVideoUsage_Value = Guid.initString("1f636849-5dc1-49f1-b1d8-ce3cf62ea385");
pub const CLSID_CODECAPI_AVEncVideoUsage = &CLSID_CODECAPI_AVEncVideoUsage_Value;

const CLSID_CODECAPI_AVEncVideoRateControlParams_Value = Guid.initString("87d43767-7645-44ec-b438-d3322fbca29f");
pub const CLSID_CODECAPI_AVEncVideoRateControlParams = &CLSID_CODECAPI_AVEncVideoRateControlParams_Value;

const CLSID_CODECAPI_AVEncVideoSupportedControls_Value = Guid.initString("d3f40fdd-77b9-473d-8196-061259e69cff");
pub const CLSID_CODECAPI_AVEncVideoSupportedControls = &CLSID_CODECAPI_AVEncVideoSupportedControls_Value;

const CLSID_CODECAPI_AVEncVideoEncodeFrameTypeQP_Value = Guid.initString("aa70b610-e03f-450c-ad07-07314e639ce7");
pub const CLSID_CODECAPI_AVEncVideoEncodeFrameTypeQP = &CLSID_CODECAPI_AVEncVideoEncodeFrameTypeQP_Value;

const CLSID_CODECAPI_AVEncSliceControlMode_Value = Guid.initString("e9e782ef-5f18-44c9-a90b-e9c3c2c17b0b");
pub const CLSID_CODECAPI_AVEncSliceControlMode = &CLSID_CODECAPI_AVEncSliceControlMode_Value;

const CLSID_CODECAPI_AVEncSliceControlSize_Value = Guid.initString("92f51df3-07a5-4172-aefe-c69ca3b60e35");
pub const CLSID_CODECAPI_AVEncSliceControlSize = &CLSID_CODECAPI_AVEncSliceControlSize_Value;

const CLSID_CODECAPI_AVEncSliceGenerationMode_Value = Guid.initString("8a6bc67f-9497-4286-b46b-02db8d60edbc");
pub const CLSID_CODECAPI_AVEncSliceGenerationMode = &CLSID_CODECAPI_AVEncSliceGenerationMode_Value;

const CLSID_CODECAPI_AVEncVideoMaxNumRefFrame_Value = Guid.initString("964829ed-94f9-43b4-b74d-ef40944b69a0");
pub const CLSID_CODECAPI_AVEncVideoMaxNumRefFrame = &CLSID_CODECAPI_AVEncVideoMaxNumRefFrame_Value;

const CLSID_CODECAPI_AVEncVideoMeanAbsoluteDifference_Value = Guid.initString("e5c0c10f-81a4-422d-8c3f-b474a4581336");
pub const CLSID_CODECAPI_AVEncVideoMeanAbsoluteDifference = &CLSID_CODECAPI_AVEncVideoMeanAbsoluteDifference_Value;

const CLSID_CODECAPI_AVEncVideoMaxQP_Value = Guid.initString("3daf6f66-a6a7-45e0-a8e5-f2743f46a3a2");
pub const CLSID_CODECAPI_AVEncVideoMaxQP = &CLSID_CODECAPI_AVEncVideoMaxQP_Value;

const CLSID_CODECAPI_AVEncVideoLTRBufferControl_Value = Guid.initString("a4a0e93d-4cbc-444c-89f4-826d310e92a7");
pub const CLSID_CODECAPI_AVEncVideoLTRBufferControl = &CLSID_CODECAPI_AVEncVideoLTRBufferControl_Value;

const CLSID_CODECAPI_AVEncVideoMarkLTRFrame_Value = Guid.initString("e42f4748-a06d-4ef9-8cea-3d05fde3bd3b");
pub const CLSID_CODECAPI_AVEncVideoMarkLTRFrame = &CLSID_CODECAPI_AVEncVideoMarkLTRFrame_Value;

const CLSID_CODECAPI_AVEncVideoUseLTRFrame_Value = Guid.initString("00752db8-55f7-4f80-895b-27639195f2ad");
pub const CLSID_CODECAPI_AVEncVideoUseLTRFrame = &CLSID_CODECAPI_AVEncVideoUseLTRFrame_Value;

const CLSID_CODECAPI_AVEncVideoROIEnabled_Value = Guid.initString("d74f7f18-44dd-4b85-aba3-05d9f42a8280");
pub const CLSID_CODECAPI_AVEncVideoROIEnabled = &CLSID_CODECAPI_AVEncVideoROIEnabled_Value;

const CLSID_CODECAPI_AVEncVideoDirtyRectEnabled_Value = Guid.initString("8acb8fdd-5e0c-4c66-8729-b8f629ab04fb");
pub const CLSID_CODECAPI_AVEncVideoDirtyRectEnabled = &CLSID_CODECAPI_AVEncVideoDirtyRectEnabled_Value;

const CLSID_CODECAPI_AVEncMaxFrameRate_Value = Guid.initString("b98e1b31-19fa-4d4f-9931-d6a5b8aab93c");
pub const CLSID_CODECAPI_AVEncMaxFrameRate = &CLSID_CODECAPI_AVEncMaxFrameRate_Value;

const CLSID_CODECAPI_AVEncMuxOutputStreamType_Value = Guid.initString("cedd9e8f-34d3-44db-a1d8-f81520254f3e");
pub const CLSID_CODECAPI_AVEncMuxOutputStreamType = &CLSID_CODECAPI_AVEncMuxOutputStreamType_Value;

pub const eAVEncMuxOutput = enum(i32) {
    Auto = 0,
    PS = 1,
    TS = 2,
};
pub const eAVEncMuxOutputAuto = eAVEncMuxOutput.Auto;
pub const eAVEncMuxOutputPS = eAVEncMuxOutput.PS;
pub const eAVEncMuxOutputTS = eAVEncMuxOutput.TS;

const CLSID_CODECAPI_AVEncStatVideoOutputFrameRate_Value = Guid.initString("be747849-9ab4-4a63-98fe-f143f04f8ee9");
pub const CLSID_CODECAPI_AVEncStatVideoOutputFrameRate = &CLSID_CODECAPI_AVEncStatVideoOutputFrameRate_Value;

const CLSID_CODECAPI_AVEncStatVideoCodedFrames_Value = Guid.initString("d47f8d61-6f5a-4a26-bb9f-cd9518462bcd");
pub const CLSID_CODECAPI_AVEncStatVideoCodedFrames = &CLSID_CODECAPI_AVEncStatVideoCodedFrames_Value;

const CLSID_CODECAPI_AVEncStatVideoTotalFrames_Value = Guid.initString("fdaa9916-119a-4222-9ad6-3f7cab99cc8b");
pub const CLSID_CODECAPI_AVEncStatVideoTotalFrames = &CLSID_CODECAPI_AVEncStatVideoTotalFrames_Value;

const CLSID_CODECAPI_AVEncAudioIntervalToEncode_Value = Guid.initString("866e4b4d-725a-467c-bb01-b496b23b25f9");
pub const CLSID_CODECAPI_AVEncAudioIntervalToEncode = &CLSID_CODECAPI_AVEncAudioIntervalToEncode_Value;

const CLSID_CODECAPI_AVEncAudioIntervalToSkip_Value = Guid.initString("88c15f94-c38c-4796-a9e8-96e967983f26");
pub const CLSID_CODECAPI_AVEncAudioIntervalToSkip = &CLSID_CODECAPI_AVEncAudioIntervalToSkip_Value;

const CLSID_CODECAPI_AVEncAudioDualMono_Value = Guid.initString("3648126b-a3e8-4329-9b3a-5ce566a43bd3");
pub const CLSID_CODECAPI_AVEncAudioDualMono = &CLSID_CODECAPI_AVEncAudioDualMono_Value;

pub const eAVEncAudioDualMono = enum(i32) {
    SameAsInput = 0,
    Off = 1,
    On = 2,
};
pub const eAVEncAudioDualMono_SameAsInput = eAVEncAudioDualMono.SameAsInput;
pub const eAVEncAudioDualMono_Off = eAVEncAudioDualMono.Off;
pub const eAVEncAudioDualMono_On = eAVEncAudioDualMono.On;

const CLSID_CODECAPI_AVEncAudioMeanBitRate_Value = Guid.initString("921295bb-4fca-4679-aab8-9e2a1d753384");
pub const CLSID_CODECAPI_AVEncAudioMeanBitRate = &CLSID_CODECAPI_AVEncAudioMeanBitRate_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel0_Value = Guid.initString("bc5d0b60-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel0 = &CLSID_CODECAPI_AVEncAudioMapDestChannel0_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel1_Value = Guid.initString("bc5d0b61-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel1 = &CLSID_CODECAPI_AVEncAudioMapDestChannel1_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel2_Value = Guid.initString("bc5d0b62-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel2 = &CLSID_CODECAPI_AVEncAudioMapDestChannel2_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel3_Value = Guid.initString("bc5d0b63-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel3 = &CLSID_CODECAPI_AVEncAudioMapDestChannel3_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel4_Value = Guid.initString("bc5d0b64-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel4 = &CLSID_CODECAPI_AVEncAudioMapDestChannel4_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel5_Value = Guid.initString("bc5d0b65-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel5 = &CLSID_CODECAPI_AVEncAudioMapDestChannel5_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel6_Value = Guid.initString("bc5d0b66-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel6 = &CLSID_CODECAPI_AVEncAudioMapDestChannel6_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel7_Value = Guid.initString("bc5d0b67-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel7 = &CLSID_CODECAPI_AVEncAudioMapDestChannel7_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel8_Value = Guid.initString("bc5d0b68-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel8 = &CLSID_CODECAPI_AVEncAudioMapDestChannel8_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel9_Value = Guid.initString("bc5d0b69-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel9 = &CLSID_CODECAPI_AVEncAudioMapDestChannel9_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel10_Value = Guid.initString("bc5d0b6a-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel10 = &CLSID_CODECAPI_AVEncAudioMapDestChannel10_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel11_Value = Guid.initString("bc5d0b6b-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel11 = &CLSID_CODECAPI_AVEncAudioMapDestChannel11_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel12_Value = Guid.initString("bc5d0b6c-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel12 = &CLSID_CODECAPI_AVEncAudioMapDestChannel12_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel13_Value = Guid.initString("bc5d0b6d-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel13 = &CLSID_CODECAPI_AVEncAudioMapDestChannel13_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel14_Value = Guid.initString("bc5d0b6e-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel14 = &CLSID_CODECAPI_AVEncAudioMapDestChannel14_Value;

const CLSID_CODECAPI_AVEncAudioMapDestChannel15_Value = Guid.initString("bc5d0b6f-df6a-4e16-9803-b82007a30c8d");
pub const CLSID_CODECAPI_AVEncAudioMapDestChannel15 = &CLSID_CODECAPI_AVEncAudioMapDestChannel15_Value;

const CLSID_CODECAPI_AVEncAudioInputContent_Value = Guid.initString("3e226c2b-60b9-4a39-b00b-a7b40f70d566");
pub const CLSID_CODECAPI_AVEncAudioInputContent = &CLSID_CODECAPI_AVEncAudioInputContent_Value;

pub const eAVEncAudioInputContent = enum(i32) {
    Unknown = 0,
    Voice = 1,
    Music = 2,
};
pub const AVEncAudioInputContent_Unknown = eAVEncAudioInputContent.Unknown;
pub const AVEncAudioInputContent_Voice = eAVEncAudioInputContent.Voice;
pub const AVEncAudioInputContent_Music = eAVEncAudioInputContent.Music;

const CLSID_CODECAPI_AVEncStatAudioPeakPCMValue_Value = Guid.initString("dce7fd34-dc00-4c16-821b-35d9eb00fb1a");
pub const CLSID_CODECAPI_AVEncStatAudioPeakPCMValue = &CLSID_CODECAPI_AVEncStatAudioPeakPCMValue_Value;

const CLSID_CODECAPI_AVEncStatAudioAveragePCMValue_Value = Guid.initString("979272f8-d17f-4e32-bb73-4e731c68ba2d");
pub const CLSID_CODECAPI_AVEncStatAudioAveragePCMValue = &CLSID_CODECAPI_AVEncStatAudioAveragePCMValue_Value;

const CLSID_CODECAPI_AVEncStatAudioAverageBPS_Value = Guid.initString("ca6724db-7059-4351-8b43-f82198826a14");
pub const CLSID_CODECAPI_AVEncStatAudioAverageBPS = &CLSID_CODECAPI_AVEncStatAudioAverageBPS_Value;

const CLSID_CODECAPI_AVEncStatAverageBPS_Value = Guid.initString("ca6724db-7059-4351-8b43-f82198826a14");
pub const CLSID_CODECAPI_AVEncStatAverageBPS = &CLSID_CODECAPI_AVEncStatAverageBPS_Value;

const CLSID_CODECAPI_AVEncStatHardwareProcessorUtilitization_Value = Guid.initString("995dc027-cb95-49e6-b91b-5967753cdcb8");
pub const CLSID_CODECAPI_AVEncStatHardwareProcessorUtilitization = &CLSID_CODECAPI_AVEncStatHardwareProcessorUtilitization_Value;

const CLSID_CODECAPI_AVEncStatHardwareBandwidthUtilitization_Value = Guid.initString("0124ba9b-dc41-4826-b45f-18ac01b3d5a8");
pub const CLSID_CODECAPI_AVEncStatHardwareBandwidthUtilitization = &CLSID_CODECAPI_AVEncStatHardwareBandwidthUtilitization_Value;

const CLSID_CODECAPI_AVEncMPVGOPSize_Value = Guid.initString("95f31b26-95a4-41aa-9303-246a7fc6eef1");
pub const CLSID_CODECAPI_AVEncMPVGOPSize = &CLSID_CODECAPI_AVEncMPVGOPSize_Value;

const CLSID_CODECAPI_AVEncMPVGOPOpen_Value = Guid.initString("b1d5d4a6-3300-49b1-ae61-a09937ab0e49");
pub const CLSID_CODECAPI_AVEncMPVGOPOpen = &CLSID_CODECAPI_AVEncMPVGOPOpen_Value;

const CLSID_CODECAPI_AVEncMPVDefaultBPictureCount_Value = Guid.initString("8d390aac-dc5c-4200-b57f-814d04babab2");
pub const CLSID_CODECAPI_AVEncMPVDefaultBPictureCount = &CLSID_CODECAPI_AVEncMPVDefaultBPictureCount_Value;

const CLSID_CODECAPI_AVEncMPVProfile_Value = Guid.initString("dabb534a-1d99-4284-975a-d90e2239baa1");
pub const CLSID_CODECAPI_AVEncMPVProfile = &CLSID_CODECAPI_AVEncMPVProfile_Value;

pub const eAVEncMPVProfile = enum(i32) {
    unknown = 0,
    Simple = 1,
    Main = 2,
    High = 3,
    @"422" = 4,
};
pub const eAVEncMPVProfile_unknown = eAVEncMPVProfile.unknown;
pub const eAVEncMPVProfile_Simple = eAVEncMPVProfile.Simple;
pub const eAVEncMPVProfile_Main = eAVEncMPVProfile.Main;
pub const eAVEncMPVProfile_High = eAVEncMPVProfile.High;
pub const eAVEncMPVProfile_422 = eAVEncMPVProfile.@"422";

const CLSID_CODECAPI_AVEncMPVLevel_Value = Guid.initString("6ee40c40-a60c-41ef-8f50-37c2249e2cb3");
pub const CLSID_CODECAPI_AVEncMPVLevel = &CLSID_CODECAPI_AVEncMPVLevel_Value;

pub const eAVEncMPVLevel = enum(i32) {
    Low = 1,
    Main = 2,
    High1440 = 3,
    High = 4,
};
pub const eAVEncMPVLevel_Low = eAVEncMPVLevel.Low;
pub const eAVEncMPVLevel_Main = eAVEncMPVLevel.Main;
pub const eAVEncMPVLevel_High1440 = eAVEncMPVLevel.High1440;
pub const eAVEncMPVLevel_High = eAVEncMPVLevel.High;

pub const eAVEncH263VProfile = enum(i32) {
    Base = 0,
    CompatibilityV2 = 1,
    CompatibilityV1 = 2,
    WirelessV2 = 3,
    WirelessV3 = 4,
    HighCompression = 5,
    Internet = 6,
    Interlace = 7,
    HighLatency = 8,
};
pub const eAVEncH263VProfile_Base = eAVEncH263VProfile.Base;
pub const eAVEncH263VProfile_CompatibilityV2 = eAVEncH263VProfile.CompatibilityV2;
pub const eAVEncH263VProfile_CompatibilityV1 = eAVEncH263VProfile.CompatibilityV1;
pub const eAVEncH263VProfile_WirelessV2 = eAVEncH263VProfile.WirelessV2;
pub const eAVEncH263VProfile_WirelessV3 = eAVEncH263VProfile.WirelessV3;
pub const eAVEncH263VProfile_HighCompression = eAVEncH263VProfile.HighCompression;
pub const eAVEncH263VProfile_Internet = eAVEncH263VProfile.Internet;
pub const eAVEncH263VProfile_Interlace = eAVEncH263VProfile.Interlace;
pub const eAVEncH263VProfile_HighLatency = eAVEncH263VProfile.HighLatency;

pub const eAVEncH264VProfile = enum(i32) {
    unknown = 0,
    Simple = 66,
    // Base = 66, this enum value conflicts with Simple
    Main = 77,
    High = 100,
    @"422" = 122,
    High10 = 110,
    @"444" = 244,
    Extended = 88,
    ScalableBase = 83,
    ScalableHigh = 86,
    MultiviewHigh = 118,
    StereoHigh = 128,
    ConstrainedBase = 256,
    UCConstrainedHigh = 257,
    UCScalableConstrainedBase = 258,
    UCScalableConstrainedHigh = 259,
};
pub const eAVEncH264VProfile_unknown = eAVEncH264VProfile.unknown;
pub const eAVEncH264VProfile_Simple = eAVEncH264VProfile.Simple;
pub const eAVEncH264VProfile_Base = eAVEncH264VProfile.Simple;
pub const eAVEncH264VProfile_Main = eAVEncH264VProfile.Main;
pub const eAVEncH264VProfile_High = eAVEncH264VProfile.High;
pub const eAVEncH264VProfile_422 = eAVEncH264VProfile.@"422";
pub const eAVEncH264VProfile_High10 = eAVEncH264VProfile.High10;
pub const eAVEncH264VProfile_444 = eAVEncH264VProfile.@"444";
pub const eAVEncH264VProfile_Extended = eAVEncH264VProfile.Extended;
pub const eAVEncH264VProfile_ScalableBase = eAVEncH264VProfile.ScalableBase;
pub const eAVEncH264VProfile_ScalableHigh = eAVEncH264VProfile.ScalableHigh;
pub const eAVEncH264VProfile_MultiviewHigh = eAVEncH264VProfile.MultiviewHigh;
pub const eAVEncH264VProfile_StereoHigh = eAVEncH264VProfile.StereoHigh;
pub const eAVEncH264VProfile_ConstrainedBase = eAVEncH264VProfile.ConstrainedBase;
pub const eAVEncH264VProfile_UCConstrainedHigh = eAVEncH264VProfile.UCConstrainedHigh;
pub const eAVEncH264VProfile_UCScalableConstrainedBase = eAVEncH264VProfile.UCScalableConstrainedBase;
pub const eAVEncH264VProfile_UCScalableConstrainedHigh = eAVEncH264VProfile.UCScalableConstrainedHigh;

pub const eAVEncH265VProfile = enum(i32) {
    unknown = 0,
    Main_420_8 = 1,
    Main_420_10 = 2,
    Main_420_12 = 3,
    Main_422_10 = 4,
    Main_422_12 = 5,
    Main_444_8 = 6,
    Main_444_10 = 7,
    Main_444_12 = 8,
    Monochrome_12 = 9,
    Monochrome_16 = 10,
    MainIntra_420_8 = 11,
    MainIntra_420_10 = 12,
    MainIntra_420_12 = 13,
    MainIntra_422_10 = 14,
    MainIntra_422_12 = 15,
    MainIntra_444_8 = 16,
    MainIntra_444_10 = 17,
    MainIntra_444_12 = 18,
    MainIntra_444_16 = 19,
    MainStill_420_8 = 20,
    MainStill_444_8 = 21,
    MainStill_444_16 = 22,
};
pub const eAVEncH265VProfile_unknown = eAVEncH265VProfile.unknown;
pub const eAVEncH265VProfile_Main_420_8 = eAVEncH265VProfile.Main_420_8;
pub const eAVEncH265VProfile_Main_420_10 = eAVEncH265VProfile.Main_420_10;
pub const eAVEncH265VProfile_Main_420_12 = eAVEncH265VProfile.Main_420_12;
pub const eAVEncH265VProfile_Main_422_10 = eAVEncH265VProfile.Main_422_10;
pub const eAVEncH265VProfile_Main_422_12 = eAVEncH265VProfile.Main_422_12;
pub const eAVEncH265VProfile_Main_444_8 = eAVEncH265VProfile.Main_444_8;
pub const eAVEncH265VProfile_Main_444_10 = eAVEncH265VProfile.Main_444_10;
pub const eAVEncH265VProfile_Main_444_12 = eAVEncH265VProfile.Main_444_12;
pub const eAVEncH265VProfile_Monochrome_12 = eAVEncH265VProfile.Monochrome_12;
pub const eAVEncH265VProfile_Monochrome_16 = eAVEncH265VProfile.Monochrome_16;
pub const eAVEncH265VProfile_MainIntra_420_8 = eAVEncH265VProfile.MainIntra_420_8;
pub const eAVEncH265VProfile_MainIntra_420_10 = eAVEncH265VProfile.MainIntra_420_10;
pub const eAVEncH265VProfile_MainIntra_420_12 = eAVEncH265VProfile.MainIntra_420_12;
pub const eAVEncH265VProfile_MainIntra_422_10 = eAVEncH265VProfile.MainIntra_422_10;
pub const eAVEncH265VProfile_MainIntra_422_12 = eAVEncH265VProfile.MainIntra_422_12;
pub const eAVEncH265VProfile_MainIntra_444_8 = eAVEncH265VProfile.MainIntra_444_8;
pub const eAVEncH265VProfile_MainIntra_444_10 = eAVEncH265VProfile.MainIntra_444_10;
pub const eAVEncH265VProfile_MainIntra_444_12 = eAVEncH265VProfile.MainIntra_444_12;
pub const eAVEncH265VProfile_MainIntra_444_16 = eAVEncH265VProfile.MainIntra_444_16;
pub const eAVEncH265VProfile_MainStill_420_8 = eAVEncH265VProfile.MainStill_420_8;
pub const eAVEncH265VProfile_MainStill_444_8 = eAVEncH265VProfile.MainStill_444_8;
pub const eAVEncH265VProfile_MainStill_444_16 = eAVEncH265VProfile.MainStill_444_16;

pub const eAVEncVP9VProfile = enum(i32) {
    unknown = 0,
    @"420_8" = 1,
    @"420_10" = 2,
    @"420_12" = 3,
};
pub const eAVEncVP9VProfile_unknown = eAVEncVP9VProfile.unknown;
pub const eAVEncVP9VProfile_420_8 = eAVEncVP9VProfile.@"420_8";
pub const eAVEncVP9VProfile_420_10 = eAVEncVP9VProfile.@"420_10";
pub const eAVEncVP9VProfile_420_12 = eAVEncVP9VProfile.@"420_12";

pub const eAVEncH263PictureType = enum(i32) {
    I = 0,
    P = 1,
    B = 2,
};
pub const eAVEncH263PictureType_I = eAVEncH263PictureType.I;
pub const eAVEncH263PictureType_P = eAVEncH263PictureType.P;
pub const eAVEncH263PictureType_B = eAVEncH263PictureType.B;

pub const eAVEncH264PictureType = enum(i32) {
    IDR = 0,
    P = 1,
    B = 2,
};
pub const eAVEncH264PictureType_IDR = eAVEncH264PictureType.IDR;
pub const eAVEncH264PictureType_P = eAVEncH264PictureType.P;
pub const eAVEncH264PictureType_B = eAVEncH264PictureType.B;

pub const eAVEncH263VLevel = enum(i32) {
    @"1" = 10,
    @"2" = 20,
    @"3" = 30,
    @"4" = 40,
    @"4_5" = 45,
    @"5" = 50,
    @"6" = 60,
    @"7" = 70,
};
pub const eAVEncH263VLevel1 = eAVEncH263VLevel.@"1";
pub const eAVEncH263VLevel2 = eAVEncH263VLevel.@"2";
pub const eAVEncH263VLevel3 = eAVEncH263VLevel.@"3";
pub const eAVEncH263VLevel4 = eAVEncH263VLevel.@"4";
pub const eAVEncH263VLevel4_5 = eAVEncH263VLevel.@"4_5";
pub const eAVEncH263VLevel5 = eAVEncH263VLevel.@"5";
pub const eAVEncH263VLevel6 = eAVEncH263VLevel.@"6";
pub const eAVEncH263VLevel7 = eAVEncH263VLevel.@"7";

pub const eAVEncH264VLevel = enum(i32) {
    @"1" = 10,
    @"1_b" = 11,
    // @"1_1" = 11, this enum value conflicts with @"1_b"
    @"1_2" = 12,
    @"1_3" = 13,
    @"2" = 20,
    @"2_1" = 21,
    @"2_2" = 22,
    @"3" = 30,
    @"3_1" = 31,
    @"3_2" = 32,
    @"4" = 40,
    @"4_1" = 41,
    @"4_2" = 42,
    @"5" = 50,
    @"5_1" = 51,
    @"5_2" = 52,
};
pub const eAVEncH264VLevel1 = eAVEncH264VLevel.@"1";
pub const eAVEncH264VLevel1_b = eAVEncH264VLevel.@"1_b";
pub const eAVEncH264VLevel1_1 = eAVEncH264VLevel.@"1_b";
pub const eAVEncH264VLevel1_2 = eAVEncH264VLevel.@"1_2";
pub const eAVEncH264VLevel1_3 = eAVEncH264VLevel.@"1_3";
pub const eAVEncH264VLevel2 = eAVEncH264VLevel.@"2";
pub const eAVEncH264VLevel2_1 = eAVEncH264VLevel.@"2_1";
pub const eAVEncH264VLevel2_2 = eAVEncH264VLevel.@"2_2";
pub const eAVEncH264VLevel3 = eAVEncH264VLevel.@"3";
pub const eAVEncH264VLevel3_1 = eAVEncH264VLevel.@"3_1";
pub const eAVEncH264VLevel3_2 = eAVEncH264VLevel.@"3_2";
pub const eAVEncH264VLevel4 = eAVEncH264VLevel.@"4";
pub const eAVEncH264VLevel4_1 = eAVEncH264VLevel.@"4_1";
pub const eAVEncH264VLevel4_2 = eAVEncH264VLevel.@"4_2";
pub const eAVEncH264VLevel5 = eAVEncH264VLevel.@"5";
pub const eAVEncH264VLevel5_1 = eAVEncH264VLevel.@"5_1";
pub const eAVEncH264VLevel5_2 = eAVEncH264VLevel.@"5_2";

pub const eAVEncH265VLevel = enum(i32) {
    @"1" = 30,
    @"2" = 60,
    @"2_1" = 63,
    @"3" = 90,
    @"3_1" = 93,
    @"4" = 120,
    @"4_1" = 123,
    @"5" = 150,
    @"5_1" = 153,
    @"5_2" = 156,
    @"6" = 180,
    @"6_1" = 183,
    @"6_2" = 186,
};
pub const eAVEncH265VLevel1 = eAVEncH265VLevel.@"1";
pub const eAVEncH265VLevel2 = eAVEncH265VLevel.@"2";
pub const eAVEncH265VLevel2_1 = eAVEncH265VLevel.@"2_1";
pub const eAVEncH265VLevel3 = eAVEncH265VLevel.@"3";
pub const eAVEncH265VLevel3_1 = eAVEncH265VLevel.@"3_1";
pub const eAVEncH265VLevel4 = eAVEncH265VLevel.@"4";
pub const eAVEncH265VLevel4_1 = eAVEncH265VLevel.@"4_1";
pub const eAVEncH265VLevel5 = eAVEncH265VLevel.@"5";
pub const eAVEncH265VLevel5_1 = eAVEncH265VLevel.@"5_1";
pub const eAVEncH265VLevel5_2 = eAVEncH265VLevel.@"5_2";
pub const eAVEncH265VLevel6 = eAVEncH265VLevel.@"6";
pub const eAVEncH265VLevel6_1 = eAVEncH265VLevel.@"6_1";
pub const eAVEncH265VLevel6_2 = eAVEncH265VLevel.@"6_2";

const CLSID_CODECAPI_AVEncMPVFrameFieldMode_Value = Guid.initString("acb5de96-7b93-4c2f-8825-b0295fa93bf4");
pub const CLSID_CODECAPI_AVEncMPVFrameFieldMode = &CLSID_CODECAPI_AVEncMPVFrameFieldMode_Value;

pub const eAVEncMPVFrameFieldMode = enum(i32) {
    ieldMode = 0,
    rameMode = 1,
};
pub const eAVEncMPVFrameFieldMode_FieldMode = eAVEncMPVFrameFieldMode.ieldMode;
pub const eAVEncMPVFrameFieldMode_FrameMode = eAVEncMPVFrameFieldMode.rameMode;

const CLSID_CODECAPI_AVEncMPVAddSeqEndCode_Value = Guid.initString("a823178f-57df-4c7a-b8fd-e5ec8887708d");
pub const CLSID_CODECAPI_AVEncMPVAddSeqEndCode = &CLSID_CODECAPI_AVEncMPVAddSeqEndCode_Value;

const CLSID_CODECAPI_AVEncMPVGOPSInSeq_Value = Guid.initString("993410d4-2691-4192-9978-98dc2603669f");
pub const CLSID_CODECAPI_AVEncMPVGOPSInSeq = &CLSID_CODECAPI_AVEncMPVGOPSInSeq_Value;

const CLSID_CODECAPI_AVEncMPVUseConcealmentMotionVectors_Value = Guid.initString("ec770cf3-6908-4b4b-aa30-7fb986214fea");
pub const CLSID_CODECAPI_AVEncMPVUseConcealmentMotionVectors = &CLSID_CODECAPI_AVEncMPVUseConcealmentMotionVectors_Value;

const CLSID_CODECAPI_AVEncMPVSceneDetection_Value = Guid.initString("552799f1-db4c-405b-8a3a-c93f2d0674dc");
pub const CLSID_CODECAPI_AVEncMPVSceneDetection = &CLSID_CODECAPI_AVEncMPVSceneDetection_Value;

pub const eAVEncMPVSceneDetection = enum(i32) {
    None = 0,
    InsertIPicture = 1,
    StartNewGOP = 2,
    StartNewLocatableGOP = 3,
};
pub const eAVEncMPVSceneDetection_None = eAVEncMPVSceneDetection.None;
pub const eAVEncMPVSceneDetection_InsertIPicture = eAVEncMPVSceneDetection.InsertIPicture;
pub const eAVEncMPVSceneDetection_StartNewGOP = eAVEncMPVSceneDetection.StartNewGOP;
pub const eAVEncMPVSceneDetection_StartNewLocatableGOP = eAVEncMPVSceneDetection.StartNewLocatableGOP;

const CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqExt_Value = Guid.initString("d5e78611-082d-4e6b-98af-0f51ab139222");
pub const CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqExt = &CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqExt_Value;

const CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqDispExt_Value = Guid.initString("6437aa6f-5a3c-4de9-8a16-53d9c4ad326f");
pub const CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqDispExt = &CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqDispExt_Value;

const CLSID_CODECAPI_AVEncMPVGenerateHeaderPicExt_Value = Guid.initString("1b8464ab-944f-45f0-b74e-3a58dad11f37");
pub const CLSID_CODECAPI_AVEncMPVGenerateHeaderPicExt = &CLSID_CODECAPI_AVEncMPVGenerateHeaderPicExt_Value;

const CLSID_CODECAPI_AVEncMPVGenerateHeaderPicDispExt_Value = Guid.initString("c6412f84-c03f-4f40-a00c-4293df8395bb");
pub const CLSID_CODECAPI_AVEncMPVGenerateHeaderPicDispExt = &CLSID_CODECAPI_AVEncMPVGenerateHeaderPicDispExt_Value;

const CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt_Value = Guid.initString("0722d62f-dd59-4a86-9cd5-644f8e2653d8");
pub const CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt = &CLSID_CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt_Value;

const CLSID_CODECAPI_AVEncMPVScanPattern_Value = Guid.initString("7f8a478e-7bbb-4ae2-b2fc-96d17fc4a2d6");
pub const CLSID_CODECAPI_AVEncMPVScanPattern = &CLSID_CODECAPI_AVEncMPVScanPattern_Value;

pub const eAVEncMPVScanPattern = enum(i32) {
    Auto = 0,
    ZigZagScan = 1,
    AlternateScan = 2,
};
pub const eAVEncMPVScanPattern_Auto = eAVEncMPVScanPattern.Auto;
pub const eAVEncMPVScanPattern_ZigZagScan = eAVEncMPVScanPattern.ZigZagScan;
pub const eAVEncMPVScanPattern_AlternateScan = eAVEncMPVScanPattern.AlternateScan;

const CLSID_CODECAPI_AVEncMPVIntraDCPrecision_Value = Guid.initString("a0116151-cbc8-4af3-97dc-d00cceb82d79");
pub const CLSID_CODECAPI_AVEncMPVIntraDCPrecision = &CLSID_CODECAPI_AVEncMPVIntraDCPrecision_Value;

const CLSID_CODECAPI_AVEncMPVQScaleType_Value = Guid.initString("2b79ebb7-f484-4af7-bb58-a2a188c5cbbe");
pub const CLSID_CODECAPI_AVEncMPVQScaleType = &CLSID_CODECAPI_AVEncMPVQScaleType_Value;

pub const eAVEncMPVQScaleType = enum(i32) {
    Auto = 0,
    Linear = 1,
    NonLinear = 2,
};
pub const eAVEncMPVQScaleType_Auto = eAVEncMPVQScaleType.Auto;
pub const eAVEncMPVQScaleType_Linear = eAVEncMPVQScaleType.Linear;
pub const eAVEncMPVQScaleType_NonLinear = eAVEncMPVQScaleType.NonLinear;

const CLSID_CODECAPI_AVEncMPVIntraVLCTable_Value = Guid.initString("a2b83ff5-1a99-405a-af95-c5997d558d3a");
pub const CLSID_CODECAPI_AVEncMPVIntraVLCTable = &CLSID_CODECAPI_AVEncMPVIntraVLCTable_Value;

pub const eAVEncMPVIntraVLCTable = enum(i32) {
    Auto = 0,
    MPEG1 = 1,
    Alternate = 2,
};
pub const eAVEncMPVIntraVLCTable_Auto = eAVEncMPVIntraVLCTable.Auto;
pub const eAVEncMPVIntraVLCTable_MPEG1 = eAVEncMPVIntraVLCTable.MPEG1;
pub const eAVEncMPVIntraVLCTable_Alternate = eAVEncMPVIntraVLCTable.Alternate;

const CLSID_CODECAPI_AVEncMPVQuantMatrixIntra_Value = Guid.initString("9bea04f3-6621-442c-8ba1-3ac378979698");
pub const CLSID_CODECAPI_AVEncMPVQuantMatrixIntra = &CLSID_CODECAPI_AVEncMPVQuantMatrixIntra_Value;

const CLSID_CODECAPI_AVEncMPVQuantMatrixNonIntra_Value = Guid.initString("87f441d8-0997-4beb-a08e-8573d409cf75");
pub const CLSID_CODECAPI_AVEncMPVQuantMatrixNonIntra = &CLSID_CODECAPI_AVEncMPVQuantMatrixNonIntra_Value;

const CLSID_CODECAPI_AVEncMPVQuantMatrixChromaIntra_Value = Guid.initString("9eb9ecd4-018d-4ffd-8f2d-39e49f07b17a");
pub const CLSID_CODECAPI_AVEncMPVQuantMatrixChromaIntra = &CLSID_CODECAPI_AVEncMPVQuantMatrixChromaIntra_Value;

const CLSID_CODECAPI_AVEncMPVQuantMatrixChromaNonIntra_Value = Guid.initString("1415b6b1-362a-4338-ba9a-1ef58703c05b");
pub const CLSID_CODECAPI_AVEncMPVQuantMatrixChromaNonIntra = &CLSID_CODECAPI_AVEncMPVQuantMatrixChromaNonIntra_Value;

const CLSID_CODECAPI_AVEncMPALayer_Value = Guid.initString("9d377230-f91b-453d-9ce0-78445414c22d");
pub const CLSID_CODECAPI_AVEncMPALayer = &CLSID_CODECAPI_AVEncMPALayer_Value;

pub const eAVEncMPALayer = enum(i32) {
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
};
pub const eAVEncMPALayer_1 = eAVEncMPALayer.@"1";
pub const eAVEncMPALayer_2 = eAVEncMPALayer.@"2";
pub const eAVEncMPALayer_3 = eAVEncMPALayer.@"3";

const CLSID_CODECAPI_AVEncMPACodingMode_Value = Guid.initString("b16ade03-4b93-43d7-a550-90b4fe224537");
pub const CLSID_CODECAPI_AVEncMPACodingMode = &CLSID_CODECAPI_AVEncMPACodingMode_Value;

pub const eAVEncMPACodingMode = enum(i32) {
    Mono = 0,
    Stereo = 1,
    DualChannel = 2,
    JointStereo = 3,
    Surround = 4,
};
pub const eAVEncMPACodingMode_Mono = eAVEncMPACodingMode.Mono;
pub const eAVEncMPACodingMode_Stereo = eAVEncMPACodingMode.Stereo;
pub const eAVEncMPACodingMode_DualChannel = eAVEncMPACodingMode.DualChannel;
pub const eAVEncMPACodingMode_JointStereo = eAVEncMPACodingMode.JointStereo;
pub const eAVEncMPACodingMode_Surround = eAVEncMPACodingMode.Surround;

const CLSID_CODECAPI_AVEncMPACopyright_Value = Guid.initString("a6ae762a-d0a9-4454-b8ef-f2dbeefdd3bd");
pub const CLSID_CODECAPI_AVEncMPACopyright = &CLSID_CODECAPI_AVEncMPACopyright_Value;

const CLSID_CODECAPI_AVEncMPAOriginalBitstream_Value = Guid.initString("3cfb7855-9cc9-47ff-b829-b36786c92346");
pub const CLSID_CODECAPI_AVEncMPAOriginalBitstream = &CLSID_CODECAPI_AVEncMPAOriginalBitstream_Value;

const CLSID_CODECAPI_AVEncMPAEnableRedundancyProtection_Value = Guid.initString("5e54b09e-b2e7-4973-a89b-0b3650a3beda");
pub const CLSID_CODECAPI_AVEncMPAEnableRedundancyProtection = &CLSID_CODECAPI_AVEncMPAEnableRedundancyProtection_Value;

const CLSID_CODECAPI_AVEncMPAPrivateUserBit_Value = Guid.initString("afa505ce-c1e3-4e3d-851b-61b700e5e6cc");
pub const CLSID_CODECAPI_AVEncMPAPrivateUserBit = &CLSID_CODECAPI_AVEncMPAPrivateUserBit_Value;

const CLSID_CODECAPI_AVEncMPAEmphasisType_Value = Guid.initString("2d59fcda-bf4e-4ed6-b5df-5b03b36b0a1f");
pub const CLSID_CODECAPI_AVEncMPAEmphasisType = &CLSID_CODECAPI_AVEncMPAEmphasisType_Value;

pub const eAVEncMPAEmphasisType = enum(i32) {
    None = 0,
    @"50_15" = 1,
    Reserved = 2,
    CCITT_J17 = 3,
};
pub const eAVEncMPAEmphasisType_None = eAVEncMPAEmphasisType.None;
pub const eAVEncMPAEmphasisType_50_15 = eAVEncMPAEmphasisType.@"50_15";
pub const eAVEncMPAEmphasisType_Reserved = eAVEncMPAEmphasisType.Reserved;
pub const eAVEncMPAEmphasisType_CCITT_J17 = eAVEncMPAEmphasisType.CCITT_J17;

const CLSID_CODECAPI_AVEncDDService_Value = Guid.initString("d2e1bec7-5172-4d2a-a50e-2f3b82b1ddf8");
pub const CLSID_CODECAPI_AVEncDDService = &CLSID_CODECAPI_AVEncDDService_Value;

pub const eAVEncDDService = enum(i32) {
    CM = 0,
    ME = 1,
    VI = 2,
    HI = 3,
    D = 4,
    C = 5,
    E = 6,
    VO = 7,
};
pub const eAVEncDDService_CM = eAVEncDDService.CM;
pub const eAVEncDDService_ME = eAVEncDDService.ME;
pub const eAVEncDDService_VI = eAVEncDDService.VI;
pub const eAVEncDDService_HI = eAVEncDDService.HI;
pub const eAVEncDDService_D = eAVEncDDService.D;
pub const eAVEncDDService_C = eAVEncDDService.C;
pub const eAVEncDDService_E = eAVEncDDService.E;
pub const eAVEncDDService_VO = eAVEncDDService.VO;

const CLSID_CODECAPI_AVEncDDDialogNormalization_Value = Guid.initString("d7055acf-f125-437d-a704-79c79f0404a8");
pub const CLSID_CODECAPI_AVEncDDDialogNormalization = &CLSID_CODECAPI_AVEncDDDialogNormalization_Value;

const CLSID_CODECAPI_AVEncDDCentreDownMixLevel_Value = Guid.initString("e285072c-c958-4a81-afd2-e5e0daf1b148");
pub const CLSID_CODECAPI_AVEncDDCentreDownMixLevel = &CLSID_CODECAPI_AVEncDDCentreDownMixLevel_Value;

const CLSID_CODECAPI_AVEncDDSurroundDownMixLevel_Value = Guid.initString("7b20d6e5-0bcf-4273-a487-506b047997e9");
pub const CLSID_CODECAPI_AVEncDDSurroundDownMixLevel = &CLSID_CODECAPI_AVEncDDSurroundDownMixLevel_Value;

const CLSID_CODECAPI_AVEncDDProductionInfoExists_Value = Guid.initString("b0b7fe5f-b6ab-4f40-964d-8d91f17c19e8");
pub const CLSID_CODECAPI_AVEncDDProductionInfoExists = &CLSID_CODECAPI_AVEncDDProductionInfoExists_Value;

const CLSID_CODECAPI_AVEncDDProductionRoomType_Value = Guid.initString("dad7ad60-23d8-4ab7-a284-556986d8a6fe");
pub const CLSID_CODECAPI_AVEncDDProductionRoomType = &CLSID_CODECAPI_AVEncDDProductionRoomType_Value;

pub const eAVEncDDProductionRoomType = enum(i32) {
    NotIndicated = 0,
    Large = 1,
    Small = 2,
};
pub const eAVEncDDProductionRoomType_NotIndicated = eAVEncDDProductionRoomType.NotIndicated;
pub const eAVEncDDProductionRoomType_Large = eAVEncDDProductionRoomType.Large;
pub const eAVEncDDProductionRoomType_Small = eAVEncDDProductionRoomType.Small;

const CLSID_CODECAPI_AVEncDDProductionMixLevel_Value = Guid.initString("301d103a-cbf9-4776-8899-7c15b461ab26");
pub const CLSID_CODECAPI_AVEncDDProductionMixLevel = &CLSID_CODECAPI_AVEncDDProductionMixLevel_Value;

const CLSID_CODECAPI_AVEncDDCopyright_Value = Guid.initString("8694f076-cd75-481d-a5c6-a904dcc828f0");
pub const CLSID_CODECAPI_AVEncDDCopyright = &CLSID_CODECAPI_AVEncDDCopyright_Value;

const CLSID_CODECAPI_AVEncDDOriginalBitstream_Value = Guid.initString("966ae800-5bd3-4ff9-95b9-d30566273856");
pub const CLSID_CODECAPI_AVEncDDOriginalBitstream = &CLSID_CODECAPI_AVEncDDOriginalBitstream_Value;

const CLSID_CODECAPI_AVEncDDDigitalDeemphasis_Value = Guid.initString("e024a2c2-947c-45ac-87d8-f1030c5c0082");
pub const CLSID_CODECAPI_AVEncDDDigitalDeemphasis = &CLSID_CODECAPI_AVEncDDDigitalDeemphasis_Value;

const CLSID_CODECAPI_AVEncDDDCHighPassFilter_Value = Guid.initString("9565239f-861c-4ac8-bfda-e00cb4db8548");
pub const CLSID_CODECAPI_AVEncDDDCHighPassFilter = &CLSID_CODECAPI_AVEncDDDCHighPassFilter_Value;

const CLSID_CODECAPI_AVEncDDChannelBWLowPassFilter_Value = Guid.initString("e197821d-d2e7-43e2-ad2c-00582f518545");
pub const CLSID_CODECAPI_AVEncDDChannelBWLowPassFilter = &CLSID_CODECAPI_AVEncDDChannelBWLowPassFilter_Value;

const CLSID_CODECAPI_AVEncDDLFELowPassFilter_Value = Guid.initString("d3b80f6f-9d15-45e5-91be-019c3fab1f01");
pub const CLSID_CODECAPI_AVEncDDLFELowPassFilter = &CLSID_CODECAPI_AVEncDDLFELowPassFilter_Value;

const CLSID_CODECAPI_AVEncDDSurround90DegreeePhaseShift_Value = Guid.initString("25ecec9d-3553-42c0-bb56-d25792104f80");
pub const CLSID_CODECAPI_AVEncDDSurround90DegreeePhaseShift = &CLSID_CODECAPI_AVEncDDSurround90DegreeePhaseShift_Value;

const CLSID_CODECAPI_AVEncDDSurround3dBAttenuation_Value = Guid.initString("4d43b99d-31e2-48b9-bf2e-5cbf1a572784");
pub const CLSID_CODECAPI_AVEncDDSurround3dBAttenuation = &CLSID_CODECAPI_AVEncDDSurround3dBAttenuation_Value;

const CLSID_CODECAPI_AVEncDDDynamicRangeCompressionControl_Value = Guid.initString("cfc2ff6d-79b8-4b8d-a8aa-a0c9bd1c2940");
pub const CLSID_CODECAPI_AVEncDDDynamicRangeCompressionControl = &CLSID_CODECAPI_AVEncDDDynamicRangeCompressionControl_Value;

pub const eAVEncDDDynamicRangeCompressionControl = enum(i32) {
    None = 0,
    FilmStandard = 1,
    FilmLight = 2,
    MusicStandard = 3,
    MusicLight = 4,
    Speech = 5,
};
pub const eAVEncDDDynamicRangeCompressionControl_None = eAVEncDDDynamicRangeCompressionControl.None;
pub const eAVEncDDDynamicRangeCompressionControl_FilmStandard = eAVEncDDDynamicRangeCompressionControl.FilmStandard;
pub const eAVEncDDDynamicRangeCompressionControl_FilmLight = eAVEncDDDynamicRangeCompressionControl.FilmLight;
pub const eAVEncDDDynamicRangeCompressionControl_MusicStandard = eAVEncDDDynamicRangeCompressionControl.MusicStandard;
pub const eAVEncDDDynamicRangeCompressionControl_MusicLight = eAVEncDDDynamicRangeCompressionControl.MusicLight;
pub const eAVEncDDDynamicRangeCompressionControl_Speech = eAVEncDDDynamicRangeCompressionControl.Speech;

const CLSID_CODECAPI_AVEncDDRFPreEmphasisFilter_Value = Guid.initString("21af44c0-244e-4f3d-a2cc-3d3068b2e73f");
pub const CLSID_CODECAPI_AVEncDDRFPreEmphasisFilter = &CLSID_CODECAPI_AVEncDDRFPreEmphasisFilter_Value;

const CLSID_CODECAPI_AVEncDDSurroundExMode_Value = Guid.initString("91607cee-dbdd-4eb6-bca2-aadfafa3dd68");
pub const CLSID_CODECAPI_AVEncDDSurroundExMode = &CLSID_CODECAPI_AVEncDDSurroundExMode_Value;

pub const eAVEncDDSurroundExMode = enum(i32) {
    NotIndicated = 0,
    No = 1,
    Yes = 2,
};
pub const eAVEncDDSurroundExMode_NotIndicated = eAVEncDDSurroundExMode.NotIndicated;
pub const eAVEncDDSurroundExMode_No = eAVEncDDSurroundExMode.No;
pub const eAVEncDDSurroundExMode_Yes = eAVEncDDSurroundExMode.Yes;

const CLSID_CODECAPI_AVEncDDPreferredStereoDownMixMode_Value = Guid.initString("7f4e6b31-9185-403d-b0a2-763743e6f063");
pub const CLSID_CODECAPI_AVEncDDPreferredStereoDownMixMode = &CLSID_CODECAPI_AVEncDDPreferredStereoDownMixMode_Value;

pub const eAVEncDDPreferredStereoDownMixMode = enum(i32) {
    tRt = 0,
    oRo = 1,
};
pub const eAVEncDDPreferredStereoDownMixMode_LtRt = eAVEncDDPreferredStereoDownMixMode.tRt;
pub const eAVEncDDPreferredStereoDownMixMode_LoRo = eAVEncDDPreferredStereoDownMixMode.oRo;

const CLSID_CODECAPI_AVEncDDLtRtCenterMixLvl_x10_Value = Guid.initString("dca128a2-491f-4600-b2da-76e3344b4197");
pub const CLSID_CODECAPI_AVEncDDLtRtCenterMixLvl_x10 = &CLSID_CODECAPI_AVEncDDLtRtCenterMixLvl_x10_Value;

const CLSID_CODECAPI_AVEncDDLtRtSurroundMixLvl_x10_Value = Guid.initString("212246c7-3d2c-4dfa-bc21-652a9098690d");
pub const CLSID_CODECAPI_AVEncDDLtRtSurroundMixLvl_x10 = &CLSID_CODECAPI_AVEncDDLtRtSurroundMixLvl_x10_Value;

const CLSID_CODECAPI_AVEncDDLoRoCenterMixLvl_x10_Value = Guid.initString("1cfba222-25b3-4bf4-9bfd-e7111267858c");
pub const CLSID_CODECAPI_AVEncDDLoRoCenterMixLvl_x10 = &CLSID_CODECAPI_AVEncDDLoRoCenterMixLvl_x10_Value;

const CLSID_CODECAPI_AVEncDDLoRoSurroundMixLvl_x10_Value = Guid.initString("e725cff6-eb56-40c7-8450-2b9367e91555");
pub const CLSID_CODECAPI_AVEncDDLoRoSurroundMixLvl_x10 = &CLSID_CODECAPI_AVEncDDLoRoSurroundMixLvl_x10_Value;

const CLSID_CODECAPI_AVEncDDAtoDConverterType_Value = Guid.initString("719f9612-81a1-47e0-9a05-d94ad5fca948");
pub const CLSID_CODECAPI_AVEncDDAtoDConverterType = &CLSID_CODECAPI_AVEncDDAtoDConverterType_Value;

pub const eAVEncDDAtoDConverterType = enum(i32) {
    Standard = 0,
    HDCD = 1,
};
pub const eAVEncDDAtoDConverterType_Standard = eAVEncDDAtoDConverterType.Standard;
pub const eAVEncDDAtoDConverterType_HDCD = eAVEncDDAtoDConverterType.HDCD;

const CLSID_CODECAPI_AVEncDDHeadphoneMode_Value = Guid.initString("4052dbec-52f5-42f5-9b00-d134b1341b9d");
pub const CLSID_CODECAPI_AVEncDDHeadphoneMode = &CLSID_CODECAPI_AVEncDDHeadphoneMode_Value;

pub const eAVEncDDHeadphoneMode = enum(i32) {
    NotIndicated = 0,
    NotEncoded = 1,
    Encoded = 2,
};
pub const eAVEncDDHeadphoneMode_NotIndicated = eAVEncDDHeadphoneMode.NotIndicated;
pub const eAVEncDDHeadphoneMode_NotEncoded = eAVEncDDHeadphoneMode.NotEncoded;
pub const eAVEncDDHeadphoneMode_Encoded = eAVEncDDHeadphoneMode.Encoded;

const CLSID_CODECAPI_AVEncWMVKeyFrameDistance_Value = Guid.initString("5569055e-e268-4771-b83e-9555ea28aed3");
pub const CLSID_CODECAPI_AVEncWMVKeyFrameDistance = &CLSID_CODECAPI_AVEncWMVKeyFrameDistance_Value;

const CLSID_CODECAPI_AVEncWMVInterlacedEncoding_Value = Guid.initString("e3d00f8a-c6f5-4e14-a588-0ec87a726f9b");
pub const CLSID_CODECAPI_AVEncWMVInterlacedEncoding = &CLSID_CODECAPI_AVEncWMVInterlacedEncoding_Value;

const CLSID_CODECAPI_AVEncWMVDecoderComplexity_Value = Guid.initString("f32c0dab-f3cb-4217-b79f-8762768b5f67");
pub const CLSID_CODECAPI_AVEncWMVDecoderComplexity = &CLSID_CODECAPI_AVEncWMVDecoderComplexity_Value;

const CLSID_CODECAPI_AVEncWMVKeyFrameBufferLevelMarker_Value = Guid.initString("51ff1115-33ac-426c-a1b1-09321bdf96b4");
pub const CLSID_CODECAPI_AVEncWMVKeyFrameBufferLevelMarker = &CLSID_CODECAPI_AVEncWMVKeyFrameBufferLevelMarker_Value;

const CLSID_CODECAPI_AVEncWMVProduceDummyFrames_Value = Guid.initString("d669d001-183c-42e3-a3ca-2f4586d2396c");
pub const CLSID_CODECAPI_AVEncWMVProduceDummyFrames = &CLSID_CODECAPI_AVEncWMVProduceDummyFrames_Value;

const CLSID_CODECAPI_AVEncStatWMVCBAvg_Value = Guid.initString("6aa6229f-d602-4b9d-b68c-c1ad78884bef");
pub const CLSID_CODECAPI_AVEncStatWMVCBAvg = &CLSID_CODECAPI_AVEncStatWMVCBAvg_Value;

const CLSID_CODECAPI_AVEncStatWMVCBMax_Value = Guid.initString("e976bef8-00fe-44b4-b625-8f238bc03499");
pub const CLSID_CODECAPI_AVEncStatWMVCBMax = &CLSID_CODECAPI_AVEncStatWMVCBMax_Value;

const CLSID_CODECAPI_AVEncStatWMVDecoderComplexityProfile_Value = Guid.initString("89e69fc3-0f9b-436c-974a-df821227c90d");
pub const CLSID_CODECAPI_AVEncStatWMVDecoderComplexityProfile = &CLSID_CODECAPI_AVEncStatWMVDecoderComplexityProfile_Value;

const CLSID_CODECAPI_AVEncStatMPVSkippedEmptyFrames_Value = Guid.initString("32195fd3-590d-4812-a7ed-6d639a1f9711");
pub const CLSID_CODECAPI_AVEncStatMPVSkippedEmptyFrames = &CLSID_CODECAPI_AVEncStatMPVSkippedEmptyFrames_Value;

const CLSID_CODECAPI_AVEncMP12PktzSTDBuffer_Value = Guid.initString("0b751bd0-819e-478c-9435-75208926b377");
pub const CLSID_CODECAPI_AVEncMP12PktzSTDBuffer = &CLSID_CODECAPI_AVEncMP12PktzSTDBuffer_Value;

const CLSID_CODECAPI_AVEncMP12PktzStreamID_Value = Guid.initString("c834d038-f5e8-4408-9b60-88f36493fedf");
pub const CLSID_CODECAPI_AVEncMP12PktzStreamID = &CLSID_CODECAPI_AVEncMP12PktzStreamID_Value;

const CLSID_CODECAPI_AVEncMP12PktzInitialPTS_Value = Guid.initString("2a4f2065-9a63-4d20-ae22-0a1bc896a315");
pub const CLSID_CODECAPI_AVEncMP12PktzInitialPTS = &CLSID_CODECAPI_AVEncMP12PktzInitialPTS_Value;

const CLSID_CODECAPI_AVEncMP12PktzPacketSize_Value = Guid.initString("ab71347a-1332-4dde-a0e5-ccf7da8a0f22");
pub const CLSID_CODECAPI_AVEncMP12PktzPacketSize = &CLSID_CODECAPI_AVEncMP12PktzPacketSize_Value;

const CLSID_CODECAPI_AVEncMP12PktzCopyright_Value = Guid.initString("c8f4b0c1-094c-43c7-8e68-a595405a6ef8");
pub const CLSID_CODECAPI_AVEncMP12PktzCopyright = &CLSID_CODECAPI_AVEncMP12PktzCopyright_Value;

const CLSID_CODECAPI_AVEncMP12PktzOriginal_Value = Guid.initString("6b178416-31b9-4964-94cb-6bff866cdf83");
pub const CLSID_CODECAPI_AVEncMP12PktzOriginal = &CLSID_CODECAPI_AVEncMP12PktzOriginal_Value;

const CLSID_CODECAPI_AVEncMP12MuxPacketOverhead_Value = Guid.initString("e40bd720-3955-4453-acf9-b79132a38fa0");
pub const CLSID_CODECAPI_AVEncMP12MuxPacketOverhead = &CLSID_CODECAPI_AVEncMP12MuxPacketOverhead_Value;

const CLSID_CODECAPI_AVEncMP12MuxNumStreams_Value = Guid.initString("f7164a41-dced-4659-a8f2-fb693f2a4cd0");
pub const CLSID_CODECAPI_AVEncMP12MuxNumStreams = &CLSID_CODECAPI_AVEncMP12MuxNumStreams_Value;

const CLSID_CODECAPI_AVEncMP12MuxEarliestPTS_Value = Guid.initString("157232b6-f809-474e-9464-a7f93014a817");
pub const CLSID_CODECAPI_AVEncMP12MuxEarliestPTS = &CLSID_CODECAPI_AVEncMP12MuxEarliestPTS_Value;

const CLSID_CODECAPI_AVEncMP12MuxLargestPacketSize_Value = Guid.initString("35ceb711-f461-4b92-a4ef-17b6841ed254");
pub const CLSID_CODECAPI_AVEncMP12MuxLargestPacketSize = &CLSID_CODECAPI_AVEncMP12MuxLargestPacketSize_Value;

const CLSID_CODECAPI_AVEncMP12MuxInitialSCR_Value = Guid.initString("3433ad21-1b91-4a0b-b190-2b77063b63a4");
pub const CLSID_CODECAPI_AVEncMP12MuxInitialSCR = &CLSID_CODECAPI_AVEncMP12MuxInitialSCR_Value;

const CLSID_CODECAPI_AVEncMP12MuxMuxRate_Value = Guid.initString("ee047c72-4bdb-4a9d-8e21-41926c823da7");
pub const CLSID_CODECAPI_AVEncMP12MuxMuxRate = &CLSID_CODECAPI_AVEncMP12MuxMuxRate_Value;

const CLSID_CODECAPI_AVEncMP12MuxPackSize_Value = Guid.initString("f916053a-1ce8-4faf-aa0b-ba31c80034b8");
pub const CLSID_CODECAPI_AVEncMP12MuxPackSize = &CLSID_CODECAPI_AVEncMP12MuxPackSize_Value;

const CLSID_CODECAPI_AVEncMP12MuxSysSTDBufferBound_Value = Guid.initString("35746903-b545-43e7-bb35-c5e0a7d5093c");
pub const CLSID_CODECAPI_AVEncMP12MuxSysSTDBufferBound = &CLSID_CODECAPI_AVEncMP12MuxSysSTDBufferBound_Value;

const CLSID_CODECAPI_AVEncMP12MuxSysRateBound_Value = Guid.initString("05f0428a-ee30-489d-ae28-205c72446710");
pub const CLSID_CODECAPI_AVEncMP12MuxSysRateBound = &CLSID_CODECAPI_AVEncMP12MuxSysRateBound_Value;

const CLSID_CODECAPI_AVEncMP12MuxTargetPacketizer_Value = Guid.initString("d862212a-2015-45dd-9a32-1b3aa88205a0");
pub const CLSID_CODECAPI_AVEncMP12MuxTargetPacketizer = &CLSID_CODECAPI_AVEncMP12MuxTargetPacketizer_Value;

const CLSID_CODECAPI_AVEncMP12MuxSysFixed_Value = Guid.initString("cefb987e-894f-452e-8f89-a4ef8cec063a");
pub const CLSID_CODECAPI_AVEncMP12MuxSysFixed = &CLSID_CODECAPI_AVEncMP12MuxSysFixed_Value;

const CLSID_CODECAPI_AVEncMP12MuxSysCSPS_Value = Guid.initString("7952ff45-9c0d-4822-bc82-8ad772e02993");
pub const CLSID_CODECAPI_AVEncMP12MuxSysCSPS = &CLSID_CODECAPI_AVEncMP12MuxSysCSPS_Value;

const CLSID_CODECAPI_AVEncMP12MuxSysVideoLock_Value = Guid.initString("b8296408-2430-4d37-a2a1-95b3e435a91d");
pub const CLSID_CODECAPI_AVEncMP12MuxSysVideoLock = &CLSID_CODECAPI_AVEncMP12MuxSysVideoLock_Value;

const CLSID_CODECAPI_AVEncMP12MuxSysAudioLock_Value = Guid.initString("0fbb5752-1d43-47bf-bd79-f2293d8ce337");
pub const CLSID_CODECAPI_AVEncMP12MuxSysAudioLock = &CLSID_CODECAPI_AVEncMP12MuxSysAudioLock_Value;

const CLSID_CODECAPI_AVEncMP12MuxDVDNavPacks_Value = Guid.initString("c7607ced-8cf1-4a99-83a1-ee5461be3574");
pub const CLSID_CODECAPI_AVEncMP12MuxDVDNavPacks = &CLSID_CODECAPI_AVEncMP12MuxDVDNavPacks_Value;

const CLSID_CODECAPI_AVDecCommonInputFormat_Value = Guid.initString("e5005239-bd89-4be3-9c0f-5dde317988cc");
pub const CLSID_CODECAPI_AVDecCommonInputFormat = &CLSID_CODECAPI_AVDecCommonInputFormat_Value;

const CLSID_CODECAPI_AVDecCommonOutputFormat_Value = Guid.initString("3c790028-c0ce-4256-b1a2-1b0fc8b1dcdc");
pub const CLSID_CODECAPI_AVDecCommonOutputFormat = &CLSID_CODECAPI_AVDecCommonOutputFormat_Value;

const CLSID_CODECAPI_AVDecCommonMeanBitRate_Value = Guid.initString("59488217-007a-4f7a-8e41-5c48b1eac5c6");
pub const CLSID_CODECAPI_AVDecCommonMeanBitRate = &CLSID_CODECAPI_AVDecCommonMeanBitRate_Value;

const CLSID_CODECAPI_AVDecCommonMeanBitRateInterval_Value = Guid.initString("0ee437c6-38a7-4c5c-944c-68ab42116b85");
pub const CLSID_CODECAPI_AVDecCommonMeanBitRateInterval = &CLSID_CODECAPI_AVDecCommonMeanBitRateInterval_Value;

const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded_Value = Guid.initString("696e1d30-548f-4036-825f-7026c60011bd");
pub const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded = &CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded_Value;

const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Value = Guid.initString("696e1d31-548f-4036-825f-7026c60011bd");
pub const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM = &CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Value;

const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM_Value = Guid.initString("696e1d32-548f-4036-825f-7026c60011bd");
pub const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM = &CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM_Value;

const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream_Value = Guid.initString("696e1d33-548f-4036-825f-7026c60011bd");
pub const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream = &CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream_Value;

const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones_Value = Guid.initString("696e1d34-548f-4036-825f-7026c60011bd");
pub const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones = &CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones_Value;

const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto_Value = Guid.initString("696e1d35-548f-4036-825f-7026c60011bd");
pub const CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto = &CLSID_CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto_Value;

const CLSID_CODECAPI_AVDecVideoImageSize_Value = Guid.initString("5ee5747c-6801-4cab-aaf1-6248fa841ba4");
pub const CLSID_CODECAPI_AVDecVideoImageSize = &CLSID_CODECAPI_AVDecVideoImageSize_Value;

const CLSID_CODECAPI_AVDecVideoPixelAspectRatio_Value = Guid.initString("b0cf8245-f32d-41df-b02c-87bd304d12ab");
pub const CLSID_CODECAPI_AVDecVideoPixelAspectRatio = &CLSID_CODECAPI_AVDecVideoPixelAspectRatio_Value;

const CLSID_CODECAPI_AVDecVideoInputScanType_Value = Guid.initString("38477e1f-0ea7-42cd-8cd1-130ced57c580");
pub const CLSID_CODECAPI_AVDecVideoInputScanType = &CLSID_CODECAPI_AVDecVideoInputScanType_Value;

pub const eAVDecVideoInputScanType = enum(i32) {
    Unknown = 0,
    Progressive = 1,
    Interlaced_UpperFieldFirst = 2,
    Interlaced_LowerFieldFirst = 3,
};
pub const eAVDecVideoInputScan_Unknown = eAVDecVideoInputScanType.Unknown;
pub const eAVDecVideoInputScan_Progressive = eAVDecVideoInputScanType.Progressive;
pub const eAVDecVideoInputScan_Interlaced_UpperFieldFirst = eAVDecVideoInputScanType.Interlaced_UpperFieldFirst;
pub const eAVDecVideoInputScan_Interlaced_LowerFieldFirst = eAVDecVideoInputScanType.Interlaced_LowerFieldFirst;

const CLSID_CODECAPI_AVDecVideoSWPowerLevel_Value = Guid.initString("fb5d2347-4dd8-4509-aed0-db5fa9aa93f4");
pub const CLSID_CODECAPI_AVDecVideoSWPowerLevel = &CLSID_CODECAPI_AVDecVideoSWPowerLevel_Value;

pub const eAVDecVideoSWPowerLevel = enum(i32) {
    BatteryLife = 0,
    Balanced = 50,
    VideoQuality = 100,
};
pub const eAVDecVideoSWPowerLevel_BatteryLife = eAVDecVideoSWPowerLevel.BatteryLife;
pub const eAVDecVideoSWPowerLevel_Balanced = eAVDecVideoSWPowerLevel.Balanced;
pub const eAVDecVideoSWPowerLevel_VideoQuality = eAVDecVideoSWPowerLevel.VideoQuality;

const CLSID_CODECAPI_GUID_AVDecAudioInputWMA_Value = Guid.initString("c95e8dcf-4058-4204-8c42-cb24d91e4b9b");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputWMA = &CLSID_CODECAPI_GUID_AVDecAudioInputWMA_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputWMAPro_Value = Guid.initString("0128b7c7-da72-4fe3-bef8-5c52e3557704");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputWMAPro = &CLSID_CODECAPI_GUID_AVDecAudioInputWMAPro_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputDolby_Value = Guid.initString("8e4228a0-f000-4e0b-8f54-ab8d24ad61a2");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputDolby = &CLSID_CODECAPI_GUID_AVDecAudioInputDolby_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputDTS_Value = Guid.initString("600bc0ca-6a1f-4e91-b241-1bbeb1cb19e0");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputDTS = &CLSID_CODECAPI_GUID_AVDecAudioInputDTS_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputPCM_Value = Guid.initString("f2421da5-bbb4-4cd5-a996-933c6b5d1347");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputPCM = &CLSID_CODECAPI_GUID_AVDecAudioInputPCM_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputMPEG_Value = Guid.initString("91106f36-02c5-4f75-9719-3b7abf75e1f6");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputMPEG = &CLSID_CODECAPI_GUID_AVDecAudioInputMPEG_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputAAC_Value = Guid.initString("97df7828-b94a-47e2-a4bc-51194db22a4d");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputAAC = &CLSID_CODECAPI_GUID_AVDecAudioInputAAC_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputHEAAC_Value = Guid.initString("16efb4aa-330e-4f5c-98a8-cf6ac55cbe60");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputHEAAC = &CLSID_CODECAPI_GUID_AVDecAudioInputHEAAC_Value;

const CLSID_CODECAPI_GUID_AVDecAudioInputDolbyDigitalPlus_Value = Guid.initString("0803e185-8f5d-47f5-9908-19a5bbc9fe34");
pub const CLSID_CODECAPI_GUID_AVDecAudioInputDolbyDigitalPlus = &CLSID_CODECAPI_GUID_AVDecAudioInputDolbyDigitalPlus_Value;

const CLSID_CODECAPI_AVDecAACDownmixMode_Value = Guid.initString("01274475-f6bb-4017-b084-81a763c942d4");
pub const CLSID_CODECAPI_AVDecAACDownmixMode = &CLSID_CODECAPI_AVDecAACDownmixMode_Value;

pub const eAVDecAACDownmixMode = enum(i32) {
    ISODownmix = 0,
    ARIBDownmix = 1,
};
pub const eAVDecAACUseISODownmix = eAVDecAACDownmixMode.ISODownmix;
pub const eAVDecAACUseARIBDownmix = eAVDecAACDownmixMode.ARIBDownmix;

const CLSID_CODECAPI_AVDecHEAACDynamicRangeControl_Value = Guid.initString("287c8abe-69a4-4d39-8080-d3d9712178a0");
pub const CLSID_CODECAPI_AVDecHEAACDynamicRangeControl = &CLSID_CODECAPI_AVDecHEAACDynamicRangeControl_Value;

pub const eAVDecHEAACDynamicRangeControl = enum(i32) {
    FF = 0,
    N = 1,
};
pub const eAVDecHEAACDynamicRangeControl_OFF = eAVDecHEAACDynamicRangeControl.FF;
pub const eAVDecHEAACDynamicRangeControl_ON = eAVDecHEAACDynamicRangeControl.N;

const CLSID_CODECAPI_AVDecAudioDualMono_Value = Guid.initString("4a52cda8-30f8-4216-be0f-ba0b2025921d");
pub const CLSID_CODECAPI_AVDecAudioDualMono = &CLSID_CODECAPI_AVDecAudioDualMono_Value;

pub const eAVDecAudioDualMono = enum(i32) {
    IsNotDualMono = 0,
    IsDualMono = 1,
    UnSpecified = 2,
};
pub const eAVDecAudioDualMono_IsNotDualMono = eAVDecAudioDualMono.IsNotDualMono;
pub const eAVDecAudioDualMono_IsDualMono = eAVDecAudioDualMono.IsDualMono;
pub const eAVDecAudioDualMono_UnSpecified = eAVDecAudioDualMono.UnSpecified;

const CLSID_CODECAPI_AVDecAudioDualMonoReproMode_Value = Guid.initString("a5106186-cc94-4bc9-8cd9-aa2f61f6807e");
pub const CLSID_CODECAPI_AVDecAudioDualMonoReproMode = &CLSID_CODECAPI_AVDecAudioDualMonoReproMode_Value;

pub const eAVDecAudioDualMonoReproMode = enum(i32) {
    STEREO = 0,
    LEFT_MONO = 1,
    RIGHT_MONO = 2,
    MIX_MONO = 3,
};
pub const eAVDecAudioDualMonoReproMode_STEREO = eAVDecAudioDualMonoReproMode.STEREO;
pub const eAVDecAudioDualMonoReproMode_LEFT_MONO = eAVDecAudioDualMonoReproMode.LEFT_MONO;
pub const eAVDecAudioDualMonoReproMode_RIGHT_MONO = eAVDecAudioDualMonoReproMode.RIGHT_MONO;
pub const eAVDecAudioDualMonoReproMode_MIX_MONO = eAVDecAudioDualMonoReproMode.MIX_MONO;

const CLSID_CODECAPI_AVAudioChannelCount_Value = Guid.initString("1d3583c4-1583-474e-b71a-5ee463c198e4");
pub const CLSID_CODECAPI_AVAudioChannelCount = &CLSID_CODECAPI_AVAudioChannelCount_Value;

const CLSID_CODECAPI_AVAudioChannelConfig_Value = Guid.initString("17f89cb3-c38d-4368-9ede-63b94d177f9f");
pub const CLSID_CODECAPI_AVAudioChannelConfig = &CLSID_CODECAPI_AVAudioChannelConfig_Value;

pub const eAVAudioChannelConfig = enum(i32) {
    FRONT_LEFT = 1,
    FRONT_RIGHT = 2,
    FRONT_CENTER = 4,
    LOW_FREQUENCY = 8,
    BACK_LEFT = 16,
    BACK_RIGHT = 32,
    FRONT_LEFT_OF_CENTER = 64,
    FRONT_RIGHT_OF_CENTER = 128,
    BACK_CENTER = 256,
    SIDE_LEFT = 512,
    SIDE_RIGHT = 1024,
    TOP_CENTER = 2048,
    TOP_FRONT_LEFT = 4096,
    TOP_FRONT_CENTER = 8192,
    TOP_FRONT_RIGHT = 16384,
    TOP_BACK_LEFT = 32768,
    TOP_BACK_CENTER = 65536,
    TOP_BACK_RIGHT = 131072,
};
pub const eAVAudioChannelConfig_FRONT_LEFT = eAVAudioChannelConfig.FRONT_LEFT;
pub const eAVAudioChannelConfig_FRONT_RIGHT = eAVAudioChannelConfig.FRONT_RIGHT;
pub const eAVAudioChannelConfig_FRONT_CENTER = eAVAudioChannelConfig.FRONT_CENTER;
pub const eAVAudioChannelConfig_LOW_FREQUENCY = eAVAudioChannelConfig.LOW_FREQUENCY;
pub const eAVAudioChannelConfig_BACK_LEFT = eAVAudioChannelConfig.BACK_LEFT;
pub const eAVAudioChannelConfig_BACK_RIGHT = eAVAudioChannelConfig.BACK_RIGHT;
pub const eAVAudioChannelConfig_FRONT_LEFT_OF_CENTER = eAVAudioChannelConfig.FRONT_LEFT_OF_CENTER;
pub const eAVAudioChannelConfig_FRONT_RIGHT_OF_CENTER = eAVAudioChannelConfig.FRONT_RIGHT_OF_CENTER;
pub const eAVAudioChannelConfig_BACK_CENTER = eAVAudioChannelConfig.BACK_CENTER;
pub const eAVAudioChannelConfig_SIDE_LEFT = eAVAudioChannelConfig.SIDE_LEFT;
pub const eAVAudioChannelConfig_SIDE_RIGHT = eAVAudioChannelConfig.SIDE_RIGHT;
pub const eAVAudioChannelConfig_TOP_CENTER = eAVAudioChannelConfig.TOP_CENTER;
pub const eAVAudioChannelConfig_TOP_FRONT_LEFT = eAVAudioChannelConfig.TOP_FRONT_LEFT;
pub const eAVAudioChannelConfig_TOP_FRONT_CENTER = eAVAudioChannelConfig.TOP_FRONT_CENTER;
pub const eAVAudioChannelConfig_TOP_FRONT_RIGHT = eAVAudioChannelConfig.TOP_FRONT_RIGHT;
pub const eAVAudioChannelConfig_TOP_BACK_LEFT = eAVAudioChannelConfig.TOP_BACK_LEFT;
pub const eAVAudioChannelConfig_TOP_BACK_CENTER = eAVAudioChannelConfig.TOP_BACK_CENTER;
pub const eAVAudioChannelConfig_TOP_BACK_RIGHT = eAVAudioChannelConfig.TOP_BACK_RIGHT;

const CLSID_CODECAPI_AVAudioSampleRate_Value = Guid.initString("971d2723-1acb-42e7-855c-520a4b70a5f2");
pub const CLSID_CODECAPI_AVAudioSampleRate = &CLSID_CODECAPI_AVAudioSampleRate_Value;

const CLSID_CODECAPI_AVDDSurroundMode_Value = Guid.initString("99f2f386-98d1-4452-a163-abc78a6eb770");
pub const CLSID_CODECAPI_AVDDSurroundMode = &CLSID_CODECAPI_AVDDSurroundMode_Value;

pub const eAVDDSurroundMode = enum(i32) {
    NotIndicated = 0,
    No = 1,
    Yes = 2,
};
pub const eAVDDSurroundMode_NotIndicated = eAVDDSurroundMode.NotIndicated;
pub const eAVDDSurroundMode_No = eAVDDSurroundMode.No;
pub const eAVDDSurroundMode_Yes = eAVDDSurroundMode.Yes;

const CLSID_CODECAPI_AVDecDDOperationalMode_Value = Guid.initString("d6d6c6d1-064e-4fdd-a40e-3ecbfcb7ebd0");
pub const CLSID_CODECAPI_AVDecDDOperationalMode = &CLSID_CODECAPI_AVDecDDOperationalMode_Value;

pub const eAVDecDDOperationalMode = enum(i32) {
    NONE = 0,
    LINE = 1,
    RF = 2,
    CUSTOM0 = 3,
    CUSTOM1 = 4,
    PORTABLE8 = 5,
    PORTABLE11 = 6,
    PORTABLE14 = 7,
};
pub const eAVDecDDOperationalMode_NONE = eAVDecDDOperationalMode.NONE;
pub const eAVDecDDOperationalMode_LINE = eAVDecDDOperationalMode.LINE;
pub const eAVDecDDOperationalMode_RF = eAVDecDDOperationalMode.RF;
pub const eAVDecDDOperationalMode_CUSTOM0 = eAVDecDDOperationalMode.CUSTOM0;
pub const eAVDecDDOperationalMode_CUSTOM1 = eAVDecDDOperationalMode.CUSTOM1;
pub const eAVDecDDOperationalMode_PORTABLE8 = eAVDecDDOperationalMode.PORTABLE8;
pub const eAVDecDDOperationalMode_PORTABLE11 = eAVDecDDOperationalMode.PORTABLE11;
pub const eAVDecDDOperationalMode_PORTABLE14 = eAVDecDDOperationalMode.PORTABLE14;

const CLSID_CODECAPI_AVDecDDMatrixDecodingMode_Value = Guid.initString("ddc811a5-04ed-4bf3-a0ca-d00449f9355f");
pub const CLSID_CODECAPI_AVDecDDMatrixDecodingMode = &CLSID_CODECAPI_AVDecDDMatrixDecodingMode_Value;

pub const eAVDecDDMatrixDecodingMode = enum(i32) {
    OFF = 0,
    ON = 1,
    AUTO = 2,
};
pub const eAVDecDDMatrixDecodingMode_OFF = eAVDecDDMatrixDecodingMode.OFF;
pub const eAVDecDDMatrixDecodingMode_ON = eAVDecDDMatrixDecodingMode.ON;
pub const eAVDecDDMatrixDecodingMode_AUTO = eAVDecDDMatrixDecodingMode.AUTO;

const CLSID_CODECAPI_AVDecDDDynamicRangeScaleHigh_Value = Guid.initString("50196c21-1f33-4af5-b296-11426d6c8789");
pub const CLSID_CODECAPI_AVDecDDDynamicRangeScaleHigh = &CLSID_CODECAPI_AVDecDDDynamicRangeScaleHigh_Value;

const CLSID_CODECAPI_AVDecDDDynamicRangeScaleLow_Value = Guid.initString("044e62e4-11a5-42d5-a3b2-3bb2c7c2d7cf");
pub const CLSID_CODECAPI_AVDecDDDynamicRangeScaleLow = &CLSID_CODECAPI_AVDecDDDynamicRangeScaleLow_Value;

const CLSID_CODECAPI_AVDecDDStereoDownMixMode_Value = Guid.initString("6ce4122c-3ee9-4182-b4ae-c10fc088649d");
pub const CLSID_CODECAPI_AVDecDDStereoDownMixMode = &CLSID_CODECAPI_AVDecDDStereoDownMixMode_Value;

pub const eAVDecDDStereoDownMixMode = enum(i32) {
    Auto = 0,
    LtRt = 1,
    LoRo = 2,
};
pub const eAVDecDDStereoDownMixMode_Auto = eAVDecDDStereoDownMixMode.Auto;
pub const eAVDecDDStereoDownMixMode_LtRt = eAVDecDDStereoDownMixMode.LtRt;
pub const eAVDecDDStereoDownMixMode_LoRo = eAVDecDDStereoDownMixMode.LoRo;

const CLSID_CODECAPI_AVDSPLoudnessEqualization_Value = Guid.initString("8afd1a15-1812-4cbf-9319-433a5b2a3b27");
pub const CLSID_CODECAPI_AVDSPLoudnessEqualization = &CLSID_CODECAPI_AVDSPLoudnessEqualization_Value;

pub const eAVDSPLoudnessEqualization = enum(i32) {
    OFF = 0,
    ON = 1,
    AUTO = 2,
};
pub const eAVDSPLoudnessEqualization_OFF = eAVDSPLoudnessEqualization.OFF;
pub const eAVDSPLoudnessEqualization_ON = eAVDSPLoudnessEqualization.ON;
pub const eAVDSPLoudnessEqualization_AUTO = eAVDSPLoudnessEqualization.AUTO;

const CLSID_CODECAPI_AVDSPSpeakerFill_Value = Guid.initString("5612bca1-56da-4582-8da1-ca8090f92768");
pub const CLSID_CODECAPI_AVDSPSpeakerFill = &CLSID_CODECAPI_AVDSPSpeakerFill_Value;

pub const eAVDSPSpeakerFill = enum(i32) {
    OFF = 0,
    ON = 1,
    AUTO = 2,
};
pub const eAVDSPSpeakerFill_OFF = eAVDSPSpeakerFill.OFF;
pub const eAVDSPSpeakerFill_ON = eAVDSPSpeakerFill.ON;
pub const eAVDSPSpeakerFill_AUTO = eAVDSPSpeakerFill.AUTO;

const CLSID_CODECAPI_AVPriorityControl_Value = Guid.initString("54ba3dc8-bdde-4329-b187-2018bc5c2ba1");
pub const CLSID_CODECAPI_AVPriorityControl = &CLSID_CODECAPI_AVPriorityControl_Value;

const CLSID_CODECAPI_AVRealtimeControl_Value = Guid.initString("6f440632-c4ad-4bf7-9e52-456942b454b0");
pub const CLSID_CODECAPI_AVRealtimeControl = &CLSID_CODECAPI_AVRealtimeControl_Value;

const CLSID_CODECAPI_AVEncNoInputCopy_Value = Guid.initString("d2b46a2a-e8ee-4ec5-869e-449b6c62c81a");
pub const CLSID_CODECAPI_AVEncNoInputCopy = &CLSID_CODECAPI_AVEncNoInputCopy_Value;

pub const eAVEncChromaEncodeMode = enum(i32) {
    @"20" = 0,
    @"44" = 1,
    @"44_v2" = 2,
};
pub const eAVEncChromaEncodeMode_420 = eAVEncChromaEncodeMode.@"20";
pub const eAVEncChromaEncodeMode_444 = eAVEncChromaEncodeMode.@"44";
pub const eAVEncChromaEncodeMode_444_v2 = eAVEncChromaEncodeMode.@"44_v2";

const CLSID_CODECAPI_AVEncChromaEncodeMode_Value = Guid.initString("8a47ab5a-4798-4c93-b5a5-554f9a3b9f50");
pub const CLSID_CODECAPI_AVEncChromaEncodeMode = &CLSID_CODECAPI_AVEncChromaEncodeMode_Value;

const CLSID_CODECAPI_AVEncProgressiveUpdateTime_Value = Guid.initString("649faf66-afc6-4828-8fdc-0771cd9ab17d");
pub const CLSID_CODECAPI_AVEncProgressiveUpdateTime = &CLSID_CODECAPI_AVEncProgressiveUpdateTime_Value;

const CLSID_CODECAPI_AVEncChromaUpdateTime_Value = Guid.initString("4b4fd998-4274-40bb-8ee4-07553e7e2d3a");
pub const CLSID_CODECAPI_AVEncChromaUpdateTime = &CLSID_CODECAPI_AVEncChromaUpdateTime_Value;

pub const DXVAHD_FRAME_FORMAT = enum(i32) {
    PROGRESSIVE = 0,
    INTERLACED_TOP_FIELD_FIRST = 1,
    INTERLACED_BOTTOM_FIELD_FIRST = 2,
};
pub const DXVAHD_FRAME_FORMAT_PROGRESSIVE = DXVAHD_FRAME_FORMAT.PROGRESSIVE;
pub const DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST = DXVAHD_FRAME_FORMAT.INTERLACED_TOP_FIELD_FIRST;
pub const DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST = DXVAHD_FRAME_FORMAT.INTERLACED_BOTTOM_FIELD_FIRST;

pub const DXVAHD_DEVICE_USAGE = enum(i32) {
    PLAYBACK_NORMAL = 0,
    OPTIMAL_SPEED = 1,
    OPTIMAL_QUALITY = 2,
};
pub const DXVAHD_DEVICE_USAGE_PLAYBACK_NORMAL = DXVAHD_DEVICE_USAGE.PLAYBACK_NORMAL;
pub const DXVAHD_DEVICE_USAGE_OPTIMAL_SPEED = DXVAHD_DEVICE_USAGE.OPTIMAL_SPEED;
pub const DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY = DXVAHD_DEVICE_USAGE.OPTIMAL_QUALITY;

pub const DXVAHD_SURFACE_TYPE = enum(i32) {
    INPUT = 0,
    INPUT_PRIVATE = 1,
    OUTPUT = 2,
};
pub const DXVAHD_SURFACE_TYPE_VIDEO_INPUT = DXVAHD_SURFACE_TYPE.INPUT;
pub const DXVAHD_SURFACE_TYPE_VIDEO_INPUT_PRIVATE = DXVAHD_SURFACE_TYPE.INPUT_PRIVATE;
pub const DXVAHD_SURFACE_TYPE_VIDEO_OUTPUT = DXVAHD_SURFACE_TYPE.OUTPUT;

pub const DXVAHD_DEVICE_TYPE = enum(i32) {
    HARDWARE = 0,
    SOFTWARE = 1,
    REFERENCE = 2,
    OTHER = 3,
};
pub const DXVAHD_DEVICE_TYPE_HARDWARE = DXVAHD_DEVICE_TYPE.HARDWARE;
pub const DXVAHD_DEVICE_TYPE_SOFTWARE = DXVAHD_DEVICE_TYPE.SOFTWARE;
pub const DXVAHD_DEVICE_TYPE_REFERENCE = DXVAHD_DEVICE_TYPE.REFERENCE;
pub const DXVAHD_DEVICE_TYPE_OTHER = DXVAHD_DEVICE_TYPE.OTHER;

pub const DXVAHD_DEVICE_CAPS = enum(i32) {
    LINEAR_SPACE = 1,
    xvYCC = 2,
    RGB_RANGE_CONVERSION = 4,
    YCbCr_MATRIX_CONVERSION = 8,
};
pub const DXVAHD_DEVICE_CAPS_LINEAR_SPACE = DXVAHD_DEVICE_CAPS.LINEAR_SPACE;
pub const DXVAHD_DEVICE_CAPS_xvYCC = DXVAHD_DEVICE_CAPS.xvYCC;
pub const DXVAHD_DEVICE_CAPS_RGB_RANGE_CONVERSION = DXVAHD_DEVICE_CAPS.RGB_RANGE_CONVERSION;
pub const DXVAHD_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION = DXVAHD_DEVICE_CAPS.YCbCr_MATRIX_CONVERSION;

pub const DXVAHD_FEATURE_CAPS = enum(i32) {
    ALPHA_FILL = 1,
    CONSTRICTION = 2,
    LUMA_KEY = 4,
    ALPHA_PALETTE = 8,
};
pub const DXVAHD_FEATURE_CAPS_ALPHA_FILL = DXVAHD_FEATURE_CAPS.ALPHA_FILL;
pub const DXVAHD_FEATURE_CAPS_CONSTRICTION = DXVAHD_FEATURE_CAPS.CONSTRICTION;
pub const DXVAHD_FEATURE_CAPS_LUMA_KEY = DXVAHD_FEATURE_CAPS.LUMA_KEY;
pub const DXVAHD_FEATURE_CAPS_ALPHA_PALETTE = DXVAHD_FEATURE_CAPS.ALPHA_PALETTE;

pub const DXVAHD_FILTER_CAPS = enum(i32) {
    BRIGHTNESS = 1,
    CONTRAST = 2,
    HUE = 4,
    SATURATION = 8,
    NOISE_REDUCTION = 16,
    EDGE_ENHANCEMENT = 32,
    ANAMORPHIC_SCALING = 64,
};
pub const DXVAHD_FILTER_CAPS_BRIGHTNESS = DXVAHD_FILTER_CAPS.BRIGHTNESS;
pub const DXVAHD_FILTER_CAPS_CONTRAST = DXVAHD_FILTER_CAPS.CONTRAST;
pub const DXVAHD_FILTER_CAPS_HUE = DXVAHD_FILTER_CAPS.HUE;
pub const DXVAHD_FILTER_CAPS_SATURATION = DXVAHD_FILTER_CAPS.SATURATION;
pub const DXVAHD_FILTER_CAPS_NOISE_REDUCTION = DXVAHD_FILTER_CAPS.NOISE_REDUCTION;
pub const DXVAHD_FILTER_CAPS_EDGE_ENHANCEMENT = DXVAHD_FILTER_CAPS.EDGE_ENHANCEMENT;
pub const DXVAHD_FILTER_CAPS_ANAMORPHIC_SCALING = DXVAHD_FILTER_CAPS.ANAMORPHIC_SCALING;

pub const DXVAHD_INPUT_FORMAT_CAPS = enum(i32) {
    RGB_INTERLACED = 1,
    RGB_PROCAMP = 2,
    RGB_LUMA_KEY = 4,
    PALETTE_INTERLACED = 8,
};
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_INTERLACED = DXVAHD_INPUT_FORMAT_CAPS.RGB_INTERLACED;
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_PROCAMP = DXVAHD_INPUT_FORMAT_CAPS.RGB_PROCAMP;
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_LUMA_KEY = DXVAHD_INPUT_FORMAT_CAPS.RGB_LUMA_KEY;
pub const DXVAHD_INPUT_FORMAT_CAPS_PALETTE_INTERLACED = DXVAHD_INPUT_FORMAT_CAPS.PALETTE_INTERLACED;

pub const DXVAHD_PROCESSOR_CAPS = enum(i32) {
    DEINTERLACE_BLEND = 1,
    DEINTERLACE_BOB = 2,
    DEINTERLACE_ADAPTIVE = 4,
    DEINTERLACE_MOTION_COMPENSATION = 8,
    INVERSE_TELECINE = 16,
    FRAME_RATE_CONVERSION = 32,
};
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BLEND = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_BLEND;
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BOB = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_BOB;
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_ADAPTIVE;
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_MOTION_COMPENSATION;
pub const DXVAHD_PROCESSOR_CAPS_INVERSE_TELECINE = DXVAHD_PROCESSOR_CAPS.INVERSE_TELECINE;
pub const DXVAHD_PROCESSOR_CAPS_FRAME_RATE_CONVERSION = DXVAHD_PROCESSOR_CAPS.FRAME_RATE_CONVERSION;

pub const DXVAHD_ITELECINE_CAPS = enum(i32) {
    @"32" = 1,
    @"22" = 2,
    @"2224" = 4,
    @"2332" = 8,
    @"32322" = 16,
    @"55" = 32,
    @"64" = 64,
    @"87" = 128,
    @"222222222223" = 256,
    OTHER = -2147483648,
};
pub const DXVAHD_ITELECINE_CAPS_32 = DXVAHD_ITELECINE_CAPS.@"32";
pub const DXVAHD_ITELECINE_CAPS_22 = DXVAHD_ITELECINE_CAPS.@"22";
pub const DXVAHD_ITELECINE_CAPS_2224 = DXVAHD_ITELECINE_CAPS.@"2224";
pub const DXVAHD_ITELECINE_CAPS_2332 = DXVAHD_ITELECINE_CAPS.@"2332";
pub const DXVAHD_ITELECINE_CAPS_32322 = DXVAHD_ITELECINE_CAPS.@"32322";
pub const DXVAHD_ITELECINE_CAPS_55 = DXVAHD_ITELECINE_CAPS.@"55";
pub const DXVAHD_ITELECINE_CAPS_64 = DXVAHD_ITELECINE_CAPS.@"64";
pub const DXVAHD_ITELECINE_CAPS_87 = DXVAHD_ITELECINE_CAPS.@"87";
pub const DXVAHD_ITELECINE_CAPS_222222222223 = DXVAHD_ITELECINE_CAPS.@"222222222223";
pub const DXVAHD_ITELECINE_CAPS_OTHER = DXVAHD_ITELECINE_CAPS.OTHER;

pub const DXVAHD_FILTER = enum(i32) {
    BRIGHTNESS = 0,
    CONTRAST = 1,
    HUE = 2,
    SATURATION = 3,
    NOISE_REDUCTION = 4,
    EDGE_ENHANCEMENT = 5,
    ANAMORPHIC_SCALING = 6,
};
pub const DXVAHD_FILTER_BRIGHTNESS = DXVAHD_FILTER.BRIGHTNESS;
pub const DXVAHD_FILTER_CONTRAST = DXVAHD_FILTER.CONTRAST;
pub const DXVAHD_FILTER_HUE = DXVAHD_FILTER.HUE;
pub const DXVAHD_FILTER_SATURATION = DXVAHD_FILTER.SATURATION;
pub const DXVAHD_FILTER_NOISE_REDUCTION = DXVAHD_FILTER.NOISE_REDUCTION;
pub const DXVAHD_FILTER_EDGE_ENHANCEMENT = DXVAHD_FILTER.EDGE_ENHANCEMENT;
pub const DXVAHD_FILTER_ANAMORPHIC_SCALING = DXVAHD_FILTER.ANAMORPHIC_SCALING;

pub const DXVAHD_BLT_STATE = enum(i32) {
    TARGET_RECT = 0,
    BACKGROUND_COLOR = 1,
    OUTPUT_COLOR_SPACE = 2,
    ALPHA_FILL = 3,
    CONSTRICTION = 4,
    PRIVATE = 1000,
};
pub const DXVAHD_BLT_STATE_TARGET_RECT = DXVAHD_BLT_STATE.TARGET_RECT;
pub const DXVAHD_BLT_STATE_BACKGROUND_COLOR = DXVAHD_BLT_STATE.BACKGROUND_COLOR;
pub const DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE = DXVAHD_BLT_STATE.OUTPUT_COLOR_SPACE;
pub const DXVAHD_BLT_STATE_ALPHA_FILL = DXVAHD_BLT_STATE.ALPHA_FILL;
pub const DXVAHD_BLT_STATE_CONSTRICTION = DXVAHD_BLT_STATE.CONSTRICTION;
pub const DXVAHD_BLT_STATE_PRIVATE = DXVAHD_BLT_STATE.PRIVATE;

pub const DXVAHD_ALPHA_FILL_MODE = enum(i32) {
    OPAQUE = 0,
    BACKGROUND = 1,
    DESTINATION = 2,
    SOURCE_STREAM = 3,
};
pub const DXVAHD_ALPHA_FILL_MODE_OPAQUE = DXVAHD_ALPHA_FILL_MODE.OPAQUE;
pub const DXVAHD_ALPHA_FILL_MODE_BACKGROUND = DXVAHD_ALPHA_FILL_MODE.BACKGROUND;
pub const DXVAHD_ALPHA_FILL_MODE_DESTINATION = DXVAHD_ALPHA_FILL_MODE.DESTINATION;
pub const DXVAHD_ALPHA_FILL_MODE_SOURCE_STREAM = DXVAHD_ALPHA_FILL_MODE.SOURCE_STREAM;

pub const DXVAHD_STREAM_STATE = enum(i32) {
    D3DFORMAT = 0,
    FRAME_FORMAT = 1,
    INPUT_COLOR_SPACE = 2,
    OUTPUT_RATE = 3,
    SOURCE_RECT = 4,
    DESTINATION_RECT = 5,
    ALPHA = 6,
    PALETTE = 7,
    LUMA_KEY = 8,
    ASPECT_RATIO = 9,
    FILTER_BRIGHTNESS = 100,
    FILTER_CONTRAST = 101,
    FILTER_HUE = 102,
    FILTER_SATURATION = 103,
    FILTER_NOISE_REDUCTION = 104,
    FILTER_EDGE_ENHANCEMENT = 105,
    FILTER_ANAMORPHIC_SCALING = 106,
    PRIVATE = 1000,
};
pub const DXVAHD_STREAM_STATE_D3DFORMAT = DXVAHD_STREAM_STATE.D3DFORMAT;
pub const DXVAHD_STREAM_STATE_FRAME_FORMAT = DXVAHD_STREAM_STATE.FRAME_FORMAT;
pub const DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE = DXVAHD_STREAM_STATE.INPUT_COLOR_SPACE;
pub const DXVAHD_STREAM_STATE_OUTPUT_RATE = DXVAHD_STREAM_STATE.OUTPUT_RATE;
pub const DXVAHD_STREAM_STATE_SOURCE_RECT = DXVAHD_STREAM_STATE.SOURCE_RECT;
pub const DXVAHD_STREAM_STATE_DESTINATION_RECT = DXVAHD_STREAM_STATE.DESTINATION_RECT;
pub const DXVAHD_STREAM_STATE_ALPHA = DXVAHD_STREAM_STATE.ALPHA;
pub const DXVAHD_STREAM_STATE_PALETTE = DXVAHD_STREAM_STATE.PALETTE;
pub const DXVAHD_STREAM_STATE_LUMA_KEY = DXVAHD_STREAM_STATE.LUMA_KEY;
pub const DXVAHD_STREAM_STATE_ASPECT_RATIO = DXVAHD_STREAM_STATE.ASPECT_RATIO;
pub const DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS = DXVAHD_STREAM_STATE.FILTER_BRIGHTNESS;
pub const DXVAHD_STREAM_STATE_FILTER_CONTRAST = DXVAHD_STREAM_STATE.FILTER_CONTRAST;
pub const DXVAHD_STREAM_STATE_FILTER_HUE = DXVAHD_STREAM_STATE.FILTER_HUE;
pub const DXVAHD_STREAM_STATE_FILTER_SATURATION = DXVAHD_STREAM_STATE.FILTER_SATURATION;
pub const DXVAHD_STREAM_STATE_FILTER_NOISE_REDUCTION = DXVAHD_STREAM_STATE.FILTER_NOISE_REDUCTION;
pub const DXVAHD_STREAM_STATE_FILTER_EDGE_ENHANCEMENT = DXVAHD_STREAM_STATE.FILTER_EDGE_ENHANCEMENT;
pub const DXVAHD_STREAM_STATE_FILTER_ANAMORPHIC_SCALING = DXVAHD_STREAM_STATE.FILTER_ANAMORPHIC_SCALING;
pub const DXVAHD_STREAM_STATE_PRIVATE = DXVAHD_STREAM_STATE.PRIVATE;

pub const DXVAHD_OUTPUT_RATE = enum(i32) {
    NORMAL = 0,
    HALF = 1,
    CUSTOM = 2,
};
pub const DXVAHD_OUTPUT_RATE_NORMAL = DXVAHD_OUTPUT_RATE.NORMAL;
pub const DXVAHD_OUTPUT_RATE_HALF = DXVAHD_OUTPUT_RATE.HALF;
pub const DXVAHD_OUTPUT_RATE_CUSTOM = DXVAHD_OUTPUT_RATE.CUSTOM;

pub const DXVAHD_RATIONAL = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXVAHD_COLOR_RGBA = extern struct {
    R: f32,
    G: f32,
    B: f32,
    A: f32,
};

pub const DXVAHD_COLOR_YCbCrA = extern struct {
    Y: f32,
    Cb: f32,
    Cr: f32,
    A: f32,
};

pub const DXVAHD_COLOR = extern union {
    RGB: DXVAHD_COLOR_RGBA,
    YCbCr: DXVAHD_COLOR_YCbCrA,
};

pub const DXVAHD_CONTENT_DESC = extern struct {
    InputFrameFormat: DXVAHD_FRAME_FORMAT,
    InputFrameRate: DXVAHD_RATIONAL,
    InputWidth: u32,
    InputHeight: u32,
    OutputFrameRate: DXVAHD_RATIONAL,
    OutputWidth: u32,
    OutputHeight: u32,
};

pub const DXVAHD_VPDEVCAPS = extern struct {
    DeviceType: DXVAHD_DEVICE_TYPE,
    DeviceCaps: u32,
    FeatureCaps: u32,
    FilterCaps: u32,
    InputFormatCaps: u32,
    InputPool: D3DPOOL,
    OutputFormatCount: u32,
    InputFormatCount: u32,
    VideoProcessorCount: u32,
    MaxInputStreams: u32,
    MaxStreamStates: u32,
};

pub const DXVAHD_VPCAPS = extern struct {
    VPGuid: Guid,
    PastFrames: u32,
    FutureFrames: u32,
    ProcessorCaps: u32,
    ITelecineCaps: u32,
    CustomRateCount: u32,
};

pub const DXVAHD_CUSTOM_RATE_DATA = extern struct {
    CustomRate: DXVAHD_RATIONAL,
    OutputFrames: u32,
    InputInterlaced: BOOL,
    InputFramesOrFields: u32,
};

pub const DXVAHD_FILTER_RANGE_DATA = extern struct {
    Minimum: i32,
    Maximum: i32,
    Default: i32,
    Multiplier: f32,
};

pub const DXVAHD_BLT_STATE_TARGET_RECT_DATA = extern struct {
    Enable: BOOL,
    TargetRect: RECT,
};

pub const DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA = extern struct {
    YCbCr: BOOL,
    BackgroundColor: DXVAHD_COLOR,
};

pub const DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u32,
        },
        Value: u32,
    },
};

pub const DXVAHD_BLT_STATE_ALPHA_FILL_DATA = extern struct {
    Mode: DXVAHD_ALPHA_FILL_MODE,
    StreamNumber: u32,
};

pub const DXVAHD_BLT_STATE_CONSTRICTION_DATA = extern struct {
    Enable: BOOL,
    Size: SIZE,
};

pub const DXVAHD_BLT_STATE_PRIVATE_DATA = extern struct {
    Guid: Guid,
    DataSize: u32,
    pData: ?*anyopaque,
};

pub const DXVAHD_STREAM_STATE_D3DFORMAT_DATA = extern struct {
    Format: D3DFORMAT,
};

pub const DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA = extern struct {
    FrameFormat: DXVAHD_FRAME_FORMAT,
};

pub const DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u32,
        },
        Value: u32,
    },
};

pub const DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA = extern struct {
    RepeatFrame: BOOL,
    OutputRate: DXVAHD_OUTPUT_RATE,
    CustomRate: DXVAHD_RATIONAL,
};

pub const DXVAHD_STREAM_STATE_SOURCE_RECT_DATA = extern struct {
    Enable: BOOL,
    SourceRect: RECT,
};

pub const DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA = extern struct {
    Enable: BOOL,
    DestinationRect: RECT,
};

pub const DXVAHD_STREAM_STATE_ALPHA_DATA = extern struct {
    Enable: BOOL,
    Alpha: f32,
};

pub const DXVAHD_STREAM_STATE_PALETTE_DATA = extern struct {
    Count: u32,
    pEntries: ?*u32,
};

pub const DXVAHD_STREAM_STATE_LUMA_KEY_DATA = extern struct {
    Enable: BOOL,
    Lower: f32,
    Upper: f32,
};

pub const DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA = extern struct {
    Enable: BOOL,
    SourceAspectRatio: DXVAHD_RATIONAL,
    DestinationAspectRatio: DXVAHD_RATIONAL,
};

pub const DXVAHD_STREAM_STATE_FILTER_DATA = extern struct {
    Enable: BOOL,
    Level: i32,
};

pub const DXVAHD_STREAM_STATE_PRIVATE_DATA = extern struct {
    Guid: Guid,
    DataSize: u32,
    pData: ?*anyopaque,
};

pub const DXVAHD_STREAM_DATA = extern struct {
    Enable: BOOL,
    OutputIndex: u32,
    InputFrameOrField: u32,
    PastFrames: u32,
    FutureFrames: u32,
    ppPastSurfaces: [*]?*IDirect3DSurface9,
    pInputSurface: ?*IDirect3DSurface9,
    ppFutureSurfaces: [*]?*IDirect3DSurface9,
};

pub const DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA = extern struct {
    Enable: BOOL,
    ITelecineFlags: u32,
    Frames: u32,
    InputField: u32,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXVAHD_Device_Value = Guid.initString("95f12dfd-d77e-49be-815f-57d579634d6d");
pub const IID_IDXVAHD_Device = &IID_IDXVAHD_Device_Value;
pub const IDXVAHD_Device = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateVideoSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                Width: u32,
                Height: u32,
                Format: D3DFORMAT,
                Pool: D3DPOOL,
                Usage: u32,
                Type: DXVAHD_SURFACE_TYPE,
                NumSurfaces: u32,
                ppSurfaces: [*]?*IDirect3DSurface9,
                pSharedHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                Width: u32,
                Height: u32,
                Format: D3DFORMAT,
                Pool: D3DPOOL,
                Usage: u32,
                Type: DXVAHD_SURFACE_TYPE,
                NumSurfaces: u32,
                ppSurfaces: [*]?*IDirect3DSurface9,
                pSharedHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorDeviceCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                pCaps: ?*DXVAHD_VPDEVCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                pCaps: ?*DXVAHD_VPDEVCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorOutputFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                Count: u32,
                pFormats: [*]D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                Count: u32,
                pFormats: [*]D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorInputFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                Count: u32,
                pFormats: [*]D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                Count: u32,
                pFormats: [*]D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                Count: u32,
                pCaps: [*]DXVAHD_VPCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                Count: u32,
                pCaps: [*]DXVAHD_VPCAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorCustomRates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                pVPGuid: ?*const Guid,
                Count: u32,
                pRates: [*]DXVAHD_CUSTOM_RATE_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                pVPGuid: ?*const Guid,
                Count: u32,
                pRates: [*]DXVAHD_CUSTOM_RATE_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorFilterRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                Filter: DXVAHD_FILTER,
                pRange: ?*DXVAHD_FILTER_RANGE_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                Filter: DXVAHD_FILTER,
                pRange: ?*DXVAHD_FILTER_RANGE_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_Device,
                pVPGuid: ?*const Guid,
                ppVideoProcessor: ?*?*IDXVAHD_VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_Device,
                pVPGuid: ?*const Guid,
                ppVideoProcessor: ?*?*IDXVAHD_VideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_CreateVideoSurface(self: *const T, Width: u32, Height: u32, Format: D3DFORMAT, Pool: D3DPOOL, Usage: u32, Type: DXVAHD_SURFACE_TYPE, NumSurfaces: u32, ppSurfaces: [*]?*IDirect3DSurface9, pSharedHandle: ?*?HANDLE) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).CreateVideoSurface(@as(*const IDXVAHD_Device, @ptrCast(self)), Width, Height, Format, Pool, Usage, Type, NumSurfaces, ppSurfaces, pSharedHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_GetVideoProcessorDeviceCaps(self: *const T, pCaps: ?*DXVAHD_VPDEVCAPS) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).GetVideoProcessorDeviceCaps(@as(*const IDXVAHD_Device, @ptrCast(self)), pCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_GetVideoProcessorOutputFormats(self: *const T, Count: u32, pFormats: [*]D3DFORMAT) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).GetVideoProcessorOutputFormats(@as(*const IDXVAHD_Device, @ptrCast(self)), Count, pFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_GetVideoProcessorInputFormats(self: *const T, Count: u32, pFormats: [*]D3DFORMAT) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).GetVideoProcessorInputFormats(@as(*const IDXVAHD_Device, @ptrCast(self)), Count, pFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_GetVideoProcessorCaps(self: *const T, Count: u32, pCaps: [*]DXVAHD_VPCAPS) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).GetVideoProcessorCaps(@as(*const IDXVAHD_Device, @ptrCast(self)), Count, pCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_GetVideoProcessorCustomRates(self: *const T, pVPGuid: ?*const Guid, Count: u32, pRates: [*]DXVAHD_CUSTOM_RATE_DATA) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).GetVideoProcessorCustomRates(@as(*const IDXVAHD_Device, @ptrCast(self)), pVPGuid, Count, pRates);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_GetVideoProcessorFilterRange(self: *const T, Filter: DXVAHD_FILTER, pRange: ?*DXVAHD_FILTER_RANGE_DATA) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).GetVideoProcessorFilterRange(@as(*const IDXVAHD_Device, @ptrCast(self)), Filter, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_Device_CreateVideoProcessor(self: *const T, pVPGuid: ?*const Guid, ppVideoProcessor: ?*?*IDXVAHD_VideoProcessor) HRESULT {
                return @as(*const IDXVAHD_Device.VTable, @ptrCast(self.vtable)).CreateVideoProcessor(@as(*const IDXVAHD_Device, @ptrCast(self)), pVPGuid, ppVideoProcessor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDXVAHD_VideoProcessor_Value = Guid.initString("95f4edf4-6e03-4cd7-be1b-3075d665aa52");
pub const IID_IDXVAHD_VideoProcessor = &IID_IDXVAHD_VideoProcessor_Value;
pub const IDXVAHD_VideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVideoProcessBltState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_VideoProcessor,
                State: DXVAHD_BLT_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_VideoProcessor,
                State: DXVAHD_BLT_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessBltState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_VideoProcessor,
                State: DXVAHD_BLT_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_VideoProcessor,
                State: DXVAHD_BLT_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoProcessStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_VideoProcessor,
                StreamNumber: u32,
                State: DXVAHD_STREAM_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_VideoProcessor,
                StreamNumber: u32,
                State: DXVAHD_STREAM_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*const anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_VideoProcessor,
                StreamNumber: u32,
                State: DXVAHD_STREAM_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_VideoProcessor,
                StreamNumber: u32,
                State: DXVAHD_STREAM_STATE,
                DataSize: u32,
                // TODO: what to do with BytesParamIndex 2?
                pData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VideoProcessBltHD: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDXVAHD_VideoProcessor,
                pOutputSurface: ?*IDirect3DSurface9,
                OutputFrame: u32,
                StreamCount: u32,
                pStreams: [*]const DXVAHD_STREAM_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDXVAHD_VideoProcessor,
                pOutputSurface: ?*IDirect3DSurface9,
                OutputFrame: u32,
                StreamCount: u32,
                pStreams: [*]const DXVAHD_STREAM_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_VideoProcessor_SetVideoProcessBltState(self: *const T, State: DXVAHD_BLT_STATE, DataSize: u32, pData: ?*const anyopaque) HRESULT {
                return @as(*const IDXVAHD_VideoProcessor.VTable, @ptrCast(self.vtable)).SetVideoProcessBltState(@as(*const IDXVAHD_VideoProcessor, @ptrCast(self)), State, DataSize, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_VideoProcessor_GetVideoProcessBltState(self: *const T, State: DXVAHD_BLT_STATE, DataSize: u32, pData: ?*anyopaque) HRESULT {
                return @as(*const IDXVAHD_VideoProcessor.VTable, @ptrCast(self.vtable)).GetVideoProcessBltState(@as(*const IDXVAHD_VideoProcessor, @ptrCast(self)), State, DataSize, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_VideoProcessor_SetVideoProcessStreamState(self: *const T, StreamNumber: u32, State: DXVAHD_STREAM_STATE, DataSize: u32, pData: ?*const anyopaque) HRESULT {
                return @as(*const IDXVAHD_VideoProcessor.VTable, @ptrCast(self.vtable)).SetVideoProcessStreamState(@as(*const IDXVAHD_VideoProcessor, @ptrCast(self)), StreamNumber, State, DataSize, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_VideoProcessor_GetVideoProcessStreamState(self: *const T, StreamNumber: u32, State: DXVAHD_STREAM_STATE, DataSize: u32, pData: ?*anyopaque) HRESULT {
                return @as(*const IDXVAHD_VideoProcessor.VTable, @ptrCast(self.vtable)).GetVideoProcessStreamState(@as(*const IDXVAHD_VideoProcessor, @ptrCast(self)), StreamNumber, State, DataSize, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDXVAHD_VideoProcessor_VideoProcessBltHD(self: *const T, pOutputSurface: ?*IDirect3DSurface9, OutputFrame: u32, StreamCount: u32, pStreams: [*]const DXVAHD_STREAM_DATA) HRESULT {
                return @as(*const IDXVAHD_VideoProcessor.VTable, @ptrCast(self.vtable)).VideoProcessBltHD(@as(*const IDXVAHD_VideoProcessor, @ptrCast(self)), pOutputSurface, OutputFrame, StreamCount, pStreams);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PDXVAHDSW_CreateDevice = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pD3DDevice: ?*IDirect3DDevice9Ex,
        phDevice: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        pD3DDevice: ?*IDirect3DDevice9Ex,
        phDevice: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_ProposeVideoPrivateFormat = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pFormat: ?*D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pFormat: ?*D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessorDeviceCaps = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        pCaps: ?*DXVAHD_VPDEVCAPS,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        pCaps: ?*DXVAHD_VPDEVCAPS,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessorOutputFormats = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessorInputFormats = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessorCaps = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        Count: u32,
        pCaps: [*]DXVAHD_VPCAPS,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        Count: u32,
        pCaps: [*]DXVAHD_VPCAPS,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessorCustomRates = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pVPGuid: ?*const Guid,
        Count: u32,
        pRates: [*]DXVAHD_CUSTOM_RATE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pVPGuid: ?*const Guid,
        Count: u32,
        pRates: [*]DXVAHD_CUSTOM_RATE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessorFilterRange = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        Filter: DXVAHD_FILTER,
        pRange: ?*DXVAHD_FILTER_RANGE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        Filter: DXVAHD_FILTER,
        pRange: ?*DXVAHD_FILTER_RANGE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_DestroyDevice = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_CreateVideoProcessor = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hDevice: ?HANDLE,
        pVPGuid: ?*const Guid,
        phVideoProcessor: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hDevice: ?HANDLE,
        pVPGuid: ?*const Guid,
        phVideoProcessor: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_SetVideoProcessBltState = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hVideoProcessor: ?HANDLE,
        State: DXVAHD_BLT_STATE,
        DataSize: u32,
        // TODO: what to do with BytesParamIndex 2?
        pData: ?*const anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hVideoProcessor: ?HANDLE,
        State: DXVAHD_BLT_STATE,
        DataSize: u32,
        // TODO: what to do with BytesParamIndex 2?
        pData: ?*const anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessBltStatePrivate = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hVideoProcessor: ?HANDLE,
        pData: ?*DXVAHD_BLT_STATE_PRIVATE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hVideoProcessor: ?HANDLE,
        pData: ?*DXVAHD_BLT_STATE_PRIVATE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_SetVideoProcessStreamState = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hVideoProcessor: ?HANDLE,
        StreamNumber: u32,
        State: DXVAHD_STREAM_STATE,
        DataSize: u32,
        // TODO: what to do with BytesParamIndex 3?
        pData: ?*const anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hVideoProcessor: ?HANDLE,
        StreamNumber: u32,
        State: DXVAHD_STREAM_STATE,
        DataSize: u32,
        // TODO: what to do with BytesParamIndex 3?
        pData: ?*const anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_GetVideoProcessStreamStatePrivate = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hVideoProcessor: ?HANDLE,
        StreamNumber: u32,
        pData: ?*DXVAHD_STREAM_STATE_PRIVATE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hVideoProcessor: ?HANDLE,
        StreamNumber: u32,
        pData: ?*DXVAHD_STREAM_STATE_PRIVATE_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_VideoProcessBltHD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hVideoProcessor: ?HANDLE,
        pOutputSurface: ?*IDirect3DSurface9,
        OutputFrame: u32,
        StreamCount: u32,
        pStreams: [*]const DXVAHD_STREAM_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hVideoProcessor: ?HANDLE,
        pOutputSurface: ?*IDirect3DSurface9,
        OutputFrame: u32,
        StreamCount: u32,
        pStreams: [*]const DXVAHD_STREAM_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDXVAHDSW_DestroyVideoProcessor = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hVideoProcessor: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hVideoProcessor: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const DXVAHDSW_CALLBACKS = extern struct {
    CreateDevice: ?PDXVAHDSW_CreateDevice,
    ProposeVideoPrivateFormat: ?PDXVAHDSW_ProposeVideoPrivateFormat,
    GetVideoProcessorDeviceCaps: ?PDXVAHDSW_GetVideoProcessorDeviceCaps,
    GetVideoProcessorOutputFormats: ?PDXVAHDSW_GetVideoProcessorOutputFormats,
    GetVideoProcessorInputFormats: ?PDXVAHDSW_GetVideoProcessorInputFormats,
    GetVideoProcessorCaps: ?PDXVAHDSW_GetVideoProcessorCaps,
    GetVideoProcessorCustomRates: ?PDXVAHDSW_GetVideoProcessorCustomRates,
    GetVideoProcessorFilterRange: ?PDXVAHDSW_GetVideoProcessorFilterRange,
    DestroyDevice: ?PDXVAHDSW_DestroyDevice,
    CreateVideoProcessor: ?PDXVAHDSW_CreateVideoProcessor,
    SetVideoProcessBltState: ?PDXVAHDSW_SetVideoProcessBltState,
    GetVideoProcessBltStatePrivate: ?PDXVAHDSW_GetVideoProcessBltStatePrivate,
    SetVideoProcessStreamState: ?PDXVAHDSW_SetVideoProcessStreamState,
    GetVideoProcessStreamStatePrivate: ?PDXVAHDSW_GetVideoProcessStreamStatePrivate,
    VideoProcessBltHD: ?PDXVAHDSW_VideoProcessBltHD,
    DestroyVideoProcessor: ?PDXVAHDSW_DestroyVideoProcessor,
};

pub const PDXVAHDSW_Plugin = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Size: u32,
        // TODO: what to do with BytesParamIndex 0?
        pCallbacks: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Size: u32,
        // TODO: what to do with BytesParamIndex 0?
        pCallbacks: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const DXVAHDETW_CREATEVIDEOPROCESSOR = extern struct {
    pObject: u64,
    pD3D9Ex: u64,
    VPGuid: Guid,
};

pub const DXVAHDETW_VIDEOPROCESSBLTSTATE = extern struct {
    pObject: u64,
    State: DXVAHD_BLT_STATE,
    DataSize: u32,
    SetState: BOOL,
};

pub const DXVAHDETW_VIDEOPROCESSSTREAMSTATE = extern struct {
    pObject: u64,
    StreamNumber: u32,
    State: DXVAHD_STREAM_STATE,
    DataSize: u32,
    SetState: BOOL,
};

pub const DXVAHDETW_VIDEOPROCESSBLTHD = extern struct {
    pObject: u64,
    pOutputSurface: u64,
    TargetRect: RECT,
    OutputFormat: D3DFORMAT,
    ColorSpace: u32,
    OutputFrame: u32,
    StreamCount: u32,
    Enter: BOOL,
};

pub const DXVAHDETW_VIDEOPROCESSBLTHD_STREAM = extern struct {
    pObject: u64,
    pInputSurface: u64,
    SourceRect: RECT,
    DestinationRect: RECT,
    InputFormat: D3DFORMAT,
    FrameFormat: DXVAHD_FRAME_FORMAT,
    ColorSpace: u32,
    StreamNumber: u32,
    OutputIndex: u32,
    InputFrameOrField: u32,
    PastFrames: u32,
    FutureFrames: u32,
};

pub const DXVAHDETW_DESTROYVIDEOPROCESSOR = extern struct {
    pObject: u64,
};

pub const PDXVAHD_CreateDevice = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pD3DDevice: ?*IDirect3DDevice9Ex,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        pPlugin: ?PDXVAHDSW_Plugin,
        ppDevice: ?*?*IDXVAHD_Device,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        pD3DDevice: ?*IDirect3DDevice9Ex,
        pContentDesc: ?*const DXVAHD_CONTENT_DESC,
        Usage: DXVAHD_DEVICE_USAGE,
        pPlugin: ?PDXVAHDSW_Plugin,
        ppDevice: ?*?*IDXVAHD_Device,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const DXVA2_ExtendedFormat = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u32,
        },
        value: u32,
    },
};

pub const DXVA2_SampleFormat = enum(i32) {
    FormatMask = 255,
    Unknown = 0,
    ProgressiveFrame = 2,
    FieldInterleavedEvenFirst = 3,
    FieldInterleavedOddFirst = 4,
    FieldSingleEven = 5,
    FieldSingleOdd = 6,
    SubStream = 7,
};
pub const DXVA2_SampleFormatMask = DXVA2_SampleFormat.FormatMask;
pub const DXVA2_SampleUnknown = DXVA2_SampleFormat.Unknown;
pub const DXVA2_SampleProgressiveFrame = DXVA2_SampleFormat.ProgressiveFrame;
pub const DXVA2_SampleFieldInterleavedEvenFirst = DXVA2_SampleFormat.FieldInterleavedEvenFirst;
pub const DXVA2_SampleFieldInterleavedOddFirst = DXVA2_SampleFormat.FieldInterleavedOddFirst;
pub const DXVA2_SampleFieldSingleEven = DXVA2_SampleFormat.FieldSingleEven;
pub const DXVA2_SampleFieldSingleOdd = DXVA2_SampleFormat.FieldSingleOdd;
pub const DXVA2_SampleSubStream = DXVA2_SampleFormat.SubStream;

pub const DXVA2_VideoChromaSubSampling = enum(i32) {
    Mask = 15,
    _Unknown = 0,
    _ProgressiveChroma = 8,
    _Horizontally_Cosited = 4,
    _Vertically_Cosited = 2,
    _Vertically_AlignedChromaPlanes = 1,
    _MPEG2 = 5,
    // _MPEG1 = 1, this enum value conflicts with _Vertically_AlignedChromaPlanes
    _DV_PAL = 6,
    _Cosited = 7,
};
pub const DXVA2_VideoChromaSubsamplingMask = DXVA2_VideoChromaSubSampling.Mask;
pub const DXVA2_VideoChromaSubsampling_Unknown = DXVA2_VideoChromaSubSampling._Unknown;
pub const DXVA2_VideoChromaSubsampling_ProgressiveChroma = DXVA2_VideoChromaSubSampling._ProgressiveChroma;
pub const DXVA2_VideoChromaSubsampling_Horizontally_Cosited = DXVA2_VideoChromaSubSampling._Horizontally_Cosited;
pub const DXVA2_VideoChromaSubsampling_Vertically_Cosited = DXVA2_VideoChromaSubSampling._Vertically_Cosited;
pub const DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = DXVA2_VideoChromaSubSampling._Vertically_AlignedChromaPlanes;
pub const DXVA2_VideoChromaSubsampling_MPEG2 = DXVA2_VideoChromaSubSampling._MPEG2;
pub const DXVA2_VideoChromaSubsampling_MPEG1 = DXVA2_VideoChromaSubSampling._Vertically_AlignedChromaPlanes;
pub const DXVA2_VideoChromaSubsampling_DV_PAL = DXVA2_VideoChromaSubSampling._DV_PAL;
pub const DXVA2_VideoChromaSubsampling_Cosited = DXVA2_VideoChromaSubSampling._Cosited;

pub const DXVA2_NominalRange = enum(i32) {
    Mask = 7,
    _Unknown = 0,
    _Normal = 1,
    _Wide = 2,
    // _0_255 = 1, this enum value conflicts with _Normal
    // _16_235 = 2, this enum value conflicts with _Wide
    _48_208 = 3,
};
pub const DXVA2_NominalRangeMask = DXVA2_NominalRange.Mask;
pub const DXVA2_NominalRange_Unknown = DXVA2_NominalRange._Unknown;
pub const DXVA2_NominalRange_Normal = DXVA2_NominalRange._Normal;
pub const DXVA2_NominalRange_Wide = DXVA2_NominalRange._Wide;
pub const DXVA2_NominalRange_0_255 = DXVA2_NominalRange._Normal;
pub const DXVA2_NominalRange_16_235 = DXVA2_NominalRange._Wide;
pub const DXVA2_NominalRange_48_208 = DXVA2_NominalRange._48_208;

pub const DXVA2_VideoTransferMatrix = enum(i32) {
    Mask = 7,
    _Unknown = 0,
    _BT709 = 1,
    _BT601 = 2,
    _SMPTE240M = 3,
};
pub const DXVA2_VideoTransferMatrixMask = DXVA2_VideoTransferMatrix.Mask;
pub const DXVA2_VideoTransferMatrix_Unknown = DXVA2_VideoTransferMatrix._Unknown;
pub const DXVA2_VideoTransferMatrix_BT709 = DXVA2_VideoTransferMatrix._BT709;
pub const DXVA2_VideoTransferMatrix_BT601 = DXVA2_VideoTransferMatrix._BT601;
pub const DXVA2_VideoTransferMatrix_SMPTE240M = DXVA2_VideoTransferMatrix._SMPTE240M;

pub const DXVA2_VideoLighting = enum(i32) {
    Mask = 15,
    _Unknown = 0,
    _bright = 1,
    _office = 2,
    _dim = 3,
    _dark = 4,
};
pub const DXVA2_VideoLightingMask = DXVA2_VideoLighting.Mask;
pub const DXVA2_VideoLighting_Unknown = DXVA2_VideoLighting._Unknown;
pub const DXVA2_VideoLighting_bright = DXVA2_VideoLighting._bright;
pub const DXVA2_VideoLighting_office = DXVA2_VideoLighting._office;
pub const DXVA2_VideoLighting_dim = DXVA2_VideoLighting._dim;
pub const DXVA2_VideoLighting_dark = DXVA2_VideoLighting._dark;

pub const DXVA2_VideoPrimaries = enum(i32) {
    Mask = 31,
    _Unknown = 0,
    _reserved = 1,
    _BT709 = 2,
    _BT470_2_SysM = 3,
    _BT470_2_SysBG = 4,
    _SMPTE170M = 5,
    _SMPTE240M = 6,
    _EBU3213 = 7,
    _SMPTE_C = 8,
};
pub const DXVA2_VideoPrimariesMask = DXVA2_VideoPrimaries.Mask;
pub const DXVA2_VideoPrimaries_Unknown = DXVA2_VideoPrimaries._Unknown;
pub const DXVA2_VideoPrimaries_reserved = DXVA2_VideoPrimaries._reserved;
pub const DXVA2_VideoPrimaries_BT709 = DXVA2_VideoPrimaries._BT709;
pub const DXVA2_VideoPrimaries_BT470_2_SysM = DXVA2_VideoPrimaries._BT470_2_SysM;
pub const DXVA2_VideoPrimaries_BT470_2_SysBG = DXVA2_VideoPrimaries._BT470_2_SysBG;
pub const DXVA2_VideoPrimaries_SMPTE170M = DXVA2_VideoPrimaries._SMPTE170M;
pub const DXVA2_VideoPrimaries_SMPTE240M = DXVA2_VideoPrimaries._SMPTE240M;
pub const DXVA2_VideoPrimaries_EBU3213 = DXVA2_VideoPrimaries._EBU3213;
pub const DXVA2_VideoPrimaries_SMPTE_C = DXVA2_VideoPrimaries._SMPTE_C;

pub const DXVA2_VideoTransferFunction = enum(i32) {
    Mask = 31,
    _Unknown = 0,
    _10 = 1,
    _18 = 2,
    _20 = 3,
    _22 = 4,
    _709 = 5,
    _240M = 6,
    _sRGB = 7,
    _28 = 8,
};
pub const DXVA2_VideoTransFuncMask = DXVA2_VideoTransferFunction.Mask;
pub const DXVA2_VideoTransFunc_Unknown = DXVA2_VideoTransferFunction._Unknown;
pub const DXVA2_VideoTransFunc_10 = DXVA2_VideoTransferFunction._10;
pub const DXVA2_VideoTransFunc_18 = DXVA2_VideoTransferFunction._18;
pub const DXVA2_VideoTransFunc_20 = DXVA2_VideoTransferFunction._20;
pub const DXVA2_VideoTransFunc_22 = DXVA2_VideoTransferFunction._22;
pub const DXVA2_VideoTransFunc_709 = DXVA2_VideoTransferFunction._709;
pub const DXVA2_VideoTransFunc_240M = DXVA2_VideoTransferFunction._240M;
pub const DXVA2_VideoTransFunc_sRGB = DXVA2_VideoTransferFunction._sRGB;
pub const DXVA2_VideoTransFunc_28 = DXVA2_VideoTransferFunction._28;

pub const DXVA2_Frequency = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXVA2_VideoDesc = extern struct {
    SampleWidth: u32,
    SampleHeight: u32,
    SampleFormat: DXVA2_ExtendedFormat,
    Format: D3DFORMAT,
    InputSampleFreq: DXVA2_Frequency,
    OutputFrameFreq: DXVA2_Frequency,
    UABProtectionLevel: u32,
    Reserved: u32,
};

pub const DXVA2_DeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    BOBVerticalStretch4Tap = 4,
    MedianFiltering = 8,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
    InverseTelecine = 256,
    Mask = 511,
};
pub const DXVA2_DeinterlaceTech_Unknown = DXVA2_DeinterlaceTech.Unknown;
pub const DXVA2_DeinterlaceTech_BOBLineReplicate = DXVA2_DeinterlaceTech.BOBLineReplicate;
pub const DXVA2_DeinterlaceTech_BOBVerticalStretch = DXVA2_DeinterlaceTech.BOBVerticalStretch;
pub const DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap = DXVA2_DeinterlaceTech.BOBVerticalStretch4Tap;
pub const DXVA2_DeinterlaceTech_MedianFiltering = DXVA2_DeinterlaceTech.MedianFiltering;
pub const DXVA2_DeinterlaceTech_EdgeFiltering = DXVA2_DeinterlaceTech.EdgeFiltering;
pub const DXVA2_DeinterlaceTech_FieldAdaptive = DXVA2_DeinterlaceTech.FieldAdaptive;
pub const DXVA2_DeinterlaceTech_PixelAdaptive = DXVA2_DeinterlaceTech.PixelAdaptive;
pub const DXVA2_DeinterlaceTech_MotionVectorSteered = DXVA2_DeinterlaceTech.MotionVectorSteered;
pub const DXVA2_DeinterlaceTech_InverseTelecine = DXVA2_DeinterlaceTech.InverseTelecine;
pub const DXVA2_DeinterlaceTech_Mask = DXVA2_DeinterlaceTech.Mask;

pub const DXVA2_FilterType = enum(i32) {
    NoiseFilterLumaLevel = 1,
    NoiseFilterLumaThreshold = 2,
    NoiseFilterLumaRadius = 3,
    NoiseFilterChromaLevel = 4,
    NoiseFilterChromaThreshold = 5,
    NoiseFilterChromaRadius = 6,
    DetailFilterLumaLevel = 7,
    DetailFilterLumaThreshold = 8,
    DetailFilterLumaRadius = 9,
    DetailFilterChromaLevel = 10,
    DetailFilterChromaThreshold = 11,
    DetailFilterChromaRadius = 12,
};
pub const DXVA2_NoiseFilterLumaLevel = DXVA2_FilterType.NoiseFilterLumaLevel;
pub const DXVA2_NoiseFilterLumaThreshold = DXVA2_FilterType.NoiseFilterLumaThreshold;
pub const DXVA2_NoiseFilterLumaRadius = DXVA2_FilterType.NoiseFilterLumaRadius;
pub const DXVA2_NoiseFilterChromaLevel = DXVA2_FilterType.NoiseFilterChromaLevel;
pub const DXVA2_NoiseFilterChromaThreshold = DXVA2_FilterType.NoiseFilterChromaThreshold;
pub const DXVA2_NoiseFilterChromaRadius = DXVA2_FilterType.NoiseFilterChromaRadius;
pub const DXVA2_DetailFilterLumaLevel = DXVA2_FilterType.DetailFilterLumaLevel;
pub const DXVA2_DetailFilterLumaThreshold = DXVA2_FilterType.DetailFilterLumaThreshold;
pub const DXVA2_DetailFilterLumaRadius = DXVA2_FilterType.DetailFilterLumaRadius;
pub const DXVA2_DetailFilterChromaLevel = DXVA2_FilterType.DetailFilterChromaLevel;
pub const DXVA2_DetailFilterChromaThreshold = DXVA2_FilterType.DetailFilterChromaThreshold;
pub const DXVA2_DetailFilterChromaRadius = DXVA2_FilterType.DetailFilterChromaRadius;

pub const DXVA2_NoiseFilterTech = enum(i32) {
    Unsupported = 0,
    Unknown = 1,
    Median = 2,
    Temporal = 4,
    BlockNoise = 8,
    MosquitoNoise = 16,
    Mask = 31,
};
pub const DXVA2_NoiseFilterTech_Unsupported = DXVA2_NoiseFilterTech.Unsupported;
pub const DXVA2_NoiseFilterTech_Unknown = DXVA2_NoiseFilterTech.Unknown;
pub const DXVA2_NoiseFilterTech_Median = DXVA2_NoiseFilterTech.Median;
pub const DXVA2_NoiseFilterTech_Temporal = DXVA2_NoiseFilterTech.Temporal;
pub const DXVA2_NoiseFilterTech_BlockNoise = DXVA2_NoiseFilterTech.BlockNoise;
pub const DXVA2_NoiseFilterTech_MosquitoNoise = DXVA2_NoiseFilterTech.MosquitoNoise;
pub const DXVA2_NoiseFilterTech_Mask = DXVA2_NoiseFilterTech.Mask;

pub const DXVA2_DetailFilterTech = enum(i32) {
    Unsupported = 0,
    Unknown = 1,
    Edge = 2,
    Sharpening = 4,
    Mask = 7,
};
pub const DXVA2_DetailFilterTech_Unsupported = DXVA2_DetailFilterTech.Unsupported;
pub const DXVA2_DetailFilterTech_Unknown = DXVA2_DetailFilterTech.Unknown;
pub const DXVA2_DetailFilterTech_Edge = DXVA2_DetailFilterTech.Edge;
pub const DXVA2_DetailFilterTech_Sharpening = DXVA2_DetailFilterTech.Sharpening;
pub const DXVA2_DetailFilterTech_Mask = DXVA2_DetailFilterTech.Mask;

pub const DXVA2_ProcAmp = enum(i32) {
    None = 0,
    Brightness = 1,
    Contrast = 2,
    Hue = 4,
    Saturation = 8,
    Mask = 15,
};
pub const DXVA2_ProcAmp_None = DXVA2_ProcAmp.None;
pub const DXVA2_ProcAmp_Brightness = DXVA2_ProcAmp.Brightness;
pub const DXVA2_ProcAmp_Contrast = DXVA2_ProcAmp.Contrast;
pub const DXVA2_ProcAmp_Hue = DXVA2_ProcAmp.Hue;
pub const DXVA2_ProcAmp_Saturation = DXVA2_ProcAmp.Saturation;
pub const DXVA2_ProcAmp_Mask = DXVA2_ProcAmp.Mask;

pub const DXVA2_VideoProcess = enum(i32) {
    None = 0,
    YUV2RGB = 1,
    StretchX = 2,
    StretchY = 4,
    AlphaBlend = 8,
    SubRects = 16,
    SubStreams = 32,
    SubStreamsExtended = 64,
    YUV2RGBExtended = 128,
    AlphaBlendExtended = 256,
    Constriction = 512,
    NoiseFilter = 1024,
    DetailFilter = 2048,
    PlanarAlpha = 4096,
    LinearScaling = 8192,
    GammaCompensated = 16384,
    MaintainsOriginalFieldData = 32768,
    Mask = 65535,
};
pub const DXVA2_VideoProcess_None = DXVA2_VideoProcess.None;
pub const DXVA2_VideoProcess_YUV2RGB = DXVA2_VideoProcess.YUV2RGB;
pub const DXVA2_VideoProcess_StretchX = DXVA2_VideoProcess.StretchX;
pub const DXVA2_VideoProcess_StretchY = DXVA2_VideoProcess.StretchY;
pub const DXVA2_VideoProcess_AlphaBlend = DXVA2_VideoProcess.AlphaBlend;
pub const DXVA2_VideoProcess_SubRects = DXVA2_VideoProcess.SubRects;
pub const DXVA2_VideoProcess_SubStreams = DXVA2_VideoProcess.SubStreams;
pub const DXVA2_VideoProcess_SubStreamsExtended = DXVA2_VideoProcess.SubStreamsExtended;
pub const DXVA2_VideoProcess_YUV2RGBExtended = DXVA2_VideoProcess.YUV2RGBExtended;
pub const DXVA2_VideoProcess_AlphaBlendExtended = DXVA2_VideoProcess.AlphaBlendExtended;
pub const DXVA2_VideoProcess_Constriction = DXVA2_VideoProcess.Constriction;
pub const DXVA2_VideoProcess_NoiseFilter = DXVA2_VideoProcess.NoiseFilter;
pub const DXVA2_VideoProcess_DetailFilter = DXVA2_VideoProcess.DetailFilter;
pub const DXVA2_VideoProcess_PlanarAlpha = DXVA2_VideoProcess.PlanarAlpha;
pub const DXVA2_VideoProcess_LinearScaling = DXVA2_VideoProcess.LinearScaling;
pub const DXVA2_VideoProcess_GammaCompensated = DXVA2_VideoProcess.GammaCompensated;
pub const DXVA2_VideoProcess_MaintainsOriginalFieldData = DXVA2_VideoProcess.MaintainsOriginalFieldData;
pub const DXVA2_VideoProcess_Mask = DXVA2_VideoProcess.Mask;

pub const DXVA2_VPDev = enum(i32) {
    HardwareDevice = 1,
    EmulatedDXVA1 = 2,
    SoftwareDevice = 4,
    Mask = 7,
};
pub const DXVA2_VPDev_HardwareDevice = DXVA2_VPDev.HardwareDevice;
pub const DXVA2_VPDev_EmulatedDXVA1 = DXVA2_VPDev.EmulatedDXVA1;
pub const DXVA2_VPDev_SoftwareDevice = DXVA2_VPDev.SoftwareDevice;
pub const DXVA2_VPDev_Mask = DXVA2_VPDev.Mask;

pub const DXVA2_SampleData = enum(i32) {
    RFF = 1,
    TFF = 2,
    RFF_TFF_Present = 4,
    Mask = 65535,
};
pub const DXVA2_SampleData_RFF = DXVA2_SampleData.RFF;
pub const DXVA2_SampleData_TFF = DXVA2_SampleData.TFF;
pub const DXVA2_SampleData_RFF_TFF_Present = DXVA2_SampleData.RFF_TFF_Present;
pub const DXVA2_SampleData_Mask = DXVA2_SampleData.Mask;

pub const DXVA2_DestData = enum(i32) {
    RFF = 1,
    TFF = 2,
    RFF_TFF_Present = 4,
    Mask = 65535,
};
pub const DXVA2_DestData_RFF = DXVA2_DestData.RFF;
pub const DXVA2_DestData_TFF = DXVA2_DestData.TFF;
pub const DXVA2_DestData_RFF_TFF_Present = DXVA2_DestData.RFF_TFF_Present;
pub const DXVA2_DestData_Mask = DXVA2_DestData.Mask;

pub const DXVA2_VideoProcessorCaps = extern struct {
    DeviceCaps: u32,
    InputPool: D3DPOOL,
    NumForwardRefSamples: u32,
    NumBackwardRefSamples: u32,
    Reserved: u32,
    DeinterlaceTechnology: u32,
    ProcAmpControlCaps: u32,
    VideoProcessorOperations: u32,
    NoiseFilterTechnology: u32,
    DetailFilterTechnology: u32,
};

pub const DXVA2_Fixed32 = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            Fraction: u16,
            Value: i16,
        },
        ll: i32,
    },
};

pub const DXVA2_AYUVSample8 = extern struct {
    Cr: u8,
    Cb: u8,
    Y: u8,
    Alpha: u8,
};

pub const DXVA2_AYUVSample16 = extern struct {
    Cr: u16,
    Cb: u16,
    Y: u16,
    Alpha: u16,
};

pub const DXVA2_VideoSample = extern struct {
    Start: i64,
    End: i64,
    SampleFormat: DXVA2_ExtendedFormat,
    SrcSurface: ?*IDirect3DSurface9,
    SrcRect: RECT,
    DstRect: RECT,
    Pal: [16]DXVA2_AYUVSample8,
    PlanarAlpha: DXVA2_Fixed32,
    SampleData: u32,
};

pub const DXVA2_ValueRange = extern struct {
    MinValue: DXVA2_Fixed32,
    MaxValue: DXVA2_Fixed32,
    DefaultValue: DXVA2_Fixed32,
    StepSize: DXVA2_Fixed32,
};

pub const DXVA2_ProcAmpValues = extern struct {
    Brightness: DXVA2_Fixed32,
    Contrast: DXVA2_Fixed32,
    Hue: DXVA2_Fixed32,
    Saturation: DXVA2_Fixed32,
};

pub const DXVA2_FilterValues = extern struct {
    Level: DXVA2_Fixed32,
    Threshold: DXVA2_Fixed32,
    Radius: DXVA2_Fixed32,
};

pub const DXVA2_VideoProcessBltParams = extern struct {
    TargetFrame: i64,
    TargetRect: RECT,
    ConstrictionSize: SIZE,
    StreamingFlags: u32,
    BackgroundColor: DXVA2_AYUVSample16,
    DestFormat: DXVA2_ExtendedFormat,
    ProcAmpValues: DXVA2_ProcAmpValues,
    Alpha: DXVA2_Fixed32,
    NoiseFilterLuma: DXVA2_FilterValues,
    NoiseFilterChroma: DXVA2_FilterValues,
    DetailFilterLuma: DXVA2_FilterValues,
    DetailFilterChroma: DXVA2_FilterValues,
    DestData: u32,
};

pub const DXVA2_BufferfType = enum(i32) {
    PictureParametersBufferType = 0,
    MacroBlockControlBufferType = 1,
    ResidualDifferenceBufferType = 2,
    DeblockingControlBufferType = 3,
    InverseQuantizationMatrixBufferType = 4,
    SliceControlBufferType = 5,
    BitStreamDateBufferType = 6,
    MotionVectorBuffer = 7,
    FilmGrainBuffer = 8,
};
pub const DXVA2_PictureParametersBufferType = DXVA2_BufferfType.PictureParametersBufferType;
pub const DXVA2_MacroBlockControlBufferType = DXVA2_BufferfType.MacroBlockControlBufferType;
pub const DXVA2_ResidualDifferenceBufferType = DXVA2_BufferfType.ResidualDifferenceBufferType;
pub const DXVA2_DeblockingControlBufferType = DXVA2_BufferfType.DeblockingControlBufferType;
pub const DXVA2_InverseQuantizationMatrixBufferType = DXVA2_BufferfType.InverseQuantizationMatrixBufferType;
pub const DXVA2_SliceControlBufferType = DXVA2_BufferfType.SliceControlBufferType;
pub const DXVA2_BitStreamDateBufferType = DXVA2_BufferfType.BitStreamDateBufferType;
pub const DXVA2_MotionVectorBuffer = DXVA2_BufferfType.MotionVectorBuffer;
pub const DXVA2_FilmGrainBuffer = DXVA2_BufferfType.FilmGrainBuffer;

pub const DXVA2_VideoRenderTargetType = enum(i32) {
    DecoderRenderTarget = 0,
    ProcessorRenderTarget = 1,
    SoftwareRenderTarget = 2,
};
pub const DXVA2_VideoDecoderRenderTarget = DXVA2_VideoRenderTargetType.DecoderRenderTarget;
pub const DXVA2_VideoProcessorRenderTarget = DXVA2_VideoRenderTargetType.ProcessorRenderTarget;
pub const DXVA2_VideoSoftwareRenderTarget = DXVA2_VideoRenderTargetType.SoftwareRenderTarget;

pub const DXVA2_ConfigPictureDecode = extern struct {
    guidConfigBitstreamEncryption: Guid,
    guidConfigMBcontrolEncryption: Guid,
    guidConfigResidDiffEncryption: Guid,
    ConfigBitstreamRaw: u32,
    ConfigMBcontrolRasterOrder: u32,
    ConfigResidDiffHost: u32,
    ConfigSpatialResid8: u32,
    ConfigResid8Subtraction: u32,
    ConfigSpatialHost8or9Clipping: u32,
    ConfigSpatialResidInterleaved: u32,
    ConfigIntraResidUnsigned: u32,
    ConfigResidDiffAccelerator: u32,
    ConfigHostInverseScan: u32,
    ConfigSpecificIDCT: u32,
    Config4GroupedCoefs: u32,
    ConfigMinRenderTargetBuffCount: u16,
    ConfigDecoderSpecific: u16,
};

pub const DXVA2_DecodeBufferDesc = extern struct {
    CompressedBufferType: DXVA2_BufferfType,
    BufferIndex: u32,
    DataOffset: u32,
    DataSize: u32,
    FirstMBaddress: u32,
    NumMBsInBuffer: u32,
    Width: u32,
    Height: u32,
    Stride: u32,
    ReservedBits: u32,
    pvPVPState: ?*anyopaque,
};

pub const DXVA2_AES_CTR_IV = extern struct {
    IV: u64,
    Count: u64,
};

pub const DXVA2_DecodeExtensionData = extern struct {
    Function: u32,
    pPrivateInputData: ?*anyopaque,
    PrivateInputDataSize: u32,
    pPrivateOutputData: ?*anyopaque,
    PrivateOutputDataSize: u32,
};

pub const DXVA2_DecodeExecuteParams = extern struct {
    NumCompBuffers: u32,
    pCompressedBuffers: ?*DXVA2_DecodeBufferDesc,
    pExtensionData: ?*DXVA2_DecodeExtensionData,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirect3DDeviceManager9_Value = Guid.initString("a0cade0f-06d5-4cf4-a1c7-f3cdd725aa75");
pub const IID_IDirect3DDeviceManager9 = &IID_IDirect3DDeviceManager9_Value;
pub const IDirect3DDeviceManager9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                pDevice: ?*IDirect3DDevice9,
                resetToken: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                pDevice: ?*IDirect3DDevice9,
                resetToken: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDeviceHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                phDevice: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                phDevice: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseDeviceHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
                ppDevice: ?*?*IDirect3DDevice9,
                fBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
                ppDevice: ?*?*IDirect3DDevice9,
                fBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
                fSaveState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
                fSaveState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
                riid: ?*const Guid,
                ppService: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirect3DDeviceManager9,
                hDevice: ?HANDLE,
                riid: ?*const Guid,
                ppService: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_ResetDevice(self: *const T, pDevice: ?*IDirect3DDevice9, resetToken: u32) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).ResetDevice(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), pDevice, resetToken);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_OpenDeviceHandle(self: *const T, phDevice: ?*?HANDLE) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).OpenDeviceHandle(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), phDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_CloseDeviceHandle(self: *const T, hDevice: ?HANDLE) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).CloseDeviceHandle(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), hDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_TestDevice(self: *const T, hDevice: ?HANDLE) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).TestDevice(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), hDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_LockDevice(self: *const T, hDevice: ?HANDLE, ppDevice: ?*?*IDirect3DDevice9, fBlock: BOOL) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).LockDevice(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), hDevice, ppDevice, fBlock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_UnlockDevice(self: *const T, hDevice: ?HANDLE, fSaveState: BOOL) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).UnlockDevice(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), hDevice, fSaveState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirect3DDeviceManager9_GetVideoService(self: *const T, hDevice: ?HANDLE, riid: ?*const Guid, ppService: ?*?*anyopaque) HRESULT {
                return @as(*const IDirect3DDeviceManager9.VTable, @ptrCast(self.vtable)).GetVideoService(@as(*const IDirect3DDeviceManager9, @ptrCast(self)), hDevice, riid, ppService);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirectXVideoAccelerationService_Value = Guid.initString("fc51a550-d5e7-11d9-af55-00054e43ff02");
pub const IID_IDirectXVideoAccelerationService = &IID_IDirectXVideoAccelerationService_Value;
pub const IDirectXVideoAccelerationService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoAccelerationService,
                Width: u32,
                Height: u32,
                BackBuffers: u32,
                Format: D3DFORMAT,
                Pool: D3DPOOL,
                Usage: u32,
                DxvaType: DXVA2_VideoRenderTargetType,
                ppSurface: ?*?*IDirect3DSurface9,
                pSharedHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoAccelerationService,
                Width: u32,
                Height: u32,
                BackBuffers: u32,
                Format: D3DFORMAT,
                Pool: D3DPOOL,
                Usage: u32,
                DxvaType: DXVA2_VideoRenderTargetType,
                ppSurface: ?*?*IDirect3DSurface9,
                pSharedHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoAccelerationService_CreateSurface(self: *const T, Width: u32, Height: u32, BackBuffers: u32, Format: D3DFORMAT, Pool: D3DPOOL, Usage: u32, DxvaType: DXVA2_VideoRenderTargetType, ppSurface: ?*?*IDirect3DSurface9, pSharedHandle: ?*?HANDLE) HRESULT {
                return @as(*const IDirectXVideoAccelerationService.VTable, @ptrCast(self.vtable)).CreateSurface(@as(*const IDirectXVideoAccelerationService, @ptrCast(self)), Width, Height, BackBuffers, Format, Pool, Usage, DxvaType, ppSurface, pSharedHandle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirectXVideoDecoderService_Value = Guid.initString("fc51a551-d5e7-11d9-af55-00054e43ff02");
pub const IID_IDirectXVideoDecoderService = &IID_IDirectXVideoDecoderService_Value;
pub const IDirectXVideoDecoderService = extern struct {
    pub const VTable = extern struct {
        base: IDirectXVideoAccelerationService.VTable,
        GetDecoderDeviceGuids: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoderService,
                pCount: ?*u32,
                pGuids: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoderService,
                pCount: ?*u32,
                pGuids: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDecoderRenderTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoderService,
                Guid: ?*const Guid,
                pCount: ?*u32,
                pFormats: ?*?*D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoderService,
                Guid: ?*const Guid,
                pCount: ?*u32,
                pFormats: ?*?*D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDecoderConfigurations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoderService,
                Guid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pReserved: ?*anyopaque,
                pCount: ?*u32,
                ppConfigs: ?*?*DXVA2_ConfigPictureDecode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoderService,
                Guid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pReserved: ?*anyopaque,
                pCount: ?*u32,
                ppConfigs: ?*?*DXVA2_ConfigPictureDecode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoDecoder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoderService,
                Guid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pConfig: ?*const DXVA2_ConfigPictureDecode,
                ppDecoderRenderTargets: [*]?*IDirect3DSurface9,
                NumRenderTargets: u32,
                ppDecode: ?*?*IDirectXVideoDecoder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoderService,
                Guid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pConfig: ?*const DXVA2_ConfigPictureDecode,
                ppDecoderRenderTargets: [*]?*IDirect3DSurface9,
                NumRenderTargets: u32,
                ppDecode: ?*?*IDirectXVideoDecoder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDirectXVideoAccelerationService.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoderService_GetDecoderDeviceGuids(self: *const T, pCount: ?*u32, pGuids: ?*?*Guid) HRESULT {
                return @as(*const IDirectXVideoDecoderService.VTable, @ptrCast(self.vtable)).GetDecoderDeviceGuids(@as(*const IDirectXVideoDecoderService, @ptrCast(self)), pCount, pGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoderService_GetDecoderRenderTargets(self: *const T, _param_Guid: ?*const Guid, pCount: ?*u32, pFormats: ?*?*D3DFORMAT) HRESULT {
                return @as(*const IDirectXVideoDecoderService.VTable, @ptrCast(self.vtable)).GetDecoderRenderTargets(@as(*const IDirectXVideoDecoderService, @ptrCast(self)), _param_Guid, pCount, pFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoderService_GetDecoderConfigurations(self: *const T, _param_Guid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, pReserved: ?*anyopaque, pCount: ?*u32, ppConfigs: ?*?*DXVA2_ConfigPictureDecode) HRESULT {
                return @as(*const IDirectXVideoDecoderService.VTable, @ptrCast(self.vtable)).GetDecoderConfigurations(@as(*const IDirectXVideoDecoderService, @ptrCast(self)), _param_Guid, pVideoDesc, pReserved, pCount, ppConfigs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoderService_CreateVideoDecoder(self: *const T, _param_Guid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, pConfig: ?*const DXVA2_ConfigPictureDecode, ppDecoderRenderTargets: [*]?*IDirect3DSurface9, NumRenderTargets: u32, ppDecode: ?*?*IDirectXVideoDecoder) HRESULT {
                return @as(*const IDirectXVideoDecoderService.VTable, @ptrCast(self.vtable)).CreateVideoDecoder(@as(*const IDirectXVideoDecoderService, @ptrCast(self)), _param_Guid, pVideoDesc, pConfig, ppDecoderRenderTargets, NumRenderTargets, ppDecode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirectXVideoProcessorService_Value = Guid.initString("fc51a552-d5e7-11d9-af55-00054e43ff02");
pub const IID_IDirectXVideoProcessorService = &IID_IDirectXVideoProcessorService_Value;
pub const IDirectXVideoProcessorService = extern struct {
    pub const VTable = extern struct {
        base: IDirectXVideoAccelerationService.VTable,
        RegisterVideoProcessorSoftwareDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                pCallbacks: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                pCallbacks: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorDeviceGuids: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pCount: ?*u32,
                pGuids: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pCount: ?*u32,
                pGuids: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorRenderTargets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pCount: ?*u32,
                pFormats: ?*?*D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                pCount: ?*u32,
                pFormats: ?*?*D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorSubStreamFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                pCount: ?*u32,
                pFormats: ?*?*D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                pCount: ?*u32,
                pFormats: ?*?*D3DFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                pCaps: ?*DXVA2_VideoProcessorCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                pCaps: ?*DXVA2_VideoProcessorCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAmpRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                ProcAmpCap: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                ProcAmpCap: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterPropertyRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                FilterSetting: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                FilterSetting: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateVideoProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                MaxNumSubStreams: u32,
                ppVidProcess: ?*?*IDirectXVideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessorService,
                VideoProcDeviceGuid: ?*const Guid,
                pVideoDesc: ?*const DXVA2_VideoDesc,
                RenderTargetFormat: D3DFORMAT,
                MaxNumSubStreams: u32,
                ppVidProcess: ?*?*IDirectXVideoProcessor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDirectXVideoAccelerationService.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_RegisterVideoProcessorSoftwareDevice(self: *const T, pCallbacks: ?*anyopaque) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).RegisterVideoProcessorSoftwareDevice(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), pCallbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_GetVideoProcessorDeviceGuids(self: *const T, pVideoDesc: ?*const DXVA2_VideoDesc, pCount: ?*u32, pGuids: ?*?*Guid) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).GetVideoProcessorDeviceGuids(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), pVideoDesc, pCount, pGuids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_GetVideoProcessorRenderTargets(self: *const T, VideoProcDeviceGuid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, pCount: ?*u32, pFormats: ?*?*D3DFORMAT) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).GetVideoProcessorRenderTargets(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), VideoProcDeviceGuid, pVideoDesc, pCount, pFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_GetVideoProcessorSubStreamFormats(self: *const T, VideoProcDeviceGuid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, pCount: ?*u32, pFormats: ?*?*D3DFORMAT) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).GetVideoProcessorSubStreamFormats(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, pCount, pFormats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_GetVideoProcessorCaps(self: *const T, VideoProcDeviceGuid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, pCaps: ?*DXVA2_VideoProcessorCaps) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).GetVideoProcessorCaps(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, pCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_GetProcAmpRange(self: *const T, VideoProcDeviceGuid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, ProcAmpCap: u32, pRange: ?*DXVA2_ValueRange) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).GetProcAmpRange(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, ProcAmpCap, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_GetFilterPropertyRange(self: *const T, VideoProcDeviceGuid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, FilterSetting: u32, pRange: ?*DXVA2_ValueRange) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).GetFilterPropertyRange(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, FilterSetting, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessorService_CreateVideoProcessor(self: *const T, VideoProcDeviceGuid: ?*const Guid, pVideoDesc: ?*const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, MaxNumSubStreams: u32, ppVidProcess: ?*?*IDirectXVideoProcessor) HRESULT {
                return @as(*const IDirectXVideoProcessorService.VTable, @ptrCast(self.vtable)).CreateVideoProcessor(@as(*const IDirectXVideoProcessorService, @ptrCast(self)), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, MaxNumSubStreams, ppVidProcess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirectXVideoDecoder_Value = Guid.initString("f2b0810a-fd00-43c9-918c-df94e2d8ef7d");
pub const IID_IDirectXVideoDecoder = &IID_IDirectXVideoDecoder_Value;
pub const IDirectXVideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoDecoderService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                ppService: ?*?*IDirectXVideoDecoderService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                ppService: ?*?*IDirectXVideoDecoderService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCreationParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                pDeviceGuid: ?*Guid,
                pVideoDesc: ?*DXVA2_VideoDesc,
                pConfig: ?*DXVA2_ConfigPictureDecode,
                pDecoderRenderTargets: [*]?*?*IDirect3DSurface9,
                pNumSurfaces: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                pDeviceGuid: ?*Guid,
                pVideoDesc: ?*DXVA2_VideoDesc,
                pConfig: ?*DXVA2_ConfigPictureDecode,
                pDecoderRenderTargets: [*]?*?*IDirect3DSurface9,
                pNumSurfaces: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                BufferType: DXVA2_BufferfType,
                ppBuffer: ?*?*anyopaque,
                pBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                BufferType: DXVA2_BufferfType,
                ppBuffer: ?*?*anyopaque,
                pBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                BufferType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                BufferType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                pRenderTarget: ?*IDirect3DSurface9,
                pvPVPData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                pRenderTarget: ?*IDirect3DSurface9,
                pvPVPData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                pHandleComplete: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                pHandleComplete: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoDecoder,
                pExecuteParams: ?*const DXVA2_DecodeExecuteParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoDecoder,
                pExecuteParams: ?*const DXVA2_DecodeExecuteParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_GetVideoDecoderService(self: *const T, ppService: ?*?*IDirectXVideoDecoderService) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).GetVideoDecoderService(@as(*const IDirectXVideoDecoder, @ptrCast(self)), ppService);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_GetCreationParameters(self: *const T, pDeviceGuid: ?*Guid, pVideoDesc: ?*DXVA2_VideoDesc, pConfig: ?*DXVA2_ConfigPictureDecode, pDecoderRenderTargets: [*]?*?*IDirect3DSurface9, pNumSurfaces: ?*u32) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).GetCreationParameters(@as(*const IDirectXVideoDecoder, @ptrCast(self)), pDeviceGuid, pVideoDesc, pConfig, pDecoderRenderTargets, pNumSurfaces);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_GetBuffer(self: *const T, BufferType: DXVA2_BufferfType, ppBuffer: ?*?*anyopaque, pBufferSize: ?*u32) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDirectXVideoDecoder, @ptrCast(self)), BufferType, ppBuffer, pBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_ReleaseBuffer(self: *const T, BufferType: u32) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IDirectXVideoDecoder, @ptrCast(self)), BufferType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_BeginFrame(self: *const T, pRenderTarget: ?*IDirect3DSurface9, pvPVPData: ?*anyopaque) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).BeginFrame(@as(*const IDirectXVideoDecoder, @ptrCast(self)), pRenderTarget, pvPVPData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_EndFrame(self: *const T, pHandleComplete: ?*?HANDLE) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).EndFrame(@as(*const IDirectXVideoDecoder, @ptrCast(self)), pHandleComplete);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoDecoder_Execute(self: *const T, pExecuteParams: ?*const DXVA2_DecodeExecuteParams) HRESULT {
                return @as(*const IDirectXVideoDecoder.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDirectXVideoDecoder, @ptrCast(self)), pExecuteParams);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirectXVideoProcessor_Value = Guid.initString("8c3a39f0-916e-4690-804f-4c8001355d25");
pub const IID_IDirectXVideoProcessor = &IID_IDirectXVideoProcessor_Value;
pub const IDirectXVideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoProcessorService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessor,
                ppService: ?*?*IDirectXVideoProcessorService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessor,
                ppService: ?*?*IDirectXVideoProcessorService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCreationParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessor,
                pDeviceGuid: ?*Guid,
                pVideoDesc: ?*DXVA2_VideoDesc,
                pRenderTargetFormat: ?*D3DFORMAT,
                pMaxNumSubStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessor,
                pDeviceGuid: ?*Guid,
                pVideoDesc: ?*DXVA2_VideoDesc,
                pRenderTargetFormat: ?*D3DFORMAT,
                pMaxNumSubStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessor,
                pCaps: ?*DXVA2_VideoProcessorCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessor,
                pCaps: ?*DXVA2_VideoProcessorCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAmpRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessor,
                ProcAmpCap: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessor,
                ProcAmpCap: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterPropertyRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessor,
                FilterSetting: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessor,
                FilterSetting: u32,
                pRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VideoProcessBlt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoProcessor,
                pRenderTarget: ?*IDirect3DSurface9,
                pBltParams: ?*const DXVA2_VideoProcessBltParams,
                pSamples: [*]const DXVA2_VideoSample,
                NumSamples: u32,
                pHandleComplete: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoProcessor,
                pRenderTarget: ?*IDirect3DSurface9,
                pBltParams: ?*const DXVA2_VideoProcessBltParams,
                pSamples: [*]const DXVA2_VideoSample,
                NumSamples: u32,
                pHandleComplete: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessor_GetVideoProcessorService(self: *const T, ppService: ?*?*IDirectXVideoProcessorService) HRESULT {
                return @as(*const IDirectXVideoProcessor.VTable, @ptrCast(self.vtable)).GetVideoProcessorService(@as(*const IDirectXVideoProcessor, @ptrCast(self)), ppService);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessor_GetCreationParameters(self: *const T, pDeviceGuid: ?*Guid, pVideoDesc: ?*DXVA2_VideoDesc, pRenderTargetFormat: ?*D3DFORMAT, pMaxNumSubStreams: ?*u32) HRESULT {
                return @as(*const IDirectXVideoProcessor.VTable, @ptrCast(self.vtable)).GetCreationParameters(@as(*const IDirectXVideoProcessor, @ptrCast(self)), pDeviceGuid, pVideoDesc, pRenderTargetFormat, pMaxNumSubStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessor_GetVideoProcessorCaps(self: *const T, pCaps: ?*DXVA2_VideoProcessorCaps) HRESULT {
                return @as(*const IDirectXVideoProcessor.VTable, @ptrCast(self.vtable)).GetVideoProcessorCaps(@as(*const IDirectXVideoProcessor, @ptrCast(self)), pCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessor_GetProcAmpRange(self: *const T, ProcAmpCap: u32, pRange: ?*DXVA2_ValueRange) HRESULT {
                return @as(*const IDirectXVideoProcessor.VTable, @ptrCast(self.vtable)).GetProcAmpRange(@as(*const IDirectXVideoProcessor, @ptrCast(self)), ProcAmpCap, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessor_GetFilterPropertyRange(self: *const T, FilterSetting: u32, pRange: ?*DXVA2_ValueRange) HRESULT {
                return @as(*const IDirectXVideoProcessor.VTable, @ptrCast(self.vtable)).GetFilterPropertyRange(@as(*const IDirectXVideoProcessor, @ptrCast(self)), FilterSetting, pRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoProcessor_VideoProcessBlt(self: *const T, pRenderTarget: ?*IDirect3DSurface9, pBltParams: ?*const DXVA2_VideoProcessBltParams, pSamples: [*]const DXVA2_VideoSample, NumSamples: u32, pHandleComplete: ?*?HANDLE) HRESULT {
                return @as(*const IDirectXVideoProcessor.VTable, @ptrCast(self.vtable)).VideoProcessBlt(@as(*const IDirectXVideoProcessor, @ptrCast(self)), pRenderTarget, pBltParams, pSamples, NumSamples, pHandleComplete);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DXVA2_SurfaceType = enum(i32) {
    DecoderRenderTarget = 0,
    ProcessorRenderTarget = 1,
    D3DRenderTargetTexture = 2,
};
pub const DXVA2_SurfaceType_DecoderRenderTarget = DXVA2_SurfaceType.DecoderRenderTarget;
pub const DXVA2_SurfaceType_ProcessorRenderTarget = DXVA2_SurfaceType.ProcessorRenderTarget;
pub const DXVA2_SurfaceType_D3DRenderTargetTexture = DXVA2_SurfaceType.D3DRenderTargetTexture;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDirectXVideoMemoryConfiguration_Value = Guid.initString("b7f916dd-db3b-49c1-84d7-e45ef99ec726");
pub const IID_IDirectXVideoMemoryConfiguration = &IID_IDirectXVideoMemoryConfiguration_Value;
pub const IDirectXVideoMemoryConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableSurfaceTypeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoMemoryConfiguration,
                dwTypeIndex: u32,
                pdwType: ?*DXVA2_SurfaceType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoMemoryConfiguration,
                dwTypeIndex: u32,
                pdwType: ?*DXVA2_SurfaceType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSurfaceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDirectXVideoMemoryConfiguration,
                dwType: DXVA2_SurfaceType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDirectXVideoMemoryConfiguration,
                dwType: DXVA2_SurfaceType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoMemoryConfiguration_GetAvailableSurfaceTypeByIndex(self: *const T, dwTypeIndex: u32, pdwType: ?*DXVA2_SurfaceType) HRESULT {
                return @as(*const IDirectXVideoMemoryConfiguration.VTable, @ptrCast(self.vtable)).GetAvailableSurfaceTypeByIndex(@as(*const IDirectXVideoMemoryConfiguration, @ptrCast(self)), dwTypeIndex, pdwType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDirectXVideoMemoryConfiguration_SetSurfaceType(self: *const T, dwType: DXVA2_SurfaceType) HRESULT {
                return @as(*const IDirectXVideoMemoryConfiguration.VTable, @ptrCast(self.vtable)).SetSurfaceType(@as(*const IDirectXVideoMemoryConfiguration, @ptrCast(self)), dwType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OPM_TYPE = enum(i32) {
    OMAC_SIZE = 16,
    // @"128_BIT_RANDOM_NUMBER_SIZE" = 16, this enum value conflicts with OMAC_SIZE
    ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE = 256,
    CONFIGURE_SETTING_DATA_SIZE = 4056,
    // GET_INFORMATION_PARAMETERS_SIZE = 4056, this enum value conflicts with CONFIGURE_SETTING_DATA_SIZE
    REQUESTED_INFORMATION_SIZE = 4076,
    HDCP_KEY_SELECTION_VECTOR_SIZE = 5,
    PROTECTION_TYPE_SIZE = 4,
    BUS_TYPE_MASK = 65535,
    BUS_IMPLEMENTATION_MODIFIER_MASK = 32767,
};
pub const OPM_OMAC_SIZE = OPM_TYPE.OMAC_SIZE;
pub const OPM_128_BIT_RANDOM_NUMBER_SIZE = OPM_TYPE.OMAC_SIZE;
pub const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE = OPM_TYPE.ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE;
pub const OPM_CONFIGURE_SETTING_DATA_SIZE = OPM_TYPE.CONFIGURE_SETTING_DATA_SIZE;
pub const OPM_GET_INFORMATION_PARAMETERS_SIZE = OPM_TYPE.CONFIGURE_SETTING_DATA_SIZE;
pub const OPM_REQUESTED_INFORMATION_SIZE = OPM_TYPE.REQUESTED_INFORMATION_SIZE;
pub const OPM_HDCP_KEY_SELECTION_VECTOR_SIZE = OPM_TYPE.HDCP_KEY_SELECTION_VECTOR_SIZE;
pub const OPM_PROTECTION_TYPE_SIZE = OPM_TYPE.PROTECTION_TYPE_SIZE;
pub const OPM_BUS_TYPE_MASK = OPM_TYPE.BUS_TYPE_MASK;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_MASK = OPM_TYPE.BUS_IMPLEMENTATION_MODIFIER_MASK;

pub const OPM_VIDEO_OUTPUT_SEMANTICS = enum(i32) {
    COPP_SEMANTICS = 0,
    OPM_SEMANTICS = 1,
    OPM_INDIRECT_DISPLAY = 2,
};
pub const OPM_VOS_COPP_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS.COPP_SEMANTICS;
pub const OPM_VOS_OPM_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS.OPM_SEMANTICS;
pub const OPM_VOS_OPM_INDIRECT_DISPLAY = OPM_VIDEO_OUTPUT_SEMANTICS.OPM_INDIRECT_DISPLAY;

pub const OPM_HDCP_FLAGS = enum(u32) {
    NONE = 0,
    REPEATER = 1,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        REPEATER: u1 = 0,
    }) OPM_HDCP_FLAGS {
        return @as(OPM_HDCP_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(OPM_HDCP_FLAGS.NONE) else 0) | (if (o.REPEATER == 1) @intFromEnum(OPM_HDCP_FLAGS.REPEATER) else 0)));
    }
};
pub const OPM_HDCP_FLAG_NONE = OPM_HDCP_FLAGS.NONE;
pub const OPM_HDCP_FLAG_REPEATER = OPM_HDCP_FLAGS.REPEATER;

pub const OPM_STATUS = enum(i32) {
    NORMAL = 0,
    LINK_LOST = 1,
    RENEGOTIATION_REQUIRED = 2,
    TAMPERING_DETECTED = 4,
    REVOKED_HDCP_DEVICE_ATTACHED = 8,
};
pub const OPM_STATUS_NORMAL = OPM_STATUS.NORMAL;
pub const OPM_STATUS_LINK_LOST = OPM_STATUS.LINK_LOST;
pub const OPM_STATUS_RENEGOTIATION_REQUIRED = OPM_STATUS.RENEGOTIATION_REQUIRED;
pub const OPM_STATUS_TAMPERING_DETECTED = OPM_STATUS.TAMPERING_DETECTED;
pub const OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED = OPM_STATUS.REVOKED_HDCP_DEVICE_ATTACHED;

pub const PM_CONNECTOR_TYPE = enum(i32) {
    NNECTOR_TYPE_OTHER = -1,
    NNECTOR_TYPE_VGA = 0,
    NNECTOR_TYPE_SVIDEO = 1,
    NNECTOR_TYPE_COMPOSITE_VIDEO = 2,
    NNECTOR_TYPE_COMPONENT_VIDEO = 3,
    NNECTOR_TYPE_DVI = 4,
    NNECTOR_TYPE_HDMI = 5,
    NNECTOR_TYPE_LVDS = 6,
    NNECTOR_TYPE_D_JPN = 8,
    NNECTOR_TYPE_SDI = 9,
    NNECTOR_TYPE_DISPLAYPORT_EXTERNAL = 10,
    NNECTOR_TYPE_DISPLAYPORT_EMBEDDED = 11,
    NNECTOR_TYPE_UDI_EXTERNAL = 12,
    NNECTOR_TYPE_UDI_EMBEDDED = 13,
    NNECTOR_TYPE_RESERVED = 14,
    NNECTOR_TYPE_MIRACAST = 15,
    NNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = 16,
    NNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = 17,
    PP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL = -2147483648,
};
pub const OPM_CONNECTOR_TYPE_OTHER = PM_CONNECTOR_TYPE.NNECTOR_TYPE_OTHER;
pub const OPM_CONNECTOR_TYPE_VGA = PM_CONNECTOR_TYPE.NNECTOR_TYPE_VGA;
pub const OPM_CONNECTOR_TYPE_SVIDEO = PM_CONNECTOR_TYPE.NNECTOR_TYPE_SVIDEO;
pub const OPM_CONNECTOR_TYPE_COMPOSITE_VIDEO = PM_CONNECTOR_TYPE.NNECTOR_TYPE_COMPOSITE_VIDEO;
pub const OPM_CONNECTOR_TYPE_COMPONENT_VIDEO = PM_CONNECTOR_TYPE.NNECTOR_TYPE_COMPONENT_VIDEO;
pub const OPM_CONNECTOR_TYPE_DVI = PM_CONNECTOR_TYPE.NNECTOR_TYPE_DVI;
pub const OPM_CONNECTOR_TYPE_HDMI = PM_CONNECTOR_TYPE.NNECTOR_TYPE_HDMI;
pub const OPM_CONNECTOR_TYPE_LVDS = PM_CONNECTOR_TYPE.NNECTOR_TYPE_LVDS;
pub const OPM_CONNECTOR_TYPE_D_JPN = PM_CONNECTOR_TYPE.NNECTOR_TYPE_D_JPN;
pub const OPM_CONNECTOR_TYPE_SDI = PM_CONNECTOR_TYPE.NNECTOR_TYPE_SDI;
pub const OPM_CONNECTOR_TYPE_DISPLAYPORT_EXTERNAL = PM_CONNECTOR_TYPE.NNECTOR_TYPE_DISPLAYPORT_EXTERNAL;
pub const OPM_CONNECTOR_TYPE_DISPLAYPORT_EMBEDDED = PM_CONNECTOR_TYPE.NNECTOR_TYPE_DISPLAYPORT_EMBEDDED;
pub const OPM_CONNECTOR_TYPE_UDI_EXTERNAL = PM_CONNECTOR_TYPE.NNECTOR_TYPE_UDI_EXTERNAL;
pub const OPM_CONNECTOR_TYPE_UDI_EMBEDDED = PM_CONNECTOR_TYPE.NNECTOR_TYPE_UDI_EMBEDDED;
pub const OPM_CONNECTOR_TYPE_RESERVED = PM_CONNECTOR_TYPE.NNECTOR_TYPE_RESERVED;
pub const OPM_CONNECTOR_TYPE_MIRACAST = PM_CONNECTOR_TYPE.NNECTOR_TYPE_MIRACAST;
pub const OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = PM_CONNECTOR_TYPE.NNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A;
pub const OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = PM_CONNECTOR_TYPE.NNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B;
pub const OPM_COPP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL = PM_CONNECTOR_TYPE.PP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL;

pub const OPM_DVI_CHARACTERISTIC = enum(i32) {
    @"0" = 1,
    @"1_OR_ABOVE" = 2,
};
pub const OPM_DVI_CHARACTERISTIC_1_0 = OPM_DVI_CHARACTERISTIC.@"0";
pub const OPM_DVI_CHARACTERISTIC_1_1_OR_ABOVE = OPM_DVI_CHARACTERISTIC.@"1_OR_ABOVE";

pub const OPM_OUTPUT_HARDWARE_PROTECTION = enum(i32) {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1,
};
pub const OPM_OUTPUT_HARDWARE_PROTECTION_NOT_SUPPORTED = OPM_OUTPUT_HARDWARE_PROTECTION.NOT_SUPPORTED;
pub const OPM_OUTPUT_HARDWARE_PROTECTION_SUPPORTED = OPM_OUTPUT_HARDWARE_PROTECTION.SUPPORTED;

pub const OPM_BUS_TYPE = enum(i32) {
    BUS_TYPE_OTHER = 0,
    BUS_TYPE_PCI = 1,
    BUS_TYPE_PCIX = 2,
    BUS_TYPE_PCIEXPRESS = 3,
    BUS_TYPE_AGP = 4,
    BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET = 65536,
    BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = 131072,
    BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 196608,
    BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR = 262144,
    BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 327680,
    BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD = -2147483648,
    // COPP_COMPATIBLE_BUS_TYPE_INTEGRATED = -2147483648, this enum value conflicts with BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD
};
pub const OPM_BUS_TYPE_OTHER = OPM_BUS_TYPE.BUS_TYPE_OTHER;
pub const OPM_BUS_TYPE_PCI = OPM_BUS_TYPE.BUS_TYPE_PCI;
pub const OPM_BUS_TYPE_PCIX = OPM_BUS_TYPE.BUS_TYPE_PCIX;
pub const OPM_BUS_TYPE_PCIEXPRESS = OPM_BUS_TYPE.BUS_TYPE_PCIEXPRESS;
pub const OPM_BUS_TYPE_AGP = OPM_BUS_TYPE.BUS_TYPE_AGP;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD;
pub const OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED = OPM_BUS_TYPE.BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD;

pub const OPM_DPCP_PROTECTION_LEVEL = enum(i32) {
    OFF = 0,
    ON = 1,
    FORCE_ULONG = 2147483647,
};
pub const OPM_DPCP_OFF = OPM_DPCP_PROTECTION_LEVEL.OFF;
pub const OPM_DPCP_ON = OPM_DPCP_PROTECTION_LEVEL.ON;
pub const OPM_DPCP_FORCE_ULONG = OPM_DPCP_PROTECTION_LEVEL.FORCE_ULONG;

pub const OPM_HDCP_PROTECTION_LEVEL = enum(i32) {
    OFF = 0,
    ON = 1,
    FORCE_ULONG = 2147483647,
};
pub const OPM_HDCP_OFF = OPM_HDCP_PROTECTION_LEVEL.OFF;
pub const OPM_HDCP_ON = OPM_HDCP_PROTECTION_LEVEL.ON;
pub const OPM_HDCP_FORCE_ULONG = OPM_HDCP_PROTECTION_LEVEL.FORCE_ULONG;

pub const OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = enum(i32) {
    OFF = 0,
    ON_WITH_NO_TYPE_RESTRICTION = 1,
    ON_WITH_TYPE1_RESTRICTION = 2,
    FORCE_ULONG = 2147483647,
};
pub const OPM_TYPE_ENFORCEMENT_HDCP_OFF = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.OFF;
pub const OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_NO_TYPE_RESTRICTION = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.ON_WITH_NO_TYPE_RESTRICTION;
pub const OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_TYPE1_RESTRICTION = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.ON_WITH_TYPE1_RESTRICTION;
pub const OPM_TYPE_ENFORCEMENT_HDCP_FORCE_ULONG = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.FORCE_ULONG;

pub const OPM_CGMSA = enum(i32) {
    OFF = 0,
    COPY_FREELY = 1,
    COPY_NO_MORE = 2,
    COPY_ONE_GENERATION = 3,
    COPY_NEVER = 4,
    REDISTRIBUTION_CONTROL_REQUIRED = 8,
};
pub const OPM_CGMSA_OFF = OPM_CGMSA.OFF;
pub const OPM_CGMSA_COPY_FREELY = OPM_CGMSA.COPY_FREELY;
pub const OPM_CGMSA_COPY_NO_MORE = OPM_CGMSA.COPY_NO_MORE;
pub const OPM_CGMSA_COPY_ONE_GENERATION = OPM_CGMSA.COPY_ONE_GENERATION;
pub const OPM_CGMSA_COPY_NEVER = OPM_CGMSA.COPY_NEVER;
pub const OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = OPM_CGMSA.REDISTRIBUTION_CONTROL_REQUIRED;

pub const OPM_ACP_PROTECTION_LEVEL = enum(i32) {
    OFF = 0,
    LEVEL_ONE = 1,
    LEVEL_TWO = 2,
    LEVEL_THREE = 3,
    FORCE_ULONG = 2147483647,
};
pub const OPM_ACP_OFF = OPM_ACP_PROTECTION_LEVEL.OFF;
pub const OPM_ACP_LEVEL_ONE = OPM_ACP_PROTECTION_LEVEL.LEVEL_ONE;
pub const OPM_ACP_LEVEL_TWO = OPM_ACP_PROTECTION_LEVEL.LEVEL_TWO;
pub const OPM_ACP_LEVEL_THREE = OPM_ACP_PROTECTION_LEVEL.LEVEL_THREE;
pub const OPM_ACP_FORCE_ULONG = OPM_ACP_PROTECTION_LEVEL.FORCE_ULONG;

pub const OPM_PROTECTION_TYPE = enum(i32) {
    OTHER = -2147483648,
    NONE = 0,
    COPP_COMPATIBLE_HDCP = 1,
    ACP = 2,
    CGMSA = 4,
    HDCP = 8,
    DPCP = 16,
    TYPE_ENFORCEMENT_HDCP = 32,
};
pub const OPM_PROTECTION_TYPE_OTHER = OPM_PROTECTION_TYPE.OTHER;
pub const OPM_PROTECTION_TYPE_NONE = OPM_PROTECTION_TYPE.NONE;
pub const OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP = OPM_PROTECTION_TYPE.COPP_COMPATIBLE_HDCP;
pub const OPM_PROTECTION_TYPE_ACP = OPM_PROTECTION_TYPE.ACP;
pub const OPM_PROTECTION_TYPE_CGMSA = OPM_PROTECTION_TYPE.CGMSA;
pub const OPM_PROTECTION_TYPE_HDCP = OPM_PROTECTION_TYPE.HDCP;
pub const OPM_PROTECTION_TYPE_DPCP = OPM_PROTECTION_TYPE.DPCP;
pub const OPM_PROTECTION_TYPE_TYPE_ENFORCEMENT_HDCP = OPM_PROTECTION_TYPE.TYPE_ENFORCEMENT_HDCP;

pub const OPM_PROTECTION_STANDARD_TYPE = enum(u32) {
    OTHER = 2147483648,
    NONE = 0,
    IEC61880_525I = 1,
    IEC61880_2_525I = 2,
    IEC62375_625P = 4,
    EIA608B_525 = 8,
    EN300294_625I = 16,
    CEA805A_TYPEA_525P = 32,
    CEA805A_TYPEA_750P = 64,
    CEA805A_TYPEA_1125I = 128,
    CEA805A_TYPEB_525P = 256,
    CEA805A_TYPEB_750P = 512,
    CEA805A_TYPEB_1125I = 1024,
    ARIBTRB15_525I = 2048,
    ARIBTRB15_525P = 4096,
    ARIBTRB15_750P = 8192,
    ARIBTRB15_1125I = 16384,
};
pub const OPM_PROTECTION_STANDARD_OTHER = OPM_PROTECTION_STANDARD_TYPE.OTHER;
pub const OPM_PROTECTION_STANDARD_NONE = OPM_PROTECTION_STANDARD_TYPE.NONE;
pub const OPM_PROTECTION_STANDARD_IEC61880_525I = OPM_PROTECTION_STANDARD_TYPE.IEC61880_525I;
pub const OPM_PROTECTION_STANDARD_IEC61880_2_525I = OPM_PROTECTION_STANDARD_TYPE.IEC61880_2_525I;
pub const OPM_PROTECTION_STANDARD_IEC62375_625P = OPM_PROTECTION_STANDARD_TYPE.IEC62375_625P;
pub const OPM_PROTECTION_STANDARD_EIA608B_525 = OPM_PROTECTION_STANDARD_TYPE.EIA608B_525;
pub const OPM_PROTECTION_STANDARD_EN300294_625I = OPM_PROTECTION_STANDARD_TYPE.EN300294_625I;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P = OPM_PROTECTION_STANDARD_TYPE.CEA805A_TYPEA_525P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P = OPM_PROTECTION_STANDARD_TYPE.CEA805A_TYPEA_750P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I = OPM_PROTECTION_STANDARD_TYPE.CEA805A_TYPEA_1125I;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P = OPM_PROTECTION_STANDARD_TYPE.CEA805A_TYPEB_525P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P = OPM_PROTECTION_STANDARD_TYPE.CEA805A_TYPEB_750P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I = OPM_PROTECTION_STANDARD_TYPE.CEA805A_TYPEB_1125I;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_525I = OPM_PROTECTION_STANDARD_TYPE.ARIBTRB15_525I;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_525P = OPM_PROTECTION_STANDARD_TYPE.ARIBTRB15_525P;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_750P = OPM_PROTECTION_STANDARD_TYPE.ARIBTRB15_750P;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_1125I = OPM_PROTECTION_STANDARD_TYPE.ARIBTRB15_1125I;

pub const OPM_IMAGE_ASPECT_RATIO_EN300294 = enum(i32) {
    EN300294_FULL_FORMAT_4_BY_3 = 0,
    EN300294_BOX_14_BY_9_CENTER = 1,
    EN300294_BOX_14_BY_9_TOP = 2,
    EN300294_BOX_16_BY_9_CENTER = 3,
    EN300294_BOX_16_BY_9_TOP = 4,
    EN300294_BOX_GT_16_BY_9_CENTER = 5,
    EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER = 6,
    EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC = 7,
    FORCE_ULONG = 2147483647,
};
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3 = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_FULL_FORMAT_4_BY_3;
pub const OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_BOX_14_BY_9_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_BOX_14_BY_9_TOP;
pub const OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_BOX_16_BY_9_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_BOX_16_BY_9_TOP;
pub const OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_BOX_GT_16_BY_9_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC = OPM_IMAGE_ASPECT_RATIO_EN300294.EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC;
pub const OPM_ASPECT_RATIO_FORCE_ULONG = OPM_IMAGE_ASPECT_RATIO_EN300294.FORCE_ULONG;

pub const OPM_RANDOM_NUMBER = extern struct {
    abRandomNumber: [16]u8,
};

pub const OPM_OMAC = extern struct {
    abOMAC: [16]u8,
};

pub const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS = extern struct {
    abEncryptedInitializationParameters: [256]u8,
};

pub const OPM_GET_INFO_PARAMETERS = extern struct {
    omac: OPM_OMAC align(1),
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    guidInformation: Guid align(1),
    ulSequenceNumber: u32 align(1),
    cbParametersSize: u32 align(1),
    abParameters: [4056]u8 align(1),
};

pub const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    guidInformation: Guid align(1),
    ulSequenceNumber: u32 align(1),
    cbParametersSize: u32 align(1),
    abParameters: [4056]u8 align(1),
};

pub const OPM_HDCP_KEY_SELECTION_VECTOR = extern struct {
    abKeySelectionVector: [5]u8,
};

pub const OPM_CONNECTED_HDCP_DEVICE_INFORMATION = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    ulStatusFlags: u32 align(1),
    ulHDCPFlags: u32 align(1),
    ksvB: OPM_HDCP_KEY_SELECTION_VECTOR align(1),
    Reserved: [11]u8 align(1),
    Reserved2: [16]u8 align(1),
    Reserved3: [16]u8 align(1),
};

pub const OPM_REQUESTED_INFORMATION = extern struct {
    omac: OPM_OMAC align(1),
    cbRequestedInformationSize: u32 align(1),
    abRequestedInformation: [4076]u8 align(1),
};

pub const OPM_STANDARD_INFORMATION = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    ulStatusFlags: u32 align(1),
    ulInformation: u32 align(1),
    ulReserved: u32 align(1),
    ulReserved2: u32 align(1),
};

pub const OPM_ACTUAL_OUTPUT_FORMAT = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    ulStatusFlags: u32 align(1),
    ulDisplayWidth: u32 align(1),
    ulDisplayHeight: u32 align(1),
    dsfSampleInterleaveFormat: DXVA2_SampleFormat align(1),
    d3dFormat: D3DFORMAT align(1),
    ulFrequencyNumerator: u32 align(1),
    ulFrequencyDenominator: u32 align(1),
};

pub const OPM_ACP_AND_CGMSA_SIGNALING = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    ulStatusFlags: u32 align(1),
    ulAvailableTVProtectionStandards: u32 align(1),
    ulActiveTVProtectionStandard: u32 align(1),
    ulReserved: u32 align(1),
    ulAspectRatioValidMask1: u32 align(1),
    ulAspectRatioData1: u32 align(1),
    ulAspectRatioValidMask2: u32 align(1),
    ulAspectRatioData2: u32 align(1),
    ulAspectRatioValidMask3: u32 align(1),
    ulAspectRatioData3: u32 align(1),
    ulReserved2: [4]u32 align(1),
    ulReserved3: [4]u32 align(1),
};

pub const OPM_OUTPUT_ID_DATA = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    ulStatusFlags: u32 align(1),
    OutputId: u64 align(1),
};

pub const OPM_CONFIGURE_PARAMETERS = extern struct {
    omac: OPM_OMAC align(1),
    guidSetting: Guid align(1),
    ulSequenceNumber: u32 align(1),
    cbParametersSize: u32 align(1),
    abParameters: [4056]u8 align(1),
};

pub const OPM_SET_PROTECTION_LEVEL_PARAMETERS = extern struct {
    ulProtectionType: u32 align(1),
    ulProtectionLevel: u32 align(1),
    Reserved: u32 align(1),
    Reserved2: u32 align(1),
};

pub const OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS = extern struct {
    ulNewTVProtectionStandard: u32 align(1),
    ulAspectRatioChangeMask1: u32 align(1),
    ulAspectRatioData1: u32 align(1),
    ulAspectRatioChangeMask2: u32 align(1),
    ulAspectRatioData2: u32 align(1),
    ulAspectRatioChangeMask3: u32 align(1),
    ulAspectRatioData3: u32 align(1),
    ulReserved: [4]u32 align(1),
    ulReserved2: [4]u32 align(1),
    ulReserved3: u32 align(1),
};

pub const OPM_SET_HDCP_SRM_PARAMETERS = extern struct {
    ulSRMVersion: u32 align(1),
};

pub const OPM_GET_CODEC_INFO_PARAMETERS = extern struct {
    cbVerifier: u32 align(1),
    Verifier: [4052]u8 align(1),
};

pub const OPM_GET_CODEC_INFO_INFORMATION = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER align(1),
    Merit: u32 align(1),
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IOPMVideoOutput_Value = Guid.initString("0a15159d-41c7-4456-93e1-284cd61d4e8d");
pub const IID_IOPMVideoOutput = &IID_IOPMVideoOutput_Value;
pub const IOPMVideoOutput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartInitialization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOPMVideoOutput,
                prnRandomNumber: ?*OPM_RANDOM_NUMBER,
                ppbCertificate: ?*?*u8,
                pulCertificateLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOPMVideoOutput,
                prnRandomNumber: ?*OPM_RANDOM_NUMBER,
                ppbCertificate: ?*?*u8,
                pulCertificateLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishInitialization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_GET_INFO_PARAMETERS,
                pRequestedInformation: ?*OPM_REQUESTED_INFORMATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_GET_INFO_PARAMETERS,
                pRequestedInformation: ?*OPM_REQUESTED_INFORMATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        COPPCompatibleGetInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS,
                pRequestedInformation: ?*OPM_REQUESTED_INFORMATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS,
                pRequestedInformation: ?*OPM_REQUESTED_INFORMATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Configure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_CONFIGURE_PARAMETERS,
                ulAdditionalParametersSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pbAdditionalParameters: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOPMVideoOutput,
                pParameters: ?*const OPM_CONFIGURE_PARAMETERS,
                ulAdditionalParametersSize: u32,
                // TODO: what to do with BytesParamIndex 1?
                pbAdditionalParameters: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOPMVideoOutput_StartInitialization(self: *const T, prnRandomNumber: ?*OPM_RANDOM_NUMBER, ppbCertificate: ?*?*u8, pulCertificateLength: ?*u32) HRESULT {
                return @as(*const IOPMVideoOutput.VTable, @ptrCast(self.vtable)).StartInitialization(@as(*const IOPMVideoOutput, @ptrCast(self)), prnRandomNumber, ppbCertificate, pulCertificateLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOPMVideoOutput_FinishInitialization(self: *const T, pParameters: ?*const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) HRESULT {
                return @as(*const IOPMVideoOutput.VTable, @ptrCast(self.vtable)).FinishInitialization(@as(*const IOPMVideoOutput, @ptrCast(self)), pParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOPMVideoOutput_GetInformation(self: *const T, pParameters: ?*const OPM_GET_INFO_PARAMETERS, pRequestedInformation: ?*OPM_REQUESTED_INFORMATION) HRESULT {
                return @as(*const IOPMVideoOutput.VTable, @ptrCast(self.vtable)).GetInformation(@as(*const IOPMVideoOutput, @ptrCast(self)), pParameters, pRequestedInformation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOPMVideoOutput_COPPCompatibleGetInformation(self: *const T, pParameters: ?*const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, pRequestedInformation: ?*OPM_REQUESTED_INFORMATION) HRESULT {
                return @as(*const IOPMVideoOutput.VTable, @ptrCast(self.vtable)).COPPCompatibleGetInformation(@as(*const IOPMVideoOutput, @ptrCast(self)), pParameters, pRequestedInformation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOPMVideoOutput_Configure(self: *const T, pParameters: ?*const OPM_CONFIGURE_PARAMETERS, ulAdditionalParametersSize: u32, pbAdditionalParameters: ?*const u8) HRESULT {
                return @as(*const IOPMVideoOutput.VTable, @ptrCast(self.vtable)).Configure(@as(*const IOPMVideoOutput, @ptrCast(self)), pParameters, ulAdditionalParametersSize, pbAdditionalParameters);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_KSPROPSETID_OPMVideoOutput_Value = Guid.initString("06f414bb-f43a-4fe2-a566-774b4c81f0db");
pub const CLSID_KSPROPSETID_OPMVideoOutput = &CLSID_KSPROPSETID_OPMVideoOutput_Value;

pub const KSMETHOD_OPMVIDEOOUTPUT = enum(i32) {
    STARTINITIALIZATION = 0,
    FINISHINITIALIZATION = 1,
    GETINFORMATION = 2,
};
pub const KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION = KSMETHOD_OPMVIDEOOUTPUT.STARTINITIALIZATION;
pub const KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION = KSMETHOD_OPMVIDEOOUTPUT.FINISHINITIALIZATION;
pub const KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION = KSMETHOD_OPMVIDEOOUTPUT.GETINFORMATION;

pub const MF_ATTRIBUTE_TYPE = enum(i32) {
    UINT32 = 19,
    UINT64 = 21,
    DOUBLE = 5,
    GUID = 72,
    STRING = 31,
    BLOB = 4113,
    IUNKNOWN = 13,
};
pub const MF_ATTRIBUTE_UINT32 = MF_ATTRIBUTE_TYPE.UINT32;
pub const MF_ATTRIBUTE_UINT64 = MF_ATTRIBUTE_TYPE.UINT64;
pub const MF_ATTRIBUTE_DOUBLE = MF_ATTRIBUTE_TYPE.DOUBLE;
pub const MF_ATTRIBUTE_GUID = MF_ATTRIBUTE_TYPE.GUID;
pub const MF_ATTRIBUTE_STRING = MF_ATTRIBUTE_TYPE.STRING;
pub const MF_ATTRIBUTE_BLOB = MF_ATTRIBUTE_TYPE.BLOB;
pub const MF_ATTRIBUTE_IUNKNOWN = MF_ATTRIBUTE_TYPE.IUNKNOWN;

pub const MF_ATTRIBUTES_MATCH_TYPE = enum(i32) {
    OUR_ITEMS = 0,
    THEIR_ITEMS = 1,
    ALL_ITEMS = 2,
    INTERSECTION = 3,
    SMALLER = 4,
};
pub const MF_ATTRIBUTES_MATCH_OUR_ITEMS = MF_ATTRIBUTES_MATCH_TYPE.OUR_ITEMS;
pub const MF_ATTRIBUTES_MATCH_THEIR_ITEMS = MF_ATTRIBUTES_MATCH_TYPE.THEIR_ITEMS;
pub const MF_ATTRIBUTES_MATCH_ALL_ITEMS = MF_ATTRIBUTES_MATCH_TYPE.ALL_ITEMS;
pub const MF_ATTRIBUTES_MATCH_INTERSECTION = MF_ATTRIBUTES_MATCH_TYPE.INTERSECTION;
pub const MF_ATTRIBUTES_MATCH_SMALLER = MF_ATTRIBUTES_MATCH_TYPE.SMALLER;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFAttributes_Value = Guid.initString("2cd2d921-c447-44a7-a13c-4adabfc247e3");
pub const IID_IMFAttributes = &IID_IMFAttributes_Value;
pub const IMFAttributes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pType: ?*MF_ATTRIBUTE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pType: ?*MF_ATTRIBUTE_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                Value: ?*const PROPVARIANT,
                pbResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                Value: ?*const PROPVARIANT,
                pbResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                pTheirs: ?*IMFAttributes,
                MatchType: MF_ATTRIBUTES_MATCH_TYPE,
                pbResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                pTheirs: ?*IMFAttributes,
                MatchType: MF_ATTRIBUTES_MATCH_TYPE,
                pbResult: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUINT32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                punValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                punValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUINT64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                punValue: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                punValue: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDouble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pfValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pfValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pguidValue: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pguidValue: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pwszValue: [*:0]u16,
                cchBufSize: u32,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pwszValue: [*:0]u16,
                cchBufSize: u32,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocatedString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                ppwszValue: ?*?PWSTR,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                ppwszValue: ?*?PWSTR,
                pcchLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBlobSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pcbBlobSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pcbBlobSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pBuf: [*:0]u8,
                cbBufSize: u32,
                pcbBlobSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pBuf: [*:0]u8,
                cbBufSize: u32,
                pcbBlobSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocatedBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                ppBuf: [*]?*u8,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                ppBuf: [*]?*u8,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUnknown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                Value: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                Value: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteAllItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUINT32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                unValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                unValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUINT64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                unValue: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                unValue: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDouble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                fValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                fValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                guidValue: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                guidValue: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                wszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                wszValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pBuf: [*:0]const u8,
                cbBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pBuf: [*:0]const u8,
                cbBufSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnknown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                guidKey: ?*const Guid,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                pcItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                pcItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                unIndex: u32,
                pguidKey: ?*Guid,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                unIndex: u32,
                pguidKey: ?*Guid,
                pValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyAllItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAttributes,
                pDest: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAttributes,
                pDest: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetItem(self: *const T, guidKey: ?*const Guid, pValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetItemType(self: *const T, guidKey: ?*const Guid, pType: ?*MF_ATTRIBUTE_TYPE) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetItemType(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_CompareItem(self: *const T, guidKey: ?*const Guid, Value: ?*const PROPVARIANT, pbResult: ?*BOOL) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).CompareItem(@as(*const IMFAttributes, @ptrCast(self)), guidKey, Value, pbResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_Compare(self: *const T, pTheirs: ?*IMFAttributes, MatchType: MF_ATTRIBUTES_MATCH_TYPE, pbResult: ?*BOOL) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).Compare(@as(*const IMFAttributes, @ptrCast(self)), pTheirs, MatchType, pbResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetUINT32(self: *const T, guidKey: ?*const Guid, punValue: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetUINT32(@as(*const IMFAttributes, @ptrCast(self)), guidKey, punValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetUINT64(self: *const T, guidKey: ?*const Guid, punValue: ?*u64) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetUINT64(@as(*const IMFAttributes, @ptrCast(self)), guidKey, punValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetDouble(self: *const T, guidKey: ?*const Guid, pfValue: ?*f64) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetDouble(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pfValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetGUID(self: *const T, guidKey: ?*const Guid, pguidValue: ?*Guid) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pguidValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetStringLength(self: *const T, guidKey: ?*const Guid, pcchLength: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetStringLength(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pcchLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetString(self: *const T, guidKey: ?*const Guid, pwszValue: [*:0]u16, cchBufSize: u32, pcchLength: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetString(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pwszValue, cchBufSize, pcchLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetAllocatedString(self: *const T, guidKey: ?*const Guid, ppwszValue: ?*?PWSTR, pcchLength: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetAllocatedString(@as(*const IMFAttributes, @ptrCast(self)), guidKey, ppwszValue, pcchLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetBlobSize(self: *const T, guidKey: ?*const Guid, pcbBlobSize: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetBlobSize(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pcbBlobSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetBlob(self: *const T, guidKey: ?*const Guid, pBuf: [*:0]u8, cbBufSize: u32, pcbBlobSize: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetBlob(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pBuf, cbBufSize, pcbBlobSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetAllocatedBlob(self: *const T, guidKey: ?*const Guid, ppBuf: [*]?*u8, pcbSize: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetAllocatedBlob(@as(*const IMFAttributes, @ptrCast(self)), guidKey, ppBuf, pcbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetUnknown(self: *const T, guidKey: ?*const Guid, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetUnknown(@as(*const IMFAttributes, @ptrCast(self)), guidKey, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetItem(self: *const T, guidKey: ?*const Guid, Value: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetItem(@as(*const IMFAttributes, @ptrCast(self)), guidKey, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_DeleteItem(self: *const T, guidKey: ?*const Guid) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).DeleteItem(@as(*const IMFAttributes, @ptrCast(self)), guidKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_DeleteAllItems(self: *const T) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).DeleteAllItems(@as(*const IMFAttributes, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetUINT32(self: *const T, guidKey: ?*const Guid, unValue: u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetUINT32(@as(*const IMFAttributes, @ptrCast(self)), guidKey, unValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetUINT64(self: *const T, guidKey: ?*const Guid, unValue: u64) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetUINT64(@as(*const IMFAttributes, @ptrCast(self)), guidKey, unValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetDouble(self: *const T, guidKey: ?*const Guid, fValue: f64) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetDouble(@as(*const IMFAttributes, @ptrCast(self)), guidKey, fValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetGUID(self: *const T, guidKey: ?*const Guid, guidValue: ?*const Guid) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetGUID(@as(*const IMFAttributes, @ptrCast(self)), guidKey, guidValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetString(self: *const T, guidKey: ?*const Guid, wszValue: ?[*:0]const u16) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetString(@as(*const IMFAttributes, @ptrCast(self)), guidKey, wszValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetBlob(self: *const T, guidKey: ?*const Guid, pBuf: [*:0]const u8, cbBufSize: u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetBlob(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pBuf, cbBufSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_SetUnknown(self: *const T, guidKey: ?*const Guid, pUnknown: ?*IUnknown) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).SetUnknown(@as(*const IMFAttributes, @ptrCast(self)), guidKey, pUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_LockStore(self: *const T) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).LockStore(@as(*const IMFAttributes, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_UnlockStore(self: *const T) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).UnlockStore(@as(*const IMFAttributes, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetCount(self: *const T, pcItems: ?*u32) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IMFAttributes, @ptrCast(self)), pcItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_GetItemByIndex(self: *const T, unIndex: u32, pguidKey: ?*Guid, pValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).GetItemByIndex(@as(*const IMFAttributes, @ptrCast(self)), unIndex, pguidKey, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAttributes_CopyAllItems(self: *const T, pDest: ?*IMFAttributes) HRESULT {
                return @as(*const IMFAttributes.VTable, @ptrCast(self.vtable)).CopyAllItems(@as(*const IMFAttributes, @ptrCast(self)), pDest);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_ATTRIBUTE_SERIALIZE_OPTIONS = enum(i32) {
    F = 1,
};
pub const MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF = MF_ATTRIBUTE_SERIALIZE_OPTIONS.F;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaBuffer_Value = Guid.initString("045fa593-8799-42b8-bc8d-8968c6453507");
pub const IID_IMFMediaBuffer = &IID_IMFMediaBuffer_Value;
pub const IMFMediaBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaBuffer,
                // TODO: what to do with BytesParamIndex 2?
                ppbBuffer: ?*?*u8,
                pcbMaxLength: ?*u32,
                pcbCurrentLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaBuffer,
                // TODO: what to do with BytesParamIndex 2?
                ppbBuffer: ?*?*u8,
                pcbMaxLength: ?*u32,
                pcbCurrentLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaBuffer,
                pcbCurrentLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaBuffer,
                pcbCurrentLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaBuffer,
                cbCurrentLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaBuffer,
                cbCurrentLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaBuffer,
                pcbMaxLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaBuffer,
                pcbMaxLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaBuffer_Lock(self: *const T, ppbBuffer: ?*?*u8, pcbMaxLength: ?*u32, pcbCurrentLength: ?*u32) HRESULT {
                return @as(*const IMFMediaBuffer.VTable, @ptrCast(self.vtable)).Lock(@as(*const IMFMediaBuffer, @ptrCast(self)), ppbBuffer, pcbMaxLength, pcbCurrentLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaBuffer_Unlock(self: *const T) HRESULT {
                return @as(*const IMFMediaBuffer.VTable, @ptrCast(self.vtable)).Unlock(@as(*const IMFMediaBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaBuffer_GetCurrentLength(self: *const T, pcbCurrentLength: ?*u32) HRESULT {
                return @as(*const IMFMediaBuffer.VTable, @ptrCast(self.vtable)).GetCurrentLength(@as(*const IMFMediaBuffer, @ptrCast(self)), pcbCurrentLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaBuffer_SetCurrentLength(self: *const T, cbCurrentLength: u32) HRESULT {
                return @as(*const IMFMediaBuffer.VTable, @ptrCast(self.vtable)).SetCurrentLength(@as(*const IMFMediaBuffer, @ptrCast(self)), cbCurrentLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaBuffer_GetMaxLength(self: *const T, pcbMaxLength: ?*u32) HRESULT {
                return @as(*const IMFMediaBuffer.VTable, @ptrCast(self.vtable)).GetMaxLength(@as(*const IMFMediaBuffer, @ptrCast(self)), pcbMaxLength);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSample_Value = Guid.initString("c40a00f2-b93a-4d80-ae8c-5a1c634f58e4");
pub const IID_IMFSample = &IID_IMFSample_Value;
pub const IMFSample = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetSampleFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                pdwSampleFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                pdwSampleFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                dwSampleFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                dwSampleFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSampleTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                phnsSampleTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                phnsSampleTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                hnsSampleTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                hnsSampleTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSampleDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                phnsSampleDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                phnsSampleDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                hnsSampleDuration: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                hnsSampleDuration: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                pdwBufferCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                pdwBufferCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                dwIndex: u32,
                ppBuffer: ?*?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                dwIndex: u32,
                ppBuffer: ?*?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertToContiguousBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                ppBuffer: ?*?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                ppBuffer: ?*?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                pBuffer: ?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                pBuffer: ?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBufferByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                dwIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                dwIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                pcbTotalLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                pcbTotalLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyToBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSample,
                pBuffer: ?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSample,
                pBuffer: ?*IMFMediaBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_GetSampleFlags(self: *const T, pdwSampleFlags: ?*u32) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).GetSampleFlags(@as(*const IMFSample, @ptrCast(self)), pdwSampleFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_SetSampleFlags(self: *const T, dwSampleFlags: u32) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).SetSampleFlags(@as(*const IMFSample, @ptrCast(self)), dwSampleFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_GetSampleTime(self: *const T, phnsSampleTime: ?*i64) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).GetSampleTime(@as(*const IMFSample, @ptrCast(self)), phnsSampleTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_SetSampleTime(self: *const T, hnsSampleTime: i64) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).SetSampleTime(@as(*const IMFSample, @ptrCast(self)), hnsSampleTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_GetSampleDuration(self: *const T, phnsSampleDuration: ?*i64) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).GetSampleDuration(@as(*const IMFSample, @ptrCast(self)), phnsSampleDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_SetSampleDuration(self: *const T, hnsSampleDuration: i64) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).SetSampleDuration(@as(*const IMFSample, @ptrCast(self)), hnsSampleDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_GetBufferCount(self: *const T, pdwBufferCount: ?*u32) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).GetBufferCount(@as(*const IMFSample, @ptrCast(self)), pdwBufferCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_GetBufferByIndex(self: *const T, dwIndex: u32, ppBuffer: ?*?*IMFMediaBuffer) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).GetBufferByIndex(@as(*const IMFSample, @ptrCast(self)), dwIndex, ppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_ConvertToContiguousBuffer(self: *const T, ppBuffer: ?*?*IMFMediaBuffer) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).ConvertToContiguousBuffer(@as(*const IMFSample, @ptrCast(self)), ppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_AddBuffer(self: *const T, pBuffer: ?*IMFMediaBuffer) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).AddBuffer(@as(*const IMFSample, @ptrCast(self)), pBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_RemoveBufferByIndex(self: *const T, dwIndex: u32) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).RemoveBufferByIndex(@as(*const IMFSample, @ptrCast(self)), dwIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_RemoveAllBuffers(self: *const T) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).RemoveAllBuffers(@as(*const IMFSample, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_GetTotalLength(self: *const T, pcbTotalLength: ?*u32) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).GetTotalLength(@as(*const IMFSample, @ptrCast(self)), pcbTotalLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSample_CopyToBuffer(self: *const T, pBuffer: ?*IMFMediaBuffer) HRESULT {
                return @as(*const IMFSample.VTable, @ptrCast(self.vtable)).CopyToBuffer(@as(*const IMFSample, @ptrCast(self)), pBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMF2DBuffer_Value = Guid.initString("7dc9d5f9-9ed9-44ec-9bbf-0600bb589fbb");
pub const IID_IMF2DBuffer = &IID_IMF2DBuffer_Value;
pub const IMF2DBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock2D: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
                ppbScanline0: ?*?*u8,
                plPitch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
                ppbScanline0: ?*?*u8,
                plPitch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unlock2D: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScanline0AndPitch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
                pbScanline0: ?*?*u8,
                plPitch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
                pbScanline0: ?*?*u8,
                plPitch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsContiguousFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
                pfIsContiguous: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
                pfIsContiguous: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContiguousLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
                pcbLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
                pcbLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContiguousCopyTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
                // TODO: what to do with BytesParamIndex 1?
                pbDestBuffer: ?*u8,
                cbDestBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
                // TODO: what to do with BytesParamIndex 1?
                pbDestBuffer: ?*u8,
                cbDestBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContiguousCopyFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer,
                // TODO: what to do with BytesParamIndex 1?
                pbSrcBuffer: ?*const u8,
                cbSrcBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer,
                // TODO: what to do with BytesParamIndex 1?
                pbSrcBuffer: ?*const u8,
                cbSrcBuffer: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_Lock2D(self: *const T, ppbScanline0: ?*?*u8, plPitch: ?*i32) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).Lock2D(@as(*const IMF2DBuffer, @ptrCast(self)), ppbScanline0, plPitch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_Unlock2D(self: *const T) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).Unlock2D(@as(*const IMF2DBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_GetScanline0AndPitch(self: *const T, pbScanline0: ?*?*u8, plPitch: ?*i32) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).GetScanline0AndPitch(@as(*const IMF2DBuffer, @ptrCast(self)), pbScanline0, plPitch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_IsContiguousFormat(self: *const T, pfIsContiguous: ?*BOOL) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).IsContiguousFormat(@as(*const IMF2DBuffer, @ptrCast(self)), pfIsContiguous);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_GetContiguousLength(self: *const T, pcbLength: ?*u32) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).GetContiguousLength(@as(*const IMF2DBuffer, @ptrCast(self)), pcbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_ContiguousCopyTo(self: *const T, pbDestBuffer: ?*u8, cbDestBuffer: u32) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).ContiguousCopyTo(@as(*const IMF2DBuffer, @ptrCast(self)), pbDestBuffer, cbDestBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer_ContiguousCopyFrom(self: *const T, pbSrcBuffer: ?*const u8, cbSrcBuffer: u32) HRESULT {
                return @as(*const IMF2DBuffer.VTable, @ptrCast(self.vtable)).ContiguousCopyFrom(@as(*const IMF2DBuffer, @ptrCast(self)), pbSrcBuffer, cbSrcBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF2DBuffer_LockFlags = enum(i32) {
    LockTypeMask = 3,
    Read = 1,
    Write = 2,
    // ReadWrite = 3, this enum value conflicts with LockTypeMask
    ForceDWORD = 2147483647,
};
pub const MF2DBuffer_LockFlags_LockTypeMask = MF2DBuffer_LockFlags.LockTypeMask;
pub const MF2DBuffer_LockFlags_Read = MF2DBuffer_LockFlags.Read;
pub const MF2DBuffer_LockFlags_Write = MF2DBuffer_LockFlags.Write;
pub const MF2DBuffer_LockFlags_ReadWrite = MF2DBuffer_LockFlags.LockTypeMask;
pub const MF2DBuffer_LockFlags_ForceDWORD = MF2DBuffer_LockFlags.ForceDWORD;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMF2DBuffer2_Value = Guid.initString("33ae5ea6-4316-436f-8ddd-d73d22f829ec");
pub const IID_IMF2DBuffer2 = &IID_IMF2DBuffer2_Value;
pub const IMF2DBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: IMF2DBuffer.VTable,
        Lock2DSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer2,
                lockFlags: MF2DBuffer_LockFlags,
                ppbScanline0: ?*?*u8,
                plPitch: ?*i32,
                ppbBufferStart: ?*?*u8,
                pcbBufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer2,
                lockFlags: MF2DBuffer_LockFlags,
                ppbScanline0: ?*?*u8,
                plPitch: ?*i32,
                ppbBufferStart: ?*?*u8,
                pcbBufferLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Copy2DTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMF2DBuffer2,
                pDestBuffer: ?*IMF2DBuffer2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMF2DBuffer2,
                pDestBuffer: ?*IMF2DBuffer2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMF2DBuffer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer2_Lock2DSize(self: *const T, lockFlags: MF2DBuffer_LockFlags, ppbScanline0: ?*?*u8, plPitch: ?*i32, ppbBufferStart: ?*?*u8, pcbBufferLength: ?*u32) HRESULT {
                return @as(*const IMF2DBuffer2.VTable, @ptrCast(self.vtable)).Lock2DSize(@as(*const IMF2DBuffer2, @ptrCast(self)), lockFlags, ppbScanline0, plPitch, ppbBufferStart, pcbBufferLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMF2DBuffer2_Copy2DTo(self: *const T, pDestBuffer: ?*IMF2DBuffer2) HRESULT {
                return @as(*const IMF2DBuffer2.VTable, @ptrCast(self.vtable)).Copy2DTo(@as(*const IMF2DBuffer2, @ptrCast(self)), pDestBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFDXGIBuffer_Value = Guid.initString("e7174cfa-1c9e-48b1-8866-626226bfc258");
pub const IID_IMFDXGIBuffer = &IID_IMFDXGIBuffer_Value;
pub const IMFDXGIBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIBuffer,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIBuffer,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubresourceIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIBuffer,
                puSubresource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIBuffer,
                puSubresource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUnknown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIBuffer,
                guid: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIBuffer,
                guid: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnknown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIBuffer,
                guid: ?*const Guid,
                pUnkData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIBuffer,
                guid: ?*const Guid,
                pUnkData: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIBuffer_GetResource(self: *const T, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFDXGIBuffer.VTable, @ptrCast(self.vtable)).GetResource(@as(*const IMFDXGIBuffer, @ptrCast(self)), riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIBuffer_GetSubresourceIndex(self: *const T, puSubresource: ?*u32) HRESULT {
                return @as(*const IMFDXGIBuffer.VTable, @ptrCast(self.vtable)).GetSubresourceIndex(@as(*const IMFDXGIBuffer, @ptrCast(self)), puSubresource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIBuffer_GetUnknown(self: *const T, guid: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFDXGIBuffer.VTable, @ptrCast(self.vtable)).GetUnknown(@as(*const IMFDXGIBuffer, @ptrCast(self)), guid, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIBuffer_SetUnknown(self: *const T, guid: ?*const Guid, pUnkData: ?*IUnknown) HRESULT {
                return @as(*const IMFDXGIBuffer.VTable, @ptrCast(self.vtable)).SetUnknown(@as(*const IMFDXGIBuffer, @ptrCast(self)), guid, pUnkData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaType_Value = Guid.initString("44ae0fa8-ea31-4109-8d2e-4cae4997c555");
pub const IID_IMFMediaType = &IID_IMFMediaType_Value;
pub const IMFMediaType = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetMajorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaType,
                pguidMajorType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaType,
                pguidMajorType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCompressedFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaType,
                pfCompressed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaType,
                pfCompressed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaType,
                pIMediaType: ?*IMFMediaType,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaType,
                pIMediaType: ?*IMFMediaType,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRepresentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaType,
                guidRepresentation: Guid,
                ppvRepresentation: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaType,
                guidRepresentation: Guid,
                ppvRepresentation: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeRepresentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaType,
                guidRepresentation: Guid,
                pvRepresentation: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaType,
                guidRepresentation: Guid,
                pvRepresentation: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaType_GetMajorType(self: *const T, pguidMajorType: ?*Guid) HRESULT {
                return @as(*const IMFMediaType.VTable, @ptrCast(self.vtable)).GetMajorType(@as(*const IMFMediaType, @ptrCast(self)), pguidMajorType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaType_IsCompressedFormat(self: *const T, pfCompressed: ?*BOOL) HRESULT {
                return @as(*const IMFMediaType.VTable, @ptrCast(self.vtable)).IsCompressedFormat(@as(*const IMFMediaType, @ptrCast(self)), pfCompressed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaType_IsEqual(self: *const T, pIMediaType: ?*IMFMediaType, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFMediaType.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IMFMediaType, @ptrCast(self)), pIMediaType, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaType_GetRepresentation(self: *const T, guidRepresentation: Guid, ppvRepresentation: ?*?*anyopaque) HRESULT {
                return @as(*const IMFMediaType.VTable, @ptrCast(self.vtable)).GetRepresentation(@as(*const IMFMediaType, @ptrCast(self)), guidRepresentation, ppvRepresentation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaType_FreeRepresentation(self: *const T, guidRepresentation: Guid, pvRepresentation: ?*anyopaque) HRESULT {
                return @as(*const IMFMediaType.VTable, @ptrCast(self.vtable)).FreeRepresentation(@as(*const IMFMediaType, @ptrCast(self)), guidRepresentation, pvRepresentation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFAudioMediaType_Value = Guid.initString("26a0adc3-ce26-4672-9304-69552edd3faf");
pub const IID_IMFAudioMediaType = &IID_IMFAudioMediaType_Value;
pub const IMFAudioMediaType = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaType.VTable,
        GetAudioFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) ?*WAVEFORMATEX,
            else => *const fn (
                self: *const IMFAudioMediaType,
            ) callconv(@import("std").os.windows.WINAPI) ?*WAVEFORMATEX,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaType.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioMediaType_GetAudioFormat(self: *const T) ?*WAVEFORMATEX {
                return @as(*const IMFAudioMediaType.VTable, @ptrCast(self.vtable)).GetAudioFormat(@as(*const IMFAudioMediaType, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFT_REGISTER_TYPE_INFO = extern struct {
    guidMajorType: Guid,
    guidSubtype: Guid,
};

pub const MFVideoInterlaceMode = enum(i32) {
    Unknown = 0,
    Progressive = 2,
    FieldInterleavedUpperFirst = 3,
    FieldInterleavedLowerFirst = 4,
    FieldSingleUpper = 5,
    FieldSingleLower = 6,
    MixedInterlaceOrProgressive = 7,
    Last = 8,
    ForceDWORD = 2147483647,
};
pub const MFVideoInterlace_Unknown = MFVideoInterlaceMode.Unknown;
pub const MFVideoInterlace_Progressive = MFVideoInterlaceMode.Progressive;
pub const MFVideoInterlace_FieldInterleavedUpperFirst = MFVideoInterlaceMode.FieldInterleavedUpperFirst;
pub const MFVideoInterlace_FieldInterleavedLowerFirst = MFVideoInterlaceMode.FieldInterleavedLowerFirst;
pub const MFVideoInterlace_FieldSingleUpper = MFVideoInterlaceMode.FieldSingleUpper;
pub const MFVideoInterlace_FieldSingleLower = MFVideoInterlaceMode.FieldSingleLower;
pub const MFVideoInterlace_MixedInterlaceOrProgressive = MFVideoInterlaceMode.MixedInterlaceOrProgressive;
pub const MFVideoInterlace_Last = MFVideoInterlaceMode.Last;
pub const MFVideoInterlace_ForceDWORD = MFVideoInterlaceMode.ForceDWORD;

pub const MFVideoTransferFunction = enum(i32) {
    Unknown = 0,
    @"10" = 1,
    @"18" = 2,
    @"20" = 3,
    @"22" = 4,
    @"709" = 5,
    @"240M" = 6,
    sRGB = 7,
    @"28" = 8,
    Log_100 = 9,
    Log_316 = 10,
    @"709_sym" = 11,
    @"2020_const" = 12,
    @"2020" = 13,
    @"26" = 14,
    @"2084" = 15,
    HLG = 16,
    @"10_rel" = 17,
    Last = 18,
    ForceDWORD = 2147483647,
};
pub const MFVideoTransFunc_Unknown = MFVideoTransferFunction.Unknown;
pub const MFVideoTransFunc_10 = MFVideoTransferFunction.@"10";
pub const MFVideoTransFunc_18 = MFVideoTransferFunction.@"18";
pub const MFVideoTransFunc_20 = MFVideoTransferFunction.@"20";
pub const MFVideoTransFunc_22 = MFVideoTransferFunction.@"22";
pub const MFVideoTransFunc_709 = MFVideoTransferFunction.@"709";
pub const MFVideoTransFunc_240M = MFVideoTransferFunction.@"240M";
pub const MFVideoTransFunc_sRGB = MFVideoTransferFunction.sRGB;
pub const MFVideoTransFunc_28 = MFVideoTransferFunction.@"28";
pub const MFVideoTransFunc_Log_100 = MFVideoTransferFunction.Log_100;
pub const MFVideoTransFunc_Log_316 = MFVideoTransferFunction.Log_316;
pub const MFVideoTransFunc_709_sym = MFVideoTransferFunction.@"709_sym";
pub const MFVideoTransFunc_2020_const = MFVideoTransferFunction.@"2020_const";
pub const MFVideoTransFunc_2020 = MFVideoTransferFunction.@"2020";
pub const MFVideoTransFunc_26 = MFVideoTransferFunction.@"26";
pub const MFVideoTransFunc_2084 = MFVideoTransferFunction.@"2084";
pub const MFVideoTransFunc_HLG = MFVideoTransferFunction.HLG;
pub const MFVideoTransFunc_10_rel = MFVideoTransferFunction.@"10_rel";
pub const MFVideoTransFunc_Last = MFVideoTransferFunction.Last;
pub const MFVideoTransFunc_ForceDWORD = MFVideoTransferFunction.ForceDWORD;

pub const MFVideoPrimaries = enum(i32) {
    Unknown = 0,
    reserved = 1,
    BT709 = 2,
    BT470_2_SysM = 3,
    BT470_2_SysBG = 4,
    SMPTE170M = 5,
    SMPTE240M = 6,
    EBU3213 = 7,
    SMPTE_C = 8,
    BT2020 = 9,
    XYZ = 10,
    DCI_P3 = 11,
    ACES = 12,
    Last = 13,
    ForceDWORD = 2147483647,
};
pub const MFVideoPrimaries_Unknown = MFVideoPrimaries.Unknown;
pub const MFVideoPrimaries_reserved = MFVideoPrimaries.reserved;
pub const MFVideoPrimaries_BT709 = MFVideoPrimaries.BT709;
pub const MFVideoPrimaries_BT470_2_SysM = MFVideoPrimaries.BT470_2_SysM;
pub const MFVideoPrimaries_BT470_2_SysBG = MFVideoPrimaries.BT470_2_SysBG;
pub const MFVideoPrimaries_SMPTE170M = MFVideoPrimaries.SMPTE170M;
pub const MFVideoPrimaries_SMPTE240M = MFVideoPrimaries.SMPTE240M;
pub const MFVideoPrimaries_EBU3213 = MFVideoPrimaries.EBU3213;
pub const MFVideoPrimaries_SMPTE_C = MFVideoPrimaries.SMPTE_C;
pub const MFVideoPrimaries_BT2020 = MFVideoPrimaries.BT2020;
pub const MFVideoPrimaries_XYZ = MFVideoPrimaries.XYZ;
pub const MFVideoPrimaries_DCI_P3 = MFVideoPrimaries.DCI_P3;
pub const MFVideoPrimaries_ACES = MFVideoPrimaries.ACES;
pub const MFVideoPrimaries_Last = MFVideoPrimaries.Last;
pub const MFVideoPrimaries_ForceDWORD = MFVideoPrimaries.ForceDWORD;

pub const MFVideoLighting = enum(i32) {
    Unknown = 0,
    bright = 1,
    office = 2,
    dim = 3,
    dark = 4,
    Last = 5,
    ForceDWORD = 2147483647,
};
pub const MFVideoLighting_Unknown = MFVideoLighting.Unknown;
pub const MFVideoLighting_bright = MFVideoLighting.bright;
pub const MFVideoLighting_office = MFVideoLighting.office;
pub const MFVideoLighting_dim = MFVideoLighting.dim;
pub const MFVideoLighting_dark = MFVideoLighting.dark;
pub const MFVideoLighting_Last = MFVideoLighting.Last;
pub const MFVideoLighting_ForceDWORD = MFVideoLighting.ForceDWORD;

pub const MFVideoTransferMatrix = enum(i32) {
    Unknown = 0,
    BT709 = 1,
    BT601 = 2,
    SMPTE240M = 3,
    BT2020_10 = 4,
    BT2020_12 = 5,
    Last = 6,
    ForceDWORD = 2147483647,
};
pub const MFVideoTransferMatrix_Unknown = MFVideoTransferMatrix.Unknown;
pub const MFVideoTransferMatrix_BT709 = MFVideoTransferMatrix.BT709;
pub const MFVideoTransferMatrix_BT601 = MFVideoTransferMatrix.BT601;
pub const MFVideoTransferMatrix_SMPTE240M = MFVideoTransferMatrix.SMPTE240M;
pub const MFVideoTransferMatrix_BT2020_10 = MFVideoTransferMatrix.BT2020_10;
pub const MFVideoTransferMatrix_BT2020_12 = MFVideoTransferMatrix.BT2020_12;
pub const MFVideoTransferMatrix_Last = MFVideoTransferMatrix.Last;
pub const MFVideoTransferMatrix_ForceDWORD = MFVideoTransferMatrix.ForceDWORD;

pub const MFVideoChromaSubsampling = enum(i32) {
    Unknown = 0,
    ProgressiveChroma = 8,
    Horizontally_Cosited = 4,
    Vertically_Cosited = 2,
    Vertically_AlignedChromaPlanes = 1,
    MPEG2 = 5,
    // MPEG1 = 1, this enum value conflicts with Vertically_AlignedChromaPlanes
    DV_PAL = 6,
    Cosited = 7,
    // Last = 8, this enum value conflicts with ProgressiveChroma
    ForceDWORD = 2147483647,
};
pub const MFVideoChromaSubsampling_Unknown = MFVideoChromaSubsampling.Unknown;
pub const MFVideoChromaSubsampling_ProgressiveChroma = MFVideoChromaSubsampling.ProgressiveChroma;
pub const MFVideoChromaSubsampling_Horizontally_Cosited = MFVideoChromaSubsampling.Horizontally_Cosited;
pub const MFVideoChromaSubsampling_Vertically_Cosited = MFVideoChromaSubsampling.Vertically_Cosited;
pub const MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes = MFVideoChromaSubsampling.Vertically_AlignedChromaPlanes;
pub const MFVideoChromaSubsampling_MPEG2 = MFVideoChromaSubsampling.MPEG2;
pub const MFVideoChromaSubsampling_MPEG1 = MFVideoChromaSubsampling.Vertically_AlignedChromaPlanes;
pub const MFVideoChromaSubsampling_DV_PAL = MFVideoChromaSubsampling.DV_PAL;
pub const MFVideoChromaSubsampling_Cosited = MFVideoChromaSubsampling.Cosited;
pub const MFVideoChromaSubsampling_Last = MFVideoChromaSubsampling.ProgressiveChroma;
pub const MFVideoChromaSubsampling_ForceDWORD = MFVideoChromaSubsampling.ForceDWORD;

pub const MFNominalRange = enum(i32) {
    Unknown = 0,
    Normal = 1,
    Wide = 2,
    // @"0_255" = 1, this enum value conflicts with Normal
    // @"16_235" = 2, this enum value conflicts with Wide
    @"48_208" = 3,
    @"64_127" = 4,
    Last = 5,
    ForceDWORD = 2147483647,
};
pub const MFNominalRange_Unknown = MFNominalRange.Unknown;
pub const MFNominalRange_Normal = MFNominalRange.Normal;
pub const MFNominalRange_Wide = MFNominalRange.Wide;
pub const MFNominalRange_0_255 = MFNominalRange.Normal;
pub const MFNominalRange_16_235 = MFNominalRange.Wide;
pub const MFNominalRange_48_208 = MFNominalRange.@"48_208";
pub const MFNominalRange_64_127 = MFNominalRange.@"64_127";
pub const MFNominalRange_Last = MFNominalRange.Last;
pub const MFNominalRange_ForceDWORD = MFNominalRange.ForceDWORD;

pub const MFVideoFlags = enum(i32) {
    _PAD_TO_Mask = 3,
    _PAD_TO_None = 0,
    _PAD_TO_4x3 = 1,
    _PAD_TO_16x9 = 2,
    _SrcContentHintMask = 28,
    // _SrcContentHintNone = 0, this enum value conflicts with _PAD_TO_None
    _SrcContentHint16x9 = 4,
    _SrcContentHint235_1 = 8,
    _AnalogProtected = 32,
    _DigitallyProtected = 64,
    _ProgressiveContent = 128,
    _FieldRepeatCountMask = 1792,
    // _FieldRepeatCountShift = 8, this enum value conflicts with _SrcContentHint235_1
    _ProgressiveSeqReset = 2048,
    _PanScanEnabled = 131072,
    _LowerFieldFirst = 262144,
    _BottomUpLinearRep = 524288,
    s_DXVASurface = 1048576,
    s_RenderTargetSurface = 4194304,
    s_ForceQWORD = 2147483647,
};
pub const MFVideoFlag_PAD_TO_Mask = MFVideoFlags._PAD_TO_Mask;
pub const MFVideoFlag_PAD_TO_None = MFVideoFlags._PAD_TO_None;
pub const MFVideoFlag_PAD_TO_4x3 = MFVideoFlags._PAD_TO_4x3;
pub const MFVideoFlag_PAD_TO_16x9 = MFVideoFlags._PAD_TO_16x9;
pub const MFVideoFlag_SrcContentHintMask = MFVideoFlags._SrcContentHintMask;
pub const MFVideoFlag_SrcContentHintNone = MFVideoFlags._PAD_TO_None;
pub const MFVideoFlag_SrcContentHint16x9 = MFVideoFlags._SrcContentHint16x9;
pub const MFVideoFlag_SrcContentHint235_1 = MFVideoFlags._SrcContentHint235_1;
pub const MFVideoFlag_AnalogProtected = MFVideoFlags._AnalogProtected;
pub const MFVideoFlag_DigitallyProtected = MFVideoFlags._DigitallyProtected;
pub const MFVideoFlag_ProgressiveContent = MFVideoFlags._ProgressiveContent;
pub const MFVideoFlag_FieldRepeatCountMask = MFVideoFlags._FieldRepeatCountMask;
pub const MFVideoFlag_FieldRepeatCountShift = MFVideoFlags._SrcContentHint235_1;
pub const MFVideoFlag_ProgressiveSeqReset = MFVideoFlags._ProgressiveSeqReset;
pub const MFVideoFlag_PanScanEnabled = MFVideoFlags._PanScanEnabled;
pub const MFVideoFlag_LowerFieldFirst = MFVideoFlags._LowerFieldFirst;
pub const MFVideoFlag_BottomUpLinearRep = MFVideoFlags._BottomUpLinearRep;
pub const MFVideoFlags_DXVASurface = MFVideoFlags.s_DXVASurface;
pub const MFVideoFlags_RenderTargetSurface = MFVideoFlags.s_RenderTargetSurface;
pub const MFVideoFlags_ForceQWORD = MFVideoFlags.s_ForceQWORD;

pub const MFRatio = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const MFOffset = extern struct {
    fract: u16,
    value: i16,
};

pub const MFVideoArea = extern struct {
    OffsetX: MFOffset,
    OffsetY: MFOffset,
    Area: SIZE,
};

pub const MFVideoInfo = extern struct {
    dwWidth: u32,
    dwHeight: u32,
    PixelAspectRatio: MFRatio,
    SourceChromaSubsampling: MFVideoChromaSubsampling,
    InterlaceMode: MFVideoInterlaceMode,
    TransferFunction: MFVideoTransferFunction,
    ColorPrimaries: MFVideoPrimaries,
    TransferMatrix: MFVideoTransferMatrix,
    SourceLighting: MFVideoLighting,
    FramesPerSecond: MFRatio,
    NominalRange: MFNominalRange,
    GeometricAperture: MFVideoArea,
    MinimumDisplayAperture: MFVideoArea,
    PanScanAperture: MFVideoArea,
    VideoFlags: u64,
};

pub const MFAYUVSample = extern struct {
    bCrValue: u8,
    bCbValue: u8,
    bYValue: u8,
    bSampleAlpha8: u8,
};

pub const MFARGB = extern struct {
    rgbBlue: u8,
    rgbGreen: u8,
    rgbRed: u8,
    rgbAlpha: u8,
};

pub const MFPaletteEntry = extern union {
    ARGB: MFARGB,
    AYCbCr: MFAYUVSample,
};

pub const MFVideoSurfaceInfo = extern struct {
    Format: u32,
    PaletteEntries: u32,
    Palette: [1]MFPaletteEntry,
};

pub const MFVideoCompressedInfo = extern struct {
    AvgBitrate: i64,
    AvgBitErrorRate: i64,
    MaxKeyFrameSpacing: u32,
};

pub const MFVIDEOFORMAT = extern struct {
    dwSize: u32,
    videoInfo: MFVideoInfo,
    guidFormat: Guid,
    compressedInfo: MFVideoCompressedInfo,
    surfaceInfo: MFVideoSurfaceInfo,
};

pub const MFStandardVideoFormat = enum(i32) {
    reserved = 0,
    NTSC = 1,
    PAL = 2,
    DVD_NTSC = 3,
    DVD_PAL = 4,
    DV_PAL = 5,
    DV_NTSC = 6,
    ATSC_SD480i = 7,
    ATSC_HD1080i = 8,
    ATSC_HD720p = 9,
};
pub const MFStdVideoFormat_reserved = MFStandardVideoFormat.reserved;
pub const MFStdVideoFormat_NTSC = MFStandardVideoFormat.NTSC;
pub const MFStdVideoFormat_PAL = MFStandardVideoFormat.PAL;
pub const MFStdVideoFormat_DVD_NTSC = MFStandardVideoFormat.DVD_NTSC;
pub const MFStdVideoFormat_DVD_PAL = MFStandardVideoFormat.DVD_PAL;
pub const MFStdVideoFormat_DV_PAL = MFStandardVideoFormat.DV_PAL;
pub const MFStdVideoFormat_DV_NTSC = MFStandardVideoFormat.DV_NTSC;
pub const MFStdVideoFormat_ATSC_SD480i = MFStandardVideoFormat.ATSC_SD480i;
pub const MFStdVideoFormat_ATSC_HD1080i = MFStandardVideoFormat.ATSC_HD1080i;
pub const MFStdVideoFormat_ATSC_HD720p = MFStandardVideoFormat.ATSC_HD720p;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoMediaType_Value = Guid.initString("b99f381f-a8f9-47a2-a5af-ca3a225a3890");
pub const IID_IMFVideoMediaType = &IID_IMFVideoMediaType_Value;
pub const IMFVideoMediaType = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaType.VTable,
        GetVideoFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMediaType,
            ) callconv(@import("std").os.windows.WINAPI) ?*MFVIDEOFORMAT,
            else => *const fn (
                self: *const IMFVideoMediaType,
            ) callconv(@import("std").os.windows.WINAPI) ?*MFVIDEOFORMAT,
        },
        GetVideoRepresentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMediaType,
                guidRepresentation: Guid,
                ppvRepresentation: ?*?*anyopaque,
                lStride: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMediaType,
                guidRepresentation: Guid,
                ppvRepresentation: ?*?*anyopaque,
                lStride: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaType.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMediaType_GetVideoFormat(self: *const T) ?*MFVIDEOFORMAT {
                return @as(*const IMFVideoMediaType.VTable, @ptrCast(self.vtable)).GetVideoFormat(@as(*const IMFVideoMediaType, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMediaType_GetVideoRepresentation(self: *const T, guidRepresentation: Guid, ppvRepresentation: ?*?*anyopaque, lStride: i32) HRESULT {
                return @as(*const IMFVideoMediaType.VTable, @ptrCast(self.vtable)).GetVideoRepresentation(@as(*const IMFVideoMediaType, @ptrCast(self)), guidRepresentation, ppvRepresentation, lStride);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFAsyncResult_Value = Guid.initString("ac6b7889-0740-4d51-8619-905994a55cc6");
pub const IID_IMFAsyncResult = &IID_IMFAsyncResult_Value;
pub const IMFAsyncResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncResult,
                ppunkState: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAsyncResult,
                ppunkState: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncResult,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAsyncResult,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncResult,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAsyncResult,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStateNoAddRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) ?*IUnknown,
            else => *const fn (
                self: *const IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) ?*IUnknown,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncResult_GetState(self: *const T, ppunkState: ?*?*IUnknown) HRESULT {
                return @as(*const IMFAsyncResult.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMFAsyncResult, @ptrCast(self)), ppunkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncResult_GetStatus(self: *const T) HRESULT {
                return @as(*const IMFAsyncResult.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMFAsyncResult, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncResult_SetStatus(self: *const T, hrStatus: HRESULT) HRESULT {
                return @as(*const IMFAsyncResult.VTable, @ptrCast(self.vtable)).SetStatus(@as(*const IMFAsyncResult, @ptrCast(self)), hrStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncResult_GetObject(self: *const T, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFAsyncResult.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IMFAsyncResult, @ptrCast(self)), ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncResult_GetStateNoAddRef(self: *const T) ?*IUnknown {
                return @as(*const IMFAsyncResult.VTable, @ptrCast(self.vtable)).GetStateNoAddRef(@as(*const IMFAsyncResult, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFAsyncCallback_Value = Guid.initString("a27003cf-2354-4f2a-8d6a-ab7cff15437e");
pub const IID_IMFAsyncCallback = &IID_IMFAsyncCallback_Value;
pub const IMFAsyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncCallback,
                pdwFlags: ?*u32,
                pdwQueue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAsyncCallback,
                pdwFlags: ?*u32,
                pdwQueue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncCallback,
                pAsyncResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAsyncCallback,
                pAsyncResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncCallback_GetParameters(self: *const T, pdwFlags: ?*u32, pdwQueue: ?*u32) HRESULT {
                return @as(*const IMFAsyncCallback.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IMFAsyncCallback, @ptrCast(self)), pdwFlags, pdwQueue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncCallback_Invoke(self: *const T, pAsyncResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFAsyncCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IMFAsyncCallback, @ptrCast(self)), pAsyncResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFAsyncCallbackLogging_Value = Guid.initString("c7a4dca1-f5f0-47b6-b92b-bf0106d25791");
pub const IID_IMFAsyncCallbackLogging = &IID_IMFAsyncCallbackLogging_Value;
pub const IMFAsyncCallbackLogging = extern struct {
    pub const VTable = extern struct {
        base: IMFAsyncCallback.VTable,
        GetObjectPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncCallbackLogging,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMFAsyncCallbackLogging,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        GetObjectTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAsyncCallbackLogging,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFAsyncCallbackLogging,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAsyncCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncCallbackLogging_GetObjectPointer(self: *const T) ?*anyopaque {
                return @as(*const IMFAsyncCallbackLogging.VTable, @ptrCast(self.vtable)).GetObjectPointer(@as(*const IMFAsyncCallbackLogging, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAsyncCallbackLogging_GetObjectTag(self: *const T) u32 {
                return @as(*const IMFAsyncCallbackLogging.VTable, @ptrCast(self.vtable)).GetObjectTag(@as(*const IMFAsyncCallbackLogging, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_EVENT_TYPE = enum(i32) {
    Unknown = 0,
    Error = 1,
    ExtendedType = 2,
    NonFatalError = 3,
    // GenericV1Anchor = 3, this enum value conflicts with NonFatalError
    SessionUnknown = 100,
    SessionTopologySet = 101,
    SessionTopologiesCleared = 102,
    SessionStarted = 103,
    SessionPaused = 104,
    SessionStopped = 105,
    SessionClosed = 106,
    SessionEnded = 107,
    SessionRateChanged = 108,
    SessionScrubSampleComplete = 109,
    SessionCapabilitiesChanged = 110,
    SessionTopologyStatus = 111,
    SessionNotifyPresentationTime = 112,
    NewPresentation = 113,
    LicenseAcquisitionStart = 114,
    LicenseAcquisitionCompleted = 115,
    IndividualizationStart = 116,
    IndividualizationCompleted = 117,
    EnablerProgress = 118,
    EnablerCompleted = 119,
    PolicyError = 120,
    PolicyReport = 121,
    BufferingStarted = 122,
    BufferingStopped = 123,
    ConnectStart = 124,
    ConnectEnd = 125,
    ReconnectStart = 126,
    ReconnectEnd = 127,
    RendererEvent = 128,
    SessionStreamSinkFormatChanged = 129,
    // SessionV1Anchor = 129, this enum value conflicts with SessionStreamSinkFormatChanged
    SourceUnknown = 200,
    SourceStarted = 201,
    StreamStarted = 202,
    SourceSeeked = 203,
    StreamSeeked = 204,
    NewStream = 205,
    UpdatedStream = 206,
    SourceStopped = 207,
    StreamStopped = 208,
    SourcePaused = 209,
    StreamPaused = 210,
    EndOfPresentation = 211,
    EndOfStream = 212,
    MediaSample = 213,
    StreamTick = 214,
    StreamThinMode = 215,
    StreamFormatChanged = 216,
    SourceRateChanged = 217,
    EndOfPresentationSegment = 218,
    SourceCharacteristicsChanged = 219,
    SourceRateChangeRequested = 220,
    SourceMetadataChanged = 221,
    SequencerSourceTopologyUpdated = 222,
    // SourceV1Anchor = 222, this enum value conflicts with SequencerSourceTopologyUpdated
    SinkUnknown = 300,
    StreamSinkStarted = 301,
    StreamSinkStopped = 302,
    StreamSinkPaused = 303,
    StreamSinkRateChanged = 304,
    StreamSinkRequestSample = 305,
    StreamSinkMarker = 306,
    StreamSinkPrerolled = 307,
    StreamSinkScrubSampleComplete = 308,
    StreamSinkFormatChanged = 309,
    StreamSinkDeviceChanged = 310,
    QualityNotify = 311,
    SinkInvalidated = 312,
    AudioSessionNameChanged = 313,
    AudioSessionVolumeChanged = 314,
    AudioSessionDeviceRemoved = 315,
    AudioSessionServerShutdown = 316,
    AudioSessionGroupingParamChanged = 317,
    AudioSessionIconChanged = 318,
    AudioSessionFormatChanged = 319,
    AudioSessionDisconnected = 320,
    AudioSessionExclusiveModeOverride = 321,
    // SinkV1Anchor = 321, this enum value conflicts with AudioSessionExclusiveModeOverride
    CaptureAudioSessionVolumeChanged = 322,
    CaptureAudioSessionDeviceRemoved = 323,
    CaptureAudioSessionFormatChanged = 324,
    CaptureAudioSessionDisconnected = 325,
    CaptureAudioSessionExclusiveModeOverride = 326,
    CaptureAudioSessionServerShutdown = 327,
    // SinkV2Anchor = 327, this enum value conflicts with CaptureAudioSessionServerShutdown
    TrustUnknown = 400,
    PolicyChanged = 401,
    ContentProtectionMessage = 402,
    PolicySet = 403,
    // TrustV1Anchor = 403, this enum value conflicts with PolicySet
    WMDRMLicenseBackupCompleted = 500,
    WMDRMLicenseBackupProgress = 501,
    WMDRMLicenseRestoreCompleted = 502,
    WMDRMLicenseRestoreProgress = 503,
    WMDRMLicenseAcquisitionCompleted = 506,
    WMDRMIndividualizationCompleted = 508,
    WMDRMIndividualizationProgress = 513,
    WMDRMProximityCompleted = 514,
    WMDRMLicenseStoreCleaned = 515,
    WMDRMRevocationDownloadCompleted = 516,
    // WMDRMV1Anchor = 516, this enum value conflicts with WMDRMRevocationDownloadCompleted
    TransformUnknown = 600,
    TransformNeedInput = 601,
    TransformHaveOutput = 602,
    TransformDrainComplete = 603,
    TransformMarker = 604,
    TransformInputStreamStateChanged = 605,
    ByteStreamCharacteristicsChanged = 700,
    VideoCaptureDeviceRemoved = 800,
    VideoCaptureDevicePreempted = 801,
    StreamSinkFormatInvalidated = 802,
    EncodingParameters = 803,
    ContentProtectionMetadata = 900,
    DeviceThermalStateChanged = 950,
    ReservedMax = 10000,
};
pub const MEUnknown = MF_EVENT_TYPE.Unknown;
pub const MEError = MF_EVENT_TYPE.Error;
pub const MEExtendedType = MF_EVENT_TYPE.ExtendedType;
pub const MENonFatalError = MF_EVENT_TYPE.NonFatalError;
pub const MEGenericV1Anchor = MF_EVENT_TYPE.NonFatalError;
pub const MESessionUnknown = MF_EVENT_TYPE.SessionUnknown;
pub const MESessionTopologySet = MF_EVENT_TYPE.SessionTopologySet;
pub const MESessionTopologiesCleared = MF_EVENT_TYPE.SessionTopologiesCleared;
pub const MESessionStarted = MF_EVENT_TYPE.SessionStarted;
pub const MESessionPaused = MF_EVENT_TYPE.SessionPaused;
pub const MESessionStopped = MF_EVENT_TYPE.SessionStopped;
pub const MESessionClosed = MF_EVENT_TYPE.SessionClosed;
pub const MESessionEnded = MF_EVENT_TYPE.SessionEnded;
pub const MESessionRateChanged = MF_EVENT_TYPE.SessionRateChanged;
pub const MESessionScrubSampleComplete = MF_EVENT_TYPE.SessionScrubSampleComplete;
pub const MESessionCapabilitiesChanged = MF_EVENT_TYPE.SessionCapabilitiesChanged;
pub const MESessionTopologyStatus = MF_EVENT_TYPE.SessionTopologyStatus;
pub const MESessionNotifyPresentationTime = MF_EVENT_TYPE.SessionNotifyPresentationTime;
pub const MENewPresentation = MF_EVENT_TYPE.NewPresentation;
pub const MELicenseAcquisitionStart = MF_EVENT_TYPE.LicenseAcquisitionStart;
pub const MELicenseAcquisitionCompleted = MF_EVENT_TYPE.LicenseAcquisitionCompleted;
pub const MEIndividualizationStart = MF_EVENT_TYPE.IndividualizationStart;
pub const MEIndividualizationCompleted = MF_EVENT_TYPE.IndividualizationCompleted;
pub const MEEnablerProgress = MF_EVENT_TYPE.EnablerProgress;
pub const MEEnablerCompleted = MF_EVENT_TYPE.EnablerCompleted;
pub const MEPolicyError = MF_EVENT_TYPE.PolicyError;
pub const MEPolicyReport = MF_EVENT_TYPE.PolicyReport;
pub const MEBufferingStarted = MF_EVENT_TYPE.BufferingStarted;
pub const MEBufferingStopped = MF_EVENT_TYPE.BufferingStopped;
pub const MEConnectStart = MF_EVENT_TYPE.ConnectStart;
pub const MEConnectEnd = MF_EVENT_TYPE.ConnectEnd;
pub const MEReconnectStart = MF_EVENT_TYPE.ReconnectStart;
pub const MEReconnectEnd = MF_EVENT_TYPE.ReconnectEnd;
pub const MERendererEvent = MF_EVENT_TYPE.RendererEvent;
pub const MESessionStreamSinkFormatChanged = MF_EVENT_TYPE.SessionStreamSinkFormatChanged;
pub const MESessionV1Anchor = MF_EVENT_TYPE.SessionStreamSinkFormatChanged;
pub const MESourceUnknown = MF_EVENT_TYPE.SourceUnknown;
pub const MESourceStarted = MF_EVENT_TYPE.SourceStarted;
pub const MEStreamStarted = MF_EVENT_TYPE.StreamStarted;
pub const MESourceSeeked = MF_EVENT_TYPE.SourceSeeked;
pub const MEStreamSeeked = MF_EVENT_TYPE.StreamSeeked;
pub const MENewStream = MF_EVENT_TYPE.NewStream;
pub const MEUpdatedStream = MF_EVENT_TYPE.UpdatedStream;
pub const MESourceStopped = MF_EVENT_TYPE.SourceStopped;
pub const MEStreamStopped = MF_EVENT_TYPE.StreamStopped;
pub const MESourcePaused = MF_EVENT_TYPE.SourcePaused;
pub const MEStreamPaused = MF_EVENT_TYPE.StreamPaused;
pub const MEEndOfPresentation = MF_EVENT_TYPE.EndOfPresentation;
pub const MEEndOfStream = MF_EVENT_TYPE.EndOfStream;
pub const MEMediaSample = MF_EVENT_TYPE.MediaSample;
pub const MEStreamTick = MF_EVENT_TYPE.StreamTick;
pub const MEStreamThinMode = MF_EVENT_TYPE.StreamThinMode;
pub const MEStreamFormatChanged = MF_EVENT_TYPE.StreamFormatChanged;
pub const MESourceRateChanged = MF_EVENT_TYPE.SourceRateChanged;
pub const MEEndOfPresentationSegment = MF_EVENT_TYPE.EndOfPresentationSegment;
pub const MESourceCharacteristicsChanged = MF_EVENT_TYPE.SourceCharacteristicsChanged;
pub const MESourceRateChangeRequested = MF_EVENT_TYPE.SourceRateChangeRequested;
pub const MESourceMetadataChanged = MF_EVENT_TYPE.SourceMetadataChanged;
pub const MESequencerSourceTopologyUpdated = MF_EVENT_TYPE.SequencerSourceTopologyUpdated;
pub const MESourceV1Anchor = MF_EVENT_TYPE.SequencerSourceTopologyUpdated;
pub const MESinkUnknown = MF_EVENT_TYPE.SinkUnknown;
pub const MEStreamSinkStarted = MF_EVENT_TYPE.StreamSinkStarted;
pub const MEStreamSinkStopped = MF_EVENT_TYPE.StreamSinkStopped;
pub const MEStreamSinkPaused = MF_EVENT_TYPE.StreamSinkPaused;
pub const MEStreamSinkRateChanged = MF_EVENT_TYPE.StreamSinkRateChanged;
pub const MEStreamSinkRequestSample = MF_EVENT_TYPE.StreamSinkRequestSample;
pub const MEStreamSinkMarker = MF_EVENT_TYPE.StreamSinkMarker;
pub const MEStreamSinkPrerolled = MF_EVENT_TYPE.StreamSinkPrerolled;
pub const MEStreamSinkScrubSampleComplete = MF_EVENT_TYPE.StreamSinkScrubSampleComplete;
pub const MEStreamSinkFormatChanged = MF_EVENT_TYPE.StreamSinkFormatChanged;
pub const MEStreamSinkDeviceChanged = MF_EVENT_TYPE.StreamSinkDeviceChanged;
pub const MEQualityNotify = MF_EVENT_TYPE.QualityNotify;
pub const MESinkInvalidated = MF_EVENT_TYPE.SinkInvalidated;
pub const MEAudioSessionNameChanged = MF_EVENT_TYPE.AudioSessionNameChanged;
pub const MEAudioSessionVolumeChanged = MF_EVENT_TYPE.AudioSessionVolumeChanged;
pub const MEAudioSessionDeviceRemoved = MF_EVENT_TYPE.AudioSessionDeviceRemoved;
pub const MEAudioSessionServerShutdown = MF_EVENT_TYPE.AudioSessionServerShutdown;
pub const MEAudioSessionGroupingParamChanged = MF_EVENT_TYPE.AudioSessionGroupingParamChanged;
pub const MEAudioSessionIconChanged = MF_EVENT_TYPE.AudioSessionIconChanged;
pub const MEAudioSessionFormatChanged = MF_EVENT_TYPE.AudioSessionFormatChanged;
pub const MEAudioSessionDisconnected = MF_EVENT_TYPE.AudioSessionDisconnected;
pub const MEAudioSessionExclusiveModeOverride = MF_EVENT_TYPE.AudioSessionExclusiveModeOverride;
pub const MESinkV1Anchor = MF_EVENT_TYPE.AudioSessionExclusiveModeOverride;
pub const MECaptureAudioSessionVolumeChanged = MF_EVENT_TYPE.CaptureAudioSessionVolumeChanged;
pub const MECaptureAudioSessionDeviceRemoved = MF_EVENT_TYPE.CaptureAudioSessionDeviceRemoved;
pub const MECaptureAudioSessionFormatChanged = MF_EVENT_TYPE.CaptureAudioSessionFormatChanged;
pub const MECaptureAudioSessionDisconnected = MF_EVENT_TYPE.CaptureAudioSessionDisconnected;
pub const MECaptureAudioSessionExclusiveModeOverride = MF_EVENT_TYPE.CaptureAudioSessionExclusiveModeOverride;
pub const MECaptureAudioSessionServerShutdown = MF_EVENT_TYPE.CaptureAudioSessionServerShutdown;
pub const MESinkV2Anchor = MF_EVENT_TYPE.CaptureAudioSessionServerShutdown;
pub const METrustUnknown = MF_EVENT_TYPE.TrustUnknown;
pub const MEPolicyChanged = MF_EVENT_TYPE.PolicyChanged;
pub const MEContentProtectionMessage = MF_EVENT_TYPE.ContentProtectionMessage;
pub const MEPolicySet = MF_EVENT_TYPE.PolicySet;
pub const METrustV1Anchor = MF_EVENT_TYPE.PolicySet;
pub const MEWMDRMLicenseBackupCompleted = MF_EVENT_TYPE.WMDRMLicenseBackupCompleted;
pub const MEWMDRMLicenseBackupProgress = MF_EVENT_TYPE.WMDRMLicenseBackupProgress;
pub const MEWMDRMLicenseRestoreCompleted = MF_EVENT_TYPE.WMDRMLicenseRestoreCompleted;
pub const MEWMDRMLicenseRestoreProgress = MF_EVENT_TYPE.WMDRMLicenseRestoreProgress;
pub const MEWMDRMLicenseAcquisitionCompleted = MF_EVENT_TYPE.WMDRMLicenseAcquisitionCompleted;
pub const MEWMDRMIndividualizationCompleted = MF_EVENT_TYPE.WMDRMIndividualizationCompleted;
pub const MEWMDRMIndividualizationProgress = MF_EVENT_TYPE.WMDRMIndividualizationProgress;
pub const MEWMDRMProximityCompleted = MF_EVENT_TYPE.WMDRMProximityCompleted;
pub const MEWMDRMLicenseStoreCleaned = MF_EVENT_TYPE.WMDRMLicenseStoreCleaned;
pub const MEWMDRMRevocationDownloadCompleted = MF_EVENT_TYPE.WMDRMRevocationDownloadCompleted;
pub const MEWMDRMV1Anchor = MF_EVENT_TYPE.WMDRMRevocationDownloadCompleted;
pub const METransformUnknown = MF_EVENT_TYPE.TransformUnknown;
pub const METransformNeedInput = MF_EVENT_TYPE.TransformNeedInput;
pub const METransformHaveOutput = MF_EVENT_TYPE.TransformHaveOutput;
pub const METransformDrainComplete = MF_EVENT_TYPE.TransformDrainComplete;
pub const METransformMarker = MF_EVENT_TYPE.TransformMarker;
pub const METransformInputStreamStateChanged = MF_EVENT_TYPE.TransformInputStreamStateChanged;
pub const MEByteStreamCharacteristicsChanged = MF_EVENT_TYPE.ByteStreamCharacteristicsChanged;
pub const MEVideoCaptureDeviceRemoved = MF_EVENT_TYPE.VideoCaptureDeviceRemoved;
pub const MEVideoCaptureDevicePreempted = MF_EVENT_TYPE.VideoCaptureDevicePreempted;
pub const MEStreamSinkFormatInvalidated = MF_EVENT_TYPE.StreamSinkFormatInvalidated;
pub const MEEncodingParameters = MF_EVENT_TYPE.EncodingParameters;
pub const MEContentProtectionMetadata = MF_EVENT_TYPE.ContentProtectionMetadata;
pub const MEDeviceThermalStateChanged = MF_EVENT_TYPE.DeviceThermalStateChanged;
pub const MEReservedMax = MF_EVENT_TYPE.ReservedMax;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaEvent_Value = Guid.initString("df598932-f10c-4e39-bba2-c308f101daa3");
pub const IID_IMFMediaEvent = &IID_IMFMediaEvent_Value;
pub const IMFMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEvent,
                pmet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEvent,
                pmet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtendedType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEvent,
                pguidExtendedType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEvent,
                pguidExtendedType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEvent,
                phrStatus: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEvent,
                phrStatus: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEvent,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEvent,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEvent_GetType(self: *const T, pmet: ?*u32) HRESULT {
                return @as(*const IMFMediaEvent.VTable, @ptrCast(self.vtable)).GetType(@as(*const IMFMediaEvent, @ptrCast(self)), pmet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEvent_GetExtendedType(self: *const T, pguidExtendedType: ?*Guid) HRESULT {
                return @as(*const IMFMediaEvent.VTable, @ptrCast(self.vtable)).GetExtendedType(@as(*const IMFMediaEvent, @ptrCast(self)), pguidExtendedType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEvent_GetStatus(self: *const T, phrStatus: ?*HRESULT) HRESULT {
                return @as(*const IMFMediaEvent.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMFMediaEvent, @ptrCast(self)), phrStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEvent_GetValue(self: *const T, pvValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMediaEvent.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IMFMediaEvent, @ptrCast(self)), pvValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaEventGenerator_Value = Guid.initString("2cd0bd52-bcd5-4b89-b62c-eadc0c031e7d");
pub const IID_IMFMediaEventGenerator = &IID_IMFMediaEventGenerator_Value;
pub const IMFMediaEventGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventGenerator,
                dwFlags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventGenerator,
                dwFlags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginGetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventGenerator,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventGenerator,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndGetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventGenerator,
                pResult: ?*IMFAsyncResult,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventGenerator,
                pResult: ?*IMFAsyncResult,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueueEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventGenerator,
                met: u32,
                guidExtendedType: ?*const Guid,
                hrStatus: HRESULT,
                pvValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventGenerator,
                met: u32,
                guidExtendedType: ?*const Guid,
                hrStatus: HRESULT,
                pvValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventGenerator_GetEvent(self: *const T, dwFlags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS, ppEvent: ?*?*IMFMediaEvent) HRESULT {
                return @as(*const IMFMediaEventGenerator.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const IMFMediaEventGenerator, @ptrCast(self)), dwFlags, ppEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventGenerator_BeginGetEvent(self: *const T, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaEventGenerator.VTable, @ptrCast(self.vtable)).BeginGetEvent(@as(*const IMFMediaEventGenerator, @ptrCast(self)), pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventGenerator_EndGetEvent(self: *const T, pResult: ?*IMFAsyncResult, ppEvent: ?*?*IMFMediaEvent) HRESULT {
                return @as(*const IMFMediaEventGenerator.VTable, @ptrCast(self.vtable)).EndGetEvent(@as(*const IMFMediaEventGenerator, @ptrCast(self)), pResult, ppEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventGenerator_QueueEvent(self: *const T, met: u32, guidExtendedType: ?*const Guid, hrStatus: HRESULT, pvValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFMediaEventGenerator.VTable, @ptrCast(self.vtable)).QueueEvent(@as(*const IMFMediaEventGenerator, @ptrCast(self)), met, guidExtendedType, hrStatus, pvValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFRemoteAsyncCallback_Value = Guid.initString("a27003d0-2354-4f2a-8d6a-ab7cff15437e");
pub const IID_IMFRemoteAsyncCallback = &IID_IMFRemoteAsyncCallback_Value;
pub const IMFRemoteAsyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRemoteAsyncCallback,
                hr: HRESULT,
                pRemoteResult: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRemoteAsyncCallback,
                hr: HRESULT,
                pRemoteResult: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRemoteAsyncCallback_Invoke(self: *const T, hr: HRESULT, pRemoteResult: ?*IUnknown) HRESULT {
                return @as(*const IMFRemoteAsyncCallback.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IMFRemoteAsyncCallback, @ptrCast(self)), hr, pRemoteResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFBYTESTREAM_SEEK_ORIGIN = enum(i32) {
    Begin = 0,
    Current = 1,
};
pub const msoBegin = MFBYTESTREAM_SEEK_ORIGIN.Begin;
pub const msoCurrent = MFBYTESTREAM_SEEK_ORIGIN.Current;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFByteStream_Value = Guid.initString("ad4c1b00-4bf7-422f-9175-756693d9130d");
pub const IID_IMFByteStream = &IID_IMFByteStream_Value;
pub const IMFByteStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pqwLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pqwLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                qwLength: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                qwLength: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pqwPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pqwPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                qwPosition: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                qwPosition: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pfEndOfStream: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pfEndOfStream: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pb: [*:0]u8,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pb: [*:0]u8,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                // TODO: what to do with BytesParamIndex 1?
                pb: ?*u8,
                cb: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                // TODO: what to do with BytesParamIndex 1?
                pb: ?*u8,
                cb: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pResult: ?*IMFAsyncResult,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pResult: ?*IMFAsyncResult,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pb: [*:0]const u8,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pb: [*:0]const u8,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginWrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                // TODO: what to do with BytesParamIndex 1?
                pb: ?*const u8,
                cb: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                // TODO: what to do with BytesParamIndex 1?
                pb: ?*const u8,
                cb: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndWrite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                pResult: ?*IMFAsyncResult,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                pResult: ?*IMFAsyncResult,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
                SeekOrigin: MFBYTESTREAM_SEEK_ORIGIN,
                llSeekOffset: i64,
                dwSeekFlags: u32,
                pqwCurrentPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
                SeekOrigin: MFBYTESTREAM_SEEK_ORIGIN,
                llSeekOffset: i64,
                dwSeekFlags: u32,
                pqwCurrentPosition: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_GetCapabilities(self: *const T, pdwCapabilities: ?*u32) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IMFByteStream, @ptrCast(self)), pdwCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_GetLength(self: *const T, pqwLength: ?*u64) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMFByteStream, @ptrCast(self)), pqwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_SetLength(self: *const T, qwLength: u64) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).SetLength(@as(*const IMFByteStream, @ptrCast(self)), qwLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_GetCurrentPosition(self: *const T, pqwPosition: ?*u64) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).GetCurrentPosition(@as(*const IMFByteStream, @ptrCast(self)), pqwPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_SetCurrentPosition(self: *const T, qwPosition: u64) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).SetCurrentPosition(@as(*const IMFByteStream, @ptrCast(self)), qwPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_IsEndOfStream(self: *const T, pfEndOfStream: ?*BOOL) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).IsEndOfStream(@as(*const IMFByteStream, @ptrCast(self)), pfEndOfStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_Read(self: *const T, pb: [*:0]u8, cb: u32, pcbRead: ?*u32) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).Read(@as(*const IMFByteStream, @ptrCast(self)), pb, cb, pcbRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_BeginRead(self: *const T, pb: ?*u8, cb: u32, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).BeginRead(@as(*const IMFByteStream, @ptrCast(self)), pb, cb, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_EndRead(self: *const T, pResult: ?*IMFAsyncResult, pcbRead: ?*u32) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).EndRead(@as(*const IMFByteStream, @ptrCast(self)), pResult, pcbRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_Write(self: *const T, pb: [*:0]const u8, cb: u32, pcbWritten: ?*u32) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).Write(@as(*const IMFByteStream, @ptrCast(self)), pb, cb, pcbWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_BeginWrite(self: *const T, pb: ?*const u8, cb: u32, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).BeginWrite(@as(*const IMFByteStream, @ptrCast(self)), pb, cb, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_EndWrite(self: *const T, pResult: ?*IMFAsyncResult, pcbWritten: ?*u32) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).EndWrite(@as(*const IMFByteStream, @ptrCast(self)), pResult, pcbWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_Seek(self: *const T, SeekOrigin: MFBYTESTREAM_SEEK_ORIGIN, llSeekOffset: i64, dwSeekFlags: u32, pqwCurrentPosition: ?*u64) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).Seek(@as(*const IMFByteStream, @ptrCast(self)), SeekOrigin, llSeekOffset, dwSeekFlags, pqwCurrentPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_Flush(self: *const T) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMFByteStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStream_Close(self: *const T) HRESULT {
                return @as(*const IMFByteStream.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFByteStream, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFByteStreamProxyClassFactory_Value = Guid.initString("a6b43f84-5c0a-42e8-a44d-b1857a76992f");
pub const IID_IMFByteStreamProxyClassFactory = &IID_IMFByteStreamProxyClassFactory_Value;
pub const IMFByteStreamProxyClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateByteStreamProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamProxyClassFactory,
                pByteStream: ?*IMFByteStream,
                pAttributes: ?*IMFAttributes,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamProxyClassFactory,
                pByteStream: ?*IMFByteStream,
                pAttributes: ?*IMFAttributes,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamProxyClassFactory_CreateByteStreamProxy(self: *const T, pByteStream: ?*IMFByteStream, pAttributes: ?*IMFAttributes, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFByteStreamProxyClassFactory.VTable, @ptrCast(self.vtable)).CreateByteStreamProxy(@as(*const IMFByteStreamProxyClassFactory, @ptrCast(self)), pByteStream, pAttributes, riid, ppvObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_FILE_ACCESSMODE = enum(i32) {
    READ = 1,
    WRITE = 2,
    READWRITE = 3,
};
pub const MF_ACCESSMODE_READ = MF_FILE_ACCESSMODE.READ;
pub const MF_ACCESSMODE_WRITE = MF_FILE_ACCESSMODE.WRITE;
pub const MF_ACCESSMODE_READWRITE = MF_FILE_ACCESSMODE.READWRITE;

pub const MF_FILE_OPENMODE = enum(i32) {
    FAIL_IF_NOT_EXIST = 0,
    FAIL_IF_EXIST = 1,
    RESET_IF_EXIST = 2,
    APPEND_IF_EXIST = 3,
    DELETE_IF_EXIST = 4,
};
pub const MF_OPENMODE_FAIL_IF_NOT_EXIST = MF_FILE_OPENMODE.FAIL_IF_NOT_EXIST;
pub const MF_OPENMODE_FAIL_IF_EXIST = MF_FILE_OPENMODE.FAIL_IF_EXIST;
pub const MF_OPENMODE_RESET_IF_EXIST = MF_FILE_OPENMODE.RESET_IF_EXIST;
pub const MF_OPENMODE_APPEND_IF_EXIST = MF_FILE_OPENMODE.APPEND_IF_EXIST;
pub const MF_OPENMODE_DELETE_IF_EXIST = MF_FILE_OPENMODE.DELETE_IF_EXIST;

pub const MF_FILE_FLAGS = enum(i32) {
    NONE = 0,
    NOBUFFERING = 1,
    ALLOW_WRITE_SHARING = 2,
};
pub const MF_FILEFLAGS_NONE = MF_FILE_FLAGS.NONE;
pub const MF_FILEFLAGS_NOBUFFERING = MF_FILE_FLAGS.NOBUFFERING;
pub const MF_FILEFLAGS_ALLOW_WRITE_SHARING = MF_FILE_FLAGS.ALLOW_WRITE_SHARING;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSampleOutputStream_Value = Guid.initString("8feed468-6f7e-440d-869a-49bdd283ad0d");
pub const IID_IMFSampleOutputStream = &IID_IMFSampleOutputStream_Value;
pub const IMFSampleOutputStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginWriteSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleOutputStream,
                pSample: ?*IMFSample,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleOutputStream,
                pSample: ?*IMFSample,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndWriteSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleOutputStream,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleOutputStream,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleOutputStream_BeginWriteSample(self: *const T, pSample: ?*IMFSample, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFSampleOutputStream.VTable, @ptrCast(self.vtable)).BeginWriteSample(@as(*const IMFSampleOutputStream, @ptrCast(self)), pSample, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleOutputStream_EndWriteSample(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFSampleOutputStream.VTable, @ptrCast(self.vtable)).EndWriteSample(@as(*const IMFSampleOutputStream, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleOutputStream_Close(self: *const T) HRESULT {
                return @as(*const IMFSampleOutputStream.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFSampleOutputStream, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFCollection_Value = Guid.initString("5bc8a76b-869a-46a3-9b03-fa218a66aebe");
pub const IID_IMFCollection = &IID_IMFCollection_Value;
pub const IMFCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetElementCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCollection,
                pcElements: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCollection,
                pcElements: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCollection,
                dwElementIndex: u32,
                ppUnkElement: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCollection,
                dwElementIndex: u32,
                ppUnkElement: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCollection,
                pUnkElement: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCollection,
                pUnkElement: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCollection,
                dwElementIndex: u32,
                ppUnkElement: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCollection,
                dwElementIndex: u32,
                ppUnkElement: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertElementAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCollection,
                dwIndex: u32,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCollection,
                dwIndex: u32,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCollection_GetElementCount(self: *const T, pcElements: ?*u32) HRESULT {
                return @as(*const IMFCollection.VTable, @ptrCast(self.vtable)).GetElementCount(@as(*const IMFCollection, @ptrCast(self)), pcElements);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCollection_GetElement(self: *const T, dwElementIndex: u32, ppUnkElement: ?*?*IUnknown) HRESULT {
                return @as(*const IMFCollection.VTable, @ptrCast(self.vtable)).GetElement(@as(*const IMFCollection, @ptrCast(self)), dwElementIndex, ppUnkElement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCollection_AddElement(self: *const T, pUnkElement: ?*IUnknown) HRESULT {
                return @as(*const IMFCollection.VTable, @ptrCast(self.vtable)).AddElement(@as(*const IMFCollection, @ptrCast(self)), pUnkElement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCollection_RemoveElement(self: *const T, dwElementIndex: u32, ppUnkElement: ?*?*IUnknown) HRESULT {
                return @as(*const IMFCollection.VTable, @ptrCast(self.vtable)).RemoveElement(@as(*const IMFCollection, @ptrCast(self)), dwElementIndex, ppUnkElement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCollection_InsertElementAt(self: *const T, dwIndex: u32, pUnknown: ?*IUnknown) HRESULT {
                return @as(*const IMFCollection.VTable, @ptrCast(self.vtable)).InsertElementAt(@as(*const IMFCollection, @ptrCast(self)), dwIndex, pUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCollection_RemoveAllElements(self: *const T) HRESULT {
                return @as(*const IMFCollection.VTable, @ptrCast(self.vtable)).RemoveAllElements(@as(*const IMFCollection, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaEventQueue_Value = Guid.initString("36f846fc-2256-48b6-b58e-e2b638316581");
pub const IID_IMFMediaEventQueue = &IID_IMFMediaEventQueue_Value;
pub const IMFMediaEventQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
                dwFlags: u32,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
                dwFlags: u32,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginGetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndGetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
                pResult: ?*IMFAsyncResult,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
                pResult: ?*IMFAsyncResult,
                ppEvent: ?*?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueueEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueueEventParamVar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
                met: u32,
                guidExtendedType: ?*const Guid,
                hrStatus: HRESULT,
                pvValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
                met: u32,
                guidExtendedType: ?*const Guid,
                hrStatus: HRESULT,
                pvValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueueEventParamUnk: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
                met: u32,
                guidExtendedType: ?*const Guid,
                hrStatus: HRESULT,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
                met: u32,
                guidExtendedType: ?*const Guid,
                hrStatus: HRESULT,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEventQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEventQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_GetEvent(self: *const T, dwFlags: u32, ppEvent: ?*?*IMFMediaEvent) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const IMFMediaEventQueue, @ptrCast(self)), dwFlags, ppEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_BeginGetEvent(self: *const T, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).BeginGetEvent(@as(*const IMFMediaEventQueue, @ptrCast(self)), pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_EndGetEvent(self: *const T, pResult: ?*IMFAsyncResult, ppEvent: ?*?*IMFMediaEvent) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).EndGetEvent(@as(*const IMFMediaEventQueue, @ptrCast(self)), pResult, ppEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_QueueEvent(self: *const T, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).QueueEvent(@as(*const IMFMediaEventQueue, @ptrCast(self)), pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_QueueEventParamVar(self: *const T, met: u32, guidExtendedType: ?*const Guid, hrStatus: HRESULT, pvValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).QueueEventParamVar(@as(*const IMFMediaEventQueue, @ptrCast(self)), met, guidExtendedType, hrStatus, pvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_QueueEventParamUnk(self: *const T, met: u32, guidExtendedType: ?*const Guid, hrStatus: HRESULT, pUnk: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).QueueEventParamUnk(@as(*const IMFMediaEventQueue, @ptrCast(self)), met, guidExtendedType, hrStatus, pUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEventQueue_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaEventQueue.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaEventQueue, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFActivate_Value = Guid.initString("7fee9e9a-4a89-47a6-899c-b6a53a70fb67");
pub const IID_IMFActivate = &IID_IMFActivate_Value;
pub const IMFActivate = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        ActivateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFActivate,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFActivate,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShutdownObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFActivate_ActivateObject(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFActivate.VTable, @ptrCast(self.vtable)).ActivateObject(@as(*const IMFActivate, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFActivate_ShutdownObject(self: *const T) HRESULT {
                return @as(*const IMFActivate.VTable, @ptrCast(self.vtable)).ShutdownObject(@as(*const IMFActivate, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFActivate_DetachObject(self: *const T) HRESULT {
                return @as(*const IMFActivate.VTable, @ptrCast(self.vtable)).DetachObject(@as(*const IMFActivate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFPluginControl_Value = Guid.initString("5c6c44bf-1db6-435b-9249-e8cd10fdec96");
pub const IID_IMFPluginControl = &IID_IMFPluginControl_Value;
pub const IMFPluginControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreferredClsid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                selector: ?[*:0]const u16,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                selector: ?[*:0]const u16,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredClsidByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                index: u32,
                selector: ?*?PWSTR,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                index: u32,
                selector: ?*?PWSTR,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreferredClsid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                selector: ?[*:0]const u16,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                selector: ?[*:0]const u16,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDisabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisabledByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                index: u32,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                index: u32,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                clsid: ?*const Guid,
                disabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl,
                pluginType: u32,
                clsid: ?*const Guid,
                disabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl_GetPreferredClsid(self: *const T, pluginType: u32, selector: ?[*:0]const u16, clsid: ?*Guid) HRESULT {
                return @as(*const IMFPluginControl.VTable, @ptrCast(self.vtable)).GetPreferredClsid(@as(*const IMFPluginControl, @ptrCast(self)), pluginType, selector, clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl_GetPreferredClsidByIndex(self: *const T, pluginType: u32, index: u32, selector: ?*?PWSTR, clsid: ?*Guid) HRESULT {
                return @as(*const IMFPluginControl.VTable, @ptrCast(self.vtable)).GetPreferredClsidByIndex(@as(*const IMFPluginControl, @ptrCast(self)), pluginType, index, selector, clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl_SetPreferredClsid(self: *const T, pluginType: u32, selector: ?[*:0]const u16, clsid: ?*const Guid) HRESULT {
                return @as(*const IMFPluginControl.VTable, @ptrCast(self.vtable)).SetPreferredClsid(@as(*const IMFPluginControl, @ptrCast(self)), pluginType, selector, clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl_IsDisabled(self: *const T, pluginType: u32, clsid: ?*const Guid) HRESULT {
                return @as(*const IMFPluginControl.VTable, @ptrCast(self.vtable)).IsDisabled(@as(*const IMFPluginControl, @ptrCast(self)), pluginType, clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl_GetDisabledByIndex(self: *const T, pluginType: u32, index: u32, clsid: ?*Guid) HRESULT {
                return @as(*const IMFPluginControl.VTable, @ptrCast(self.vtable)).GetDisabledByIndex(@as(*const IMFPluginControl, @ptrCast(self)), pluginType, index, clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl_SetDisabled(self: *const T, pluginType: u32, clsid: ?*const Guid, disabled: BOOL) HRESULT {
                return @as(*const IMFPluginControl.VTable, @ptrCast(self.vtable)).SetDisabled(@as(*const IMFPluginControl, @ptrCast(self)), pluginType, clsid, disabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_PLUGIN_CONTROL_POLICY = enum(i32) {
    ALL_PLUGINS = 0,
    APPROVED_PLUGINS = 1,
    WEB_PLUGINS = 2,
    WEB_PLUGINS_EDGEMODE = 3,
};
pub const MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS = MF_PLUGIN_CONTROL_POLICY.ALL_PLUGINS;
pub const MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS = MF_PLUGIN_CONTROL_POLICY.APPROVED_PLUGINS;
pub const MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS = MF_PLUGIN_CONTROL_POLICY.WEB_PLUGINS;
pub const MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE = MF_PLUGIN_CONTROL_POLICY.WEB_PLUGINS_EDGEMODE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFPluginControl2_Value = Guid.initString("c6982083-3ddc-45cb-af5e-0f7a8ce4de77");
pub const IID_IMFPluginControl2 = &IID_IMFPluginControl2_Value;
pub const IMFPluginControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFPluginControl.VTable,
        SetPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPluginControl2,
                policy: MF_PLUGIN_CONTROL_POLICY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPluginControl2,
                policy: MF_PLUGIN_CONTROL_POLICY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFPluginControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPluginControl2_SetPolicy(self: *const T, policy: MF_PLUGIN_CONTROL_POLICY) HRESULT {
                return @as(*const IMFPluginControl2.VTable, @ptrCast(self.vtable)).SetPolicy(@as(*const IMFPluginControl2, @ptrCast(self)), policy);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFDXGIDeviceManager_Value = Guid.initString("eb533d5d-2db6-40f8-97a9-494692014f07");
pub const IID_IMFDXGIDeviceManager = &IID_IMFDXGIDeviceManager_Value;
pub const IMFDXGIDeviceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloseDeviceHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
                riid: ?*const Guid,
                ppService: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
                riid: ?*const Guid,
                ppService: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
                riid: ?*const Guid,
                ppUnkDevice: ?*?*anyopaque,
                fBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
                riid: ?*const Guid,
                ppUnkDevice: ?*?*anyopaque,
                fBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDeviceHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                phDevice: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                phDevice: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                pUnkDevice: ?*IUnknown,
                resetToken: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                pUnkDevice: ?*IUnknown,
                resetToken: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
                fSaveState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManager,
                hDevice: ?HANDLE,
                fSaveState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_CloseDeviceHandle(self: *const T, hDevice: ?HANDLE) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).CloseDeviceHandle(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), hDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_GetVideoService(self: *const T, hDevice: ?HANDLE, riid: ?*const Guid, ppService: ?*?*anyopaque) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).GetVideoService(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), hDevice, riid, ppService);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_LockDevice(self: *const T, hDevice: ?HANDLE, riid: ?*const Guid, ppUnkDevice: ?*?*anyopaque, fBlock: BOOL) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).LockDevice(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), hDevice, riid, ppUnkDevice, fBlock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_OpenDeviceHandle(self: *const T, phDevice: ?*?HANDLE) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).OpenDeviceHandle(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), phDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_ResetDevice(self: *const T, pUnkDevice: ?*IUnknown, resetToken: u32) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).ResetDevice(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), pUnkDevice, resetToken);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_TestDevice(self: *const T, hDevice: ?HANDLE) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).TestDevice(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), hDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManager_UnlockDevice(self: *const T, hDevice: ?HANDLE, fSaveState: BOOL) HRESULT {
                return @as(*const IMFDXGIDeviceManager.VTable, @ptrCast(self.vtable)).UnlockDevice(@as(*const IMFDXGIDeviceManager, @ptrCast(self)), hDevice, fSaveState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_STREAM_STATE = enum(i32) {
    STOPPED = 0,
    PAUSED = 1,
    RUNNING = 2,
};
pub const MF_STREAM_STATE_STOPPED = MF_STREAM_STATE.STOPPED;
pub const MF_STREAM_STATE_PAUSED = MF_STREAM_STATE.PAUSED;
pub const MF_STREAM_STATE_RUNNING = MF_STREAM_STATE.RUNNING;

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFMuxStreamAttributesManager_Value = Guid.initString("ce8bd576-e440-43b3-be34-1e53f565f7e8");
pub const IID_IMFMuxStreamAttributesManager = &IID_IMFMuxStreamAttributesManager_Value;
pub const IMFMuxStreamAttributesManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamAttributesManager,
                pdwMuxStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamAttributesManager,
                pdwMuxStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamAttributesManager,
                dwMuxStreamIndex: u32,
                ppStreamAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamAttributesManager,
                dwMuxStreamIndex: u32,
                ppStreamAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamAttributesManager_GetStreamCount(self: *const T, pdwMuxStreamCount: ?*u32) HRESULT {
                return @as(*const IMFMuxStreamAttributesManager.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFMuxStreamAttributesManager, @ptrCast(self)), pdwMuxStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamAttributesManager_GetAttributes(self: *const T, dwMuxStreamIndex: u32, ppStreamAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFMuxStreamAttributesManager.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IMFMuxStreamAttributesManager, @ptrCast(self)), dwMuxStreamIndex, ppStreamAttributes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFMuxStreamMediaTypeManager_Value = Guid.initString("505a2c72-42f7-4690-aeab-8f513d0ffdb8");
pub const IID_IMFMuxStreamMediaTypeManager = &IID_IMFMuxStreamMediaTypeManager_Value;
pub const IMFMuxStreamMediaTypeManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamMediaTypeManager,
                pdwMuxStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamMediaTypeManager,
                pdwMuxStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamMediaTypeManager,
                dwMuxStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamMediaTypeManager,
                dwMuxStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamConfigurationCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamMediaTypeManager,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamMediaTypeManager,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStreamConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamMediaTypeManager,
                ullStreamMask: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamMediaTypeManager,
                ullStreamMask: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamMediaTypeManager,
                ullStreamMask: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamMediaTypeManager,
                ullStreamMask: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamMediaTypeManager,
                ulIndex: u32,
                pullStreamMask: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamMediaTypeManager,
                ulIndex: u32,
                pullStreamMask: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamMediaTypeManager_GetStreamCount(self: *const T, pdwMuxStreamCount: ?*u32) HRESULT {
                return @as(*const IMFMuxStreamMediaTypeManager.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFMuxStreamMediaTypeManager, @ptrCast(self)), pdwMuxStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamMediaTypeManager_GetMediaType(self: *const T, dwMuxStreamIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFMuxStreamMediaTypeManager.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IMFMuxStreamMediaTypeManager, @ptrCast(self)), dwMuxStreamIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamMediaTypeManager_GetStreamConfigurationCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFMuxStreamMediaTypeManager.VTable, @ptrCast(self.vtable)).GetStreamConfigurationCount(@as(*const IMFMuxStreamMediaTypeManager, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamMediaTypeManager_AddStreamConfiguration(self: *const T, ullStreamMask: u64) HRESULT {
                return @as(*const IMFMuxStreamMediaTypeManager.VTable, @ptrCast(self.vtable)).AddStreamConfiguration(@as(*const IMFMuxStreamMediaTypeManager, @ptrCast(self)), ullStreamMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamMediaTypeManager_RemoveStreamConfiguration(self: *const T, ullStreamMask: u64) HRESULT {
                return @as(*const IMFMuxStreamMediaTypeManager.VTable, @ptrCast(self.vtable)).RemoveStreamConfiguration(@as(*const IMFMuxStreamMediaTypeManager, @ptrCast(self)), ullStreamMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamMediaTypeManager_GetStreamConfiguration(self: *const T, ulIndex: u32, pullStreamMask: ?*u64) HRESULT {
                return @as(*const IMFMuxStreamMediaTypeManager.VTable, @ptrCast(self.vtable)).GetStreamConfiguration(@as(*const IMFMuxStreamMediaTypeManager, @ptrCast(self)), ulIndex, pullStreamMask);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFMuxStreamSampleManager_Value = Guid.initString("74abbc19-b1cc-4e41-bb8b-9d9b86a8f6ca");
pub const IID_IMFMuxStreamSampleManager = &IID_IMFMuxStreamSampleManager_Value;
pub const IMFMuxStreamSampleManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamSampleManager,
                pdwMuxStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamSampleManager,
                pdwMuxStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamSampleManager,
                dwMuxStreamIndex: u32,
                ppSample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMuxStreamSampleManager,
                dwMuxStreamIndex: u32,
                ppSample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMuxStreamSampleManager,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn (
                self: *const IMFMuxStreamSampleManager,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamSampleManager_GetStreamCount(self: *const T, pdwMuxStreamCount: ?*u32) HRESULT {
                return @as(*const IMFMuxStreamSampleManager.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFMuxStreamSampleManager, @ptrCast(self)), pdwMuxStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamSampleManager_GetSample(self: *const T, dwMuxStreamIndex: u32, ppSample: ?*?*IMFSample) HRESULT {
                return @as(*const IMFMuxStreamSampleManager.VTable, @ptrCast(self.vtable)).GetSample(@as(*const IMFMuxStreamSampleManager, @ptrCast(self)), dwMuxStreamIndex, ppSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMuxStreamSampleManager_GetStreamConfiguration(self: *const T) u64 {
                return @as(*const IMFMuxStreamSampleManager.VTable, @ptrCast(self.vtable)).GetStreamConfiguration(@as(*const IMFMuxStreamSampleManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSecureBuffer_Value = Guid.initString("c1209904-e584-4752-a2d6-7f21693f8b21");
pub const IID_IMFSecureBuffer = &IID_IMFSecureBuffer_Value;
pub const IMFSecureBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSecureBuffer,
                pGuidIdentifier: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSecureBuffer,
                pGuidIdentifier: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSecureBuffer_GetIdentifier(self: *const T, pGuidIdentifier: ?*Guid) HRESULT {
                return @as(*const IMFSecureBuffer.VTable, @ptrCast(self.vtable)).GetIdentifier(@as(*const IMFSecureBuffer, @ptrCast(self)), pGuidIdentifier);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _MFT_INPUT_DATA_BUFFER_FLAGS = enum(i32) {
    R = -1,
};
pub const MFT_INPUT_DATA_BUFFER_PLACEHOLDER = _MFT_INPUT_DATA_BUFFER_FLAGS.R;

pub const _MFT_OUTPUT_DATA_BUFFER_FLAGS = enum(i32) {
    INCOMPLETE = 16777216,
    FORMAT_CHANGE = 256,
    STREAM_END = 512,
    NO_SAMPLE = 768,
};
pub const MFT_OUTPUT_DATA_BUFFER_INCOMPLETE = _MFT_OUTPUT_DATA_BUFFER_FLAGS.INCOMPLETE;
pub const MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE = _MFT_OUTPUT_DATA_BUFFER_FLAGS.FORMAT_CHANGE;
pub const MFT_OUTPUT_DATA_BUFFER_STREAM_END = _MFT_OUTPUT_DATA_BUFFER_FLAGS.STREAM_END;
pub const MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE = _MFT_OUTPUT_DATA_BUFFER_FLAGS.NO_SAMPLE;

pub const _MFT_INPUT_STATUS_FLAGS = enum(i32) {
    A = 1,
};
pub const MFT_INPUT_STATUS_ACCEPT_DATA = _MFT_INPUT_STATUS_FLAGS.A;

pub const _MFT_OUTPUT_STATUS_FLAGS = enum(i32) {
    Y = 1,
};
pub const MFT_OUTPUT_STATUS_SAMPLE_READY = _MFT_OUTPUT_STATUS_FLAGS.Y;

pub const _MFT_INPUT_STREAM_INFO_FLAGS = enum(i32) {
    WHOLE_SAMPLES = 1,
    SINGLE_SAMPLE_PER_BUFFER = 2,
    FIXED_SAMPLE_SIZE = 4,
    HOLDS_BUFFERS = 8,
    DOES_NOT_ADDREF = 256,
    REMOVABLE = 512,
    OPTIONAL = 1024,
    PROCESSES_IN_PLACE = 2048,
};
pub const MFT_INPUT_STREAM_WHOLE_SAMPLES = _MFT_INPUT_STREAM_INFO_FLAGS.WHOLE_SAMPLES;
pub const MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = _MFT_INPUT_STREAM_INFO_FLAGS.SINGLE_SAMPLE_PER_BUFFER;
pub const MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE = _MFT_INPUT_STREAM_INFO_FLAGS.FIXED_SAMPLE_SIZE;
pub const MFT_INPUT_STREAM_HOLDS_BUFFERS = _MFT_INPUT_STREAM_INFO_FLAGS.HOLDS_BUFFERS;
pub const MFT_INPUT_STREAM_DOES_NOT_ADDREF = _MFT_INPUT_STREAM_INFO_FLAGS.DOES_NOT_ADDREF;
pub const MFT_INPUT_STREAM_REMOVABLE = _MFT_INPUT_STREAM_INFO_FLAGS.REMOVABLE;
pub const MFT_INPUT_STREAM_OPTIONAL = _MFT_INPUT_STREAM_INFO_FLAGS.OPTIONAL;
pub const MFT_INPUT_STREAM_PROCESSES_IN_PLACE = _MFT_INPUT_STREAM_INFO_FLAGS.PROCESSES_IN_PLACE;

pub const _MFT_OUTPUT_STREAM_INFO_FLAGS = enum(i32) {
    WHOLE_SAMPLES = 1,
    SINGLE_SAMPLE_PER_BUFFER = 2,
    FIXED_SAMPLE_SIZE = 4,
    DISCARDABLE = 8,
    OPTIONAL = 16,
    PROVIDES_SAMPLES = 256,
    CAN_PROVIDE_SAMPLES = 512,
    LAZY_READ = 1024,
    REMOVABLE = 2048,
};
pub const MFT_OUTPUT_STREAM_WHOLE_SAMPLES = _MFT_OUTPUT_STREAM_INFO_FLAGS.WHOLE_SAMPLES;
pub const MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = _MFT_OUTPUT_STREAM_INFO_FLAGS.SINGLE_SAMPLE_PER_BUFFER;
pub const MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE = _MFT_OUTPUT_STREAM_INFO_FLAGS.FIXED_SAMPLE_SIZE;
pub const MFT_OUTPUT_STREAM_DISCARDABLE = _MFT_OUTPUT_STREAM_INFO_FLAGS.DISCARDABLE;
pub const MFT_OUTPUT_STREAM_OPTIONAL = _MFT_OUTPUT_STREAM_INFO_FLAGS.OPTIONAL;
pub const MFT_OUTPUT_STREAM_PROVIDES_SAMPLES = _MFT_OUTPUT_STREAM_INFO_FLAGS.PROVIDES_SAMPLES;
pub const MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES = _MFT_OUTPUT_STREAM_INFO_FLAGS.CAN_PROVIDE_SAMPLES;
pub const MFT_OUTPUT_STREAM_LAZY_READ = _MFT_OUTPUT_STREAM_INFO_FLAGS.LAZY_READ;
pub const MFT_OUTPUT_STREAM_REMOVABLE = _MFT_OUTPUT_STREAM_INFO_FLAGS.REMOVABLE;

pub const _MFT_SET_TYPE_FLAGS = enum(i32) {
    Y = 1,
};
pub const MFT_SET_TYPE_TEST_ONLY = _MFT_SET_TYPE_FLAGS.Y;

pub const _MFT_PROCESS_OUTPUT_FLAGS = enum(i32) {
    DISCARD_WHEN_NO_BUFFER = 1,
    REGENERATE_LAST_OUTPUT = 2,
};
pub const MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = _MFT_PROCESS_OUTPUT_FLAGS.DISCARD_WHEN_NO_BUFFER;
pub const MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT = _MFT_PROCESS_OUTPUT_FLAGS.REGENERATE_LAST_OUTPUT;

pub const _MFT_PROCESS_OUTPUT_STATUS = enum(i32) {
    S = 256,
};
pub const MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS = _MFT_PROCESS_OUTPUT_STATUS.S;

pub const MFT_DRAIN_TYPE = enum(i32) {
    PRODUCE_TAILS = 0,
    NO_TAILS = 1,
};
pub const MFT_DRAIN_PRODUCE_TAILS = MFT_DRAIN_TYPE.PRODUCE_TAILS;
pub const MFT_DRAIN_NO_TAILS = MFT_DRAIN_TYPE.NO_TAILS;

pub const MFT_MESSAGE_TYPE = enum(i32) {
    COMMAND_FLUSH = 0,
    COMMAND_DRAIN = 1,
    SET_D3D_MANAGER = 2,
    DROP_SAMPLES = 3,
    COMMAND_TICK = 4,
    NOTIFY_BEGIN_STREAMING = 268435456,
    NOTIFY_END_STREAMING = 268435457,
    NOTIFY_END_OF_STREAM = 268435458,
    NOTIFY_START_OF_STREAM = 268435459,
    NOTIFY_RELEASE_RESOURCES = 268435460,
    NOTIFY_REACQUIRE_RESOURCES = 268435461,
    NOTIFY_EVENT = 268435462,
    COMMAND_SET_OUTPUT_STREAM_STATE = 268435463,
    COMMAND_FLUSH_OUTPUT_STREAM = 268435464,
    COMMAND_MARKER = 536870912,
};
pub const MFT_MESSAGE_COMMAND_FLUSH = MFT_MESSAGE_TYPE.COMMAND_FLUSH;
pub const MFT_MESSAGE_COMMAND_DRAIN = MFT_MESSAGE_TYPE.COMMAND_DRAIN;
pub const MFT_MESSAGE_SET_D3D_MANAGER = MFT_MESSAGE_TYPE.SET_D3D_MANAGER;
pub const MFT_MESSAGE_DROP_SAMPLES = MFT_MESSAGE_TYPE.DROP_SAMPLES;
pub const MFT_MESSAGE_COMMAND_TICK = MFT_MESSAGE_TYPE.COMMAND_TICK;
pub const MFT_MESSAGE_NOTIFY_BEGIN_STREAMING = MFT_MESSAGE_TYPE.NOTIFY_BEGIN_STREAMING;
pub const MFT_MESSAGE_NOTIFY_END_STREAMING = MFT_MESSAGE_TYPE.NOTIFY_END_STREAMING;
pub const MFT_MESSAGE_NOTIFY_END_OF_STREAM = MFT_MESSAGE_TYPE.NOTIFY_END_OF_STREAM;
pub const MFT_MESSAGE_NOTIFY_START_OF_STREAM = MFT_MESSAGE_TYPE.NOTIFY_START_OF_STREAM;
pub const MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES = MFT_MESSAGE_TYPE.NOTIFY_RELEASE_RESOURCES;
pub const MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES = MFT_MESSAGE_TYPE.NOTIFY_REACQUIRE_RESOURCES;
pub const MFT_MESSAGE_NOTIFY_EVENT = MFT_MESSAGE_TYPE.NOTIFY_EVENT;
pub const MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE = MFT_MESSAGE_TYPE.COMMAND_SET_OUTPUT_STREAM_STATE;
pub const MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM = MFT_MESSAGE_TYPE.COMMAND_FLUSH_OUTPUT_STREAM;
pub const MFT_MESSAGE_COMMAND_MARKER = MFT_MESSAGE_TYPE.COMMAND_MARKER;

pub const MFT_INPUT_STREAM_INFO = extern struct {
    hnsMaxLatency: i64,
    dwFlags: u32,
    cbSize: u32,
    cbMaxLookahead: u32,
    cbAlignment: u32,
};

pub const MFT_OUTPUT_STREAM_INFO = extern struct {
    dwFlags: u32,
    cbSize: u32,
    cbAlignment: u32,
};

pub const MFT_OUTPUT_DATA_BUFFER = extern struct {
    dwStreamID: u32,
    pSample: ?*IMFSample,
    dwStatus: u32,
    pEvents: ?*IMFCollection,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTransform_Value = Guid.initString("bf94c121-5b05-4e6f-8000-ba598961414d");
pub const IID_IMFTransform = &IID_IMFTransform_Value;
pub const IMFTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                pdwInputMinimum: ?*u32,
                pdwInputMaximum: ?*u32,
                pdwOutputMinimum: ?*u32,
                pdwOutputMaximum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                pdwInputMinimum: ?*u32,
                pdwInputMaximum: ?*u32,
                pdwOutputMinimum: ?*u32,
                pdwOutputMaximum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                pcInputStreams: ?*u32,
                pcOutputStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                pcInputStreams: ?*u32,
                pcOutputStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputIDArraySize: u32,
                pdwInputIDs: [*]u32,
                dwOutputIDArraySize: u32,
                pdwOutputIDs: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputIDArraySize: u32,
                pdwInputIDs: [*]u32,
                dwOutputIDArraySize: u32,
                pdwOutputIDs: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStreamInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pStreamInfo: ?*MFT_INPUT_STREAM_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pStreamInfo: ?*MFT_INPUT_STREAM_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                pStreamInfo: ?*MFT_OUTPUT_STREAM_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                pStreamInfo: ?*MFT_OUTPUT_STREAM_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                pAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                pAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStreamAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                pAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                pAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteInputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwStreamID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwStreamID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddInputStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                cStreams: u32,
                adwStreamIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                cStreams: u32,
                adwStreamIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputAvailableType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                dwTypeIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                dwTypeIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputAvailableType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                dwTypeIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                dwTypeIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pType: ?*IMFMediaType,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pType: ?*IMFMediaType,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                pType: ?*IMFMediaType,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                pType: ?*IMFMediaType,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCurrentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCurrentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwOutputStreamID: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                hnsLowerBound: i64,
                hnsUpperBound: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                hnsLowerBound: i64,
                hnsUpperBound: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                eMessage: MFT_MESSAGE_TYPE,
                ulParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                eMessage: MFT_MESSAGE_TYPE,
                ulParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pSample: ?*IMFSample,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwInputStreamID: u32,
                pSample: ?*IMFSample,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTransform,
                dwFlags: u32,
                cOutputBufferCount: u32,
                pOutputSamples: [*]MFT_OUTPUT_DATA_BUFFER,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTransform,
                dwFlags: u32,
                cOutputBufferCount: u32,
                pOutputSamples: [*]MFT_OUTPUT_DATA_BUFFER,
                pdwStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetStreamLimits(self: *const T, pdwInputMinimum: ?*u32, pdwInputMaximum: ?*u32, pdwOutputMinimum: ?*u32, pdwOutputMaximum: ?*u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetStreamLimits(@as(*const IMFTransform, @ptrCast(self)), pdwInputMinimum, pdwInputMaximum, pdwOutputMinimum, pdwOutputMaximum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetStreamCount(self: *const T, pcInputStreams: ?*u32, pcOutputStreams: ?*u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFTransform, @ptrCast(self)), pcInputStreams, pcOutputStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetStreamIDs(self: *const T, dwInputIDArraySize: u32, pdwInputIDs: [*]u32, dwOutputIDArraySize: u32, pdwOutputIDs: [*]u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetStreamIDs(@as(*const IMFTransform, @ptrCast(self)), dwInputIDArraySize, pdwInputIDs, dwOutputIDArraySize, pdwOutputIDs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetInputStreamInfo(self: *const T, dwInputStreamID: u32, pStreamInfo: ?*MFT_INPUT_STREAM_INFO) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetInputStreamInfo(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, pStreamInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetOutputStreamInfo(self: *const T, dwOutputStreamID: u32, pStreamInfo: ?*MFT_OUTPUT_STREAM_INFO) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetOutputStreamInfo(@as(*const IMFTransform, @ptrCast(self)), dwOutputStreamID, pStreamInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetAttributes(self: *const T, pAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetAttributes(@as(*const IMFTransform, @ptrCast(self)), pAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetInputStreamAttributes(self: *const T, dwInputStreamID: u32, pAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetInputStreamAttributes(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, pAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetOutputStreamAttributes(self: *const T, dwOutputStreamID: u32, pAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetOutputStreamAttributes(@as(*const IMFTransform, @ptrCast(self)), dwOutputStreamID, pAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_DeleteInputStream(self: *const T, dwStreamID: u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).DeleteInputStream(@as(*const IMFTransform, @ptrCast(self)), dwStreamID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_AddInputStreams(self: *const T, cStreams: u32, adwStreamIDs: ?*u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).AddInputStreams(@as(*const IMFTransform, @ptrCast(self)), cStreams, adwStreamIDs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetInputAvailableType(self: *const T, dwInputStreamID: u32, dwTypeIndex: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetInputAvailableType(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, dwTypeIndex, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetOutputAvailableType(self: *const T, dwOutputStreamID: u32, dwTypeIndex: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetOutputAvailableType(@as(*const IMFTransform, @ptrCast(self)), dwOutputStreamID, dwTypeIndex, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_SetInputType(self: *const T, dwInputStreamID: u32, pType: ?*IMFMediaType, dwFlags: u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).SetInputType(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, pType, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_SetOutputType(self: *const T, dwOutputStreamID: u32, pType: ?*IMFMediaType, dwFlags: u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).SetOutputType(@as(*const IMFTransform, @ptrCast(self)), dwOutputStreamID, pType, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetInputCurrentType(self: *const T, dwInputStreamID: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetInputCurrentType(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetOutputCurrentType(self: *const T, dwOutputStreamID: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetOutputCurrentType(@as(*const IMFTransform, @ptrCast(self)), dwOutputStreamID, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetInputStatus(self: *const T, dwInputStreamID: u32, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetInputStatus(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_GetOutputStatus(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).GetOutputStatus(@as(*const IMFTransform, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_SetOutputBounds(self: *const T, hnsLowerBound: i64, hnsUpperBound: i64) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).SetOutputBounds(@as(*const IMFTransform, @ptrCast(self)), hnsLowerBound, hnsUpperBound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_ProcessEvent(self: *const T, dwInputStreamID: u32, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).ProcessEvent(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_ProcessMessage(self: *const T, eMessage: MFT_MESSAGE_TYPE, ulParam: usize) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).ProcessMessage(@as(*const IMFTransform, @ptrCast(self)), eMessage, ulParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_ProcessInput(self: *const T, dwInputStreamID: u32, pSample: ?*IMFSample, dwFlags: u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).ProcessInput(@as(*const IMFTransform, @ptrCast(self)), dwInputStreamID, pSample, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTransform_ProcessOutput(self: *const T, dwFlags: u32, cOutputBufferCount: u32, pOutputSamples: [*]MFT_OUTPUT_DATA_BUFFER, pdwStatus: ?*u32) HRESULT {
                return @as(*const IMFTransform.VTable, @ptrCast(self.vtable)).ProcessOutput(@as(*const IMFTransform, @ptrCast(self)), dwFlags, cOutputBufferCount, pOutputSamples, pdwStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DeviceStreamState = enum(i32) {
    Stop = 0,
    Pause = 1,
    Run = 2,
    Disabled = 3,
};
pub const DeviceStreamState_Stop = DeviceStreamState.Stop;
pub const DeviceStreamState_Pause = DeviceStreamState.Pause;
pub const DeviceStreamState_Run = DeviceStreamState.Run;
pub const DeviceStreamState_Disabled = DeviceStreamState.Disabled;

pub const STREAM_MEDIUM = extern struct {
    gidMedium: Guid,
    unMediumInstance: u32,
};

pub const MF3DVideoOutputType = enum(i32) {
    BaseView = 0,
    Stereo = 1,
};
pub const MF3DVideoOutputType_BaseView = MF3DVideoOutputType.BaseView;
pub const MF3DVideoOutputType_Stereo = MF3DVideoOutputType.Stereo;

pub const MFT_AUDIO_DECODER_DEGRADATION_REASON = enum(i32) {
    NONE = 0,
    LICENSING_REQUIREMENT = 1,
};
pub const MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE = MFT_AUDIO_DECODER_DEGRADATION_REASON.NONE;
pub const MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT = MFT_AUDIO_DECODER_DEGRADATION_REASON.LICENSING_REQUIREMENT;

pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE = enum(i32) {
    NONE = 0,
    DOWNMIX2CHANNEL = 1,
    DOWNMIX6CHANNEL = 2,
    DOWNMIX8CHANNEL = 3,
};
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE = MFT_AUDIO_DECODER_DEGRADATION_TYPE.NONE;
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL = MFT_AUDIO_DECODER_DEGRADATION_TYPE.DOWNMIX2CHANNEL;
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL = MFT_AUDIO_DECODER_DEGRADATION_TYPE.DOWNMIX6CHANNEL;
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL = MFT_AUDIO_DECODER_DEGRADATION_TYPE.DOWNMIX8CHANNEL;

pub const MFAudioDecoderDegradationInfo = extern struct {
    eDegradationReason: MFT_AUDIO_DECODER_DEGRADATION_REASON,
    eType: MFT_AUDIO_DECODER_DEGRADATION_TYPE,
};

pub const MFT_STREAM_STATE_PARAM = extern struct {
    StreamId: u32,
    State: MF_STREAM_STATE,
};

pub const MFSESSION_SETTOPOLOGY_FLAGS = enum(i32) {
    IMMEDIATE = 1,
    NORESOLUTION = 2,
    CLEAR_CURRENT = 4,
};
pub const MFSESSION_SETTOPOLOGY_IMMEDIATE = MFSESSION_SETTOPOLOGY_FLAGS.IMMEDIATE;
pub const MFSESSION_SETTOPOLOGY_NORESOLUTION = MFSESSION_SETTOPOLOGY_FLAGS.NORESOLUTION;
pub const MFSESSION_SETTOPOLOGY_CLEAR_CURRENT = MFSESSION_SETTOPOLOGY_FLAGS.CLEAR_CURRENT;

pub const MFSESSION_GETFULLTOPOLOGY_FLAGS = enum(i32) {
    T = 1,
};
pub const MFSESSION_GETFULLTOPOLOGY_CURRENT = MFSESSION_GETFULLTOPOLOGY_FLAGS.T;

pub const MFPMPSESSION_CREATION_FLAGS = enum(i32) {
    UNPROTECTED_PROCESS = 1,
    IN_PROCESS = 2,
};
pub const MFPMPSESSION_UNPROTECTED_PROCESS = MFPMPSESSION_CREATION_FLAGS.UNPROTECTED_PROCESS;
pub const MFPMPSESSION_IN_PROCESS = MFPMPSESSION_CREATION_FLAGS.IN_PROCESS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaSession_Value = Guid.initString("90377834-21d0-4dee-8214-ba2e3e6c1127");
pub const IID_IMFMediaSession = &IID_IMFMediaSession_Value;
pub const IMFMediaSession = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        SetTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
                dwSetTopologyFlags: u32,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
                dwSetTopologyFlags: u32,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearTopologies: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
                pguidTimeFormat: ?*const Guid,
                pvarStartPosition: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
                pguidTimeFormat: ?*const Guid,
                pvarStartPosition: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
                ppClock: ?*?*IMFClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
                ppClock: ?*?*IMFClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSessionCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
                pdwCaps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
                pdwCaps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSession,
                dwGetFullTopologyFlags: u32,
                TopoId: u64,
                ppFullTopology: ?*?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSession,
                dwGetFullTopologyFlags: u32,
                TopoId: u64,
                ppFullTopology: ?*?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_SetTopology(self: *const T, dwSetTopologyFlags: u32, pTopology: ?*IMFTopology) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).SetTopology(@as(*const IMFMediaSession, @ptrCast(self)), dwSetTopologyFlags, pTopology);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_ClearTopologies(self: *const T) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).ClearTopologies(@as(*const IMFMediaSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_Start(self: *const T, pguidTimeFormat: ?*const Guid, pvarStartPosition: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).Start(@as(*const IMFMediaSession, @ptrCast(self)), pguidTimeFormat, pvarStartPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_Pause(self: *const T) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMFMediaSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_Stop(self: *const T) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFMediaSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_Close(self: *const T) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFMediaSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_GetClock(self: *const T, ppClock: ?*?*IMFClock) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).GetClock(@as(*const IMFMediaSession, @ptrCast(self)), ppClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_GetSessionCapabilities(self: *const T, pdwCaps: ?*u32) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).GetSessionCapabilities(@as(*const IMFMediaSession, @ptrCast(self)), pdwCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSession_GetFullTopology(self: *const T, dwGetFullTopologyFlags: u32, TopoId: u64, ppFullTopology: ?*?*IMFTopology) HRESULT {
                return @as(*const IMFMediaSession.VTable, @ptrCast(self.vtable)).GetFullTopology(@as(*const IMFMediaSession, @ptrCast(self)), dwGetFullTopologyFlags, TopoId, ppFullTopology);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_OBJECT_TYPE = enum(i32) {
    MEDIASOURCE = 0,
    BYTESTREAM = 1,
    INVALID = 2,
};
pub const MF_OBJECT_MEDIASOURCE = MF_OBJECT_TYPE.MEDIASOURCE;
pub const MF_OBJECT_BYTESTREAM = MF_OBJECT_TYPE.BYTESTREAM;
pub const MF_OBJECT_INVALID = MF_OBJECT_TYPE.INVALID;

pub const MF_RESOLUTION_FLAGS = enum(u32) {
    MEDIASOURCE = 1,
    BYTESTREAM = 2,
    CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = 16,
    KEEP_BYTE_STREAM_ALIVE_ON_FAIL = 32,
    DISABLE_LOCAL_PLUGINS = 64,
    PLUGIN_CONTROL_POLICY_APPROVED_ONLY = 128,
    PLUGIN_CONTROL_POLICY_WEB_ONLY = 256,
    PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE = 512,
    ENABLE_STORE_PLUGINS = 1024,
    READ = 65536,
    WRITE = 131072,
    _,
    pub fn initFlags(o: struct {
        MEDIASOURCE: u1 = 0,
        BYTESTREAM: u1 = 0,
        CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE: u1 = 0,
        KEEP_BYTE_STREAM_ALIVE_ON_FAIL: u1 = 0,
        DISABLE_LOCAL_PLUGINS: u1 = 0,
        PLUGIN_CONTROL_POLICY_APPROVED_ONLY: u1 = 0,
        PLUGIN_CONTROL_POLICY_WEB_ONLY: u1 = 0,
        PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE: u1 = 0,
        ENABLE_STORE_PLUGINS: u1 = 0,
        READ: u1 = 0,
        WRITE: u1 = 0,
    }) MF_RESOLUTION_FLAGS {
        return @as(MF_RESOLUTION_FLAGS, @enumFromInt((if (o.MEDIASOURCE == 1) @intFromEnum(MF_RESOLUTION_FLAGS.MEDIASOURCE) else 0) | (if (o.BYTESTREAM == 1) @intFromEnum(MF_RESOLUTION_FLAGS.BYTESTREAM) else 0) | (if (o.CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE == 1) @intFromEnum(MF_RESOLUTION_FLAGS.CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE) else 0) | (if (o.KEEP_BYTE_STREAM_ALIVE_ON_FAIL == 1) @intFromEnum(MF_RESOLUTION_FLAGS.KEEP_BYTE_STREAM_ALIVE_ON_FAIL) else 0) | (if (o.DISABLE_LOCAL_PLUGINS == 1) @intFromEnum(MF_RESOLUTION_FLAGS.DISABLE_LOCAL_PLUGINS) else 0) | (if (o.PLUGIN_CONTROL_POLICY_APPROVED_ONLY == 1) @intFromEnum(MF_RESOLUTION_FLAGS.PLUGIN_CONTROL_POLICY_APPROVED_ONLY) else 0) | (if (o.PLUGIN_CONTROL_POLICY_WEB_ONLY == 1) @intFromEnum(MF_RESOLUTION_FLAGS.PLUGIN_CONTROL_POLICY_WEB_ONLY) else 0) | (if (o.PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE == 1) @intFromEnum(MF_RESOLUTION_FLAGS.PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE) else 0) | (if (o.ENABLE_STORE_PLUGINS == 1) @intFromEnum(MF_RESOLUTION_FLAGS.ENABLE_STORE_PLUGINS) else 0) | (if (o.READ == 1) @intFromEnum(MF_RESOLUTION_FLAGS.READ) else 0) | (if (o.WRITE == 1) @intFromEnum(MF_RESOLUTION_FLAGS.WRITE) else 0)));
    }
};
pub const MF_RESOLUTION_MEDIASOURCE = MF_RESOLUTION_FLAGS.MEDIASOURCE;
pub const MF_RESOLUTION_BYTESTREAM = MF_RESOLUTION_FLAGS.BYTESTREAM;
pub const MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = MF_RESOLUTION_FLAGS.CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE;
pub const MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL = MF_RESOLUTION_FLAGS.KEEP_BYTE_STREAM_ALIVE_ON_FAIL;
pub const MF_RESOLUTION_DISABLE_LOCAL_PLUGINS = MF_RESOLUTION_FLAGS.DISABLE_LOCAL_PLUGINS;
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY = MF_RESOLUTION_FLAGS.PLUGIN_CONTROL_POLICY_APPROVED_ONLY;
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY = MF_RESOLUTION_FLAGS.PLUGIN_CONTROL_POLICY_WEB_ONLY;
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE = MF_RESOLUTION_FLAGS.PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE;
pub const MF_RESOLUTION_ENABLE_STORE_PLUGINS = MF_RESOLUTION_FLAGS.ENABLE_STORE_PLUGINS;
pub const MF_RESOLUTION_READ = MF_RESOLUTION_FLAGS.READ;
pub const MF_RESOLUTION_WRITE = MF_RESOLUTION_FLAGS.WRITE;

pub const MF_CONNECT_METHOD = enum(i32) {
    DIRECT = 0,
    ALLOW_CONVERTER = 1,
    ALLOW_DECODER = 3,
    RESOLVE_INDEPENDENT_OUTPUTTYPES = 4,
    AS_OPTIONAL = 65536,
    AS_OPTIONAL_BRANCH = 131072,
};
pub const MF_CONNECT_DIRECT = MF_CONNECT_METHOD.DIRECT;
pub const MF_CONNECT_ALLOW_CONVERTER = MF_CONNECT_METHOD.ALLOW_CONVERTER;
pub const MF_CONNECT_ALLOW_DECODER = MF_CONNECT_METHOD.ALLOW_DECODER;
pub const MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES = MF_CONNECT_METHOD.RESOLVE_INDEPENDENT_OUTPUTTYPES;
pub const MF_CONNECT_AS_OPTIONAL = MF_CONNECT_METHOD.AS_OPTIONAL;
pub const MF_CONNECT_AS_OPTIONAL_BRANCH = MF_CONNECT_METHOD.AS_OPTIONAL_BRANCH;

pub const MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS = enum(i32) {
    TOPOLOGY_RESOLUTION_SUCCEEDED = 0,
    OPTIONAL_NODE_REJECTED_MEDIA_TYPE = 1,
    OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = 2,
};
pub const MF_TOPOLOGY_RESOLUTION_SUCCEEDED = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS.TOPOLOGY_RESOLUTION_SUCCEEDED;
pub const MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS.OPTIONAL_NODE_REJECTED_MEDIA_TYPE;
pub const MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS.OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSourceResolver_Value = Guid.initString("fbe5a32d-a497-4b61-bb85-97b1a848a6e3");
pub const IID_IMFSourceResolver = &IID_IMFSourceResolver_Value;
pub const IMFSourceResolver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateObjectFromURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateObjectFromByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pByteStream: ?*IMFByteStream,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pByteStream: ?*IMFByteStream,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginCreateObjectFromURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndCreateObjectFromURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginCreateObjectFromByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pByteStream: ?*IMFByteStream,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pByteStream: ?*IMFByteStream,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndCreateObjectFromByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelObjectCreation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceResolver,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceResolver,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_CreateObjectFromURL(self: *const T, pwszURL: ?[*:0]const u16, dwFlags: u32, pProps: ?*IPropertyStore, pObjectType: ?*MF_OBJECT_TYPE, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).CreateObjectFromURL(@as(*const IMFSourceResolver, @ptrCast(self)), pwszURL, dwFlags, pProps, pObjectType, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_CreateObjectFromByteStream(self: *const T, pByteStream: ?*IMFByteStream, pwszURL: ?[*:0]const u16, dwFlags: u32, pProps: ?*IPropertyStore, pObjectType: ?*MF_OBJECT_TYPE, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).CreateObjectFromByteStream(@as(*const IMFSourceResolver, @ptrCast(self)), pByteStream, pwszURL, dwFlags, pProps, pObjectType, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_BeginCreateObjectFromURL(self: *const T, pwszURL: ?[*:0]const u16, dwFlags: u32, pProps: ?*IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).BeginCreateObjectFromURL(@as(*const IMFSourceResolver, @ptrCast(self)), pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_EndCreateObjectFromURL(self: *const T, pResult: ?*IMFAsyncResult, pObjectType: ?*MF_OBJECT_TYPE, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).EndCreateObjectFromURL(@as(*const IMFSourceResolver, @ptrCast(self)), pResult, pObjectType, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_BeginCreateObjectFromByteStream(self: *const T, pByteStream: ?*IMFByteStream, pwszURL: ?[*:0]const u16, dwFlags: u32, pProps: ?*IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).BeginCreateObjectFromByteStream(@as(*const IMFSourceResolver, @ptrCast(self)), pByteStream, pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_EndCreateObjectFromByteStream(self: *const T, pResult: ?*IMFAsyncResult, pObjectType: ?*MF_OBJECT_TYPE, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).EndCreateObjectFromByteStream(@as(*const IMFSourceResolver, @ptrCast(self)), pResult, pObjectType, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceResolver_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: ?*IUnknown) HRESULT {
                return @as(*const IMFSourceResolver.VTable, @ptrCast(self.vtable)).CancelObjectCreation(@as(*const IMFSourceResolver, @ptrCast(self)), pIUnknownCancelCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFMEDIASOURCE_CHARACTERISTICS = enum(i32) {
    IS_LIVE = 1,
    CAN_SEEK = 2,
    CAN_PAUSE = 4,
    HAS_SLOW_SEEK = 8,
    HAS_MULTIPLE_PRESENTATIONS = 16,
    CAN_SKIPFORWARD = 32,
    CAN_SKIPBACKWARD = 64,
    DOES_NOT_USE_NETWORK = 128,
};
pub const MFMEDIASOURCE_IS_LIVE = MFMEDIASOURCE_CHARACTERISTICS.IS_LIVE;
pub const MFMEDIASOURCE_CAN_SEEK = MFMEDIASOURCE_CHARACTERISTICS.CAN_SEEK;
pub const MFMEDIASOURCE_CAN_PAUSE = MFMEDIASOURCE_CHARACTERISTICS.CAN_PAUSE;
pub const MFMEDIASOURCE_HAS_SLOW_SEEK = MFMEDIASOURCE_CHARACTERISTICS.HAS_SLOW_SEEK;
pub const MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS = MFMEDIASOURCE_CHARACTERISTICS.HAS_MULTIPLE_PRESENTATIONS;
pub const MFMEDIASOURCE_CAN_SKIPFORWARD = MFMEDIASOURCE_CHARACTERISTICS.CAN_SKIPFORWARD;
pub const MFMEDIASOURCE_CAN_SKIPBACKWARD = MFMEDIASOURCE_CHARACTERISTICS.CAN_SKIPBACKWARD;
pub const MFMEDIASOURCE_DOES_NOT_USE_NETWORK = MFMEDIASOURCE_CHARACTERISTICS.DOES_NOT_USE_NETWORK;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaSource_Value = Guid.initString("279a808d-aec7-40c8-9c6b-a6b492c78a66");
pub const IID_IMFMediaSource = &IID_IMFMediaSource_Value;
pub const IMFMediaSource = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        GetCharacteristics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePresentationDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource,
                ppPresentationDescriptor: ?*?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource,
                ppPresentationDescriptor: ?*?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
                pguidTimeFormat: ?*const Guid,
                pvarStartPosition: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
                pguidTimeFormat: ?*const Guid,
                pvarStartPosition: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource_GetCharacteristics(self: *const T, pdwCharacteristics: ?*u32) HRESULT {
                return @as(*const IMFMediaSource.VTable, @ptrCast(self.vtable)).GetCharacteristics(@as(*const IMFMediaSource, @ptrCast(self)), pdwCharacteristics);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource_CreatePresentationDescriptor(self: *const T, ppPresentationDescriptor: ?*?*IMFPresentationDescriptor) HRESULT {
                return @as(*const IMFMediaSource.VTable, @ptrCast(self.vtable)).CreatePresentationDescriptor(@as(*const IMFMediaSource, @ptrCast(self)), ppPresentationDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource_Start(self: *const T, pPresentationDescriptor: ?*IMFPresentationDescriptor, pguidTimeFormat: ?*const Guid, pvarStartPosition: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFMediaSource.VTable, @ptrCast(self.vtable)).Start(@as(*const IMFMediaSource, @ptrCast(self)), pPresentationDescriptor, pguidTimeFormat, pvarStartPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource_Stop(self: *const T) HRESULT {
                return @as(*const IMFMediaSource.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFMediaSource, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource_Pause(self: *const T) HRESULT {
                return @as(*const IMFMediaSource.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMFMediaSource, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaSource.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaSource, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaSourceEx_Value = Guid.initString("3c9b2eb9-86d5-4514-a394-f56664f9f0d8");
pub const IID_IMFMediaSourceEx = &IID_IMFMediaSourceEx_Value;
pub const IMFMediaSourceEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaSource.VTable,
        GetSourceAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceEx,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceEx,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceEx,
                dwStreamIdentifier: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceEx,
                dwStreamIdentifier: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetD3DManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceEx,
                pManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceEx,
                pManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaSource.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceEx_GetSourceAttributes(self: *const T, ppAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFMediaSourceEx.VTable, @ptrCast(self.vtable)).GetSourceAttributes(@as(*const IMFMediaSourceEx, @ptrCast(self)), ppAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceEx_GetStreamAttributes(self: *const T, dwStreamIdentifier: u32, ppAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFMediaSourceEx.VTable, @ptrCast(self.vtable)).GetStreamAttributes(@as(*const IMFMediaSourceEx, @ptrCast(self)), dwStreamIdentifier, ppAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceEx_SetD3DManager(self: *const T, pManager: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaSourceEx.VTable, @ptrCast(self.vtable)).SetD3DManager(@as(*const IMFMediaSourceEx, @ptrCast(self)), pManager);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFClockConsumer_Value = Guid.initString("6ef2a662-47c0-4666-b13d-cbb717f2fa2c");
pub const IID_IMFClockConsumer = &IID_IMFClockConsumer_Value;
pub const IMFClockConsumer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPresentationClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockConsumer,
                pPresentationClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockConsumer,
                pPresentationClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentationClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockConsumer,
                ppPresentationClock: ?*?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockConsumer,
                ppPresentationClock: ?*?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockConsumer_SetPresentationClock(self: *const T, pPresentationClock: ?*IMFPresentationClock) HRESULT {
                return @as(*const IMFClockConsumer.VTable, @ptrCast(self.vtable)).SetPresentationClock(@as(*const IMFClockConsumer, @ptrCast(self)), pPresentationClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockConsumer_GetPresentationClock(self: *const T, ppPresentationClock: ?*?*IMFPresentationClock) HRESULT {
                return @as(*const IMFClockConsumer.VTable, @ptrCast(self.vtable)).GetPresentationClock(@as(*const IMFClockConsumer, @ptrCast(self)), ppPresentationClock);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaStream_Value = Guid.initString("d182108f-4ec6-443f-aa42-a71106ec825f");
pub const IID_IMFMediaStream = &IID_IMFMediaStream_Value;
pub const IMFMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        GetMediaSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaStream,
                ppMediaSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaStream,
                ppMediaSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaStream,
                ppStreamDescriptor: ?*?*IMFStreamDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaStream,
                ppStreamDescriptor: ?*?*IMFStreamDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaStream,
                pToken: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaStream,
                pToken: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaStream_GetMediaSource(self: *const T, ppMediaSource: ?*?*IMFMediaSource) HRESULT {
                return @as(*const IMFMediaStream.VTable, @ptrCast(self.vtable)).GetMediaSource(@as(*const IMFMediaStream, @ptrCast(self)), ppMediaSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaStream_GetStreamDescriptor(self: *const T, ppStreamDescriptor: ?*?*IMFStreamDescriptor) HRESULT {
                return @as(*const IMFMediaStream.VTable, @ptrCast(self.vtable)).GetStreamDescriptor(@as(*const IMFMediaStream, @ptrCast(self)), ppStreamDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaStream_RequestSample(self: *const T, pToken: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaStream.VTable, @ptrCast(self.vtable)).RequestSample(@as(*const IMFMediaStream, @ptrCast(self)), pToken);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaSink_Value = Guid.initString("6ef2a660-47c0-4666-b13d-cbb717f2fa2c");
pub const IID_IMFMediaSink = &IID_IMFMediaSink_Value;
pub const IMFMediaSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCharacteristics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStreamSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                dwStreamSinkIdentifier: u32,
                pMediaType: ?*IMFMediaType,
                ppStreamSink: ?*?*IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                dwStreamSinkIdentifier: u32,
                pMediaType: ?*IMFMediaType,
                ppStreamSink: ?*?*IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                dwStreamSinkIdentifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                dwStreamSinkIdentifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSinkCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                pcStreamSinkCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                pcStreamSinkCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSinkByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                dwIndex: u32,
                ppStreamSink: ?*?*IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                dwIndex: u32,
                ppStreamSink: ?*?*IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSinkById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                dwStreamSinkIdentifier: u32,
                ppStreamSink: ?*?*IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                dwStreamSinkIdentifier: u32,
                ppStreamSink: ?*?*IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPresentationClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                pPresentationClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                pPresentationClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentationClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
                ppPresentationClock: ?*?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
                ppPresentationClock: ?*?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_GetCharacteristics(self: *const T, pdwCharacteristics: ?*u32) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).GetCharacteristics(@as(*const IMFMediaSink, @ptrCast(self)), pdwCharacteristics);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_AddStreamSink(self: *const T, dwStreamSinkIdentifier: u32, pMediaType: ?*IMFMediaType, ppStreamSink: ?*?*IMFStreamSink) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).AddStreamSink(@as(*const IMFMediaSink, @ptrCast(self)), dwStreamSinkIdentifier, pMediaType, ppStreamSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_RemoveStreamSink(self: *const T, dwStreamSinkIdentifier: u32) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).RemoveStreamSink(@as(*const IMFMediaSink, @ptrCast(self)), dwStreamSinkIdentifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_GetStreamSinkCount(self: *const T, pcStreamSinkCount: ?*u32) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).GetStreamSinkCount(@as(*const IMFMediaSink, @ptrCast(self)), pcStreamSinkCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_GetStreamSinkByIndex(self: *const T, dwIndex: u32, ppStreamSink: ?*?*IMFStreamSink) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).GetStreamSinkByIndex(@as(*const IMFMediaSink, @ptrCast(self)), dwIndex, ppStreamSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_GetStreamSinkById(self: *const T, dwStreamSinkIdentifier: u32, ppStreamSink: ?*?*IMFStreamSink) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).GetStreamSinkById(@as(*const IMFMediaSink, @ptrCast(self)), dwStreamSinkIdentifier, ppStreamSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_SetPresentationClock(self: *const T, pPresentationClock: ?*IMFPresentationClock) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).SetPresentationClock(@as(*const IMFMediaSink, @ptrCast(self)), pPresentationClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_GetPresentationClock(self: *const T, ppPresentationClock: ?*?*IMFPresentationClock) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).GetPresentationClock(@as(*const IMFMediaSink, @ptrCast(self)), ppPresentationClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSink_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaSink.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFSTREAMSINK_MARKER_TYPE = enum(i32) {
    DEFAULT = 0,
    ENDOFSEGMENT = 1,
    TICK = 2,
    EVENT = 3,
};
pub const MFSTREAMSINK_MARKER_DEFAULT = MFSTREAMSINK_MARKER_TYPE.DEFAULT;
pub const MFSTREAMSINK_MARKER_ENDOFSEGMENT = MFSTREAMSINK_MARKER_TYPE.ENDOFSEGMENT;
pub const MFSTREAMSINK_MARKER_TICK = MFSTREAMSINK_MARKER_TYPE.TICK;
pub const MFSTREAMSINK_MARKER_EVENT = MFSTREAMSINK_MARKER_TYPE.EVENT;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFStreamSink_Value = Guid.initString("0a97b3cf-8e7c-4a3d-8f8c-0c843dc247fb");
pub const IID_IMFStreamSink = &IID_IMFStreamSink_Value;
pub const IMFStreamSink = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        GetMediaSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamSink,
                ppMediaSink: ?*?*IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamSink,
                ppMediaSink: ?*?*IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamSink,
                pdwIdentifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamSink,
                pdwIdentifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaTypeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamSink,
                ppHandler: ?*?*IMFMediaTypeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamSink,
                ppHandler: ?*?*IMFMediaTypeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamSink,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamSink,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlaceMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamSink,
                eMarkerType: MFSTREAMSINK_MARKER_TYPE,
                pvarMarkerValue: ?*const PROPVARIANT,
                pvarContextValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamSink,
                eMarkerType: MFSTREAMSINK_MARKER_TYPE,
                pvarMarkerValue: ?*const PROPVARIANT,
                pvarContextValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamSink_GetMediaSink(self: *const T, ppMediaSink: ?*?*IMFMediaSink) HRESULT {
                return @as(*const IMFStreamSink.VTable, @ptrCast(self.vtable)).GetMediaSink(@as(*const IMFStreamSink, @ptrCast(self)), ppMediaSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamSink_GetIdentifier(self: *const T, pdwIdentifier: ?*u32) HRESULT {
                return @as(*const IMFStreamSink.VTable, @ptrCast(self.vtable)).GetIdentifier(@as(*const IMFStreamSink, @ptrCast(self)), pdwIdentifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamSink_GetMediaTypeHandler(self: *const T, ppHandler: ?*?*IMFMediaTypeHandler) HRESULT {
                return @as(*const IMFStreamSink.VTable, @ptrCast(self.vtable)).GetMediaTypeHandler(@as(*const IMFStreamSink, @ptrCast(self)), ppHandler);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamSink_ProcessSample(self: *const T, pSample: ?*IMFSample) HRESULT {
                return @as(*const IMFStreamSink.VTable, @ptrCast(self.vtable)).ProcessSample(@as(*const IMFStreamSink, @ptrCast(self)), pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamSink_PlaceMarker(self: *const T, eMarkerType: MFSTREAMSINK_MARKER_TYPE, pvarMarkerValue: ?*const PROPVARIANT, pvarContextValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFStreamSink.VTable, @ptrCast(self.vtable)).PlaceMarker(@as(*const IMFStreamSink, @ptrCast(self)), eMarkerType, pvarMarkerValue, pvarContextValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamSink_Flush(self: *const T) HRESULT {
                return @as(*const IMFStreamSink.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMFStreamSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoSampleAllocator_Value = Guid.initString("86cbc910-e533-4751-8e3b-f19b5b806a03");
pub const IID_IMFVideoSampleAllocator = &IID_IMFVideoSampleAllocator_Value;
pub const IMFVideoSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectXManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocator,
                pManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocator,
                pManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UninitializeSampleAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeSampleAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocator,
                cRequestedFrames: u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocator,
                cRequestedFrames: u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocator,
                ppSample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocator,
                ppSample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocator_SetDirectXManager(self: *const T, pManager: ?*IUnknown) HRESULT {
                return @as(*const IMFVideoSampleAllocator.VTable, @ptrCast(self.vtable)).SetDirectXManager(@as(*const IMFVideoSampleAllocator, @ptrCast(self)), pManager);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocator_UninitializeSampleAllocator(self: *const T) HRESULT {
                return @as(*const IMFVideoSampleAllocator.VTable, @ptrCast(self.vtable)).UninitializeSampleAllocator(@as(*const IMFVideoSampleAllocator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocator_InitializeSampleAllocator(self: *const T, cRequestedFrames: u32, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFVideoSampleAllocator.VTable, @ptrCast(self.vtable)).InitializeSampleAllocator(@as(*const IMFVideoSampleAllocator, @ptrCast(self)), cRequestedFrames, pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocator_AllocateSample(self: *const T, ppSample: ?*?*IMFSample) HRESULT {
                return @as(*const IMFVideoSampleAllocator.VTable, @ptrCast(self.vtable)).AllocateSample(@as(*const IMFVideoSampleAllocator, @ptrCast(self)), ppSample);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFVideoSampleAllocatorNotify_Value = Guid.initString("a792cdbe-c374-4e89-8335-278e7b9956a4");
pub const IID_IMFVideoSampleAllocatorNotify = &IID_IMFVideoSampleAllocatorNotify_Value;
pub const IMFVideoSampleAllocatorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRelease: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocatorNotify_NotifyRelease(self: *const T) HRESULT {
                return @as(*const IMFVideoSampleAllocatorNotify.VTable, @ptrCast(self.vtable)).NotifyRelease(@as(*const IMFVideoSampleAllocatorNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFVideoSampleAllocatorNotifyEx_Value = Guid.initString("3978aa1a-6d5b-4b7f-a340-90899189ae34");
pub const IID_IMFVideoSampleAllocatorNotifyEx = &IID_IMFVideoSampleAllocatorNotifyEx_Value;
pub const IMFVideoSampleAllocatorNotifyEx = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoSampleAllocatorNotify.VTable,
        NotifyPrune: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocatorNotifyEx,
                __MIDL__IMFVideoSampleAllocatorNotifyEx0000: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocatorNotifyEx,
                __MIDL__IMFVideoSampleAllocatorNotifyEx0000: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFVideoSampleAllocatorNotify.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocatorNotifyEx_NotifyPrune(self: *const T, __MIDL__IMFVideoSampleAllocatorNotifyEx0000: ?*IMFSample) HRESULT {
                return @as(*const IMFVideoSampleAllocatorNotifyEx.VTable, @ptrCast(self.vtable)).NotifyPrune(@as(*const IMFVideoSampleAllocatorNotifyEx, @ptrCast(self)), __MIDL__IMFVideoSampleAllocatorNotifyEx0000);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFVideoSampleAllocatorCallback_Value = Guid.initString("992388b4-3372-4f67-8b6f-c84c071f4751");
pub const IID_IMFVideoSampleAllocatorCallback = &IID_IMFVideoSampleAllocatorCallback_Value;
pub const IMFVideoSampleAllocatorCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocatorCallback,
                pNotify: ?*IMFVideoSampleAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocatorCallback,
                pNotify: ?*IMFVideoSampleAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFreeSampleCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocatorCallback,
                plSamples: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocatorCallback,
                plSamples: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocatorCallback_SetCallback(self: *const T, pNotify: ?*IMFVideoSampleAllocatorNotify) HRESULT {
                return @as(*const IMFVideoSampleAllocatorCallback.VTable, @ptrCast(self.vtable)).SetCallback(@as(*const IMFVideoSampleAllocatorCallback, @ptrCast(self)), pNotify);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocatorCallback_GetFreeSampleCount(self: *const T, plSamples: ?*i32) HRESULT {
                return @as(*const IMFVideoSampleAllocatorCallback.VTable, @ptrCast(self.vtable)).GetFreeSampleCount(@as(*const IMFVideoSampleAllocatorCallback, @ptrCast(self)), plSamples);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFVideoSampleAllocatorEx_Value = Guid.initString("545b3a48-3283-4f62-866f-a62d8f598f9f");
pub const IID_IMFVideoSampleAllocatorEx = &IID_IMFVideoSampleAllocatorEx_Value;
pub const IMFVideoSampleAllocatorEx = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoSampleAllocator.VTable,
        InitializeSampleAllocatorEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoSampleAllocatorEx,
                cInitialSamples: u32,
                cMaximumSamples: u32,
                pAttributes: ?*IMFAttributes,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoSampleAllocatorEx,
                cInitialSamples: u32,
                cMaximumSamples: u32,
                pAttributes: ?*IMFAttributes,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFVideoSampleAllocator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(self: *const T, cInitialSamples: u32, cMaximumSamples: u32, pAttributes: ?*IMFAttributes, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFVideoSampleAllocatorEx.VTable, @ptrCast(self.vtable)).InitializeSampleAllocatorEx(@as(*const IMFVideoSampleAllocatorEx, @ptrCast(self)), cInitialSamples, cMaximumSamples, pAttributes, pMediaType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFDXGIDeviceManagerSource_Value = Guid.initString("20bc074b-7a8d-4609-8c3b-64a0a3b5d7ce");
pub const IID_IMFDXGIDeviceManagerSource = &IID_IMFDXGIDeviceManagerSource_Value;
pub const IMFDXGIDeviceManagerSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDXGIDeviceManagerSource,
                ppManager: ?*?*IMFDXGIDeviceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDXGIDeviceManagerSource,
                ppManager: ?*?*IMFDXGIDeviceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDXGIDeviceManagerSource_GetManager(self: *const T, ppManager: ?*?*IMFDXGIDeviceManager) HRESULT {
                return @as(*const IMFDXGIDeviceManagerSource.VTable, @ptrCast(self.vtable)).GetManager(@as(*const IMFDXGIDeviceManagerSource, @ptrCast(self)), ppManager);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_VIDEO_PROCESSOR_ROTATION = enum(i32) {
    NE = 0,
    RMAL = 1,
};
pub const ROTATION_NONE = MF_VIDEO_PROCESSOR_ROTATION.NE;
pub const ROTATION_NORMAL = MF_VIDEO_PROCESSOR_ROTATION.RMAL;

pub const MF_VIDEO_PROCESSOR_MIRROR = enum(i32) {
    NONE = 0,
    HORIZONTAL = 1,
    VERTICAL = 2,
};
pub const MIRROR_NONE = MF_VIDEO_PROCESSOR_MIRROR.NONE;
pub const MIRROR_HORIZONTAL = MF_VIDEO_PROCESSOR_MIRROR.HORIZONTAL;
pub const MIRROR_VERTICAL = MF_VIDEO_PROCESSOR_MIRROR.VERTICAL;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFVideoProcessorControl_Value = Guid.initString("a3f675d5-6119-4f7f-a100-1d8b280f0efb");
pub const IID_IMFVideoProcessorControl = &IID_IMFVideoProcessorControl_Value;
pub const IMFVideoProcessorControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl,
                pBorderColor: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl,
                pBorderColor: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl,
                pSrcRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl,
                pSrcRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDestinationRectangle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl,
                pDstRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl,
                pDstRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMirror: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl,
                eMirror: MF_VIDEO_PROCESSOR_MIRROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl,
                eMirror: MF_VIDEO_PROCESSOR_MIRROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl,
                eRotation: MF_VIDEO_PROCESSOR_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl,
                eRotation: MF_VIDEO_PROCESSOR_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConstrictionSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl,
                pConstrictionSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl,
                pConstrictionSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl_SetBorderColor(self: *const T, pBorderColor: ?*MFARGB) HRESULT {
                return @as(*const IMFVideoProcessorControl.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IMFVideoProcessorControl, @ptrCast(self)), pBorderColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl_SetSourceRectangle(self: *const T, pSrcRect: ?*RECT) HRESULT {
                return @as(*const IMFVideoProcessorControl.VTable, @ptrCast(self.vtable)).SetSourceRectangle(@as(*const IMFVideoProcessorControl, @ptrCast(self)), pSrcRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl_SetDestinationRectangle(self: *const T, pDstRect: ?*RECT) HRESULT {
                return @as(*const IMFVideoProcessorControl.VTable, @ptrCast(self.vtable)).SetDestinationRectangle(@as(*const IMFVideoProcessorControl, @ptrCast(self)), pDstRect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl_SetMirror(self: *const T, eMirror: MF_VIDEO_PROCESSOR_MIRROR) HRESULT {
                return @as(*const IMFVideoProcessorControl.VTable, @ptrCast(self.vtable)).SetMirror(@as(*const IMFVideoProcessorControl, @ptrCast(self)), eMirror);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl_SetRotation(self: *const T, eRotation: MF_VIDEO_PROCESSOR_ROTATION) HRESULT {
                return @as(*const IMFVideoProcessorControl.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const IMFVideoProcessorControl, @ptrCast(self)), eRotation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl_SetConstrictionSize(self: *const T, pConstrictionSize: ?*SIZE) HRESULT {
                return @as(*const IMFVideoProcessorControl.VTable, @ptrCast(self.vtable)).SetConstrictionSize(@as(*const IMFVideoProcessorControl, @ptrCast(self)), pConstrictionSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFVideoProcessorControl2_Value = Guid.initString("bde633d3-e1dc-4a7f-a693-bbae399c4a20");
pub const IID_IMFVideoProcessorControl2 = &IID_IMFVideoProcessorControl2_Value;
pub const IMFVideoProcessorControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoProcessorControl.VTable,
        SetRotationOverride: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl2,
                uiRotation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl2,
                uiRotation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableHardwareEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl2,
                fEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl2,
                fEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedHardwareEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl2,
                puiSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl2,
                puiSupport: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFVideoProcessorControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl2_SetRotationOverride(self: *const T, uiRotation: u32) HRESULT {
                return @as(*const IMFVideoProcessorControl2.VTable, @ptrCast(self.vtable)).SetRotationOverride(@as(*const IMFVideoProcessorControl2, @ptrCast(self)), uiRotation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl2_EnableHardwareEffects(self: *const T, fEnabled: BOOL) HRESULT {
                return @as(*const IMFVideoProcessorControl2.VTable, @ptrCast(self.vtable)).EnableHardwareEffects(@as(*const IMFVideoProcessorControl2, @ptrCast(self)), fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl2_GetSupportedHardwareEffects(self: *const T, puiSupport: ?*u32) HRESULT {
                return @as(*const IMFVideoProcessorControl2.VTable, @ptrCast(self.vtable)).GetSupportedHardwareEffects(@as(*const IMFVideoProcessorControl2, @ptrCast(self)), puiSupport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoSphericalFormat = enum(i32) {
    Unsupported = 0,
    Equirectangular = 1,
    CubeMap = 2,
    @"3DMesh" = 3,
};
pub const MFVideoSphericalFormat_Unsupported = MFVideoSphericalFormat.Unsupported;
pub const MFVideoSphericalFormat_Equirectangular = MFVideoSphericalFormat.Equirectangular;
pub const MFVideoSphericalFormat_CubeMap = MFVideoSphericalFormat.CubeMap;
pub const MFVideoSphericalFormat_3DMesh = MFVideoSphericalFormat.@"3DMesh";

pub const MFVideoSphericalProjectionMode = enum(i32) {
    Spherical = 0,
    Flat = 1,
};
pub const MFVideoSphericalProjectionMode_Spherical = MFVideoSphericalProjectionMode.Spherical;
pub const MFVideoSphericalProjectionMode_Flat = MFVideoSphericalProjectionMode.Flat;

const IID_IMFVideoProcessorControl3_Value = Guid.initString("2424b3f2-eb23-40f1-91aa-74bddeea0883");
pub const IID_IMFVideoProcessorControl3 = &IID_IMFVideoProcessorControl3_Value;
pub const IMFVideoProcessorControl3 = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoProcessorControl2.VTable,
        GetNaturalOutputType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl3,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl3,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableSphericalVideoProcessing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl3,
                fEnable: BOOL,
                eFormat: MFVideoSphericalFormat,
                eProjectionMode: MFVideoSphericalProjectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl3,
                fEnable: BOOL,
                eFormat: MFVideoSphericalFormat,
                eProjectionMode: MFVideoSphericalProjectionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSphericalVideoProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl3,
                X: f32,
                Y: f32,
                Z: f32,
                W: f32,
                fieldOfView: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl3,
                X: f32,
                Y: f32,
                Z: f32,
                W: f32,
                fieldOfView: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessorControl3,
                pOutputDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessorControl3,
                pOutputDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFVideoProcessorControl2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl3_GetNaturalOutputType(self: *const T, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFVideoProcessorControl3.VTable, @ptrCast(self.vtable)).GetNaturalOutputType(@as(*const IMFVideoProcessorControl3, @ptrCast(self)), ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl3_EnableSphericalVideoProcessing(self: *const T, fEnable: BOOL, eFormat: MFVideoSphericalFormat, eProjectionMode: MFVideoSphericalProjectionMode) HRESULT {
                return @as(*const IMFVideoProcessorControl3.VTable, @ptrCast(self.vtable)).EnableSphericalVideoProcessing(@as(*const IMFVideoProcessorControl3, @ptrCast(self)), fEnable, eFormat, eProjectionMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl3_SetSphericalVideoProperties(self: *const T, X: f32, Y: f32, Z: f32, W: f32, fieldOfView: f32) HRESULT {
                return @as(*const IMFVideoProcessorControl3.VTable, @ptrCast(self.vtable)).SetSphericalVideoProperties(@as(*const IMFVideoProcessorControl3, @ptrCast(self)), X, Y, Z, W, fieldOfView);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessorControl3_SetOutputDevice(self: *const T, pOutputDevice: ?*IUnknown) HRESULT {
                return @as(*const IMFVideoProcessorControl3.VTable, @ptrCast(self.vtable)).SetOutputDevice(@as(*const IMFVideoProcessorControl3, @ptrCast(self)), pOutputDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoRendererEffectControl_Value = Guid.initString("604d33d7-cf23-41d5-8224-5bbbb1a87475");
pub const IID_IMFVideoRendererEffectControl = &IID_IMFVideoRendererEffectControl_Value;
pub const IMFVideoRendererEffectControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAppServiceConnectionEstablished: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoRendererEffectControl,
                pAppServiceConnection: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoRendererEffectControl,
                pAppServiceConnection: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoRendererEffectControl_OnAppServiceConnectionEstablished(self: *const T, pAppServiceConnection: ?*IUnknown) HRESULT {
                return @as(*const IMFVideoRendererEffectControl.VTable, @ptrCast(self.vtable)).OnAppServiceConnectionEstablished(@as(*const IMFVideoRendererEffectControl, @ptrCast(self)), pAppServiceConnection);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTopology_Value = Guid.initString("83cf873a-f6da-4bc8-823f-bacfd55dc433");
pub const IID_IMFTopology = &IID_IMFTopology_Value;
pub const IMFTopology = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetTopologyID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                pID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                pID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                pNode: ?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                pNode: ?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                pNode: ?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                pNode: ?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNodeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                pwNodes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                pwNodes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                wIndex: u16,
                ppNode: ?*?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                wIndex: u16,
                ppNode: ?*?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloneFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNodeByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                qwTopoNodeID: u64,
                ppNode: ?*?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                qwTopoNodeID: u64,
                ppNode: ?*?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceNodeCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                ppCollection: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                ppCollection: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputNodeCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopology,
                ppCollection: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopology,
                ppCollection: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_GetTopologyID(self: *const T, pID: ?*u64) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).GetTopologyID(@as(*const IMFTopology, @ptrCast(self)), pID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_AddNode(self: *const T, pNode: ?*IMFTopologyNode) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).AddNode(@as(*const IMFTopology, @ptrCast(self)), pNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_RemoveNode(self: *const T, pNode: ?*IMFTopologyNode) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).RemoveNode(@as(*const IMFTopology, @ptrCast(self)), pNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_GetNodeCount(self: *const T, pwNodes: ?*u16) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).GetNodeCount(@as(*const IMFTopology, @ptrCast(self)), pwNodes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_GetNode(self: *const T, wIndex: u16, ppNode: ?*?*IMFTopologyNode) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).GetNode(@as(*const IMFTopology, @ptrCast(self)), wIndex, ppNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_Clear(self: *const T) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).Clear(@as(*const IMFTopology, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_CloneFrom(self: *const T, pTopology: ?*IMFTopology) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).CloneFrom(@as(*const IMFTopology, @ptrCast(self)), pTopology);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_GetNodeByID(self: *const T, qwTopoNodeID: u64, ppNode: ?*?*IMFTopologyNode) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).GetNodeByID(@as(*const IMFTopology, @ptrCast(self)), qwTopoNodeID, ppNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_GetSourceNodeCollection(self: *const T, ppCollection: ?*?*IMFCollection) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).GetSourceNodeCollection(@as(*const IMFTopology, @ptrCast(self)), ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopology_GetOutputNodeCollection(self: *const T, ppCollection: ?*?*IMFCollection) HRESULT {
                return @as(*const IMFTopology.VTable, @ptrCast(self.vtable)).GetOutputNodeCollection(@as(*const IMFTopology, @ptrCast(self)), ppCollection);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFTOPOLOGY_DXVA_MODE = enum(i32) {
    DEFAULT = 0,
    NONE = 1,
    FULL = 2,
};
pub const MFTOPOLOGY_DXVA_DEFAULT = MFTOPOLOGY_DXVA_MODE.DEFAULT;
pub const MFTOPOLOGY_DXVA_NONE = MFTOPOLOGY_DXVA_MODE.NONE;
pub const MFTOPOLOGY_DXVA_FULL = MFTOPOLOGY_DXVA_MODE.FULL;

pub const MFTOPOLOGY_HARDWARE_MODE = enum(i32) {
    SOFTWARE_ONLY = 0,
    USE_HARDWARE = 1,
    USE_ONLY_HARDWARE = 2,
};
pub const MFTOPOLOGY_HWMODE_SOFTWARE_ONLY = MFTOPOLOGY_HARDWARE_MODE.SOFTWARE_ONLY;
pub const MFTOPOLOGY_HWMODE_USE_HARDWARE = MFTOPOLOGY_HARDWARE_MODE.USE_HARDWARE;
pub const MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE = MFTOPOLOGY_HARDWARE_MODE.USE_ONLY_HARDWARE;

pub const MF_TOPOLOGY_TYPE = enum(i32) {
    OUTPUT_NODE = 0,
    SOURCESTREAM_NODE = 1,
    TRANSFORM_NODE = 2,
    TEE_NODE = 3,
    MAX = -1,
};
pub const MF_TOPOLOGY_OUTPUT_NODE = MF_TOPOLOGY_TYPE.OUTPUT_NODE;
pub const MF_TOPOLOGY_SOURCESTREAM_NODE = MF_TOPOLOGY_TYPE.SOURCESTREAM_NODE;
pub const MF_TOPOLOGY_TRANSFORM_NODE = MF_TOPOLOGY_TYPE.TRANSFORM_NODE;
pub const MF_TOPOLOGY_TEE_NODE = MF_TOPOLOGY_TYPE.TEE_NODE;
pub const MF_TOPOLOGY_MAX = MF_TOPOLOGY_TYPE.MAX;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTopologyNode_Value = Guid.initString("83cf873a-f6da-4bc8-823f-bacfd55dc430");
pub const IID_IMFTopologyNode = &IID_IMFTopologyNode_Value;
pub const IMFTopologyNode = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        SetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                pObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                pObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNodeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                pType: ?*MF_TOPOLOGY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                pType: ?*MF_TOPOLOGY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTopoNodeID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                pID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                pID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTopoNodeID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                ullTopoID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                ullTopoID: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                pcInputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                pcInputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                pDownstreamNode: ?*IMFTopologyNode,
                dwInputIndexOnDownstreamNode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                pDownstreamNode: ?*IMFTopologyNode,
                dwInputIndexOnDownstreamNode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwInputIndex: u32,
                ppUpstreamNode: ?*?*IMFTopologyNode,
                pdwOutputIndexOnUpstreamNode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwInputIndex: u32,
                ppUpstreamNode: ?*?*IMFTopologyNode,
                pdwOutputIndexOnUpstreamNode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                ppDownstreamNode: ?*?*IMFTopologyNode,
                pdwInputIndexOnDownstreamNode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                ppDownstreamNode: ?*?*IMFTopologyNode,
                pdwInputIndexOnDownstreamNode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputPrefType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                pType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                pType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputPrefType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwOutputIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputPrefType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwInputIndex: u32,
                pType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwInputIndex: u32,
                pType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputPrefType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                dwInputIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                dwInputIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloneFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNode,
                pNode: ?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNode,
                pNode: ?*IMFTopologyNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_SetObject(self: *const T, pObject: ?*IUnknown) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).SetObject(@as(*const IMFTopologyNode, @ptrCast(self)), pObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetObject(self: *const T, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IMFTopologyNode, @ptrCast(self)), ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetNodeType(self: *const T, pType: ?*MF_TOPOLOGY_TYPE) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetNodeType(@as(*const IMFTopologyNode, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetTopoNodeID(self: *const T, pID: ?*u64) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetTopoNodeID(@as(*const IMFTopologyNode, @ptrCast(self)), pID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_SetTopoNodeID(self: *const T, ullTopoID: u64) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).SetTopoNodeID(@as(*const IMFTopologyNode, @ptrCast(self)), ullTopoID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetInputCount(self: *const T, pcInputs: ?*u32) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetInputCount(@as(*const IMFTopologyNode, @ptrCast(self)), pcInputs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetOutputCount(self: *const T, pcOutputs: ?*u32) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetOutputCount(@as(*const IMFTopologyNode, @ptrCast(self)), pcOutputs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_ConnectOutput(self: *const T, dwOutputIndex: u32, pDownstreamNode: ?*IMFTopologyNode, dwInputIndexOnDownstreamNode: u32) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).ConnectOutput(@as(*const IMFTopologyNode, @ptrCast(self)), dwOutputIndex, pDownstreamNode, dwInputIndexOnDownstreamNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_DisconnectOutput(self: *const T, dwOutputIndex: u32) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).DisconnectOutput(@as(*const IMFTopologyNode, @ptrCast(self)), dwOutputIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetInput(self: *const T, dwInputIndex: u32, ppUpstreamNode: ?*?*IMFTopologyNode, pdwOutputIndexOnUpstreamNode: ?*u32) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetInput(@as(*const IMFTopologyNode, @ptrCast(self)), dwInputIndex, ppUpstreamNode, pdwOutputIndexOnUpstreamNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetOutput(self: *const T, dwOutputIndex: u32, ppDownstreamNode: ?*?*IMFTopologyNode, pdwInputIndexOnDownstreamNode: ?*u32) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetOutput(@as(*const IMFTopologyNode, @ptrCast(self)), dwOutputIndex, ppDownstreamNode, pdwInputIndexOnDownstreamNode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_SetOutputPrefType(self: *const T, dwOutputIndex: u32, pType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).SetOutputPrefType(@as(*const IMFTopologyNode, @ptrCast(self)), dwOutputIndex, pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetOutputPrefType(self: *const T, dwOutputIndex: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetOutputPrefType(@as(*const IMFTopologyNode, @ptrCast(self)), dwOutputIndex, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_SetInputPrefType(self: *const T, dwInputIndex: u32, pType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).SetInputPrefType(@as(*const IMFTopologyNode, @ptrCast(self)), dwInputIndex, pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_GetInputPrefType(self: *const T, dwInputIndex: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).GetInputPrefType(@as(*const IMFTopologyNode, @ptrCast(self)), dwInputIndex, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNode_CloneFrom(self: *const T, pNode: ?*IMFTopologyNode) HRESULT {
                return @as(*const IMFTopologyNode.VTable, @ptrCast(self.vtable)).CloneFrom(@as(*const IMFTopologyNode, @ptrCast(self)), pNode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TOPONODE_FLUSH_MODE = enum(i32) {
    ALWAYS = 0,
    SEEK = 1,
    NEVER = 2,
};
pub const MF_TOPONODE_FLUSH_ALWAYS = MF_TOPONODE_FLUSH_MODE.ALWAYS;
pub const MF_TOPONODE_FLUSH_SEEK = MF_TOPONODE_FLUSH_MODE.SEEK;
pub const MF_TOPONODE_FLUSH_NEVER = MF_TOPONODE_FLUSH_MODE.NEVER;

pub const MF_TOPONODE_DRAIN_MODE = enum(i32) {
    DEFAULT = 0,
    ALWAYS = 1,
    NEVER = 2,
};
pub const MF_TOPONODE_DRAIN_DEFAULT = MF_TOPONODE_DRAIN_MODE.DEFAULT;
pub const MF_TOPONODE_DRAIN_ALWAYS = MF_TOPONODE_DRAIN_MODE.ALWAYS;
pub const MF_TOPONODE_DRAIN_NEVER = MF_TOPONODE_DRAIN_MODE.NEVER;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFGetService_Value = Guid.initString("fa993888-4383-415a-a930-dd472a8cf6f7");
pub const IID_IMFGetService = &IID_IMFGetService_Value;
pub const IMFGetService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFGetService,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFGetService,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFGetService_GetService(self: *const T, guidService: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFGetService.VTable, @ptrCast(self.vtable)).GetService(@as(*const IMFGetService, @ptrCast(self)), guidService, riid, ppvObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFCLOCK_CHARACTERISTICS_FLAGS = enum(i32) {
    FREQUENCY_10MHZ = 2,
    ALWAYS_RUNNING = 4,
    IS_SYSTEM_CLOCK = 8,
};
pub const MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ = MFCLOCK_CHARACTERISTICS_FLAGS.FREQUENCY_10MHZ;
pub const MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING = MFCLOCK_CHARACTERISTICS_FLAGS.ALWAYS_RUNNING;
pub const MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK = MFCLOCK_CHARACTERISTICS_FLAGS.IS_SYSTEM_CLOCK;

pub const MFCLOCK_STATE = enum(i32) {
    INVALID = 0,
    RUNNING = 1,
    STOPPED = 2,
    PAUSED = 3,
};
pub const MFCLOCK_STATE_INVALID = MFCLOCK_STATE.INVALID;
pub const MFCLOCK_STATE_RUNNING = MFCLOCK_STATE.RUNNING;
pub const MFCLOCK_STATE_STOPPED = MFCLOCK_STATE.STOPPED;
pub const MFCLOCK_STATE_PAUSED = MFCLOCK_STATE.PAUSED;

pub const MFCLOCK_RELATIONAL_FLAGS = enum(i32) {
    D = 1,
};
pub const MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD = MFCLOCK_RELATIONAL_FLAGS.D;

pub const MFCLOCK_PROPERTIES = extern struct {
    qwCorrelationRate: u64,
    guidClockId: Guid,
    dwClockFlags: u32,
    qwClockFrequency: u64,
    dwClockTolerance: u32,
    dwClockJitter: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFClock_Value = Guid.initString("2eb1e945-18b8-4139-9b1a-d5d584818530");
pub const IID_IMFClock = &IID_IMFClock_Value;
pub const IMFClock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClockCharacteristics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClock,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClock,
                pdwCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCorrelatedTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClock,
                dwReserved: u32,
                pllClockTime: ?*i64,
                phnsSystemTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClock,
                dwReserved: u32,
                pllClockTime: ?*i64,
                phnsSystemTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContinuityKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClock,
                pdwContinuityKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClock,
                pdwContinuityKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClock,
                dwReserved: u32,
                peClockState: ?*MFCLOCK_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClock,
                dwReserved: u32,
                peClockState: ?*MFCLOCK_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClock,
                pClockProperties: ?*MFCLOCK_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClock,
                pClockProperties: ?*MFCLOCK_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClock_GetClockCharacteristics(self: *const T, pdwCharacteristics: ?*u32) HRESULT {
                return @as(*const IMFClock.VTable, @ptrCast(self.vtable)).GetClockCharacteristics(@as(*const IMFClock, @ptrCast(self)), pdwCharacteristics);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClock_GetCorrelatedTime(self: *const T, dwReserved: u32, pllClockTime: ?*i64, phnsSystemTime: ?*i64) HRESULT {
                return @as(*const IMFClock.VTable, @ptrCast(self.vtable)).GetCorrelatedTime(@as(*const IMFClock, @ptrCast(self)), dwReserved, pllClockTime, phnsSystemTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClock_GetContinuityKey(self: *const T, pdwContinuityKey: ?*u32) HRESULT {
                return @as(*const IMFClock.VTable, @ptrCast(self.vtable)).GetContinuityKey(@as(*const IMFClock, @ptrCast(self)), pdwContinuityKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClock_GetState(self: *const T, dwReserved: u32, peClockState: ?*MFCLOCK_STATE) HRESULT {
                return @as(*const IMFClock.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMFClock, @ptrCast(self)), dwReserved, peClockState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClock_GetProperties(self: *const T, pClockProperties: ?*MFCLOCK_PROPERTIES) HRESULT {
                return @as(*const IMFClock.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IMFClock, @ptrCast(self)), pClockProperties);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFPresentationClock_Value = Guid.initString("868ce85c-8ea9-4f55-ab82-b009a910a805");
pub const IID_IMFPresentationClock = &IID_IMFPresentationClock_Value;
pub const IMFPresentationClock = extern struct {
    pub const VTable = extern struct {
        base: IMFClock.VTable,
        SetTimeSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
                pTimeSource: ?*IMFPresentationTimeSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
                pTimeSource: ?*IMFPresentationTimeSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
                ppTimeSource: ?*?*IMFPresentationTimeSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
                ppTimeSource: ?*?*IMFPresentationTimeSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
                phnsClockTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
                phnsClockTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddClockStateSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
                pStateSink: ?*IMFClockStateSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
                pStateSink: ?*IMFClockStateSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveClockStateSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
                pStateSink: ?*IMFClockStateSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
                pStateSink: ?*IMFClockStateSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
                llClockStartOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
                llClockStartOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFClock.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_SetTimeSource(self: *const T, pTimeSource: ?*IMFPresentationTimeSource) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).SetTimeSource(@as(*const IMFPresentationClock, @ptrCast(self)), pTimeSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_GetTimeSource(self: *const T, ppTimeSource: ?*?*IMFPresentationTimeSource) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).GetTimeSource(@as(*const IMFPresentationClock, @ptrCast(self)), ppTimeSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_GetTime(self: *const T, phnsClockTime: ?*i64) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IMFPresentationClock, @ptrCast(self)), phnsClockTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_AddClockStateSink(self: *const T, pStateSink: ?*IMFClockStateSink) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).AddClockStateSink(@as(*const IMFPresentationClock, @ptrCast(self)), pStateSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_RemoveClockStateSink(self: *const T, pStateSink: ?*IMFClockStateSink) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).RemoveClockStateSink(@as(*const IMFPresentationClock, @ptrCast(self)), pStateSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_Start(self: *const T, llClockStartOffset: i64) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).Start(@as(*const IMFPresentationClock, @ptrCast(self)), llClockStartOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_Stop(self: *const T) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFPresentationClock, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationClock_Pause(self: *const T) HRESULT {
                return @as(*const IMFPresentationClock.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMFPresentationClock, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFPresentationTimeSource_Value = Guid.initString("7ff12cce-f76f-41c2-863b-1666c8e5e139");
pub const IID_IMFPresentationTimeSource = &IID_IMFPresentationTimeSource_Value;
pub const IMFPresentationTimeSource = extern struct {
    pub const VTable = extern struct {
        base: IMFClock.VTable,
        GetUnderlyingClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationTimeSource,
                ppClock: ?*?*IMFClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationTimeSource,
                ppClock: ?*?*IMFClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFClock.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationTimeSource_GetUnderlyingClock(self: *const T, ppClock: ?*?*IMFClock) HRESULT {
                return @as(*const IMFPresentationTimeSource.VTable, @ptrCast(self.vtable)).GetUnderlyingClock(@as(*const IMFPresentationTimeSource, @ptrCast(self)), ppClock);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFClockStateSink_Value = Guid.initString("f6696e82-74f7-4f3d-a178-8a5e09c3659f");
pub const IID_IMFClockStateSink = &IID_IMFClockStateSink_Value;
pub const IMFClockStateSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnClockStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
                llClockStartOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
                llClockStartOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClockStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClockPause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClockRestart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClockSetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
                flRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFClockStateSink,
                hnsSystemTime: i64,
                flRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockStateSink_OnClockStart(self: *const T, hnsSystemTime: i64, llClockStartOffset: i64) HRESULT {
                return @as(*const IMFClockStateSink.VTable, @ptrCast(self.vtable)).OnClockStart(@as(*const IMFClockStateSink, @ptrCast(self)), hnsSystemTime, llClockStartOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockStateSink_OnClockStop(self: *const T, hnsSystemTime: i64) HRESULT {
                return @as(*const IMFClockStateSink.VTable, @ptrCast(self.vtable)).OnClockStop(@as(*const IMFClockStateSink, @ptrCast(self)), hnsSystemTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockStateSink_OnClockPause(self: *const T, hnsSystemTime: i64) HRESULT {
                return @as(*const IMFClockStateSink.VTable, @ptrCast(self.vtable)).OnClockPause(@as(*const IMFClockStateSink, @ptrCast(self)), hnsSystemTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockStateSink_OnClockRestart(self: *const T, hnsSystemTime: i64) HRESULT {
                return @as(*const IMFClockStateSink.VTable, @ptrCast(self.vtable)).OnClockRestart(@as(*const IMFClockStateSink, @ptrCast(self)), hnsSystemTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFClockStateSink_OnClockSetRate(self: *const T, hnsSystemTime: i64, flRate: f32) HRESULT {
                return @as(*const IMFClockStateSink.VTable, @ptrCast(self.vtable)).OnClockSetRate(@as(*const IMFClockStateSink, @ptrCast(self)), hnsSystemTime, flRate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFPresentationDescriptor_Value = Guid.initString("03cb2711-24d7-4db6-a17f-f3a7a479a536");
pub const IID_IMFPresentationDescriptor = &IID_IMFPresentationDescriptor_Value;
pub const IMFPresentationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamDescriptorCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationDescriptor,
                pdwDescriptorCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationDescriptor,
                pdwDescriptorCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationDescriptor,
                dwIndex: u32,
                pfSelected: ?*BOOL,
                ppDescriptor: ?*?*IMFStreamDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationDescriptor,
                dwIndex: u32,
                pfSelected: ?*BOOL,
                ppDescriptor: ?*?*IMFStreamDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationDescriptor,
                dwDescriptorIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationDescriptor,
                dwDescriptorIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeselectStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationDescriptor,
                dwDescriptorIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationDescriptor,
                dwDescriptorIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPresentationDescriptor,
                ppPresentationDescriptor: ?*?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPresentationDescriptor,
                ppPresentationDescriptor: ?*?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationDescriptor_GetStreamDescriptorCount(self: *const T, pdwDescriptorCount: ?*u32) HRESULT {
                return @as(*const IMFPresentationDescriptor.VTable, @ptrCast(self.vtable)).GetStreamDescriptorCount(@as(*const IMFPresentationDescriptor, @ptrCast(self)), pdwDescriptorCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationDescriptor_GetStreamDescriptorByIndex(self: *const T, dwIndex: u32, pfSelected: ?*BOOL, ppDescriptor: ?*?*IMFStreamDescriptor) HRESULT {
                return @as(*const IMFPresentationDescriptor.VTable, @ptrCast(self.vtable)).GetStreamDescriptorByIndex(@as(*const IMFPresentationDescriptor, @ptrCast(self)), dwIndex, pfSelected, ppDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationDescriptor_SelectStream(self: *const T, dwDescriptorIndex: u32) HRESULT {
                return @as(*const IMFPresentationDescriptor.VTable, @ptrCast(self.vtable)).SelectStream(@as(*const IMFPresentationDescriptor, @ptrCast(self)), dwDescriptorIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationDescriptor_DeselectStream(self: *const T, dwDescriptorIndex: u32) HRESULT {
                return @as(*const IMFPresentationDescriptor.VTable, @ptrCast(self.vtable)).DeselectStream(@as(*const IMFPresentationDescriptor, @ptrCast(self)), dwDescriptorIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPresentationDescriptor_Clone(self: *const T, ppPresentationDescriptor: ?*?*IMFPresentationDescriptor) HRESULT {
                return @as(*const IMFPresentationDescriptor.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMFPresentationDescriptor, @ptrCast(self)), ppPresentationDescriptor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFStreamDescriptor_Value = Guid.initString("56c03d9c-9dbb-45f5-ab4b-d80f47c05938");
pub const IID_IMFStreamDescriptor = &IID_IMFStreamDescriptor_Value;
pub const IMFStreamDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamDescriptor,
                pdwStreamIdentifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamDescriptor,
                pdwStreamIdentifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaTypeHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamDescriptor,
                ppMediaTypeHandler: ?*?*IMFMediaTypeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamDescriptor,
                ppMediaTypeHandler: ?*?*IMFMediaTypeHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamDescriptor_GetStreamIdentifier(self: *const T, pdwStreamIdentifier: ?*u32) HRESULT {
                return @as(*const IMFStreamDescriptor.VTable, @ptrCast(self.vtable)).GetStreamIdentifier(@as(*const IMFStreamDescriptor, @ptrCast(self)), pdwStreamIdentifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamDescriptor_GetMediaTypeHandler(self: *const T, ppMediaTypeHandler: ?*?*IMFMediaTypeHandler) HRESULT {
                return @as(*const IMFStreamDescriptor.VTable, @ptrCast(self.vtable)).GetMediaTypeHandler(@as(*const IMFStreamDescriptor, @ptrCast(self)), ppMediaTypeHandler);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaTypeHandler_Value = Guid.initString("e93dcf6c-4b07-4e1e-8123-aa16ed6eadf5");
pub const IID_IMFMediaTypeHandler = &IID_IMFMediaTypeHandler_Value;
pub const IMFMediaTypeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMediaTypeSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTypeHandler,
                pMediaType: ?*IMFMediaType,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTypeHandler,
                pMediaType: ?*IMFMediaType,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaTypeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTypeHandler,
                pdwTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTypeHandler,
                pdwTypeCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaTypeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTypeHandler,
                dwIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTypeHandler,
                dwIndex: u32,
                ppType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTypeHandler,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTypeHandler,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTypeHandler,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTypeHandler,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMajorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTypeHandler,
                pguidMajorType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTypeHandler,
                pguidMajorType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTypeHandler_IsMediaTypeSupported(self: *const T, pMediaType: ?*IMFMediaType, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFMediaTypeHandler.VTable, @ptrCast(self.vtable)).IsMediaTypeSupported(@as(*const IMFMediaTypeHandler, @ptrCast(self)), pMediaType, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTypeHandler_GetMediaTypeCount(self: *const T, pdwTypeCount: ?*u32) HRESULT {
                return @as(*const IMFMediaTypeHandler.VTable, @ptrCast(self.vtable)).GetMediaTypeCount(@as(*const IMFMediaTypeHandler, @ptrCast(self)), pdwTypeCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTypeHandler_GetMediaTypeByIndex(self: *const T, dwIndex: u32, ppType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFMediaTypeHandler.VTable, @ptrCast(self.vtable)).GetMediaTypeByIndex(@as(*const IMFMediaTypeHandler, @ptrCast(self)), dwIndex, ppType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTypeHandler_SetCurrentMediaType(self: *const T, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFMediaTypeHandler.VTable, @ptrCast(self.vtable)).SetCurrentMediaType(@as(*const IMFMediaTypeHandler, @ptrCast(self)), pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTypeHandler_GetCurrentMediaType(self: *const T, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFMediaTypeHandler.VTable, @ptrCast(self.vtable)).GetCurrentMediaType(@as(*const IMFMediaTypeHandler, @ptrCast(self)), ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTypeHandler_GetMajorType(self: *const T, pguidMajorType: ?*Guid) HRESULT {
                return @as(*const IMFMediaTypeHandler.VTable, @ptrCast(self.vtable)).GetMajorType(@as(*const IMFMediaTypeHandler, @ptrCast(self)), pguidMajorType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFTIMER_FLAGS = enum(i32) {
    E = 1,
};
pub const MFTIMER_RELATIVE = MFTIMER_FLAGS.E;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTimer_Value = Guid.initString("e56e4cbd-8f70-49d8-a0f8-edb3d6ab9bf2");
pub const IID_IMFTimer = &IID_IMFTimer_Value;
pub const IMFTimer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimer,
                dwFlags: u32,
                llClockTime: i64,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
                ppunkKey: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimer,
                dwFlags: u32,
                llClockTime: i64,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
                ppunkKey: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimer,
                punkKey: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimer,
                punkKey: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimer_SetTimer(self: *const T, dwFlags: u32, llClockTime: i64, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown, ppunkKey: ?*?*IUnknown) HRESULT {
                return @as(*const IMFTimer.VTable, @ptrCast(self.vtable)).SetTimer(@as(*const IMFTimer, @ptrCast(self)), dwFlags, llClockTime, pCallback, punkState, ppunkKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimer_CancelTimer(self: *const T, punkKey: ?*IUnknown) HRESULT {
                return @as(*const IMFTimer.VTable, @ptrCast(self.vtable)).CancelTimer(@as(*const IMFTimer, @ptrCast(self)), punkKey);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_ACTIVATE_CUSTOM_MIXER = enum(i32) {
    L = 1,
};
pub const MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = MF_ACTIVATE_CUSTOM_MIXER.L;

pub const MF_ACTIVATE_CUSTOM_PRESENTER = enum(i32) {
    L = 1,
};
pub const MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL = MF_ACTIVATE_CUSTOM_PRESENTER.L;

pub const MFSHUTDOWN_STATUS = enum(i32) {
    INITIATED = 0,
    COMPLETED = 1,
};
pub const MFSHUTDOWN_INITIATED = MFSHUTDOWN_STATUS.INITIATED;
pub const MFSHUTDOWN_COMPLETED = MFSHUTDOWN_STATUS.COMPLETED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFShutdown_Value = Guid.initString("97ec2ea4-0e42-4937-97ac-9d6d328824e1");
pub const IID_IMFShutdown = &IID_IMFShutdown_Value;
pub const IMFShutdown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFShutdown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFShutdown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShutdownStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFShutdown,
                pStatus: ?*MFSHUTDOWN_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFShutdown,
                pStatus: ?*MFSHUTDOWN_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFShutdown_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFShutdown.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFShutdown, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFShutdown_GetShutdownStatus(self: *const T, pStatus: ?*MFSHUTDOWN_STATUS) HRESULT {
                return @as(*const IMFShutdown.VTable, @ptrCast(self.vtable)).GetShutdownStatus(@as(*const IMFShutdown, @ptrCast(self)), pStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTopoLoader_Value = Guid.initString("de9a6157-f660-4643-b56a-df9f7998c7cd");
pub const IID_IMFTopoLoader = &IID_IMFTopoLoader_Value;
pub const IMFTopoLoader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopoLoader,
                pInputTopo: ?*IMFTopology,
                ppOutputTopo: ?*?*IMFTopology,
                pCurrentTopo: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopoLoader,
                pInputTopo: ?*IMFTopology,
                ppOutputTopo: ?*?*IMFTopology,
                pCurrentTopo: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopoLoader_Load(self: *const T, pInputTopo: ?*IMFTopology, ppOutputTopo: ?*?*IMFTopology, pCurrentTopo: ?*IMFTopology) HRESULT {
                return @as(*const IMFTopoLoader.VTable, @ptrCast(self.vtable)).Load(@as(*const IMFTopoLoader, @ptrCast(self)), pInputTopo, ppOutputTopo, pCurrentTopo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFContentProtectionManager_Value = Guid.initString("acf92459-6a61-42bd-b57c-b43e51203cb0");
pub const IID_IMFContentProtectionManager = &IID_IMFContentProtectionManager_Value;
pub const IMFContentProtectionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginEnableContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentProtectionManager,
                pEnablerActivate: ?*IMFActivate,
                pTopo: ?*IMFTopology,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentProtectionManager,
                pEnablerActivate: ?*IMFActivate,
                pTopo: ?*IMFTopology,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndEnableContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentProtectionManager,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentProtectionManager,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentProtectionManager_BeginEnableContent(self: *const T, pEnablerActivate: ?*IMFActivate, pTopo: ?*IMFTopology, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFContentProtectionManager.VTable, @ptrCast(self.vtable)).BeginEnableContent(@as(*const IMFContentProtectionManager, @ptrCast(self)), pEnablerActivate, pTopo, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentProtectionManager_EndEnableContent(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFContentProtectionManager.VTable, @ptrCast(self.vtable)).EndEnableContent(@as(*const IMFContentProtectionManager, @ptrCast(self)), pResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_URL_TRUST_STATUS = enum(i32) {
    UNTRUSTED = 0,
    TRUSTED = 1,
    TAMPERED = 2,
};
pub const MF_LICENSE_URL_UNTRUSTED = MF_URL_TRUST_STATUS.UNTRUSTED;
pub const MF_LICENSE_URL_TRUSTED = MF_URL_TRUST_STATUS.TRUSTED;
pub const MF_LICENSE_URL_TAMPERED = MF_URL_TRUST_STATUS.TAMPERED;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFContentEnabler_Value = Guid.initString("d3c4ef59-49ce-4381-9071-d5bcd044c770");
pub const IID_IMFContentEnabler = &IID_IMFContentEnabler_Value;
pub const IMFContentEnabler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnableType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
                pType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
                pType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
                ppwszURL: [*]?PWSTR,
                pcchURL: ?*u32,
                pTrustStatus: ?*MF_URL_TRUST_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
                ppwszURL: [*]?PWSTR,
                pcchURL: ?*u32,
                pTrustStatus: ?*MF_URL_TRUST_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnableData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
                ppbData: [*]?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
                ppbData: [*]?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAutomaticSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
                pfAutomatic: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
                pfAutomatic: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutomaticEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MonitorEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentEnabler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentEnabler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_GetEnableType(self: *const T, pType: ?*Guid) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).GetEnableType(@as(*const IMFContentEnabler, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_GetEnableURL(self: *const T, ppwszURL: [*]?PWSTR, pcchURL: ?*u32, pTrustStatus: ?*MF_URL_TRUST_STATUS) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).GetEnableURL(@as(*const IMFContentEnabler, @ptrCast(self)), ppwszURL, pcchURL, pTrustStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_GetEnableData(self: *const T, ppbData: [*]?*u8, pcbData: ?*u32) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).GetEnableData(@as(*const IMFContentEnabler, @ptrCast(self)), ppbData, pcbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_IsAutomaticSupported(self: *const T, pfAutomatic: ?*BOOL) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).IsAutomaticSupported(@as(*const IMFContentEnabler, @ptrCast(self)), pfAutomatic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_AutomaticEnable(self: *const T) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).AutomaticEnable(@as(*const IMFContentEnabler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_MonitorEnable(self: *const T) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).MonitorEnable(@as(*const IMFContentEnabler, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentEnabler_Cancel(self: *const T) HRESULT {
                return @as(*const IMFContentEnabler.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IMFContentEnabler, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFRR_COMPONENT_HASH_INFO = extern struct {
    ulReason: u32,
    rgHeaderHash: [43]u16,
    rgPublicKeyHash: [43]u16,
    wszName: [260]u16,
};

pub const MFRR_COMPONENTS = extern struct {
    dwRRInfoVersion: u32,
    dwRRComponents: u32,
    pRRComponents: ?*MFRR_COMPONENT_HASH_INFO,
};

pub const ASF_FLAT_PICTURE = extern struct {
    bPictureType: u8 align(1),
    dwDataLen: u32 align(1),
};

pub const ASF_FLAT_SYNCHRONISED_LYRICS = extern struct {
    bTimeStampFormat: u8 align(1),
    bContentType: u8 align(1),
    dwLyricsLen: u32 align(1),
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMetadata_Value = Guid.initString("f88cfb8c-ef16-4991-b450-cb8c69e51704");
pub const IID_IMFMetadata = &IID_IMFMetadata_Value;
pub const IMFMetadata = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                pwszRFC1766: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                pwszRFC1766: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                ppwszRFC1766: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                ppwszRFC1766: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllLanguages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                ppvLanguages: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                ppvLanguages: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                pwszName: ?[*:0]const u16,
                ppvValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                pwszName: ?[*:0]const u16,
                ppvValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                pwszName: ?[*:0]const u16,
                ppvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                pwszName: ?[*:0]const u16,
                ppvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                pwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                pwszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllPropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadata,
                ppvNames: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadata,
                ppvNames: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_SetLanguage(self: *const T, pwszRFC1766: ?[*:0]const u16) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).SetLanguage(@as(*const IMFMetadata, @ptrCast(self)), pwszRFC1766);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_GetLanguage(self: *const T, ppwszRFC1766: ?*?PWSTR) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IMFMetadata, @ptrCast(self)), ppwszRFC1766);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_GetAllLanguages(self: *const T, ppvLanguages: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).GetAllLanguages(@as(*const IMFMetadata, @ptrCast(self)), ppvLanguages);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_SetProperty(self: *const T, pwszName: ?[*:0]const u16, ppvValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IMFMetadata, @ptrCast(self)), pwszName, ppvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_GetProperty(self: *const T, pwszName: ?[*:0]const u16, ppvValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IMFMetadata, @ptrCast(self)), pwszName, ppvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_DeleteProperty(self: *const T, pwszName: ?[*:0]const u16) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).DeleteProperty(@as(*const IMFMetadata, @ptrCast(self)), pwszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadata_GetAllPropertyNames(self: *const T, ppvNames: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMetadata.VTable, @ptrCast(self.vtable)).GetAllPropertyNames(@as(*const IMFMetadata, @ptrCast(self)), ppvNames);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMetadataProvider_Value = Guid.initString("56181d2d-e221-4adb-b1c8-3cee6a53f76f");
pub const IID_IMFMetadataProvider = &IID_IMFMetadataProvider_Value;
pub const IMFMetadataProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMFMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMetadataProvider,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
                dwStreamIdentifier: u32,
                dwFlags: u32,
                ppMFMetadata: ?*?*IMFMetadata,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMetadataProvider,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
                dwStreamIdentifier: u32,
                dwFlags: u32,
                ppMFMetadata: ?*?*IMFMetadata,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMetadataProvider_GetMFMetadata(self: *const T, pPresentationDescriptor: ?*IMFPresentationDescriptor, dwStreamIdentifier: u32, dwFlags: u32, ppMFMetadata: ?*?*IMFMetadata) HRESULT {
                return @as(*const IMFMetadataProvider.VTable, @ptrCast(self.vtable)).GetMFMetadata(@as(*const IMFMetadataProvider, @ptrCast(self)), pPresentationDescriptor, dwStreamIdentifier, dwFlags, ppMFMetadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFRATE_DIRECTION = enum(i32) {
    FORWARD = 0,
    REVERSE = 1,
};
pub const MFRATE_FORWARD = MFRATE_DIRECTION.FORWARD;
pub const MFRATE_REVERSE = MFRATE_DIRECTION.REVERSE;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFRateSupport_Value = Guid.initString("0a9ccdbc-d797-4563-9667-94ec5d79292d");
pub const IID_IMFRateSupport = &IID_IMFRateSupport_Value;
pub const IMFRateSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSlowestRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRateSupport,
                eDirection: MFRATE_DIRECTION,
                fThin: BOOL,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRateSupport,
                eDirection: MFRATE_DIRECTION,
                fThin: BOOL,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFastestRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRateSupport,
                eDirection: MFRATE_DIRECTION,
                fThin: BOOL,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRateSupport,
                eDirection: MFRATE_DIRECTION,
                fThin: BOOL,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRateSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRateSupport,
                fThin: BOOL,
                flRate: f32,
                pflNearestSupportedRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRateSupport,
                fThin: BOOL,
                flRate: f32,
                pflNearestSupportedRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRateSupport_GetSlowestRate(self: *const T, eDirection: MFRATE_DIRECTION, fThin: BOOL, pflRate: ?*f32) HRESULT {
                return @as(*const IMFRateSupport.VTable, @ptrCast(self.vtable)).GetSlowestRate(@as(*const IMFRateSupport, @ptrCast(self)), eDirection, fThin, pflRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRateSupport_GetFastestRate(self: *const T, eDirection: MFRATE_DIRECTION, fThin: BOOL, pflRate: ?*f32) HRESULT {
                return @as(*const IMFRateSupport.VTable, @ptrCast(self.vtable)).GetFastestRate(@as(*const IMFRateSupport, @ptrCast(self)), eDirection, fThin, pflRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRateSupport_IsRateSupported(self: *const T, fThin: BOOL, flRate: f32, pflNearestSupportedRate: ?*f32) HRESULT {
                return @as(*const IMFRateSupport.VTable, @ptrCast(self.vtable)).IsRateSupported(@as(*const IMFRateSupport, @ptrCast(self)), fThin, flRate, pflNearestSupportedRate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFRateControl_Value = Guid.initString("88ddcd21-03c3-4275-91ed-55ee3929328f");
pub const IID_IMFRateControl = &IID_IMFRateControl_Value;
pub const IMFRateControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRateControl,
                fThin: BOOL,
                flRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRateControl,
                fThin: BOOL,
                flRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRateControl,
                pfThin: ?*BOOL,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRateControl,
                pfThin: ?*BOOL,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRateControl_SetRate(self: *const T, fThin: BOOL, flRate: f32) HRESULT {
                return @as(*const IMFRateControl.VTable, @ptrCast(self.vtable)).SetRate(@as(*const IMFRateControl, @ptrCast(self)), fThin, flRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRateControl_GetRate(self: *const T, pfThin: ?*BOOL, pflRate: ?*f32) HRESULT {
                return @as(*const IMFRateControl.VTable, @ptrCast(self.vtable)).GetRate(@as(*const IMFRateControl, @ptrCast(self)), pfThin, pflRate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFTimecodeTranslate_Value = Guid.initString("ab9d8661-f7e8-4ef4-9861-89f334f94e74");
pub const IID_IMFTimecodeTranslate = &IID_IMFTimecodeTranslate_Value;
pub const IMFTimecodeTranslate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginConvertTimecodeToHNS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimecodeTranslate,
                pPropVarTimecode: ?*const PROPVARIANT,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimecodeTranslate,
                pPropVarTimecode: ?*const PROPVARIANT,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndConvertTimecodeToHNS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimecodeTranslate,
                pResult: ?*IMFAsyncResult,
                phnsTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimecodeTranslate,
                pResult: ?*IMFAsyncResult,
                phnsTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginConvertHNSToTimecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimecodeTranslate,
                hnsTime: i64,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimecodeTranslate,
                hnsTime: i64,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndConvertHNSToTimecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimecodeTranslate,
                pResult: ?*IMFAsyncResult,
                pPropVarTimecode: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimecodeTranslate,
                pResult: ?*IMFAsyncResult,
                pPropVarTimecode: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimecodeTranslate_BeginConvertTimecodeToHNS(self: *const T, pPropVarTimecode: ?*const PROPVARIANT, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFTimecodeTranslate.VTable, @ptrCast(self.vtable)).BeginConvertTimecodeToHNS(@as(*const IMFTimecodeTranslate, @ptrCast(self)), pPropVarTimecode, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimecodeTranslate_EndConvertTimecodeToHNS(self: *const T, pResult: ?*IMFAsyncResult, phnsTime: ?*i64) HRESULT {
                return @as(*const IMFTimecodeTranslate.VTable, @ptrCast(self.vtable)).EndConvertTimecodeToHNS(@as(*const IMFTimecodeTranslate, @ptrCast(self)), pResult, phnsTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimecodeTranslate_BeginConvertHNSToTimecode(self: *const T, hnsTime: i64, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFTimecodeTranslate.VTable, @ptrCast(self.vtable)).BeginConvertHNSToTimecode(@as(*const IMFTimecodeTranslate, @ptrCast(self)), hnsTime, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimecodeTranslate_EndConvertHNSToTimecode(self: *const T, pResult: ?*IMFAsyncResult, pPropVarTimecode: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFTimecodeTranslate.VTable, @ptrCast(self.vtable)).EndConvertHNSToTimecode(@as(*const IMFTimecodeTranslate, @ptrCast(self)), pResult, pPropVarTimecode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSeekInfo_Value = Guid.initString("26afea53-d9ed-42b5-ab80-e64f9ee34779");
pub const IID_IMFSeekInfo = &IID_IMFSeekInfo_Value;
pub const IMFSeekInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNearestKeyFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSeekInfo,
                pguidTimeFormat: ?*const Guid,
                pvarStartPosition: ?*const PROPVARIANT,
                pvarPreviousKeyFrame: ?*PROPVARIANT,
                pvarNextKeyFrame: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSeekInfo,
                pguidTimeFormat: ?*const Guid,
                pvarStartPosition: ?*const PROPVARIANT,
                pvarPreviousKeyFrame: ?*PROPVARIANT,
                pvarNextKeyFrame: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSeekInfo_GetNearestKeyFrames(self: *const T, pguidTimeFormat: ?*const Guid, pvarStartPosition: ?*const PROPVARIANT, pvarPreviousKeyFrame: ?*PROPVARIANT, pvarNextKeyFrame: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFSeekInfo.VTable, @ptrCast(self.vtable)).GetNearestKeyFrames(@as(*const IMFSeekInfo, @ptrCast(self)), pguidTimeFormat, pvarStartPosition, pvarPreviousKeyFrame, pvarNextKeyFrame);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSimpleAudioVolume_Value = Guid.initString("089edf13-cf71-4338-8d13-9e569dbdc319");
pub const IID_IMFSimpleAudioVolume = &IID_IMFSimpleAudioVolume_Value;
pub const IMFSimpleAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSimpleAudioVolume,
                fLevel: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSimpleAudioVolume,
                fLevel: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMasterVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSimpleAudioVolume,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSimpleAudioVolume,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSimpleAudioVolume,
                bMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSimpleAudioVolume,
                bMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSimpleAudioVolume,
                pbMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSimpleAudioVolume,
                pbMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSimpleAudioVolume_SetMasterVolume(self: *const T, fLevel: f32) HRESULT {
                return @as(*const IMFSimpleAudioVolume.VTable, @ptrCast(self.vtable)).SetMasterVolume(@as(*const IMFSimpleAudioVolume, @ptrCast(self)), fLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSimpleAudioVolume_GetMasterVolume(self: *const T, pfLevel: ?*f32) HRESULT {
                return @as(*const IMFSimpleAudioVolume.VTable, @ptrCast(self.vtable)).GetMasterVolume(@as(*const IMFSimpleAudioVolume, @ptrCast(self)), pfLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSimpleAudioVolume_SetMute(self: *const T, bMute: BOOL) HRESULT {
                return @as(*const IMFSimpleAudioVolume.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IMFSimpleAudioVolume, @ptrCast(self)), bMute);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSimpleAudioVolume_GetMute(self: *const T, pbMute: ?*BOOL) HRESULT {
                return @as(*const IMFSimpleAudioVolume.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IMFSimpleAudioVolume, @ptrCast(self)), pbMute);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFAudioStreamVolume_Value = Guid.initString("76b1bbdb-4ec8-4f36-b106-70a9316df593");
pub const IID_IMFAudioStreamVolume = &IID_IMFAudioStreamVolume_Value;
pub const IMFAudioStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioStreamVolume,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioStreamVolume,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChannelVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioStreamVolume,
                dwIndex: u32,
                fLevel: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioStreamVolume,
                dwIndex: u32,
                fLevel: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChannelVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioStreamVolume,
                dwIndex: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioStreamVolume,
                dwIndex: u32,
                pfLevel: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]const f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]const f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllVolumes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioStreamVolume,
                dwCount: u32,
                pfVolumes: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioStreamVolume_GetChannelCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelCount(@as(*const IMFAudioStreamVolume, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioStreamVolume_SetChannelVolume(self: *const T, dwIndex: u32, fLevel: f32) HRESULT {
                return @as(*const IMFAudioStreamVolume.VTable, @ptrCast(self.vtable)).SetChannelVolume(@as(*const IMFAudioStreamVolume, @ptrCast(self)), dwIndex, fLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioStreamVolume_GetChannelVolume(self: *const T, dwIndex: u32, pfLevel: ?*f32) HRESULT {
                return @as(*const IMFAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetChannelVolume(@as(*const IMFAudioStreamVolume, @ptrCast(self)), dwIndex, pfLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioStreamVolume_SetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]const f32) HRESULT {
                return @as(*const IMFAudioStreamVolume.VTable, @ptrCast(self.vtable)).SetAllVolumes(@as(*const IMFAudioStreamVolume, @ptrCast(self)), dwCount, pfVolumes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioStreamVolume_GetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]f32) HRESULT {
                return @as(*const IMFAudioStreamVolume.VTable, @ptrCast(self.vtable)).GetAllVolumes(@as(*const IMFAudioStreamVolume, @ptrCast(self)), dwCount, pfVolumes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFAudioPolicy_Value = Guid.initString("a0638c2b-6465-4395-9ae7-a321a9fd2856");
pub const IID_IMFAudioPolicy = &IID_IMFAudioPolicy_Value;
pub const IMFAudioPolicy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGroupingParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioPolicy,
                rguidClass: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioPolicy,
                rguidClass: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupingParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioPolicy,
                pguidClass: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioPolicy,
                pguidClass: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioPolicy,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioPolicy,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioPolicy,
                pszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioPolicy,
                pszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIconPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioPolicy,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioPolicy,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFAudioPolicy,
                pszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFAudioPolicy,
                pszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioPolicy_SetGroupingParam(self: *const T, rguidClass: ?*const Guid) HRESULT {
                return @as(*const IMFAudioPolicy.VTable, @ptrCast(self.vtable)).SetGroupingParam(@as(*const IMFAudioPolicy, @ptrCast(self)), rguidClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioPolicy_GetGroupingParam(self: *const T, pguidClass: ?*Guid) HRESULT {
                return @as(*const IMFAudioPolicy.VTable, @ptrCast(self.vtable)).GetGroupingParam(@as(*const IMFAudioPolicy, @ptrCast(self)), pguidClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioPolicy_SetDisplayName(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IMFAudioPolicy.VTable, @ptrCast(self.vtable)).SetDisplayName(@as(*const IMFAudioPolicy, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioPolicy_GetDisplayName(self: *const T, pszName: ?*?PWSTR) HRESULT {
                return @as(*const IMFAudioPolicy.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IMFAudioPolicy, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioPolicy_SetIconPath(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IMFAudioPolicy.VTable, @ptrCast(self.vtable)).SetIconPath(@as(*const IMFAudioPolicy, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFAudioPolicy_GetIconPath(self: *const T, pszPath: ?*?PWSTR) HRESULT {
                return @as(*const IMFAudioPolicy.VTable, @ptrCast(self.vtable)).GetIconPath(@as(*const IMFAudioPolicy, @ptrCast(self)), pszPath);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSampleGrabberSinkCallback_Value = Guid.initString("8c7b80bf-ee42-4b59-b1df-55668e1bdca8");
pub const IID_IMFSampleGrabberSinkCallback = &IID_IMFSampleGrabberSinkCallback_Value;
pub const IMFSampleGrabberSinkCallback = extern struct {
    pub const VTable = extern struct {
        base: IMFClockStateSink.VTable,
        OnSetPresentationClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleGrabberSinkCallback,
                pPresentationClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleGrabberSinkCallback,
                pPresentationClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProcessSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleGrabberSinkCallback,
                guidMajorMediaType: ?*const Guid,
                dwSampleFlags: u32,
                llSampleTime: i64,
                llSampleDuration: i64,
                // TODO: what to do with BytesParamIndex 5?
                pSampleBuffer: ?*const u8,
                dwSampleSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleGrabberSinkCallback,
                guidMajorMediaType: ?*const Guid,
                dwSampleFlags: u32,
                llSampleTime: i64,
                llSampleDuration: i64,
                // TODO: what to do with BytesParamIndex 5?
                pSampleBuffer: ?*const u8,
                dwSampleSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnShutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleGrabberSinkCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleGrabberSinkCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFClockStateSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleGrabberSinkCallback_OnSetPresentationClock(self: *const T, pPresentationClock: ?*IMFPresentationClock) HRESULT {
                return @as(*const IMFSampleGrabberSinkCallback.VTable, @ptrCast(self.vtable)).OnSetPresentationClock(@as(*const IMFSampleGrabberSinkCallback, @ptrCast(self)), pPresentationClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleGrabberSinkCallback_OnProcessSample(self: *const T, guidMajorMediaType: ?*const Guid, dwSampleFlags: u32, llSampleTime: i64, llSampleDuration: i64, pSampleBuffer: ?*const u8, dwSampleSize: u32) HRESULT {
                return @as(*const IMFSampleGrabberSinkCallback.VTable, @ptrCast(self.vtable)).OnProcessSample(@as(*const IMFSampleGrabberSinkCallback, @ptrCast(self)), guidMajorMediaType, dwSampleFlags, llSampleTime, llSampleDuration, pSampleBuffer, dwSampleSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleGrabberSinkCallback_OnShutdown(self: *const T) HRESULT {
                return @as(*const IMFSampleGrabberSinkCallback.VTable, @ptrCast(self.vtable)).OnShutdown(@as(*const IMFSampleGrabberSinkCallback, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFSampleGrabberSinkCallback2_Value = Guid.initString("ca86aa50-c46e-429e-ab27-16d6ac6844cb");
pub const IID_IMFSampleGrabberSinkCallback2 = &IID_IMFSampleGrabberSinkCallback2_Value;
pub const IMFSampleGrabberSinkCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFSampleGrabberSinkCallback.VTable,
        OnProcessSampleEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleGrabberSinkCallback2,
                guidMajorMediaType: ?*const Guid,
                dwSampleFlags: u32,
                llSampleTime: i64,
                llSampleDuration: i64,
                // TODO: what to do with BytesParamIndex 5?
                pSampleBuffer: ?*const u8,
                dwSampleSize: u32,
                pAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleGrabberSinkCallback2,
                guidMajorMediaType: ?*const Guid,
                dwSampleFlags: u32,
                llSampleTime: i64,
                llSampleDuration: i64,
                // TODO: what to do with BytesParamIndex 5?
                pSampleBuffer: ?*const u8,
                dwSampleSize: u32,
                pAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFSampleGrabberSinkCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleGrabberSinkCallback2_OnProcessSampleEx(self: *const T, guidMajorMediaType: ?*const Guid, dwSampleFlags: u32, llSampleTime: i64, llSampleDuration: i64, pSampleBuffer: ?*const u8, dwSampleSize: u32, pAttributes: ?*IMFAttributes) HRESULT {
                return @as(*const IMFSampleGrabberSinkCallback2.VTable, @ptrCast(self.vtable)).OnProcessSampleEx(@as(*const IMFSampleGrabberSinkCallback2, @ptrCast(self)), guidMajorMediaType, dwSampleFlags, llSampleTime, llSampleDuration, pSampleBuffer, dwSampleSize, pAttributes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFWorkQueueServices_Value = Guid.initString("35fe1bb8-a3a9-40fe-bbec-eb569c9ccca3");
pub const IID_IMFWorkQueueServices = &IID_IMFWorkQueueServices_Value;
pub const IMFWorkQueueServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginRegisterTopologyWorkQueuesWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndRegisterTopologyWorkQueuesWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginUnregisterTopologyWorkQueuesWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUnregisterTopologyWorkQueuesWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTopologyWorkQueueMMCSSClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                dwTopologyWorkQueueId: u32,
                pwszClass: [*:0]u16,
                pcchClass: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                dwTopologyWorkQueueId: u32,
                pwszClass: [*:0]u16,
                pcchClass: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTopologyWorkQueueMMCSSTaskId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                dwTopologyWorkQueueId: u32,
                pdwTaskId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                dwTopologyWorkQueueId: u32,
                pdwTaskId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginRegisterPlatformWorkQueueWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueue: u32,
                wszClass: ?[*:0]const u16,
                dwTaskId: u32,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueue: u32,
                wszClass: ?[*:0]const u16,
                dwTaskId: u32,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndRegisterPlatformWorkQueueWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
                pdwTaskId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
                pdwTaskId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginUnregisterPlatformWorkQueueWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueue: u32,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueue: u32,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndUnregisterPlatformWorkQueueWithMMCSS: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlaftormWorkQueueMMCSSClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueueId: u32,
                pwszClass: [*:0]u16,
                pcchClass: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueueId: u32,
                pwszClass: [*:0]u16,
                pcchClass: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlatformWorkQueueMMCSSTaskId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueueId: u32,
                pdwTaskId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServices,
                dwPlatformWorkQueueId: u32,
                pdwTaskId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_BeginRegisterTopologyWorkQueuesWithMMCSS(self: *const T, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).BeginRegisterTopologyWorkQueuesWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_EndRegisterTopologyWorkQueuesWithMMCSS(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).EndRegisterTopologyWorkQueuesWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_BeginUnregisterTopologyWorkQueuesWithMMCSS(self: *const T, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).BeginUnregisterTopologyWorkQueuesWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_EndUnregisterTopologyWorkQueuesWithMMCSS(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).EndUnregisterTopologyWorkQueuesWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_GetTopologyWorkQueueMMCSSClass(self: *const T, dwTopologyWorkQueueId: u32, pwszClass: [*:0]u16, pcchClass: ?*u32) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).GetTopologyWorkQueueMMCSSClass(@as(*const IMFWorkQueueServices, @ptrCast(self)), dwTopologyWorkQueueId, pwszClass, pcchClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_GetTopologyWorkQueueMMCSSTaskId(self: *const T, dwTopologyWorkQueueId: u32, pdwTaskId: ?*u32) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).GetTopologyWorkQueueMMCSSTaskId(@as(*const IMFWorkQueueServices, @ptrCast(self)), dwTopologyWorkQueueId, pdwTaskId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_BeginRegisterPlatformWorkQueueWithMMCSS(self: *const T, dwPlatformWorkQueue: u32, wszClass: ?[*:0]const u16, dwTaskId: u32, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).BeginRegisterPlatformWorkQueueWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), dwPlatformWorkQueue, wszClass, dwTaskId, pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_EndRegisterPlatformWorkQueueWithMMCSS(self: *const T, pResult: ?*IMFAsyncResult, pdwTaskId: ?*u32) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).EndRegisterPlatformWorkQueueWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), pResult, pdwTaskId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_BeginUnregisterPlatformWorkQueueWithMMCSS(self: *const T, dwPlatformWorkQueue: u32, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).BeginUnregisterPlatformWorkQueueWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), dwPlatformWorkQueue, pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_EndUnregisterPlatformWorkQueueWithMMCSS(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).EndUnregisterPlatformWorkQueueWithMMCSS(@as(*const IMFWorkQueueServices, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_GetPlaftormWorkQueueMMCSSClass(self: *const T, dwPlatformWorkQueueId: u32, pwszClass: [*:0]u16, pcchClass: ?*u32) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).GetPlaftormWorkQueueMMCSSClass(@as(*const IMFWorkQueueServices, @ptrCast(self)), dwPlatformWorkQueueId, pwszClass, pcchClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServices_GetPlatformWorkQueueMMCSSTaskId(self: *const T, dwPlatformWorkQueueId: u32, pdwTaskId: ?*u32) HRESULT {
                return @as(*const IMFWorkQueueServices.VTable, @ptrCast(self.vtable)).GetPlatformWorkQueueMMCSSTaskId(@as(*const IMFWorkQueueServices, @ptrCast(self)), dwPlatformWorkQueueId, pdwTaskId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFWorkQueueServicesEx_Value = Guid.initString("96bf961b-40fe-42f1-ba9d-320238b49700");
pub const IID_IMFWorkQueueServicesEx = &IID_IMFWorkQueueServicesEx_Value;
pub const IMFWorkQueueServicesEx = extern struct {
    pub const VTable = extern struct {
        base: IMFWorkQueueServices.VTable,
        GetTopologyWorkQueueMMCSSPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServicesEx,
                dwTopologyWorkQueueId: u32,
                plPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServicesEx,
                dwTopologyWorkQueueId: u32,
                plPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginRegisterPlatformWorkQueueWithMMCSSEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServicesEx,
                dwPlatformWorkQueue: u32,
                wszClass: ?[*:0]const u16,
                dwTaskId: u32,
                lPriority: i32,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServicesEx,
                dwPlatformWorkQueue: u32,
                wszClass: ?[*:0]const u16,
                dwTaskId: u32,
                lPriority: i32,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlatformWorkQueueMMCSSPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFWorkQueueServicesEx,
                dwPlatformWorkQueueId: u32,
                plPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFWorkQueueServicesEx,
                dwPlatformWorkQueueId: u32,
                plPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFWorkQueueServices.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServicesEx_GetTopologyWorkQueueMMCSSPriority(self: *const T, dwTopologyWorkQueueId: u32, plPriority: ?*i32) HRESULT {
                return @as(*const IMFWorkQueueServicesEx.VTable, @ptrCast(self.vtable)).GetTopologyWorkQueueMMCSSPriority(@as(*const IMFWorkQueueServicesEx, @ptrCast(self)), dwTopologyWorkQueueId, plPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServicesEx_BeginRegisterPlatformWorkQueueWithMMCSSEx(self: *const T, dwPlatformWorkQueue: u32, wszClass: ?[*:0]const u16, dwTaskId: u32, lPriority: i32, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFWorkQueueServicesEx.VTable, @ptrCast(self.vtable)).BeginRegisterPlatformWorkQueueWithMMCSSEx(@as(*const IMFWorkQueueServicesEx, @ptrCast(self)), dwPlatformWorkQueue, wszClass, dwTaskId, lPriority, pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFWorkQueueServicesEx_GetPlatformWorkQueueMMCSSPriority(self: *const T, dwPlatformWorkQueueId: u32, plPriority: ?*i32) HRESULT {
                return @as(*const IMFWorkQueueServicesEx.VTable, @ptrCast(self.vtable)).GetPlatformWorkQueueMMCSSPriority(@as(*const IMFWorkQueueServicesEx, @ptrCast(self)), dwPlatformWorkQueueId, plPriority);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_QUALITY_DROP_MODE = enum(i32) {
    DROP_MODE_NONE = 0,
    DROP_MODE_1 = 1,
    DROP_MODE_2 = 2,
    DROP_MODE_3 = 3,
    DROP_MODE_4 = 4,
    DROP_MODE_5 = 5,
    NUM_DROP_MODES = 6,
};
pub const MF_DROP_MODE_NONE = MF_QUALITY_DROP_MODE.DROP_MODE_NONE;
pub const MF_DROP_MODE_1 = MF_QUALITY_DROP_MODE.DROP_MODE_1;
pub const MF_DROP_MODE_2 = MF_QUALITY_DROP_MODE.DROP_MODE_2;
pub const MF_DROP_MODE_3 = MF_QUALITY_DROP_MODE.DROP_MODE_3;
pub const MF_DROP_MODE_4 = MF_QUALITY_DROP_MODE.DROP_MODE_4;
pub const MF_DROP_MODE_5 = MF_QUALITY_DROP_MODE.DROP_MODE_5;
pub const MF_NUM_DROP_MODES = MF_QUALITY_DROP_MODE.NUM_DROP_MODES;

pub const MF_QUALITY_LEVEL = enum(i32) {
    QUALITY_NORMAL = 0,
    QUALITY_NORMAL_MINUS_1 = 1,
    QUALITY_NORMAL_MINUS_2 = 2,
    QUALITY_NORMAL_MINUS_3 = 3,
    QUALITY_NORMAL_MINUS_4 = 4,
    QUALITY_NORMAL_MINUS_5 = 5,
    NUM_QUALITY_LEVELS = 6,
};
pub const MF_QUALITY_NORMAL = MF_QUALITY_LEVEL.QUALITY_NORMAL;
pub const MF_QUALITY_NORMAL_MINUS_1 = MF_QUALITY_LEVEL.QUALITY_NORMAL_MINUS_1;
pub const MF_QUALITY_NORMAL_MINUS_2 = MF_QUALITY_LEVEL.QUALITY_NORMAL_MINUS_2;
pub const MF_QUALITY_NORMAL_MINUS_3 = MF_QUALITY_LEVEL.QUALITY_NORMAL_MINUS_3;
pub const MF_QUALITY_NORMAL_MINUS_4 = MF_QUALITY_LEVEL.QUALITY_NORMAL_MINUS_4;
pub const MF_QUALITY_NORMAL_MINUS_5 = MF_QUALITY_LEVEL.QUALITY_NORMAL_MINUS_5;
pub const MF_NUM_QUALITY_LEVELS = MF_QUALITY_LEVEL.NUM_QUALITY_LEVELS;

pub const MF_QUALITY_ADVISE_FLAGS = enum(i32) {
    P = 1,
};
pub const MF_QUALITY_CANNOT_KEEP_UP = MF_QUALITY_ADVISE_FLAGS.P;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFQualityManager_Value = Guid.initString("8d009d86-5b9f-4115-b1fc-9f80d52ab8ab");
pub const IID_IMFQualityManager = &IID_IMFQualityManager_Value;
pub const IMFQualityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityManager,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityManager,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyPresentationClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityManager,
                pClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityManager,
                pClock: ?*IMFPresentationClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyProcessInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityManager,
                pNode: ?*IMFTopologyNode,
                lInputIndex: i32,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityManager,
                pNode: ?*IMFTopologyNode,
                lInputIndex: i32,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyProcessOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityManager,
                pNode: ?*IMFTopologyNode,
                lOutputIndex: i32,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityManager,
                pNode: ?*IMFTopologyNode,
                lOutputIndex: i32,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyQualityEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityManager,
                pObject: ?*IUnknown,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityManager,
                pObject: ?*IUnknown,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityManager_NotifyTopology(self: *const T, pTopology: ?*IMFTopology) HRESULT {
                return @as(*const IMFQualityManager.VTable, @ptrCast(self.vtable)).NotifyTopology(@as(*const IMFQualityManager, @ptrCast(self)), pTopology);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityManager_NotifyPresentationClock(self: *const T, pClock: ?*IMFPresentationClock) HRESULT {
                return @as(*const IMFQualityManager.VTable, @ptrCast(self.vtable)).NotifyPresentationClock(@as(*const IMFQualityManager, @ptrCast(self)), pClock);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityManager_NotifyProcessInput(self: *const T, pNode: ?*IMFTopologyNode, lInputIndex: i32, pSample: ?*IMFSample) HRESULT {
                return @as(*const IMFQualityManager.VTable, @ptrCast(self.vtable)).NotifyProcessInput(@as(*const IMFQualityManager, @ptrCast(self)), pNode, lInputIndex, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityManager_NotifyProcessOutput(self: *const T, pNode: ?*IMFTopologyNode, lOutputIndex: i32, pSample: ?*IMFSample) HRESULT {
                return @as(*const IMFQualityManager.VTable, @ptrCast(self.vtable)).NotifyProcessOutput(@as(*const IMFQualityManager, @ptrCast(self)), pNode, lOutputIndex, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityManager_NotifyQualityEvent(self: *const T, pObject: ?*IUnknown, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFQualityManager.VTable, @ptrCast(self.vtable)).NotifyQualityEvent(@as(*const IMFQualityManager, @ptrCast(self)), pObject, pEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityManager_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFQualityManager.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFQualityManager, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFQualityAdvise_Value = Guid.initString("ec15e2e9-e36b-4f7c-8758-77d452ef4ce7");
pub const IID_IMFQualityAdvise = &IID_IMFQualityAdvise_Value;
pub const IMFQualityAdvise = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDropMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdvise,
                eDropMode: MF_QUALITY_DROP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdvise,
                eDropMode: MF_QUALITY_DROP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQualityLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdvise,
                eQualityLevel: MF_QUALITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdvise,
                eQualityLevel: MF_QUALITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDropMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdvise,
                peDropMode: ?*MF_QUALITY_DROP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdvise,
                peDropMode: ?*MF_QUALITY_DROP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQualityLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdvise,
                peQualityLevel: ?*MF_QUALITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdvise,
                peQualityLevel: ?*MF_QUALITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DropTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdvise,
                hnsAmountToDrop: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdvise,
                hnsAmountToDrop: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdvise_SetDropMode(self: *const T, eDropMode: MF_QUALITY_DROP_MODE) HRESULT {
                return @as(*const IMFQualityAdvise.VTable, @ptrCast(self.vtable)).SetDropMode(@as(*const IMFQualityAdvise, @ptrCast(self)), eDropMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdvise_SetQualityLevel(self: *const T, eQualityLevel: MF_QUALITY_LEVEL) HRESULT {
                return @as(*const IMFQualityAdvise.VTable, @ptrCast(self.vtable)).SetQualityLevel(@as(*const IMFQualityAdvise, @ptrCast(self)), eQualityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdvise_GetDropMode(self: *const T, peDropMode: ?*MF_QUALITY_DROP_MODE) HRESULT {
                return @as(*const IMFQualityAdvise.VTable, @ptrCast(self.vtable)).GetDropMode(@as(*const IMFQualityAdvise, @ptrCast(self)), peDropMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdvise_GetQualityLevel(self: *const T, peQualityLevel: ?*MF_QUALITY_LEVEL) HRESULT {
                return @as(*const IMFQualityAdvise.VTable, @ptrCast(self.vtable)).GetQualityLevel(@as(*const IMFQualityAdvise, @ptrCast(self)), peQualityLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdvise_DropTime(self: *const T, hnsAmountToDrop: i64) HRESULT {
                return @as(*const IMFQualityAdvise.VTable, @ptrCast(self.vtable)).DropTime(@as(*const IMFQualityAdvise, @ptrCast(self)), hnsAmountToDrop);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFQualityAdvise2_Value = Guid.initString("f3706f0d-8ea2-4886-8000-7155e9ec2eae");
pub const IID_IMFQualityAdvise2 = &IID_IMFQualityAdvise2_Value;
pub const IMFQualityAdvise2 = extern struct {
    pub const VTable = extern struct {
        base: IMFQualityAdvise.VTable,
        NotifyQualityEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdvise2,
                pEvent: ?*IMFMediaEvent,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdvise2,
                pEvent: ?*IMFMediaEvent,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFQualityAdvise.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdvise2_NotifyQualityEvent(self: *const T, pEvent: ?*IMFMediaEvent, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFQualityAdvise2.VTable, @ptrCast(self.vtable)).NotifyQualityEvent(@as(*const IMFQualityAdvise2, @ptrCast(self)), pEvent, pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFQualityAdviseLimits_Value = Guid.initString("dfcd8e4d-30b5-4567-acaa-8eb5b7853dc9");
pub const IID_IMFQualityAdviseLimits = &IID_IMFQualityAdviseLimits_Value;
pub const IMFQualityAdviseLimits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMaximumDropMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdviseLimits,
                peDropMode: ?*MF_QUALITY_DROP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdviseLimits,
                peDropMode: ?*MF_QUALITY_DROP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinimumQualityLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFQualityAdviseLimits,
                peQualityLevel: ?*MF_QUALITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFQualityAdviseLimits,
                peQualityLevel: ?*MF_QUALITY_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdviseLimits_GetMaximumDropMode(self: *const T, peDropMode: ?*MF_QUALITY_DROP_MODE) HRESULT {
                return @as(*const IMFQualityAdviseLimits.VTable, @ptrCast(self.vtable)).GetMaximumDropMode(@as(*const IMFQualityAdviseLimits, @ptrCast(self)), peDropMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFQualityAdviseLimits_GetMinimumQualityLevel(self: *const T, peQualityLevel: ?*MF_QUALITY_LEVEL) HRESULT {
                return @as(*const IMFQualityAdviseLimits.VTable, @ptrCast(self.vtable)).GetMinimumQualityLevel(@as(*const IMFQualityAdviseLimits, @ptrCast(self)), peQualityLevel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFRealTimeClient_Value = Guid.initString("2347d60b-3fb5-480c-8803-8df3adcd3ef0");
pub const IID_IMFRealTimeClient = &IID_IMFRealTimeClient_Value;
pub const IMFRealTimeClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRealTimeClient,
                dwTaskIndex: u32,
                wszClass: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRealTimeClient,
                dwTaskIndex: u32,
                wszClass: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRealTimeClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRealTimeClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWorkQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRealTimeClient,
                dwWorkQueueId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRealTimeClient,
                dwWorkQueueId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRealTimeClient_RegisterThreads(self: *const T, dwTaskIndex: u32, wszClass: ?[*:0]const u16) HRESULT {
                return @as(*const IMFRealTimeClient.VTable, @ptrCast(self.vtable)).RegisterThreads(@as(*const IMFRealTimeClient, @ptrCast(self)), dwTaskIndex, wszClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRealTimeClient_UnregisterThreads(self: *const T) HRESULT {
                return @as(*const IMFRealTimeClient.VTable, @ptrCast(self.vtable)).UnregisterThreads(@as(*const IMFRealTimeClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRealTimeClient_SetWorkQueue(self: *const T, dwWorkQueueId: u32) HRESULT {
                return @as(*const IMFRealTimeClient.VTable, @ptrCast(self.vtable)).SetWorkQueue(@as(*const IMFRealTimeClient, @ptrCast(self)), dwWorkQueueId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFRealTimeClientEx_Value = Guid.initString("03910848-ab16-4611-b100-17b88ae2f248");
pub const IID_IMFRealTimeClientEx = &IID_IMFRealTimeClientEx_Value;
pub const IMFRealTimeClientEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterThreadsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRealTimeClientEx,
                pdwTaskIndex: ?*u32,
                wszClassName: ?[*:0]const u16,
                lBasePriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRealTimeClientEx,
                pdwTaskIndex: ?*u32,
                wszClassName: ?[*:0]const u16,
                lBasePriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRealTimeClientEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRealTimeClientEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWorkQueueEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRealTimeClientEx,
                dwMultithreadedWorkQueueId: u32,
                lWorkItemBasePriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRealTimeClientEx,
                dwMultithreadedWorkQueueId: u32,
                lWorkItemBasePriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRealTimeClientEx_RegisterThreadsEx(self: *const T, pdwTaskIndex: ?*u32, wszClassName: ?[*:0]const u16, lBasePriority: i32) HRESULT {
                return @as(*const IMFRealTimeClientEx.VTable, @ptrCast(self.vtable)).RegisterThreadsEx(@as(*const IMFRealTimeClientEx, @ptrCast(self)), pdwTaskIndex, wszClassName, lBasePriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRealTimeClientEx_UnregisterThreads(self: *const T) HRESULT {
                return @as(*const IMFRealTimeClientEx.VTable, @ptrCast(self.vtable)).UnregisterThreads(@as(*const IMFRealTimeClientEx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRealTimeClientEx_SetWorkQueueEx(self: *const T, dwMultithreadedWorkQueueId: u32, lWorkItemBasePriority: i32) HRESULT {
                return @as(*const IMFRealTimeClientEx.VTable, @ptrCast(self.vtable)).SetWorkQueueEx(@as(*const IMFRealTimeClientEx, @ptrCast(self)), dwMultithreadedWorkQueueId, lWorkItemBasePriority);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFSequencerTopologyFlags = enum(i32) {
    t = 1,
};
pub const SequencerTopologyFlags_Last = MFSequencerTopologyFlags.t;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSequencerSource_Value = Guid.initString("197cd219-19cb-4de1-a64c-acf2edcbe59e");
pub const IID_IMFSequencerSource = &IID_IMFSequencerSource_Value;
pub const IMFSequencerSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AppendTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSequencerSource,
                pTopology: ?*IMFTopology,
                dwFlags: u32,
                pdwId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSequencerSource,
                pTopology: ?*IMFTopology,
                dwFlags: u32,
                pdwId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSequencerSource,
                dwId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSequencerSource,
                dwId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentationContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSequencerSource,
                pPD: ?*IMFPresentationDescriptor,
                pId: ?*u32,
                ppTopology: ?*?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSequencerSource,
                pPD: ?*IMFPresentationDescriptor,
                pId: ?*u32,
                ppTopology: ?*?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSequencerSource,
                dwId: u32,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSequencerSource,
                dwId: u32,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateTopologyFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSequencerSource,
                dwId: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSequencerSource,
                dwId: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSequencerSource_AppendTopology(self: *const T, pTopology: ?*IMFTopology, dwFlags: u32, pdwId: ?*u32) HRESULT {
                return @as(*const IMFSequencerSource.VTable, @ptrCast(self.vtable)).AppendTopology(@as(*const IMFSequencerSource, @ptrCast(self)), pTopology, dwFlags, pdwId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSequencerSource_DeleteTopology(self: *const T, dwId: u32) HRESULT {
                return @as(*const IMFSequencerSource.VTable, @ptrCast(self.vtable)).DeleteTopology(@as(*const IMFSequencerSource, @ptrCast(self)), dwId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSequencerSource_GetPresentationContext(self: *const T, pPD: ?*IMFPresentationDescriptor, pId: ?*u32, ppTopology: ?*?*IMFTopology) HRESULT {
                return @as(*const IMFSequencerSource.VTable, @ptrCast(self.vtable)).GetPresentationContext(@as(*const IMFSequencerSource, @ptrCast(self)), pPD, pId, ppTopology);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSequencerSource_UpdateTopology(self: *const T, dwId: u32, pTopology: ?*IMFTopology) HRESULT {
                return @as(*const IMFSequencerSource.VTable, @ptrCast(self.vtable)).UpdateTopology(@as(*const IMFSequencerSource, @ptrCast(self)), dwId, pTopology);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSequencerSource_UpdateTopologyFlags(self: *const T, dwId: u32, dwFlags: u32) HRESULT {
                return @as(*const IMFSequencerSource.VTable, @ptrCast(self.vtable)).UpdateTopologyFlags(@as(*const IMFSequencerSource, @ptrCast(self)), dwId, dwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaSourceTopologyProvider_Value = Guid.initString("0e1d6009-c9f3-442d-8c51-a42d2d49452f");
pub const IID_IMFMediaSourceTopologyProvider = &IID_IMFMediaSourceTopologyProvider_Value;
pub const IMFMediaSourceTopologyProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaSourceTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceTopologyProvider,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
                ppTopology: ?*?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceTopologyProvider,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
                ppTopology: ?*?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceTopologyProvider_GetMediaSourceTopology(self: *const T, pPresentationDescriptor: ?*IMFPresentationDescriptor, ppTopology: ?*?*IMFTopology) HRESULT {
                return @as(*const IMFMediaSourceTopologyProvider.VTable, @ptrCast(self.vtable)).GetMediaSourceTopology(@as(*const IMFMediaSourceTopologyProvider, @ptrCast(self)), pPresentationDescriptor, ppTopology);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaSourcePresentationProvider_Value = Guid.initString("0e1d600a-c9f3-442d-8c51-a42d2d49452f");
pub const IID_IMFMediaSourcePresentationProvider = &IID_IMFMediaSourcePresentationProvider_Value;
pub const IMFMediaSourcePresentationProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ForceEndOfPresentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourcePresentationProvider,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourcePresentationProvider,
                pPresentationDescriptor: ?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourcePresentationProvider_ForceEndOfPresentation(self: *const T, pPresentationDescriptor: ?*IMFPresentationDescriptor) HRESULT {
                return @as(*const IMFMediaSourcePresentationProvider.VTable, @ptrCast(self.vtable)).ForceEndOfPresentation(@as(*const IMFMediaSourcePresentationProvider, @ptrCast(self)), pPresentationDescriptor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFTOPONODE_ATTRIBUTE_UPDATE = extern struct {
    NodeId: u64,
    guidAttributeKey: Guid,
    attrType: MF_ATTRIBUTE_TYPE,
    Anonymous: extern union {
        u32: u32,
        u64: u64,
        d: f64,
    },
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTopologyNodeAttributeEditor_Value = Guid.initString("676aa6dd-238a-410d-bb99-65668d01605a");
pub const IID_IMFTopologyNodeAttributeEditor = &IID_IMFTopologyNodeAttributeEditor_Value;
pub const IMFTopologyNodeAttributeEditor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateNodeAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyNodeAttributeEditor,
                TopoId: u64,
                cUpdates: u32,
                pUpdates: [*]MFTOPONODE_ATTRIBUTE_UPDATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyNodeAttributeEditor,
                TopoId: u64,
                cUpdates: u32,
                pUpdates: [*]MFTOPONODE_ATTRIBUTE_UPDATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyNodeAttributeEditor_UpdateNodeAttributes(self: *const T, TopoId: u64, cUpdates: u32, pUpdates: [*]MFTOPONODE_ATTRIBUTE_UPDATE) HRESULT {
                return @as(*const IMFTopologyNodeAttributeEditor.VTable, @ptrCast(self.vtable)).UpdateNodeAttributes(@as(*const IMFTopologyNodeAttributeEditor, @ptrCast(self)), TopoId, cUpdates, pUpdates);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_LEAKY_BUCKET_PAIR = extern struct {
    dwBitrate: u32,
    msBufferWindow: u32,
};

pub const MFBYTESTREAM_BUFFERING_PARAMS = extern struct {
    cbTotalFileSize: u64,
    cbPlayableDataSize: u64,
    prgBuckets: ?*MF_LEAKY_BUCKET_PAIR,
    cBuckets: u32,
    qwNetBufferingTime: u64,
    qwExtraBufferingTimeDuringSeek: u64,
    qwPlayDuration: u64,
    dRate: f32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFByteStreamBuffering_Value = Guid.initString("6d66d782-1d4f-4db7-8c63-cb8c77f1ef5e");
pub const IID_IMFByteStreamBuffering = &IID_IMFByteStreamBuffering_Value;
pub const IMFByteStreamBuffering = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBufferingParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamBuffering,
                pParams: ?*MFBYTESTREAM_BUFFERING_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamBuffering,
                pParams: ?*MFBYTESTREAM_BUFFERING_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableBuffering: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamBuffering,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamBuffering,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopBuffering: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamBuffering,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamBuffering,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamBuffering_SetBufferingParams(self: *const T, pParams: ?*MFBYTESTREAM_BUFFERING_PARAMS) HRESULT {
                return @as(*const IMFByteStreamBuffering.VTable, @ptrCast(self.vtable)).SetBufferingParams(@as(*const IMFByteStreamBuffering, @ptrCast(self)), pParams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamBuffering_EnableBuffering(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IMFByteStreamBuffering.VTable, @ptrCast(self.vtable)).EnableBuffering(@as(*const IMFByteStreamBuffering, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamBuffering_StopBuffering(self: *const T) HRESULT {
                return @as(*const IMFByteStreamBuffering.VTable, @ptrCast(self.vtable)).StopBuffering(@as(*const IMFByteStreamBuffering, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFByteStreamCacheControl_Value = Guid.initString("f5042ea4-7a96-4a75-aa7b-2be1ef7f88d5");
pub const IID_IMFByteStreamCacheControl = &IID_IMFByteStreamCacheControl_Value;
pub const IMFByteStreamCacheControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StopBackgroundTransfer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamCacheControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamCacheControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamCacheControl_StopBackgroundTransfer(self: *const T) HRESULT {
                return @as(*const IMFByteStreamCacheControl.VTable, @ptrCast(self.vtable)).StopBackgroundTransfer(@as(*const IMFByteStreamCacheControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFByteStreamTimeSeek_Value = Guid.initString("64976bfa-fb61-4041-9069-8c9a5f659beb");
pub const IID_IMFByteStreamTimeSeek = &IID_IMFByteStreamTimeSeek_Value;
pub const IMFByteStreamTimeSeek = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTimeSeekSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamTimeSeek,
                pfTimeSeekIsSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamTimeSeek,
                pfTimeSeekIsSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TimeSeek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamTimeSeek,
                qwTimePosition: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamTimeSeek,
                qwTimePosition: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeSeekResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamTimeSeek,
                pqwStartTime: ?*u64,
                pqwStopTime: ?*u64,
                pqwDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamTimeSeek,
                pqwStartTime: ?*u64,
                pqwStopTime: ?*u64,
                pqwDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamTimeSeek_IsTimeSeekSupported(self: *const T, pfTimeSeekIsSupported: ?*BOOL) HRESULT {
                return @as(*const IMFByteStreamTimeSeek.VTable, @ptrCast(self.vtable)).IsTimeSeekSupported(@as(*const IMFByteStreamTimeSeek, @ptrCast(self)), pfTimeSeekIsSupported);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamTimeSeek_TimeSeek(self: *const T, qwTimePosition: u64) HRESULT {
                return @as(*const IMFByteStreamTimeSeek.VTable, @ptrCast(self.vtable)).TimeSeek(@as(*const IMFByteStreamTimeSeek, @ptrCast(self)), qwTimePosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamTimeSeek_GetTimeSeekResult(self: *const T, pqwStartTime: ?*u64, pqwStopTime: ?*u64, pqwDuration: ?*u64) HRESULT {
                return @as(*const IMFByteStreamTimeSeek.VTable, @ptrCast(self.vtable)).GetTimeSeekResult(@as(*const IMFByteStreamTimeSeek, @ptrCast(self)), pqwStartTime, pqwStopTime, pqwDuration);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_BYTE_STREAM_CACHE_RANGE = extern struct {
    qwStartOffset: u64,
    qwEndOffset: u64,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFByteStreamCacheControl2_Value = Guid.initString("71ce469c-f34b-49ea-a56b-2d2a10e51149");
pub const IID_IMFByteStreamCacheControl2 = &IID_IMFByteStreamCacheControl2_Value;
pub const IMFByteStreamCacheControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFByteStreamCacheControl.VTable,
        GetByteRanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamCacheControl2,
                pcRanges: ?*u32,
                ppRanges: [*]?*MF_BYTE_STREAM_CACHE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamCacheControl2,
                pcRanges: ?*u32,
                ppRanges: [*]?*MF_BYTE_STREAM_CACHE_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCacheLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamCacheControl2,
                qwBytes: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamCacheControl2,
                qwBytes: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsBackgroundTransferActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamCacheControl2,
                pfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamCacheControl2,
                pfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFByteStreamCacheControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamCacheControl2_GetByteRanges(self: *const T, pcRanges: ?*u32, ppRanges: [*]?*MF_BYTE_STREAM_CACHE_RANGE) HRESULT {
                return @as(*const IMFByteStreamCacheControl2.VTable, @ptrCast(self.vtable)).GetByteRanges(@as(*const IMFByteStreamCacheControl2, @ptrCast(self)), pcRanges, ppRanges);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamCacheControl2_SetCacheLimit(self: *const T, qwBytes: u64) HRESULT {
                return @as(*const IMFByteStreamCacheControl2.VTable, @ptrCast(self.vtable)).SetCacheLimit(@as(*const IMFByteStreamCacheControl2, @ptrCast(self)), qwBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamCacheControl2_IsBackgroundTransferActive(self: *const T, pfActive: ?*BOOL) HRESULT {
                return @as(*const IMFByteStreamCacheControl2.VTable, @ptrCast(self.vtable)).IsBackgroundTransferActive(@as(*const IMFByteStreamCacheControl2, @ptrCast(self)), pfActive);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFNetCredential_Value = Guid.initString("5b87ef6a-7ed8-434f-ba0e-184fac1628d1");
pub const IID_IMFNetCredential = &IID_IMFNetCredential_Value;
pub const IMFNetCredential = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredential,
                // TODO: what to do with BytesParamIndex 1?
                pbData: ?*u8,
                cbData: u32,
                fDataIsEncrypted: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredential,
                // TODO: what to do with BytesParamIndex 1?
                pbData: ?*u8,
                cbData: u32,
                fDataIsEncrypted: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredential,
                // TODO: what to do with BytesParamIndex 1?
                pbData: ?*u8,
                cbData: u32,
                fDataIsEncrypted: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredential,
                // TODO: what to do with BytesParamIndex 1?
                pbData: ?*u8,
                cbData: u32,
                fDataIsEncrypted: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredential,
                pbData: ?[*:0]u8,
                pcbData: ?*u32,
                fEncryptData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredential,
                pbData: ?[*:0]u8,
                pcbData: ?*u32,
                fEncryptData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredential,
                pbData: ?[*:0]u8,
                pcbData: ?*u32,
                fEncryptData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredential,
                pbData: ?[*:0]u8,
                pcbData: ?*u32,
                fEncryptData: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoggedOnUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredential,
                pfLoggedOnUser: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredential,
                pfLoggedOnUser: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredential_SetUser(self: *const T, pbData: ?*u8, cbData: u32, fDataIsEncrypted: BOOL) HRESULT {
                return @as(*const IMFNetCredential.VTable, @ptrCast(self.vtable)).SetUser(@as(*const IMFNetCredential, @ptrCast(self)), pbData, cbData, fDataIsEncrypted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredential_SetPassword(self: *const T, pbData: ?*u8, cbData: u32, fDataIsEncrypted: BOOL) HRESULT {
                return @as(*const IMFNetCredential.VTable, @ptrCast(self.vtable)).SetPassword(@as(*const IMFNetCredential, @ptrCast(self)), pbData, cbData, fDataIsEncrypted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredential_GetUser(self: *const T, pbData: ?[*:0]u8, pcbData: ?*u32, fEncryptData: BOOL) HRESULT {
                return @as(*const IMFNetCredential.VTable, @ptrCast(self.vtable)).GetUser(@as(*const IMFNetCredential, @ptrCast(self)), pbData, pcbData, fEncryptData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredential_GetPassword(self: *const T, pbData: ?[*:0]u8, pcbData: ?*u32, fEncryptData: BOOL) HRESULT {
                return @as(*const IMFNetCredential.VTable, @ptrCast(self.vtable)).GetPassword(@as(*const IMFNetCredential, @ptrCast(self)), pbData, pcbData, fEncryptData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredential_LoggedOnUser(self: *const T, pfLoggedOnUser: ?*BOOL) HRESULT {
                return @as(*const IMFNetCredential.VTable, @ptrCast(self.vtable)).LoggedOnUser(@as(*const IMFNetCredential, @ptrCast(self)), pfLoggedOnUser);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFNetCredentialManagerGetParam = extern struct {
    hrOp: HRESULT,
    fAllowLoggedOnUser: BOOL,
    fClearTextPackage: BOOL,
    pszUrl: ?[*:0]const u16,
    pszSite: ?[*:0]const u16,
    pszRealm: ?[*:0]const u16,
    pszPackage: ?[*:0]const u16,
    nRetries: i32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFNetCredentialManager_Value = Guid.initString("5b87ef6b-7ed8-434f-ba0e-184fac1628d1");
pub const IID_IMFNetCredentialManager = &IID_IMFNetCredentialManager_Value;
pub const IMFNetCredentialManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginGetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredentialManager,
                pParam: ?*MFNetCredentialManagerGetParam,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredentialManager,
                pParam: ?*MFNetCredentialManagerGetParam,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndGetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredentialManager,
                pResult: ?*IMFAsyncResult,
                ppCred: ?*?*IMFNetCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredentialManager,
                pResult: ?*IMFAsyncResult,
                ppCred: ?*?*IMFNetCredential,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGood: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredentialManager,
                pCred: ?*IMFNetCredential,
                fGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredentialManager,
                pCred: ?*IMFNetCredential,
                fGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredentialManager_BeginGetCredentials(self: *const T, pParam: ?*MFNetCredentialManagerGetParam, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFNetCredentialManager.VTable, @ptrCast(self.vtable)).BeginGetCredentials(@as(*const IMFNetCredentialManager, @ptrCast(self)), pParam, pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredentialManager_EndGetCredentials(self: *const T, pResult: ?*IMFAsyncResult, ppCred: ?*?*IMFNetCredential) HRESULT {
                return @as(*const IMFNetCredentialManager.VTable, @ptrCast(self.vtable)).EndGetCredentials(@as(*const IMFNetCredentialManager, @ptrCast(self)), pResult, ppCred);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredentialManager_SetGood(self: *const T, pCred: ?*IMFNetCredential, fGood: BOOL) HRESULT {
                return @as(*const IMFNetCredentialManager.VTable, @ptrCast(self.vtable)).SetGood(@as(*const IMFNetCredentialManager, @ptrCast(self)), pCred, fGood);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFNetCredentialRequirements = enum(i32) {
    PROMPT = 1,
    SAVE_SELECTED = 2,
};
pub const REQUIRE_PROMPT = MFNetCredentialRequirements.PROMPT;
pub const REQUIRE_SAVE_SELECTED = MFNetCredentialRequirements.SAVE_SELECTED;

pub const MFNetCredentialOptions = enum(i32) {
    SAVE = 1,
    DONT_CACHE = 2,
    ALLOW_CLEAR_TEXT = 4,
};
pub const MFNET_CREDENTIAL_SAVE = MFNetCredentialOptions.SAVE;
pub const MFNET_CREDENTIAL_DONT_CACHE = MFNetCredentialOptions.DONT_CACHE;
pub const MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT = MFNetCredentialOptions.ALLOW_CLEAR_TEXT;

pub const MFNetAuthenticationFlags = enum(i32) {
    PROXY = 1,
    CLEAR_TEXT = 2,
    LOGGED_ON_USER = 4,
};
pub const MFNET_AUTHENTICATION_PROXY = MFNetAuthenticationFlags.PROXY;
pub const MFNET_AUTHENTICATION_CLEAR_TEXT = MFNetAuthenticationFlags.CLEAR_TEXT;
pub const MFNET_AUTHENTICATION_LOGGED_ON_USER = MFNetAuthenticationFlags.LOGGED_ON_USER;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFNetCredentialCache_Value = Guid.initString("5b87ef6c-7ed8-434f-ba0e-184fac1628d1");
pub const IID_IMFNetCredentialCache = &IID_IMFNetCredentialCache_Value;
pub const IMFNetCredentialCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCredential: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredentialCache,
                pszUrl: ?[*:0]const u16,
                pszRealm: ?[*:0]const u16,
                dwAuthenticationFlags: u32,
                ppCred: ?*?*IMFNetCredential,
                pdwRequirementsFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredentialCache,
                pszUrl: ?[*:0]const u16,
                pszRealm: ?[*:0]const u16,
                dwAuthenticationFlags: u32,
                ppCred: ?*?*IMFNetCredential,
                pdwRequirementsFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGood: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredentialCache,
                pCred: ?*IMFNetCredential,
                fGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredentialCache,
                pCred: ?*IMFNetCredential,
                fGood: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUserOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCredentialCache,
                pCred: ?*IMFNetCredential,
                dwOptionsFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCredentialCache,
                pCred: ?*IMFNetCredential,
                dwOptionsFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredentialCache_GetCredential(self: *const T, pszUrl: ?[*:0]const u16, pszRealm: ?[*:0]const u16, dwAuthenticationFlags: u32, ppCred: ?*?*IMFNetCredential, pdwRequirementsFlags: ?*u32) HRESULT {
                return @as(*const IMFNetCredentialCache.VTable, @ptrCast(self.vtable)).GetCredential(@as(*const IMFNetCredentialCache, @ptrCast(self)), pszUrl, pszRealm, dwAuthenticationFlags, ppCred, pdwRequirementsFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredentialCache_SetGood(self: *const T, pCred: ?*IMFNetCredential, fGood: BOOL) HRESULT {
                return @as(*const IMFNetCredentialCache.VTable, @ptrCast(self.vtable)).SetGood(@as(*const IMFNetCredentialCache, @ptrCast(self)), pCred, fGood);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCredentialCache_SetUserOptions(self: *const T, pCred: ?*IMFNetCredential, dwOptionsFlags: u32) HRESULT {
                return @as(*const IMFNetCredentialCache.VTable, @ptrCast(self.vtable)).SetUserOptions(@as(*const IMFNetCredentialCache, @ptrCast(self)), pCred, dwOptionsFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFSSLCertificateManager_Value = Guid.initString("61f7d887-1230-4a8b-aeba-8ad434d1a64d");
pub const IID_IMFSSLCertificateManager = &IID_IMFSSLCertificateManager_Value;
pub const IMFSSLCertificateManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                ppbData: ?*?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                ppbData: ?*?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginGetClientCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndGetClientCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSSLCertificateManager,
                pResult: ?*IMFAsyncResult,
                ppbData: ?*?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSSLCertificateManager,
                pResult: ?*IMFAsyncResult,
                ppbData: ?*?*u8,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCertificatePolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                pfOverrideAutomaticCheck: ?*BOOL,
                pfClientCertificateAvailable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                pfOverrideAutomaticCheck: ?*BOOL,
                pfClientCertificateAvailable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnServerCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 2?
                pbData: ?*u8,
                cbData: u32,
                pfIsGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSSLCertificateManager,
                pszURL: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 2?
                pbData: ?*u8,
                cbData: u32,
                pfIsGood: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSSLCertificateManager_GetClientCertificate(self: *const T, pszURL: ?[*:0]const u16, ppbData: ?*?*u8, pcbData: ?*u32) HRESULT {
                return @as(*const IMFSSLCertificateManager.VTable, @ptrCast(self.vtable)).GetClientCertificate(@as(*const IMFSSLCertificateManager, @ptrCast(self)), pszURL, ppbData, pcbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSSLCertificateManager_BeginGetClientCertificate(self: *const T, pszURL: ?[*:0]const u16, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFSSLCertificateManager.VTable, @ptrCast(self.vtable)).BeginGetClientCertificate(@as(*const IMFSSLCertificateManager, @ptrCast(self)), pszURL, pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSSLCertificateManager_EndGetClientCertificate(self: *const T, pResult: ?*IMFAsyncResult, ppbData: ?*?*u8, pcbData: ?*u32) HRESULT {
                return @as(*const IMFSSLCertificateManager.VTable, @ptrCast(self.vtable)).EndGetClientCertificate(@as(*const IMFSSLCertificateManager, @ptrCast(self)), pResult, ppbData, pcbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSSLCertificateManager_GetCertificatePolicy(self: *const T, pszURL: ?[*:0]const u16, pfOverrideAutomaticCheck: ?*BOOL, pfClientCertificateAvailable: ?*BOOL) HRESULT {
                return @as(*const IMFSSLCertificateManager.VTable, @ptrCast(self.vtable)).GetCertificatePolicy(@as(*const IMFSSLCertificateManager, @ptrCast(self)), pszURL, pfOverrideAutomaticCheck, pfClientCertificateAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSSLCertificateManager_OnServerCertificate(self: *const T, pszURL: ?[*:0]const u16, pbData: ?*u8, cbData: u32, pfIsGood: ?*BOOL) HRESULT {
                return @as(*const IMFSSLCertificateManager.VTable, @ptrCast(self.vtable)).OnServerCertificate(@as(*const IMFSSLCertificateManager, @ptrCast(self)), pszURL, pbData, cbData, pfIsGood);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFNetResourceFilter_Value = Guid.initString("091878a3-bf11-4a5c-bc9f-33995b06ef2d");
pub const IID_IMFNetResourceFilter = &IID_IMFNetResourceFilter_Value;
pub const IMFNetResourceFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRedirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetResourceFilter,
                pszUrl: ?[*:0]const u16,
                pvbCancel: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetResourceFilter,
                pszUrl: ?[*:0]const u16,
                pvbCancel: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSendingRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetResourceFilter,
                pszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetResourceFilter,
                pszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetResourceFilter_OnRedirect(self: *const T, pszUrl: ?[*:0]const u16, pvbCancel: ?*i16) HRESULT {
                return @as(*const IMFNetResourceFilter.VTable, @ptrCast(self.vtable)).OnRedirect(@as(*const IMFNetResourceFilter, @ptrCast(self)), pszUrl, pvbCancel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetResourceFilter_OnSendingRequest(self: *const T, pszUrl: ?[*:0]const u16) HRESULT {
                return @as(*const IMFNetResourceFilter.VTable, @ptrCast(self.vtable)).OnSendingRequest(@as(*const IMFNetResourceFilter, @ptrCast(self)), pszUrl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSourceOpenMonitor_Value = Guid.initString("059054b3-027c-494c-a27d-9113291cf87f");
pub const IID_IMFSourceOpenMonitor = &IID_IMFSourceOpenMonitor_Value;
pub const IMFSourceOpenMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSourceEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceOpenMonitor,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceOpenMonitor,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceOpenMonitor_OnSourceEvent(self: *const T, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFSourceOpenMonitor.VTable, @ptrCast(self.vtable)).OnSourceEvent(@as(*const IMFSourceOpenMonitor, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFNetProxyLocator_Value = Guid.initString("e9cd0383-a268-4bb4-82de-658d53574d41");
pub const IID_IMFNetProxyLocator = &IID_IMFNetProxyLocator_Value;
pub const IMFNetProxyLocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindFirstProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetProxyLocator,
                pszHost: ?[*:0]const u16,
                pszUrl: ?[*:0]const u16,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetProxyLocator,
                pszHost: ?[*:0]const u16,
                pszUrl: ?[*:0]const u16,
                fReserved: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindNextProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetProxyLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetProxyLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterProxyResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetProxyLocator,
                hrOp: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetProxyLocator,
                hrOp: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetProxyLocator,
                pszStr: ?[*:0]u16,
                pcchStr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetProxyLocator,
                pszStr: ?[*:0]u16,
                pcchStr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetProxyLocator,
                ppProxyLocator: ?*?*IMFNetProxyLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetProxyLocator,
                ppProxyLocator: ?*?*IMFNetProxyLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetProxyLocator_FindFirstProxy(self: *const T, pszHost: ?[*:0]const u16, pszUrl: ?[*:0]const u16, fReserved: BOOL) HRESULT {
                return @as(*const IMFNetProxyLocator.VTable, @ptrCast(self.vtable)).FindFirstProxy(@as(*const IMFNetProxyLocator, @ptrCast(self)), pszHost, pszUrl, fReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetProxyLocator_FindNextProxy(self: *const T) HRESULT {
                return @as(*const IMFNetProxyLocator.VTable, @ptrCast(self.vtable)).FindNextProxy(@as(*const IMFNetProxyLocator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetProxyLocator_RegisterProxyResult(self: *const T, hrOp: HRESULT) HRESULT {
                return @as(*const IMFNetProxyLocator.VTable, @ptrCast(self.vtable)).RegisterProxyResult(@as(*const IMFNetProxyLocator, @ptrCast(self)), hrOp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetProxyLocator_GetCurrentProxy(self: *const T, pszStr: ?[*:0]u16, pcchStr: ?*u32) HRESULT {
                return @as(*const IMFNetProxyLocator.VTable, @ptrCast(self.vtable)).GetCurrentProxy(@as(*const IMFNetProxyLocator, @ptrCast(self)), pszStr, pcchStr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetProxyLocator_Clone(self: *const T, ppProxyLocator: ?*?*IMFNetProxyLocator) HRESULT {
                return @as(*const IMFNetProxyLocator.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMFNetProxyLocator, @ptrCast(self)), ppProxyLocator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFNetProxyLocatorFactory_Value = Guid.initString("e9cd0384-a268-4bb4-82de-658d53574d41");
pub const IID_IMFNetProxyLocatorFactory = &IID_IMFNetProxyLocatorFactory_Value;
pub const IMFNetProxyLocatorFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProxyLocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetProxyLocatorFactory,
                pszProtocol: ?[*:0]const u16,
                ppProxyLocator: ?*?*IMFNetProxyLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetProxyLocatorFactory,
                pszProtocol: ?[*:0]const u16,
                ppProxyLocator: ?*?*IMFNetProxyLocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetProxyLocatorFactory_CreateProxyLocator(self: *const T, pszProtocol: ?[*:0]const u16, ppProxyLocator: ?*?*IMFNetProxyLocator) HRESULT {
                return @as(*const IMFNetProxyLocatorFactory.VTable, @ptrCast(self.vtable)).CreateProxyLocator(@as(*const IMFNetProxyLocatorFactory, @ptrCast(self)), pszProtocol, ppProxyLocator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSaveJob_Value = Guid.initString("e9931663-80bf-4c6e-98af-5dcf58747d1f");
pub const IID_IMFSaveJob = &IID_IMFSaveJob_Value;
pub const IMFSaveJob = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSaveJob,
                pStream: ?*IMFByteStream,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSaveJob,
                pStream: ?*IMFByteStream,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSaveJob,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSaveJob,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSaveJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSaveJob,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSaveJob,
                pdwPercentComplete: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSaveJob,
                pdwPercentComplete: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSaveJob_BeginSave(self: *const T, pStream: ?*IMFByteStream, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFSaveJob.VTable, @ptrCast(self.vtable)).BeginSave(@as(*const IMFSaveJob, @ptrCast(self)), pStream, pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSaveJob_EndSave(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFSaveJob.VTable, @ptrCast(self.vtable)).EndSave(@as(*const IMFSaveJob, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSaveJob_CancelSave(self: *const T) HRESULT {
                return @as(*const IMFSaveJob.VTable, @ptrCast(self.vtable)).CancelSave(@as(*const IMFSaveJob, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSaveJob_GetProgress(self: *const T, pdwPercentComplete: ?*u32) HRESULT {
                return @as(*const IMFSaveJob.VTable, @ptrCast(self.vtable)).GetProgress(@as(*const IMFSaveJob, @ptrCast(self)), pdwPercentComplete);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFNETSOURCE_PROTOCOL_TYPE = enum(i32) {
    UNDEFINED = 0,
    HTTP = 1,
    RTSP = 2,
    FILE = 3,
    MULTICAST = 4,
};
pub const MFNETSOURCE_UNDEFINED = MFNETSOURCE_PROTOCOL_TYPE.UNDEFINED;
pub const MFNETSOURCE_HTTP = MFNETSOURCE_PROTOCOL_TYPE.HTTP;
pub const MFNETSOURCE_RTSP = MFNETSOURCE_PROTOCOL_TYPE.RTSP;
pub const MFNETSOURCE_FILE = MFNETSOURCE_PROTOCOL_TYPE.FILE;
pub const MFNETSOURCE_MULTICAST = MFNETSOURCE_PROTOCOL_TYPE.MULTICAST;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFNetSchemeHandlerConfig_Value = Guid.initString("7be19e73-c9bf-468a-ac5a-a5e8653bec87");
pub const IID_IMFNetSchemeHandlerConfig = &IID_IMFNetSchemeHandlerConfig_Value;
pub const IMFNetSchemeHandlerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfSupportedProtocols: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetSchemeHandlerConfig,
                pcProtocols: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetSchemeHandlerConfig,
                pcProtocols: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProtocolType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetSchemeHandlerConfig,
                nProtocolIndex: u32,
                pnProtocolType: ?*MFNETSOURCE_PROTOCOL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetSchemeHandlerConfig,
                nProtocolIndex: u32,
                pnProtocolType: ?*MFNETSOURCE_PROTOCOL_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetProtocolRolloverSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetSchemeHandlerConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetSchemeHandlerConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetSchemeHandlerConfig_GetNumberOfSupportedProtocols(self: *const T, pcProtocols: ?*u32) HRESULT {
                return @as(*const IMFNetSchemeHandlerConfig.VTable, @ptrCast(self.vtable)).GetNumberOfSupportedProtocols(@as(*const IMFNetSchemeHandlerConfig, @ptrCast(self)), pcProtocols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetSchemeHandlerConfig_GetSupportedProtocolType(self: *const T, nProtocolIndex: u32, pnProtocolType: ?*MFNETSOURCE_PROTOCOL_TYPE) HRESULT {
                return @as(*const IMFNetSchemeHandlerConfig.VTable, @ptrCast(self.vtable)).GetSupportedProtocolType(@as(*const IMFNetSchemeHandlerConfig, @ptrCast(self)), nProtocolIndex, pnProtocolType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetSchemeHandlerConfig_ResetProtocolRolloverSettings(self: *const T) HRESULT {
                return @as(*const IMFNetSchemeHandlerConfig.VTable, @ptrCast(self.vtable)).ResetProtocolRolloverSettings(@as(*const IMFNetSchemeHandlerConfig, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFNETSOURCE_TRANSPORT_TYPE = enum(i32) {
    UDP = 0,
    TCP = 1,
};
pub const MFNETSOURCE_UDP = MFNETSOURCE_TRANSPORT_TYPE.UDP;
pub const MFNETSOURCE_TCP = MFNETSOURCE_TRANSPORT_TYPE.TCP;

pub const MFNETSOURCE_CACHE_STATE = enum(i32) {
    UNAVAILABLE = 0,
    ACTIVE_WRITING = 1,
    ACTIVE_COMPLETE = 2,
};
pub const MFNETSOURCE_CACHE_UNAVAILABLE = MFNETSOURCE_CACHE_STATE.UNAVAILABLE;
pub const MFNETSOURCE_CACHE_ACTIVE_WRITING = MFNETSOURCE_CACHE_STATE.ACTIVE_WRITING;
pub const MFNETSOURCE_CACHE_ACTIVE_COMPLETE = MFNETSOURCE_CACHE_STATE.ACTIVE_COMPLETE;

pub const MFNETSOURCE_STATISTICS_IDS = enum(i32) {
    RECVPACKETS_ID = 0,
    LOSTPACKETS_ID = 1,
    RESENDSREQUESTED_ID = 2,
    RESENDSRECEIVED_ID = 3,
    RECOVEREDBYECCPACKETS_ID = 4,
    RECOVEREDBYRTXPACKETS_ID = 5,
    OUTPACKETS_ID = 6,
    RECVRATE_ID = 7,
    AVGBANDWIDTHBPS_ID = 8,
    BYTESRECEIVED_ID = 9,
    PROTOCOL_ID = 10,
    TRANSPORT_ID = 11,
    CACHE_STATE_ID = 12,
    LINKBANDWIDTH_ID = 13,
    CONTENTBITRATE_ID = 14,
    SPEEDFACTOR_ID = 15,
    BUFFERSIZE_ID = 16,
    BUFFERPROGRESS_ID = 17,
    LASTBWSWITCHTS_ID = 18,
    SEEKRANGESTART_ID = 19,
    SEEKRANGEEND_ID = 20,
    BUFFERINGCOUNT_ID = 21,
    INCORRECTLYSIGNEDPACKETS_ID = 22,
    SIGNEDSESSION_ID = 23,
    MAXBITRATE_ID = 24,
    RECEPTION_QUALITY_ID = 25,
    RECOVEREDPACKETS_ID = 26,
    VBR_ID = 27,
    DOWNLOADPROGRESS_ID = 28,
    UNPREDEFINEDPROTOCOLNAME_ID = 29,
};
pub const MFNETSOURCE_RECVPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.RECVPACKETS_ID;
pub const MFNETSOURCE_LOSTPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.LOSTPACKETS_ID;
pub const MFNETSOURCE_RESENDSREQUESTED_ID = MFNETSOURCE_STATISTICS_IDS.RESENDSREQUESTED_ID;
pub const MFNETSOURCE_RESENDSRECEIVED_ID = MFNETSOURCE_STATISTICS_IDS.RESENDSRECEIVED_ID;
pub const MFNETSOURCE_RECOVEREDBYECCPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.RECOVEREDBYECCPACKETS_ID;
pub const MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.RECOVEREDBYRTXPACKETS_ID;
pub const MFNETSOURCE_OUTPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.OUTPACKETS_ID;
pub const MFNETSOURCE_RECVRATE_ID = MFNETSOURCE_STATISTICS_IDS.RECVRATE_ID;
pub const MFNETSOURCE_AVGBANDWIDTHBPS_ID = MFNETSOURCE_STATISTICS_IDS.AVGBANDWIDTHBPS_ID;
pub const MFNETSOURCE_BYTESRECEIVED_ID = MFNETSOURCE_STATISTICS_IDS.BYTESRECEIVED_ID;
pub const MFNETSOURCE_PROTOCOL_ID = MFNETSOURCE_STATISTICS_IDS.PROTOCOL_ID;
pub const MFNETSOURCE_TRANSPORT_ID = MFNETSOURCE_STATISTICS_IDS.TRANSPORT_ID;
pub const MFNETSOURCE_CACHE_STATE_ID = MFNETSOURCE_STATISTICS_IDS.CACHE_STATE_ID;
pub const MFNETSOURCE_LINKBANDWIDTH_ID = MFNETSOURCE_STATISTICS_IDS.LINKBANDWIDTH_ID;
pub const MFNETSOURCE_CONTENTBITRATE_ID = MFNETSOURCE_STATISTICS_IDS.CONTENTBITRATE_ID;
pub const MFNETSOURCE_SPEEDFACTOR_ID = MFNETSOURCE_STATISTICS_IDS.SPEEDFACTOR_ID;
pub const MFNETSOURCE_BUFFERSIZE_ID = MFNETSOURCE_STATISTICS_IDS.BUFFERSIZE_ID;
pub const MFNETSOURCE_BUFFERPROGRESS_ID = MFNETSOURCE_STATISTICS_IDS.BUFFERPROGRESS_ID;
pub const MFNETSOURCE_LASTBWSWITCHTS_ID = MFNETSOURCE_STATISTICS_IDS.LASTBWSWITCHTS_ID;
pub const MFNETSOURCE_SEEKRANGESTART_ID = MFNETSOURCE_STATISTICS_IDS.SEEKRANGESTART_ID;
pub const MFNETSOURCE_SEEKRANGEEND_ID = MFNETSOURCE_STATISTICS_IDS.SEEKRANGEEND_ID;
pub const MFNETSOURCE_BUFFERINGCOUNT_ID = MFNETSOURCE_STATISTICS_IDS.BUFFERINGCOUNT_ID;
pub const MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.INCORRECTLYSIGNEDPACKETS_ID;
pub const MFNETSOURCE_SIGNEDSESSION_ID = MFNETSOURCE_STATISTICS_IDS.SIGNEDSESSION_ID;
pub const MFNETSOURCE_MAXBITRATE_ID = MFNETSOURCE_STATISTICS_IDS.MAXBITRATE_ID;
pub const MFNETSOURCE_RECEPTION_QUALITY_ID = MFNETSOURCE_STATISTICS_IDS.RECEPTION_QUALITY_ID;
pub const MFNETSOURCE_RECOVEREDPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.RECOVEREDPACKETS_ID;
pub const MFNETSOURCE_VBR_ID = MFNETSOURCE_STATISTICS_IDS.VBR_ID;
pub const MFNETSOURCE_DOWNLOADPROGRESS_ID = MFNETSOURCE_STATISTICS_IDS.DOWNLOADPROGRESS_ID;
pub const MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID = MFNETSOURCE_STATISTICS_IDS.UNPREDEFINEDPROTOCOLNAME_ID;

pub const MFNET_PROXYSETTINGS = enum(i32) {
    NONE = 0,
    MANUAL = 1,
    AUTO = 2,
    BROWSER = 3,
};
pub const MFNET_PROXYSETTING_NONE = MFNET_PROXYSETTINGS.NONE;
pub const MFNET_PROXYSETTING_MANUAL = MFNET_PROXYSETTINGS.MANUAL;
pub const MFNET_PROXYSETTING_AUTO = MFNET_PROXYSETTINGS.AUTO;
pub const MFNET_PROXYSETTING_BROWSER = MFNET_PROXYSETTINGS.BROWSER;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSchemeHandler_Value = Guid.initString("6d4c7b74-52a0-4bb7-b0db-55f29f47a668");
pub const IID_IMFSchemeHandler = &IID_IMFSchemeHandler_Value;
pub const IMFSchemeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSchemeHandler,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSchemeHandler,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSchemeHandler,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSchemeHandler,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelObjectCreation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSchemeHandler,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSchemeHandler,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSchemeHandler_BeginCreateObject(self: *const T, pwszURL: ?[*:0]const u16, dwFlags: u32, pProps: ?*IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFSchemeHandler.VTable, @ptrCast(self.vtable)).BeginCreateObject(@as(*const IMFSchemeHandler, @ptrCast(self)), pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSchemeHandler_EndCreateObject(self: *const T, pResult: ?*IMFAsyncResult, pObjectType: ?*MF_OBJECT_TYPE, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFSchemeHandler.VTable, @ptrCast(self.vtable)).EndCreateObject(@as(*const IMFSchemeHandler, @ptrCast(self)), pResult, pObjectType, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSchemeHandler_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: ?*IUnknown) HRESULT {
                return @as(*const IMFSchemeHandler.VTable, @ptrCast(self.vtable)).CancelObjectCreation(@as(*const IMFSchemeHandler, @ptrCast(self)), pIUnknownCancelCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFByteStreamHandler_Value = Guid.initString("bb420aa4-765b-4a1f-91fe-d6a8a143924c");
pub const IID_IMFByteStreamHandler = &IID_IMFByteStreamHandler_Value;
pub const IMFByteStreamHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamHandler,
                pByteStream: ?*IMFByteStream,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamHandler,
                pByteStream: ?*IMFByteStream,
                pwszURL: ?[*:0]const u16,
                dwFlags: u32,
                pProps: ?*IPropertyStore,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamHandler,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamHandler,
                pResult: ?*IMFAsyncResult,
                pObjectType: ?*MF_OBJECT_TYPE,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelObjectCreation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamHandler,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamHandler,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxNumberOfBytesRequiredForResolution: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFByteStreamHandler,
                pqwBytes: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFByteStreamHandler,
                pqwBytes: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamHandler_BeginCreateObject(self: *const T, pByteStream: ?*IMFByteStream, pwszURL: ?[*:0]const u16, dwFlags: u32, pProps: ?*IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFByteStreamHandler.VTable, @ptrCast(self.vtable)).BeginCreateObject(@as(*const IMFByteStreamHandler, @ptrCast(self)), pByteStream, pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamHandler_EndCreateObject(self: *const T, pResult: ?*IMFAsyncResult, pObjectType: ?*MF_OBJECT_TYPE, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFByteStreamHandler.VTable, @ptrCast(self.vtable)).EndCreateObject(@as(*const IMFByteStreamHandler, @ptrCast(self)), pResult, pObjectType, ppObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamHandler_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: ?*IUnknown) HRESULT {
                return @as(*const IMFByteStreamHandler.VTable, @ptrCast(self.vtable)).CancelObjectCreation(@as(*const IMFByteStreamHandler, @ptrCast(self)), pIUnknownCancelCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFByteStreamHandler_GetMaxNumberOfBytesRequiredForResolution(self: *const T, pqwBytes: ?*u64) HRESULT {
                return @as(*const IMFByteStreamHandler.VTable, @ptrCast(self.vtable)).GetMaxNumberOfBytesRequiredForResolution(@as(*const IMFByteStreamHandler, @ptrCast(self)), pqwBytes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTrustedInput_Value = Guid.initString("542612c4-a1b8-4632-b521-de11ea64a0b0");
pub const IID_IMFTrustedInput = &IID_IMFTrustedInput_Value;
pub const IMFTrustedInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputTrustAuthority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTrustedInput,
                dwStreamID: u32,
                riid: ?*const Guid,
                ppunkObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTrustedInput,
                dwStreamID: u32,
                riid: ?*const Guid,
                ppunkObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTrustedInput_GetInputTrustAuthority(self: *const T, dwStreamID: u32, riid: ?*const Guid, ppunkObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFTrustedInput.VTable, @ptrCast(self.vtable)).GetInputTrustAuthority(@as(*const IMFTrustedInput, @ptrCast(self)), dwStreamID, riid, ppunkObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFPOLICYMANAGER_ACTION = enum(i32) {
    NO = 0,
    PLAY = 1,
    COPY = 2,
    EXPORT = 3,
    EXTRACT = 4,
    RESERVED1 = 5,
    RESERVED2 = 6,
    RESERVED3 = 7,
    // LAST = 7, this enum value conflicts with RESERVED3
};
pub const PEACTION_NO = MFPOLICYMANAGER_ACTION.NO;
pub const PEACTION_PLAY = MFPOLICYMANAGER_ACTION.PLAY;
pub const PEACTION_COPY = MFPOLICYMANAGER_ACTION.COPY;
pub const PEACTION_EXPORT = MFPOLICYMANAGER_ACTION.EXPORT;
pub const PEACTION_EXTRACT = MFPOLICYMANAGER_ACTION.EXTRACT;
pub const PEACTION_RESERVED1 = MFPOLICYMANAGER_ACTION.RESERVED1;
pub const PEACTION_RESERVED2 = MFPOLICYMANAGER_ACTION.RESERVED2;
pub const PEACTION_RESERVED3 = MFPOLICYMANAGER_ACTION.RESERVED3;
pub const PEACTION_LAST = MFPOLICYMANAGER_ACTION.RESERVED3;

pub const MFINPUTTRUSTAUTHORITY_ACCESS_ACTION = extern struct {
    Action: MFPOLICYMANAGER_ACTION,
    pbTicket: ?*u8,
    cbTicket: u32,
};

pub const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS = extern struct {
    dwSize: u32,
    dwVer: u32,
    cbSignatureOffset: u32,
    cbSignatureSize: u32,
    cbExtensionOffset: u32,
    cbExtensionSize: u32,
    cActions: u32,
    rgOutputActions: [1]MFINPUTTRUSTAUTHORITY_ACCESS_ACTION,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFInputTrustAuthority_Value = Guid.initString("d19f8e98-b126-4446-890c-5dcb7ad71453");
pub const IID_IMFInputTrustAuthority = &IID_IMFInputTrustAuthority_Value;
pub const IMFInputTrustAuthority = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecrypter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFInputTrustAuthority,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFInputTrustAuthority,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFInputTrustAuthority,
                Action: MFPOLICYMANAGER_ACTION,
                ppContentEnablerActivate: ?*?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFInputTrustAuthority,
                Action: MFPOLICYMANAGER_ACTION,
                ppContentEnablerActivate: ?*?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFInputTrustAuthority,
                Action: MFPOLICYMANAGER_ACTION,
                ppPolicy: ?*?*IMFOutputPolicy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFInputTrustAuthority,
                Action: MFPOLICYMANAGER_ACTION,
                ppPolicy: ?*?*IMFOutputPolicy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFInputTrustAuthority,
                pParam: ?*MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFInputTrustAuthority,
                pParam: ?*MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFInputTrustAuthority,
                pParam: ?*MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFInputTrustAuthority,
                pParam: ?*MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFInputTrustAuthority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFInputTrustAuthority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFInputTrustAuthority_GetDecrypter(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFInputTrustAuthority.VTable, @ptrCast(self.vtable)).GetDecrypter(@as(*const IMFInputTrustAuthority, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFInputTrustAuthority_RequestAccess(self: *const T, Action: MFPOLICYMANAGER_ACTION, ppContentEnablerActivate: ?*?*IMFActivate) HRESULT {
                return @as(*const IMFInputTrustAuthority.VTable, @ptrCast(self.vtable)).RequestAccess(@as(*const IMFInputTrustAuthority, @ptrCast(self)), Action, ppContentEnablerActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFInputTrustAuthority_GetPolicy(self: *const T, Action: MFPOLICYMANAGER_ACTION, ppPolicy: ?*?*IMFOutputPolicy) HRESULT {
                return @as(*const IMFInputTrustAuthority.VTable, @ptrCast(self.vtable)).GetPolicy(@as(*const IMFInputTrustAuthority, @ptrCast(self)), Action, ppPolicy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFInputTrustAuthority_BindAccess(self: *const T, pParam: ?*MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) HRESULT {
                return @as(*const IMFInputTrustAuthority.VTable, @ptrCast(self.vtable)).BindAccess(@as(*const IMFInputTrustAuthority, @ptrCast(self)), pParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFInputTrustAuthority_UpdateAccess(self: *const T, pParam: ?*MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) HRESULT {
                return @as(*const IMFInputTrustAuthority.VTable, @ptrCast(self.vtable)).UpdateAccess(@as(*const IMFInputTrustAuthority, @ptrCast(self)), pParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFInputTrustAuthority_Reset(self: *const T) HRESULT {
                return @as(*const IMFInputTrustAuthority.VTable, @ptrCast(self.vtable)).Reset(@as(*const IMFInputTrustAuthority, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTrustedOutput_Value = Guid.initString("d19f8e95-b126-4446-890c-5dcb7ad71453");
pub const IID_IMFTrustedOutput = &IID_IMFTrustedOutput_Value;
pub const IMFTrustedOutput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOutputTrustAuthorityCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTrustedOutput,
                pcOutputTrustAuthorities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTrustedOutput,
                pcOutputTrustAuthorities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputTrustAuthorityByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTrustedOutput,
                dwIndex: u32,
                ppauthority: ?*?*IMFOutputTrustAuthority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTrustedOutput,
                dwIndex: u32,
                ppauthority: ?*?*IMFOutputTrustAuthority,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsFinal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTrustedOutput,
                pfIsFinal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTrustedOutput,
                pfIsFinal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTrustedOutput_GetOutputTrustAuthorityCount(self: *const T, pcOutputTrustAuthorities: ?*u32) HRESULT {
                return @as(*const IMFTrustedOutput.VTable, @ptrCast(self.vtable)).GetOutputTrustAuthorityCount(@as(*const IMFTrustedOutput, @ptrCast(self)), pcOutputTrustAuthorities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTrustedOutput_GetOutputTrustAuthorityByIndex(self: *const T, dwIndex: u32, ppauthority: ?*?*IMFOutputTrustAuthority) HRESULT {
                return @as(*const IMFTrustedOutput.VTable, @ptrCast(self.vtable)).GetOutputTrustAuthorityByIndex(@as(*const IMFTrustedOutput, @ptrCast(self)), dwIndex, ppauthority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTrustedOutput_IsFinal(self: *const T, pfIsFinal: ?*BOOL) HRESULT {
                return @as(*const IMFTrustedOutput.VTable, @ptrCast(self.vtable)).IsFinal(@as(*const IMFTrustedOutput, @ptrCast(self)), pfIsFinal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFOutputTrustAuthority_Value = Guid.initString("d19f8e94-b126-4446-890c-5dcb7ad71453");
pub const IID_IMFOutputTrustAuthority = &IID_IMFOutputTrustAuthority_Value;
pub const IMFOutputTrustAuthority = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputTrustAuthority,
                pAction: ?*MFPOLICYMANAGER_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputTrustAuthority,
                pAction: ?*MFPOLICYMANAGER_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputTrustAuthority,
                ppPolicy: ?[*]?*IMFOutputPolicy,
                nPolicy: u32,
                ppbTicket: ?*?*u8,
                pcbTicket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputTrustAuthority,
                ppPolicy: ?[*]?*IMFOutputPolicy,
                nPolicy: u32,
                ppbTicket: ?*?*u8,
                pcbTicket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputTrustAuthority_GetAction(self: *const T, pAction: ?*MFPOLICYMANAGER_ACTION) HRESULT {
                return @as(*const IMFOutputTrustAuthority.VTable, @ptrCast(self.vtable)).GetAction(@as(*const IMFOutputTrustAuthority, @ptrCast(self)), pAction);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputTrustAuthority_SetPolicy(self: *const T, ppPolicy: ?[*]?*IMFOutputPolicy, nPolicy: u32, ppbTicket: ?*?*u8, pcbTicket: ?*u32) HRESULT {
                return @as(*const IMFOutputTrustAuthority.VTable, @ptrCast(self.vtable)).SetPolicy(@as(*const IMFOutputTrustAuthority, @ptrCast(self)), ppPolicy, nPolicy, ppbTicket, pcbTicket);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFOutputPolicy_Value = Guid.initString("7f00f10a-daed-41af-ab26-5fdfa4dfba3c");
pub const IID_IMFOutputPolicy = &IID_IMFOutputPolicy_Value;
pub const IMFOutputPolicy = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GenerateRequiredSchemas: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputPolicy,
                dwAttributes: u32,
                guidOutputSubType: Guid,
                rgGuidProtectionSchemasSupported: ?*Guid,
                cProtectionSchemasSupported: u32,
                ppRequiredProtectionSchemas: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputPolicy,
                dwAttributes: u32,
                guidOutputSubType: Guid,
                rgGuidProtectionSchemasSupported: ?*Guid,
                cProtectionSchemasSupported: u32,
                ppRequiredProtectionSchemas: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginatorID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputPolicy,
                pguidOriginatorID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputPolicy,
                pguidOriginatorID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinimumGRLVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputPolicy,
                pdwMinimumGRLVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputPolicy,
                pdwMinimumGRLVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputPolicy_GenerateRequiredSchemas(self: *const T, dwAttributes: u32, guidOutputSubType: Guid, rgGuidProtectionSchemasSupported: ?*Guid, cProtectionSchemasSupported: u32, ppRequiredProtectionSchemas: ?*?*IMFCollection) HRESULT {
                return @as(*const IMFOutputPolicy.VTable, @ptrCast(self.vtable)).GenerateRequiredSchemas(@as(*const IMFOutputPolicy, @ptrCast(self)), dwAttributes, guidOutputSubType, rgGuidProtectionSchemasSupported, cProtectionSchemasSupported, ppRequiredProtectionSchemas);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputPolicy_GetOriginatorID(self: *const T, pguidOriginatorID: ?*Guid) HRESULT {
                return @as(*const IMFOutputPolicy.VTable, @ptrCast(self.vtable)).GetOriginatorID(@as(*const IMFOutputPolicy, @ptrCast(self)), pguidOriginatorID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputPolicy_GetMinimumGRLVersion(self: *const T, pdwMinimumGRLVersion: ?*u32) HRESULT {
                return @as(*const IMFOutputPolicy.VTable, @ptrCast(self.vtable)).GetMinimumGRLVersion(@as(*const IMFOutputPolicy, @ptrCast(self)), pdwMinimumGRLVersion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFOutputSchema_Value = Guid.initString("7be0fc5b-abd9-44fb-a5c8-f50136e71599");
pub const IID_IMFOutputSchema = &IID_IMFOutputSchema_Value;
pub const IMFOutputSchema = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetSchemaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputSchema,
                pguidSchemaType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputSchema,
                pguidSchemaType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConfigurationData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputSchema,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputSchema,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginatorID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFOutputSchema,
                pguidOriginatorID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFOutputSchema,
                pguidOriginatorID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputSchema_GetSchemaType(self: *const T, pguidSchemaType: ?*Guid) HRESULT {
                return @as(*const IMFOutputSchema.VTable, @ptrCast(self.vtable)).GetSchemaType(@as(*const IMFOutputSchema, @ptrCast(self)), pguidSchemaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputSchema_GetConfigurationData(self: *const T, pdwVal: ?*u32) HRESULT {
                return @as(*const IMFOutputSchema.VTable, @ptrCast(self.vtable)).GetConfigurationData(@as(*const IMFOutputSchema, @ptrCast(self)), pdwVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFOutputSchema_GetOriginatorID(self: *const T, pguidOriginatorID: ?*Guid) HRESULT {
                return @as(*const IMFOutputSchema.VTable, @ptrCast(self.vtable)).GetOriginatorID(@as(*const IMFOutputSchema, @ptrCast(self)), pguidOriginatorID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_OPM_CGMSA_PROTECTION_LEVEL = enum(i32) {
    OFF = 0,
    COPY_FREELY = 1,
    COPY_NO_MORE = 2,
    COPY_ONE_GENERATION = 3,
    COPY_NEVER = 4,
    REDISTRIBUTION_CONTROL_REQUIRED = 8,
};
pub const MF_OPM_CGMSA_OFF = MF_OPM_CGMSA_PROTECTION_LEVEL.OFF;
pub const MF_OPM_CGMSA_COPY_FREELY = MF_OPM_CGMSA_PROTECTION_LEVEL.COPY_FREELY;
pub const MF_OPM_CGMSA_COPY_NO_MORE = MF_OPM_CGMSA_PROTECTION_LEVEL.COPY_NO_MORE;
pub const MF_OPM_CGMSA_COPY_ONE_GENERATION = MF_OPM_CGMSA_PROTECTION_LEVEL.COPY_ONE_GENERATION;
pub const MF_OPM_CGMSA_COPY_NEVER = MF_OPM_CGMSA_PROTECTION_LEVEL.COPY_NEVER;
pub const MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = MF_OPM_CGMSA_PROTECTION_LEVEL.REDISTRIBUTION_CONTROL_REQUIRED;

pub const MF_OPM_ACP_PROTECTION_LEVEL = enum(i32) {
    OFF = 0,
    LEVEL_ONE = 1,
    LEVEL_TWO = 2,
    LEVEL_THREE = 3,
    FORCE_ULONG = 2147483647,
};
pub const MF_OPM_ACP_OFF = MF_OPM_ACP_PROTECTION_LEVEL.OFF;
pub const MF_OPM_ACP_LEVEL_ONE = MF_OPM_ACP_PROTECTION_LEVEL.LEVEL_ONE;
pub const MF_OPM_ACP_LEVEL_TWO = MF_OPM_ACP_PROTECTION_LEVEL.LEVEL_TWO;
pub const MF_OPM_ACP_LEVEL_THREE = MF_OPM_ACP_PROTECTION_LEVEL.LEVEL_THREE;
pub const MF_OPM_ACP_FORCE_ULONG = MF_OPM_ACP_PROTECTION_LEVEL.FORCE_ULONG;

pub const MFAudioConstriction = enum(i32) {
    Off = 0,
    @"48_16" = 1,
    @"44_16" = 2,
    @"14_14" = 3,
    Mute = 4,
};
pub const MFaudioConstrictionOff = MFAudioConstriction.Off;
pub const MFaudioConstriction48_16 = MFAudioConstriction.@"48_16";
pub const MFaudioConstriction44_16 = MFAudioConstriction.@"44_16";
pub const MFaudioConstriction14_14 = MFAudioConstriction.@"14_14";
pub const MFaudioConstrictionMute = MFAudioConstriction.Mute;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSecureChannel_Value = Guid.initString("d0ae555d-3b12-4d97-b060-0990bc5aeb67");
pub const IID_IMFSecureChannel = &IID_IMFSecureChannel_Value;
pub const IMFSecureChannel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSecureChannel,
                ppCert: ?*?*u8,
                pcbCert: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSecureChannel,
                ppCert: ?*?*u8,
                pcbCert: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetupSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSecureChannel,
                // TODO: what to do with BytesParamIndex 1?
                pbEncryptedSessionKey: ?*u8,
                cbSessionKey: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSecureChannel,
                // TODO: what to do with BytesParamIndex 1?
                pbEncryptedSessionKey: ?*u8,
                cbSessionKey: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSecureChannel_GetCertificate(self: *const T, ppCert: ?*?*u8, pcbCert: ?*u32) HRESULT {
                return @as(*const IMFSecureChannel.VTable, @ptrCast(self.vtable)).GetCertificate(@as(*const IMFSecureChannel, @ptrCast(self)), ppCert, pcbCert);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSecureChannel_SetupSession(self: *const T, pbEncryptedSessionKey: ?*u8, cbSessionKey: u32) HRESULT {
                return @as(*const IMFSecureChannel.VTable, @ptrCast(self.vtable)).SetupSession(@as(*const IMFSecureChannel, @ptrCast(self)), pbEncryptedSessionKey, cbSessionKey);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SAMPLE_PROTECTION_VERSION = enum(i32) {
    NO = 0,
    BASIC_LOKI = 1,
    SCATTER = 2,
    RC4 = 3,
    AES128CTR = 4,
};
pub const SAMPLE_PROTECTION_VERSION_NO = SAMPLE_PROTECTION_VERSION.NO;
pub const SAMPLE_PROTECTION_VERSION_BASIC_LOKI = SAMPLE_PROTECTION_VERSION.BASIC_LOKI;
pub const SAMPLE_PROTECTION_VERSION_SCATTER = SAMPLE_PROTECTION_VERSION.SCATTER;
pub const SAMPLE_PROTECTION_VERSION_RC4 = SAMPLE_PROTECTION_VERSION.RC4;
pub const SAMPLE_PROTECTION_VERSION_AES128CTR = SAMPLE_PROTECTION_VERSION.AES128CTR;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSampleProtection_Value = Guid.initString("8e36395f-c7b9-43c4-a54d-512b4af63c95");
pub const IID_IMFSampleProtection = &IID_IMFSampleProtection_Value;
pub const IMFSampleProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputProtectionVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleProtection,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleProtection,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputProtectionVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleProtection,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleProtection,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtectionCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleProtection,
                dwVersion: u32,
                ppCert: ?*?*u8,
                pcbCert: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleProtection,
                dwVersion: u32,
                ppCert: ?*?*u8,
                pcbCert: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitOutputProtection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleProtection,
                dwVersion: u32,
                dwOutputId: u32,
                pbCert: ?*u8,
                cbCert: u32,
                ppbSeed: ?*?*u8,
                pcbSeed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleProtection,
                dwVersion: u32,
                dwOutputId: u32,
                pbCert: ?*u8,
                cbCert: u32,
                ppbSeed: ?*?*u8,
                pcbSeed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitInputProtection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleProtection,
                dwVersion: u32,
                dwInputId: u32,
                pbSeed: ?*u8,
                cbSeed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleProtection,
                dwVersion: u32,
                dwInputId: u32,
                pbSeed: ?*u8,
                cbSeed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleProtection_GetInputProtectionVersion(self: *const T, pdwVersion: ?*u32) HRESULT {
                return @as(*const IMFSampleProtection.VTable, @ptrCast(self.vtable)).GetInputProtectionVersion(@as(*const IMFSampleProtection, @ptrCast(self)), pdwVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleProtection_GetOutputProtectionVersion(self: *const T, pdwVersion: ?*u32) HRESULT {
                return @as(*const IMFSampleProtection.VTable, @ptrCast(self.vtable)).GetOutputProtectionVersion(@as(*const IMFSampleProtection, @ptrCast(self)), pdwVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleProtection_GetProtectionCertificate(self: *const T, dwVersion: u32, ppCert: ?*?*u8, pcbCert: ?*u32) HRESULT {
                return @as(*const IMFSampleProtection.VTable, @ptrCast(self.vtable)).GetProtectionCertificate(@as(*const IMFSampleProtection, @ptrCast(self)), dwVersion, ppCert, pcbCert);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleProtection_InitOutputProtection(self: *const T, dwVersion: u32, dwOutputId: u32, pbCert: ?*u8, cbCert: u32, ppbSeed: ?*?*u8, pcbSeed: ?*u32) HRESULT {
                return @as(*const IMFSampleProtection.VTable, @ptrCast(self.vtable)).InitOutputProtection(@as(*const IMFSampleProtection, @ptrCast(self)), dwVersion, dwOutputId, pbCert, cbCert, ppbSeed, pcbSeed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleProtection_InitInputProtection(self: *const T, dwVersion: u32, dwInputId: u32, pbSeed: ?*u8, cbSeed: u32) HRESULT {
                return @as(*const IMFSampleProtection.VTable, @ptrCast(self.vtable)).InitInputProtection(@as(*const IMFSampleProtection, @ptrCast(self)), dwVersion, dwInputId, pbSeed, cbSeed);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFMediaSinkPreroll_Value = Guid.initString("5dfd4b2a-7674-4110-a4e6-8a68fd5f3688");
pub const IID_IMFMediaSinkPreroll = &IID_IMFMediaSinkPreroll_Value;
pub const IMFMediaSinkPreroll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyPreroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSinkPreroll,
                hnsUpcomingStartTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSinkPreroll,
                hnsUpcomingStartTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSinkPreroll_NotifyPreroll(self: *const T, hnsUpcomingStartTime: i64) HRESULT {
                return @as(*const IMFMediaSinkPreroll.VTable, @ptrCast(self.vtable)).NotifyPreroll(@as(*const IMFMediaSinkPreroll, @ptrCast(self)), hnsUpcomingStartTime);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFFinalizableMediaSink_Value = Guid.initString("eaecb74a-9a50-42ce-9541-6a7f57aa4ad7");
pub const IID_IMFFinalizableMediaSink = &IID_IMFFinalizableMediaSink_Value;
pub const IMFFinalizableMediaSink = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaSink.VTable,
        BeginFinalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFFinalizableMediaSink,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFFinalizableMediaSink,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndFinalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFFinalizableMediaSink,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFFinalizableMediaSink,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFFinalizableMediaSink_BeginFinalize(self: *const T, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFFinalizableMediaSink.VTable, @ptrCast(self.vtable)).BeginFinalize(@as(*const IMFFinalizableMediaSink, @ptrCast(self)), pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFFinalizableMediaSink_EndFinalize(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFFinalizableMediaSink.VTable, @ptrCast(self.vtable)).EndFinalize(@as(*const IMFFinalizableMediaSink, @ptrCast(self)), pResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFStreamingSinkConfig_Value = Guid.initString("9db7aa41-3cc5-40d4-8509-555804ad34cc");
pub const IID_IMFStreamingSinkConfig = &IID_IMFStreamingSinkConfig_Value;
pub const IMFStreamingSinkConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartStreaming: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFStreamingSinkConfig,
                fSeekOffsetIsByteOffset: BOOL,
                qwSeekOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFStreamingSinkConfig,
                fSeekOffsetIsByteOffset: BOOL,
                qwSeekOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFStreamingSinkConfig_StartStreaming(self: *const T, fSeekOffsetIsByteOffset: BOOL, qwSeekOffset: u64) HRESULT {
                return @as(*const IMFStreamingSinkConfig.VTable, @ptrCast(self.vtable)).StartStreaming(@as(*const IMFStreamingSinkConfig, @ptrCast(self)), fSeekOffsetIsByteOffset, qwSeekOffset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFRemoteProxy_Value = Guid.initString("994e23ad-1cc2-493c-b9fa-46f1cb040fa4");
pub const IID_IMFRemoteProxy = &IID_IMFRemoteProxy_Value;
pub const IMFRemoteProxy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRemoteObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRemoteProxy,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRemoteProxy,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemoteHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRemoteProxy,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRemoteProxy,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRemoteProxy_GetRemoteObject(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFRemoteProxy.VTable, @ptrCast(self.vtable)).GetRemoteObject(@as(*const IMFRemoteProxy, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRemoteProxy_GetRemoteHost(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFRemoteProxy.VTable, @ptrCast(self.vtable)).GetRemoteHost(@as(*const IMFRemoteProxy, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFObjectReferenceStream_Value = Guid.initString("09ef5be3-c8a7-469e-8b70-73bf25bb193f");
pub const IID_IMFObjectReferenceStream = &IID_IMFObjectReferenceStream_Value;
pub const IMFObjectReferenceStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SaveReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFObjectReferenceStream,
                riid: ?*const Guid,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFObjectReferenceStream,
                riid: ?*const Guid,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFObjectReferenceStream,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFObjectReferenceStream,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFObjectReferenceStream_SaveReference(self: *const T, riid: ?*const Guid, pUnk: ?*IUnknown) HRESULT {
                return @as(*const IMFObjectReferenceStream.VTable, @ptrCast(self.vtable)).SaveReference(@as(*const IMFObjectReferenceStream, @ptrCast(self)), riid, pUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFObjectReferenceStream_LoadReference(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFObjectReferenceStream.VTable, @ptrCast(self.vtable)).LoadReference(@as(*const IMFObjectReferenceStream, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFPMPHost_Value = Guid.initString("f70ca1a9-fdc7-4782-b994-adffb1c98606");
pub const IID_IMFPMPHost = &IID_IMFPMPHost_Value;
pub const IMFPMPHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateObjectByCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPHost,
                clsid: ?*const Guid,
                pStream: ?*IStream,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPHost,
                clsid: ?*const Guid,
                pStream: ?*IStream,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPHost_LockProcess(self: *const T) HRESULT {
                return @as(*const IMFPMPHost.VTable, @ptrCast(self.vtable)).LockProcess(@as(*const IMFPMPHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPHost_UnlockProcess(self: *const T) HRESULT {
                return @as(*const IMFPMPHost.VTable, @ptrCast(self.vtable)).UnlockProcess(@as(*const IMFPMPHost, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPHost_CreateObjectByCLSID(self: *const T, clsid: ?*const Guid, pStream: ?*IStream, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFPMPHost.VTable, @ptrCast(self.vtable)).CreateObjectByCLSID(@as(*const IMFPMPHost, @ptrCast(self)), clsid, pStream, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFPMPClient_Value = Guid.initString("6c4e655d-ead8-4421-b6b9-54dcdbbdf820");
pub const IID_IMFPMPClient = &IID_IMFPMPClient_Value;
pub const IMFPMPClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPMPHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPClient,
                pPMPHost: ?*IMFPMPHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPClient,
                pPMPHost: ?*IMFPMPHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPClient_SetPMPHost(self: *const T, pPMPHost: ?*IMFPMPHost) HRESULT {
                return @as(*const IMFPMPClient.VTable, @ptrCast(self.vtable)).SetPMPHost(@as(*const IMFPMPClient, @ptrCast(self)), pPMPHost);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFPMPServer_Value = Guid.initString("994e23af-1cc2-493c-b9fa-46f1cb040fa4");
pub const IID_IMFPMPServer = &IID_IMFPMPServer_Value;
pub const IMFPMPServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPServer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPServer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPServer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPServer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateObjectByCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPServer,
                clsid: ?*const Guid,
                riid: ?*const Guid,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPServer,
                clsid: ?*const Guid,
                riid: ?*const Guid,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPServer_LockProcess(self: *const T) HRESULT {
                return @as(*const IMFPMPServer.VTable, @ptrCast(self.vtable)).LockProcess(@as(*const IMFPMPServer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPServer_UnlockProcess(self: *const T) HRESULT {
                return @as(*const IMFPMPServer.VTable, @ptrCast(self.vtable)).UnlockProcess(@as(*const IMFPMPServer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPServer_CreateObjectByCLSID(self: *const T, clsid: ?*const Guid, riid: ?*const Guid, ppObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFPMPServer.VTable, @ptrCast(self.vtable)).CreateObjectByCLSID(@as(*const IMFPMPServer, @ptrCast(self)), clsid, riid, ppObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFRemoteDesktopPlugin_Value = Guid.initString("1cde6309-cae0-4940-907e-c1ec9c3d1d4a");
pub const IID_IMFRemoteDesktopPlugin = &IID_IMFRemoteDesktopPlugin_Value;
pub const IMFRemoteDesktopPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRemoteDesktopPlugin,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRemoteDesktopPlugin,
                pTopology: ?*IMFTopology,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRemoteDesktopPlugin_UpdateTopology(self: *const T, pTopology: ?*IMFTopology) HRESULT {
                return @as(*const IMFRemoteDesktopPlugin.VTable, @ptrCast(self.vtable)).UpdateTopology(@as(*const IMFRemoteDesktopPlugin, @ptrCast(self)), pTopology);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFSAMIStyle_Value = Guid.initString("a7e025dd-5303-4a62-89d6-e747e1efac73");
pub const IID_IMFSAMIStyle = &IID_IMFSAMIStyle_Value;
pub const IMFSAMIStyle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStyleCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSAMIStyle,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSAMIStyle,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStyles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSAMIStyle,
                pPropVarStyleArray: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSAMIStyle,
                pPropVarStyleArray: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSelectedStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSAMIStyle,
                pwszStyle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSAMIStyle,
                pwszStyle: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSAMIStyle,
                ppwszStyle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSAMIStyle,
                ppwszStyle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSAMIStyle_GetStyleCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFSAMIStyle.VTable, @ptrCast(self.vtable)).GetStyleCount(@as(*const IMFSAMIStyle, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSAMIStyle_GetStyles(self: *const T, pPropVarStyleArray: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFSAMIStyle.VTable, @ptrCast(self.vtable)).GetStyles(@as(*const IMFSAMIStyle, @ptrCast(self)), pPropVarStyleArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSAMIStyle_SetSelectedStyle(self: *const T, pwszStyle: ?[*:0]const u16) HRESULT {
                return @as(*const IMFSAMIStyle.VTable, @ptrCast(self.vtable)).SetSelectedStyle(@as(*const IMFSAMIStyle, @ptrCast(self)), pwszStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSAMIStyle_GetSelectedStyle(self: *const T, ppwszStyle: ?*?PWSTR) HRESULT {
                return @as(*const IMFSAMIStyle.VTable, @ptrCast(self.vtable)).GetSelectedStyle(@as(*const IMFSAMIStyle, @ptrCast(self)), ppwszStyle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFTranscodeProfile_Value = Guid.initString("4adfdba3-7ab0-4953-a62b-461e7ff3da1e");
pub const IID_IMFTranscodeProfile = &IID_IMFTranscodeProfile_Value;
pub const IMFTranscodeProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAudioAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeProfile,
                pAttrs: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeProfile,
                pAttrs: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeProfile,
                ppAttrs: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeProfile,
                ppAttrs: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeProfile,
                pAttrs: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeProfile,
                pAttrs: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeProfile,
                ppAttrs: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeProfile,
                ppAttrs: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContainerAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeProfile,
                pAttrs: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeProfile,
                pAttrs: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainerAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeProfile,
                ppAttrs: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeProfile,
                ppAttrs: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeProfile_SetAudioAttributes(self: *const T, pAttrs: ?*IMFAttributes) HRESULT {
                return @as(*const IMFTranscodeProfile.VTable, @ptrCast(self.vtable)).SetAudioAttributes(@as(*const IMFTranscodeProfile, @ptrCast(self)), pAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeProfile_GetAudioAttributes(self: *const T, ppAttrs: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFTranscodeProfile.VTable, @ptrCast(self.vtable)).GetAudioAttributes(@as(*const IMFTranscodeProfile, @ptrCast(self)), ppAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeProfile_SetVideoAttributes(self: *const T, pAttrs: ?*IMFAttributes) HRESULT {
                return @as(*const IMFTranscodeProfile.VTable, @ptrCast(self.vtable)).SetVideoAttributes(@as(*const IMFTranscodeProfile, @ptrCast(self)), pAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeProfile_GetVideoAttributes(self: *const T, ppAttrs: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFTranscodeProfile.VTable, @ptrCast(self.vtable)).GetVideoAttributes(@as(*const IMFTranscodeProfile, @ptrCast(self)), ppAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeProfile_SetContainerAttributes(self: *const T, pAttrs: ?*IMFAttributes) HRESULT {
                return @as(*const IMFTranscodeProfile.VTable, @ptrCast(self.vtable)).SetContainerAttributes(@as(*const IMFTranscodeProfile, @ptrCast(self)), pAttrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeProfile_GetContainerAttributes(self: *const T, ppAttrs: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFTranscodeProfile.VTable, @ptrCast(self.vtable)).GetContainerAttributes(@as(*const IMFTranscodeProfile, @ptrCast(self)), ppAttrs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TRANSCODE_TOPOLOGYMODE_FLAGS = enum(i32) {
    SOFTWARE_ONLY = 0,
    HARDWARE_ALLOWED = 1,
};
pub const MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY = MF_TRANSCODE_TOPOLOGYMODE_FLAGS.SOFTWARE_ONLY;
pub const MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED = MF_TRANSCODE_TOPOLOGYMODE_FLAGS.HARDWARE_ALLOWED;

pub const MF_TRANSCODE_ADJUST_PROFILE_FLAGS = enum(i32) {
    DEFAULT = 0,
    USE_SOURCE_ATTRIBUTES = 1,
};
pub const MF_TRANSCODE_ADJUST_PROFILE_DEFAULT = MF_TRANSCODE_ADJUST_PROFILE_FLAGS.DEFAULT;
pub const MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES = MF_TRANSCODE_ADJUST_PROFILE_FLAGS.USE_SOURCE_ATTRIBUTES;

pub const MF_VIDEO_PROCESSOR_ALGORITHM_TYPE = enum(i32) {
    DEFAULT = 0,
    MRF_CRF_444 = 1,
};
pub const MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT = MF_VIDEO_PROCESSOR_ALGORITHM_TYPE.DEFAULT;
pub const MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444 = MF_VIDEO_PROCESSOR_ALGORITHM_TYPE.MRF_CRF_444;

pub const MF_TRANSCODE_SINK_INFO = extern struct {
    dwVideoStreamID: u32,
    pVideoMediaType: ?*IMFMediaType,
    dwAudioStreamID: u32,
    pAudioMediaType: ?*IMFMediaType,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFTranscodeSinkInfoProvider_Value = Guid.initString("8cffcd2e-5a03-4a3a-aff7-edcd107c620e");
pub const IID_IMFTranscodeSinkInfoProvider = &IID_IMFTranscodeSinkInfoProvider_Value;
pub const IMFTranscodeSinkInfoProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOutputFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pwszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pwszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pByteStreamActivate: ?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pByteStreamActivate: ?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pProfile: ?*IMFTranscodeProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pProfile: ?*IMFTranscodeProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSinkInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pSinkInfo: ?*MF_TRANSCODE_SINK_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTranscodeSinkInfoProvider,
                pSinkInfo: ?*MF_TRANSCODE_SINK_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeSinkInfoProvider_SetOutputFile(self: *const T, pwszFileName: ?[*:0]const u16) HRESULT {
                return @as(*const IMFTranscodeSinkInfoProvider.VTable, @ptrCast(self.vtable)).SetOutputFile(@as(*const IMFTranscodeSinkInfoProvider, @ptrCast(self)), pwszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeSinkInfoProvider_SetOutputByteStream(self: *const T, pByteStreamActivate: ?*IMFActivate) HRESULT {
                return @as(*const IMFTranscodeSinkInfoProvider.VTable, @ptrCast(self.vtable)).SetOutputByteStream(@as(*const IMFTranscodeSinkInfoProvider, @ptrCast(self)), pByteStreamActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeSinkInfoProvider_SetProfile(self: *const T, pProfile: ?*IMFTranscodeProfile) HRESULT {
                return @as(*const IMFTranscodeSinkInfoProvider.VTable, @ptrCast(self.vtable)).SetProfile(@as(*const IMFTranscodeSinkInfoProvider, @ptrCast(self)), pProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTranscodeSinkInfoProvider_GetSinkInfo(self: *const T, pSinkInfo: ?*MF_TRANSCODE_SINK_INFO) HRESULT {
                return @as(*const IMFTranscodeSinkInfoProvider.VTable, @ptrCast(self.vtable)).GetSinkInfo(@as(*const IMFTranscodeSinkInfoProvider, @ptrCast(self)), pSinkInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFFieldOfUseMFTUnlock_Value = Guid.initString("508e71d3-ec66-4fc3-8775-b4b9ed6ba847");
pub const IID_IMFFieldOfUseMFTUnlock = &IID_IMFFieldOfUseMFTUnlock_Value;
pub const IMFFieldOfUseMFTUnlock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Unlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFFieldOfUseMFTUnlock,
                pUnkMFT: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFFieldOfUseMFTUnlock,
                pUnkMFT: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFFieldOfUseMFTUnlock_Unlock(self: *const T, pUnkMFT: ?*IUnknown) HRESULT {
                return @as(*const IMFFieldOfUseMFTUnlock.VTable, @ptrCast(self.vtable)).Unlock(@as(*const IMFFieldOfUseMFTUnlock, @ptrCast(self)), pUnkMFT);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFT_REGISTRATION_INFO = extern struct {
    clsid: Guid,
    guidCategory: Guid,
    uiFlags: u32,
    pszName: ?[*:0]const u16,
    cInTypes: u32,
    pInTypes: ?*MFT_REGISTER_TYPE_INFO,
    cOutTypes: u32,
    pOutTypes: ?*MFT_REGISTER_TYPE_INFO,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFLocalMFTRegistration_Value = Guid.initString("149c4d73-b4be-4f8d-8b87-079e926b6add");
pub const IID_IMFLocalMFTRegistration = &IID_IMFLocalMFTRegistration_Value;
pub const IMFLocalMFTRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterMFTs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFLocalMFTRegistration,
                pMFTs: [*]MFT_REGISTRATION_INFO,
                cMFTs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFLocalMFTRegistration,
                pMFTs: [*]MFT_REGISTRATION_INFO,
                cMFTs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFLocalMFTRegistration_RegisterMFTs(self: *const T, pMFTs: [*]MFT_REGISTRATION_INFO, cMFTs: u32) HRESULT {
                return @as(*const IMFLocalMFTRegistration.VTable, @ptrCast(self.vtable)).RegisterMFTs(@as(*const IMFLocalMFTRegistration, @ptrCast(self)), pMFTs, cMFTs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCapturePhotoConfirmation_Value = Guid.initString("19f68549-ca8a-4706-a4ef-481dbc95e12c");
pub const IID_IMFCapturePhotoConfirmation = &IID_IMFCapturePhotoConfirmation_Value;
pub const IMFCapturePhotoConfirmation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPhotoConfirmationCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePhotoConfirmation,
                pNotificationCallback: ?*IMFAsyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePhotoConfirmation,
                pNotificationCallback: ?*IMFAsyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPixelFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePhotoConfirmation,
                subtype: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePhotoConfirmation,
                subtype: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPixelFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePhotoConfirmation,
                subtype: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePhotoConfirmation,
                subtype: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePhotoConfirmation_SetPhotoConfirmationCallback(self: *const T, pNotificationCallback: ?*IMFAsyncCallback) HRESULT {
                return @as(*const IMFCapturePhotoConfirmation.VTable, @ptrCast(self.vtable)).SetPhotoConfirmationCallback(@as(*const IMFCapturePhotoConfirmation, @ptrCast(self)), pNotificationCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePhotoConfirmation_SetPixelFormat(self: *const T, subtype: Guid) HRESULT {
                return @as(*const IMFCapturePhotoConfirmation.VTable, @ptrCast(self.vtable)).SetPixelFormat(@as(*const IMFCapturePhotoConfirmation, @ptrCast(self)), subtype);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePhotoConfirmation_GetPixelFormat(self: *const T, subtype: ?*Guid) HRESULT {
                return @as(*const IMFCapturePhotoConfirmation.VTable, @ptrCast(self.vtable)).GetPixelFormat(@as(*const IMFCapturePhotoConfirmation, @ptrCast(self)), subtype);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFPMPHostApp_Value = Guid.initString("84d2054a-3aa1-4728-a3b0-440a418cf49c");
pub const IID_IMFPMPHostApp = &IID_IMFPMPHostApp_Value;
pub const IMFPMPHostApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateClassById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPHostApp,
                id: ?[*:0]const u16,
                pStream: ?*IStream,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPHostApp,
                id: ?[*:0]const u16,
                pStream: ?*IStream,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPHostApp_LockProcess(self: *const T) HRESULT {
                return @as(*const IMFPMPHostApp.VTable, @ptrCast(self.vtable)).LockProcess(@as(*const IMFPMPHostApp, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPHostApp_UnlockProcess(self: *const T) HRESULT {
                return @as(*const IMFPMPHostApp.VTable, @ptrCast(self.vtable)).UnlockProcess(@as(*const IMFPMPHostApp, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPHostApp_ActivateClassById(self: *const T, id: ?[*:0]const u16, pStream: ?*IStream, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMFPMPHostApp.VTable, @ptrCast(self.vtable)).ActivateClassById(@as(*const IMFPMPHostApp, @ptrCast(self)), id, pStream, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFPMPClientApp_Value = Guid.initString("c004f646-be2c-48f3-93a2-a0983eba1108");
pub const IID_IMFPMPClientApp = &IID_IMFPMPClientApp_Value;
pub const IMFPMPClientApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPMPHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMPClientApp,
                pPMPHost: ?*IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMPClientApp,
                pPMPHost: ?*IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMPClientApp_SetPMPHost(self: *const T, pPMPHost: ?*IMFPMPHostApp) HRESULT {
                return @as(*const IMFPMPClientApp.VTable, @ptrCast(self.vtable)).SetPMPHost(@as(*const IMFPMPClientApp, @ptrCast(self)), pPMPHost);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaStreamSourceSampleRequest_Value = Guid.initString("380b9af9-a85b-4e78-a2af-ea5ce645c6b4");
pub const IID_IMFMediaStreamSourceSampleRequest = &IID_IMFMediaStreamSourceSampleRequest_Value;
pub const IMFMediaStreamSourceSampleRequest = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaStreamSourceSampleRequest,
                value: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaStreamSourceSampleRequest,
                value: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaStreamSourceSampleRequest_SetSample(self: *const T, value: ?*IMFSample) HRESULT {
                return @as(*const IMFMediaStreamSourceSampleRequest.VTable, @ptrCast(self.vtable)).SetSample(@as(*const IMFMediaStreamSourceSampleRequest, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTrackedSample_Value = Guid.initString("245bf8e9-0755-40f7-88a5-ae0f18d55e17");
pub const IID_IMFTrackedSample = &IID_IMFTrackedSample_Value;
pub const IMFTrackedSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTrackedSample,
                pSampleAllocator: ?*IMFAsyncCallback,
                pUnkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTrackedSample,
                pSampleAllocator: ?*IMFAsyncCallback,
                pUnkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTrackedSample_SetAllocator(self: *const T, pSampleAllocator: ?*IMFAsyncCallback, pUnkState: ?*IUnknown) HRESULT {
                return @as(*const IMFTrackedSample.VTable, @ptrCast(self.vtable)).SetAllocator(@as(*const IMFTrackedSample, @ptrCast(self)), pSampleAllocator, pUnkState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFProtectedEnvironmentAccess_Value = Guid.initString("ef5dc845-f0d9-4ec9-b00c-cb5183d38434");
pub const IID_IMFProtectedEnvironmentAccess = &IID_IMFProtectedEnvironmentAccess_Value;
pub const IMFProtectedEnvironmentAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Call: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFProtectedEnvironmentAccess,
                inputLength: u32,
                // TODO: what to do with BytesParamIndex 0?
                input: ?*const u8,
                outputLength: u32,
                // TODO: what to do with BytesParamIndex 2?
                output: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFProtectedEnvironmentAccess,
                inputLength: u32,
                // TODO: what to do with BytesParamIndex 0?
                input: ?*const u8,
                outputLength: u32,
                // TODO: what to do with BytesParamIndex 2?
                output: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadGRL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFProtectedEnvironmentAccess,
                outputLength: ?*u32,
                output: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFProtectedEnvironmentAccess,
                outputLength: ?*u32,
                output: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFProtectedEnvironmentAccess_Call(self: *const T, inputLength: u32, input: ?*const u8, outputLength: u32, output: ?*u8) HRESULT {
                return @as(*const IMFProtectedEnvironmentAccess.VTable, @ptrCast(self.vtable)).Call(@as(*const IMFProtectedEnvironmentAccess, @ptrCast(self)), inputLength, input, outputLength, output);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFProtectedEnvironmentAccess_ReadGRL(self: *const T, outputLength: ?*u32, output: ?*?*u8) HRESULT {
                return @as(*const IMFProtectedEnvironmentAccess.VTable, @ptrCast(self.vtable)).ReadGRL(@as(*const IMFProtectedEnvironmentAccess, @ptrCast(self)), outputLength, output);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSignedLibrary_Value = Guid.initString("4a724bca-ff6a-4c07-8e0d-7a358421cf06");
pub const IID_IMFSignedLibrary = &IID_IMFSignedLibrary_Value;
pub const IMFSignedLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcedureAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSignedLibrary,
                name: ?[*:0]const u8,
                address: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSignedLibrary,
                name: ?[*:0]const u8,
                address: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSignedLibrary_GetProcedureAddress(self: *const T, name: ?[*:0]const u8, address: ?*?*anyopaque) HRESULT {
                return @as(*const IMFSignedLibrary.VTable, @ptrCast(self.vtable)).GetProcedureAddress(@as(*const IMFSignedLibrary, @ptrCast(self)), name, address);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSystemId_Value = Guid.initString("fff4af3a-1fc1-4ef9-a29b-d26c49e2f31a");
pub const IID_IMFSystemId = &IID_IMFSystemId_Value;
pub const IMFSystemId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSystemId,
                size: ?*u32,
                data: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSystemId,
                size: ?*u32,
                data: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Setup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSystemId,
                stage: u32,
                cbIn: u32,
                // TODO: what to do with BytesParamIndex 1?
                pbIn: ?*const u8,
                pcbOut: ?*u32,
                ppbOut: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSystemId,
                stage: u32,
                cbIn: u32,
                // TODO: what to do with BytesParamIndex 1?
                pbIn: ?*const u8,
                pcbOut: ?*u32,
                ppbOut: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSystemId_GetData(self: *const T, size: ?*u32, data: ?*?*u8) HRESULT {
                return @as(*const IMFSystemId.VTable, @ptrCast(self.vtable)).GetData(@as(*const IMFSystemId, @ptrCast(self)), size, data);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSystemId_Setup(self: *const T, stage: u32, cbIn: u32, pbIn: ?*const u8, pcbOut: ?*u32, ppbOut: ?*?*u8) HRESULT {
                return @as(*const IMFSystemId.VTable, @ptrCast(self.vtable)).Setup(@as(*const IMFSystemId, @ptrCast(self)), stage, cbIn, pbIn, pcbOut, ppbOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFCONTENTPROTECTIONDEVICE_INPUT_DATA = extern struct {
    HWProtectionFunctionID: u32,
    PrivateDataByteCount: u32,
    HWProtectionDataByteCount: u32,
    Reserved: u32,
    InputData: [4]u8,
};

pub const MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA = extern struct {
    PrivateDataByteCount: u32,
    MaxHWProtectionDataByteCount: u32,
    HWProtectionDataByteCount: u32,
    Status: HRESULT,
    TransportTimeInHundredsOfNanoseconds: i64,
    ExecutionTimeInHundredsOfNanoseconds: i64,
    OutputData: [4]u8,
};

pub const MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA = extern struct {
    TaskIndex: u32,
    ClassName: [260]u16,
    BasePriority: i32,
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFContentProtectionDevice_Value = Guid.initString("e6257174-a060-4c9a-a088-3b1b471cad28");
pub const IID_IMFContentProtectionDevice = &IID_IMFContentProtectionDevice_Value;
pub const IMFContentProtectionDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentProtectionDevice,
                FunctionId: u32,
                InputBufferByteCount: u32,
                // TODO: what to do with BytesParamIndex 1?
                InputBuffer: ?*const u8,
                OutputBufferByteCount: ?*u32,
                // TODO: what to do with BytesParamIndex 3?
                OutputBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentProtectionDevice,
                FunctionId: u32,
                InputBufferByteCount: u32,
                // TODO: what to do with BytesParamIndex 1?
                InputBuffer: ?*const u8,
                OutputBufferByteCount: ?*u32,
                // TODO: what to do with BytesParamIndex 3?
                OutputBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateDataByteCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentProtectionDevice,
                PrivateInputByteCount: ?*u32,
                PrivateOutputByteCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentProtectionDevice,
                PrivateInputByteCount: ?*u32,
                PrivateOutputByteCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentProtectionDevice_InvokeFunction(self: *const T, FunctionId: u32, InputBufferByteCount: u32, InputBuffer: ?*const u8, OutputBufferByteCount: ?*u32, OutputBuffer: ?*u8) HRESULT {
                return @as(*const IMFContentProtectionDevice.VTable, @ptrCast(self.vtable)).InvokeFunction(@as(*const IMFContentProtectionDevice, @ptrCast(self)), FunctionId, InputBufferByteCount, InputBuffer, OutputBufferByteCount, OutputBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentProtectionDevice_GetPrivateDataByteCount(self: *const T, PrivateInputByteCount: ?*u32, PrivateOutputByteCount: ?*u32) HRESULT {
                return @as(*const IMFContentProtectionDevice.VTable, @ptrCast(self.vtable)).GetPrivateDataByteCount(@as(*const IMFContentProtectionDevice, @ptrCast(self)), PrivateInputByteCount, PrivateOutputByteCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFContentDecryptorContext_Value = Guid.initString("7ec4b1bd-43fb-4763-85d2-64fcb5c5f4cb");
pub const IID_IMFContentDecryptorContext = &IID_IMFContentDecryptorContext_Value;
pub const IMFContentDecryptorContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeHardwareKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptorContext,
                InputPrivateDataByteCount: u32,
                InputPrivateData: ?[*]const u8,
                OutputPrivateData: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptorContext,
                InputPrivateDataByteCount: u32,
                InputPrivateData: ?[*]const u8,
                OutputPrivateData: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptorContext_InitializeHardwareKey(self: *const T, InputPrivateDataByteCount: u32, InputPrivateData: ?[*]const u8, OutputPrivateData: ?*u64) HRESULT {
                return @as(*const IMFContentDecryptorContext.VTable, @ptrCast(self.vtable)).InitializeHardwareKey(@as(*const IMFContentDecryptorContext, @ptrCast(self)), InputPrivateDataByteCount, InputPrivateData, OutputPrivateData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIAKEYSESSION_TYPE = enum(i32) {
    TEMPORARY = 0,
    PERSISTENT_LICENSE = 1,
    PERSISTENT_RELEASE_MESSAGE = 2,
    PERSISTENT_USAGE_RECORD = 3,
};
pub const MF_MEDIAKEYSESSION_TYPE_TEMPORARY = MF_MEDIAKEYSESSION_TYPE.TEMPORARY;
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE = MF_MEDIAKEYSESSION_TYPE.PERSISTENT_LICENSE;
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE = MF_MEDIAKEYSESSION_TYPE.PERSISTENT_RELEASE_MESSAGE;
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD = MF_MEDIAKEYSESSION_TYPE.PERSISTENT_USAGE_RECORD;

pub const MF_MEDIAKEY_STATUS = enum(i32) {
    USABLE = 0,
    EXPIRED = 1,
    OUTPUT_DOWNSCALED = 2,
    OUTPUT_NOT_ALLOWED = 3,
    STATUS_PENDING = 4,
    INTERNAL_ERROR = 5,
    RELEASED = 6,
    OUTPUT_RESTRICTED = 7,
};
pub const MF_MEDIAKEY_STATUS_USABLE = MF_MEDIAKEY_STATUS.USABLE;
pub const MF_MEDIAKEY_STATUS_EXPIRED = MF_MEDIAKEY_STATUS.EXPIRED;
pub const MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED = MF_MEDIAKEY_STATUS.OUTPUT_DOWNSCALED;
pub const MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED = MF_MEDIAKEY_STATUS.OUTPUT_NOT_ALLOWED;
pub const MF_MEDIAKEY_STATUS_STATUS_PENDING = MF_MEDIAKEY_STATUS.STATUS_PENDING;
pub const MF_MEDIAKEY_STATUS_INTERNAL_ERROR = MF_MEDIAKEY_STATUS.INTERNAL_ERROR;
pub const MF_MEDIAKEY_STATUS_RELEASED = MF_MEDIAKEY_STATUS.RELEASED;
pub const MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED = MF_MEDIAKEY_STATUS.OUTPUT_RESTRICTED;

pub const MFMediaKeyStatus = extern struct {
    pbKeyId: ?*u8,
    cbKeyId: u32,
    eMediaKeyStatus: MF_MEDIAKEY_STATUS,
};

pub const MF_MEDIAKEYSESSION_MESSAGETYPE = enum(i32) {
    LICENSE_REQUEST = 0,
    LICENSE_RENEWAL = 1,
    LICENSE_RELEASE = 2,
    INDIVIDUALIZATION_REQUEST = 3,
};
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST = MF_MEDIAKEYSESSION_MESSAGETYPE.LICENSE_REQUEST;
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL = MF_MEDIAKEYSESSION_MESSAGETYPE.LICENSE_RENEWAL;
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE = MF_MEDIAKEYSESSION_MESSAGETYPE.LICENSE_RELEASE;
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST = MF_MEDIAKEYSESSION_MESSAGETYPE.INDIVIDUALIZATION_REQUEST;

pub const MF_CROSS_ORIGIN_POLICY = enum(i32) {
    NONE = 0,
    ANONYMOUS = 1,
    USE_CREDENTIALS = 2,
};
pub const MF_CROSS_ORIGIN_POLICY_NONE = MF_CROSS_ORIGIN_POLICY.NONE;
pub const MF_CROSS_ORIGIN_POLICY_ANONYMOUS = MF_CROSS_ORIGIN_POLICY.ANONYMOUS;
pub const MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS = MF_CROSS_ORIGIN_POLICY.USE_CREDENTIALS;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFNetCrossOriginSupport_Value = Guid.initString("bc2b7d44-a72d-49d5-8376-1480dee58b22");
pub const IID_IMFNetCrossOriginSupport = &IID_IMFNetCrossOriginSupport_Value;
pub const IMFNetCrossOriginSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCrossOriginPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCrossOriginSupport,
                pPolicy: ?*MF_CROSS_ORIGIN_POLICY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCrossOriginSupport,
                pPolicy: ?*MF_CROSS_ORIGIN_POLICY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceOrigin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCrossOriginSupport,
                wszSourceOrigin: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCrossOriginSupport,
                wszSourceOrigin: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSameOrigin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFNetCrossOriginSupport,
                wszURL: ?[*:0]const u16,
                pfIsSameOrigin: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFNetCrossOriginSupport,
                wszURL: ?[*:0]const u16,
                pfIsSameOrigin: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCrossOriginSupport_GetCrossOriginPolicy(self: *const T, pPolicy: ?*MF_CROSS_ORIGIN_POLICY) HRESULT {
                return @as(*const IMFNetCrossOriginSupport.VTable, @ptrCast(self.vtable)).GetCrossOriginPolicy(@as(*const IMFNetCrossOriginSupport, @ptrCast(self)), pPolicy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCrossOriginSupport_GetSourceOrigin(self: *const T, wszSourceOrigin: ?*?PWSTR) HRESULT {
                return @as(*const IMFNetCrossOriginSupport.VTable, @ptrCast(self.vtable)).GetSourceOrigin(@as(*const IMFNetCrossOriginSupport, @ptrCast(self)), wszSourceOrigin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFNetCrossOriginSupport_IsSameOrigin(self: *const T, wszURL: ?[*:0]const u16, pfIsSameOrigin: ?*BOOL) HRESULT {
                return @as(*const IMFNetCrossOriginSupport.VTable, @ptrCast(self.vtable)).IsSameOrigin(@as(*const IMFNetCrossOriginSupport, @ptrCast(self)), wszURL, pfIsSameOrigin);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFHttpDownloadRequest_Value = Guid.initString("f779fddf-26e7-4270-8a8b-b983d1859de0");
pub const IID_IMFHttpDownloadRequest = &IID_IMFHttpDownloadRequest_Value;
pub const IMFHttpDownloadRequest = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                szHeader: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                szHeader: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginSendRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pbPayload: ?[*:0]const u8,
                cbPayload: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pbPayload: ?[*:0]const u8,
                cbPayload: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSendRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginReceiveResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndReceiveResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pResult: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginReadPayload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pb: [*:0]u8,
                cb: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pb: [*:0]u8,
                cb: u32,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndReadPayload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pResult: ?*IMFAsyncResult,
                pqwOffset: ?*u64,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pResult: ?*IMFAsyncResult,
                pqwOffset: ?*u64,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                szHeaderName: ?[*:0]const u16,
                dwIndex: u32,
                ppszHeaderValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                szHeaderName: ?[*:0]const u16,
                dwIndex: u32,
                ppszHeaderValue: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                ppszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasNullSourceOrigin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pfNullSourceOrigin: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pfNullSourceOrigin: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeSeekResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pqwStartTime: ?*u64,
                pqwStopTime: ?*u64,
                pqwDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pqwStartTime: ?*u64,
                pqwStopTime: ?*u64,
                pqwDuration: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHttpStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pdwHttpStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pdwHttpStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAtEndOfPayload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pfAtEndOfPayload: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pfAtEndOfPayload: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pqwTotalLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pqwTotalLength: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRangeEndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
                pqwRangeEnd: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
                pqwRangeEnd: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_AddHeader(self: *const T, szHeader: ?[*:0]const u16) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).AddHeader(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), szHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_BeginSendRequest(self: *const T, pbPayload: ?[*:0]const u8, cbPayload: u32, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).BeginSendRequest(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pbPayload, cbPayload, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_EndSendRequest(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).EndSendRequest(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_BeginReceiveResponse(self: *const T, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).BeginReceiveResponse(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_EndReceiveResponse(self: *const T, pResult: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).EndReceiveResponse(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_BeginReadPayload(self: *const T, pb: [*:0]u8, cb: u32, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).BeginReadPayload(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pb, cb, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_EndReadPayload(self: *const T, pResult: ?*IMFAsyncResult, pqwOffset: ?*u64, pcbRead: ?*u32) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).EndReadPayload(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pResult, pqwOffset, pcbRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_QueryHeader(self: *const T, szHeaderName: ?[*:0]const u16, dwIndex: u32, ppszHeaderValue: ?*?PWSTR) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).QueryHeader(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), szHeaderName, dwIndex, ppszHeaderValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_GetURL(self: *const T, ppszURL: ?*?PWSTR) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).GetURL(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), ppszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_HasNullSourceOrigin(self: *const T, pfNullSourceOrigin: ?*BOOL) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).HasNullSourceOrigin(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pfNullSourceOrigin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_GetTimeSeekResult(self: *const T, pqwStartTime: ?*u64, pqwStopTime: ?*u64, pqwDuration: ?*u64) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).GetTimeSeekResult(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pqwStartTime, pqwStopTime, pqwDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_GetHttpStatus(self: *const T, pdwHttpStatus: ?*u32) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).GetHttpStatus(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pdwHttpStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_GetAtEndOfPayload(self: *const T, pfAtEndOfPayload: ?*BOOL) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).GetAtEndOfPayload(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pfAtEndOfPayload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_GetTotalLength(self: *const T, pqwTotalLength: ?*u64) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).GetTotalLength(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pqwTotalLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_GetRangeEndOffset(self: *const T, pqwRangeEnd: ?*u64) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).GetRangeEndOffset(@as(*const IMFHttpDownloadRequest, @ptrCast(self)), pqwRangeEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadRequest_Close(self: *const T) HRESULT {
                return @as(*const IMFHttpDownloadRequest.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFHttpDownloadRequest, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFHttpDownloadSession_Value = Guid.initString("71fa9a2c-53ce-4662-a132-1a7e8cbf62db");
pub const IID_IMFHttpDownloadSession = &IID_IMFHttpDownloadSession_Value;
pub const IMFHttpDownloadSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadSession,
                szServerName: ?[*:0]const u16,
                nPort: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadSession,
                szServerName: ?[*:0]const u16,
                nPort: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadSession,
                szObjectName: ?[*:0]const u16,
                fBypassProxyCache: BOOL,
                fSecure: BOOL,
                szVerb: ?[*:0]const u16,
                szReferrer: ?[*:0]const u16,
                ppRequest: ?*?*IMFHttpDownloadRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadSession,
                szObjectName: ?[*:0]const u16,
                fBypassProxyCache: BOOL,
                fSecure: BOOL,
                szVerb: ?[*:0]const u16,
                szReferrer: ?[*:0]const u16,
                ppRequest: ?*?*IMFHttpDownloadRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadSession_SetServer(self: *const T, szServerName: ?[*:0]const u16, nPort: u32) HRESULT {
                return @as(*const IMFHttpDownloadSession.VTable, @ptrCast(self.vtable)).SetServer(@as(*const IMFHttpDownloadSession, @ptrCast(self)), szServerName, nPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadSession_CreateRequest(self: *const T, szObjectName: ?[*:0]const u16, fBypassProxyCache: BOOL, fSecure: BOOL, szVerb: ?[*:0]const u16, szReferrer: ?[*:0]const u16, ppRequest: ?*?*IMFHttpDownloadRequest) HRESULT {
                return @as(*const IMFHttpDownloadSession.VTable, @ptrCast(self.vtable)).CreateRequest(@as(*const IMFHttpDownloadSession, @ptrCast(self)), szObjectName, fBypassProxyCache, fSecure, szVerb, szReferrer, ppRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadSession_Close(self: *const T) HRESULT {
                return @as(*const IMFHttpDownloadSession.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFHttpDownloadSession, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFHttpDownloadSessionProvider_Value = Guid.initString("1b4cf4b9-3a16-4115-839d-03cc5c99df01");
pub const IID_IMFHttpDownloadSessionProvider = &IID_IMFHttpDownloadSessionProvider_Value;
pub const IMFHttpDownloadSessionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateHttpDownloadSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHttpDownloadSessionProvider,
                wszScheme: ?[*:0]const u16,
                ppDownloadSession: ?*?*IMFHttpDownloadSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHttpDownloadSessionProvider,
                wszScheme: ?[*:0]const u16,
                ppDownloadSession: ?*?*IMFHttpDownloadSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHttpDownloadSessionProvider_CreateHttpDownloadSession(self: *const T, wszScheme: ?[*:0]const u16, ppDownloadSession: ?*?*IMFHttpDownloadSession) HRESULT {
                return @as(*const IMFHttpDownloadSessionProvider.VTable, @ptrCast(self.vtable)).CreateHttpDownloadSession(@as(*const IMFHttpDownloadSessionProvider, @ptrCast(self)), wszScheme, ppDownloadSession);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_VIDEO_SPHERICAL_VIEWDIRECTION = extern struct {
    iHeading: i32,
    iPitch: i32,
    iRoll: i32,
};

const IID_IMFMediaSource2_Value = Guid.initString("fbb03414-d13b-4786-8319-5ac51fc0a136");
pub const IID_IMFMediaSource2 = &IID_IMFMediaSource2_Value;
pub const IMFMediaSource2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaSourceEx.VTable,
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSource2,
                dwStreamID: u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSource2,
                dwStreamID: u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaSourceEx.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSource2_SetMediaType(self: *const T, dwStreamID: u32, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFMediaSource2.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IMFMediaSource2, @ptrCast(self)), dwStreamID, pMediaType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaStream2_Value = Guid.initString("c5bc37d6-75c7-46a1-a132-81b5f723c20f");
pub const IID_IMFMediaStream2 = &IID_IMFMediaStream2_Value;
pub const IMFMediaStream2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaStream.VTable,
        SetStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaStream2,
                value: MF_STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaStream2,
                value: MF_STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaStream2,
                value: ?*MF_STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaStream2,
                value: ?*MF_STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaStream.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaStream2_SetStreamState(self: *const T, value: MF_STREAM_STATE) HRESULT {
                return @as(*const IMFMediaStream2.VTable, @ptrCast(self.vtable)).SetStreamState(@as(*const IMFMediaStream2, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaStream2_GetStreamState(self: *const T, value: ?*MF_STREAM_STATE) HRESULT {
                return @as(*const IMFMediaStream2.VTable, @ptrCast(self.vtable)).GetStreamState(@as(*const IMFMediaStream2, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFSensorDeviceType = enum(i32) {
    Unknown = 0,
    Device = 1,
    MediaSource = 2,
    FrameProvider = 3,
    SensorTransform = 4,
};
pub const MFSensorDeviceType_Unknown = MFSensorDeviceType.Unknown;
pub const MFSensorDeviceType_Device = MFSensorDeviceType.Device;
pub const MFSensorDeviceType_MediaSource = MFSensorDeviceType.MediaSource;
pub const MFSensorDeviceType_FrameProvider = MFSensorDeviceType.FrameProvider;
pub const MFSensorDeviceType_SensorTransform = MFSensorDeviceType.SensorTransform;

pub const MFSensorStreamType = enum(i32) {
    Unknown = 0,
    Input = 1,
    Output = 2,
};
pub const MFSensorStreamType_Unknown = MFSensorStreamType.Unknown;
pub const MFSensorStreamType_Input = MFSensorStreamType.Input;
pub const MFSensorStreamType_Output = MFSensorStreamType.Output;

pub const MFSensorDeviceMode = enum(i32) {
    Controller = 0,
    Shared = 1,
};
pub const MFSensorDeviceMode_Controller = MFSensorDeviceMode.Controller;
pub const MFSensorDeviceMode_Shared = MFSensorDeviceMode.Shared;

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IMFSensorDevice_Value = Guid.initString("fb9f48f2-2a18-4e28-9730-786f30f04dc4");
pub const IID_IMFSensorDevice = &IID_IMFSensorDevice_Value;
pub const IMFSensorDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                pDeviceId: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                pDeviceId: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                pType: ?*MFSensorDeviceType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                pType: ?*MFSensorDeviceType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                pFlags: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                pFlags: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolicLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                SymbolicLink: [*:0]u16,
                cchSymbolicLink: i32,
                pcchWritten: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                SymbolicLink: [*:0]u16,
                cchSymbolicLink: i32,
                pcchWritten: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamAttributesCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                eType: MFSensorStreamType,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                eType: MFSensorStreamType,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                eType: MFSensorStreamType,
                dwIndex: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                eType: MFSensorStreamType,
                dwIndex: u32,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSensorDeviceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                eMode: MFSensorDeviceMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                eMode: MFSensorDeviceMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSensorDeviceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorDevice,
                peMode: ?*MFSensorDeviceMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorDevice,
                peMode: ?*MFSensorDeviceMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetDeviceId(self: *const T, pDeviceId: ?*u64) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetDeviceId(@as(*const IMFSensorDevice, @ptrCast(self)), pDeviceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetDeviceType(self: *const T, pType: ?*MFSensorDeviceType) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetDeviceType(@as(*const IMFSensorDevice, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetFlags(self: *const T, pFlags: ?*u64) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMFSensorDevice, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetSymbolicLink(self: *const T, SymbolicLink: [*:0]u16, cchSymbolicLink: i32, pcchWritten: ?*i32) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetSymbolicLink(@as(*const IMFSensorDevice, @ptrCast(self)), SymbolicLink, cchSymbolicLink, pcchWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetDeviceAttributes(self: *const T, ppAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetDeviceAttributes(@as(*const IMFSensorDevice, @ptrCast(self)), ppAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetStreamAttributesCount(self: *const T, eType: MFSensorStreamType, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetStreamAttributesCount(@as(*const IMFSensorDevice, @ptrCast(self)), eType, pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetStreamAttributes(self: *const T, eType: MFSensorStreamType, dwIndex: u32, ppAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetStreamAttributes(@as(*const IMFSensorDevice, @ptrCast(self)), eType, dwIndex, ppAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_SetSensorDeviceMode(self: *const T, eMode: MFSensorDeviceMode) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).SetSensorDeviceMode(@as(*const IMFSensorDevice, @ptrCast(self)), eMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorDevice_GetSensorDeviceMode(self: *const T, peMode: ?*MFSensorDeviceMode) HRESULT {
                return @as(*const IMFSensorDevice.VTable, @ptrCast(self.vtable)).GetSensorDeviceMode(@as(*const IMFSensorDevice, @ptrCast(self)), peMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.14393'
const IID_IMFSensorGroup_Value = Guid.initString("4110243a-9757-461f-89f1-f22345bcab4e");
pub const IID_IMFSensorGroup = &IID_IMFSensorGroup_Value;
pub const IMFSensorGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolicLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                SymbolicLink: [*:0]u16,
                cchSymbolicLink: i32,
                pcchWritten: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                SymbolicLink: [*:0]u16,
                cchSymbolicLink: i32,
                pcchWritten: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                pFlags: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                pFlags: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSensorGroupAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSensorDeviceCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSensorDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                dwIndex: u32,
                ppDevice: ?*?*IMFSensorDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                dwIndex: u32,
                ppDevice: ?*?*IMFSensorDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultSensorDeviceIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                dwIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                dwIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultSensorDeviceIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                pdwIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                pdwIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMediaSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorGroup,
                ppSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorGroup,
                ppSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_GetSymbolicLink(self: *const T, SymbolicLink: [*:0]u16, cchSymbolicLink: i32, pcchWritten: ?*i32) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).GetSymbolicLink(@as(*const IMFSensorGroup, @ptrCast(self)), SymbolicLink, cchSymbolicLink, pcchWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_GetFlags(self: *const T, pFlags: ?*u64) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMFSensorGroup, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_GetSensorGroupAttributes(self: *const T, ppAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).GetSensorGroupAttributes(@as(*const IMFSensorGroup, @ptrCast(self)), ppAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_GetSensorDeviceCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).GetSensorDeviceCount(@as(*const IMFSensorGroup, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_GetSensorDevice(self: *const T, dwIndex: u32, ppDevice: ?*?*IMFSensorDevice) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).GetSensorDevice(@as(*const IMFSensorGroup, @ptrCast(self)), dwIndex, ppDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_SetDefaultSensorDeviceIndex(self: *const T, dwIndex: u32) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).SetDefaultSensorDeviceIndex(@as(*const IMFSensorGroup, @ptrCast(self)), dwIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_GetDefaultSensorDeviceIndex(self: *const T, pdwIndex: ?*u32) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).GetDefaultSensorDeviceIndex(@as(*const IMFSensorGroup, @ptrCast(self)), pdwIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorGroup_CreateMediaSource(self: *const T, ppSource: ?*?*IMFMediaSource) HRESULT {
                return @as(*const IMFSensorGroup.VTable, @ptrCast(self.vtable)).CreateMediaSource(@as(*const IMFSensorGroup, @ptrCast(self)), ppSource);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorStream_Value = Guid.initString("e9a42171-c56e-498a-8b39-eda5a070b7fc");
pub const IID_IMFSensorStream = &IID_IMFSensorStream_Value;
pub const IMFSensorStream = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetMediaTypeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorStream,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorStream,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorStream,
                dwIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorStream,
                dwIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloneSensorStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorStream,
                ppStream: ?*?*IMFSensorStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorStream,
                ppStream: ?*?*IMFSensorStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorStream_GetMediaTypeCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFSensorStream.VTable, @ptrCast(self.vtable)).GetMediaTypeCount(@as(*const IMFSensorStream, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorStream_GetMediaType(self: *const T, dwIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFSensorStream.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IMFSensorStream, @ptrCast(self)), dwIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorStream_CloneSensorStream(self: *const T, ppStream: ?*?*IMFSensorStream) HRESULT {
                return @as(*const IMFSensorStream.VTable, @ptrCast(self.vtable)).CloneSensorStream(@as(*const IMFSensorStream, @ptrCast(self)), ppStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorTransformFactory_Value = Guid.initString("eed9c2ee-66b4-4f18-a697-ac7d3960215c");
pub const IID_IMFSensorTransformFactory = &IID_IMFSensorTransformFactory_Value;
pub const IMFSensorTransformFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFactoryAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorTransformFactory,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorTransformFactory,
                ppAttributes: ?*?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeFactory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorTransformFactory,
                dwMaxTransformCount: u32,
                pSensorDevices: ?*IMFCollection,
                pAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorTransformFactory,
                dwMaxTransformCount: u32,
                pSensorDevices: ?*IMFCollection,
                pAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransformCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorTransformFactory,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorTransformFactory,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransformInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorTransformFactory,
                TransformIndex: u32,
                pguidTransformId: ?*Guid,
                ppAttributes: ?*?*IMFAttributes,
                ppStreamInformation: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorTransformFactory,
                TransformIndex: u32,
                pguidTransformId: ?*Guid,
                ppAttributes: ?*?*IMFAttributes,
                ppStreamInformation: ?*?*IMFCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTransform: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorTransformFactory,
                guidSensorTransformID: ?*const Guid,
                pAttributes: ?*IMFAttributes,
                ppDeviceMFT: ?*?*IMFDeviceTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorTransformFactory,
                guidSensorTransformID: ?*const Guid,
                pAttributes: ?*IMFAttributes,
                ppDeviceMFT: ?*?*IMFDeviceTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorTransformFactory_GetFactoryAttributes(self: *const T, ppAttributes: ?*?*IMFAttributes) HRESULT {
                return @as(*const IMFSensorTransformFactory.VTable, @ptrCast(self.vtable)).GetFactoryAttributes(@as(*const IMFSensorTransformFactory, @ptrCast(self)), ppAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorTransformFactory_InitializeFactory(self: *const T, dwMaxTransformCount: u32, pSensorDevices: ?*IMFCollection, pAttributes: ?*IMFAttributes) HRESULT {
                return @as(*const IMFSensorTransformFactory.VTable, @ptrCast(self.vtable)).InitializeFactory(@as(*const IMFSensorTransformFactory, @ptrCast(self)), dwMaxTransformCount, pSensorDevices, pAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorTransformFactory_GetTransformCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFSensorTransformFactory.VTable, @ptrCast(self.vtable)).GetTransformCount(@as(*const IMFSensorTransformFactory, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorTransformFactory_GetTransformInformation(self: *const T, TransformIndex: u32, pguidTransformId: ?*Guid, ppAttributes: ?*?*IMFAttributes, ppStreamInformation: ?*?*IMFCollection) HRESULT {
                return @as(*const IMFSensorTransformFactory.VTable, @ptrCast(self.vtable)).GetTransformInformation(@as(*const IMFSensorTransformFactory, @ptrCast(self)), TransformIndex, pguidTransformId, ppAttributes, ppStreamInformation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorTransformFactory_CreateTransform(self: *const T, guidSensorTransformID: ?*const Guid, pAttributes: ?*IMFAttributes, ppDeviceMFT: ?*?*IMFDeviceTransform) HRESULT {
                return @as(*const IMFSensorTransformFactory.VTable, @ptrCast(self.vtable)).CreateTransform(@as(*const IMFSensorTransformFactory, @ptrCast(self)), guidSensorTransformID, pAttributes, ppDeviceMFT);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SENSORPROFILEID = extern struct {
    Type: Guid,
    Index: u32,
    Unused: u32,
};

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IMFSensorProfile_Value = Guid.initString("22f765d1-8dab-4107-846d-56baf72215e7");
pub const IID_IMFSensorProfile = &IID_IMFSensorProfile_Value;
pub const IMFSensorProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProfileId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfile,
                pId: ?*SENSORPROFILEID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfile,
                pId: ?*SENSORPROFILEID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProfileFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfile,
                StreamId: u32,
                wzFilterSetString: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfile,
                StreamId: u32,
                wzFilterSetString: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMediaTypeSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfile,
                StreamId: u32,
                pMediaType: ?*IMFMediaType,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfile,
                StreamId: u32,
                pMediaType: ?*IMFMediaType,
                pfSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBlockedControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfile,
                wzBlockedControl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfile,
                wzBlockedControl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfile_GetProfileId(self: *const T, pId: ?*SENSORPROFILEID) HRESULT {
                return @as(*const IMFSensorProfile.VTable, @ptrCast(self.vtable)).GetProfileId(@as(*const IMFSensorProfile, @ptrCast(self)), pId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfile_AddProfileFilter(self: *const T, StreamId: u32, wzFilterSetString: ?[*:0]const u16) HRESULT {
                return @as(*const IMFSensorProfile.VTable, @ptrCast(self.vtable)).AddProfileFilter(@as(*const IMFSensorProfile, @ptrCast(self)), StreamId, wzFilterSetString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfile_IsMediaTypeSupported(self: *const T, StreamId: u32, pMediaType: ?*IMFMediaType, pfSupported: ?*BOOL) HRESULT {
                return @as(*const IMFSensorProfile.VTable, @ptrCast(self.vtable)).IsMediaTypeSupported(@as(*const IMFSensorProfile, @ptrCast(self)), StreamId, pMediaType, pfSupported);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfile_AddBlockedControl(self: *const T, wzBlockedControl: ?[*:0]const u16) HRESULT {
                return @as(*const IMFSensorProfile.VTable, @ptrCast(self.vtable)).AddBlockedControl(@as(*const IMFSensorProfile, @ptrCast(self)), wzBlockedControl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.17134'
const IID_IMFSensorProfileCollection_Value = Guid.initString("c95ea55b-0187-48be-9353-8d2507662351");
pub const IID_IMFSensorProfileCollection = &IID_IMFSensorProfileCollection_Value;
pub const IMFSensorProfileCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProfileCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfileCollection,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFSensorProfileCollection,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfileCollection,
                Index: u32,
                ppProfile: ?*?*IMFSensorProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfileCollection,
                Index: u32,
                ppProfile: ?*?*IMFSensorProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfileCollection,
                pProfile: ?*IMFSensorProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfileCollection,
                pProfile: ?*IMFSensorProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfileCollection,
                ProfileId: ?*SENSORPROFILEID,
                ppProfile: ?*?*IMFSensorProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProfileCollection,
                ProfileId: ?*SENSORPROFILEID,
                ppProfile: ?*?*IMFSensorProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProfileByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfileCollection,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSensorProfileCollection,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        RemoveProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProfileCollection,
                ProfileId: ?*SENSORPROFILEID,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSensorProfileCollection,
                ProfileId: ?*SENSORPROFILEID,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfileCollection_GetProfileCount(self: *const T) u32 {
                return @as(*const IMFSensorProfileCollection.VTable, @ptrCast(self.vtable)).GetProfileCount(@as(*const IMFSensorProfileCollection, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfileCollection_GetProfile(self: *const T, Index: u32, ppProfile: ?*?*IMFSensorProfile) HRESULT {
                return @as(*const IMFSensorProfileCollection.VTable, @ptrCast(self.vtable)).GetProfile(@as(*const IMFSensorProfileCollection, @ptrCast(self)), Index, ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfileCollection_AddProfile(self: *const T, pProfile: ?*IMFSensorProfile) HRESULT {
                return @as(*const IMFSensorProfileCollection.VTable, @ptrCast(self.vtable)).AddProfile(@as(*const IMFSensorProfileCollection, @ptrCast(self)), pProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfileCollection_FindProfile(self: *const T, ProfileId: ?*SENSORPROFILEID, ppProfile: ?*?*IMFSensorProfile) HRESULT {
                return @as(*const IMFSensorProfileCollection.VTable, @ptrCast(self.vtable)).FindProfile(@as(*const IMFSensorProfileCollection, @ptrCast(self)), ProfileId, ppProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfileCollection_RemoveProfileByIndex(self: *const T, Index: u32) void {
                return @as(*const IMFSensorProfileCollection.VTable, @ptrCast(self.vtable)).RemoveProfileByIndex(@as(*const IMFSensorProfileCollection, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProfileCollection_RemoveProfile(self: *const T, ProfileId: ?*SENSORPROFILEID) void {
                return @as(*const IMFSensorProfileCollection.VTable, @ptrCast(self.vtable)).RemoveProfile(@as(*const IMFSensorProfileCollection, @ptrCast(self)), ProfileId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorProcessActivity_Value = Guid.initString("39dc7f4a-b141-4719-813c-a7f46162a2b8");
pub const IID_IMFSensorProcessActivity = &IID_IMFSensorProcessActivity_Value;
pub const IMFSensorProcessActivity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProcessActivity,
                pPID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProcessActivity,
                pPID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamingState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProcessActivity,
                pfStreaming: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProcessActivity,
                pfStreaming: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProcessActivity,
                pMode: ?*MFSensorDeviceMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProcessActivity,
                pMode: ?*MFSensorDeviceMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReportTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorProcessActivity,
                pft: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorProcessActivity,
                pft: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProcessActivity_GetProcessId(self: *const T, pPID: ?*u32) HRESULT {
                return @as(*const IMFSensorProcessActivity.VTable, @ptrCast(self.vtable)).GetProcessId(@as(*const IMFSensorProcessActivity, @ptrCast(self)), pPID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProcessActivity_GetStreamingState(self: *const T, pfStreaming: ?*BOOL) HRESULT {
                return @as(*const IMFSensorProcessActivity.VTable, @ptrCast(self.vtable)).GetStreamingState(@as(*const IMFSensorProcessActivity, @ptrCast(self)), pfStreaming);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProcessActivity_GetStreamingMode(self: *const T, pMode: ?*MFSensorDeviceMode) HRESULT {
                return @as(*const IMFSensorProcessActivity.VTable, @ptrCast(self.vtable)).GetStreamingMode(@as(*const IMFSensorProcessActivity, @ptrCast(self)), pMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorProcessActivity_GetReportTime(self: *const T, pft: ?*FILETIME) HRESULT {
                return @as(*const IMFSensorProcessActivity.VTable, @ptrCast(self.vtable)).GetReportTime(@as(*const IMFSensorProcessActivity, @ptrCast(self)), pft);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorActivityReport_Value = Guid.initString("3e8c4be1-a8c2-4528-90de-2851bde5fead");
pub const IID_IMFSensorActivityReport = &IID_IMFSensorActivityReport_Value;
pub const IMFSensorActivityReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFriendlyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivityReport,
                FriendlyName: [*:0]u16,
                cchFriendlyName: u32,
                pcchWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivityReport,
                FriendlyName: [*:0]u16,
                cchFriendlyName: u32,
                pcchWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolicLink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivityReport,
                SymbolicLink: [*:0]u16,
                cchSymbolicLink: u32,
                pcchWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivityReport,
                SymbolicLink: [*:0]u16,
                cchSymbolicLink: u32,
                pcchWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivityReport,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivityReport,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessActivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivityReport,
                Index: u32,
                ppProcessActivity: ?*?*IMFSensorProcessActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivityReport,
                Index: u32,
                ppProcessActivity: ?*?*IMFSensorProcessActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivityReport_GetFriendlyName(self: *const T, FriendlyName: [*:0]u16, cchFriendlyName: u32, pcchWritten: ?*u32) HRESULT {
                return @as(*const IMFSensorActivityReport.VTable, @ptrCast(self.vtable)).GetFriendlyName(@as(*const IMFSensorActivityReport, @ptrCast(self)), FriendlyName, cchFriendlyName, pcchWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivityReport_GetSymbolicLink(self: *const T, SymbolicLink: [*:0]u16, cchSymbolicLink: u32, pcchWritten: ?*u32) HRESULT {
                return @as(*const IMFSensorActivityReport.VTable, @ptrCast(self.vtable)).GetSymbolicLink(@as(*const IMFSensorActivityReport, @ptrCast(self)), SymbolicLink, cchSymbolicLink, pcchWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivityReport_GetProcessCount(self: *const T, pcCount: ?*u32) HRESULT {
                return @as(*const IMFSensorActivityReport.VTable, @ptrCast(self.vtable)).GetProcessCount(@as(*const IMFSensorActivityReport, @ptrCast(self)), pcCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivityReport_GetProcessActivity(self: *const T, Index: u32, ppProcessActivity: ?*?*IMFSensorProcessActivity) HRESULT {
                return @as(*const IMFSensorActivityReport.VTable, @ptrCast(self.vtable)).GetProcessActivity(@as(*const IMFSensorActivityReport, @ptrCast(self)), Index, ppProcessActivity);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorActivitiesReport_Value = Guid.initString("683f7a5e-4a19-43cd-b1a9-dbf4ab3f7777");
pub const IID_IMFSensorActivitiesReport = &IID_IMFSensorActivitiesReport_Value;
pub const IMFSensorActivitiesReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivitiesReport,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivitiesReport,
                pcCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActivityReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivitiesReport,
                Index: u32,
                sensorActivityReport: ?*?*IMFSensorActivityReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivitiesReport,
                Index: u32,
                sensorActivityReport: ?*?*IMFSensorActivityReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActivityReportByDeviceName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivitiesReport,
                SymbolicName: ?[*:0]const u16,
                sensorActivityReport: ?*?*IMFSensorActivityReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivitiesReport,
                SymbolicName: ?[*:0]const u16,
                sensorActivityReport: ?*?*IMFSensorActivityReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivitiesReport_GetCount(self: *const T, pcCount: ?*u32) HRESULT {
                return @as(*const IMFSensorActivitiesReport.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IMFSensorActivitiesReport, @ptrCast(self)), pcCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivitiesReport_GetActivityReport(self: *const T, Index: u32, sensorActivityReport: ?*?*IMFSensorActivityReport) HRESULT {
                return @as(*const IMFSensorActivitiesReport.VTable, @ptrCast(self.vtable)).GetActivityReport(@as(*const IMFSensorActivitiesReport, @ptrCast(self)), Index, sensorActivityReport);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivitiesReport_GetActivityReportByDeviceName(self: *const T, SymbolicName: ?[*:0]const u16, sensorActivityReport: ?*?*IMFSensorActivityReport) HRESULT {
                return @as(*const IMFSensorActivitiesReport.VTable, @ptrCast(self.vtable)).GetActivityReportByDeviceName(@as(*const IMFSensorActivitiesReport, @ptrCast(self)), SymbolicName, sensorActivityReport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorActivitiesReportCallback_Value = Guid.initString("de5072ee-dbe3-46dc-8a87-b6f631194751");
pub const IID_IMFSensorActivitiesReportCallback = &IID_IMFSensorActivitiesReportCallback_Value;
pub const IMFSensorActivitiesReportCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivitiesReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivitiesReportCallback,
                sensorActivitiesReport: ?*IMFSensorActivitiesReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivitiesReportCallback,
                sensorActivitiesReport: ?*IMFSensorActivitiesReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivitiesReportCallback_OnActivitiesReport(self: *const T, sensorActivitiesReport: ?*IMFSensorActivitiesReport) HRESULT {
                return @as(*const IMFSensorActivitiesReportCallback.VTable, @ptrCast(self.vtable)).OnActivitiesReport(@as(*const IMFSensorActivitiesReportCallback, @ptrCast(self)), sensorActivitiesReport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSensorActivityMonitor_Value = Guid.initString("d0cef145-b3f4-4340-a2e5-7a5080ca05cb");
pub const IID_IMFSensorActivityMonitor = &IID_IMFSensorActivityMonitor_Value;
pub const IMFSensorActivityMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivityMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivityMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSensorActivityMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSensorActivityMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivityMonitor_Start(self: *const T) HRESULT {
                return @as(*const IMFSensorActivityMonitor.VTable, @ptrCast(self.vtable)).Start(@as(*const IMFSensorActivityMonitor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSensorActivityMonitor_Stop(self: *const T) HRESULT {
                return @as(*const IMFSensorActivityMonitor.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFSensorActivityMonitor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFCameraIntrinsic_CameraModel = extern struct {
    FocalLength_x: f32,
    FocalLength_y: f32,
    PrincipalPoint_x: f32,
    PrincipalPoint_y: f32,
};

pub const MFCameraIntrinsic_DistortionModel6KT = extern struct {
    Radial_k1: f32,
    Radial_k2: f32,
    Radial_k3: f32,
    Radial_k4: f32,
    Radial_k5: f32,
    Radial_k6: f32,
    Tangential_p1: f32,
    Tangential_p2: f32,
};

pub const MFCameraIntrinsic_DistortionModelArcTan = extern struct {
    Radial_k0: f32,
    DistortionCenter_x: f32,
    DistortionCenter_y: f32,
    Tangential_x: f32,
    Tangential_y: f32,
};

pub const MFCameraIntrinsic_DistortionModelType = enum(i32) {
    @"6KT" = 0,
    ArcTan = 1,
};
pub const MFCameraIntrinsic_DistortionModelType_6KT = MFCameraIntrinsic_DistortionModelType.@"6KT";
pub const MFCameraIntrinsic_DistortionModelType_ArcTan = MFCameraIntrinsic_DistortionModelType.ArcTan;

pub const MFExtendedCameraIntrinsic_IntrinsicModel = extern struct {
    Width: u32,
    Height: u32,
    SplitFrameId: u32,
    CameraModel: MFCameraIntrinsic_CameraModel,
};

const IID_IMFExtendedCameraIntrinsicModel_Value = Guid.initString("5c595e64-4630-4231-855a-12842f733245");
pub const IID_IMFExtendedCameraIntrinsicModel = &IID_IMFExtendedCameraIntrinsicModel_Value;
pub const IMFExtendedCameraIntrinsicModel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicModel,
                pIntrinsicModel: ?*MFExtendedCameraIntrinsic_IntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicModel,
                pIntrinsicModel: ?*MFExtendedCameraIntrinsic_IntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicModel,
                pIntrinsicModel: ?*const MFExtendedCameraIntrinsic_IntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicModel,
                pIntrinsicModel: ?*const MFExtendedCameraIntrinsic_IntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDistortionModelType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicModel,
                pDistortionModelType: ?*MFCameraIntrinsic_DistortionModelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicModel,
                pDistortionModelType: ?*MFCameraIntrinsic_DistortionModelType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicModel_GetModel(self: *const T, pIntrinsicModel: ?*MFExtendedCameraIntrinsic_IntrinsicModel) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicModel.VTable, @ptrCast(self.vtable)).GetModel(@as(*const IMFExtendedCameraIntrinsicModel, @ptrCast(self)), pIntrinsicModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicModel_SetModel(self: *const T, pIntrinsicModel: ?*const MFExtendedCameraIntrinsic_IntrinsicModel) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicModel.VTable, @ptrCast(self.vtable)).SetModel(@as(*const IMFExtendedCameraIntrinsicModel, @ptrCast(self)), pIntrinsicModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicModel_GetDistortionModelType(self: *const T, pDistortionModelType: ?*MFCameraIntrinsic_DistortionModelType) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicModel.VTable, @ptrCast(self.vtable)).GetDistortionModelType(@as(*const IMFExtendedCameraIntrinsicModel, @ptrCast(self)), pDistortionModelType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraIntrinsicsDistortionModel6KT_Value = Guid.initString("74c2653b-5f55-4eb1-9f0f-18b8f68b7d3d");
pub const IID_IMFExtendedCameraIntrinsicsDistortionModel6KT = &IID_IMFExtendedCameraIntrinsicsDistortionModel6KT_Value;
pub const IMFExtendedCameraIntrinsicsDistortionModel6KT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDistortionModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModel6KT,
                pDistortionModel: ?*MFCameraIntrinsic_DistortionModel6KT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModel6KT,
                pDistortionModel: ?*MFCameraIntrinsic_DistortionModel6KT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDistortionModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModel6KT,
                pDistortionModel: ?*const MFCameraIntrinsic_DistortionModel6KT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModel6KT,
                pDistortionModel: ?*const MFCameraIntrinsic_DistortionModel6KT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicsDistortionModel6KT_GetDistortionModel(self: *const T, pDistortionModel: ?*MFCameraIntrinsic_DistortionModel6KT) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicsDistortionModel6KT.VTable, @ptrCast(self.vtable)).GetDistortionModel(@as(*const IMFExtendedCameraIntrinsicsDistortionModel6KT, @ptrCast(self)), pDistortionModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicsDistortionModel6KT_SetDistortionModel(self: *const T, pDistortionModel: ?*const MFCameraIntrinsic_DistortionModel6KT) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicsDistortionModel6KT.VTable, @ptrCast(self.vtable)).SetDistortionModel(@as(*const IMFExtendedCameraIntrinsicsDistortionModel6KT, @ptrCast(self)), pDistortionModel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan_Value = Guid.initString("812d5f95-b572-45dc-bafc-ae24199ddda8");
pub const IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan = &IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan_Value;
pub const IMFExtendedCameraIntrinsicsDistortionModelArcTan = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDistortionModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModelArcTan,
                pDistortionModel: ?*MFCameraIntrinsic_DistortionModelArcTan,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModelArcTan,
                pDistortionModel: ?*MFCameraIntrinsic_DistortionModelArcTan,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDistortionModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModelArcTan,
                pDistortionModel: ?*const MFCameraIntrinsic_DistortionModelArcTan,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsicsDistortionModelArcTan,
                pDistortionModel: ?*const MFCameraIntrinsic_DistortionModelArcTan,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicsDistortionModelArcTan_GetDistortionModel(self: *const T, pDistortionModel: ?*MFCameraIntrinsic_DistortionModelArcTan) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan.VTable, @ptrCast(self.vtable)).GetDistortionModel(@as(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan, @ptrCast(self)), pDistortionModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsicsDistortionModelArcTan_SetDistortionModel(self: *const T, pDistortionModel: ?*const MFCameraIntrinsic_DistortionModelArcTan) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan.VTable, @ptrCast(self.vtable)).SetDistortionModel(@as(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan, @ptrCast(self)), pDistortionModel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraIntrinsics_Value = Guid.initString("687f6dac-6987-4750-a16a-734d1e7a10fe");
pub const IID_IMFExtendedCameraIntrinsics = &IID_IMFExtendedCameraIntrinsics_Value;
pub const IMFExtendedCameraIntrinsics = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeFromBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsics,
                // TODO: what to do with BytesParamIndex 1?
                pbBuffer: ?*u8,
                dwBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsics,
                // TODO: what to do with BytesParamIndex 1?
                pbBuffer: ?*u8,
                dwBufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBufferSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsics,
                pdwBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsics,
                pdwBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SerializeToBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsics,
                // TODO: what to do with BytesParamIndex 1?
                pbBuffer: ?*u8,
                pdwBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsics,
                // TODO: what to do with BytesParamIndex 1?
                pbBuffer: ?*u8,
                pdwBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicModelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsics,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsics,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicModelByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsics,
                dwIndex: u32,
                ppIntrinsicModel: ?*?*IMFExtendedCameraIntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsics,
                dwIndex: u32,
                ppIntrinsicModel: ?*?*IMFExtendedCameraIntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddIntrinsicModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraIntrinsics,
                pIntrinsicModel: ?*IMFExtendedCameraIntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraIntrinsics,
                pIntrinsicModel: ?*IMFExtendedCameraIntrinsicModel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsics_InitializeFromBuffer(self: *const T, pbBuffer: ?*u8, dwBufferSize: u32) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsics.VTable, @ptrCast(self.vtable)).InitializeFromBuffer(@as(*const IMFExtendedCameraIntrinsics, @ptrCast(self)), pbBuffer, dwBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsics_GetBufferSize(self: *const T, pdwBufferSize: ?*u32) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsics.VTable, @ptrCast(self.vtable)).GetBufferSize(@as(*const IMFExtendedCameraIntrinsics, @ptrCast(self)), pdwBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsics_SerializeToBuffer(self: *const T, pbBuffer: ?*u8, pdwBufferSize: ?*u32) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsics.VTable, @ptrCast(self.vtable)).SerializeToBuffer(@as(*const IMFExtendedCameraIntrinsics, @ptrCast(self)), pbBuffer, pdwBufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsics_GetIntrinsicModelCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsics.VTable, @ptrCast(self.vtable)).GetIntrinsicModelCount(@as(*const IMFExtendedCameraIntrinsics, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsics_GetIntrinsicModelByIndex(self: *const T, dwIndex: u32, ppIntrinsicModel: ?*?*IMFExtendedCameraIntrinsicModel) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsics.VTable, @ptrCast(self.vtable)).GetIntrinsicModelByIndex(@as(*const IMFExtendedCameraIntrinsics, @ptrCast(self)), dwIndex, ppIntrinsicModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraIntrinsics_AddIntrinsicModel(self: *const T, pIntrinsicModel: ?*IMFExtendedCameraIntrinsicModel) HRESULT {
                return @as(*const IMFExtendedCameraIntrinsics.VTable, @ptrCast(self.vtable)).AddIntrinsicModel(@as(*const IMFExtendedCameraIntrinsics, @ptrCast(self)), pIntrinsicModel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraControl_Value = Guid.initString("38e33520-fca1-4845-a27a-68b7c6ab3789");
pub const IID_IMFExtendedCameraControl = &IID_IMFExtendedCameraControl_Value;
pub const IMFExtendedCameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraControl,
                ulFlags: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraControl,
                ulFlags: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        LockPayload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraControl,
                ppPayload: ?*?*u8,
                pulPayload: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraControl,
                ppPayload: ?*?*u8,
                pulPayload: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockPayload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraControl_GetCapabilities(self: *const T) u64 {
                return @as(*const IMFExtendedCameraControl.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IMFExtendedCameraControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraControl_SetFlags(self: *const T, ulFlags: u64) HRESULT {
                return @as(*const IMFExtendedCameraControl.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IMFExtendedCameraControl, @ptrCast(self)), ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraControl_GetFlags(self: *const T) u64 {
                return @as(*const IMFExtendedCameraControl.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMFExtendedCameraControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraControl_LockPayload(self: *const T, ppPayload: ?*?*u8, pulPayload: ?*u32) HRESULT {
                return @as(*const IMFExtendedCameraControl.VTable, @ptrCast(self.vtable)).LockPayload(@as(*const IMFExtendedCameraControl, @ptrCast(self)), ppPayload, pulPayload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraControl_UnlockPayload(self: *const T) HRESULT {
                return @as(*const IMFExtendedCameraControl.VTable, @ptrCast(self.vtable)).UnlockPayload(@as(*const IMFExtendedCameraControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraControl_CommitSettings(self: *const T) HRESULT {
                return @as(*const IMFExtendedCameraControl.VTable, @ptrCast(self.vtable)).CommitSettings(@as(*const IMFExtendedCameraControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraController_Value = Guid.initString("b91ebfee-ca03-4af4-8a82-a31752f4a0fc");
pub const IID_IMFExtendedCameraController = &IID_IMFExtendedCameraController_Value;
pub const IMFExtendedCameraController = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExtendedCameraControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedCameraController,
                dwStreamIndex: u32,
                ulPropertyId: u32,
                ppControl: ?*?*IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedCameraController,
                dwStreamIndex: u32,
                ulPropertyId: u32,
                ppControl: ?*?*IMFExtendedCameraControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedCameraController_GetExtendedCameraControl(self: *const T, dwStreamIndex: u32, ulPropertyId: u32, ppControl: ?*?*IMFExtendedCameraControl) HRESULT {
                return @as(*const IMFExtendedCameraController.VTable, @ptrCast(self.vtable)).GetExtendedCameraControl(@as(*const IMFExtendedCameraController, @ptrCast(self)), dwStreamIndex, ulPropertyId, ppControl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFRelativePanelReport_Value = Guid.initString("f25362ea-2c0e-447f-81e2-755914cdc0c3");
pub const IID_IMFRelativePanelReport = &IID_IMFRelativePanelReport_Value;
pub const IMFRelativePanelReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRelativePanel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRelativePanelReport,
                panel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRelativePanelReport,
                panel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRelativePanelReport_GetRelativePanel(self: *const T, panel: ?*u32) HRESULT {
                return @as(*const IMFRelativePanelReport.VTable, @ptrCast(self.vtable)).GetRelativePanel(@as(*const IMFRelativePanelReport, @ptrCast(self)), panel);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFRelativePanelWatcher_Value = Guid.initString("421af7f6-573e-4ad0-8fda-2e57cedb18c6");
pub const IID_IMFRelativePanelWatcher = &IID_IMFRelativePanelWatcher_Value;
pub const IMFRelativePanelWatcher = extern struct {
    pub const VTable = extern struct {
        base: IMFShutdown.VTable,
        BeginGetReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRelativePanelWatcher,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRelativePanelWatcher,
                pCallback: ?*IMFAsyncCallback,
                pState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndGetReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRelativePanelWatcher,
                pResult: ?*IMFAsyncResult,
                ppRelativePanelReport: ?*?*IMFRelativePanelReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRelativePanelWatcher,
                pResult: ?*IMFAsyncResult,
                ppRelativePanelReport: ?*?*IMFRelativePanelReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFRelativePanelWatcher,
                ppRelativePanelReport: ?*?*IMFRelativePanelReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFRelativePanelWatcher,
                ppRelativePanelReport: ?*?*IMFRelativePanelReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFShutdown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRelativePanelWatcher_BeginGetReport(self: *const T, pCallback: ?*IMFAsyncCallback, pState: ?*IUnknown) HRESULT {
                return @as(*const IMFRelativePanelWatcher.VTable, @ptrCast(self.vtable)).BeginGetReport(@as(*const IMFRelativePanelWatcher, @ptrCast(self)), pCallback, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRelativePanelWatcher_EndGetReport(self: *const T, pResult: ?*IMFAsyncResult, ppRelativePanelReport: ?*?*IMFRelativePanelReport) HRESULT {
                return @as(*const IMFRelativePanelWatcher.VTable, @ptrCast(self.vtable)).EndGetReport(@as(*const IMFRelativePanelWatcher, @ptrCast(self)), pResult, ppRelativePanelReport);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFRelativePanelWatcher_GetReport(self: *const T, ppRelativePanelReport: ?*?*IMFRelativePanelReport) HRESULT {
                return @as(*const IMFRelativePanelWatcher.VTable, @ptrCast(self.vtable)).GetReport(@as(*const IMFRelativePanelWatcher, @ptrCast(self)), ppRelativePanelReport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFCameraOcclusionState = enum(i32) {
    pen = 0,
    ccludedByLid = 1,
    ccludedByCameraHardware = 2,
};
pub const MFCameraOcclusionState_Open = MFCameraOcclusionState.pen;
pub const MFCameraOcclusionState_OccludedByLid = MFCameraOcclusionState.ccludedByLid;
pub const MFCameraOcclusionState_OccludedByCameraHardware = MFCameraOcclusionState.ccludedByCameraHardware;

const IID_IMFCameraOcclusionStateReport_Value = Guid.initString("1640b2cf-74da-4462-a43b-b76d3bdc1434");
pub const IID_IMFCameraOcclusionStateReport = &IID_IMFCameraOcclusionStateReport_Value;
pub const IMFCameraOcclusionStateReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOcclusionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraOcclusionStateReport,
                occlusionState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCameraOcclusionStateReport,
                occlusionState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraOcclusionStateReport_GetOcclusionState(self: *const T, occlusionState: ?*u32) HRESULT {
                return @as(*const IMFCameraOcclusionStateReport.VTable, @ptrCast(self.vtable)).GetOcclusionState(@as(*const IMFCameraOcclusionStateReport, @ptrCast(self)), occlusionState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCameraOcclusionStateReportCallback_Value = Guid.initString("6e5841c7-3889-4019-9035-783fb19b5948");
pub const IID_IMFCameraOcclusionStateReportCallback = &IID_IMFCameraOcclusionStateReportCallback_Value;
pub const IMFCameraOcclusionStateReportCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnOcclusionStateReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraOcclusionStateReportCallback,
                occlusionStateReport: ?*IMFCameraOcclusionStateReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCameraOcclusionStateReportCallback,
                occlusionStateReport: ?*IMFCameraOcclusionStateReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraOcclusionStateReportCallback_OnOcclusionStateReport(self: *const T, occlusionStateReport: ?*IMFCameraOcclusionStateReport) HRESULT {
                return @as(*const IMFCameraOcclusionStateReportCallback.VTable, @ptrCast(self.vtable)).OnOcclusionStateReport(@as(*const IMFCameraOcclusionStateReportCallback, @ptrCast(self)), occlusionStateReport);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCameraOcclusionStateMonitor_Value = Guid.initString("cc692f46-c697-47e2-a72d-7b064617749b");
pub const IID_IMFCameraOcclusionStateMonitor = &IID_IMFCameraOcclusionStateMonitor_Value;
pub const IMFCameraOcclusionStateMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraOcclusionStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCameraOcclusionStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraOcclusionStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCameraOcclusionStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedStates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraOcclusionStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFCameraOcclusionStateMonitor,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraOcclusionStateMonitor_Start(self: *const T) HRESULT {
                return @as(*const IMFCameraOcclusionStateMonitor.VTable, @ptrCast(self.vtable)).Start(@as(*const IMFCameraOcclusionStateMonitor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraOcclusionStateMonitor_Stop(self: *const T) HRESULT {
                return @as(*const IMFCameraOcclusionStateMonitor.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFCameraOcclusionStateMonitor, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraOcclusionStateMonitor_GetSupportedStates(self: *const T) u32 {
                return @as(*const IMFCameraOcclusionStateMonitor.VTable, @ptrCast(self.vtable)).GetSupportedStates(@as(*const IMFCameraOcclusionStateMonitor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFVideoCaptureSampleAllocator_Value = Guid.initString("725b77c7-ca9f-4fe5-9d72-9946bf9b3c70");
pub const IID_IMFVideoCaptureSampleAllocator = &IID_IMFVideoCaptureSampleAllocator_Value;
pub const IMFVideoCaptureSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoSampleAllocator.VTable,
        InitializeCaptureSampleAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoCaptureSampleAllocator,
                cbSampleSize: u32,
                cbCaptureMetadataSize: u32,
                cbAlignment: u32,
                cMinimumSamples: u32,
                pAttributes: ?*IMFAttributes,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoCaptureSampleAllocator,
                cbSampleSize: u32,
                cbCaptureMetadataSize: u32,
                cbAlignment: u32,
                cMinimumSamples: u32,
                pAttributes: ?*IMFAttributes,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFVideoSampleAllocator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoCaptureSampleAllocator_InitializeCaptureSampleAllocator(self: *const T, cbSampleSize: u32, cbCaptureMetadataSize: u32, cbAlignment: u32, cMinimumSamples: u32, pAttributes: ?*IMFAttributes, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFVideoCaptureSampleAllocator.VTable, @ptrCast(self.vtable)).InitializeCaptureSampleAllocator(@as(*const IMFVideoCaptureSampleAllocator, @ptrCast(self)), cbSampleSize, cbCaptureMetadataSize, cbAlignment, cMinimumSamples, pAttributes, pMediaType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFSampleAllocatorUsage = enum(i32) {
    UsesProvidedAllocator = 0,
    UsesCustomAllocator = 1,
    DoesNotAllocate = 2,
};
pub const MFSampleAllocatorUsage_UsesProvidedAllocator = MFSampleAllocatorUsage.UsesProvidedAllocator;
pub const MFSampleAllocatorUsage_UsesCustomAllocator = MFSampleAllocatorUsage.UsesCustomAllocator;
pub const MFSampleAllocatorUsage_DoesNotAllocate = MFSampleAllocatorUsage.DoesNotAllocate;

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFSampleAllocatorControl_Value = Guid.initString("da62b958-3a38-4a97-bd27-149c640c0771");
pub const IID_IMFSampleAllocatorControl = &IID_IMFSampleAllocatorControl_Value;
pub const IMFSampleAllocatorControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDefaultAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleAllocatorControl,
                dwOutputStreamID: u32,
                pAllocator: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleAllocatorControl,
                dwOutputStreamID: u32,
                pAllocator: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocatorUsage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSampleAllocatorControl,
                dwOutputStreamID: u32,
                pdwInputStreamID: ?*u32,
                peUsage: ?*MFSampleAllocatorUsage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSampleAllocatorControl,
                dwOutputStreamID: u32,
                pdwInputStreamID: ?*u32,
                peUsage: ?*MFSampleAllocatorUsage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleAllocatorControl_SetDefaultAllocator(self: *const T, dwOutputStreamID: u32, pAllocator: ?*IUnknown) HRESULT {
                return @as(*const IMFSampleAllocatorControl.VTable, @ptrCast(self.vtable)).SetDefaultAllocator(@as(*const IMFSampleAllocatorControl, @ptrCast(self)), dwOutputStreamID, pAllocator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSampleAllocatorControl_GetAllocatorUsage(self: *const T, dwOutputStreamID: u32, pdwInputStreamID: ?*u32, peUsage: ?*MFSampleAllocatorUsage) HRESULT {
                return @as(*const IMFSampleAllocatorControl.VTable, @ptrCast(self.vtable)).GetAllocatorUsage(@as(*const IMFSampleAllocatorControl, @ptrCast(self)), dwOutputStreamID, pdwInputStreamID, peUsage);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFContentInfo_Value = Guid.initString("b1dca5cd-d5da-4451-8e9e-db5c59914ead");
pub const IID_IMFASFContentInfo = &IID_IMFASFContentInfo_Value;
pub const IMFASFContentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHeaderSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                pIStartOfContent: ?*IMFMediaBuffer,
                cbHeaderSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                pIStartOfContent: ?*IMFMediaBuffer,
                cbHeaderSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                pIHeaderBuffer: ?*IMFMediaBuffer,
                cbOffsetWithinHeader: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                pIHeaderBuffer: ?*IMFMediaBuffer,
                cbOffsetWithinHeader: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                pIHeader: ?*IMFMediaBuffer,
                pcbHeader: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                pIHeader: ?*IMFMediaBuffer,
                pcbHeader: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                ppIProfile: ?*?*IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                ppIProfile: ?*?*IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                pIProfile: ?*IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                pIProfile: ?*IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GeneratePresentationDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                ppIPresentationDescriptor: ?*?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                ppIPresentationDescriptor: ?*?*IMFPresentationDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEncodingConfigurationPropertyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFContentInfo,
                wStreamNumber: u16,
                ppIStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFContentInfo,
                wStreamNumber: u16,
                ppIStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_GetHeaderSize(self: *const T, pIStartOfContent: ?*IMFMediaBuffer, cbHeaderSize: ?*u64) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).GetHeaderSize(@as(*const IMFASFContentInfo, @ptrCast(self)), pIStartOfContent, cbHeaderSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_ParseHeader(self: *const T, pIHeaderBuffer: ?*IMFMediaBuffer, cbOffsetWithinHeader: u64) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).ParseHeader(@as(*const IMFASFContentInfo, @ptrCast(self)), pIHeaderBuffer, cbOffsetWithinHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_GenerateHeader(self: *const T, pIHeader: ?*IMFMediaBuffer, pcbHeader: ?*u32) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).GenerateHeader(@as(*const IMFASFContentInfo, @ptrCast(self)), pIHeader, pcbHeader);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_GetProfile(self: *const T, ppIProfile: ?*?*IMFASFProfile) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).GetProfile(@as(*const IMFASFContentInfo, @ptrCast(self)), ppIProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_SetProfile(self: *const T, pIProfile: ?*IMFASFProfile) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).SetProfile(@as(*const IMFASFContentInfo, @ptrCast(self)), pIProfile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_GeneratePresentationDescriptor(self: *const T, ppIPresentationDescriptor: ?*?*IMFPresentationDescriptor) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).GeneratePresentationDescriptor(@as(*const IMFASFContentInfo, @ptrCast(self)), ppIPresentationDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFContentInfo_GetEncodingConfigurationPropertyStore(self: *const T, wStreamNumber: u16, ppIStore: ?*?*IPropertyStore) HRESULT {
                return @as(*const IMFASFContentInfo.VTable, @ptrCast(self.vtable)).GetEncodingConfigurationPropertyStore(@as(*const IMFASFContentInfo, @ptrCast(self)), wStreamNumber, ppIStore);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFProfile_Value = Guid.initString("d267bf6a-028b-4e0d-903d-43f0ef82d0d4");
pub const IID_IMFASFProfile = &IID_IMFASFProfile_Value;
pub const IMFASFProfile = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                dwStreamIndex: u32,
                pwStreamNumber: ?*u16,
                ppIStream: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                dwStreamIndex: u32,
                pwStreamNumber: ?*u16,
                ppIStream: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamByNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                wStreamNumber: u16,
                ppIStream: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                wStreamNumber: u16,
                ppIStream: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                pIStream: ?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                pIStream: ?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                pIMediaType: ?*IMFMediaType,
                ppIStream: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                pIMediaType: ?*IMFMediaType,
                ppIStream: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMutualExclusionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                pcMutexs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                pcMutexs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                dwMutexIndex: u32,
                ppIMutex: ?*?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                dwMutexIndex: u32,
                ppIMutex: ?*?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                pIMutex: ?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                pIMutex: ?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                dwMutexIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                dwMutexIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMutualExclusion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                ppIMutex: ?*?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                ppIMutex: ?*?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                pIStreamPrioritization: ?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                pIStreamPrioritization: ?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStreamPrioritization: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFProfile,
                ppIProfile: ?*?*IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFProfile,
                ppIProfile: ?*?*IMFASFProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_GetStreamCount(self: *const T, pcStreams: ?*u32) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFASFProfile, @ptrCast(self)), pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_GetStream(self: *const T, dwStreamIndex: u32, pwStreamNumber: ?*u16, ppIStream: ?*?*IMFASFStreamConfig) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IMFASFProfile, @ptrCast(self)), dwStreamIndex, pwStreamNumber, ppIStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_GetStreamByNumber(self: *const T, wStreamNumber: u16, ppIStream: ?*?*IMFASFStreamConfig) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).GetStreamByNumber(@as(*const IMFASFProfile, @ptrCast(self)), wStreamNumber, ppIStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_SetStream(self: *const T, pIStream: ?*IMFASFStreamConfig) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).SetStream(@as(*const IMFASFProfile, @ptrCast(self)), pIStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_RemoveStream(self: *const T, wStreamNumber: u16) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IMFASFProfile, @ptrCast(self)), wStreamNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_CreateStream(self: *const T, pIMediaType: ?*IMFMediaType, ppIStream: ?*?*IMFASFStreamConfig) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).CreateStream(@as(*const IMFASFProfile, @ptrCast(self)), pIMediaType, ppIStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_GetMutualExclusionCount(self: *const T, pcMutexs: ?*u32) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).GetMutualExclusionCount(@as(*const IMFASFProfile, @ptrCast(self)), pcMutexs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_GetMutualExclusion(self: *const T, dwMutexIndex: u32, ppIMutex: ?*?*IMFASFMutualExclusion) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).GetMutualExclusion(@as(*const IMFASFProfile, @ptrCast(self)), dwMutexIndex, ppIMutex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_AddMutualExclusion(self: *const T, pIMutex: ?*IMFASFMutualExclusion) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).AddMutualExclusion(@as(*const IMFASFProfile, @ptrCast(self)), pIMutex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_RemoveMutualExclusion(self: *const T, dwMutexIndex: u32) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).RemoveMutualExclusion(@as(*const IMFASFProfile, @ptrCast(self)), dwMutexIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_CreateMutualExclusion(self: *const T, ppIMutex: ?*?*IMFASFMutualExclusion) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).CreateMutualExclusion(@as(*const IMFASFProfile, @ptrCast(self)), ppIMutex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_GetStreamPrioritization(self: *const T, ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).GetStreamPrioritization(@as(*const IMFASFProfile, @ptrCast(self)), ppIStreamPrioritization);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_AddStreamPrioritization(self: *const T, pIStreamPrioritization: ?*IMFASFStreamPrioritization) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).AddStreamPrioritization(@as(*const IMFASFProfile, @ptrCast(self)), pIStreamPrioritization);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_RemoveStreamPrioritization(self: *const T) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).RemoveStreamPrioritization(@as(*const IMFASFProfile, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_CreateStreamPrioritization(self: *const T, ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).CreateStreamPrioritization(@as(*const IMFASFProfile, @ptrCast(self)), ppIStreamPrioritization);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFProfile_Clone(self: *const T, ppIProfile: ?*?*IMFASFProfile) HRESULT {
                return @as(*const IMFASFProfile.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMFASFProfile, @ptrCast(self)), ppIProfile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFStreamConfig_Value = Guid.initString("9e8ae8d2-dbbd-4200-9aca-06e6df484913");
pub const IID_IMFASFStreamConfig = &IID_IMFASFStreamConfig_Value;
pub const IMFASFStreamConfig = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                pguidStreamType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                pguidStreamType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) u16,
            else => *const fn (
                self: *const IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) u16,
        },
        SetStreamNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                wStreamNum: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                ppIMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                ppIMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                pIMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                pIMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPayloadExtensionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                pcPayloadExtensions: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                pcPayloadExtensions: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPayloadExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                wPayloadExtensionNumber: u16,
                pguidExtensionSystemID: ?*Guid,
                pcbExtensionDataSize: ?*u16,
                pbExtensionSystemInfo: ?*u8,
                pcbExtensionSystemInfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                wPayloadExtensionNumber: u16,
                pguidExtensionSystemID: ?*Guid,
                pcbExtensionDataSize: ?*u16,
                pbExtensionSystemInfo: ?*u8,
                pcbExtensionSystemInfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPayloadExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                guidExtensionSystemID: Guid,
                cbExtensionDataSize: u16,
                pbExtensionSystemInfo: [*:0]u8,
                cbExtensionSystemInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                guidExtensionSystemID: Guid,
                cbExtensionDataSize: u16,
                pbExtensionSystemInfo: [*:0]u8,
                cbExtensionSystemInfo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllPayloadExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamConfig,
                ppIStreamConfig: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamConfig,
                ppIStreamConfig: ?*?*IMFASFStreamConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_GetStreamType(self: *const T, pguidStreamType: ?*Guid) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamType(@as(*const IMFASFStreamConfig, @ptrCast(self)), pguidStreamType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_GetStreamNumber(self: *const T) u16 {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamNumber(@as(*const IMFASFStreamConfig, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_SetStreamNumber(self: *const T, wStreamNum: u16) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).SetStreamNumber(@as(*const IMFASFStreamConfig, @ptrCast(self)), wStreamNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_GetMediaType(self: *const T, ppIMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IMFASFStreamConfig, @ptrCast(self)), ppIMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_SetMediaType(self: *const T, pIMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IMFASFStreamConfig, @ptrCast(self)), pIMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_GetPayloadExtensionCount(self: *const T, pcPayloadExtensions: ?*u16) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).GetPayloadExtensionCount(@as(*const IMFASFStreamConfig, @ptrCast(self)), pcPayloadExtensions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_GetPayloadExtension(self: *const T, wPayloadExtensionNumber: u16, pguidExtensionSystemID: ?*Guid, pcbExtensionDataSize: ?*u16, pbExtensionSystemInfo: ?*u8, pcbExtensionSystemInfo: ?*u32) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).GetPayloadExtension(@as(*const IMFASFStreamConfig, @ptrCast(self)), wPayloadExtensionNumber, pguidExtensionSystemID, pcbExtensionDataSize, pbExtensionSystemInfo, pcbExtensionSystemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_AddPayloadExtension(self: *const T, guidExtensionSystemID: Guid, cbExtensionDataSize: u16, pbExtensionSystemInfo: [*:0]u8, cbExtensionSystemInfo: u32) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).AddPayloadExtension(@as(*const IMFASFStreamConfig, @ptrCast(self)), guidExtensionSystemID, cbExtensionDataSize, pbExtensionSystemInfo, cbExtensionSystemInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_RemoveAllPayloadExtensions(self: *const T) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).RemoveAllPayloadExtensions(@as(*const IMFASFStreamConfig, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamConfig_Clone(self: *const T, ppIStreamConfig: ?*?*IMFASFStreamConfig) HRESULT {
                return @as(*const IMFASFStreamConfig.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMFASFStreamConfig, @ptrCast(self)), ppIStreamConfig);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFMutualExclusion_Value = Guid.initString("12558291-e399-11d5-bc2a-00b0d0f3f4ab");
pub const IID_IMFASFMutualExclusion = &IID_IMFASFMutualExclusion_Value;
pub const IMFASFMutualExclusion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                pguidType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                guidType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                guidType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                pdwRecordCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                pdwRecordCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamsForRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
                pwStreamNumArray: ?*u16,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
                pwStreamNumArray: ?*u16,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStreamForRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStreamFromRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
                wStreamNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                dwRecordNumber: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                pdwRecordNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                pdwRecordNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMutualExclusion,
                ppIMutex: ?*?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMutualExclusion,
                ppIMutex: ?*?*IMFASFMutualExclusion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_GetType(self: *const T, pguidType: ?*Guid) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).GetType(@as(*const IMFASFMutualExclusion, @ptrCast(self)), pguidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_SetType(self: *const T, guidType: ?*const Guid) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).SetType(@as(*const IMFASFMutualExclusion, @ptrCast(self)), guidType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_GetRecordCount(self: *const T, pdwRecordCount: ?*u32) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).GetRecordCount(@as(*const IMFASFMutualExclusion, @ptrCast(self)), pdwRecordCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_GetStreamsForRecord(self: *const T, dwRecordNumber: u32, pwStreamNumArray: ?*u16, pcStreams: ?*u32) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).GetStreamsForRecord(@as(*const IMFASFMutualExclusion, @ptrCast(self)), dwRecordNumber, pwStreamNumArray, pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_AddStreamForRecord(self: *const T, dwRecordNumber: u32, wStreamNumber: u16) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).AddStreamForRecord(@as(*const IMFASFMutualExclusion, @ptrCast(self)), dwRecordNumber, wStreamNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_RemoveStreamFromRecord(self: *const T, dwRecordNumber: u32, wStreamNumber: u16) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).RemoveStreamFromRecord(@as(*const IMFASFMutualExclusion, @ptrCast(self)), dwRecordNumber, wStreamNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_RemoveRecord(self: *const T, dwRecordNumber: u32) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).RemoveRecord(@as(*const IMFASFMutualExclusion, @ptrCast(self)), dwRecordNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_AddRecord(self: *const T, pdwRecordNumber: ?*u32) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).AddRecord(@as(*const IMFASFMutualExclusion, @ptrCast(self)), pdwRecordNumber);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMutualExclusion_Clone(self: *const T, ppIMutex: ?*?*IMFASFMutualExclusion) HRESULT {
                return @as(*const IMFASFMutualExclusion.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMFASFMutualExclusion, @ptrCast(self)), ppIMutex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFStreamPrioritization_Value = Guid.initString("699bdc27-bbaf-49ff-8e38-9c39c9b5e088");
pub const IID_IMFASFStreamPrioritization = &IID_IMFASFStreamPrioritization_Value;
pub const IMFASFStreamPrioritization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamPrioritization,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamPrioritization,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamPrioritization,
                dwStreamIndex: u32,
                pwStreamNumber: ?*u16,
                pwStreamFlags: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamPrioritization,
                dwStreamIndex: u32,
                pwStreamNumber: ?*u16,
                pwStreamFlags: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamPrioritization,
                wStreamNumber: u16,
                wStreamFlags: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamPrioritization,
                wStreamNumber: u16,
                wStreamFlags: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamPrioritization,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamPrioritization,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamPrioritization,
                ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamPrioritization,
                ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamPrioritization_GetStreamCount(self: *const T, pdwStreamCount: ?*u32) HRESULT {
                return @as(*const IMFASFStreamPrioritization.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFASFStreamPrioritization, @ptrCast(self)), pdwStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamPrioritization_GetStream(self: *const T, dwStreamIndex: u32, pwStreamNumber: ?*u16, pwStreamFlags: ?*u16) HRESULT {
                return @as(*const IMFASFStreamPrioritization.VTable, @ptrCast(self.vtable)).GetStream(@as(*const IMFASFStreamPrioritization, @ptrCast(self)), dwStreamIndex, pwStreamNumber, pwStreamFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamPrioritization_AddStream(self: *const T, wStreamNumber: u16, wStreamFlags: u16) HRESULT {
                return @as(*const IMFASFStreamPrioritization.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IMFASFStreamPrioritization, @ptrCast(self)), wStreamNumber, wStreamFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamPrioritization_RemoveStream(self: *const T, dwStreamIndex: u32) HRESULT {
                return @as(*const IMFASFStreamPrioritization.VTable, @ptrCast(self.vtable)).RemoveStream(@as(*const IMFASFStreamPrioritization, @ptrCast(self)), dwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamPrioritization_Clone(self: *const T, ppIStreamPrioritization: ?*?*IMFASFStreamPrioritization) HRESULT {
                return @as(*const IMFASFStreamPrioritization.VTable, @ptrCast(self.vtable)).Clone(@as(*const IMFASFStreamPrioritization, @ptrCast(self)), ppIStreamPrioritization);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFASF_INDEXER_FLAGS = enum(i32) {
    WRITE_NEW_INDEX = 1,
    READ_FOR_REVERSEPLAYBACK = 2,
    WRITE_FOR_LIVEREAD = 4,
};
pub const MFASF_INDEXER_WRITE_NEW_INDEX = MFASF_INDEXER_FLAGS.WRITE_NEW_INDEX;
pub const MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK = MFASF_INDEXER_FLAGS.READ_FOR_REVERSEPLAYBACK;
pub const MFASF_INDEXER_WRITE_FOR_LIVEREAD = MFASF_INDEXER_FLAGS.WRITE_FOR_LIVEREAD;

pub const ASF_INDEX_IDENTIFIER = extern struct {
    guidIndexType: Guid,
    wStreamNumber: u16,
};

pub const ASF_INDEX_DESCRIPTOR = extern struct {
    Identifier: ASF_INDEX_IDENTIFIER,
    cPerEntryBytes: u16,
    szDescription: [32]u16,
    dwInterval: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFIndexer_Value = Guid.initString("53590f48-dc3b-4297-813f-787761ad7b3e");
pub const IID_IMFASFIndexer = &IID_IMFASFIndexer_Value;
pub const IMFASFIndexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pIContentInfo: ?*IMFASFContentInfo,
                pcbIndexOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pIContentInfo: ?*IMFASFContentInfo,
                pcbIndexOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndexByteStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                ppIByteStreams: ?*?*IMFByteStream,
                cByteStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                ppIByteStreams: ?*?*IMFByteStream,
                cByteStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByteStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pcByteStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pcByteStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pIndexIdentifier: ?*ASF_INDEX_IDENTIFIER,
                pfIsIndexed: ?*BOOL,
                pbIndexDescriptor: ?*u8,
                pcbIndexDescriptor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pIndexIdentifier: ?*ASF_INDEX_IDENTIFIER,
                pfIsIndexed: ?*BOOL,
                pbIndexDescriptor: ?*u8,
                pcbIndexDescriptor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndexStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pbIndexDescriptor: ?*u8,
                cbIndexDescriptor: u32,
                fGenerateIndex: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pbIndexDescriptor: ?*u8,
                cbIndexDescriptor: u32,
                fGenerateIndex: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSeekPositionForValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pvarValue: ?*const PROPVARIANT,
                pIndexIdentifier: ?*ASF_INDEX_IDENTIFIER,
                pcbOffsetWithinData: ?*u64,
                phnsApproxTime: ?*i64,
                pdwPayloadNumberOfStreamWithinPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pvarValue: ?*const PROPVARIANT,
                pIndexIdentifier: ?*ASF_INDEX_IDENTIFIER,
                pcbOffsetWithinData: ?*u64,
                phnsApproxTime: ?*i64,
                pdwPayloadNumberOfStreamWithinPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateIndexEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pIASFPacketSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pIASFPacketSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexWriteSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pcbIndexWriteSpace: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pcbIndexWriteSpace: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompletedIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFIndexer,
                pIIndexBuffer: ?*IMFMediaBuffer,
                cbOffsetWithinIndex: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFIndexer,
                pIIndexBuffer: ?*IMFMediaBuffer,
                cbOffsetWithinIndex: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_SetFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IMFASFIndexer, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMFASFIndexer, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_Initialize(self: *const T, pIContentInfo: ?*IMFASFContentInfo) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMFASFIndexer, @ptrCast(self)), pIContentInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetIndexPosition(self: *const T, pIContentInfo: ?*IMFASFContentInfo, pcbIndexOffset: ?*u64) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetIndexPosition(@as(*const IMFASFIndexer, @ptrCast(self)), pIContentInfo, pcbIndexOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_SetIndexByteStreams(self: *const T, ppIByteStreams: ?*?*IMFByteStream, cByteStreams: u32) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).SetIndexByteStreams(@as(*const IMFASFIndexer, @ptrCast(self)), ppIByteStreams, cByteStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetIndexByteStreamCount(self: *const T, pcByteStreams: ?*u32) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetIndexByteStreamCount(@as(*const IMFASFIndexer, @ptrCast(self)), pcByteStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetIndexStatus(self: *const T, pIndexIdentifier: ?*ASF_INDEX_IDENTIFIER, pfIsIndexed: ?*BOOL, pbIndexDescriptor: ?*u8, pcbIndexDescriptor: ?*u32) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetIndexStatus(@as(*const IMFASFIndexer, @ptrCast(self)), pIndexIdentifier, pfIsIndexed, pbIndexDescriptor, pcbIndexDescriptor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_SetIndexStatus(self: *const T, pbIndexDescriptor: ?*u8, cbIndexDescriptor: u32, fGenerateIndex: BOOL) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).SetIndexStatus(@as(*const IMFASFIndexer, @ptrCast(self)), pbIndexDescriptor, cbIndexDescriptor, fGenerateIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetSeekPositionForValue(self: *const T, pvarValue: ?*const PROPVARIANT, pIndexIdentifier: ?*ASF_INDEX_IDENTIFIER, pcbOffsetWithinData: ?*u64, phnsApproxTime: ?*i64, pdwPayloadNumberOfStreamWithinPacket: ?*u32) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetSeekPositionForValue(@as(*const IMFASFIndexer, @ptrCast(self)), pvarValue, pIndexIdentifier, pcbOffsetWithinData, phnsApproxTime, pdwPayloadNumberOfStreamWithinPacket);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GenerateIndexEntries(self: *const T, pIASFPacketSample: ?*IMFSample) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GenerateIndexEntries(@as(*const IMFASFIndexer, @ptrCast(self)), pIASFPacketSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_CommitIndex(self: *const T, pIContentInfo: ?*IMFASFContentInfo) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).CommitIndex(@as(*const IMFASFIndexer, @ptrCast(self)), pIContentInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetIndexWriteSpace(self: *const T, pcbIndexWriteSpace: ?*u64) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetIndexWriteSpace(@as(*const IMFASFIndexer, @ptrCast(self)), pcbIndexWriteSpace);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFIndexer_GetCompletedIndex(self: *const T, pIIndexBuffer: ?*IMFMediaBuffer, cbOffsetWithinIndex: u64) HRESULT {
                return @as(*const IMFASFIndexer.VTable, @ptrCast(self.vtable)).GetCompletedIndex(@as(*const IMFASFIndexer, @ptrCast(self)), pIIndexBuffer, cbOffsetWithinIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFSplitter_Value = Guid.initString("12558295-e399-11d5-bc2a-00b0d0f3f4ab");
pub const IID_IMFASFSplitter = &IID_IMFASFSplitter_Value;
pub const IMFASFSplitter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pwStreamNumbers: ?*u16,
                wNumStreams: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pwStreamNumbers: ?*u16,
                wNumStreams: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pwStreamNumbers: ?*u16,
                pwNumStreams: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pwStreamNumbers: ?*u16,
                pwNumStreams: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pIBuffer: ?*IMFMediaBuffer,
                cbBufferOffset: u32,
                cbLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pIBuffer: ?*IMFMediaBuffer,
                cbBufferOffset: u32,
                cbLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pdwStatusFlags: ?*ASF_STATUSFLAGS,
                pwStreamNumber: ?*u16,
                ppISample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pdwStatusFlags: ?*ASF_STATUSFLAGS,
                pwStreamNumber: ?*u16,
                ppISample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastSendTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFSplitter,
                pdwLastSendTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFSplitter,
                pdwLastSendTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_Initialize(self: *const T, pIContentInfo: ?*IMFASFContentInfo) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMFASFSplitter, @ptrCast(self)), pIContentInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_SetFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IMFASFSplitter, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_GetFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMFASFSplitter, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_SelectStreams(self: *const T, pwStreamNumbers: ?*u16, wNumStreams: u16) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).SelectStreams(@as(*const IMFASFSplitter, @ptrCast(self)), pwStreamNumbers, wNumStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_GetSelectedStreams(self: *const T, pwStreamNumbers: ?*u16, pwNumStreams: ?*u16) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).GetSelectedStreams(@as(*const IMFASFSplitter, @ptrCast(self)), pwStreamNumbers, pwNumStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_ParseData(self: *const T, pIBuffer: ?*IMFMediaBuffer, cbBufferOffset: u32, cbLength: u32) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).ParseData(@as(*const IMFASFSplitter, @ptrCast(self)), pIBuffer, cbBufferOffset, cbLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_GetNextSample(self: *const T, pdwStatusFlags: ?*ASF_STATUSFLAGS, pwStreamNumber: ?*u16, ppISample: ?*?*IMFSample) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).GetNextSample(@as(*const IMFASFSplitter, @ptrCast(self)), pdwStatusFlags, pwStreamNumber, ppISample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_Flush(self: *const T) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMFASFSplitter, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFSplitter_GetLastSendTime(self: *const T, pdwLastSendTime: ?*u32) HRESULT {
                return @as(*const IMFASFSplitter.VTable, @ptrCast(self.vtable)).GetLastSendTime(@as(*const IMFASFSplitter, @ptrCast(self)), pdwLastSendTime);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFASF_SPLITTERFLAGS = enum(i32) {
    REVERSE = 1,
    WMDRM = 2,
};
pub const MFASF_SPLITTER_REVERSE = MFASF_SPLITTERFLAGS.REVERSE;
pub const MFASF_SPLITTER_WMDRM = MFASF_SPLITTERFLAGS.WMDRM;

pub const ASF_STATUSFLAGS = enum(i32) {
    INCOMPLETE = 1,
    NONFATAL_ERROR = 2,
};
pub const ASF_STATUSFLAGS_INCOMPLETE = ASF_STATUSFLAGS.INCOMPLETE;
pub const ASF_STATUSFLAGS_NONFATAL_ERROR = ASF_STATUSFLAGS.NONFATAL_ERROR;

pub const MFASF_MULTIPLEXERFLAGS = enum(i32) {
    E = 1,
};
pub const MFASF_MULTIPLEXER_AUTOADJUST_BITRATE = MFASF_MULTIPLEXERFLAGS.E;

pub const ASF_MUX_STATISTICS = extern struct {
    cFramesWritten: u32,
    cFramesDropped: u32,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFMultiplexer_Value = Guid.initString("57bdd80a-9b38-4838-b737-c58f670d7d4f");
pub const IID_IMFASFMultiplexer = &IID_IMFASFMultiplexer_Value;
pub const IMFASFMultiplexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                wStreamNumber: u16,
                pISample: ?*IMFSample,
                hnsTimestampAdjust: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                wStreamNumber: u16,
                pISample: ?*IMFSample,
                hnsTimestampAdjust: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextPacket: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                pdwStatusFlags: ?*u32,
                ppIPacket: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                pdwStatusFlags: ?*u32,
                ppIPacket: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                pIContentInfo: ?*IMFASFContentInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                wStreamNumber: u16,
                pMuxStats: ?*ASF_MUX_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                wStreamNumber: u16,
                pMuxStats: ?*ASF_MUX_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncTolerance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFMultiplexer,
                msSyncTolerance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFMultiplexer,
                msSyncTolerance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_Initialize(self: *const T, pIContentInfo: ?*IMFASFContentInfo) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMFASFMultiplexer, @ptrCast(self)), pIContentInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_SetFlags(self: *const T, dwFlags: u32) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IMFASFMultiplexer, @ptrCast(self)), dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_GetFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMFASFMultiplexer, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_ProcessSample(self: *const T, wStreamNumber: u16, pISample: ?*IMFSample, hnsTimestampAdjust: i64) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).ProcessSample(@as(*const IMFASFMultiplexer, @ptrCast(self)), wStreamNumber, pISample, hnsTimestampAdjust);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_GetNextPacket(self: *const T, pdwStatusFlags: ?*u32, ppIPacket: ?*?*IMFSample) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).GetNextPacket(@as(*const IMFASFMultiplexer, @ptrCast(self)), pdwStatusFlags, ppIPacket);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_Flush(self: *const T) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMFASFMultiplexer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_End(self: *const T, pIContentInfo: ?*IMFASFContentInfo) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).End(@as(*const IMFASFMultiplexer, @ptrCast(self)), pIContentInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_GetStatistics(self: *const T, wStreamNumber: u16, pMuxStats: ?*ASF_MUX_STATISTICS) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).GetStatistics(@as(*const IMFASFMultiplexer, @ptrCast(self)), wStreamNumber, pMuxStats);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFMultiplexer_SetSyncTolerance(self: *const T, msSyncTolerance: u32) HRESULT {
                return @as(*const IMFASFMultiplexer.VTable, @ptrCast(self.vtable)).SetSyncTolerance(@as(*const IMFASFMultiplexer, @ptrCast(self)), msSyncTolerance);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFASF_STREAMSELECTOR_FLAGS = enum(i32) {
    DISABLE_THINNING = 1,
    USE_AVERAGE_BITRATE = 2,
};
pub const MFASF_STREAMSELECTOR_DISABLE_THINNING = MFASF_STREAMSELECTOR_FLAGS.DISABLE_THINNING;
pub const MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE = MFASF_STREAMSELECTOR_FLAGS.USE_AVERAGE_BITRATE;

pub const ASF_SELECTION_STATUS = enum(i32) {
    NOTSELECTED = 0,
    CLEANPOINTSONLY = 1,
    ALLDATAUNITS = 2,
};
pub const ASF_STATUS_NOTSELECTED = ASF_SELECTION_STATUS.NOTSELECTED;
pub const ASF_STATUS_CLEANPOINTSONLY = ASF_SELECTION_STATUS.CLEANPOINTSONLY;
pub const ASF_STATUS_ALLDATAUNITS = ASF_SELECTION_STATUS.ALLDATAUNITS;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFASFStreamSelector_Value = Guid.initString("d01bad4a-4fa0-4a60-9349-c27e62da9d41");
pub const IID_IMFASFStreamSelector = &IID_IMFASFStreamSelector_Value;
pub const IMFASFStreamSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                pcOutputs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputStreamNumbers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                rgwStreamNumbers: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                rgwStreamNumbers: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFromStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                wStreamNum: u16,
                pdwOutput: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                wStreamNum: u16,
                pdwOutput: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputOverride: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                pSelection: ?*ASF_SELECTION_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                pSelection: ?*ASF_SELECTION_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputOverride: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                Selection: ASF_SELECTION_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                Selection: ASF_SELECTION_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMutexCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                pcMutexes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                pcMutexes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMutex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                dwMutexNum: u32,
                ppMutex: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                dwMutexNum: u32,
                ppMutex: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMutexSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                dwMutexNum: u32,
                wSelectedRecord: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwOutputNum: u32,
                dwMutexNum: u32,
                wSelectedRecord: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidthStepCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                pcStepCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                pcStepCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidthStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwStepNum: u32,
                pdwBitrate: ?*u32,
                rgwStreamNumbers: ?*u16,
                rgSelections: ?*ASF_SELECTION_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwStepNum: u32,
                pdwBitrate: ?*u32,
                rgwStreamNumbers: ?*u16,
                rgSelections: ?*ASF_SELECTION_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BitrateToStepNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwBitrate: u32,
                pdwStepNum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwBitrate: u32,
                pdwStepNum: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamSelectorFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFASFStreamSelector,
                dwStreamSelectorFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFASFStreamSelector,
                dwStreamSelectorFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetStreamCount(self: *const T, pcStreams: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const IMFASFStreamSelector, @ptrCast(self)), pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputCount(self: *const T, pcOutputs: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputCount(@as(*const IMFASFStreamSelector, @ptrCast(self)), pcOutputs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputStreamCount(self: *const T, dwOutputNum: u32, pcStreams: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputStreamCount(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, pcStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputStreamNumbers(self: *const T, dwOutputNum: u32, rgwStreamNumbers: ?*u16) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputStreamNumbers(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, rgwStreamNumbers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputFromStream(self: *const T, wStreamNum: u16, pdwOutput: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputFromStream(@as(*const IMFASFStreamSelector, @ptrCast(self)), wStreamNum, pdwOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputOverride(self: *const T, dwOutputNum: u32, pSelection: ?*ASF_SELECTION_STATUS) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputOverride(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, pSelection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_SetOutputOverride(self: *const T, dwOutputNum: u32, Selection: ASF_SELECTION_STATUS) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).SetOutputOverride(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, Selection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputMutexCount(self: *const T, dwOutputNum: u32, pcMutexes: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputMutexCount(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, pcMutexes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetOutputMutex(self: *const T, dwOutputNum: u32, dwMutexNum: u32, ppMutex: ?*?*IUnknown) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetOutputMutex(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, dwMutexNum, ppMutex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_SetOutputMutexSelection(self: *const T, dwOutputNum: u32, dwMutexNum: u32, wSelectedRecord: u16) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).SetOutputMutexSelection(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwOutputNum, dwMutexNum, wSelectedRecord);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetBandwidthStepCount(self: *const T, pcStepCount: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetBandwidthStepCount(@as(*const IMFASFStreamSelector, @ptrCast(self)), pcStepCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_GetBandwidthStep(self: *const T, dwStepNum: u32, pdwBitrate: ?*u32, rgwStreamNumbers: ?*u16, rgSelections: ?*ASF_SELECTION_STATUS) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).GetBandwidthStep(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwStepNum, pdwBitrate, rgwStreamNumbers, rgSelections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_BitrateToStepNumber(self: *const T, dwBitrate: u32, pdwStepNum: ?*u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).BitrateToStepNumber(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwBitrate, pdwStepNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFASFStreamSelector_SetStreamSelectorFlags(self: *const T, dwStreamSelectorFlags: u32) HRESULT {
                return @as(*const IMFASFStreamSelector.VTable, @ptrCast(self.vtable)).SetStreamSelectorFlags(@as(*const IMFASFStreamSelector, @ptrCast(self)), dwStreamSelectorFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFSINK_WMDRMACTION = enum(i32) {
    UNDEFINED = 0,
    ENCODE = 1,
    TRANSCODE = 2,
    TRANSCRYPT = 3,
    // LAST = 3, this enum value conflicts with TRANSCRYPT
};
pub const MFSINK_WMDRMACTION_UNDEFINED = MFSINK_WMDRMACTION.UNDEFINED;
pub const MFSINK_WMDRMACTION_ENCODE = MFSINK_WMDRMACTION.ENCODE;
pub const MFSINK_WMDRMACTION_TRANSCODE = MFSINK_WMDRMACTION.TRANSCODE;
pub const MFSINK_WMDRMACTION_TRANSCRYPT = MFSINK_WMDRMACTION.TRANSCRYPT;
pub const MFSINK_WMDRMACTION_LAST = MFSINK_WMDRMACTION.TRANSCRYPT;

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFDRMNetHelper_Value = Guid.initString("3d1ff0ea-679a-4190-8d46-7fa69e8c7e15");
pub const IID_IMFDRMNetHelper = &IID_IMFDRMNetHelper_Value;
pub const IMFDRMNetHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProcessLicenseRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDRMNetHelper,
                pLicenseRequest: [*:0]u8,
                cbLicenseRequest: u32,
                ppLicenseResponse: [*]?*u8,
                pcbLicenseResponse: ?*u32,
                pbstrKID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDRMNetHelper,
                pLicenseRequest: [*:0]u8,
                cbLicenseRequest: u32,
                ppLicenseResponse: [*]?*u8,
                pcbLicenseResponse: ?*u32,
                pbstrKID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChainedLicenseResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDRMNetHelper,
                ppLicenseResponse: [*]?*u8,
                pcbLicenseResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDRMNetHelper,
                ppLicenseResponse: [*]?*u8,
                pcbLicenseResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDRMNetHelper_ProcessLicenseRequest(self: *const T, pLicenseRequest: [*:0]u8, cbLicenseRequest: u32, ppLicenseResponse: [*]?*u8, pcbLicenseResponse: ?*u32, pbstrKID: ?*?BSTR) HRESULT {
                return @as(*const IMFDRMNetHelper.VTable, @ptrCast(self.vtable)).ProcessLicenseRequest(@as(*const IMFDRMNetHelper, @ptrCast(self)), pLicenseRequest, cbLicenseRequest, ppLicenseResponse, pcbLicenseResponse, pbstrKID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDRMNetHelper_GetChainedLicenseResponse(self: *const T, ppLicenseResponse: [*]?*u8, pcbLicenseResponse: ?*u32) HRESULT {
                return @as(*const IMFDRMNetHelper.VTable, @ptrCast(self.vtable)).GetChainedLicenseResponse(@as(*const IMFDRMNetHelper, @ptrCast(self)), ppLicenseResponse, pcbLicenseResponse);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoNormalizedRect = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

pub const MF_CAPTURE_ENGINE_DEVICE_TYPE = enum(i32) {
    AUDIO = 0,
    VIDEO = 1,
};
pub const MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO = MF_CAPTURE_ENGINE_DEVICE_TYPE.AUDIO;
pub const MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO = MF_CAPTURE_ENGINE_DEVICE_TYPE.VIDEO;

pub const MF_CAPTURE_ENGINE_SINK_TYPE = enum(i32) {
    RECORD = 0,
    PREVIEW = 1,
    PHOTO = 2,
};
pub const MF_CAPTURE_ENGINE_SINK_TYPE_RECORD = MF_CAPTURE_ENGINE_SINK_TYPE.RECORD;
pub const MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW = MF_CAPTURE_ENGINE_SINK_TYPE.PREVIEW;
pub const MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO = MF_CAPTURE_ENGINE_SINK_TYPE.PHOTO;

pub const MF_CAPTURE_ENGINE_SOURCE = enum(u32) {
    PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW = 4294967290,
    PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD = 4294967289,
    PREFERRED_SOURCE_STREAM_FOR_PHOTO = 4294967288,
    PREFERRED_SOURCE_STREAM_FOR_AUDIO = 4294967287,
    PREFERRED_SOURCE_STREAM_FOR_METADATA = 4294967286,
    MEDIASOURCE = 4294967295,
};
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW = MF_CAPTURE_ENGINE_SOURCE.PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD = MF_CAPTURE_ENGINE_SOURCE.PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO = MF_CAPTURE_ENGINE_SOURCE.PREFERRED_SOURCE_STREAM_FOR_PHOTO;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO = MF_CAPTURE_ENGINE_SOURCE.PREFERRED_SOURCE_STREAM_FOR_AUDIO;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_METADATA = MF_CAPTURE_ENGINE_SOURCE.PREFERRED_SOURCE_STREAM_FOR_METADATA;
pub const MF_CAPTURE_ENGINE_MEDIASOURCE = MF_CAPTURE_ENGINE_SOURCE.MEDIASOURCE;

pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY = enum(i32) {
    VIDEO_PREVIEW = 0,
    VIDEO_CAPTURE = 1,
    PHOTO_INDEPENDENT = 2,
    PHOTO_DEPENDENT = 3,
    AUDIO = 4,
    UNSUPPORTED = 5,
    METADATA = 6,
};
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW = MF_CAPTURE_ENGINE_STREAM_CATEGORY.VIDEO_PREVIEW;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE = MF_CAPTURE_ENGINE_STREAM_CATEGORY.VIDEO_CAPTURE;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT = MF_CAPTURE_ENGINE_STREAM_CATEGORY.PHOTO_INDEPENDENT;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT = MF_CAPTURE_ENGINE_STREAM_CATEGORY.PHOTO_DEPENDENT;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO = MF_CAPTURE_ENGINE_STREAM_CATEGORY.AUDIO;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED = MF_CAPTURE_ENGINE_STREAM_CATEGORY.UNSUPPORTED;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_METADATA = MF_CAPTURE_ENGINE_STREAM_CATEGORY.METADATA;

pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = enum(i32) {
    OTHER = 0,
    COMMUNICATIONS = 1,
    MEDIA = 2,
    GAMECHAT = 3,
    SPEECH = 4,
    FARFIELDSPEECH = 5,
    UNIFORMSPEECH = 6,
    VOICETYPING = 7,
};
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.OTHER;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.COMMUNICATIONS;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.MEDIA;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.GAMECHAT;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.SPEECH;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_FARFIELDSPEECH = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.FARFIELDSPEECH;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_UNIFORMSPEECH = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.UNIFORMSPEECH;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_VOICETYPING = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.VOICETYPING;

pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE = enum(i32) {
    DEFAULT = 0,
    RAW = 1,
};
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT = MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE.DEFAULT;
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW = MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE.RAW;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureEngineOnEventCallback_Value = Guid.initString("aeda51c0-9025-4983-9012-de597b88b089");
pub const IID_IMFCaptureEngineOnEventCallback = &IID_IMFCaptureEngineOnEventCallback_Value;
pub const IMFCaptureEngineOnEventCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngineOnEventCallback,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngineOnEventCallback,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngineOnEventCallback_OnEvent(self: *const T, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFCaptureEngineOnEventCallback.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IMFCaptureEngineOnEventCallback, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureEngineOnSampleCallback_Value = Guid.initString("52150b82-ab39-4467-980f-e48bf0822ecd");
pub const IID_IMFCaptureEngineOnSampleCallback = &IID_IMFCaptureEngineOnSampleCallback_Value;
pub const IMFCaptureEngineOnSampleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngineOnSampleCallback,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngineOnSampleCallback,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngineOnSampleCallback_OnSample(self: *const T, pSample: ?*IMFSample) HRESULT {
                return @as(*const IMFCaptureEngineOnSampleCallback.VTable, @ptrCast(self.vtable)).OnSample(@as(*const IMFCaptureEngineOnSampleCallback, @ptrCast(self)), pSample);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureSink_Value = Guid.initString("72d6135b-35e9-412c-b926-fd5265f2a885");
pub const IID_IMFCaptureSink = &IID_IMFCaptureSink_Value;
pub const IMFCaptureSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOutputMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSink,
                dwSinkStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSink,
                dwSinkStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSink,
                dwSinkStreamIndex: u32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSink,
                dwSinkStreamIndex: u32,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSink,
                dwSourceStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
                pAttributes: ?*IMFAttributes,
                pdwSinkStreamIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSink,
                dwSourceStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
                pAttributes: ?*IMFAttributes,
                pdwSinkStreamIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Prepare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSink_GetOutputMediaType(self: *const T, dwSinkStreamIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFCaptureSink.VTable, @ptrCast(self.vtable)).GetOutputMediaType(@as(*const IMFCaptureSink, @ptrCast(self)), dwSinkStreamIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSink_GetService(self: *const T, dwSinkStreamIndex: u32, rguidService: ?*const Guid, riid: ?*const Guid, ppUnknown: ?*?*IUnknown) HRESULT {
                return @as(*const IMFCaptureSink.VTable, @ptrCast(self.vtable)).GetService(@as(*const IMFCaptureSink, @ptrCast(self)), dwSinkStreamIndex, rguidService, riid, ppUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSink_AddStream(self: *const T, dwSourceStreamIndex: u32, pMediaType: ?*IMFMediaType, pAttributes: ?*IMFAttributes, pdwSinkStreamIndex: ?*u32) HRESULT {
                return @as(*const IMFCaptureSink.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IMFCaptureSink, @ptrCast(self)), dwSourceStreamIndex, pMediaType, pAttributes, pdwSinkStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSink_Prepare(self: *const T) HRESULT {
                return @as(*const IMFCaptureSink.VTable, @ptrCast(self.vtable)).Prepare(@as(*const IMFCaptureSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSink_RemoveAllStreams(self: *const T) HRESULT {
                return @as(*const IMFCaptureSink.VTable, @ptrCast(self.vtable)).RemoveAllStreams(@as(*const IMFCaptureSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureRecordSink_Value = Guid.initString("3323b55a-f92a-4fe2-8edc-e9bfc0634d77");
pub const IID_IMFCaptureRecordSink = &IID_IMFCaptureRecordSink_Value;
pub const IMFCaptureRecordSink = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetOutputByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureRecordSink,
                pByteStream: ?*IMFByteStream,
                guidContainerType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureRecordSink,
                pByteStream: ?*IMFByteStream,
                guidContainerType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureRecordSink,
                fileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureRecordSink,
                fileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureRecordSink,
                dwStreamSinkIndex: u32,
                pCallback: ?*IMFCaptureEngineOnSampleCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureRecordSink,
                dwStreamSinkIndex: u32,
                pCallback: ?*IMFCaptureEngineOnSampleCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustomSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureRecordSink,
                pMediaSink: ?*IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureRecordSink,
                pMediaSink: ?*IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureRecordSink,
                dwStreamIndex: u32,
                pdwRotationValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureRecordSink,
                dwStreamIndex: u32,
                pdwRotationValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureRecordSink,
                dwStreamIndex: u32,
                dwRotationValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureRecordSink,
                dwStreamIndex: u32,
                dwRotationValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFCaptureSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureRecordSink_SetOutputByteStream(self: *const T, pByteStream: ?*IMFByteStream, guidContainerType: ?*const Guid) HRESULT {
                return @as(*const IMFCaptureRecordSink.VTable, @ptrCast(self.vtable)).SetOutputByteStream(@as(*const IMFCaptureRecordSink, @ptrCast(self)), pByteStream, guidContainerType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureRecordSink_SetOutputFileName(self: *const T, fileName: ?[*:0]const u16) HRESULT {
                return @as(*const IMFCaptureRecordSink.VTable, @ptrCast(self.vtable)).SetOutputFileName(@as(*const IMFCaptureRecordSink, @ptrCast(self)), fileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureRecordSink_SetSampleCallback(self: *const T, dwStreamSinkIndex: u32, pCallback: ?*IMFCaptureEngineOnSampleCallback) HRESULT {
                return @as(*const IMFCaptureRecordSink.VTable, @ptrCast(self.vtable)).SetSampleCallback(@as(*const IMFCaptureRecordSink, @ptrCast(self)), dwStreamSinkIndex, pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureRecordSink_SetCustomSink(self: *const T, pMediaSink: ?*IMFMediaSink) HRESULT {
                return @as(*const IMFCaptureRecordSink.VTable, @ptrCast(self.vtable)).SetCustomSink(@as(*const IMFCaptureRecordSink, @ptrCast(self)), pMediaSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureRecordSink_GetRotation(self: *const T, dwStreamIndex: u32, pdwRotationValue: ?*u32) HRESULT {
                return @as(*const IMFCaptureRecordSink.VTable, @ptrCast(self.vtable)).GetRotation(@as(*const IMFCaptureRecordSink, @ptrCast(self)), dwStreamIndex, pdwRotationValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureRecordSink_SetRotation(self: *const T, dwStreamIndex: u32, dwRotationValue: u32) HRESULT {
                return @as(*const IMFCaptureRecordSink.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const IMFCaptureRecordSink, @ptrCast(self)), dwStreamIndex, dwRotationValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCapturePreviewSink_Value = Guid.initString("77346cfd-5b49-4d73-ace0-5b52a859f2e0");
pub const IID_IMFCapturePreviewSink = &IID_IMFCapturePreviewSink_Value;
pub const IMFCapturePreviewSink = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetRenderHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                handle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                handle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                pSurface: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                pSurface: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                dwStreamSinkIndex: u32,
                pCallback: ?*IMFCaptureEngineOnSampleCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                dwStreamSinkIndex: u32,
                pCallback: ?*IMFCaptureEngineOnSampleCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMirrorState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                pfMirrorState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                pfMirrorState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMirrorState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                fMirrorState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                fMirrorState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                dwStreamIndex: u32,
                pdwRotationValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                dwStreamIndex: u32,
                pdwRotationValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                dwStreamIndex: u32,
                dwRotationValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                dwStreamIndex: u32,
                dwRotationValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustomSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePreviewSink,
                pMediaSink: ?*IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePreviewSink,
                pMediaSink: ?*IMFMediaSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFCaptureSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_SetRenderHandle(self: *const T, handle: ?HANDLE) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).SetRenderHandle(@as(*const IMFCapturePreviewSink, @ptrCast(self)), handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_SetRenderSurface(self: *const T, pSurface: ?*IUnknown) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).SetRenderSurface(@as(*const IMFCapturePreviewSink, @ptrCast(self)), pSurface);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_UpdateVideo(self: *const T, pSrc: ?*const MFVideoNormalizedRect, pDst: ?*const RECT, pBorderClr: ?*const u32) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).UpdateVideo(@as(*const IMFCapturePreviewSink, @ptrCast(self)), pSrc, pDst, pBorderClr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_SetSampleCallback(self: *const T, dwStreamSinkIndex: u32, pCallback: ?*IMFCaptureEngineOnSampleCallback) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).SetSampleCallback(@as(*const IMFCapturePreviewSink, @ptrCast(self)), dwStreamSinkIndex, pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_GetMirrorState(self: *const T, pfMirrorState: ?*BOOL) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).GetMirrorState(@as(*const IMFCapturePreviewSink, @ptrCast(self)), pfMirrorState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_SetMirrorState(self: *const T, fMirrorState: BOOL) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).SetMirrorState(@as(*const IMFCapturePreviewSink, @ptrCast(self)), fMirrorState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_GetRotation(self: *const T, dwStreamIndex: u32, pdwRotationValue: ?*u32) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).GetRotation(@as(*const IMFCapturePreviewSink, @ptrCast(self)), dwStreamIndex, pdwRotationValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_SetRotation(self: *const T, dwStreamIndex: u32, dwRotationValue: u32) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const IMFCapturePreviewSink, @ptrCast(self)), dwStreamIndex, dwRotationValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePreviewSink_SetCustomSink(self: *const T, pMediaSink: ?*IMFMediaSink) HRESULT {
                return @as(*const IMFCapturePreviewSink.VTable, @ptrCast(self.vtable)).SetCustomSink(@as(*const IMFCapturePreviewSink, @ptrCast(self)), pMediaSink);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCapturePhotoSink_Value = Guid.initString("d2d43cc8-48bb-4aa7-95db-10c06977e777");
pub const IID_IMFCapturePhotoSink = &IID_IMFCapturePhotoSink_Value;
pub const IMFCapturePhotoSink = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetOutputFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePhotoSink,
                fileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePhotoSink,
                fileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePhotoSink,
                pCallback: ?*IMFCaptureEngineOnSampleCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePhotoSink,
                pCallback: ?*IMFCaptureEngineOnSampleCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCapturePhotoSink,
                pByteStream: ?*IMFByteStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCapturePhotoSink,
                pByteStream: ?*IMFByteStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFCaptureSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePhotoSink_SetOutputFileName(self: *const T, fileName: ?[*:0]const u16) HRESULT {
                return @as(*const IMFCapturePhotoSink.VTable, @ptrCast(self.vtable)).SetOutputFileName(@as(*const IMFCapturePhotoSink, @ptrCast(self)), fileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePhotoSink_SetSampleCallback(self: *const T, pCallback: ?*IMFCaptureEngineOnSampleCallback) HRESULT {
                return @as(*const IMFCapturePhotoSink.VTable, @ptrCast(self.vtable)).SetSampleCallback(@as(*const IMFCapturePhotoSink, @ptrCast(self)), pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCapturePhotoSink_SetOutputByteStream(self: *const T, pByteStream: ?*IMFByteStream) HRESULT {
                return @as(*const IMFCapturePhotoSink.VTable, @ptrCast(self.vtable)).SetOutputByteStream(@as(*const IMFCapturePhotoSink, @ptrCast(self)), pByteStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureSource_Value = Guid.initString("439a42a8-0d2c-4505-be83-f79b2a05d5c4");
pub const IID_IMFCaptureSource = &IID_IMFCaptureSource_Value;
pub const IMFCaptureSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCaptureDeviceSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE,
                ppMediaSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE,
                ppMediaSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaptureDeviceActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE,
                ppActivate: ?*?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE,
                ppActivate: ?*?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                rguidService: ?*const Guid,
                riid: ?*const Guid,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableDeviceMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                dwMediaTypeIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                dwMediaTypeIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentDeviceMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentDeviceMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceStreamCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pStreamCategory: ?*MF_CAPTURE_ENGINE_STREAM_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwSourceStreamIndex: u32,
                pStreamCategory: ?*MF_CAPTURE_ENGINE_STREAM_CATEGORY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMirrorState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwStreamIndex: u32,
                pfMirrorState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwStreamIndex: u32,
                pfMirrorState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMirrorState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                dwStreamIndex: u32,
                fMirrorState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                dwStreamIndex: u32,
                fMirrorState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamIndexFromFriendlyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSource,
                uifriendlyName: u32,
                pdwActualStreamIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSource,
                uifriendlyName: u32,
                pdwActualStreamIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetCaptureDeviceSource(self: *const T, mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppMediaSource: ?*?*IMFMediaSource) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetCaptureDeviceSource(@as(*const IMFCaptureSource, @ptrCast(self)), mfCaptureEngineDeviceType, ppMediaSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetCaptureDeviceActivate(self: *const T, mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppActivate: ?*?*IMFActivate) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetCaptureDeviceActivate(@as(*const IMFCaptureSource, @ptrCast(self)), mfCaptureEngineDeviceType, ppActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetService(self: *const T, rguidService: ?*const Guid, riid: ?*const Guid, ppUnknown: ?*?*IUnknown) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetService(@as(*const IMFCaptureSource, @ptrCast(self)), rguidService, riid, ppUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_AddEffect(self: *const T, dwSourceStreamIndex: u32, pUnknown: ?*IUnknown) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).AddEffect(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex, pUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_RemoveEffect(self: *const T, dwSourceStreamIndex: u32, pUnknown: ?*IUnknown) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).RemoveEffect(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex, pUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_RemoveAllEffects(self: *const T, dwSourceStreamIndex: u32) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).RemoveAllEffects(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetAvailableDeviceMediaType(self: *const T, dwSourceStreamIndex: u32, dwMediaTypeIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetAvailableDeviceMediaType(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex, dwMediaTypeIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_SetCurrentDeviceMediaType(self: *const T, dwSourceStreamIndex: u32, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).SetCurrentDeviceMediaType(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex, pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetCurrentDeviceMediaType(self: *const T, dwSourceStreamIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetCurrentDeviceMediaType(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetDeviceStreamCount(self: *const T, pdwStreamCount: ?*u32) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetDeviceStreamCount(@as(*const IMFCaptureSource, @ptrCast(self)), pdwStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetDeviceStreamCategory(self: *const T, dwSourceStreamIndex: u32, pStreamCategory: ?*MF_CAPTURE_ENGINE_STREAM_CATEGORY) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetDeviceStreamCategory(@as(*const IMFCaptureSource, @ptrCast(self)), dwSourceStreamIndex, pStreamCategory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetMirrorState(self: *const T, dwStreamIndex: u32, pfMirrorState: ?*BOOL) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetMirrorState(@as(*const IMFCaptureSource, @ptrCast(self)), dwStreamIndex, pfMirrorState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_SetMirrorState(self: *const T, dwStreamIndex: u32, fMirrorState: BOOL) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).SetMirrorState(@as(*const IMFCaptureSource, @ptrCast(self)), dwStreamIndex, fMirrorState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSource_GetStreamIndexFromFriendlyName(self: *const T, uifriendlyName: u32, pdwActualStreamIndex: ?*u32) HRESULT {
                return @as(*const IMFCaptureSource.VTable, @ptrCast(self.vtable)).GetStreamIndexFromFriendlyName(@as(*const IMFCaptureSource, @ptrCast(self)), uifriendlyName, pdwActualStreamIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureEngine_Value = Guid.initString("a6bba433-176b-48b2-b375-53aa03473207");
pub const IID_IMFCaptureEngine = &IID_IMFCaptureEngine_Value;
pub const IMFCaptureEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
                pEventCallback: ?*IMFCaptureEngineOnEventCallback,
                pAttributes: ?*IMFAttributes,
                pAudioSource: ?*IUnknown,
                pVideoSource: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
                pEventCallback: ?*IMFCaptureEngineOnEventCallback,
                pAttributes: ?*IMFAttributes,
                pAudioSource: ?*IUnknown,
                pVideoSource: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartPreview: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopPreview: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopRecord: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
                bFinalize: BOOL,
                bFlushUnprocessedSamples: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
                bFinalize: BOOL,
                bFlushUnprocessedSamples: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TakePhoto: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
                mfCaptureEngineSinkType: MF_CAPTURE_ENGINE_SINK_TYPE,
                ppSink: ?*?*IMFCaptureSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
                mfCaptureEngineSinkType: MF_CAPTURE_ENGINE_SINK_TYPE,
                ppSink: ?*?*IMFCaptureSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngine,
                ppSource: ?*?*IMFCaptureSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngine,
                ppSource: ?*?*IMFCaptureSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_Initialize(self: *const T, pEventCallback: ?*IMFCaptureEngineOnEventCallback, pAttributes: ?*IMFAttributes, pAudioSource: ?*IUnknown, pVideoSource: ?*IUnknown) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMFCaptureEngine, @ptrCast(self)), pEventCallback, pAttributes, pAudioSource, pVideoSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_StartPreview(self: *const T) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).StartPreview(@as(*const IMFCaptureEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_StopPreview(self: *const T) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).StopPreview(@as(*const IMFCaptureEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_StartRecord(self: *const T) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).StartRecord(@as(*const IMFCaptureEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_StopRecord(self: *const T, bFinalize: BOOL, bFlushUnprocessedSamples: BOOL) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).StopRecord(@as(*const IMFCaptureEngine, @ptrCast(self)), bFinalize, bFlushUnprocessedSamples);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_TakePhoto(self: *const T) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).TakePhoto(@as(*const IMFCaptureEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_GetSink(self: *const T, mfCaptureEngineSinkType: MF_CAPTURE_ENGINE_SINK_TYPE, ppSink: ?*?*IMFCaptureSink) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).GetSink(@as(*const IMFCaptureEngine, @ptrCast(self)), mfCaptureEngineSinkType, ppSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngine_GetSource(self: *const T, ppSource: ?*?*IMFCaptureSource) HRESULT {
                return @as(*const IMFCaptureEngine.VTable, @ptrCast(self.vtable)).GetSource(@as(*const IMFCaptureEngine, @ptrCast(self)), ppSource);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFCaptureEngineClassFactory_Value = Guid.initString("8f02d140-56fc-4302-a705-3a97c78be779");
pub const IID_IMFCaptureEngineClassFactory = &IID_IMFCaptureEngineClassFactory_Value;
pub const IMFCaptureEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngineClassFactory,
                clsid: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngineClassFactory,
                clsid: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngineClassFactory_CreateInstance(self: *const T, clsid: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFCaptureEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IMFCaptureEngineClassFactory, @ptrCast(self)), clsid, riid, ppvObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFCaptureEngineOnSampleCallback2_Value = Guid.initString("e37ceed7-340f-4514-9f4d-9c2ae026100b");
pub const IID_IMFCaptureEngineOnSampleCallback2 = &IID_IMFCaptureEngineOnSampleCallback2_Value;
pub const IMFCaptureEngineOnSampleCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureEngineOnSampleCallback.VTable,
        OnSynchronizedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureEngineOnSampleCallback2,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureEngineOnSampleCallback2,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFCaptureEngineOnSampleCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureEngineOnSampleCallback2_OnSynchronizedEvent(self: *const T, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFCaptureEngineOnSampleCallback2.VTable, @ptrCast(self.vtable)).OnSynchronizedEvent(@as(*const IMFCaptureEngineOnSampleCallback2, @ptrCast(self)), pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFCaptureSink2_Value = Guid.initString("f9e4219e-6197-4b5e-b888-bee310ab2c59");
pub const IID_IMFCaptureSink2 = &IID_IMFCaptureSink2_Value;
pub const IMFCaptureSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetOutputMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCaptureSink2,
                dwStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
                pEncodingAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCaptureSink2,
                dwStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
                pEncodingAttributes: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFCaptureSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCaptureSink2_SetOutputMediaType(self: *const T, dwStreamIndex: u32, pMediaType: ?*IMFMediaType, pEncodingAttributes: ?*IMFAttributes) HRESULT {
                return @as(*const IMFCaptureSink2.VTable, @ptrCast(self.vtable)).SetOutputMediaType(@as(*const IMFCaptureSink2, @ptrCast(self)), dwStreamIndex, pMediaType, pEncodingAttributes);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFD3D12SynchronizationObjectCommands_Value = Guid.initString("09d0f835-92ff-4e53-8efa-40faa551f233");
pub const IID_IMFD3D12SynchronizationObjectCommands = &IID_IMFD3D12SynchronizationObjectCommands_Value;
pub const IMFD3D12SynchronizationObjectCommands = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnqueueResourceReady: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                pProducerCommandQueue: ?*ID3D12CommandQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                pProducerCommandQueue: ?*ID3D12CommandQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnqueueResourceReadyWait: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                pConsumerCommandQueue: ?*ID3D12CommandQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                pConsumerCommandQueue: ?*ID3D12CommandQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SignalEventOnResourceReady: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnqueueResourceRelease: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                pConsumerCommandQueue: ?*ID3D12CommandQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFD3D12SynchronizationObjectCommands,
                pConsumerCommandQueue: ?*ID3D12CommandQueue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFD3D12SynchronizationObjectCommands_EnqueueResourceReady(self: *const T, pProducerCommandQueue: ?*ID3D12CommandQueue) HRESULT {
                return @as(*const IMFD3D12SynchronizationObjectCommands.VTable, @ptrCast(self.vtable)).EnqueueResourceReady(@as(*const IMFD3D12SynchronizationObjectCommands, @ptrCast(self)), pProducerCommandQueue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFD3D12SynchronizationObjectCommands_EnqueueResourceReadyWait(self: *const T, pConsumerCommandQueue: ?*ID3D12CommandQueue) HRESULT {
                return @as(*const IMFD3D12SynchronizationObjectCommands.VTable, @ptrCast(self.vtable)).EnqueueResourceReadyWait(@as(*const IMFD3D12SynchronizationObjectCommands, @ptrCast(self)), pConsumerCommandQueue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFD3D12SynchronizationObjectCommands_SignalEventOnResourceReady(self: *const T, hEvent: ?HANDLE) HRESULT {
                return @as(*const IMFD3D12SynchronizationObjectCommands.VTable, @ptrCast(self.vtable)).SignalEventOnResourceReady(@as(*const IMFD3D12SynchronizationObjectCommands, @ptrCast(self)), hEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFD3D12SynchronizationObjectCommands_EnqueueResourceRelease(self: *const T, pConsumerCommandQueue: ?*ID3D12CommandQueue) HRESULT {
                return @as(*const IMFD3D12SynchronizationObjectCommands.VTable, @ptrCast(self.vtable)).EnqueueResourceRelease(@as(*const IMFD3D12SynchronizationObjectCommands, @ptrCast(self)), pConsumerCommandQueue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFD3D12SynchronizationObject_Value = Guid.initString("802302b0-82de-45e1-b421-f19ee5bdaf23");
pub const IID_IMFD3D12SynchronizationObject = &IID_IMFD3D12SynchronizationObject_Value;
pub const IMFD3D12SynchronizationObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SignalEventOnFinalResourceRelease: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFD3D12SynchronizationObject,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFD3D12SynchronizationObject,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFD3D12SynchronizationObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFD3D12SynchronizationObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFD3D12SynchronizationObject_SignalEventOnFinalResourceRelease(self: *const T, hEvent: ?HANDLE) HRESULT {
                return @as(*const IMFD3D12SynchronizationObject.VTable, @ptrCast(self.vtable)).SignalEventOnFinalResourceRelease(@as(*const IMFD3D12SynchronizationObject, @ptrCast(self)), hEvent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFD3D12SynchronizationObject_Reset(self: *const T) HRESULT {
                return @as(*const IMFD3D12SynchronizationObject.VTable, @ptrCast(self.vtable)).Reset(@as(*const IMFD3D12SynchronizationObject, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MT_D3D_RESOURCE_VERSION_ENUM = enum(i32) {
    @"1_RESOURCE" = 0,
    @"2_RESOURCE" = 1,
};
pub const MF_D3D11_RESOURCE = MF_MT_D3D_RESOURCE_VERSION_ENUM.@"1_RESOURCE";
pub const MF_D3D12_RESOURCE = MF_MT_D3D_RESOURCE_VERSION_ENUM.@"2_RESOURCE";

pub const MFPERIODICCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pContext: ?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        pContext: ?*IUnknown,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const MFASYNC_WORKQUEUE_TYPE = enum(i32) {
    STANDARD_WORKQUEUE = 0,
    WINDOW_WORKQUEUE = 1,
    MULTITHREADED_WORKQUEUE = 2,
};
pub const MF_STANDARD_WORKQUEUE = MFASYNC_WORKQUEUE_TYPE.STANDARD_WORKQUEUE;
pub const MF_WINDOW_WORKQUEUE = MFASYNC_WORKQUEUE_TYPE.WINDOW_WORKQUEUE;
pub const MF_MULTITHREADED_WORKQUEUE = MFASYNC_WORKQUEUE_TYPE.MULTITHREADED_WORKQUEUE;

pub const MFASYNCRESULT = extern struct {
    pub const VTable = extern struct {
        base: IMFAsyncResult.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAsyncResult.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TOPOSTATUS = enum(i32) {
    INVALID = 0,
    READY = 100,
    STARTED_SOURCE = 200,
    DYNAMIC_CHANGED = 210,
    SINK_SWITCHED = 300,
    ENDED = 400,
};
pub const MF_TOPOSTATUS_INVALID = MF_TOPOSTATUS.INVALID;
pub const MF_TOPOSTATUS_READY = MF_TOPOSTATUS.READY;
pub const MF_TOPOSTATUS_STARTED_SOURCE = MF_TOPOSTATUS.STARTED_SOURCE;
pub const MF_TOPOSTATUS_DYNAMIC_CHANGED = MF_TOPOSTATUS.DYNAMIC_CHANGED;
pub const MF_TOPOSTATUS_SINK_SWITCHED = MF_TOPOSTATUS.SINK_SWITCHED;
pub const MF_TOPOSTATUS_ENDED = MF_TOPOSTATUS.ENDED;

pub const MFSampleEncryptionProtectionScheme = enum(i32) {
    NONE = 0,
    AES_CTR = 1,
    AES_CBC = 2,
};
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE = MFSampleEncryptionProtectionScheme.NONE;
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR = MFSampleEncryptionProtectionScheme.AES_CTR;
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC = MFSampleEncryptionProtectionScheme.AES_CBC;

pub const MOVE_RECT = extern struct {
    SourcePoint: POINT,
    DestRect: RECT,
};

pub const DIRTYRECT_INFO = extern struct {
    FrameNumber: u32,
    NumDirtyRects: u32,
    DirtyRects: [1]RECT,
};

pub const MOVEREGION_INFO = extern struct {
    FrameNumber: u32,
    NumMoveRegions: u32,
    MoveRegions: [1]MOVE_RECT,
};

pub const ROI_AREA = extern struct {
    rect: RECT,
    QPDelta: i32,
};

pub const MACROBLOCK_DATA = extern struct {
    flags: u32,
    motionVectorX: i16,
    motionVectorY: i16,
    QPDelta: i32,
};

pub const DigitalWindowSetting = extern struct {
    OriginX: f64,
    OriginY: f64,
    WindowSize: f64,
};

pub const _MFT_ENUM_FLAG = enum(i32) {
    SYNCMFT = 1,
    ASYNCMFT = 2,
    HARDWARE = 4,
    FIELDOFUSE = 8,
    LOCALMFT = 16,
    TRANSCODE_ONLY = 32,
    SORTANDFILTER = 64,
    SORTANDFILTER_APPROVED_ONLY = 192,
    SORTANDFILTER_WEB_ONLY = 320,
    SORTANDFILTER_WEB_ONLY_EDGEMODE = 576,
    UNTRUSTED_STOREMFT = 1024,
    ALL = 63,
};
pub const MFT_ENUM_FLAG_SYNCMFT = _MFT_ENUM_FLAG.SYNCMFT;
pub const MFT_ENUM_FLAG_ASYNCMFT = _MFT_ENUM_FLAG.ASYNCMFT;
pub const MFT_ENUM_FLAG_HARDWARE = _MFT_ENUM_FLAG.HARDWARE;
pub const MFT_ENUM_FLAG_FIELDOFUSE = _MFT_ENUM_FLAG.FIELDOFUSE;
pub const MFT_ENUM_FLAG_LOCALMFT = _MFT_ENUM_FLAG.LOCALMFT;
pub const MFT_ENUM_FLAG_TRANSCODE_ONLY = _MFT_ENUM_FLAG.TRANSCODE_ONLY;
pub const MFT_ENUM_FLAG_SORTANDFILTER = _MFT_ENUM_FLAG.SORTANDFILTER;
pub const MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY = _MFT_ENUM_FLAG.SORTANDFILTER_APPROVED_ONLY;
pub const MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY = _MFT_ENUM_FLAG.SORTANDFILTER_WEB_ONLY;
pub const MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE = _MFT_ENUM_FLAG.SORTANDFILTER_WEB_ONLY_EDGEMODE;
pub const MFT_ENUM_FLAG_UNTRUSTED_STOREMFT = _MFT_ENUM_FLAG.UNTRUSTED_STOREMFT;
pub const MFT_ENUM_FLAG_ALL = _MFT_ENUM_FLAG.ALL;

pub const MFFrameSourceTypes = enum(i32) {
    Color = 1,
    Infrared = 2,
    Depth = 4,
    Image = 8,
    Custom = 128,
};
pub const MFFrameSourceTypes_Color = MFFrameSourceTypes.Color;
pub const MFFrameSourceTypes_Infrared = MFFrameSourceTypes.Infrared;
pub const MFFrameSourceTypes_Depth = MFFrameSourceTypes.Depth;
pub const MFFrameSourceTypes_Image = MFFrameSourceTypes.Image;
pub const MFFrameSourceTypes_Custom = MFFrameSourceTypes.Custom;

pub const MFVideo3DFormat = enum(i32) {
    BaseView = 0,
    MultiView = 1,
    Packed_LeftRight = 2,
    Packed_TopBottom = 3,
};
pub const MFVideo3DSampleFormat_BaseView = MFVideo3DFormat.BaseView;
pub const MFVideo3DSampleFormat_MultiView = MFVideo3DFormat.MultiView;
pub const MFVideo3DSampleFormat_Packed_LeftRight = MFVideo3DFormat.Packed_LeftRight;
pub const MFVideo3DSampleFormat_Packed_TopBottom = MFVideo3DFormat.Packed_TopBottom;

pub const MFVideo3DSampleFormat = enum(i32) {
    MultiView = 1,
    Packed = 0,
};
pub const MFSampleExtension_3DVideo_MultiView = MFVideo3DSampleFormat.MultiView;
pub const MFSampleExtension_3DVideo_Packed = MFVideo3DSampleFormat.Packed;

pub const MFVideoRotationFormat = enum(i32) {
    @"0" = 0,
    @"90" = 90,
    @"180" = 180,
    @"270" = 270,
};
pub const MFVideoRotationFormat_0 = MFVideoRotationFormat.@"0";
pub const MFVideoRotationFormat_90 = MFVideoRotationFormat.@"90";
pub const MFVideoRotationFormat_180 = MFVideoRotationFormat.@"180";
pub const MFVideoRotationFormat_270 = MFVideoRotationFormat.@"270";

pub const MFDepthMeasurement = enum(i32) {
    FocalPlane = 0,
    OpticalCenter = 1,
};
pub const DistanceToFocalPlane = MFDepthMeasurement.FocalPlane;
pub const DistanceToOpticalCenter = MFDepthMeasurement.OpticalCenter;

pub const MF_CUSTOM_DECODE_UNIT_TYPE = enum(i32) {
    NAL = 0,
    SEI = 1,
};
pub const MF_DECODE_UNIT_NAL = MF_CUSTOM_DECODE_UNIT_TYPE.NAL;
pub const MF_DECODE_UNIT_SEI = MF_CUSTOM_DECODE_UNIT_TYPE.SEI;

pub const MFFOLDDOWN_MATRIX = extern struct {
    cbSize: u32,
    cSrcChannels: u32,
    cDstChannels: u32,
    dwChannelMask: u32,
    Coeff: [64]i32,
};

pub const MFVideoDRMFlags = enum(i32) {
    None = 0,
    AnalogProtected = 1,
    DigitallyProtected = 2,
};
pub const MFVideoDRMFlag_None = MFVideoDRMFlags.None;
pub const MFVideoDRMFlag_AnalogProtected = MFVideoDRMFlags.AnalogProtected;
pub const MFVideoDRMFlag_DigitallyProtected = MFVideoDRMFlags.DigitallyProtected;

pub const MFVideoPadFlags = enum(i32) {
    None = 0,
    @"4x3" = 1,
    @"16x9" = 2,
};
pub const MFVideoPadFlag_PAD_TO_None = MFVideoPadFlags.None;
pub const MFVideoPadFlag_PAD_TO_4x3 = MFVideoPadFlags.@"4x3";
pub const MFVideoPadFlag_PAD_TO_16x9 = MFVideoPadFlags.@"16x9";

pub const MFVideoSrcContentHintFlags = enum(i32) {
    None = 0,
    @"16x9" = 1,
    @"235_1" = 2,
};
pub const MFVideoSrcContentHintFlag_None = MFVideoSrcContentHintFlags.None;
pub const MFVideoSrcContentHintFlag_16x9 = MFVideoSrcContentHintFlags.@"16x9";
pub const MFVideoSrcContentHintFlag_235_1 = MFVideoSrcContentHintFlags.@"235_1";

pub const MT_CUSTOM_VIDEO_PRIMARIES = extern struct {
    fRx: f32,
    fRy: f32,
    fGx: f32,
    fGy: f32,
    fBx: f32,
    fBy: f32,
    fWx: f32,
    fWy: f32,
};

pub const MT_ARBITRARY_HEADER = extern struct {
    majortype: Guid,
    subtype: Guid,
    bFixedSizeSamples: BOOL,
    bTemporalCompression: BOOL,
    lSampleSize: u32,
    formattype: Guid,
};

pub const MF_FLOAT2 = extern struct {
    x: f32,
    y: f32,
};

pub const MF_FLOAT3 = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const MF_QUATERNION = extern struct {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
};

pub const MFCameraExtrinsic_CalibratedTransform = extern struct {
    CalibrationId: Guid,
    Position: MF_FLOAT3,
    Orientation: MF_QUATERNION,
};

pub const MFCameraExtrinsics = extern struct {
    TransformCount: u32,
    CalibratedTransforms: [1]MFCameraExtrinsic_CalibratedTransform,
};

pub const MFCameraIntrinsic_PinholeCameraModel = extern struct {
    FocalLength: MF_FLOAT2,
    PrincipalPoint: MF_FLOAT2,
};

pub const MFCameraIntrinsic_DistortionModel = extern struct {
    Radial_k1: f32,
    Radial_k2: f32,
    Radial_k3: f32,
    Tangential_p1: f32,
    Tangential_p2: f32,
};

pub const MFPinholeCameraIntrinsic_IntrinsicModel = extern struct {
    Width: u32,
    Height: u32,
    CameraModel: MFCameraIntrinsic_PinholeCameraModel,
    DistortionModel: MFCameraIntrinsic_DistortionModel,
};

pub const MFPinholeCameraIntrinsics = extern struct {
    IntrinsicModelCount: u32,
    IntrinsicModels: [1]MFPinholeCameraIntrinsic_IntrinsicModel,
};

pub const MFWaveFormatExConvertFlags = enum(i32) {
    Normal = 0,
    ForceExtensible = 1,
};
pub const MFWaveFormatExConvertFlag_Normal = MFWaveFormatExConvertFlags.Normal;
pub const MFWaveFormatExConvertFlag_ForceExtensible = MFWaveFormatExConvertFlags.ForceExtensible;

pub const EAllocationType = enum(i32) {
    Dynamic = 0,
    RT = 1,
    Pageable = 2,
    Ignore = 3,
};
pub const eAllocationTypeDynamic = EAllocationType.Dynamic;
pub const eAllocationTypeRT = EAllocationType.RT;
pub const eAllocationTypePageable = EAllocationType.Pageable;
pub const eAllocationTypeIgnore = EAllocationType.Ignore;

pub const MF_MEDIA_ENGINE_ERR = enum(i32) {
    NOERROR = 0,
    ABORTED = 1,
    NETWORK = 2,
    DECODE = 3,
    SRC_NOT_SUPPORTED = 4,
    ENCRYPTED = 5,
};
pub const MF_MEDIA_ENGINE_ERR_NOERROR = MF_MEDIA_ENGINE_ERR.NOERROR;
pub const MF_MEDIA_ENGINE_ERR_ABORTED = MF_MEDIA_ENGINE_ERR.ABORTED;
pub const MF_MEDIA_ENGINE_ERR_NETWORK = MF_MEDIA_ENGINE_ERR.NETWORK;
pub const MF_MEDIA_ENGINE_ERR_DECODE = MF_MEDIA_ENGINE_ERR.DECODE;
pub const MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED = MF_MEDIA_ENGINE_ERR.SRC_NOT_SUPPORTED;
pub const MF_MEDIA_ENGINE_ERR_ENCRYPTED = MF_MEDIA_ENGINE_ERR.ENCRYPTED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaError_Value = Guid.initString("fc0e10d2-ab2a-4501-a951-06bb1075184c");
pub const IID_IMFMediaError = &IID_IMFMediaError_Value;
pub const IMFMediaError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) u16,
            else => *const fn (
                self: *const IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) u16,
        },
        GetExtendedErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaError,
                @"error": MF_MEDIA_ENGINE_ERR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaError,
                @"error": MF_MEDIA_ENGINE_ERR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExtendedErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaError,
                @"error": HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaError,
                @"error": HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaError_GetErrorCode(self: *const T) u16 {
                return @as(*const IMFMediaError.VTable, @ptrCast(self.vtable)).GetErrorCode(@as(*const IMFMediaError, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaError_GetExtendedErrorCode(self: *const T) HRESULT {
                return @as(*const IMFMediaError.VTable, @ptrCast(self.vtable)).GetExtendedErrorCode(@as(*const IMFMediaError, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaError_SetErrorCode(self: *const T, @"error": MF_MEDIA_ENGINE_ERR) HRESULT {
                return @as(*const IMFMediaError.VTable, @ptrCast(self.vtable)).SetErrorCode(@as(*const IMFMediaError, @ptrCast(self)), @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaError_SetExtendedErrorCode(self: *const T, @"error": HRESULT) HRESULT {
                return @as(*const IMFMediaError.VTable, @ptrCast(self.vtable)).SetExtendedErrorCode(@as(*const IMFMediaError, @ptrCast(self)), @"error");
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaTimeRange_Value = Guid.initString("db71a2fc-078a-414e-9df9-8c2531b0aa6c");
pub const IID_IMFMediaTimeRange = &IID_IMFMediaTimeRange_Value;
pub const IMFMediaTimeRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTimeRange,
                index: u32,
                pStart: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTimeRange,
                index: u32,
                pStart: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTimeRange,
                index: u32,
                pEnd: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTimeRange,
                index: u32,
                pEnd: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContainsTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTimeRange,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaTimeRange,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        AddRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTimeRange,
                startTime: f64,
                endTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTimeRange,
                startTime: f64,
                endTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTimeRange_GetLength(self: *const T) u32 {
                return @as(*const IMFMediaTimeRange.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMFMediaTimeRange, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTimeRange_GetStart(self: *const T, index: u32, pStart: ?*f64) HRESULT {
                return @as(*const IMFMediaTimeRange.VTable, @ptrCast(self.vtable)).GetStart(@as(*const IMFMediaTimeRange, @ptrCast(self)), index, pStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTimeRange_GetEnd(self: *const T, index: u32, pEnd: ?*f64) HRESULT {
                return @as(*const IMFMediaTimeRange.VTable, @ptrCast(self.vtable)).GetEnd(@as(*const IMFMediaTimeRange, @ptrCast(self)), index, pEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTimeRange_ContainsTime(self: *const T, time: f64) BOOL {
                return @as(*const IMFMediaTimeRange.VTable, @ptrCast(self.vtable)).ContainsTime(@as(*const IMFMediaTimeRange, @ptrCast(self)), time);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTimeRange_AddRange(self: *const T, startTime: f64, endTime: f64) HRESULT {
                return @as(*const IMFMediaTimeRange.VTable, @ptrCast(self.vtable)).AddRange(@as(*const IMFMediaTimeRange, @ptrCast(self)), startTime, endTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaTimeRange_Clear(self: *const T) HRESULT {
                return @as(*const IMFMediaTimeRange.VTable, @ptrCast(self.vtable)).Clear(@as(*const IMFMediaTimeRange, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_EVENT = enum(i32) {
    LOADSTART = 1,
    PROGRESS = 2,
    SUSPEND = 3,
    ABORT = 4,
    ERROR = 5,
    EMPTIED = 6,
    STALLED = 7,
    PLAY = 8,
    PAUSE = 9,
    LOADEDMETADATA = 10,
    LOADEDDATA = 11,
    WAITING = 12,
    PLAYING = 13,
    CANPLAY = 14,
    CANPLAYTHROUGH = 15,
    SEEKING = 16,
    SEEKED = 17,
    TIMEUPDATE = 18,
    ENDED = 19,
    RATECHANGE = 20,
    DURATIONCHANGE = 21,
    VOLUMECHANGE = 22,
    FORMATCHANGE = 1000,
    PURGEQUEUEDEVENTS = 1001,
    TIMELINE_MARKER = 1002,
    BALANCECHANGE = 1003,
    DOWNLOADCOMPLETE = 1004,
    BUFFERINGSTARTED = 1005,
    BUFFERINGENDED = 1006,
    FRAMESTEPCOMPLETED = 1007,
    NOTIFYSTABLESTATE = 1008,
    FIRSTFRAMEREADY = 1009,
    TRACKSCHANGE = 1010,
    OPMINFO = 1011,
    RESOURCELOST = 1012,
    DELAYLOADEVENT_CHANGED = 1013,
    STREAMRENDERINGERROR = 1014,
    SUPPORTEDRATES_CHANGED = 1015,
    AUDIOENDPOINTCHANGE = 1016,
};
pub const MF_MEDIA_ENGINE_EVENT_LOADSTART = MF_MEDIA_ENGINE_EVENT.LOADSTART;
pub const MF_MEDIA_ENGINE_EVENT_PROGRESS = MF_MEDIA_ENGINE_EVENT.PROGRESS;
pub const MF_MEDIA_ENGINE_EVENT_SUSPEND = MF_MEDIA_ENGINE_EVENT.SUSPEND;
pub const MF_MEDIA_ENGINE_EVENT_ABORT = MF_MEDIA_ENGINE_EVENT.ABORT;
pub const MF_MEDIA_ENGINE_EVENT_ERROR = MF_MEDIA_ENGINE_EVENT.ERROR;
pub const MF_MEDIA_ENGINE_EVENT_EMPTIED = MF_MEDIA_ENGINE_EVENT.EMPTIED;
pub const MF_MEDIA_ENGINE_EVENT_STALLED = MF_MEDIA_ENGINE_EVENT.STALLED;
pub const MF_MEDIA_ENGINE_EVENT_PLAY = MF_MEDIA_ENGINE_EVENT.PLAY;
pub const MF_MEDIA_ENGINE_EVENT_PAUSE = MF_MEDIA_ENGINE_EVENT.PAUSE;
pub const MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA = MF_MEDIA_ENGINE_EVENT.LOADEDMETADATA;
pub const MF_MEDIA_ENGINE_EVENT_LOADEDDATA = MF_MEDIA_ENGINE_EVENT.LOADEDDATA;
pub const MF_MEDIA_ENGINE_EVENT_WAITING = MF_MEDIA_ENGINE_EVENT.WAITING;
pub const MF_MEDIA_ENGINE_EVENT_PLAYING = MF_MEDIA_ENGINE_EVENT.PLAYING;
pub const MF_MEDIA_ENGINE_EVENT_CANPLAY = MF_MEDIA_ENGINE_EVENT.CANPLAY;
pub const MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH = MF_MEDIA_ENGINE_EVENT.CANPLAYTHROUGH;
pub const MF_MEDIA_ENGINE_EVENT_SEEKING = MF_MEDIA_ENGINE_EVENT.SEEKING;
pub const MF_MEDIA_ENGINE_EVENT_SEEKED = MF_MEDIA_ENGINE_EVENT.SEEKED;
pub const MF_MEDIA_ENGINE_EVENT_TIMEUPDATE = MF_MEDIA_ENGINE_EVENT.TIMEUPDATE;
pub const MF_MEDIA_ENGINE_EVENT_ENDED = MF_MEDIA_ENGINE_EVENT.ENDED;
pub const MF_MEDIA_ENGINE_EVENT_RATECHANGE = MF_MEDIA_ENGINE_EVENT.RATECHANGE;
pub const MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE = MF_MEDIA_ENGINE_EVENT.DURATIONCHANGE;
pub const MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE = MF_MEDIA_ENGINE_EVENT.VOLUMECHANGE;
pub const MF_MEDIA_ENGINE_EVENT_FORMATCHANGE = MF_MEDIA_ENGINE_EVENT.FORMATCHANGE;
pub const MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS = MF_MEDIA_ENGINE_EVENT.PURGEQUEUEDEVENTS;
pub const MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER = MF_MEDIA_ENGINE_EVENT.TIMELINE_MARKER;
pub const MF_MEDIA_ENGINE_EVENT_BALANCECHANGE = MF_MEDIA_ENGINE_EVENT.BALANCECHANGE;
pub const MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE = MF_MEDIA_ENGINE_EVENT.DOWNLOADCOMPLETE;
pub const MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED = MF_MEDIA_ENGINE_EVENT.BUFFERINGSTARTED;
pub const MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED = MF_MEDIA_ENGINE_EVENT.BUFFERINGENDED;
pub const MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED = MF_MEDIA_ENGINE_EVENT.FRAMESTEPCOMPLETED;
pub const MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE = MF_MEDIA_ENGINE_EVENT.NOTIFYSTABLESTATE;
pub const MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY = MF_MEDIA_ENGINE_EVENT.FIRSTFRAMEREADY;
pub const MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE = MF_MEDIA_ENGINE_EVENT.TRACKSCHANGE;
pub const MF_MEDIA_ENGINE_EVENT_OPMINFO = MF_MEDIA_ENGINE_EVENT.OPMINFO;
pub const MF_MEDIA_ENGINE_EVENT_RESOURCELOST = MF_MEDIA_ENGINE_EVENT.RESOURCELOST;
pub const MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED = MF_MEDIA_ENGINE_EVENT.DELAYLOADEVENT_CHANGED;
pub const MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR = MF_MEDIA_ENGINE_EVENT.STREAMRENDERINGERROR;
pub const MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED = MF_MEDIA_ENGINE_EVENT.SUPPORTEDRATES_CHANGED;
pub const MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE = MF_MEDIA_ENGINE_EVENT.AUDIOENDPOINTCHANGE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngineNotify_Value = Guid.initString("fee7c112-e776-42b5-9bbf-0048524e2bd5");
pub const IID_IMFMediaEngineNotify = &IID_IMFMediaEngineNotify_Value;
pub const IMFMediaEngineNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EventNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineNotify,
                event: u32,
                param1: usize,
                param2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineNotify,
                event: u32,
                param1: usize,
                param2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineNotify_EventNotify(self: *const T, event: u32, param1: usize, param2: u32) HRESULT {
                return @as(*const IMFMediaEngineNotify.VTable, @ptrCast(self.vtable)).EventNotify(@as(*const IMFMediaEngineNotify, @ptrCast(self)), event, param1, param2);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngineSrcElements_Value = Guid.initString("7a5e5354-b114-4c72-b991-3131d75032ea");
pub const IID_IMFMediaEngineSrcElements = &IID_IMFMediaEngineSrcElements_Value;
pub const IMFMediaEngineSrcElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElements,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFMediaEngineSrcElements,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElements,
                index: u32,
                pURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElements,
                index: u32,
                pURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElements,
                index: u32,
                pType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElements,
                index: u32,
                pType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElements,
                index: u32,
                pMedia: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElements,
                index: u32,
                pMedia: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElements,
                pURL: ?BSTR,
                pType: ?BSTR,
                pMedia: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElements,
                pURL: ?BSTR,
                pType: ?BSTR,
                pMedia: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElements_GetLength(self: *const T) u32 {
                return @as(*const IMFMediaEngineSrcElements.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMFMediaEngineSrcElements, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElements_GetURL(self: *const T, index: u32, pURL: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaEngineSrcElements.VTable, @ptrCast(self.vtable)).GetURL(@as(*const IMFMediaEngineSrcElements, @ptrCast(self)), index, pURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElements_GetType(self: *const T, index: u32, pType: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaEngineSrcElements.VTable, @ptrCast(self.vtable)).GetType(@as(*const IMFMediaEngineSrcElements, @ptrCast(self)), index, pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElements_GetMedia(self: *const T, index: u32, pMedia: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaEngineSrcElements.VTable, @ptrCast(self.vtable)).GetMedia(@as(*const IMFMediaEngineSrcElements, @ptrCast(self)), index, pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElements_AddElement(self: *const T, pURL: ?BSTR, pType: ?BSTR, pMedia: ?BSTR) HRESULT {
                return @as(*const IMFMediaEngineSrcElements.VTable, @ptrCast(self.vtable)).AddElement(@as(*const IMFMediaEngineSrcElements, @ptrCast(self)), pURL, pType, pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElements_RemoveAllElements(self: *const T) HRESULT {
                return @as(*const IMFMediaEngineSrcElements.VTable, @ptrCast(self.vtable)).RemoveAllElements(@as(*const IMFMediaEngineSrcElements, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_NETWORK = enum(i32) {
    EMPTY = 0,
    IDLE = 1,
    LOADING = 2,
    NO_SOURCE = 3,
};
pub const MF_MEDIA_ENGINE_NETWORK_EMPTY = MF_MEDIA_ENGINE_NETWORK.EMPTY;
pub const MF_MEDIA_ENGINE_NETWORK_IDLE = MF_MEDIA_ENGINE_NETWORK.IDLE;
pub const MF_MEDIA_ENGINE_NETWORK_LOADING = MF_MEDIA_ENGINE_NETWORK.LOADING;
pub const MF_MEDIA_ENGINE_NETWORK_NO_SOURCE = MF_MEDIA_ENGINE_NETWORK.NO_SOURCE;

pub const MF_MEDIA_ENGINE_READY = enum(i32) {
    NOTHING = 0,
    METADATA = 1,
    CURRENT_DATA = 2,
    FUTURE_DATA = 3,
    ENOUGH_DATA = 4,
};
pub const MF_MEDIA_ENGINE_READY_HAVE_NOTHING = MF_MEDIA_ENGINE_READY.NOTHING;
pub const MF_MEDIA_ENGINE_READY_HAVE_METADATA = MF_MEDIA_ENGINE_READY.METADATA;
pub const MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA = MF_MEDIA_ENGINE_READY.CURRENT_DATA;
pub const MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA = MF_MEDIA_ENGINE_READY.FUTURE_DATA;
pub const MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA = MF_MEDIA_ENGINE_READY.ENOUGH_DATA;

pub const MF_MEDIA_ENGINE_CANPLAY = enum(i32) {
    NOT_SUPPORTED = 0,
    MAYBE = 1,
    PROBABLY = 2,
};
pub const MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED = MF_MEDIA_ENGINE_CANPLAY.NOT_SUPPORTED;
pub const MF_MEDIA_ENGINE_CANPLAY_MAYBE = MF_MEDIA_ENGINE_CANPLAY.MAYBE;
pub const MF_MEDIA_ENGINE_CANPLAY_PROBABLY = MF_MEDIA_ENGINE_CANPLAY.PROBABLY;

pub const MF_MEDIA_ENGINE_PRELOAD = enum(i32) {
    MISSING = 0,
    EMPTY = 1,
    NONE = 2,
    METADATA = 3,
    AUTOMATIC = 4,
};
pub const MF_MEDIA_ENGINE_PRELOAD_MISSING = MF_MEDIA_ENGINE_PRELOAD.MISSING;
pub const MF_MEDIA_ENGINE_PRELOAD_EMPTY = MF_MEDIA_ENGINE_PRELOAD.EMPTY;
pub const MF_MEDIA_ENGINE_PRELOAD_NONE = MF_MEDIA_ENGINE_PRELOAD.NONE;
pub const MF_MEDIA_ENGINE_PRELOAD_METADATA = MF_MEDIA_ENGINE_PRELOAD.METADATA;
pub const MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC = MF_MEDIA_ENGINE_PRELOAD.AUTOMATIC;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngine_Value = Guid.initString("98a1b0bb-03eb-4935-ae7c-93c1fa0e1c93");
pub const IID_IMFMediaEngine = &IID_IMFMediaEngine_Value;
pub const IMFMediaEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                ppError: ?*?*IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                ppError: ?*?*IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                @"error": MF_MEDIA_ENGINE_ERR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                @"error": MF_MEDIA_ENGINE_ERR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourceElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                pSrcElements: ?*IMFMediaEngineSrcElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                pSrcElements: ?*IMFMediaEngineSrcElements,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                pUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                pUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                ppUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                ppUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) u16,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) u16,
        },
        GetPreload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) MF_MEDIA_ENGINE_PRELOAD,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) MF_MEDIA_ENGINE_PRELOAD,
        },
        SetPreload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                Preload: MF_MEDIA_ENGINE_PRELOAD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                Preload: MF_MEDIA_ENGINE_PRELOAD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffered: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                ppBuffered: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                ppBuffered: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanPlayType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                type: ?BSTR,
                pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                type: ?BSTR,
                pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReadyState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) u16,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) u16,
        },
        IsSeeking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetCurrentTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetCurrentTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                seekTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                seekTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        IsPaused: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetDefaultPlaybackRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetDefaultPlaybackRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                Rate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                Rate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlaybackRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetPlaybackRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                Rate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                Rate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                ppPlayed: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                ppPlayed: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSeekable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                ppSeekable: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                ppSeekable: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEnded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetAutoPlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetAutoPlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                AutoPlay: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                AutoPlay: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLoop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetLoop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                Loop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                Loop: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Play: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMuted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        SetMuted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                Muted: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                Muted: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                Volume: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                Volume: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        HasAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetNativeVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                cx: ?*u32,
                cy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                cx: ?*u32,
                cy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoAspectRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                cx: ?*u32,
                cy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                cx: ?*u32,
                cy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransferVideoFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                pDstSurf: ?*IUnknown,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                pDstSurf: ?*IUnknown,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnVideoStreamTick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngine,
                pPts: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngine,
                pPts: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetError(self: *const T, ppError: ?*?*IMFMediaError) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetError(@as(*const IMFMediaEngine, @ptrCast(self)), ppError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetErrorCode(self: *const T, @"error": MF_MEDIA_ENGINE_ERR) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetErrorCode(@as(*const IMFMediaEngine, @ptrCast(self)), @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetSourceElements(self: *const T, pSrcElements: ?*IMFMediaEngineSrcElements) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetSourceElements(@as(*const IMFMediaEngine, @ptrCast(self)), pSrcElements);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetSource(self: *const T, pUrl: ?BSTR) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetSource(@as(*const IMFMediaEngine, @ptrCast(self)), pUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetCurrentSource(self: *const T, ppUrl: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetCurrentSource(@as(*const IMFMediaEngine, @ptrCast(self)), ppUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetNetworkState(self: *const T) u16 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetNetworkState(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetPreload(self: *const T) MF_MEDIA_ENGINE_PRELOAD {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetPreload(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetPreload(self: *const T, Preload: MF_MEDIA_ENGINE_PRELOAD) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetPreload(@as(*const IMFMediaEngine, @ptrCast(self)), Preload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetBuffered(self: *const T, ppBuffered: ?*?*IMFMediaTimeRange) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetBuffered(@as(*const IMFMediaEngine, @ptrCast(self)), ppBuffered);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_Load(self: *const T) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).Load(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_CanPlayType(self: *const T, type_: ?BSTR, pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).CanPlayType(@as(*const IMFMediaEngine, @ptrCast(self)), type_, pAnswer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetReadyState(self: *const T) u16 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetReadyState(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_IsSeeking(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).IsSeeking(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetCurrentTime(self: *const T) f64 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetCurrentTime(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetCurrentTime(self: *const T, seekTime: f64) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetCurrentTime(@as(*const IMFMediaEngine, @ptrCast(self)), seekTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetStartTime(self: *const T) f64 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetDuration(self: *const T) f64 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_IsPaused(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).IsPaused(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetDefaultPlaybackRate(self: *const T) f64 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetDefaultPlaybackRate(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetDefaultPlaybackRate(self: *const T, Rate: f64) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetDefaultPlaybackRate(@as(*const IMFMediaEngine, @ptrCast(self)), Rate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetPlaybackRate(self: *const T) f64 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetPlaybackRate(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetPlaybackRate(self: *const T, Rate: f64) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetPlaybackRate(@as(*const IMFMediaEngine, @ptrCast(self)), Rate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetPlayed(self: *const T, ppPlayed: ?*?*IMFMediaTimeRange) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetPlayed(@as(*const IMFMediaEngine, @ptrCast(self)), ppPlayed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetSeekable(self: *const T, ppSeekable: ?*?*IMFMediaTimeRange) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetSeekable(@as(*const IMFMediaEngine, @ptrCast(self)), ppSeekable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_IsEnded(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).IsEnded(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetAutoPlay(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetAutoPlay(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetAutoPlay(self: *const T, AutoPlay: BOOL) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetAutoPlay(@as(*const IMFMediaEngine, @ptrCast(self)), AutoPlay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetLoop(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetLoop(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetLoop(self: *const T, Loop: BOOL) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetLoop(@as(*const IMFMediaEngine, @ptrCast(self)), Loop);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_Play(self: *const T) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).Play(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_Pause(self: *const T) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetMuted(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetMuted(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetMuted(self: *const T, Muted: BOOL) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetMuted(@as(*const IMFMediaEngine, @ptrCast(self)), Muted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetVolume(self: *const T) f64 {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetVolume(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_SetVolume(self: *const T, Volume: f64) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const IMFMediaEngine, @ptrCast(self)), Volume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_HasVideo(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).HasVideo(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_HasAudio(self: *const T) BOOL {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).HasAudio(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetNativeVideoSize(self: *const T, cx: ?*u32, cy: ?*u32) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IMFMediaEngine, @ptrCast(self)), cx, cy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_GetVideoAspectRatio(self: *const T, cx: ?*u32, cy: ?*u32) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).GetVideoAspectRatio(@as(*const IMFMediaEngine, @ptrCast(self)), cx, cy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaEngine, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_TransferVideoFrame(self: *const T, pDstSurf: ?*IUnknown, pSrc: ?*const MFVideoNormalizedRect, pDst: ?*const RECT, pBorderClr: ?*const MFARGB) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).TransferVideoFrame(@as(*const IMFMediaEngine, @ptrCast(self)), pDstSurf, pSrc, pDst, pBorderClr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngine_OnVideoStreamTick(self: *const T, pPts: ?*i64) HRESULT {
                return @as(*const IMFMediaEngine.VTable, @ptrCast(self.vtable)).OnVideoStreamTick(@as(*const IMFMediaEngine, @ptrCast(self)), pPts);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE = enum(i32) {
    NONE = 0,
    SIDE_BY_SIDE = 1,
    TOP_BOTTOM = 2,
};
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE = MF_MEDIA_ENGINE_S3D_PACKING_MODE.NONE;
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE = MF_MEDIA_ENGINE_S3D_PACKING_MODE.SIDE_BY_SIDE;
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM = MF_MEDIA_ENGINE_S3D_PACKING_MODE.TOP_BOTTOM;

pub const MF_MEDIA_ENGINE_STATISTIC = enum(i32) {
    FRAMES_RENDERED = 0,
    FRAMES_DROPPED = 1,
    BYTES_DOWNLOADED = 2,
    BUFFER_PROGRESS = 3,
    FRAMES_PER_SECOND = 4,
    PLAYBACK_JITTER = 5,
    FRAMES_CORRUPTED = 6,
    TOTAL_FRAME_DELAY = 7,
};
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED = MF_MEDIA_ENGINE_STATISTIC.FRAMES_RENDERED;
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED = MF_MEDIA_ENGINE_STATISTIC.FRAMES_DROPPED;
pub const MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED = MF_MEDIA_ENGINE_STATISTIC.BYTES_DOWNLOADED;
pub const MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS = MF_MEDIA_ENGINE_STATISTIC.BUFFER_PROGRESS;
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND = MF_MEDIA_ENGINE_STATISTIC.FRAMES_PER_SECOND;
pub const MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER = MF_MEDIA_ENGINE_STATISTIC.PLAYBACK_JITTER;
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED = MF_MEDIA_ENGINE_STATISTIC.FRAMES_CORRUPTED;
pub const MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY = MF_MEDIA_ENGINE_STATISTIC.TOTAL_FRAME_DELAY;

pub const MF_MEDIA_ENGINE_SEEK_MODE = enum(i32) {
    NORMAL = 0,
    APPROXIMATE = 1,
};
pub const MF_MEDIA_ENGINE_SEEK_MODE_NORMAL = MF_MEDIA_ENGINE_SEEK_MODE.NORMAL;
pub const MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE = MF_MEDIA_ENGINE_SEEK_MODE.APPROXIMATE;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngineEx_Value = Guid.initString("83015ead-b1e6-40d0-a98a-37145ffe1ad1");
pub const IID_IMFMediaEngineEx = &IID_IMFMediaEngineEx_Value;
pub const IMFMediaEngineEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngine.VTable,
        SetSourceFromByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pByteStream: ?*IMFByteStream,
                pURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pByteStream: ?*IMFByteStream,
                pURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                StatisticID: MF_MEDIA_ENGINE_STATISTIC,
                pStatistic: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                StatisticID: MF_MEDIA_ENGINE_STATISTIC,
                pStatistic: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateVideoStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                balance: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                balance: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPlaybackRateSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                rate: f64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                rate: f64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        FrameStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                Forward: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                Forward: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResourceCharacteristics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentationAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                dwStreamIndex: u32,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                dwStreamIndex: u32,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                dwStreamIndex: u32,
                pEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                dwStreamIndex: u32,
                pEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                dwStreamIndex: u32,
                Enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                dwStreamIndex: u32,
                Enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyStreamSelections: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pProtected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pProtected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertVideoEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pEffect: ?*IUnknown,
                fOptional: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pEffect: ?*IUnknown,
                fOptional: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertAudioEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pEffect: ?*IUnknown,
                fOptional: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pEffect: ?*IUnknown,
                fOptional: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimelineMarkerTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                timeToFire: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                timeToFire: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimelineMarkerTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pTimeToFire: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pTimeToFire: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelTimelineMarkerTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsStereo3D: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngineEx,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetStereo3DFramePackingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                packMode: ?*MF_MEDIA_ENGINE_S3D_PACKING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                packMode: ?*MF_MEDIA_ENGINE_S3D_PACKING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStereo3DFramePackingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                packMode: MF_MEDIA_ENGINE_S3D_PACKING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                packMode: MF_MEDIA_ENGINE_S3D_PACKING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStereo3DRenderMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                outputType: ?*MF3DVideoOutputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                outputType: ?*MF3DVideoOutputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStereo3DRenderMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                outputType: MF3DVideoOutputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                outputType: MF3DVideoOutputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableWindowlessSwapchainMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoSwapchainHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                phSwapchain: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                phSwapchain: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableHorizontalMirrorMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioStreamCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pCategory: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pCategory: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAudioStreamCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                category: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                category: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioEndpointRole: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pRole: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAudioEndpointRole: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                role: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                role: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRealTimeMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRealTimeMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentTimeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                seekTime: f64,
                seekMode: MF_MEDIA_ENGINE_SEEK_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                seekTime: f64,
                seekMode: MF_MEDIA_ENGINE_SEEK_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableTimeUpdateTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEx,
                fEnableTimer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEx,
                fEnableTimer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEngine.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetSourceFromByteStream(self: *const T, pByteStream: ?*IMFByteStream, pURL: ?BSTR) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetSourceFromByteStream(@as(*const IMFMediaEngineEx, @ptrCast(self)), pByteStream, pURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetStatistics(self: *const T, StatisticID: MF_MEDIA_ENGINE_STATISTIC, pStatistic: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetStatistics(@as(*const IMFMediaEngineEx, @ptrCast(self)), StatisticID, pStatistic);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_UpdateVideoStream(self: *const T, pSrc: ?*const MFVideoNormalizedRect, pDst: ?*const RECT, pBorderClr: ?*const MFARGB) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).UpdateVideoStream(@as(*const IMFMediaEngineEx, @ptrCast(self)), pSrc, pDst, pBorderClr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetBalance(self: *const T) f64 {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetBalance(@as(*const IMFMediaEngineEx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetBalance(self: *const T, balance: f64) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetBalance(@as(*const IMFMediaEngineEx, @ptrCast(self)), balance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_IsPlaybackRateSupported(self: *const T, rate: f64) BOOL {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).IsPlaybackRateSupported(@as(*const IMFMediaEngineEx, @ptrCast(self)), rate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_FrameStep(self: *const T, Forward: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).FrameStep(@as(*const IMFMediaEngineEx, @ptrCast(self)), Forward);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetResourceCharacteristics(self: *const T, pCharacteristics: ?*u32) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetResourceCharacteristics(@as(*const IMFMediaEngineEx, @ptrCast(self)), pCharacteristics);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetPresentationAttribute(self: *const T, guidMFAttribute: ?*const Guid, pvValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetPresentationAttribute(@as(*const IMFMediaEngineEx, @ptrCast(self)), guidMFAttribute, pvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetNumberOfStreams(self: *const T, pdwStreamCount: ?*u32) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IMFMediaEngineEx, @ptrCast(self)), pdwStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetStreamAttribute(self: *const T, dwStreamIndex: u32, guidMFAttribute: ?*const Guid, pvValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetStreamAttribute(@as(*const IMFMediaEngineEx, @ptrCast(self)), dwStreamIndex, guidMFAttribute, pvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetStreamSelection(self: *const T, dwStreamIndex: u32, pEnabled: ?*BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetStreamSelection(@as(*const IMFMediaEngineEx, @ptrCast(self)), dwStreamIndex, pEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetStreamSelection(self: *const T, dwStreamIndex: u32, Enabled: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetStreamSelection(@as(*const IMFMediaEngineEx, @ptrCast(self)), dwStreamIndex, Enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_ApplyStreamSelections(self: *const T) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).ApplyStreamSelections(@as(*const IMFMediaEngineEx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_IsProtected(self: *const T, pProtected: ?*BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).IsProtected(@as(*const IMFMediaEngineEx, @ptrCast(self)), pProtected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_InsertVideoEffect(self: *const T, pEffect: ?*IUnknown, fOptional: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).InsertVideoEffect(@as(*const IMFMediaEngineEx, @ptrCast(self)), pEffect, fOptional);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_InsertAudioEffect(self: *const T, pEffect: ?*IUnknown, fOptional: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).InsertAudioEffect(@as(*const IMFMediaEngineEx, @ptrCast(self)), pEffect, fOptional);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_RemoveAllEffects(self: *const T) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).RemoveAllEffects(@as(*const IMFMediaEngineEx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetTimelineMarkerTimer(self: *const T, timeToFire: f64) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetTimelineMarkerTimer(@as(*const IMFMediaEngineEx, @ptrCast(self)), timeToFire);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetTimelineMarkerTimer(self: *const T, pTimeToFire: ?*f64) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetTimelineMarkerTimer(@as(*const IMFMediaEngineEx, @ptrCast(self)), pTimeToFire);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_CancelTimelineMarkerTimer(self: *const T) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).CancelTimelineMarkerTimer(@as(*const IMFMediaEngineEx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_IsStereo3D(self: *const T) BOOL {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).IsStereo3D(@as(*const IMFMediaEngineEx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetStereo3DFramePackingMode(self: *const T, packMode: ?*MF_MEDIA_ENGINE_S3D_PACKING_MODE) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetStereo3DFramePackingMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), packMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetStereo3DFramePackingMode(self: *const T, packMode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetStereo3DFramePackingMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), packMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetStereo3DRenderMode(self: *const T, outputType: ?*MF3DVideoOutputType) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetStereo3DRenderMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), outputType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetStereo3DRenderMode(self: *const T, outputType: MF3DVideoOutputType) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetStereo3DRenderMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), outputType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_EnableWindowlessSwapchainMode(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).EnableWindowlessSwapchainMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetVideoSwapchainHandle(self: *const T, phSwapchain: ?*?HANDLE) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetVideoSwapchainHandle(@as(*const IMFMediaEngineEx, @ptrCast(self)), phSwapchain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_EnableHorizontalMirrorMode(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).EnableHorizontalMirrorMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetAudioStreamCategory(self: *const T, pCategory: ?*u32) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetAudioStreamCategory(@as(*const IMFMediaEngineEx, @ptrCast(self)), pCategory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetAudioStreamCategory(self: *const T, category: u32) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetAudioStreamCategory(@as(*const IMFMediaEngineEx, @ptrCast(self)), category);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetAudioEndpointRole(self: *const T, pRole: ?*u32) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetAudioEndpointRole(@as(*const IMFMediaEngineEx, @ptrCast(self)), pRole);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetAudioEndpointRole(self: *const T, role: u32) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetAudioEndpointRole(@as(*const IMFMediaEngineEx, @ptrCast(self)), role);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_GetRealTimeMode(self: *const T, pfEnabled: ?*BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).GetRealTimeMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetRealTimeMode(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetRealTimeMode(@as(*const IMFMediaEngineEx, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_SetCurrentTimeEx(self: *const T, seekTime: f64, seekMode: MF_MEDIA_ENGINE_SEEK_MODE) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).SetCurrentTimeEx(@as(*const IMFMediaEngineEx, @ptrCast(self)), seekTime, seekMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEx_EnableTimeUpdateTimer(self: *const T, fEnableTimer: BOOL) HRESULT {
                return @as(*const IMFMediaEngineEx.VTable, @ptrCast(self.vtable)).EnableTimeUpdateTimer(@as(*const IMFMediaEngineEx, @ptrCast(self)), fEnableTimer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineAudioEndpointId_Value = Guid.initString("7a3bac98-0e76-49fb-8c20-8a86fd98eaf2");
pub const IID_IMFMediaEngineAudioEndpointId = &IID_IMFMediaEngineAudioEndpointId_Value;
pub const IMFMediaEngineAudioEndpointId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAudioEndpointId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineAudioEndpointId,
                pszEndpointId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineAudioEndpointId,
                pszEndpointId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioEndpointId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineAudioEndpointId,
                ppszEndpointId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineAudioEndpointId,
                ppszEndpointId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineAudioEndpointId_SetAudioEndpointId(self: *const T, pszEndpointId: ?[*:0]const u16) HRESULT {
                return @as(*const IMFMediaEngineAudioEndpointId.VTable, @ptrCast(self.vtable)).SetAudioEndpointId(@as(*const IMFMediaEngineAudioEndpointId, @ptrCast(self)), pszEndpointId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineAudioEndpointId_GetAudioEndpointId(self: *const T, ppszEndpointId: ?*?PWSTR) HRESULT {
                return @as(*const IMFMediaEngineAudioEndpointId.VTable, @ptrCast(self.vtable)).GetAudioEndpointId(@as(*const IMFMediaEngineAudioEndpointId, @ptrCast(self)), ppszEndpointId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_EXTENSION_TYPE = enum(i32) {
    MEDIASOURCE = 0,
    BYTESTREAM = 1,
};
pub const MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE = MF_MEDIA_ENGINE_EXTENSION_TYPE.MEDIASOURCE;
pub const MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM = MF_MEDIA_ENGINE_EXTENSION_TYPE.BYTESTREAM;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngineExtension_Value = Guid.initString("2f69d622-20b5-41e9-afdf-89ced1dda04e");
pub const IID_IMFMediaEngineExtension = &IID_IMFMediaEngineExtension_Value;
pub const IMFMediaEngineExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanPlayType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineExtension,
                AudioOnly: BOOL,
                MimeType: ?BSTR,
                pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineExtension,
                AudioOnly: BOOL,
                MimeType: ?BSTR,
                pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineExtension,
                bstrURL: ?BSTR,
                pByteStream: ?*IMFByteStream,
                type: MF_OBJECT_TYPE,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineExtension,
                bstrURL: ?BSTR,
                pByteStream: ?*IMFByteStream,
                type: MF_OBJECT_TYPE,
                ppIUnknownCancelCookie: ?*?*IUnknown,
                pCallback: ?*IMFAsyncCallback,
                punkState: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelObjectCreation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineExtension,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineExtension,
                pIUnknownCancelCookie: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndCreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineExtension,
                pResult: ?*IMFAsyncResult,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineExtension,
                pResult: ?*IMFAsyncResult,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineExtension_CanPlayType(self: *const T, AudioOnly: BOOL, MimeType: ?BSTR, pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY) HRESULT {
                return @as(*const IMFMediaEngineExtension.VTable, @ptrCast(self.vtable)).CanPlayType(@as(*const IMFMediaEngineExtension, @ptrCast(self)), AudioOnly, MimeType, pAnswer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineExtension_BeginCreateObject(self: *const T, bstrURL: ?BSTR, pByteStream: ?*IMFByteStream, type_: MF_OBJECT_TYPE, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: ?*IMFAsyncCallback, punkState: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaEngineExtension.VTable, @ptrCast(self.vtable)).BeginCreateObject(@as(*const IMFMediaEngineExtension, @ptrCast(self)), bstrURL, pByteStream, type_, ppIUnknownCancelCookie, pCallback, punkState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineExtension_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaEngineExtension.VTable, @ptrCast(self.vtable)).CancelObjectCreation(@as(*const IMFMediaEngineExtension, @ptrCast(self)), pIUnknownCancelCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineExtension_EndCreateObject(self: *const T, pResult: ?*IMFAsyncResult, ppObject: ?*?*IUnknown) HRESULT {
                return @as(*const IMFMediaEngineExtension.VTable, @ptrCast(self.vtable)).EndCreateObject(@as(*const IMFMediaEngineExtension, @ptrCast(self)), pResult, ppObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS = enum(i32) {
    PROTECTED = 1,
    REQUIRES_SURFACE_PROTECTION = 2,
    REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION = 4,
};
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS.PROTECTED;
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS.REQUIRES_SURFACE_PROTECTION;
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS.REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngineProtectedContent_Value = Guid.initString("9f8021e8-9c8c-487e-bb5c-79aa4779938c");
pub const IID_IMFMediaEngineProtectedContent = &IID_IMFMediaEngineProtectedContent_Value;
pub const IMFMediaEngineProtectedContent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShareResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineProtectedContent,
                pUnkDeviceContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineProtectedContent,
                pUnkDeviceContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRequiredProtections: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineProtectedContent,
                pFrameProtectionFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineProtectedContent,
                pFrameProtectionFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOPMWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineProtectedContent,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineProtectedContent,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransferVideoFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineProtectedContent,
                pDstSurf: ?*IUnknown,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const MFARGB,
                pFrameProtectionFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineProtectedContent,
                pDstSurf: ?*IUnknown,
                pSrc: ?*const MFVideoNormalizedRect,
                pDst: ?*const RECT,
                pBorderClr: ?*const MFARGB,
                pFrameProtectionFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContentProtectionManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineProtectedContent,
                pCPM: ?*IMFContentProtectionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineProtectedContent,
                pCPM: ?*IMFContentProtectionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetApplicationCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineProtectedContent,
                // TODO: what to do with BytesParamIndex 1?
                pbBlob: ?*const u8,
                cbBlob: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineProtectedContent,
                // TODO: what to do with BytesParamIndex 1?
                pbBlob: ?*const u8,
                cbBlob: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineProtectedContent_ShareResources(self: *const T, pUnkDeviceContext: ?*IUnknown) HRESULT {
                return @as(*const IMFMediaEngineProtectedContent.VTable, @ptrCast(self.vtable)).ShareResources(@as(*const IMFMediaEngineProtectedContent, @ptrCast(self)), pUnkDeviceContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineProtectedContent_GetRequiredProtections(self: *const T, pFrameProtectionFlags: ?*u32) HRESULT {
                return @as(*const IMFMediaEngineProtectedContent.VTable, @ptrCast(self.vtable)).GetRequiredProtections(@as(*const IMFMediaEngineProtectedContent, @ptrCast(self)), pFrameProtectionFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineProtectedContent_SetOPMWindow(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IMFMediaEngineProtectedContent.VTable, @ptrCast(self.vtable)).SetOPMWindow(@as(*const IMFMediaEngineProtectedContent, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineProtectedContent_TransferVideoFrame(self: *const T, pDstSurf: ?*IUnknown, pSrc: ?*const MFVideoNormalizedRect, pDst: ?*const RECT, pBorderClr: ?*const MFARGB, pFrameProtectionFlags: ?*u32) HRESULT {
                return @as(*const IMFMediaEngineProtectedContent.VTable, @ptrCast(self.vtable)).TransferVideoFrame(@as(*const IMFMediaEngineProtectedContent, @ptrCast(self)), pDstSurf, pSrc, pDst, pBorderClr, pFrameProtectionFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineProtectedContent_SetContentProtectionManager(self: *const T, pCPM: ?*IMFContentProtectionManager) HRESULT {
                return @as(*const IMFMediaEngineProtectedContent.VTable, @ptrCast(self.vtable)).SetContentProtectionManager(@as(*const IMFMediaEngineProtectedContent, @ptrCast(self)), pCPM);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineProtectedContent_SetApplicationCertificate(self: *const T, pbBlob: ?*const u8, cbBlob: u32) HRESULT {
                return @as(*const IMFMediaEngineProtectedContent.VTable, @ptrCast(self.vtable)).SetApplicationCertificate(@as(*const IMFMediaEngineProtectedContent, @ptrCast(self)), pbBlob, cbBlob);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSourceProvider_Value = Guid.initString("ebbaf249-afc2-4582-91c6-b60df2e84954");
pub const IID_IAudioSourceProvider = &IID_IAudioSourceProvider_Value;
pub const IAudioSourceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProvideInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAudioSourceProvider,
                dwSampleCount: u32,
                pdwChannelCount: ?*u32,
                pInterleavedAudioData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAudioSourceProvider,
                dwSampleCount: u32,
                pdwChannelCount: ?*u32,
                pInterleavedAudioData: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAudioSourceProvider_ProvideInput(self: *const T, dwSampleCount: u32, pdwChannelCount: ?*u32, pInterleavedAudioData: ?*f32) HRESULT {
                return @as(*const IAudioSourceProvider.VTable, @ptrCast(self.vtable)).ProvideInput(@as(*const IAudioSourceProvider, @ptrCast(self)), dwSampleCount, pdwChannelCount, pInterleavedAudioData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineWebSupport_Value = Guid.initString("ba2743a1-07e0-48ef-84b6-9a2ed023ca6c");
pub const IID_IMFMediaEngineWebSupport = &IID_IMFMediaEngineWebSupport_Value;
pub const IMFMediaEngineWebSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShouldDelayTheLoadEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineWebSupport,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaEngineWebSupport,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        ConnectWebAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineWebSupport,
                dwSampleRate: u32,
                ppSourceProvider: ?*?*IAudioSourceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineWebSupport,
                dwSampleRate: u32,
                ppSourceProvider: ?*?*IAudioSourceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectWebAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineWebSupport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineWebSupport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineWebSupport_ShouldDelayTheLoadEvent(self: *const T) BOOL {
                return @as(*const IMFMediaEngineWebSupport.VTable, @ptrCast(self.vtable)).ShouldDelayTheLoadEvent(@as(*const IMFMediaEngineWebSupport, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineWebSupport_ConnectWebAudio(self: *const T, dwSampleRate: u32, ppSourceProvider: ?*?*IAudioSourceProvider) HRESULT {
                return @as(*const IMFMediaEngineWebSupport.VTable, @ptrCast(self.vtable)).ConnectWebAudio(@as(*const IMFMediaEngineWebSupport, @ptrCast(self)), dwSampleRate, ppSourceProvider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineWebSupport_DisconnectWebAudio(self: *const T) HRESULT {
                return @as(*const IMFMediaEngineWebSupport.VTable, @ptrCast(self.vtable)).DisconnectWebAudio(@as(*const IMFMediaEngineWebSupport, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MSE_VP9_SUPPORT_TYPE = enum(i32) {
    DEFAULT = 0,
    ON = 1,
    OFF = 2,
};
pub const MF_MSE_VP9_SUPPORT_DEFAULT = MF_MSE_VP9_SUPPORT_TYPE.DEFAULT;
pub const MF_MSE_VP9_SUPPORT_ON = MF_MSE_VP9_SUPPORT_TYPE.ON;
pub const MF_MSE_VP9_SUPPORT_OFF = MF_MSE_VP9_SUPPORT_TYPE.OFF;

pub const MF_MSE_OPUS_SUPPORT_TYPE = enum(i32) {
    N = 0,
    FF = 1,
};
pub const MF_MSE_OPUS_SUPPORT_ON = MF_MSE_OPUS_SUPPORT_TYPE.N;
pub const MF_MSE_OPUS_SUPPORT_OFF = MF_MSE_OPUS_SUPPORT_TYPE.FF;

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaSourceExtensionNotify_Value = Guid.initString("a7901327-05dd-4469-a7b7-0e01979e361d");
pub const IID_IMFMediaSourceExtensionNotify = &IID_IMFMediaSourceExtensionNotify_Value;
pub const IMFMediaSourceExtensionNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSourceOpen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtensionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaSourceExtensionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnSourceEnded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtensionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaSourceExtensionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnSourceClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtensionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaSourceExtensionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtensionNotify_OnSourceOpen(self: *const T) void {
                return @as(*const IMFMediaSourceExtensionNotify.VTable, @ptrCast(self.vtable)).OnSourceOpen(@as(*const IMFMediaSourceExtensionNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtensionNotify_OnSourceEnded(self: *const T) void {
                return @as(*const IMFMediaSourceExtensionNotify.VTable, @ptrCast(self.vtable)).OnSourceEnded(@as(*const IMFMediaSourceExtensionNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtensionNotify_OnSourceClose(self: *const T) void {
                return @as(*const IMFMediaSourceExtensionNotify.VTable, @ptrCast(self.vtable)).OnSourceClose(@as(*const IMFMediaSourceExtensionNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFBufferListNotify_Value = Guid.initString("24cd47f7-81d8-4785-adb2-af697a963cd2");
pub const IID_IMFBufferListNotify = &IID_IMFBufferListNotify_Value;
pub const IMFBufferListNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAddSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFBufferListNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFBufferListNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnRemoveSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFBufferListNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFBufferListNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFBufferListNotify_OnAddSourceBuffer(self: *const T) void {
                return @as(*const IMFBufferListNotify.VTable, @ptrCast(self.vtable)).OnAddSourceBuffer(@as(*const IMFBufferListNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFBufferListNotify_OnRemoveSourceBuffer(self: *const T) void {
                return @as(*const IMFBufferListNotify.VTable, @ptrCast(self.vtable)).OnRemoveSourceBuffer(@as(*const IMFBufferListNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFSourceBufferNotify_Value = Guid.initString("87e47623-2ceb-45d6-9b88-d8520c4dcbbc");
pub const IID_IMFSourceBufferNotify = &IID_IMFSourceBufferNotify_Value;
pub const IMFSourceBufferNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferNotify,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSourceBufferNotify,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnUpdateEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFSourceBufferNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferNotify_OnUpdateStart(self: *const T) void {
                return @as(*const IMFSourceBufferNotify.VTable, @ptrCast(self.vtable)).OnUpdateStart(@as(*const IMFSourceBufferNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferNotify_OnAbort(self: *const T) void {
                return @as(*const IMFSourceBufferNotify.VTable, @ptrCast(self.vtable)).OnAbort(@as(*const IMFSourceBufferNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferNotify_OnError(self: *const T, hr: HRESULT) void {
                return @as(*const IMFSourceBufferNotify.VTable, @ptrCast(self.vtable)).OnError(@as(*const IMFSourceBufferNotify, @ptrCast(self)), hr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferNotify_OnUpdate(self: *const T) void {
                return @as(*const IMFSourceBufferNotify.VTable, @ptrCast(self.vtable)).OnUpdate(@as(*const IMFSourceBufferNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferNotify_OnUpdateEnd(self: *const T) void {
                return @as(*const IMFSourceBufferNotify.VTable, @ptrCast(self.vtable)).OnUpdateEnd(@as(*const IMFSourceBufferNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFSourceBuffer_Value = Guid.initString("e2cd3a4b-af25-4d3d-9110-da0e6f8ee877");
pub const IID_IMFSourceBuffer = &IID_IMFSourceBuffer_Value;
pub const IMFSourceBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUpdating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetBuffered: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                ppBuffered: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                ppBuffered: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeStampOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetTimeStampOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                offset: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                offset: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppendWindowStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetAppendWindowStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppendWindowEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetAppendWindowEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                time: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Append: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const u8,
                len: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                // TODO: what to do with BytesParamIndex 1?
                pData: ?*const u8,
                len: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendByteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                pStream: ?*IMFByteStream,
                pMaxLen: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                pStream: ?*IMFByteStream,
                pMaxLen: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBuffer,
                start: f64,
                end: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBuffer,
                start: f64,
                end: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_GetUpdating(self: *const T) BOOL {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).GetUpdating(@as(*const IMFSourceBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_GetBuffered(self: *const T, ppBuffered: ?*?*IMFMediaTimeRange) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).GetBuffered(@as(*const IMFSourceBuffer, @ptrCast(self)), ppBuffered);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_GetTimeStampOffset(self: *const T) f64 {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).GetTimeStampOffset(@as(*const IMFSourceBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_SetTimeStampOffset(self: *const T, offset: f64) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).SetTimeStampOffset(@as(*const IMFSourceBuffer, @ptrCast(self)), offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_GetAppendWindowStart(self: *const T) f64 {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).GetAppendWindowStart(@as(*const IMFSourceBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_SetAppendWindowStart(self: *const T, time: f64) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).SetAppendWindowStart(@as(*const IMFSourceBuffer, @ptrCast(self)), time);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_GetAppendWindowEnd(self: *const T) f64 {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).GetAppendWindowEnd(@as(*const IMFSourceBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_SetAppendWindowEnd(self: *const T, time: f64) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).SetAppendWindowEnd(@as(*const IMFSourceBuffer, @ptrCast(self)), time);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_Append(self: *const T, pData: ?*const u8, len: u32) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).Append(@as(*const IMFSourceBuffer, @ptrCast(self)), pData, len);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_AppendByteStream(self: *const T, pStream: ?*IMFByteStream, pMaxLen: ?*u64) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).AppendByteStream(@as(*const IMFSourceBuffer, @ptrCast(self)), pStream, pMaxLen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_Abort(self: *const T) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).Abort(@as(*const IMFSourceBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBuffer_Remove(self: *const T, start: f64, end: f64) HRESULT {
                return @as(*const IMFSourceBuffer.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMFSourceBuffer, @ptrCast(self)), start, end);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MSE_APPEND_MODE = enum(i32) {
    GMENTS = 0,
    QUENCE = 1,
};
pub const MF_MSE_APPEND_MODE_SEGMENTS = MF_MSE_APPEND_MODE.GMENTS;
pub const MF_MSE_APPEND_MODE_SEQUENCE = MF_MSE_APPEND_MODE.QUENCE;

const IID_IMFSourceBufferAppendMode_Value = Guid.initString("19666fb4-babe-4c55-bc03-0a074da37e2a");
pub const IID_IMFSourceBufferAppendMode = &IID_IMFSourceBufferAppendMode_Value;
pub const IMFSourceBufferAppendMode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppendMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferAppendMode,
            ) callconv(@import("std").os.windows.WINAPI) MF_MSE_APPEND_MODE,
            else => *const fn (
                self: *const IMFSourceBufferAppendMode,
            ) callconv(@import("std").os.windows.WINAPI) MF_MSE_APPEND_MODE,
        },
        SetAppendMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferAppendMode,
                mode: MF_MSE_APPEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceBufferAppendMode,
                mode: MF_MSE_APPEND_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferAppendMode_GetAppendMode(self: *const T) MF_MSE_APPEND_MODE {
                return @as(*const IMFSourceBufferAppendMode.VTable, @ptrCast(self.vtable)).GetAppendMode(@as(*const IMFSourceBufferAppendMode, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferAppendMode_SetAppendMode(self: *const T, mode: MF_MSE_APPEND_MODE) HRESULT {
                return @as(*const IMFSourceBufferAppendMode.VTable, @ptrCast(self.vtable)).SetAppendMode(@as(*const IMFSourceBufferAppendMode, @ptrCast(self)), mode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFSourceBufferList_Value = Guid.initString("249981f8-8325-41f3-b80c-3b9e3aad0cbe");
pub const IID_IMFSourceBufferList = &IID_IMFSourceBufferList_Value;
pub const IMFSourceBufferList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferList,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFSourceBufferList,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceBufferList,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBuffer,
            else => *const fn (
                self: *const IMFSourceBufferList,
                index: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBuffer,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferList_GetLength(self: *const T) u32 {
                return @as(*const IMFSourceBufferList.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMFSourceBufferList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceBufferList_GetSourceBuffer(self: *const T, index: u32) ?*IMFSourceBuffer {
                return @as(*const IMFSourceBufferList.VTable, @ptrCast(self.vtable)).GetSourceBuffer(@as(*const IMFSourceBufferList, @ptrCast(self)), index);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MSE_READY = enum(i32) {
    CLOSED = 1,
    OPEN = 2,
    ENDED = 3,
};
pub const MF_MSE_READY_CLOSED = MF_MSE_READY.CLOSED;
pub const MF_MSE_READY_OPEN = MF_MSE_READY.OPEN;
pub const MF_MSE_READY_ENDED = MF_MSE_READY.ENDED;

pub const MF_MSE_ERROR = enum(i32) {
    NOERROR = 0,
    NETWORK = 1,
    DECODE = 2,
    UNKNOWN_ERROR = 3,
};
pub const MF_MSE_ERROR_NOERROR = MF_MSE_ERROR.NOERROR;
pub const MF_MSE_ERROR_NETWORK = MF_MSE_ERROR.NETWORK;
pub const MF_MSE_ERROR_DECODE = MF_MSE_ERROR.DECODE;
pub const MF_MSE_ERROR_UNKNOWN_ERROR = MF_MSE_ERROR.UNKNOWN_ERROR;

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaSourceExtension_Value = Guid.initString("e467b94e-a713-4562-a802-816a42e9008a");
pub const IID_IMFMediaSourceExtension = &IID_IMFMediaSourceExtension_Value;
pub const IMFMediaSourceExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBufferList,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBufferList,
        },
        GetActiveSourceBuffers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBufferList,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBufferList,
        },
        GetReadyState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) MF_MSE_READY,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) MF_MSE_READY,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        SetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
                duration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
                duration: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
                type: ?BSTR,
                pNotify: ?*IMFSourceBufferNotify,
                ppSourceBuffer: ?*?*IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
                type: ?BSTR,
                pNotify: ?*IMFSourceBufferNotify,
                ppSourceBuffer: ?*?*IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
                pSourceBuffer: ?*IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
                pSourceBuffer: ?*IMFSourceBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
                @"error": MF_MSE_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
                @"error": MF_MSE_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTypeSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
                type: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
                type: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetSourceBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtension,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBuffer,
            else => *const fn (
                self: *const IMFMediaSourceExtension,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*IMFSourceBuffer,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_GetSourceBuffers(self: *const T) ?*IMFSourceBufferList {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).GetSourceBuffers(@as(*const IMFMediaSourceExtension, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_GetActiveSourceBuffers(self: *const T) ?*IMFSourceBufferList {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).GetActiveSourceBuffers(@as(*const IMFMediaSourceExtension, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_GetReadyState(self: *const T) MF_MSE_READY {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).GetReadyState(@as(*const IMFMediaSourceExtension, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_GetDuration(self: *const T) f64 {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMFMediaSourceExtension, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_SetDuration(self: *const T, duration: f64) HRESULT {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).SetDuration(@as(*const IMFMediaSourceExtension, @ptrCast(self)), duration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_AddSourceBuffer(self: *const T, type_: ?BSTR, pNotify: ?*IMFSourceBufferNotify, ppSourceBuffer: ?*?*IMFSourceBuffer) HRESULT {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).AddSourceBuffer(@as(*const IMFMediaSourceExtension, @ptrCast(self)), type_, pNotify, ppSourceBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_RemoveSourceBuffer(self: *const T, pSourceBuffer: ?*IMFSourceBuffer) HRESULT {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).RemoveSourceBuffer(@as(*const IMFMediaSourceExtension, @ptrCast(self)), pSourceBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_SetEndOfStream(self: *const T, @"error": MF_MSE_ERROR) HRESULT {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).SetEndOfStream(@as(*const IMFMediaSourceExtension, @ptrCast(self)), @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_IsTypeSupported(self: *const T, type_: ?BSTR) BOOL {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).IsTypeSupported(@as(*const IMFMediaSourceExtension, @ptrCast(self)), type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtension_GetSourceBuffer(self: *const T, dwStreamIndex: u32) ?*IMFSourceBuffer {
                return @as(*const IMFMediaSourceExtension.VTable, @ptrCast(self.vtable)).GetSourceBuffer(@as(*const IMFMediaSourceExtension, @ptrCast(self)), dwStreamIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSourceExtensionLiveSeekableRange_Value = Guid.initString("5d1abfd6-450a-4d92-9efc-d6b6cbc1f4da");
pub const IID_IMFMediaSourceExtensionLiveSeekableRange = &IID_IMFMediaSourceExtensionLiveSeekableRange_Value;
pub const IMFMediaSourceExtensionLiveSeekableRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLiveSeekableRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtensionLiveSeekableRange,
                start: f64,
                end: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceExtensionLiveSeekableRange,
                start: f64,
                end: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearLiveSeekableRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSourceExtensionLiveSeekableRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSourceExtensionLiveSeekableRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtensionLiveSeekableRange_SetLiveSeekableRange(self: *const T, start: f64, end: f64) HRESULT {
                return @as(*const IMFMediaSourceExtensionLiveSeekableRange.VTable, @ptrCast(self.vtable)).SetLiveSeekableRange(@as(*const IMFMediaSourceExtensionLiveSeekableRange, @ptrCast(self)), start, end);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSourceExtensionLiveSeekableRange_ClearLiveSeekableRange(self: *const T) HRESULT {
                return @as(*const IMFMediaSourceExtensionLiveSeekableRange.VTable, @ptrCast(self.vtable)).ClearLiveSeekableRange(@as(*const IMFMediaSourceExtensionLiveSeekableRange, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineEME_Value = Guid.initString("50dc93e4-ba4f-4275-ae66-83e836e57469");
pub const IID_IMFMediaEngineEME = &IID_IMFMediaEngineEME_Value;
pub const IMFMediaEngineEME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Keys: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaEngineEME,
                keys: ?*?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaEngineEME,
                keys: ?*?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEME,
                keys: ?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineEME,
                keys: ?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEME_get_Keys(self: *const T, keys: ?*?*IMFMediaKeys) HRESULT {
                return @as(*const IMFMediaEngineEME.VTable, @ptrCast(self.vtable)).get_Keys(@as(*const IMFMediaEngineEME, @ptrCast(self)), keys);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEME_SetMediaKeys(self: *const T, keys: ?*IMFMediaKeys) HRESULT {
                return @as(*const IMFMediaEngineEME.VTable, @ptrCast(self.vtable)).SetMediaKeys(@as(*const IMFMediaEngineEME, @ptrCast(self)), keys);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineSrcElementsEx_Value = Guid.initString("654a6bb3-e1a3-424a-9908-53a43a0dfda0");
pub const IID_IMFMediaEngineSrcElementsEx = &IID_IMFMediaEngineSrcElementsEx_Value;
pub const IMFMediaEngineSrcElementsEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngineSrcElements.VTable,
        AddElementEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElementsEx,
                pURL: ?BSTR,
                pType: ?BSTR,
                pMedia: ?BSTR,
                keySystem: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElementsEx,
                pURL: ?BSTR,
                pType: ?BSTR,
                pMedia: ?BSTR,
                keySystem: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeySystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSrcElementsEx,
                index: u32,
                pType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSrcElementsEx,
                index: u32,
                pType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEngineSrcElements.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElementsEx_AddElementEx(self: *const T, pURL: ?BSTR, pType: ?BSTR, pMedia: ?BSTR, keySystem: ?BSTR) HRESULT {
                return @as(*const IMFMediaEngineSrcElementsEx.VTable, @ptrCast(self.vtable)).AddElementEx(@as(*const IMFMediaEngineSrcElementsEx, @ptrCast(self)), pURL, pType, pMedia, keySystem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSrcElementsEx_GetKeySystem(self: *const T, index: u32, pType: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaEngineSrcElementsEx.VTable, @ptrCast(self.vtable)).GetKeySystem(@as(*const IMFMediaEngineSrcElementsEx, @ptrCast(self)), index, pType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineNeedKeyNotify_Value = Guid.initString("46a30204-a696-4b18-8804-246b8f031bb1");
pub const IID_IMFMediaEngineNeedKeyNotify = &IID_IMFMediaEngineNeedKeyNotify_Value;
pub const IMFMediaEngineNeedKeyNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NeedKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineNeedKeyNotify,
                // TODO: what to do with BytesParamIndex 1?
                initData: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaEngineNeedKeyNotify,
                // TODO: what to do with BytesParamIndex 1?
                initData: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineNeedKeyNotify_NeedKey(self: *const T, initData: ?*const u8, cb: u32) void {
                return @as(*const IMFMediaEngineNeedKeyNotify.VTable, @ptrCast(self.vtable)).NeedKey(@as(*const IMFMediaEngineNeedKeyNotify, @ptrCast(self)), initData, cb);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaKeys_Value = Guid.initString("5cb31c05-61ff-418f-afda-caaf41421a38");
pub const IID_IMFMediaKeys = &IID_IMFMediaKeys_Value;
pub const IMFMediaKeys = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeys,
                mimeType: ?BSTR,
                // TODO: what to do with BytesParamIndex 2?
                initData: ?*const u8,
                cb: u32,
                // TODO: what to do with BytesParamIndex 4?
                customData: ?*const u8,
                cbCustomData: u32,
                notify: ?*IMFMediaKeySessionNotify,
                ppSession: ?*?*IMFMediaKeySession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeys,
                mimeType: ?BSTR,
                // TODO: what to do with BytesParamIndex 2?
                initData: ?*const u8,
                cb: u32,
                // TODO: what to do with BytesParamIndex 4?
                customData: ?*const u8,
                cbCustomData: u32,
                notify: ?*IMFMediaKeySessionNotify,
                ppSession: ?*?*IMFMediaKeySession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySystem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeys,
                keySystem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeys,
                keySystem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSuspendNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeys,
                notify: ?*?*IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeys,
                notify: ?*?*IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys_CreateSession(self: *const T, mimeType: ?BSTR, initData: ?*const u8, cb: u32, customData: ?*const u8, cbCustomData: u32, notify: ?*IMFMediaKeySessionNotify, ppSession: ?*?*IMFMediaKeySession) HRESULT {
                return @as(*const IMFMediaKeys.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const IMFMediaKeys, @ptrCast(self)), mimeType, initData, cb, customData, cbCustomData, notify, ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys_get_KeySystem(self: *const T, keySystem: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaKeys.VTable, @ptrCast(self.vtable)).get_KeySystem(@as(*const IMFMediaKeys, @ptrCast(self)), keySystem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaKeys.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaKeys, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys_GetSuspendNotify(self: *const T, notify: ?*?*IMFCdmSuspendNotify) HRESULT {
                return @as(*const IMFMediaKeys.VTable, @ptrCast(self.vtable)).GetSuspendNotify(@as(*const IMFMediaKeys, @ptrCast(self)), notify);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_KEYERR = enum(i32) {
    UNKNOWN = 1,
    CLIENT = 2,
    SERVICE = 3,
    OUTPUT = 4,
    HARDWARECHANGE = 5,
    DOMAIN = 6,
};
pub const MF_MEDIAENGINE_KEYERR_UNKNOWN = MF_MEDIA_ENGINE_KEYERR.UNKNOWN;
pub const MF_MEDIAENGINE_KEYERR_CLIENT = MF_MEDIA_ENGINE_KEYERR.CLIENT;
pub const MF_MEDIAENGINE_KEYERR_SERVICE = MF_MEDIA_ENGINE_KEYERR.SERVICE;
pub const MF_MEDIAENGINE_KEYERR_OUTPUT = MF_MEDIA_ENGINE_KEYERR.OUTPUT;
pub const MF_MEDIAENGINE_KEYERR_HARDWARECHANGE = MF_MEDIA_ENGINE_KEYERR.HARDWARECHANGE;
pub const MF_MEDIAENGINE_KEYERR_DOMAIN = MF_MEDIA_ENGINE_KEYERR.DOMAIN;

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaKeySession_Value = Guid.initString("24fa67d5-d1d0-4dc5-995c-c0efdc191fb5");
pub const IID_IMFMediaKeySession = &IID_IMFMediaKeySession_Value;
pub const IMFMediaKeySession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession,
                code: ?*u16,
                systemCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession,
                code: ?*u16,
                systemCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySystem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeySession,
                keySystem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeySession,
                keySystem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SessionId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeySession,
                sessionId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeySession,
                sessionId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession,
                // TODO: what to do with BytesParamIndex 1?
                key: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession,
                // TODO: what to do with BytesParamIndex 1?
                key: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession_GetError(self: *const T, code: ?*u16, systemCode: ?*u32) HRESULT {
                return @as(*const IMFMediaKeySession.VTable, @ptrCast(self.vtable)).GetError(@as(*const IMFMediaKeySession, @ptrCast(self)), code, systemCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession_get_KeySystem(self: *const T, keySystem: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaKeySession.VTable, @ptrCast(self.vtable)).get_KeySystem(@as(*const IMFMediaKeySession, @ptrCast(self)), keySystem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession_get_SessionId(self: *const T, sessionId: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaKeySession.VTable, @ptrCast(self.vtable)).get_SessionId(@as(*const IMFMediaKeySession, @ptrCast(self)), sessionId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession_Update(self: *const T, key: ?*const u8, cb: u32) HRESULT {
                return @as(*const IMFMediaKeySession.VTable, @ptrCast(self.vtable)).Update(@as(*const IMFMediaKeySession, @ptrCast(self)), key, cb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession_Close(self: *const T) HRESULT {
                return @as(*const IMFMediaKeySession.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFMediaKeySession, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaKeySessionNotify_Value = Guid.initString("6a0083f9-8947-4c1d-9ce0-cdee22b23135");
pub const IID_IMFMediaKeySessionNotify = &IID_IMFMediaKeySessionNotify_Value;
pub const IMFMediaKeySessionNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySessionNotify,
                destinationURL: ?BSTR,
                // TODO: what to do with BytesParamIndex 2?
                message: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaKeySessionNotify,
                destinationURL: ?BSTR,
                // TODO: what to do with BytesParamIndex 2?
                message: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        KeyAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySessionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaKeySessionNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        KeyError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySessionNotify,
                code: u16,
                systemCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaKeySessionNotify,
                code: u16,
                systemCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySessionNotify_KeyMessage(self: *const T, destinationURL: ?BSTR, message: ?*const u8, cb: u32) void {
                return @as(*const IMFMediaKeySessionNotify.VTable, @ptrCast(self.vtable)).KeyMessage(@as(*const IMFMediaKeySessionNotify, @ptrCast(self)), destinationURL, message, cb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySessionNotify_KeyAdded(self: *const T) void {
                return @as(*const IMFMediaKeySessionNotify.VTable, @ptrCast(self.vtable)).KeyAdded(@as(*const IMFMediaKeySessionNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySessionNotify_KeyError(self: *const T, code: u16, systemCode: u32) void {
                return @as(*const IMFMediaKeySessionNotify.VTable, @ptrCast(self.vtable)).KeyError(@as(*const IMFMediaKeySessionNotify, @ptrCast(self)), code, systemCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFCdmSuspendNotify_Value = Guid.initString("7a5645d2-43bd-47fd-87b7-dcd24cc7d692");
pub const IID_IMFCdmSuspendNotify = &IID_IMFCdmSuspendNotify_Value;
pub const IMFCdmSuspendNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        End: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCdmSuspendNotify_Begin(self: *const T) HRESULT {
                return @as(*const IMFCdmSuspendNotify.VTable, @ptrCast(self.vtable)).Begin(@as(*const IMFCdmSuspendNotify, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCdmSuspendNotify_End(self: *const T) HRESULT {
                return @as(*const IMFCdmSuspendNotify.VTable, @ptrCast(self.vtable)).End(@as(*const IMFCdmSuspendNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_HDCP_STATUS = enum(i32) {
    N = 0,
    FF = 1,
    N_WITH_TYPE_ENFORCEMENT = 2,
};
pub const MF_HDCP_STATUS_ON = MF_HDCP_STATUS.N;
pub const MF_HDCP_STATUS_OFF = MF_HDCP_STATUS.FF;
pub const MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT = MF_HDCP_STATUS.N_WITH_TYPE_ENFORCEMENT;

const IID_IMFHDCPStatus_Value = Guid.initString("de400f54-5bf1-40cf-8964-0bea136b1e3d");
pub const IID_IMFHDCPStatus = &IID_IMFHDCPStatus_Value;
pub const IMFHDCPStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Query: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHDCPStatus,
                pStatus: ?*MF_HDCP_STATUS,
                pfStatus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHDCPStatus,
                pStatus: ?*MF_HDCP_STATUS,
                pfStatus: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFHDCPStatus,
                status: MF_HDCP_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFHDCPStatus,
                status: MF_HDCP_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHDCPStatus_Query(self: *const T, pStatus: ?*MF_HDCP_STATUS, pfStatus: ?*BOOL) HRESULT {
                return @as(*const IMFHDCPStatus.VTable, @ptrCast(self.vtable)).Query(@as(*const IMFHDCPStatus, @ptrCast(self)), pStatus, pfStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFHDCPStatus_Set(self: *const T, status: MF_HDCP_STATUS) HRESULT {
                return @as(*const IMFHDCPStatus.VTable, @ptrCast(self.vtable)).Set(@as(*const IMFHDCPStatus, @ptrCast(self)), status);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_OPM_STATUS = enum(i32) {
    NOT_REQUESTED = 0,
    ESTABLISHED = 1,
    FAILED_VM = 2,
    FAILED_BDA = 3,
    FAILED_UNSIGNED_DRIVER = 4,
    FAILED = 5,
};
pub const MF_MEDIA_ENGINE_OPM_NOT_REQUESTED = MF_MEDIA_ENGINE_OPM_STATUS.NOT_REQUESTED;
pub const MF_MEDIA_ENGINE_OPM_ESTABLISHED = MF_MEDIA_ENGINE_OPM_STATUS.ESTABLISHED;
pub const MF_MEDIA_ENGINE_OPM_FAILED_VM = MF_MEDIA_ENGINE_OPM_STATUS.FAILED_VM;
pub const MF_MEDIA_ENGINE_OPM_FAILED_BDA = MF_MEDIA_ENGINE_OPM_STATUS.FAILED_BDA;
pub const MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER = MF_MEDIA_ENGINE_OPM_STATUS.FAILED_UNSIGNED_DRIVER;
pub const MF_MEDIA_ENGINE_OPM_FAILED = MF_MEDIA_ENGINE_OPM_STATUS.FAILED;

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineOPMInfo_Value = Guid.initString("765763e6-6c01-4b01-bb0f-b829f60ed28c");
pub const IID_IMFMediaEngineOPMInfo = &IID_IMFMediaEngineOPMInfo_Value;
pub const IMFMediaEngineOPMInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOPMInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineOPMInfo,
                pStatus: ?*MF_MEDIA_ENGINE_OPM_STATUS,
                pConstricted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineOPMInfo,
                pStatus: ?*MF_MEDIA_ENGINE_OPM_STATUS,
                pConstricted: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineOPMInfo_GetOPMInfo(self: *const T, pStatus: ?*MF_MEDIA_ENGINE_OPM_STATUS, pConstricted: ?*BOOL) HRESULT {
                return @as(*const IMFMediaEngineOPMInfo.VTable, @ptrCast(self.vtable)).GetOPMInfo(@as(*const IMFMediaEngineOPMInfo, @ptrCast(self)), pStatus, pConstricted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_CREATEFLAGS = enum(i32) {
    AUDIOONLY = 1,
    WAITFORSTABLE_STATE = 2,
    FORCEMUTE = 4,
    REAL_TIME_MODE = 8,
    DISABLE_LOCAL_PLUGINS = 16,
    CREATEFLAGS_MASK = 31,
};
pub const MF_MEDIA_ENGINE_AUDIOONLY = MF_MEDIA_ENGINE_CREATEFLAGS.AUDIOONLY;
pub const MF_MEDIA_ENGINE_WAITFORSTABLE_STATE = MF_MEDIA_ENGINE_CREATEFLAGS.WAITFORSTABLE_STATE;
pub const MF_MEDIA_ENGINE_FORCEMUTE = MF_MEDIA_ENGINE_CREATEFLAGS.FORCEMUTE;
pub const MF_MEDIA_ENGINE_REAL_TIME_MODE = MF_MEDIA_ENGINE_CREATEFLAGS.REAL_TIME_MODE;
pub const MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS = MF_MEDIA_ENGINE_CREATEFLAGS.DISABLE_LOCAL_PLUGINS;
pub const MF_MEDIA_ENGINE_CREATEFLAGS_MASK = MF_MEDIA_ENGINE_CREATEFLAGS.CREATEFLAGS_MASK;

pub const MF_MEDIA_ENGINE_PROTECTION_FLAGS = enum(i32) {
    ENABLE_PROTECTED_CONTENT = 1,
    USE_PMP_FOR_ALL_CONTENT = 2,
    USE_UNPROTECTED_PMP = 4,
};
pub const MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT = MF_MEDIA_ENGINE_PROTECTION_FLAGS.ENABLE_PROTECTED_CONTENT;
pub const MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT = MF_MEDIA_ENGINE_PROTECTION_FLAGS.USE_PMP_FOR_ALL_CONTENT;
pub const MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP = MF_MEDIA_ENGINE_PROTECTION_FLAGS.USE_UNPROTECTED_PMP;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaEngineClassFactory_Value = Guid.initString("4d645ace-26aa-4688-9be1-df3516990b93");
pub const IID_IMFMediaEngineClassFactory = &IID_IMFMediaEngineClassFactory_Value;
pub const IMFMediaEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactory,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppPlayer: ?*?*IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactory,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppPlayer: ?*?*IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTimeRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactory,
                ppTimeRange: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactory,
                ppTimeRange: ?*?*IMFMediaTimeRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactory,
                ppError: ?*?*IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactory,
                ppError: ?*?*IMFMediaError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactory_CreateInstance(self: *const T, dwFlags: u32, pAttr: ?*IMFAttributes, ppPlayer: ?*?*IMFMediaEngine) HRESULT {
                return @as(*const IMFMediaEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IMFMediaEngineClassFactory, @ptrCast(self)), dwFlags, pAttr, ppPlayer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactory_CreateTimeRange(self: *const T, ppTimeRange: ?*?*IMFMediaTimeRange) HRESULT {
                return @as(*const IMFMediaEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateTimeRange(@as(*const IMFMediaEngineClassFactory, @ptrCast(self)), ppTimeRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactory_CreateError(self: *const T, ppError: ?*?*IMFMediaError) HRESULT {
                return @as(*const IMFMediaEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateError(@as(*const IMFMediaEngineClassFactory, @ptrCast(self)), ppError);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineClassFactoryEx_Value = Guid.initString("c56156c6-ea5b-48a5-9df8-fbe035d0929e");
pub const IID_IMFMediaEngineClassFactoryEx = &IID_IMFMediaEngineClassFactoryEx_Value;
pub const IMFMediaEngineClassFactoryEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngineClassFactory.VTable,
        CreateMediaSourceExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactoryEx,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppMSE: ?*?*IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactoryEx,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppMSE: ?*?*IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMediaKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactoryEx,
                keySystem: ?BSTR,
                cdmStorePath: ?BSTR,
                ppKeys: ?*?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactoryEx,
                keySystem: ?BSTR,
                cdmStorePath: ?BSTR,
                ppKeys: ?*?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTypeSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactoryEx,
                type: ?BSTR,
                keySystem: ?BSTR,
                isSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactoryEx,
                type: ?BSTR,
                keySystem: ?BSTR,
                isSupported: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEngineClassFactory.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactoryEx_CreateMediaSourceExtension(self: *const T, dwFlags: u32, pAttr: ?*IMFAttributes, ppMSE: ?*?*IMFMediaSourceExtension) HRESULT {
                return @as(*const IMFMediaEngineClassFactoryEx.VTable, @ptrCast(self.vtable)).CreateMediaSourceExtension(@as(*const IMFMediaEngineClassFactoryEx, @ptrCast(self)), dwFlags, pAttr, ppMSE);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactoryEx_CreateMediaKeys(self: *const T, keySystem: ?BSTR, cdmStorePath: ?BSTR, ppKeys: ?*?*IMFMediaKeys) HRESULT {
                return @as(*const IMFMediaEngineClassFactoryEx.VTable, @ptrCast(self.vtable)).CreateMediaKeys(@as(*const IMFMediaEngineClassFactoryEx, @ptrCast(self)), keySystem, cdmStorePath, ppKeys);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactoryEx_IsTypeSupported(self: *const T, type_: ?BSTR, keySystem: ?BSTR, isSupported: ?*BOOL) HRESULT {
                return @as(*const IMFMediaEngineClassFactoryEx.VTable, @ptrCast(self.vtable)).IsTypeSupported(@as(*const IMFMediaEngineClassFactoryEx, @ptrCast(self)), type_, keySystem, isSupported);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineClassFactory2_Value = Guid.initString("09083cef-867f-4bf6-8776-dee3a7b42fca");
pub const IID_IMFMediaEngineClassFactory2 = &IID_IMFMediaEngineClassFactory2_Value;
pub const IMFMediaEngineClassFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMediaKeys2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactory2,
                keySystem: ?BSTR,
                defaultCdmStorePath: ?BSTR,
                inprivateCdmStorePath: ?BSTR,
                ppKeys: ?*?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactory2,
                keySystem: ?BSTR,
                defaultCdmStorePath: ?BSTR,
                inprivateCdmStorePath: ?BSTR,
                ppKeys: ?*?*IMFMediaKeys,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactory2_CreateMediaKeys2(self: *const T, keySystem: ?BSTR, defaultCdmStorePath: ?BSTR, inprivateCdmStorePath: ?BSTR, ppKeys: ?*?*IMFMediaKeys) HRESULT {
                return @as(*const IMFMediaEngineClassFactory2.VTable, @ptrCast(self.vtable)).CreateMediaKeys2(@as(*const IMFMediaEngineClassFactory2, @ptrCast(self)), keySystem, defaultCdmStorePath, inprivateCdmStorePath, ppKeys);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedDRMTypeSupport_Value = Guid.initString("332ec562-3758-468d-a784-e38f23552128");
pub const IID_IMFExtendedDRMTypeSupport = &IID_IMFExtendedDRMTypeSupport_Value;
pub const IMFExtendedDRMTypeSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTypeSupportedEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFExtendedDRMTypeSupport,
                type: ?BSTR,
                keySystem: ?BSTR,
                pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFExtendedDRMTypeSupport,
                type: ?BSTR,
                keySystem: ?BSTR,
                pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFExtendedDRMTypeSupport_IsTypeSupportedEx(self: *const T, type_: ?BSTR, keySystem: ?BSTR, pAnswer: ?*MF_MEDIA_ENGINE_CANPLAY) HRESULT {
                return @as(*const IMFExtendedDRMTypeSupport.VTable, @ptrCast(self.vtable)).IsTypeSupportedEx(@as(*const IMFExtendedDRMTypeSupport, @ptrCast(self)), type_, keySystem, pAnswer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFMediaEngineSupportsSourceTransfer_Value = Guid.initString("a724b056-1b2e-4642-a6f3-db9420c52908");
pub const IID_IMFMediaEngineSupportsSourceTransfer = &IID_IMFMediaEngineSupportsSourceTransfer_Value;
pub const IMFMediaEngineSupportsSourceTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShouldTransferSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSupportsSourceTransfer,
                pfShouldTransfer: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSupportsSourceTransfer,
                pfShouldTransfer: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachMediaSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSupportsSourceTransfer,
                ppByteStream: ?*?*IMFByteStream,
                ppMediaSource: ?*?*IMFMediaSource,
                ppMSE: ?*?*IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSupportsSourceTransfer,
                ppByteStream: ?*?*IMFByteStream,
                ppMediaSource: ?*?*IMFMediaSource,
                ppMSE: ?*?*IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachMediaSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineSupportsSourceTransfer,
                pByteStream: ?*IMFByteStream,
                pMediaSource: ?*IMFMediaSource,
                pMSE: ?*IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineSupportsSourceTransfer,
                pByteStream: ?*IMFByteStream,
                pMediaSource: ?*IMFMediaSource,
                pMSE: ?*IMFMediaSourceExtension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSupportsSourceTransfer_ShouldTransferSource(self: *const T, pfShouldTransfer: ?*BOOL) HRESULT {
                return @as(*const IMFMediaEngineSupportsSourceTransfer.VTable, @ptrCast(self.vtable)).ShouldTransferSource(@as(*const IMFMediaEngineSupportsSourceTransfer, @ptrCast(self)), pfShouldTransfer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSupportsSourceTransfer_DetachMediaSource(self: *const T, ppByteStream: ?*?*IMFByteStream, ppMediaSource: ?*?*IMFMediaSource, ppMSE: ?*?*IMFMediaSourceExtension) HRESULT {
                return @as(*const IMFMediaEngineSupportsSourceTransfer.VTable, @ptrCast(self.vtable)).DetachMediaSource(@as(*const IMFMediaEngineSupportsSourceTransfer, @ptrCast(self)), ppByteStream, ppMediaSource, ppMSE);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineSupportsSourceTransfer_AttachMediaSource(self: *const T, pByteStream: ?*IMFByteStream, pMediaSource: ?*IMFMediaSource, pMSE: ?*IMFMediaSourceExtension) HRESULT {
                return @as(*const IMFMediaEngineSupportsSourceTransfer.VTable, @ptrCast(self.vtable)).AttachMediaSource(@as(*const IMFMediaEngineSupportsSourceTransfer, @ptrCast(self)), pByteStream, pMediaSource, pMSE);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineTransferSource_Value = Guid.initString("24230452-fe54-40cc-94f3-fcc394c340d6");
pub const IID_IMFMediaEngineTransferSource = &IID_IMFMediaEngineTransferSource_Value;
pub const IMFMediaEngineTransferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TransferSourceToMediaEngine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineTransferSource,
                destination: ?*IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineTransferSource,
                destination: ?*IMFMediaEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineTransferSource_TransferSourceToMediaEngine(self: *const T, destination: ?*IMFMediaEngine) HRESULT {
                return @as(*const IMFMediaEngineTransferSource.VTable, @ptrCast(self.vtable)).TransferSourceToMediaEngine(@as(*const IMFMediaEngineTransferSource, @ptrCast(self)), destination);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TIMED_TEXT_TRACK_KIND = enum(i32) {
    UNKNOWN = 0,
    SUBTITLES = 1,
    CAPTIONS = 2,
    METADATA = 3,
};
pub const MF_TIMED_TEXT_TRACK_KIND_UNKNOWN = MF_TIMED_TEXT_TRACK_KIND.UNKNOWN;
pub const MF_TIMED_TEXT_TRACK_KIND_SUBTITLES = MF_TIMED_TEXT_TRACK_KIND.SUBTITLES;
pub const MF_TIMED_TEXT_TRACK_KIND_CAPTIONS = MF_TIMED_TEXT_TRACK_KIND.CAPTIONS;
pub const MF_TIMED_TEXT_TRACK_KIND_METADATA = MF_TIMED_TEXT_TRACK_KIND.METADATA;

pub const MF_TIMED_TEXT_UNIT_TYPE = enum(i32) {
    IXELS = 0,
    ERCENTAGE = 1,
};
pub const MF_TIMED_TEXT_UNIT_TYPE_PIXELS = MF_TIMED_TEXT_UNIT_TYPE.IXELS;
pub const MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE = MF_TIMED_TEXT_UNIT_TYPE.ERCENTAGE;

pub const MF_TIMED_TEXT_FONT_STYLE = enum(i32) {
    NORMAL = 0,
    OBLIQUE = 1,
    ITALIC = 2,
};
pub const MF_TIMED_TEXT_FONT_STYLE_NORMAL = MF_TIMED_TEXT_FONT_STYLE.NORMAL;
pub const MF_TIMED_TEXT_FONT_STYLE_OBLIQUE = MF_TIMED_TEXT_FONT_STYLE.OBLIQUE;
pub const MF_TIMED_TEXT_FONT_STYLE_ITALIC = MF_TIMED_TEXT_FONT_STYLE.ITALIC;

pub const MF_TIMED_TEXT_ALIGNMENT = enum(i32) {
    START = 0,
    END = 1,
    CENTER = 2,
};
pub const MF_TIMED_TEXT_ALIGNMENT_START = MF_TIMED_TEXT_ALIGNMENT.START;
pub const MF_TIMED_TEXT_ALIGNMENT_END = MF_TIMED_TEXT_ALIGNMENT.END;
pub const MF_TIMED_TEXT_ALIGNMENT_CENTER = MF_TIMED_TEXT_ALIGNMENT.CENTER;

pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT = enum(i32) {
    BEFORE = 0,
    AFTER = 1,
    CENTER = 2,
};
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE = MF_TIMED_TEXT_DISPLAY_ALIGNMENT.BEFORE;
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER = MF_TIMED_TEXT_DISPLAY_ALIGNMENT.AFTER;
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER = MF_TIMED_TEXT_DISPLAY_ALIGNMENT.CENTER;

pub const MF_TIMED_TEXT_DECORATION = enum(i32) {
    NONE = 0,
    UNDERLINE = 1,
    LINE_THROUGH = 2,
    OVERLINE = 4,
};
pub const MF_TIMED_TEXT_DECORATION_NONE = MF_TIMED_TEXT_DECORATION.NONE;
pub const MF_TIMED_TEXT_DECORATION_UNDERLINE = MF_TIMED_TEXT_DECORATION.UNDERLINE;
pub const MF_TIMED_TEXT_DECORATION_LINE_THROUGH = MF_TIMED_TEXT_DECORATION.LINE_THROUGH;
pub const MF_TIMED_TEXT_DECORATION_OVERLINE = MF_TIMED_TEXT_DECORATION.OVERLINE;

pub const MF_TIMED_TEXT_WRITING_MODE = enum(i32) {
    LRTB = 0,
    RLTB = 1,
    TBRL = 2,
    TBLR = 3,
    LR = 4,
    RL = 5,
    TB = 6,
};
pub const MF_TIMED_TEXT_WRITING_MODE_LRTB = MF_TIMED_TEXT_WRITING_MODE.LRTB;
pub const MF_TIMED_TEXT_WRITING_MODE_RLTB = MF_TIMED_TEXT_WRITING_MODE.RLTB;
pub const MF_TIMED_TEXT_WRITING_MODE_TBRL = MF_TIMED_TEXT_WRITING_MODE.TBRL;
pub const MF_TIMED_TEXT_WRITING_MODE_TBLR = MF_TIMED_TEXT_WRITING_MODE.TBLR;
pub const MF_TIMED_TEXT_WRITING_MODE_LR = MF_TIMED_TEXT_WRITING_MODE.LR;
pub const MF_TIMED_TEXT_WRITING_MODE_RL = MF_TIMED_TEXT_WRITING_MODE.RL;
pub const MF_TIMED_TEXT_WRITING_MODE_TB = MF_TIMED_TEXT_WRITING_MODE.TB;

pub const MF_TIMED_TEXT_SCROLL_MODE = enum(i32) {
    POP_ON = 0,
    ROLL_UP = 1,
};
pub const MF_TIMED_TEXT_SCROLL_MODE_POP_ON = MF_TIMED_TEXT_SCROLL_MODE.POP_ON;
pub const MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP = MF_TIMED_TEXT_SCROLL_MODE.ROLL_UP;

pub const MF_TIMED_TEXT_ERROR_CODE = enum(i32) {
    NOERROR = 0,
    FATAL = 1,
    DATA_FORMAT = 2,
    NETWORK = 3,
    INTERNAL = 4,
};
pub const MF_TIMED_TEXT_ERROR_CODE_NOERROR = MF_TIMED_TEXT_ERROR_CODE.NOERROR;
pub const MF_TIMED_TEXT_ERROR_CODE_FATAL = MF_TIMED_TEXT_ERROR_CODE.FATAL;
pub const MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT = MF_TIMED_TEXT_ERROR_CODE.DATA_FORMAT;
pub const MF_TIMED_TEXT_ERROR_CODE_NETWORK = MF_TIMED_TEXT_ERROR_CODE.NETWORK;
pub const MF_TIMED_TEXT_ERROR_CODE_INTERNAL = MF_TIMED_TEXT_ERROR_CODE.INTERNAL;

pub const MF_TIMED_TEXT_CUE_EVENT = enum(i32) {
    ACTIVE = 0,
    INACTIVE = 1,
    CLEAR = 2,
};
pub const MF_TIMED_TEXT_CUE_EVENT_ACTIVE = MF_TIMED_TEXT_CUE_EVENT.ACTIVE;
pub const MF_TIMED_TEXT_CUE_EVENT_INACTIVE = MF_TIMED_TEXT_CUE_EVENT.INACTIVE;
pub const MF_TIMED_TEXT_CUE_EVENT_CLEAR = MF_TIMED_TEXT_CUE_EVENT.CLEAR;

pub const MF_TIMED_TEXT_TRACK_READY_STATE = enum(i32) {
    NONE = 0,
    LOADING = 1,
    LOADED = 2,
    ERROR = 3,
};
pub const MF_TIMED_TEXT_TRACK_READY_STATE_NONE = MF_TIMED_TEXT_TRACK_READY_STATE.NONE;
pub const MF_TIMED_TEXT_TRACK_READY_STATE_LOADING = MF_TIMED_TEXT_TRACK_READY_STATE.LOADING;
pub const MF_TIMED_TEXT_TRACK_READY_STATE_LOADED = MF_TIMED_TEXT_TRACK_READY_STATE.LOADED;
pub const MF_TIMED_TEXT_TRACK_READY_STATE_ERROR = MF_TIMED_TEXT_TRACK_READY_STATE.ERROR;

pub const MF_TIMED_TEXT_RUBY_POSITION = enum(i32) {
    BEFORE = 0,
    AFTER = 1,
    OUTSIDE = 2,
};
pub const MF_TIMED_TEXT_RUBY_POSITION_BEFORE = MF_TIMED_TEXT_RUBY_POSITION.BEFORE;
pub const MF_TIMED_TEXT_RUBY_POSITION_AFTER = MF_TIMED_TEXT_RUBY_POSITION.AFTER;
pub const MF_TIMED_TEXT_RUBY_POSITION_OUTSIDE = MF_TIMED_TEXT_RUBY_POSITION.OUTSIDE;

pub const MF_TIMED_TEXT_RUBY_ALIGN = enum(i32) {
    CENTER = 0,
    START = 1,
    END = 2,
    SPACEAROUND = 3,
    SPACEBETWEEN = 4,
    WITHBASE = 5,
};
pub const MF_TIMED_TEXT_RUBY_ALIGN_CENTER = MF_TIMED_TEXT_RUBY_ALIGN.CENTER;
pub const MF_TIMED_TEXT_RUBY_ALIGN_START = MF_TIMED_TEXT_RUBY_ALIGN.START;
pub const MF_TIMED_TEXT_RUBY_ALIGN_END = MF_TIMED_TEXT_RUBY_ALIGN.END;
pub const MF_TIMED_TEXT_RUBY_ALIGN_SPACEAROUND = MF_TIMED_TEXT_RUBY_ALIGN.SPACEAROUND;
pub const MF_TIMED_TEXT_RUBY_ALIGN_SPACEBETWEEN = MF_TIMED_TEXT_RUBY_ALIGN.SPACEBETWEEN;
pub const MF_TIMED_TEXT_RUBY_ALIGN_WITHBASE = MF_TIMED_TEXT_RUBY_ALIGN.WITHBASE;

pub const MF_TIMED_TEXT_RUBY_RESERVE = enum(i32) {
    NONE = 0,
    BEFORE = 1,
    AFTER = 2,
    BOTH = 3,
    OUTSIDE = 4,
};
pub const MF_TIMED_TEXT_RUBY_RESERVE_NONE = MF_TIMED_TEXT_RUBY_RESERVE.NONE;
pub const MF_TIMED_TEXT_RUBY_RESERVE_BEFORE = MF_TIMED_TEXT_RUBY_RESERVE.BEFORE;
pub const MF_TIMED_TEXT_RUBY_RESERVE_AFTER = MF_TIMED_TEXT_RUBY_RESERVE.AFTER;
pub const MF_TIMED_TEXT_RUBY_RESERVE_BOTH = MF_TIMED_TEXT_RUBY_RESERVE.BOTH;
pub const MF_TIMED_TEXT_RUBY_RESERVE_OUTSIDE = MF_TIMED_TEXT_RUBY_RESERVE.OUTSIDE;

pub const MF_TIMED_TEXT_BOUTEN_TYPE = enum(i32) {
    NONE = 0,
    AUTO = 1,
    FILLEDCIRCLE = 2,
    OPENCIRCLE = 3,
    FILLEDDOT = 4,
    OPENDOT = 5,
    FILLEDSESAME = 6,
    OPENSESAME = 7,
};
pub const MF_TIMED_TEXT_BOUTEN_TYPE_NONE = MF_TIMED_TEXT_BOUTEN_TYPE.NONE;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_AUTO = MF_TIMED_TEXT_BOUTEN_TYPE.AUTO;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDCIRCLE = MF_TIMED_TEXT_BOUTEN_TYPE.FILLEDCIRCLE;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_OPENCIRCLE = MF_TIMED_TEXT_BOUTEN_TYPE.OPENCIRCLE;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDDOT = MF_TIMED_TEXT_BOUTEN_TYPE.FILLEDDOT;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_OPENDOT = MF_TIMED_TEXT_BOUTEN_TYPE.OPENDOT;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDSESAME = MF_TIMED_TEXT_BOUTEN_TYPE.FILLEDSESAME;
pub const MF_TIMED_TEXT_BOUTEN_TYPE_OPENSESAME = MF_TIMED_TEXT_BOUTEN_TYPE.OPENSESAME;

pub const MF_TIMED_TEXT_BOUTEN_POSITION = enum(i32) {
    BEFORE = 0,
    AFTER = 1,
    OUTSIDE = 2,
};
pub const MF_TIMED_TEXT_BOUTEN_POSITION_BEFORE = MF_TIMED_TEXT_BOUTEN_POSITION.BEFORE;
pub const MF_TIMED_TEXT_BOUTEN_POSITION_AFTER = MF_TIMED_TEXT_BOUTEN_POSITION.AFTER;
pub const MF_TIMED_TEXT_BOUTEN_POSITION_OUTSIDE = MF_TIMED_TEXT_BOUTEN_POSITION.OUTSIDE;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedText_Value = Guid.initString("1f2a94c9-a3df-430d-9d0f-acd85ddc29af");
pub const IID_IMFTimedText = &IID_IMFTimedText_Value;
pub const IMFTimedText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterNotifications: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                notify: ?*IMFTimedTextNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                notify: ?*IMFTimedTextNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                trackId: u32,
                selected: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                trackId: u32,
                selected: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDataSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                byteStream: ?*IMFByteStream,
                label: ?[*:0]const u16,
                language: ?[*:0]const u16,
                kind: MF_TIMED_TEXT_TRACK_KIND,
                isDefault: BOOL,
                trackId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                byteStream: ?*IMFByteStream,
                label: ?[*:0]const u16,
                language: ?[*:0]const u16,
                kind: MF_TIMED_TEXT_TRACK_KIND,
                isDefault: BOOL,
                trackId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDataSourceFromUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                url: ?[*:0]const u16,
                label: ?[*:0]const u16,
                language: ?[*:0]const u16,
                kind: MF_TIMED_TEXT_TRACK_KIND,
                isDefault: BOOL,
                trackId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                url: ?[*:0]const u16,
                label: ?[*:0]const u16,
                language: ?[*:0]const u16,
                kind: MF_TIMED_TEXT_TRACK_KIND,
                isDefault: BOOL,
                trackId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                label: ?[*:0]const u16,
                language: ?[*:0]const u16,
                kind: MF_TIMED_TEXT_TRACK_KIND,
                track: ?*?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                label: ?[*:0]const u16,
                language: ?[*:0]const u16,
                kind: MF_TIMED_TEXT_TRACK_KIND,
                track: ?*?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                track: ?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                track: ?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCueTimeOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                offset: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                offset: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCueTimeOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                offset: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                offset: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTracks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                tracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                tracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveTracks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                activeTracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                activeTracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextTracks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                textTracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                textTracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMetadataTracks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                metadataTracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                metadataTracks: ?*?*IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInBandEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
                enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedText,
                enabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInBandEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedText,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFTimedText,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_RegisterNotifications(self: *const T, notify: ?*IMFTimedTextNotify) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).RegisterNotifications(@as(*const IMFTimedText, @ptrCast(self)), notify);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_SelectTrack(self: *const T, trackId: u32, selected: BOOL) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).SelectTrack(@as(*const IMFTimedText, @ptrCast(self)), trackId, selected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_AddDataSource(self: *const T, byteStream: ?*IMFByteStream, label: ?[*:0]const u16, language: ?[*:0]const u16, kind: MF_TIMED_TEXT_TRACK_KIND, isDefault: BOOL, trackId: ?*u32) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).AddDataSource(@as(*const IMFTimedText, @ptrCast(self)), byteStream, label, language, kind, isDefault, trackId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_AddDataSourceFromUrl(self: *const T, url: ?[*:0]const u16, label: ?[*:0]const u16, language: ?[*:0]const u16, kind: MF_TIMED_TEXT_TRACK_KIND, isDefault: BOOL, trackId: ?*u32) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).AddDataSourceFromUrl(@as(*const IMFTimedText, @ptrCast(self)), url, label, language, kind, isDefault, trackId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_AddTrack(self: *const T, label: ?[*:0]const u16, language: ?[*:0]const u16, kind: MF_TIMED_TEXT_TRACK_KIND, track: ?*?*IMFTimedTextTrack) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).AddTrack(@as(*const IMFTimedText, @ptrCast(self)), label, language, kind, track);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_RemoveTrack(self: *const T, track: ?*IMFTimedTextTrack) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).RemoveTrack(@as(*const IMFTimedText, @ptrCast(self)), track);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_GetCueTimeOffset(self: *const T, offset: ?*f64) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).GetCueTimeOffset(@as(*const IMFTimedText, @ptrCast(self)), offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_SetCueTimeOffset(self: *const T, offset: f64) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).SetCueTimeOffset(@as(*const IMFTimedText, @ptrCast(self)), offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_GetTracks(self: *const T, tracks: ?*?*IMFTimedTextTrackList) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).GetTracks(@as(*const IMFTimedText, @ptrCast(self)), tracks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_GetActiveTracks(self: *const T, activeTracks: ?*?*IMFTimedTextTrackList) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).GetActiveTracks(@as(*const IMFTimedText, @ptrCast(self)), activeTracks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_GetTextTracks(self: *const T, textTracks: ?*?*IMFTimedTextTrackList) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).GetTextTracks(@as(*const IMFTimedText, @ptrCast(self)), textTracks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_GetMetadataTracks(self: *const T, metadataTracks: ?*?*IMFTimedTextTrackList) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).GetMetadataTracks(@as(*const IMFTimedText, @ptrCast(self)), metadataTracks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_SetInBandEnabled(self: *const T, enabled: BOOL) HRESULT {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).SetInBandEnabled(@as(*const IMFTimedText, @ptrCast(self)), enabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedText_IsInBandEnabled(self: *const T) BOOL {
                return @as(*const IMFTimedText.VTable, @ptrCast(self.vtable)).IsInBandEnabled(@as(*const IMFTimedText, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextNotify_Value = Guid.initString("df6b87b6-ce12-45db-aba7-432fe054e57d");
pub const IID_IMFTimedTextNotify = &IID_IMFTimedTextNotify_Value;
pub const IMFTimedTextNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TrackAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TrackRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TrackSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
                selected: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
                selected: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        TrackReadyStateChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
                trackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
                errorCode: MF_TIMED_TEXT_ERROR_CODE,
                extendedErrorCode: HRESULT,
                sourceTrackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
                errorCode: MF_TIMED_TEXT_ERROR_CODE,
                extendedErrorCode: HRESULT,
                sourceTrackId: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Cue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
                cueEvent: MF_TIMED_TEXT_CUE_EVENT,
                currentTime: f64,
                cue: ?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
                cueEvent: MF_TIMED_TEXT_CUE_EVENT,
                currentTime: f64,
                cue: ?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFTimedTextNotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_TrackAdded(self: *const T, trackId: u32) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).TrackAdded(@as(*const IMFTimedTextNotify, @ptrCast(self)), trackId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_TrackRemoved(self: *const T, trackId: u32) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).TrackRemoved(@as(*const IMFTimedTextNotify, @ptrCast(self)), trackId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_TrackSelected(self: *const T, trackId: u32, selected: BOOL) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).TrackSelected(@as(*const IMFTimedTextNotify, @ptrCast(self)), trackId, selected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_TrackReadyStateChanged(self: *const T, trackId: u32) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).TrackReadyStateChanged(@as(*const IMFTimedTextNotify, @ptrCast(self)), trackId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_Error(self: *const T, errorCode: MF_TIMED_TEXT_ERROR_CODE, extendedErrorCode: HRESULT, sourceTrackId: u32) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).Error(@as(*const IMFTimedTextNotify, @ptrCast(self)), errorCode, extendedErrorCode, sourceTrackId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_Cue(self: *const T, cueEvent: MF_TIMED_TEXT_CUE_EVENT, currentTime: f64, cue: ?*IMFTimedTextCue) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).Cue(@as(*const IMFTimedTextNotify, @ptrCast(self)), cueEvent, currentTime, cue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextNotify_Reset(self: *const T) void {
                return @as(*const IMFTimedTextNotify.VTable, @ptrCast(self.vtable)).Reset(@as(*const IMFTimedTextNotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextTrack_Value = Guid.initString("8822c32d-654e-4233-bf21-d7f2e67d30d4");
pub const IID_IMFTimedTextTrack = &IID_IMFTimedTextTrack_Value;
pub const IMFTimedTextTrack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
                label: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
                label: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
                label: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
                label: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
                language: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
                language: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTrackKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_KIND,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_KIND,
        },
        IsInBand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetInBandMetadataTrackDispatchType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
                dispatchType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
                dispatchType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsActive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_ERROR_CODE,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_ERROR_CODE,
        },
        GetExtendedErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
                format: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
                format: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReadyState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_READY_STATE,
            else => *const fn (
                self: *const IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_READY_STATE,
        },
        GetCueList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrack,
                cues: ?*?*IMFTimedTextCueList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrack,
                cues: ?*?*IMFTimedTextCueList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetId(self: *const T) u32 {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetId(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetLabel(self: *const T, label: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetLabel(@as(*const IMFTimedTextTrack, @ptrCast(self)), label);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_SetLabel(self: *const T, label: ?[*:0]const u16) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).SetLabel(@as(*const IMFTimedTextTrack, @ptrCast(self)), label);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetLanguage(self: *const T, language: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IMFTimedTextTrack, @ptrCast(self)), language);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetTrackKind(self: *const T) MF_TIMED_TEXT_TRACK_KIND {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetTrackKind(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_IsInBand(self: *const T) BOOL {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).IsInBand(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetInBandMetadataTrackDispatchType(self: *const T, dispatchType: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetInBandMetadataTrackDispatchType(@as(*const IMFTimedTextTrack, @ptrCast(self)), dispatchType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_IsActive(self: *const T) BOOL {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).IsActive(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetErrorCode(self: *const T) MF_TIMED_TEXT_ERROR_CODE {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetErrorCode(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetExtendedErrorCode(self: *const T) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetExtendedErrorCode(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetDataFormat(self: *const T, format: ?*Guid) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetDataFormat(@as(*const IMFTimedTextTrack, @ptrCast(self)), format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetReadyState(self: *const T) MF_TIMED_TEXT_TRACK_READY_STATE {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetReadyState(@as(*const IMFTimedTextTrack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrack_GetCueList(self: *const T, cues: ?*?*IMFTimedTextCueList) HRESULT {
                return @as(*const IMFTimedTextTrack.VTable, @ptrCast(self.vtable)).GetCueList(@as(*const IMFTimedTextTrack, @ptrCast(self)), cues);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextTrackList_Value = Guid.initString("23ff334c-442c-445f-bccc-edc438aa11e2");
pub const IID_IMFTimedTextTrackList = &IID_IMFTimedTextTrackList_Value;
pub const IMFTimedTextTrackList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextTrackList,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrackList,
                index: u32,
                track: ?*?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrackList,
                index: u32,
                track: ?*?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTrackById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextTrackList,
                trackId: u32,
                track: ?*?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextTrackList,
                trackId: u32,
                track: ?*?*IMFTimedTextTrack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrackList_GetLength(self: *const T) u32 {
                return @as(*const IMFTimedTextTrackList.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMFTimedTextTrackList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrackList_GetTrack(self: *const T, index: u32, track: ?*?*IMFTimedTextTrack) HRESULT {
                return @as(*const IMFTimedTextTrackList.VTable, @ptrCast(self.vtable)).GetTrack(@as(*const IMFTimedTextTrackList, @ptrCast(self)), index, track);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextTrackList_GetTrackById(self: *const T, trackId: u32, track: ?*?*IMFTimedTextTrack) HRESULT {
                return @as(*const IMFTimedTextTrackList.VTable, @ptrCast(self.vtable)).GetTrackById(@as(*const IMFTimedTextTrackList, @ptrCast(self)), trackId, track);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextCue_Value = Guid.initString("1e560447-9a2b-43e1-a94c-b0aaabfbfbc9");
pub const IID_IMFTimedTextCue = &IID_IMFTimedTextCue_Value;
pub const IMFTimedTextCue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetOriginalId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
                originalId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCue,
                originalId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCueKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_KIND,
            else => *const fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_KIND,
        },
        GetStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) f64,
            else => *const fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) f64,
        },
        GetTrackId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
                data: ?*?*IMFTimedTextBinary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCue,
                data: ?*?*IMFTimedTextBinary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
                region: ?*?*IMFTimedTextRegion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCue,
                region: ?*?*IMFTimedTextRegion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
                style: ?*?*IMFTimedTextStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCue,
                style: ?*?*IMFTimedTextStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCue,
                index: u32,
                line: ?*?*IMFTimedTextFormattedText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCue,
                index: u32,
                line: ?*?*IMFTimedTextFormattedText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetId(self: *const T) u32 {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetId(@as(*const IMFTimedTextCue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetOriginalId(self: *const T, originalId: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetOriginalId(@as(*const IMFTimedTextCue, @ptrCast(self)), originalId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetCueKind(self: *const T) MF_TIMED_TEXT_TRACK_KIND {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetCueKind(@as(*const IMFTimedTextCue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetStartTime(self: *const T) f64 {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const IMFTimedTextCue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetDuration(self: *const T) f64 {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMFTimedTextCue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetTrackId(self: *const T) u32 {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetTrackId(@as(*const IMFTimedTextCue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetData(self: *const T, data: ?*?*IMFTimedTextBinary) HRESULT {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetData(@as(*const IMFTimedTextCue, @ptrCast(self)), data);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetRegion(self: *const T, region: ?*?*IMFTimedTextRegion) HRESULT {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetRegion(@as(*const IMFTimedTextCue, @ptrCast(self)), region);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetStyle(self: *const T, style: ?*?*IMFTimedTextStyle) HRESULT {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetStyle(@as(*const IMFTimedTextCue, @ptrCast(self)), style);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetLineCount(self: *const T) u32 {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetLineCount(@as(*const IMFTimedTextCue, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCue_GetLine(self: *const T, index: u32, line: ?*?*IMFTimedTextFormattedText) HRESULT {
                return @as(*const IMFTimedTextCue.VTable, @ptrCast(self.vtable)).GetLine(@as(*const IMFTimedTextCue, @ptrCast(self)), index, line);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextFormattedText_Value = Guid.initString("e13af3c1-4d47-4354-b1f5-e83ae0ecae60");
pub const IID_IMFTimedTextFormattedText = &IID_IMFTimedTextFormattedText_Value;
pub const IMFTimedTextFormattedText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextFormattedText,
                text: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextFormattedText,
                text: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubformattingCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextFormattedText,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextFormattedText,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetSubformatting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextFormattedText,
                index: u32,
                firstChar: ?*u32,
                charLength: ?*u32,
                style: ?*?*IMFTimedTextStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextFormattedText,
                index: u32,
                firstChar: ?*u32,
                charLength: ?*u32,
                style: ?*?*IMFTimedTextStyle,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextFormattedText_GetText(self: *const T, text: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextFormattedText.VTable, @ptrCast(self.vtable)).GetText(@as(*const IMFTimedTextFormattedText, @ptrCast(self)), text);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextFormattedText_GetSubformattingCount(self: *const T) u32 {
                return @as(*const IMFTimedTextFormattedText.VTable, @ptrCast(self.vtable)).GetSubformattingCount(@as(*const IMFTimedTextFormattedText, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextFormattedText_GetSubformatting(self: *const T, index: u32, firstChar: ?*u32, charLength: ?*u32, style: ?*?*IMFTimedTextStyle) HRESULT {
                return @as(*const IMFTimedTextFormattedText.VTable, @ptrCast(self.vtable)).GetSubformatting(@as(*const IMFTimedTextFormattedText, @ptrCast(self)), index, firstChar, charLength, style);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextStyle_Value = Guid.initString("09b2455d-b834-4f01-a347-9052e21c450e");
pub const IID_IMFTimedTextStyle = &IID_IMFTimedTextStyle_Value;
pub const IMFTimedTextStyle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                name: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                name: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsExternal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFTimedTextStyle,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetFontFamily: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                fontFamily: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                fontFamily: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFontSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                fontSize: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                fontSize: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                color: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                color: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                bgColor: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                bgColor: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetShowBackgroundAlways: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                showBackgroundAlways: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                showBackgroundAlways: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFontStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                fontStyle: ?*MF_TIMED_TEXT_FONT_STYLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                fontStyle: ?*MF_TIMED_TEXT_FONT_STYLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBold: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                bold: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                bold: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRightToLeft: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                rightToLeft: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                rightToLeft: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                textAlign: ?*MF_TIMED_TEXT_ALIGNMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                textAlign: ?*MF_TIMED_TEXT_ALIGNMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextDecoration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                textDecoration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                textDecoration: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextOutline: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle,
                color: ?*MFARGB,
                thickness: ?*f64,
                blurRadius: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle,
                color: ?*MFARGB,
                thickness: ?*f64,
                blurRadius: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetName(self: *const T, name: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetName(@as(*const IMFTimedTextStyle, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_IsExternal(self: *const T) BOOL {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).IsExternal(@as(*const IMFTimedTextStyle, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetFontFamily(self: *const T, fontFamily: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetFontFamily(@as(*const IMFTimedTextStyle, @ptrCast(self)), fontFamily);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetFontSize(self: *const T, fontSize: ?*f64, unitType: ?*MF_TIMED_TEXT_UNIT_TYPE) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetFontSize(@as(*const IMFTimedTextStyle, @ptrCast(self)), fontSize, unitType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetColor(self: *const T, color: ?*MFARGB) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetColor(@as(*const IMFTimedTextStyle, @ptrCast(self)), color);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetBackgroundColor(self: *const T, bgColor: ?*MFARGB) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IMFTimedTextStyle, @ptrCast(self)), bgColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetShowBackgroundAlways(self: *const T, showBackgroundAlways: ?*BOOL) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetShowBackgroundAlways(@as(*const IMFTimedTextStyle, @ptrCast(self)), showBackgroundAlways);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetFontStyle(self: *const T, fontStyle: ?*MF_TIMED_TEXT_FONT_STYLE) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetFontStyle(@as(*const IMFTimedTextStyle, @ptrCast(self)), fontStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetBold(self: *const T, bold: ?*BOOL) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetBold(@as(*const IMFTimedTextStyle, @ptrCast(self)), bold);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetRightToLeft(self: *const T, rightToLeft: ?*BOOL) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetRightToLeft(@as(*const IMFTimedTextStyle, @ptrCast(self)), rightToLeft);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetTextAlignment(self: *const T, textAlign: ?*MF_TIMED_TEXT_ALIGNMENT) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetTextAlignment(@as(*const IMFTimedTextStyle, @ptrCast(self)), textAlign);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetTextDecoration(self: *const T, textDecoration: ?*u32) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetTextDecoration(@as(*const IMFTimedTextStyle, @ptrCast(self)), textDecoration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle_GetTextOutline(self: *const T, color: ?*MFARGB, thickness: ?*f64, blurRadius: ?*f64, unitType: ?*MF_TIMED_TEXT_UNIT_TYPE) HRESULT {
                return @as(*const IMFTimedTextStyle.VTable, @ptrCast(self.vtable)).GetTextOutline(@as(*const IMFTimedTextStyle, @ptrCast(self)), color, thickness, blurRadius, unitType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextRegion_Value = Guid.initString("c8d22afc-bc47-4bdf-9b04-787e49ce3f58");
pub const IID_IMFTimedTextRegion = &IID_IMFTimedTextRegion_Value;
pub const IMFTimedTextRegion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                name: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                name: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                pX: ?*f64,
                pY: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                pX: ?*f64,
                pY: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                pWidth: ?*f64,
                pHeight: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                pWidth: ?*f64,
                pHeight: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                bgColor: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                bgColor: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWritingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                writingMode: ?*MF_TIMED_TEXT_WRITING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                writingMode: ?*MF_TIMED_TEXT_WRITING_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayAlignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                displayAlign: ?*MF_TIMED_TEXT_DISPLAY_ALIGNMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                displayAlign: ?*MF_TIMED_TEXT_DISPLAY_ALIGNMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineHeight: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                pLineHeight: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                pLineHeight: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClipOverflow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                clipOverflow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                clipOverflow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPadding: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                before: ?*f64,
                start: ?*f64,
                after: ?*f64,
                end: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                before: ?*f64,
                start: ?*f64,
                after: ?*f64,
                end: ?*f64,
                unitType: ?*MF_TIMED_TEXT_UNIT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWrap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                wrap: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                wrap: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                zIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                zIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScrollMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRegion,
                scrollMode: ?*MF_TIMED_TEXT_SCROLL_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRegion,
                scrollMode: ?*MF_TIMED_TEXT_SCROLL_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetName(self: *const T, name: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetName(@as(*const IMFTimedTextRegion, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetPosition(self: *const T, pX: ?*f64, pY: ?*f64, unitType: ?*MF_TIMED_TEXT_UNIT_TYPE) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IMFTimedTextRegion, @ptrCast(self)), pX, pY, unitType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetExtent(self: *const T, pWidth: ?*f64, pHeight: ?*f64, unitType: ?*MF_TIMED_TEXT_UNIT_TYPE) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetExtent(@as(*const IMFTimedTextRegion, @ptrCast(self)), pWidth, pHeight, unitType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetBackgroundColor(self: *const T, bgColor: ?*MFARGB) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IMFTimedTextRegion, @ptrCast(self)), bgColor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetWritingMode(self: *const T, writingMode: ?*MF_TIMED_TEXT_WRITING_MODE) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetWritingMode(@as(*const IMFTimedTextRegion, @ptrCast(self)), writingMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetDisplayAlignment(self: *const T, displayAlign: ?*MF_TIMED_TEXT_DISPLAY_ALIGNMENT) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetDisplayAlignment(@as(*const IMFTimedTextRegion, @ptrCast(self)), displayAlign);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetLineHeight(self: *const T, pLineHeight: ?*f64, unitType: ?*MF_TIMED_TEXT_UNIT_TYPE) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetLineHeight(@as(*const IMFTimedTextRegion, @ptrCast(self)), pLineHeight, unitType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetClipOverflow(self: *const T, clipOverflow: ?*BOOL) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetClipOverflow(@as(*const IMFTimedTextRegion, @ptrCast(self)), clipOverflow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetPadding(self: *const T, before: ?*f64, start: ?*f64, after: ?*f64, end: ?*f64, unitType: ?*MF_TIMED_TEXT_UNIT_TYPE) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetPadding(@as(*const IMFTimedTextRegion, @ptrCast(self)), before, start, after, end, unitType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetWrap(self: *const T, wrap: ?*BOOL) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetWrap(@as(*const IMFTimedTextRegion, @ptrCast(self)), wrap);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetZIndex(self: *const T, zIndex: ?*i32) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetZIndex(@as(*const IMFTimedTextRegion, @ptrCast(self)), zIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRegion_GetScrollMode(self: *const T, scrollMode: ?*MF_TIMED_TEXT_SCROLL_MODE) HRESULT {
                return @as(*const IMFTimedTextRegion.VTable, @ptrCast(self.vtable)).GetScrollMode(@as(*const IMFTimedTextRegion, @ptrCast(self)), scrollMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IMFTimedTextBinary_Value = Guid.initString("4ae3a412-0545-43c4-bf6f-6b97a5c6c432");
pub const IID_IMFTimedTextBinary = &IID_IMFTimedTextBinary_Value;
pub const IMFTimedTextBinary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextBinary,
                data: ?*const ?*u8,
                length: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextBinary,
                data: ?*const ?*u8,
                length: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextBinary_GetData(self: *const T, data: ?*const ?*u8, length: ?*u32) HRESULT {
                return @as(*const IMFTimedTextBinary.VTable, @ptrCast(self.vtable)).GetData(@as(*const IMFTimedTextBinary, @ptrCast(self)), data, length);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextCueList_Value = Guid.initString("ad128745-211b-40a0-9981-fe65f166d0fd");
pub const IID_IMFTimedTextCueList = &IID_IMFTimedTextCueList_Value;
pub const IMFTimedTextCueList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMFTimedTextCueList,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetCueByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
                index: u32,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCueList,
                index: u32,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCueById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
                id: u32,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCueList,
                id: u32,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCueByOriginalId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
                originalId: ?[*:0]const u16,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCueList,
                originalId: ?[*:0]const u16,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTextCue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
                start: f64,
                duration: f64,
                text: ?[*:0]const u16,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCueList,
                start: f64,
                duration: f64,
                text: ?[*:0]const u16,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDataCue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
                start: f64,
                duration: f64,
                // TODO: what to do with BytesParamIndex 3?
                data: ?*const u8,
                dataSize: u32,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCueList,
                start: f64,
                duration: f64,
                // TODO: what to do with BytesParamIndex 3?
                data: ?*const u8,
                dataSize: u32,
                cue: ?*?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveCue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextCueList,
                cue: ?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextCueList,
                cue: ?*IMFTimedTextCue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_GetLength(self: *const T) u32 {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IMFTimedTextCueList, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_GetCueByIndex(self: *const T, index: u32, cue: ?*?*IMFTimedTextCue) HRESULT {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).GetCueByIndex(@as(*const IMFTimedTextCueList, @ptrCast(self)), index, cue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_GetCueById(self: *const T, id: u32, cue: ?*?*IMFTimedTextCue) HRESULT {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).GetCueById(@as(*const IMFTimedTextCueList, @ptrCast(self)), id, cue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_GetCueByOriginalId(self: *const T, originalId: ?[*:0]const u16, cue: ?*?*IMFTimedTextCue) HRESULT {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).GetCueByOriginalId(@as(*const IMFTimedTextCueList, @ptrCast(self)), originalId, cue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_AddTextCue(self: *const T, start: f64, duration: f64, text: ?[*:0]const u16, cue: ?*?*IMFTimedTextCue) HRESULT {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).AddTextCue(@as(*const IMFTimedTextCueList, @ptrCast(self)), start, duration, text, cue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_AddDataCue(self: *const T, start: f64, duration: f64, data: ?*const u8, dataSize: u32, cue: ?*?*IMFTimedTextCue) HRESULT {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).AddDataCue(@as(*const IMFTimedTextCueList, @ptrCast(self)), start, duration, data, dataSize, cue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextCueList_RemoveCue(self: *const T, cue: ?*IMFTimedTextCue) HRESULT {
                return @as(*const IMFTimedTextCueList.VTable, @ptrCast(self.vtable)).RemoveCue(@as(*const IMFTimedTextCueList, @ptrCast(self)), cue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextRuby_Value = Guid.initString("76c6a6f5-4955-4de5-b27b-14b734cc14b4");
pub const IID_IMFTimedTextRuby = &IID_IMFTimedTextRuby_Value;
pub const IMFTimedTextRuby = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRubyText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRuby,
                rubyText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRuby,
                rubyText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRubyPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRuby,
                value: ?*MF_TIMED_TEXT_RUBY_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRuby,
                value: ?*MF_TIMED_TEXT_RUBY_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRubyAlign: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRuby,
                value: ?*MF_TIMED_TEXT_RUBY_ALIGN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRuby,
                value: ?*MF_TIMED_TEXT_RUBY_ALIGN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRubyReserve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextRuby,
                value: ?*MF_TIMED_TEXT_RUBY_RESERVE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextRuby,
                value: ?*MF_TIMED_TEXT_RUBY_RESERVE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRuby_GetRubyText(self: *const T, rubyText: ?*?PWSTR) HRESULT {
                return @as(*const IMFTimedTextRuby.VTable, @ptrCast(self.vtable)).GetRubyText(@as(*const IMFTimedTextRuby, @ptrCast(self)), rubyText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRuby_GetRubyPosition(self: *const T, value: ?*MF_TIMED_TEXT_RUBY_POSITION) HRESULT {
                return @as(*const IMFTimedTextRuby.VTable, @ptrCast(self.vtable)).GetRubyPosition(@as(*const IMFTimedTextRuby, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRuby_GetRubyAlign(self: *const T, value: ?*MF_TIMED_TEXT_RUBY_ALIGN) HRESULT {
                return @as(*const IMFTimedTextRuby.VTable, @ptrCast(self.vtable)).GetRubyAlign(@as(*const IMFTimedTextRuby, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextRuby_GetRubyReserve(self: *const T, value: ?*MF_TIMED_TEXT_RUBY_RESERVE) HRESULT {
                return @as(*const IMFTimedTextRuby.VTable, @ptrCast(self.vtable)).GetRubyReserve(@as(*const IMFTimedTextRuby, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextBouten_Value = Guid.initString("3c5f3e8a-90c0-464e-8136-898d2975f847");
pub const IID_IMFTimedTextBouten = &IID_IMFTimedTextBouten_Value;
pub const IMFTimedTextBouten = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoutenType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextBouten,
                value: ?*MF_TIMED_TEXT_BOUTEN_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextBouten,
                value: ?*MF_TIMED_TEXT_BOUTEN_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoutenColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextBouten,
                value: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextBouten,
                value: ?*MFARGB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoutenPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextBouten,
                value: ?*MF_TIMED_TEXT_BOUTEN_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextBouten,
                value: ?*MF_TIMED_TEXT_BOUTEN_POSITION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextBouten_GetBoutenType(self: *const T, value: ?*MF_TIMED_TEXT_BOUTEN_TYPE) HRESULT {
                return @as(*const IMFTimedTextBouten.VTable, @ptrCast(self.vtable)).GetBoutenType(@as(*const IMFTimedTextBouten, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextBouten_GetBoutenColor(self: *const T, value: ?*MFARGB) HRESULT {
                return @as(*const IMFTimedTextBouten.VTable, @ptrCast(self.vtable)).GetBoutenColor(@as(*const IMFTimedTextBouten, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextBouten_GetBoutenPosition(self: *const T, value: ?*MF_TIMED_TEXT_BOUTEN_POSITION) HRESULT {
                return @as(*const IMFTimedTextBouten.VTable, @ptrCast(self.vtable)).GetBoutenPosition(@as(*const IMFTimedTextBouten, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextStyle2_Value = Guid.initString("db639199-c809-4c89-bfca-d0bbb9729d6e");
pub const IID_IMFTimedTextStyle2 = &IID_IMFTimedTextStyle2_Value;
pub const IMFTimedTextStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRuby: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle2,
                ruby: ?*?*IMFTimedTextRuby,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle2,
                ruby: ?*?*IMFTimedTextRuby,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBouten: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle2,
                bouten: ?*?*IMFTimedTextBouten,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle2,
                bouten: ?*?*IMFTimedTextBouten,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTextCombined: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle2,
                value: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle2,
                value: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFontAngleInDegrees: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTimedTextStyle2,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTimedTextStyle2,
                value: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle2_GetRuby(self: *const T, ruby: ?*?*IMFTimedTextRuby) HRESULT {
                return @as(*const IMFTimedTextStyle2.VTable, @ptrCast(self.vtable)).GetRuby(@as(*const IMFTimedTextStyle2, @ptrCast(self)), ruby);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle2_GetBouten(self: *const T, bouten: ?*?*IMFTimedTextBouten) HRESULT {
                return @as(*const IMFTimedTextStyle2.VTable, @ptrCast(self.vtable)).GetBouten(@as(*const IMFTimedTextStyle2, @ptrCast(self)), bouten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle2_IsTextCombined(self: *const T, value: ?*BOOL) HRESULT {
                return @as(*const IMFTimedTextStyle2.VTable, @ptrCast(self.vtable)).IsTextCombined(@as(*const IMFTimedTextStyle2, @ptrCast(self)), value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTimedTextStyle2_GetFontAngleInDegrees(self: *const T, value: ?*f64) HRESULT {
                return @as(*const IMFTimedTextStyle2.VTable, @ptrCast(self.vtable)).GetFontAngleInDegrees(@as(*const IMFTimedTextStyle2, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED = enum(i32) {
    UNKNOWN = 0,
    AUDIO = 1,
    VIDEO = 2,
};
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN = MF_MEDIA_ENGINE_STREAMTYPE_FAILED.UNKNOWN;
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO = MF_MEDIA_ENGINE_STREAMTYPE_FAILED.AUDIO;
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO = MF_MEDIA_ENGINE_STREAMTYPE_FAILED.VIDEO;

const IID_IMFMediaEngineEMENotify_Value = Guid.initString("9e184d15-cdb7-4f86-b49e-566689f4a601");
pub const IID_IMFMediaEngineEMENotify = &IID_IMFMediaEngineEMENotify_Value;
pub const IMFMediaEngineEMENotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Encrypted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEMENotify,
                // TODO: what to do with BytesParamIndex 1?
                pbInitData: ?*const u8,
                cb: u32,
                bstrInitDataType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaEngineEMENotify,
                // TODO: what to do with BytesParamIndex 1?
                pbInitData: ?*const u8,
                cb: u32,
                bstrInitDataType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        WaitingForKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineEMENotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaEngineEMENotify,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEMENotify_Encrypted(self: *const T, pbInitData: ?*const u8, cb: u32, bstrInitDataType: ?BSTR) void {
                return @as(*const IMFMediaEngineEMENotify.VTable, @ptrCast(self.vtable)).Encrypted(@as(*const IMFMediaEngineEMENotify, @ptrCast(self)), pbInitData, cb, bstrInitDataType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineEMENotify_WaitingForKey(self: *const T) void {
                return @as(*const IMFMediaEngineEMENotify.VTable, @ptrCast(self.vtable)).WaitingForKey(@as(*const IMFMediaEngineEMENotify, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIAKEYS_REQUIREMENT = enum(i32) {
    REQUIRED = 1,
    OPTIONAL = 2,
    NOT_ALLOWED = 3,
};
pub const MF_MEDIAKEYS_REQUIREMENT_REQUIRED = MF_MEDIAKEYS_REQUIREMENT.REQUIRED;
pub const MF_MEDIAKEYS_REQUIREMENT_OPTIONAL = MF_MEDIAKEYS_REQUIREMENT.OPTIONAL;
pub const MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED = MF_MEDIAKEYS_REQUIREMENT.NOT_ALLOWED;

const IID_IMFMediaKeySessionNotify2_Value = Guid.initString("c3a9e92a-da88-46b0-a110-6cf953026cb9");
pub const IID_IMFMediaKeySessionNotify2 = &IID_IMFMediaKeySessionNotify2_Value;
pub const IMFMediaKeySessionNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaKeySessionNotify.VTable,
        KeyMessage2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySessionNotify2,
                eMessageType: MF_MEDIAKEYSESSION_MESSAGETYPE,
                destinationURL: ?BSTR,
                // TODO: what to do with BytesParamIndex 3?
                pbMessage: ?*const u8,
                cbMessage: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaKeySessionNotify2,
                eMessageType: MF_MEDIAKEYSESSION_MESSAGETYPE,
                destinationURL: ?BSTR,
                // TODO: what to do with BytesParamIndex 3?
                pbMessage: ?*const u8,
                cbMessage: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        KeyStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySessionNotify2,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFMediaKeySessionNotify2,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaKeySessionNotify.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySessionNotify2_KeyMessage2(self: *const T, eMessageType: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationURL: ?BSTR, pbMessage: ?*const u8, cbMessage: u32) void {
                return @as(*const IMFMediaKeySessionNotify2.VTable, @ptrCast(self.vtable)).KeyMessage2(@as(*const IMFMediaKeySessionNotify2, @ptrCast(self)), eMessageType, destinationURL, pbMessage, cbMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySessionNotify2_KeyStatusChange(self: *const T) void {
                return @as(*const IMFMediaKeySessionNotify2.VTable, @ptrCast(self.vtable)).KeyStatusChange(@as(*const IMFMediaKeySessionNotify2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeySystemAccess_Value = Guid.initString("aec63fda-7a97-4944-b35c-6c6df8085cc3");
pub const IID_IMFMediaKeySystemAccess = &IID_IMFMediaKeySystemAccess_Value;
pub const IMFMediaKeySystemAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMediaKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySystemAccess,
                pCdmCustomConfig: ?*IPropertyStore,
                ppKeys: ?*?*IMFMediaKeys2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySystemAccess,
                pCdmCustomConfig: ?*IPropertyStore,
                ppKeys: ?*?*IMFMediaKeys2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportedConfiguration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeySystemAccess,
                ppSupportedConfiguration: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeySystemAccess,
                ppSupportedConfiguration: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeySystem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeySystemAccess,
                pKeySystem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeySystemAccess,
                pKeySystem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySystemAccess_CreateMediaKeys(self: *const T, pCdmCustomConfig: ?*IPropertyStore, ppKeys: ?*?*IMFMediaKeys2) HRESULT {
                return @as(*const IMFMediaKeySystemAccess.VTable, @ptrCast(self.vtable)).CreateMediaKeys(@as(*const IMFMediaKeySystemAccess, @ptrCast(self)), pCdmCustomConfig, ppKeys);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySystemAccess_get_SupportedConfiguration(self: *const T, ppSupportedConfiguration: ?*?*IPropertyStore) HRESULT {
                return @as(*const IMFMediaKeySystemAccess.VTable, @ptrCast(self.vtable)).get_SupportedConfiguration(@as(*const IMFMediaKeySystemAccess, @ptrCast(self)), ppSupportedConfiguration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySystemAccess_get_KeySystem(self: *const T, pKeySystem: ?*?BSTR) HRESULT {
                return @as(*const IMFMediaKeySystemAccess.VTable, @ptrCast(self.vtable)).get_KeySystem(@as(*const IMFMediaKeySystemAccess, @ptrCast(self)), pKeySystem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineClassFactory3_Value = Guid.initString("3787614f-65f7-4003-b673-ead8293a0e60");
pub const IID_IMFMediaEngineClassFactory3 = &IID_IMFMediaEngineClassFactory3_Value;
pub const IMFMediaEngineClassFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMediaKeySystemAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactory3,
                keySystem: ?BSTR,
                ppSupportedConfigurationsArray: [*]?*IPropertyStore,
                uSize: u32,
                ppKeyAccess: ?*?*IMFMediaKeySystemAccess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactory3,
                keySystem: ?BSTR,
                ppSupportedConfigurationsArray: [*]?*IPropertyStore,
                uSize: u32,
                ppKeyAccess: ?*?*IMFMediaKeySystemAccess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactory3_CreateMediaKeySystemAccess(self: *const T, keySystem: ?BSTR, ppSupportedConfigurationsArray: [*]?*IPropertyStore, uSize: u32, ppKeyAccess: ?*?*IMFMediaKeySystemAccess) HRESULT {
                return @as(*const IMFMediaEngineClassFactory3.VTable, @ptrCast(self.vtable)).CreateMediaKeySystemAccess(@as(*const IMFMediaEngineClassFactory3, @ptrCast(self)), keySystem, ppSupportedConfigurationsArray, uSize, ppKeyAccess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeys2_Value = Guid.initString("45892507-ad66-4de2-83a2-acbb13cd8d43");
pub const IID_IMFMediaKeys2 = &IID_IMFMediaKeys2_Value;
pub const IMFMediaKeys2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaKeys.VTable,
        CreateSession2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeys2,
                eSessionType: MF_MEDIAKEYSESSION_TYPE,
                pMFMediaKeySessionNotify2: ?*IMFMediaKeySessionNotify2,
                ppSession: ?*?*IMFMediaKeySession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeys2,
                eSessionType: MF_MEDIAKEYSESSION_TYPE,
                pMFMediaKeySessionNotify2: ?*IMFMediaKeySessionNotify2,
                ppSession: ?*?*IMFMediaKeySession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetServerCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeys2,
                // TODO: what to do with BytesParamIndex 1?
                pbServerCertificate: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeys2,
                // TODO: what to do with BytesParamIndex 1?
                pbServerCertificate: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDOMException: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeys2,
                systemCode: HRESULT,
                code: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeys2,
                systemCode: HRESULT,
                code: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaKeys.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys2_CreateSession2(self: *const T, eSessionType: MF_MEDIAKEYSESSION_TYPE, pMFMediaKeySessionNotify2: ?*IMFMediaKeySessionNotify2, ppSession: ?*?*IMFMediaKeySession2) HRESULT {
                return @as(*const IMFMediaKeys2.VTable, @ptrCast(self.vtable)).CreateSession2(@as(*const IMFMediaKeys2, @ptrCast(self)), eSessionType, pMFMediaKeySessionNotify2, ppSession);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys2_SetServerCertificate(self: *const T, pbServerCertificate: ?*const u8, cb: u32) HRESULT {
                return @as(*const IMFMediaKeys2.VTable, @ptrCast(self.vtable)).SetServerCertificate(@as(*const IMFMediaKeys2, @ptrCast(self)), pbServerCertificate, cb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeys2_GetDOMException(self: *const T, systemCode: HRESULT, code: ?*HRESULT) HRESULT {
                return @as(*const IMFMediaKeys2.VTable, @ptrCast(self.vtable)).GetDOMException(@as(*const IMFMediaKeys2, @ptrCast(self)), systemCode, code);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeySession2_Value = Guid.initString("e9707e05-6d55-4636-b185-3de21210bd75");
pub const IID_IMFMediaKeySession2 = &IID_IMFMediaKeySession2_Value;
pub const IMFMediaKeySession2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaKeySession.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyStatuses: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeySession2,
                pKeyStatusesArray: ?*?*MFMediaKeyStatus,
                puSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeySession2,
                pKeyStatusesArray: ?*?*MFMediaKeyStatus,
                puSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession2,
                bstrSessionId: ?BSTR,
                pfLoaded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession2,
                bstrSessionId: ?BSTR,
                pfLoaded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession2,
                initDataType: ?BSTR,
                // TODO: what to do with BytesParamIndex 2?
                pbInitData: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession2,
                initDataType: ?BSTR,
                // TODO: what to do with BytesParamIndex 2?
                pbInitData: ?*const u8,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Expiration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IMFMediaKeySession2,
                dblExpiration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IMFMediaKeySession2,
                dblExpiration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaKeySession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaKeySession2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaKeySession.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession2_get_KeyStatuses(self: *const T, pKeyStatusesArray: ?*?*MFMediaKeyStatus, puSize: ?*u32) HRESULT {
                return @as(*const IMFMediaKeySession2.VTable, @ptrCast(self.vtable)).get_KeyStatuses(@as(*const IMFMediaKeySession2, @ptrCast(self)), pKeyStatusesArray, puSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession2_Load(self: *const T, bstrSessionId: ?BSTR, pfLoaded: ?*BOOL) HRESULT {
                return @as(*const IMFMediaKeySession2.VTable, @ptrCast(self.vtable)).Load(@as(*const IMFMediaKeySession2, @ptrCast(self)), bstrSessionId, pfLoaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession2_GenerateRequest(self: *const T, initDataType: ?BSTR, pbInitData: ?*const u8, cb: u32) HRESULT {
                return @as(*const IMFMediaKeySession2.VTable, @ptrCast(self.vtable)).GenerateRequest(@as(*const IMFMediaKeySession2, @ptrCast(self)), initDataType, pbInitData, cb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession2_get_Expiration(self: *const T, dblExpiration: ?*f64) HRESULT {
                return @as(*const IMFMediaKeySession2.VTable, @ptrCast(self.vtable)).get_Expiration(@as(*const IMFMediaKeySession2, @ptrCast(self)), dblExpiration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession2_Remove(self: *const T) HRESULT {
                return @as(*const IMFMediaKeySession2.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMFMediaKeySession2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaKeySession2_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFMediaKeySession2.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFMediaKeySession2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineClassFactory4_Value = Guid.initString("fbe256c1-43cf-4a9b-8cb8-ce8632a34186");
pub const IID_IMFMediaEngineClassFactory4 = &IID_IMFMediaEngineClassFactory4_Value;
pub const IMFMediaEngineClassFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContentDecryptionModuleFactory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaEngineClassFactory4,
                keySystem: ?[*:0]const u16,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaEngineClassFactory4,
                keySystem: ?[*:0]const u16,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaEngineClassFactory4_CreateContentDecryptionModuleFactory(self: *const T, keySystem: ?[*:0]const u16, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFMediaEngineClassFactory4.VTable, @ptrCast(self.vtable)).CreateContentDecryptionModuleFactory(@as(*const IMFMediaEngineClassFactory4, @ptrCast(self)), keySystem, riid, ppvObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFDLNASinkInit_Value = Guid.initString("0c012799-1b61-4c10-bda9-04445be5f561");
pub const IID_IMFDLNASinkInit = &IID_IMFDLNASinkInit_Value;
pub const IMFDLNASinkInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDLNASinkInit,
                pByteStream: ?*IMFByteStream,
                fPal: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDLNASinkInit,
                pByteStream: ?*IMFByteStream,
                fPal: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDLNASinkInit_Initialize(self: *const T, pByteStream: ?*IMFByteStream, fPal: BOOL) HRESULT {
                return @as(*const IMFDLNASinkInit.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMFDLNASinkInit, @ptrCast(self)), pByteStream, fPal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFMPEG2DLNASINKSTATS = extern struct {
    cBytesWritten: u64,
    fPAL: BOOL,
    fccVideo: u32,
    dwVideoWidth: u32,
    dwVideoHeight: u32,
    cVideoFramesReceived: u64,
    cVideoFramesEncoded: u64,
    cVideoFramesSkipped: u64,
    cBlackVideoFramesEncoded: u64,
    cVideoFramesDuplicated: u64,
    cAudioSamplesPerSec: u32,
    cAudioChannels: u32,
    cAudioBytesReceived: u64,
    cAudioFramesEncoded: u64,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFReadWriteClassFactory_Value = Guid.initString("e7fe2e12-661c-40da-92f9-4f002ab67627");
pub const IID_IMFReadWriteClassFactory = &IID_IMFReadWriteClassFactory_Value;
pub const IMFReadWriteClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstanceFromURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFReadWriteClassFactory,
                clsid: ?*const Guid,
                pwszURL: ?[*:0]const u16,
                pAttributes: ?*IMFAttributes,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFReadWriteClassFactory,
                clsid: ?*const Guid,
                pwszURL: ?[*:0]const u16,
                pAttributes: ?*IMFAttributes,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstanceFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFReadWriteClassFactory,
                clsid: ?*const Guid,
                punkObject: ?*IUnknown,
                pAttributes: ?*IMFAttributes,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFReadWriteClassFactory,
                clsid: ?*const Guid,
                punkObject: ?*IUnknown,
                pAttributes: ?*IMFAttributes,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFReadWriteClassFactory_CreateInstanceFromURL(self: *const T, clsid: ?*const Guid, pwszURL: ?[*:0]const u16, pAttributes: ?*IMFAttributes, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFReadWriteClassFactory.VTable, @ptrCast(self.vtable)).CreateInstanceFromURL(@as(*const IMFReadWriteClassFactory, @ptrCast(self)), clsid, pwszURL, pAttributes, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFReadWriteClassFactory_CreateInstanceFromObject(self: *const T, clsid: ?*const Guid, punkObject: ?*IUnknown, pAttributes: ?*IMFAttributes, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFReadWriteClassFactory.VTable, @ptrCast(self.vtable)).CreateInstanceFromObject(@as(*const IMFReadWriteClassFactory, @ptrCast(self)), clsid, punkObject, pAttributes, riid, ppvObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_SOURCE_READER_FLAG = enum(i32) {
    ERROR = 1,
    ENDOFSTREAM = 2,
    NEWSTREAM = 4,
    NATIVEMEDIATYPECHANGED = 16,
    CURRENTMEDIATYPECHANGED = 32,
    STREAMTICK = 256,
    ALLEFFECTSREMOVED = 512,
};
pub const MF_SOURCE_READERF_ERROR = MF_SOURCE_READER_FLAG.ERROR;
pub const MF_SOURCE_READERF_ENDOFSTREAM = MF_SOURCE_READER_FLAG.ENDOFSTREAM;
pub const MF_SOURCE_READERF_NEWSTREAM = MF_SOURCE_READER_FLAG.NEWSTREAM;
pub const MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED = MF_SOURCE_READER_FLAG.NATIVEMEDIATYPECHANGED;
pub const MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = MF_SOURCE_READER_FLAG.CURRENTMEDIATYPECHANGED;
pub const MF_SOURCE_READERF_STREAMTICK = MF_SOURCE_READER_FLAG.STREAMTICK;
pub const MF_SOURCE_READERF_ALLEFFECTSREMOVED = MF_SOURCE_READER_FLAG.ALLEFFECTSREMOVED;

pub const MF_SOURCE_READER_CONTROL_FLAG = enum(i32) {
    N = 1,
};
pub const MF_SOURCE_READER_CONTROLF_DRAIN = MF_SOURCE_READER_CONTROL_FLAG.N;

pub const MF_SOURCE_READER_CONSTANTS = enum(i32) {
    INVALID_STREAM_INDEX = -1,
    ALL_STREAMS = -2,
    // ANY_STREAM = -2, this enum value conflicts with ALL_STREAMS
    FIRST_AUDIO_STREAM = -3,
    FIRST_VIDEO_STREAM = -4,
    // MEDIASOURCE = -1, this enum value conflicts with INVALID_STREAM_INDEX
};
pub const MF_SOURCE_READER_INVALID_STREAM_INDEX = MF_SOURCE_READER_CONSTANTS.INVALID_STREAM_INDEX;
pub const MF_SOURCE_READER_ALL_STREAMS = MF_SOURCE_READER_CONSTANTS.ALL_STREAMS;
pub const MF_SOURCE_READER_ANY_STREAM = MF_SOURCE_READER_CONSTANTS.ALL_STREAMS;
pub const MF_SOURCE_READER_FIRST_AUDIO_STREAM = MF_SOURCE_READER_CONSTANTS.FIRST_AUDIO_STREAM;
pub const MF_SOURCE_READER_FIRST_VIDEO_STREAM = MF_SOURCE_READER_CONSTANTS.FIRST_VIDEO_STREAM;
pub const MF_SOURCE_READER_MEDIASOURCE = MF_SOURCE_READER_CONSTANTS.INVALID_STREAM_INDEX;

pub const MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS = enum(i32) {
    X = -1,
};
pub const MF_SOURCE_READER_CURRENT_TYPE_INDEX = MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS.X;

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFSourceReader_Value = Guid.initString("70ae66f2-c809-4e4f-8915-bdcb406b7993");
pub const IID_IMFSourceReader = &IID_IMFSourceReader_Value;
pub const IMFSourceReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                pfSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                pfSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                fSelected: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                fSelected: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNativeMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                dwMediaTypeIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                dwMediaTypeIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                ppMediaType: ?*?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                pdwReserved: ?*u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                pdwReserved: ?*u32,
                pMediaType: ?*IMFMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                guidTimeFormat: ?*const Guid,
                varPosition: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                guidTimeFormat: ?*const Guid,
                varPosition: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                dwControlFlags: u32,
                pdwActualStreamIndex: ?*u32,
                pdwStreamFlags: ?*u32,
                pllTimestamp: ?*i64,
                ppSample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                dwControlFlags: u32,
                pdwActualStreamIndex: ?*u32,
                pdwStreamFlags: ?*u32,
                pllTimestamp: ?*i64,
                ppSample: ?*?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentationAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                guidAttribute: ?*const Guid,
                pvarAttribute: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReader,
                dwStreamIndex: u32,
                guidAttribute: ?*const Guid,
                pvarAttribute: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_GetStreamSelection(self: *const T, dwStreamIndex: u32, pfSelected: ?*BOOL) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).GetStreamSelection(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, pfSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_SetStreamSelection(self: *const T, dwStreamIndex: u32, fSelected: BOOL) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).SetStreamSelection(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, fSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_GetNativeMediaType(self: *const T, dwStreamIndex: u32, dwMediaTypeIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).GetNativeMediaType(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, dwMediaTypeIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_GetCurrentMediaType(self: *const T, dwStreamIndex: u32, ppMediaType: ?*?*IMFMediaType) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).GetCurrentMediaType(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, ppMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_SetCurrentMediaType(self: *const T, dwStreamIndex: u32, pdwReserved: ?*u32, pMediaType: ?*IMFMediaType) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).SetCurrentMediaType(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, pdwReserved, pMediaType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_SetCurrentPosition(self: *const T, guidTimeFormat: ?*const Guid, varPosition: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).SetCurrentPosition(@as(*const IMFSourceReader, @ptrCast(self)), guidTimeFormat, varPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_ReadSample(self: *const T, dwStreamIndex: u32, dwControlFlags: u32, pdwActualStreamIndex: ?*u32, pdwStreamFlags: ?*u32, pllTimestamp: ?*i64, ppSample: ?*?*IMFSample) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).ReadSample(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, dwControlFlags, pdwActualStreamIndex, pdwStreamFlags, pllTimestamp, ppSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_Flush(self: *const T, dwStreamIndex: u32) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_GetServiceForStream(self: *const T, dwStreamIndex: u32, guidService: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).GetServiceForStream(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, guidService, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReader_GetPresentationAttribute(self: *const T, dwStreamIndex: u32, guidAttribute: ?*const Guid, pvarAttribute: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFSourceReader.VTable, @ptrCast(self.vtable)).GetPresentationAttribute(@as(*const IMFSourceReader, @ptrCast(self)), dwStreamIndex, guidAttribute, pvarAttribute);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSourceReaderEx_Value = Guid.initString("7b981cf0-560e-4116-9875-b099895f23d7");
pub const IID_IMFSourceReaderEx = &IID_IMFSourceReaderEx_Value;
pub const IMFSourceReaderEx = extern struct {
    pub const VTable = extern struct {
        base: IMFSourceReader.VTable,
        SetNativeMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
                pdwStreamFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
                pMediaType: ?*IMFMediaType,
                pdwStreamFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTransformForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
                pTransformOrActivate: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
                pTransformOrActivate: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllTransformsForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransformForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
                dwTransformIndex: u32,
                pGuidCategory: ?*Guid,
                ppTransform: ?*?*IMFTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderEx,
                dwStreamIndex: u32,
                dwTransformIndex: u32,
                pGuidCategory: ?*Guid,
                ppTransform: ?*?*IMFTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFSourceReader.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderEx_SetNativeMediaType(self: *const T, dwStreamIndex: u32, pMediaType: ?*IMFMediaType, pdwStreamFlags: ?*u32) HRESULT {
                return @as(*const IMFSourceReaderEx.VTable, @ptrCast(self.vtable)).SetNativeMediaType(@as(*const IMFSourceReaderEx, @ptrCast(self)), dwStreamIndex, pMediaType, pdwStreamFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderEx_AddTransformForStream(self: *const T, dwStreamIndex: u32, pTransformOrActivate: ?*IUnknown) HRESULT {
                return @as(*const IMFSourceReaderEx.VTable, @ptrCast(self.vtable)).AddTransformForStream(@as(*const IMFSourceReaderEx, @ptrCast(self)), dwStreamIndex, pTransformOrActivate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderEx_RemoveAllTransformsForStream(self: *const T, dwStreamIndex: u32) HRESULT {
                return @as(*const IMFSourceReaderEx.VTable, @ptrCast(self.vtable)).RemoveAllTransformsForStream(@as(*const IMFSourceReaderEx, @ptrCast(self)), dwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderEx_GetTransformForStream(self: *const T, dwStreamIndex: u32, dwTransformIndex: u32, pGuidCategory: ?*Guid, ppTransform: ?*?*IMFTransform) HRESULT {
                return @as(*const IMFSourceReaderEx.VTable, @ptrCast(self.vtable)).GetTransformForStream(@as(*const IMFSourceReaderEx, @ptrCast(self)), dwStreamIndex, dwTransformIndex, pGuidCategory, ppTransform);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFSourceReaderCallback_Value = Guid.initString("deec8d99-fa1d-4d82-84c2-2c8969944867");
pub const IID_IMFSourceReaderCallback = &IID_IMFSourceReaderCallback_Value;
pub const IMFSourceReaderCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnReadSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderCallback,
                hrStatus: HRESULT,
                dwStreamIndex: u32,
                dwStreamFlags: u32,
                llTimestamp: i64,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderCallback,
                hrStatus: HRESULT,
                dwStreamIndex: u32,
                dwStreamFlags: u32,
                llTimestamp: i64,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFlush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderCallback,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderCallback,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderCallback,
                dwStreamIndex: u32,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderCallback,
                dwStreamIndex: u32,
                pEvent: ?*IMFMediaEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderCallback_OnReadSample(self: *const T, hrStatus: HRESULT, dwStreamIndex: u32, dwStreamFlags: u32, llTimestamp: i64, pSample: ?*IMFSample) HRESULT {
                return @as(*const IMFSourceReaderCallback.VTable, @ptrCast(self.vtable)).OnReadSample(@as(*const IMFSourceReaderCallback, @ptrCast(self)), hrStatus, dwStreamIndex, dwStreamFlags, llTimestamp, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderCallback_OnFlush(self: *const T, dwStreamIndex: u32) HRESULT {
                return @as(*const IMFSourceReaderCallback.VTable, @ptrCast(self.vtable)).OnFlush(@as(*const IMFSourceReaderCallback, @ptrCast(self)), dwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderCallback_OnEvent(self: *const T, dwStreamIndex: u32, pEvent: ?*IMFMediaEvent) HRESULT {
                return @as(*const IMFSourceReaderCallback.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IMFSourceReaderCallback, @ptrCast(self)), dwStreamIndex, pEvent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceReaderCallback2_Value = Guid.initString("cf839fe6-8c2a-4dd2-b6ea-c22d6961af05");
pub const IID_IMFSourceReaderCallback2 = &IID_IMFSourceReaderCallback2_Value;
pub const IMFSourceReaderCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFSourceReaderCallback.VTable,
        OnTransformChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderCallback2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderCallback2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStreamError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSourceReaderCallback2,
                dwStreamIndex: u32,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSourceReaderCallback2,
                dwStreamIndex: u32,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFSourceReaderCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderCallback2_OnTransformChange(self: *const T) HRESULT {
                return @as(*const IMFSourceReaderCallback2.VTable, @ptrCast(self.vtable)).OnTransformChange(@as(*const IMFSourceReaderCallback2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSourceReaderCallback2_OnStreamError(self: *const T, dwStreamIndex: u32, hrStatus: HRESULT) HRESULT {
                return @as(*const IMFSourceReaderCallback2.VTable, @ptrCast(self.vtable)).OnStreamError(@as(*const IMFSourceReaderCallback2, @ptrCast(self)), dwStreamIndex, hrStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_SINK_WRITER_CONSTANTS = enum(u32) {
    INVALID_STREAM_INDEX = 4294967295,
    ALL_STREAMS = 4294967294,
    // MEDIASINK = 4294967295, this enum value conflicts with INVALID_STREAM_INDEX
};
pub const MF_SINK_WRITER_INVALID_STREAM_INDEX = MF_SINK_WRITER_CONSTANTS.INVALID_STREAM_INDEX;
pub const MF_SINK_WRITER_ALL_STREAMS = MF_SINK_WRITER_CONSTANTS.ALL_STREAMS;
pub const MF_SINK_WRITER_MEDIASINK = MF_SINK_WRITER_CONSTANTS.INVALID_STREAM_INDEX;

pub const MF_SINK_WRITER_STATISTICS = extern struct {
    cb: u32,
    llLastTimestampReceived: i64,
    llLastTimestampEncoded: i64,
    llLastTimestampProcessed: i64,
    llLastStreamTickReceived: i64,
    llLastSinkSampleRequest: i64,
    qwNumSamplesReceived: u64,
    qwNumSamplesEncoded: u64,
    qwNumSamplesProcessed: u64,
    qwNumStreamTicksReceived: u64,
    dwByteCountQueued: u32,
    qwByteCountProcessed: u64,
    dwNumOutstandingSinkSampleRequests: u32,
    dwAverageSampleRateReceived: u32,
    dwAverageSampleRateEncoded: u32,
    dwAverageSampleRateProcessed: u32,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFSinkWriter_Value = Guid.initString("3137f1cd-fe5e-4805-a5d8-fb477448cb3d");
pub const IID_IMFSinkWriter = &IID_IMFSinkWriter_Value;
pub const IMFSinkWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                pTargetMediaType: ?*IMFMediaType,
                pdwStreamIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                pTargetMediaType: ?*IMFMediaType,
                pdwStreamIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pInputMediaType: ?*IMFMediaType,
                pEncodingParameters: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pInputMediaType: ?*IMFMediaType,
                pEncodingParameters: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginWriting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pSample: ?*IMFSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendStreamTick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                llTimestamp: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                llTimestamp: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlaceMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyEndOfSegment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pStats: ?*MF_SINK_WRITER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriter,
                dwStreamIndex: u32,
                pStats: ?*MF_SINK_WRITER_STATISTICS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_AddStream(self: *const T, pTargetMediaType: ?*IMFMediaType, pdwStreamIndex: ?*u32) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).AddStream(@as(*const IMFSinkWriter, @ptrCast(self)), pTargetMediaType, pdwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_SetInputMediaType(self: *const T, dwStreamIndex: u32, pInputMediaType: ?*IMFMediaType, pEncodingParameters: ?*IMFAttributes) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).SetInputMediaType(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex, pInputMediaType, pEncodingParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_BeginWriting(self: *const T) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).BeginWriting(@as(*const IMFSinkWriter, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_WriteSample(self: *const T, dwStreamIndex: u32, pSample: ?*IMFSample) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).WriteSample(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex, pSample);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_SendStreamTick(self: *const T, dwStreamIndex: u32, llTimestamp: i64) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).SendStreamTick(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex, llTimestamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_PlaceMarker(self: *const T, dwStreamIndex: u32, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).PlaceMarker(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex, pvContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_NotifyEndOfSegment(self: *const T, dwStreamIndex: u32) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).NotifyEndOfSegment(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_Flush(self: *const T, dwStreamIndex: u32) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_Finalize(self: *const T) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).Finalize(@as(*const IMFSinkWriter, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_GetServiceForStream(self: *const T, dwStreamIndex: u32, guidService: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).GetServiceForStream(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex, guidService, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriter_GetStatistics(self: *const T, dwStreamIndex: u32, pStats: ?*MF_SINK_WRITER_STATISTICS) HRESULT {
                return @as(*const IMFSinkWriter.VTable, @ptrCast(self.vtable)).GetStatistics(@as(*const IMFSinkWriter, @ptrCast(self)), dwStreamIndex, pStats);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSinkWriterEx_Value = Guid.initString("588d72ab-5bc1-496a-8714-b70617141b25");
pub const IID_IMFSinkWriterEx = &IID_IMFSinkWriterEx_Value;
pub const IMFSinkWriterEx = extern struct {
    pub const VTable = extern struct {
        base: IMFSinkWriter.VTable,
        GetTransformForStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterEx,
                dwStreamIndex: u32,
                dwTransformIndex: u32,
                pGuidCategory: ?*Guid,
                ppTransform: ?*?*IMFTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterEx,
                dwStreamIndex: u32,
                dwTransformIndex: u32,
                pGuidCategory: ?*Guid,
                ppTransform: ?*?*IMFTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFSinkWriter.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterEx_GetTransformForStream(self: *const T, dwStreamIndex: u32, dwTransformIndex: u32, pGuidCategory: ?*Guid, ppTransform: ?*?*IMFTransform) HRESULT {
                return @as(*const IMFSinkWriterEx.VTable, @ptrCast(self.vtable)).GetTransformForStream(@as(*const IMFSinkWriterEx, @ptrCast(self)), dwStreamIndex, dwTransformIndex, pGuidCategory, ppTransform);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IMFSinkWriterEncoderConfig_Value = Guid.initString("17c3779e-3cde-4ede-8c60-3899f5f53ad6");
pub const IID_IMFSinkWriterEncoderConfig = &IID_IMFSinkWriterEncoderConfig_Value;
pub const IMFSinkWriterEncoderConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTargetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterEncoderConfig,
                dwStreamIndex: u32,
                pTargetMediaType: ?*IMFMediaType,
                pEncodingParameters: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterEncoderConfig,
                dwStreamIndex: u32,
                pTargetMediaType: ?*IMFMediaType,
                pEncodingParameters: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlaceEncodingParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterEncoderConfig,
                dwStreamIndex: u32,
                pEncodingParameters: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterEncoderConfig,
                dwStreamIndex: u32,
                pEncodingParameters: ?*IMFAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterEncoderConfig_SetTargetMediaType(self: *const T, dwStreamIndex: u32, pTargetMediaType: ?*IMFMediaType, pEncodingParameters: ?*IMFAttributes) HRESULT {
                return @as(*const IMFSinkWriterEncoderConfig.VTable, @ptrCast(self.vtable)).SetTargetMediaType(@as(*const IMFSinkWriterEncoderConfig, @ptrCast(self)), dwStreamIndex, pTargetMediaType, pEncodingParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterEncoderConfig_PlaceEncodingParameters(self: *const T, dwStreamIndex: u32, pEncodingParameters: ?*IMFAttributes) HRESULT {
                return @as(*const IMFSinkWriterEncoderConfig.VTable, @ptrCast(self.vtable)).PlaceEncodingParameters(@as(*const IMFSinkWriterEncoderConfig, @ptrCast(self)), dwStreamIndex, pEncodingParameters);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFSinkWriterCallback_Value = Guid.initString("666f76de-33d2-41b9-a458-29ed0a972c58");
pub const IID_IMFSinkWriterCallback = &IID_IMFSinkWriterCallback_Value;
pub const IMFSinkWriterCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFinalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterCallback,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterCallback,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterCallback,
                dwStreamIndex: u32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterCallback,
                dwStreamIndex: u32,
                pvContext: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterCallback_OnFinalize(self: *const T, hrStatus: HRESULT) HRESULT {
                return @as(*const IMFSinkWriterCallback.VTable, @ptrCast(self.vtable)).OnFinalize(@as(*const IMFSinkWriterCallback, @ptrCast(self)), hrStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterCallback_OnMarker(self: *const T, dwStreamIndex: u32, pvContext: ?*anyopaque) HRESULT {
                return @as(*const IMFSinkWriterCallback.VTable, @ptrCast(self.vtable)).OnMarker(@as(*const IMFSinkWriterCallback, @ptrCast(self)), dwStreamIndex, pvContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSinkWriterCallback2_Value = Guid.initString("2456bd58-c067-4513-84fe-8d0c88ffdc61");
pub const IID_IMFSinkWriterCallback2 = &IID_IMFSinkWriterCallback2_Value;
pub const IMFSinkWriterCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFSinkWriterCallback.VTable,
        OnTransformChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterCallback2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterCallback2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStreamError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSinkWriterCallback2,
                dwStreamIndex: u32,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSinkWriterCallback2,
                dwStreamIndex: u32,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFSinkWriterCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterCallback2_OnTransformChange(self: *const T) HRESULT {
                return @as(*const IMFSinkWriterCallback2.VTable, @ptrCast(self.vtable)).OnTransformChange(@as(*const IMFSinkWriterCallback2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSinkWriterCallback2_OnStreamError(self: *const T, dwStreamIndex: u32, hrStatus: HRESULT) HRESULT {
                return @as(*const IMFSinkWriterCallback2.VTable, @ptrCast(self.vtable)).OnStreamError(@as(*const IMFSinkWriterCallback2, @ptrCast(self)), dwStreamIndex, hrStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoPositionMapper_Value = Guid.initString("1f6a9f17-e70b-4e24-8ae4-0b2c3ba7a4ae");
pub const IID_IMFVideoPositionMapper = &IID_IMFVideoPositionMapper_Value;
pub const IMFVideoPositionMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapOutputCoordinateToInputStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoPositionMapper,
                xOut: f32,
                yOut: f32,
                dwOutputStreamIndex: u32,
                dwInputStreamIndex: u32,
                pxIn: ?*f32,
                pyIn: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoPositionMapper,
                xOut: f32,
                yOut: f32,
                dwOutputStreamIndex: u32,
                dwInputStreamIndex: u32,
                pxIn: ?*f32,
                pyIn: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoPositionMapper_MapOutputCoordinateToInputStream(self: *const T, xOut: f32, yOut: f32, dwOutputStreamIndex: u32, dwInputStreamIndex: u32, pxIn: ?*f32, pyIn: ?*f32) HRESULT {
                return @as(*const IMFVideoPositionMapper.VTable, @ptrCast(self.vtable)).MapOutputCoordinateToInputStream(@as(*const IMFVideoPositionMapper, @ptrCast(self)), xOut, yOut, dwOutputStreamIndex, dwInputStreamIndex, pxIn, pyIn);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoDeviceID_Value = Guid.initString("a38d9567-5a9c-4f3c-b293-8eb415b279ba");
pub const IID_IMFVideoDeviceID = &IID_IMFVideoDeviceID_Value;
pub const IMFVideoDeviceID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDeviceID,
                pDeviceID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDeviceID,
                pDeviceID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDeviceID_GetDeviceID(self: *const T, pDeviceID: ?*Guid) HRESULT {
                return @as(*const IMFVideoDeviceID.VTable, @ptrCast(self.vtable)).GetDeviceID(@as(*const IMFVideoDeviceID, @ptrCast(self)), pDeviceID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoAspectRatioMode = enum(i32) {
    None = 0,
    PreservePicture = 1,
    PreservePixel = 2,
    NonLinearStretch = 4,
    Mask = 7,
};
pub const MFVideoARMode_None = MFVideoAspectRatioMode.None;
pub const MFVideoARMode_PreservePicture = MFVideoAspectRatioMode.PreservePicture;
pub const MFVideoARMode_PreservePixel = MFVideoAspectRatioMode.PreservePixel;
pub const MFVideoARMode_NonLinearStretch = MFVideoAspectRatioMode.NonLinearStretch;
pub const MFVideoARMode_Mask = MFVideoAspectRatioMode.Mask;

pub const MFVideoRenderPrefs = enum(i32) {
    DoNotRenderBorder = 1,
    DoNotClipToDevice = 2,
    AllowOutputThrottling = 4,
    ForceOutputThrottling = 8,
    ForceBatching = 16,
    AllowBatching = 32,
    ForceScaling = 64,
    AllowScaling = 128,
    DoNotRepaintOnStop = 256,
    Mask = 511,
};
pub const MFVideoRenderPrefs_DoNotRenderBorder = MFVideoRenderPrefs.DoNotRenderBorder;
pub const MFVideoRenderPrefs_DoNotClipToDevice = MFVideoRenderPrefs.DoNotClipToDevice;
pub const MFVideoRenderPrefs_AllowOutputThrottling = MFVideoRenderPrefs.AllowOutputThrottling;
pub const MFVideoRenderPrefs_ForceOutputThrottling = MFVideoRenderPrefs.ForceOutputThrottling;
pub const MFVideoRenderPrefs_ForceBatching = MFVideoRenderPrefs.ForceBatching;
pub const MFVideoRenderPrefs_AllowBatching = MFVideoRenderPrefs.AllowBatching;
pub const MFVideoRenderPrefs_ForceScaling = MFVideoRenderPrefs.ForceScaling;
pub const MFVideoRenderPrefs_AllowScaling = MFVideoRenderPrefs.AllowScaling;
pub const MFVideoRenderPrefs_DoNotRepaintOnStop = MFVideoRenderPrefs.DoNotRepaintOnStop;
pub const MFVideoRenderPrefs_Mask = MFVideoRenderPrefs.Mask;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoDisplayControl_Value = Guid.initString("a490b1e4-ab84-4d31-a1b2-181e03b1077a");
pub const IID_IMFVideoDisplayControl = &IID_IMFVideoDisplayControl_Value;
pub const IMFVideoDisplayControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pszVideo: ?*SIZE,
                pszARVideo: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pszVideo: ?*SIZE,
                pszARVideo: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdealVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pszMin: ?*SIZE,
                pszMax: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pszMin: ?*SIZE,
                pszMax: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pnrcSource: ?*const MFVideoNormalizedRect,
                prcDest: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pnrcSource: ?*const MFVideoNormalizedRect,
                prcDest: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pnrcSource: ?*MFVideoNormalizedRect,
                prcDest: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pnrcSource: ?*MFVideoNormalizedRect,
                prcDest: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                dwAspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                dwAspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pdwAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pdwAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                hwndVideo: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                hwndVideo: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                phwndVideo: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                phwndVideo: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RepaintVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pBih: ?*BITMAPINFOHEADER,
                pDib: [*]?*u8,
                pcbDib: ?*u32,
                pTimeStamp: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pBih: ?*BITMAPINFOHEADER,
                pDib: [*]?*u8,
                pcbDib: ?*u32,
                pTimeStamp: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                Clr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                Clr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pClr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pClr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pdwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pdwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFullscreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                fFullscreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                fFullscreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullscreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoDisplayControl,
                pfFullscreen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoDisplayControl,
                pfFullscreen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetNativeVideoSize(self: *const T, pszVideo: ?*SIZE, pszARVideo: ?*SIZE) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pszVideo, pszARVideo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetIdealVideoSize(self: *const T, pszMin: ?*SIZE, pszMax: ?*SIZE) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetIdealVideoSize(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pszMin, pszMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_SetVideoPosition(self: *const T, pnrcSource: ?*const MFVideoNormalizedRect, prcDest: ?*const RECT) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).SetVideoPosition(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pnrcSource, prcDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetVideoPosition(self: *const T, pnrcSource: ?*MFVideoNormalizedRect, prcDest: ?*RECT) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pnrcSource, prcDest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_SetAspectRatioMode(self: *const T, dwAspectRatioMode: u32) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IMFVideoDisplayControl, @ptrCast(self)), dwAspectRatioMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetAspectRatioMode(self: *const T, pdwAspectRatioMode: ?*u32) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pdwAspectRatioMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_SetVideoWindow(self: *const T, hwndVideo: ?HWND) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).SetVideoWindow(@as(*const IMFVideoDisplayControl, @ptrCast(self)), hwndVideo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetVideoWindow(self: *const T, phwndVideo: ?*?HWND) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetVideoWindow(@as(*const IMFVideoDisplayControl, @ptrCast(self)), phwndVideo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_RepaintVideo(self: *const T) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).RepaintVideo(@as(*const IMFVideoDisplayControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetCurrentImage(self: *const T, pBih: ?*BITMAPINFOHEADER, pDib: [*]?*u8, pcbDib: ?*u32, pTimeStamp: ?*i64) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pBih, pDib, pcbDib, pTimeStamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_SetBorderColor(self: *const T, Clr: u32) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IMFVideoDisplayControl, @ptrCast(self)), Clr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetBorderColor(self: *const T, pClr: ?*u32) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetBorderColor(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pClr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IMFVideoDisplayControl, @ptrCast(self)), dwRenderFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetRenderingPrefs(self: *const T, pdwRenderFlags: ?*u32) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pdwRenderFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_SetFullscreen(self: *const T, fFullscreen: BOOL) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).SetFullscreen(@as(*const IMFVideoDisplayControl, @ptrCast(self)), fFullscreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoDisplayControl_GetFullscreen(self: *const T, pfFullscreen: ?*BOOL) HRESULT {
                return @as(*const IMFVideoDisplayControl.VTable, @ptrCast(self.vtable)).GetFullscreen(@as(*const IMFVideoDisplayControl, @ptrCast(self)), pfFullscreen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFVP_MESSAGE_TYPE = enum(i32) {
    FLUSH = 0,
    INVALIDATEMEDIATYPE = 1,
    PROCESSINPUTNOTIFY = 2,
    BEGINSTREAMING = 3,
    ENDSTREAMING = 4,
    ENDOFSTREAM = 5,
    STEP = 6,
    CANCELSTEP = 7,
};
pub const MFVP_MESSAGE_FLUSH = MFVP_MESSAGE_TYPE.FLUSH;
pub const MFVP_MESSAGE_INVALIDATEMEDIATYPE = MFVP_MESSAGE_TYPE.INVALIDATEMEDIATYPE;
pub const MFVP_MESSAGE_PROCESSINPUTNOTIFY = MFVP_MESSAGE_TYPE.PROCESSINPUTNOTIFY;
pub const MFVP_MESSAGE_BEGINSTREAMING = MFVP_MESSAGE_TYPE.BEGINSTREAMING;
pub const MFVP_MESSAGE_ENDSTREAMING = MFVP_MESSAGE_TYPE.ENDSTREAMING;
pub const MFVP_MESSAGE_ENDOFSTREAM = MFVP_MESSAGE_TYPE.ENDOFSTREAM;
pub const MFVP_MESSAGE_STEP = MFVP_MESSAGE_TYPE.STEP;
pub const MFVP_MESSAGE_CANCELSTEP = MFVP_MESSAGE_TYPE.CANCELSTEP;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoPresenter_Value = Guid.initString("29aff080-182a-4a5d-af3b-448f3a6346cb");
pub const IID_IMFVideoPresenter = &IID_IMFVideoPresenter_Value;
pub const IMFVideoPresenter = extern struct {
    pub const VTable = extern struct {
        base: IMFClockStateSink.VTable,
        ProcessMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoPresenter,
                eMessage: MFVP_MESSAGE_TYPE,
                ulParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoPresenter,
                eMessage: MFVP_MESSAGE_TYPE,
                ulParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoPresenter,
                ppMediaType: ?*?*IMFVideoMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoPresenter,
                ppMediaType: ?*?*IMFVideoMediaType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFClockStateSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoPresenter_ProcessMessage(self: *const T, eMessage: MFVP_MESSAGE_TYPE, ulParam: usize) HRESULT {
                return @as(*const IMFVideoPresenter.VTable, @ptrCast(self.vtable)).ProcessMessage(@as(*const IMFVideoPresenter, @ptrCast(self)), eMessage, ulParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoPresenter_GetCurrentMediaType(self: *const T, ppMediaType: ?*?*IMFVideoMediaType) HRESULT {
                return @as(*const IMFVideoPresenter.VTable, @ptrCast(self.vtable)).GetCurrentMediaType(@as(*const IMFVideoPresenter, @ptrCast(self)), ppMediaType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFDesiredSample_Value = Guid.initString("56c294d0-753e-4260-8d61-a3d8820b1d54");
pub const IID_IMFDesiredSample = &IID_IMFDesiredSample_Value;
pub const IMFDesiredSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDesiredSampleTimeAndDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDesiredSample,
                phnsSampleTime: ?*i64,
                phnsSampleDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFDesiredSample,
                phnsSampleTime: ?*i64,
                phnsSampleDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDesiredSampleTimeAndDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDesiredSample,
                hnsSampleTime: i64,
                hnsSampleDuration: i64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFDesiredSample,
                hnsSampleTime: i64,
                hnsSampleDuration: i64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFDesiredSample,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFDesiredSample,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDesiredSample_GetDesiredSampleTimeAndDuration(self: *const T, phnsSampleTime: ?*i64, phnsSampleDuration: ?*i64) HRESULT {
                return @as(*const IMFDesiredSample.VTable, @ptrCast(self.vtable)).GetDesiredSampleTimeAndDuration(@as(*const IMFDesiredSample, @ptrCast(self)), phnsSampleTime, phnsSampleDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDesiredSample_SetDesiredSampleTimeAndDuration(self: *const T, hnsSampleTime: i64, hnsSampleDuration: i64) void {
                return @as(*const IMFDesiredSample.VTable, @ptrCast(self.vtable)).SetDesiredSampleTimeAndDuration(@as(*const IMFDesiredSample, @ptrCast(self)), hnsSampleTime, hnsSampleDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFDesiredSample_Clear(self: *const T) void {
                return @as(*const IMFDesiredSample.VTable, @ptrCast(self.vtable)).Clear(@as(*const IMFDesiredSample, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoMixerControl_Value = Guid.initString("a5c6c53f-c202-4aa5-9695-175ba8c508a5");
pub const IID_IMFVideoMixerControl = &IID_IMFVideoMixerControl_Value;
pub const IMFVideoMixerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                dwZ: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                dwZ: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                pdwZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                pdwZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                pnrcOutput: ?*const MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                pnrcOutput: ?*const MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                pnrcOutput: ?*MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerControl,
                dwStreamID: u32,
                pnrcOutput: ?*MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerControl_SetStreamZOrder(self: *const T, dwStreamID: u32, dwZ: u32) HRESULT {
                return @as(*const IMFVideoMixerControl.VTable, @ptrCast(self.vtable)).SetStreamZOrder(@as(*const IMFVideoMixerControl, @ptrCast(self)), dwStreamID, dwZ);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerControl_GetStreamZOrder(self: *const T, dwStreamID: u32, pdwZ: ?*u32) HRESULT {
                return @as(*const IMFVideoMixerControl.VTable, @ptrCast(self.vtable)).GetStreamZOrder(@as(*const IMFVideoMixerControl, @ptrCast(self)), dwStreamID, pdwZ);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerControl_SetStreamOutputRect(self: *const T, dwStreamID: u32, pnrcOutput: ?*const MFVideoNormalizedRect) HRESULT {
                return @as(*const IMFVideoMixerControl.VTable, @ptrCast(self.vtable)).SetStreamOutputRect(@as(*const IMFVideoMixerControl, @ptrCast(self)), dwStreamID, pnrcOutput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerControl_GetStreamOutputRect(self: *const T, dwStreamID: u32, pnrcOutput: ?*MFVideoNormalizedRect) HRESULT {
                return @as(*const IMFVideoMixerControl.VTable, @ptrCast(self.vtable)).GetStreamOutputRect(@as(*const IMFVideoMixerControl, @ptrCast(self)), dwStreamID, pnrcOutput);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoMixPrefs = enum(i32) {
    ForceHalfInterlace = 1,
    AllowDropToHalfInterlace = 2,
    AllowDropToBob = 4,
    ForceBob = 8,
    EnableRotation = 16,
    Mask = 31,
};
pub const MFVideoMixPrefs_ForceHalfInterlace = MFVideoMixPrefs.ForceHalfInterlace;
pub const MFVideoMixPrefs_AllowDropToHalfInterlace = MFVideoMixPrefs.AllowDropToHalfInterlace;
pub const MFVideoMixPrefs_AllowDropToBob = MFVideoMixPrefs.AllowDropToBob;
pub const MFVideoMixPrefs_ForceBob = MFVideoMixPrefs.ForceBob;
pub const MFVideoMixPrefs_EnableRotation = MFVideoMixPrefs.EnableRotation;
pub const MFVideoMixPrefs_Mask = MFVideoMixPrefs.Mask;

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFVideoMixerControl2_Value = Guid.initString("8459616d-966e-4930-b658-54fa7e5a16d3");
pub const IID_IMFVideoMixerControl2 = &IID_IMFVideoMixerControl2_Value;
pub const IMFVideoMixerControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoMixerControl.VTable,
        SetMixingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerControl2,
                dwMixFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerControl2,
                dwMixFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMixingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerControl2,
                pdwMixFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerControl2,
                pdwMixFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFVideoMixerControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerControl2_SetMixingPrefs(self: *const T, dwMixFlags: u32) HRESULT {
                return @as(*const IMFVideoMixerControl2.VTable, @ptrCast(self.vtable)).SetMixingPrefs(@as(*const IMFVideoMixerControl2, @ptrCast(self)), dwMixFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerControl2_GetMixingPrefs(self: *const T, pdwMixFlags: ?*u32) HRESULT {
                return @as(*const IMFVideoMixerControl2.VTable, @ptrCast(self.vtable)).GetMixingPrefs(@as(*const IMFVideoMixerControl2, @ptrCast(self)), pdwMixFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoRenderer_Value = Guid.initString("dfdfd197-a9ca-43d8-b341-6af3503792cd");
pub const IID_IMFVideoRenderer = &IID_IMFVideoRenderer_Value;
pub const IMFVideoRenderer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeRenderer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoRenderer,
                pVideoMixer: ?*IMFTransform,
                pVideoPresenter: ?*IMFVideoPresenter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoRenderer,
                pVideoMixer: ?*IMFTransform,
                pVideoPresenter: ?*IMFVideoPresenter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoRenderer_InitializeRenderer(self: *const T, pVideoMixer: ?*IMFTransform, pVideoPresenter: ?*IMFVideoPresenter) HRESULT {
                return @as(*const IMFVideoRenderer.VTable, @ptrCast(self.vtable)).InitializeRenderer(@as(*const IMFVideoRenderer, @ptrCast(self)), pVideoMixer, pVideoPresenter);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEVRFilterConfig_Value = Guid.initString("83e91e85-82c1-4ea7-801d-85dc50b75086");
pub const IID_IEVRFilterConfig = &IID_IEVRFilterConfig_Value;
pub const IEVRFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRFilterConfig,
                dwMaxStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRFilterConfig,
                dwMaxStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRFilterConfig,
                pdwMaxStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRFilterConfig,
                pdwMaxStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRFilterConfig_SetNumberOfStreams(self: *const T, dwMaxStreams: u32) HRESULT {
                return @as(*const IEVRFilterConfig.VTable, @ptrCast(self.vtable)).SetNumberOfStreams(@as(*const IEVRFilterConfig, @ptrCast(self)), dwMaxStreams);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRFilterConfig_GetNumberOfStreams(self: *const T, pdwMaxStreams: ?*u32) HRESULT {
                return @as(*const IEVRFilterConfig.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IEVRFilterConfig, @ptrCast(self)), pdwMaxStreams);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EVRFilterConfigPrefs = enum(i32) {
    EnableQoS = 1,
    // Mask = 1, this enum value conflicts with EnableQoS
};
pub const EVRFilterConfigPrefs_EnableQoS = EVRFilterConfigPrefs.EnableQoS;
pub const EVRFilterConfigPrefs_Mask = EVRFilterConfigPrefs.EnableQoS;

// TODO: this type is limited to platform 'windows6.1'
const IID_IEVRFilterConfigEx_Value = Guid.initString("aea36028-796d-454f-beee-b48071e24304");
pub const IID_IEVRFilterConfigEx = &IID_IEVRFilterConfigEx_Value;
pub const IEVRFilterConfigEx = extern struct {
    pub const VTable = extern struct {
        base: IEVRFilterConfig.VTable,
        SetConfigPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRFilterConfigEx,
                dwConfigFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRFilterConfigEx,
                dwConfigFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConfigPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRFilterConfigEx,
                pdwConfigFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRFilterConfigEx,
                pdwConfigFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IEVRFilterConfig.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRFilterConfigEx_SetConfigPrefs(self: *const T, dwConfigFlags: u32) HRESULT {
                return @as(*const IEVRFilterConfigEx.VTable, @ptrCast(self.vtable)).SetConfigPrefs(@as(*const IEVRFilterConfigEx, @ptrCast(self)), dwConfigFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRFilterConfigEx_GetConfigPrefs(self: *const T, pdwConfigFlags: ?*u32) HRESULT {
                return @as(*const IEVRFilterConfigEx.VTable, @ptrCast(self.vtable)).GetConfigPrefs(@as(*const IEVRFilterConfigEx, @ptrCast(self)), pdwConfigFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MF_SERVICE_LOOKUP_TYPE = enum(i32) {
    UPSTREAM = 0,
    UPSTREAM_DIRECT = 1,
    DOWNSTREAM = 2,
    DOWNSTREAM_DIRECT = 3,
    ALL = 4,
    GLOBAL = 5,
};
pub const MF_SERVICE_LOOKUP_UPSTREAM = MF_SERVICE_LOOKUP_TYPE.UPSTREAM;
pub const MF_SERVICE_LOOKUP_UPSTREAM_DIRECT = MF_SERVICE_LOOKUP_TYPE.UPSTREAM_DIRECT;
pub const MF_SERVICE_LOOKUP_DOWNSTREAM = MF_SERVICE_LOOKUP_TYPE.DOWNSTREAM;
pub const MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT = MF_SERVICE_LOOKUP_TYPE.DOWNSTREAM_DIRECT;
pub const MF_SERVICE_LOOKUP_ALL = MF_SERVICE_LOOKUP_TYPE.ALL;
pub const MF_SERVICE_LOOKUP_GLOBAL = MF_SERVICE_LOOKUP_TYPE.GLOBAL;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTopologyServiceLookup_Value = Guid.initString("fa993889-4383-415a-a930-dd472a8cf6f7");
pub const IID_IMFTopologyServiceLookup = &IID_IMFTopologyServiceLookup_Value;
pub const IMFTopologyServiceLookup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LookupService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyServiceLookup,
                Type: MF_SERVICE_LOOKUP_TYPE,
                dwIndex: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObjects: [*]?*anyopaque,
                pnObjects: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyServiceLookup,
                Type: MF_SERVICE_LOOKUP_TYPE,
                dwIndex: u32,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObjects: [*]?*anyopaque,
                pnObjects: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyServiceLookup_LookupService(self: *const T, Type: MF_SERVICE_LOOKUP_TYPE, dwIndex: u32, guidService: ?*const Guid, riid: ?*const Guid, ppvObjects: [*]?*anyopaque, pnObjects: ?*u32) HRESULT {
                return @as(*const IMFTopologyServiceLookup.VTable, @ptrCast(self.vtable)).LookupService(@as(*const IMFTopologyServiceLookup, @ptrCast(self)), Type, dwIndex, guidService, riid, ppvObjects, pnObjects);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFTopologyServiceLookupClient_Value = Guid.initString("fa99388a-4383-415a-a930-dd472a8cf6f7");
pub const IID_IMFTopologyServiceLookupClient = &IID_IMFTopologyServiceLookupClient_Value;
pub const IMFTopologyServiceLookupClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitServicePointers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyServiceLookupClient,
                pLookup: ?*IMFTopologyServiceLookup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyServiceLookupClient,
                pLookup: ?*IMFTopologyServiceLookup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseServicePointers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFTopologyServiceLookupClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFTopologyServiceLookupClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyServiceLookupClient_InitServicePointers(self: *const T, pLookup: ?*IMFTopologyServiceLookup) HRESULT {
                return @as(*const IMFTopologyServiceLookupClient.VTable, @ptrCast(self.vtable)).InitServicePointers(@as(*const IMFTopologyServiceLookupClient, @ptrCast(self)), pLookup);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFTopologyServiceLookupClient_ReleaseServicePointers(self: *const T) HRESULT {
                return @as(*const IMFTopologyServiceLookupClient.VTable, @ptrCast(self.vtable)).ReleaseServicePointers(@as(*const IMFTopologyServiceLookupClient, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEVRTrustedVideoPlugin_Value = Guid.initString("83a4ce40-7710-494b-a893-a472049af630");
pub const IID_IEVRTrustedVideoPlugin = &IID_IEVRTrustedVideoPlugin_Value;
pub const IEVRTrustedVideoPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsInTrustedVideoMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRTrustedVideoPlugin,
                pYes: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRTrustedVideoPlugin,
                pYes: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanConstrict: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRTrustedVideoPlugin,
                pYes: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRTrustedVideoPlugin,
                pYes: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConstriction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRTrustedVideoPlugin,
                dwKPix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRTrustedVideoPlugin,
                dwKPix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableImageExport: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRTrustedVideoPlugin,
                bDisable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRTrustedVideoPlugin,
                bDisable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRTrustedVideoPlugin_IsInTrustedVideoMode(self: *const T, pYes: ?*BOOL) HRESULT {
                return @as(*const IEVRTrustedVideoPlugin.VTable, @ptrCast(self.vtable)).IsInTrustedVideoMode(@as(*const IEVRTrustedVideoPlugin, @ptrCast(self)), pYes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRTrustedVideoPlugin_CanConstrict(self: *const T, pYes: ?*BOOL) HRESULT {
                return @as(*const IEVRTrustedVideoPlugin.VTable, @ptrCast(self.vtable)).CanConstrict(@as(*const IEVRTrustedVideoPlugin, @ptrCast(self)), pYes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRTrustedVideoPlugin_SetConstriction(self: *const T, dwKPix: u32) HRESULT {
                return @as(*const IEVRTrustedVideoPlugin.VTable, @ptrCast(self.vtable)).SetConstriction(@as(*const IEVRTrustedVideoPlugin, @ptrCast(self)), dwKPix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRTrustedVideoPlugin_DisableImageExport(self: *const T, bDisable: BOOL) HRESULT {
                return @as(*const IEVRTrustedVideoPlugin.VTable, @ptrCast(self.vtable)).DisableImageExport(@as(*const IEVRTrustedVideoPlugin, @ptrCast(self)), bDisable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFP_CREATION_OPTIONS = enum(i32) {
    NONE = 0,
    FREE_THREADED_CALLBACK = 1,
    NO_MMCSS = 2,
    NO_REMOTE_DESKTOP_OPTIMIZATION = 4,
};
pub const MFP_OPTION_NONE = MFP_CREATION_OPTIONS.NONE;
pub const MFP_OPTION_FREE_THREADED_CALLBACK = MFP_CREATION_OPTIONS.FREE_THREADED_CALLBACK;
pub const MFP_OPTION_NO_MMCSS = MFP_CREATION_OPTIONS.NO_MMCSS;
pub const MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION = MFP_CREATION_OPTIONS.NO_REMOTE_DESKTOP_OPTIMIZATION;

pub const MFP_MEDIAPLAYER_STATE = enum(i32) {
    EMPTY = 0,
    STOPPED = 1,
    PLAYING = 2,
    PAUSED = 3,
    SHUTDOWN = 4,
};
pub const MFP_MEDIAPLAYER_STATE_EMPTY = MFP_MEDIAPLAYER_STATE.EMPTY;
pub const MFP_MEDIAPLAYER_STATE_STOPPED = MFP_MEDIAPLAYER_STATE.STOPPED;
pub const MFP_MEDIAPLAYER_STATE_PLAYING = MFP_MEDIAPLAYER_STATE.PLAYING;
pub const MFP_MEDIAPLAYER_STATE_PAUSED = MFP_MEDIAPLAYER_STATE.PAUSED;
pub const MFP_MEDIAPLAYER_STATE_SHUTDOWN = MFP_MEDIAPLAYER_STATE.SHUTDOWN;

pub const _MFP_MEDIAITEM_CHARACTERISTICS = enum(i32) {
    IS_LIVE = 1,
    CAN_SEEK = 2,
    CAN_PAUSE = 4,
    HAS_SLOW_SEEK = 8,
};
pub const MFP_MEDIAITEM_IS_LIVE = _MFP_MEDIAITEM_CHARACTERISTICS.IS_LIVE;
pub const MFP_MEDIAITEM_CAN_SEEK = _MFP_MEDIAITEM_CHARACTERISTICS.CAN_SEEK;
pub const MFP_MEDIAITEM_CAN_PAUSE = _MFP_MEDIAITEM_CHARACTERISTICS.CAN_PAUSE;
pub const MFP_MEDIAITEM_HAS_SLOW_SEEK = _MFP_MEDIAITEM_CHARACTERISTICS.HAS_SLOW_SEEK;

pub const _MFP_CREDENTIAL_FLAGS = enum(i32) {
    PROMPT = 1,
    SAVE = 2,
    DO_NOT_CACHE = 4,
    CLEAR_TEXT = 8,
    PROXY = 16,
    LOGGED_ON_USER = 32,
};
pub const MFP_CREDENTIAL_PROMPT = _MFP_CREDENTIAL_FLAGS.PROMPT;
pub const MFP_CREDENTIAL_SAVE = _MFP_CREDENTIAL_FLAGS.SAVE;
pub const MFP_CREDENTIAL_DO_NOT_CACHE = _MFP_CREDENTIAL_FLAGS.DO_NOT_CACHE;
pub const MFP_CREDENTIAL_CLEAR_TEXT = _MFP_CREDENTIAL_FLAGS.CLEAR_TEXT;
pub const MFP_CREDENTIAL_PROXY = _MFP_CREDENTIAL_FLAGS.PROXY;
pub const MFP_CREDENTIAL_LOGGED_ON_USER = _MFP_CREDENTIAL_FLAGS.LOGGED_ON_USER;

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFPMediaPlayer_Value = Guid.initString("a714590a-58af-430a-85bf-44f5ec838d85");
pub const IID_IMFPMediaPlayer = &IID_IMFPMediaPlayer_Value;
pub const IMFPMediaPlayer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Play: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FrameStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                guidPositionType: ?*const Guid,
                pvPositionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                guidPositionType: ?*const Guid,
                pvPositionValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                guidPositionType: ?*const Guid,
                pvPositionValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                guidPositionType: ?*const Guid,
                pvPositionValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                guidPositionType: ?*const Guid,
                pvDurationValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                guidPositionType: ?*const Guid,
                pvDurationValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                flRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                flRate: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pflRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedRates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                fForwardDirection: BOOL,
                pflSlowestRate: ?*f32,
                pflFastestRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                fForwardDirection: BOOL,
                pflSlowestRate: ?*f32,
                pflFastestRate: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                peState: ?*MFP_MEDIAPLAYER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                peState: ?*MFP_MEDIAPLAYER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMediaItemFromURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pwszURL: ?[*:0]const u16,
                fSync: BOOL,
                dwUserData: usize,
                ppMediaItem: ?*?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pwszURL: ?[*:0]const u16,
                fSync: BOOL,
                dwUserData: usize,
                ppMediaItem: ?*?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMediaItemFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pIUnknownObj: ?*IUnknown,
                fSync: BOOL,
                dwUserData: usize,
                ppMediaItem: ?*?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pIUnknownObj: ?*IUnknown,
                fSync: BOOL,
                dwUserData: usize,
                ppMediaItem: ?*?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pIMFPMediaItem: ?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pIMFPMediaItem: ?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearMediaItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                ppIMFPMediaItem: ?*?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                ppIMFPMediaItem: ?*?*IMFPMediaItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pflVolume: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pflVolume: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                flVolume: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                flVolume: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pflBalance: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pflBalance: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                flBalance: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                flBalance: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pfMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pfMute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                fMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                fMute: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNativeVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pszVideo: ?*SIZE,
                pszARVideo: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pszVideo: ?*SIZE,
                pszARVideo: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdealVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pszMin: ?*SIZE,
                pszMax: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pszMin: ?*SIZE,
                pszMax: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoSourceRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pnrcSource: ?*const MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pnrcSource: ?*const MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoSourceRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pnrcSource: ?*MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pnrcSource: ?*MFVideoNormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                dwAspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                dwAspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pdwAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pdwAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                phwndVideo: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                phwndVideo: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                Clr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                Clr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pClr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pClr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pEffect: ?*IUnknown,
                fOptional: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pEffect: ?*IUnknown,
                fOptional: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
                pEffect: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
                pEffect: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAllEffects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_Play(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).Play(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_Pause(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_Stop(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_FrameStep(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).FrameStep(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetPosition(self: *const T, guidPositionType: ?*const Guid, pvPositionValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetPosition(@as(*const IMFPMediaPlayer, @ptrCast(self)), guidPositionType, pvPositionValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetPosition(self: *const T, guidPositionType: ?*const Guid, pvPositionValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IMFPMediaPlayer, @ptrCast(self)), guidPositionType, pvPositionValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetDuration(self: *const T, guidPositionType: ?*const Guid, pvDurationValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMFPMediaPlayer, @ptrCast(self)), guidPositionType, pvDurationValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetRate(self: *const T, flRate: f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetRate(@as(*const IMFPMediaPlayer, @ptrCast(self)), flRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetRate(self: *const T, pflRate: ?*f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetRate(@as(*const IMFPMediaPlayer, @ptrCast(self)), pflRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetSupportedRates(self: *const T, fForwardDirection: BOOL, pflSlowestRate: ?*f32, pflFastestRate: ?*f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetSupportedRates(@as(*const IMFPMediaPlayer, @ptrCast(self)), fForwardDirection, pflSlowestRate, pflFastestRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetState(self: *const T, peState: ?*MFP_MEDIAPLAYER_STATE) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMFPMediaPlayer, @ptrCast(self)), peState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_CreateMediaItemFromURL(self: *const T, pwszURL: ?[*:0]const u16, fSync: BOOL, dwUserData: usize, ppMediaItem: ?*?*IMFPMediaItem) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).CreateMediaItemFromURL(@as(*const IMFPMediaPlayer, @ptrCast(self)), pwszURL, fSync, dwUserData, ppMediaItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_CreateMediaItemFromObject(self: *const T, pIUnknownObj: ?*IUnknown, fSync: BOOL, dwUserData: usize, ppMediaItem: ?*?*IMFPMediaItem) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).CreateMediaItemFromObject(@as(*const IMFPMediaPlayer, @ptrCast(self)), pIUnknownObj, fSync, dwUserData, ppMediaItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetMediaItem(self: *const T, pIMFPMediaItem: ?*IMFPMediaItem) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetMediaItem(@as(*const IMFPMediaPlayer, @ptrCast(self)), pIMFPMediaItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_ClearMediaItem(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).ClearMediaItem(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetMediaItem(self: *const T, ppIMFPMediaItem: ?*?*IMFPMediaItem) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetMediaItem(@as(*const IMFPMediaPlayer, @ptrCast(self)), ppIMFPMediaItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetVolume(self: *const T, pflVolume: ?*f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetVolume(@as(*const IMFPMediaPlayer, @ptrCast(self)), pflVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetVolume(self: *const T, flVolume: f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetVolume(@as(*const IMFPMediaPlayer, @ptrCast(self)), flVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetBalance(self: *const T, pflBalance: ?*f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetBalance(@as(*const IMFPMediaPlayer, @ptrCast(self)), pflBalance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetBalance(self: *const T, flBalance: f32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetBalance(@as(*const IMFPMediaPlayer, @ptrCast(self)), flBalance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetMute(self: *const T, pfMute: ?*BOOL) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetMute(@as(*const IMFPMediaPlayer, @ptrCast(self)), pfMute);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetMute(self: *const T, fMute: BOOL) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetMute(@as(*const IMFPMediaPlayer, @ptrCast(self)), fMute);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetNativeVideoSize(self: *const T, pszVideo: ?*SIZE, pszARVideo: ?*SIZE) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IMFPMediaPlayer, @ptrCast(self)), pszVideo, pszARVideo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetIdealVideoSize(self: *const T, pszMin: ?*SIZE, pszMax: ?*SIZE) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetIdealVideoSize(@as(*const IMFPMediaPlayer, @ptrCast(self)), pszMin, pszMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetVideoSourceRect(self: *const T, pnrcSource: ?*const MFVideoNormalizedRect) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetVideoSourceRect(@as(*const IMFPMediaPlayer, @ptrCast(self)), pnrcSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetVideoSourceRect(self: *const T, pnrcSource: ?*MFVideoNormalizedRect) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetVideoSourceRect(@as(*const IMFPMediaPlayer, @ptrCast(self)), pnrcSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetAspectRatioMode(self: *const T, dwAspectRatioMode: u32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IMFPMediaPlayer, @ptrCast(self)), dwAspectRatioMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetAspectRatioMode(self: *const T, pdwAspectRatioMode: ?*u32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IMFPMediaPlayer, @ptrCast(self)), pdwAspectRatioMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetVideoWindow(self: *const T, phwndVideo: ?*?HWND) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetVideoWindow(@as(*const IMFPMediaPlayer, @ptrCast(self)), phwndVideo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_UpdateVideo(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).UpdateVideo(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_SetBorderColor(self: *const T, Clr: u32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IMFPMediaPlayer, @ptrCast(self)), Clr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_GetBorderColor(self: *const T, pClr: ?*u32) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).GetBorderColor(@as(*const IMFPMediaPlayer, @ptrCast(self)), pClr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_InsertEffect(self: *const T, pEffect: ?*IUnknown, fOptional: BOOL) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).InsertEffect(@as(*const IMFPMediaPlayer, @ptrCast(self)), pEffect, fOptional);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_RemoveEffect(self: *const T, pEffect: ?*IUnknown) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).RemoveEffect(@as(*const IMFPMediaPlayer, @ptrCast(self)), pEffect);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_RemoveAllEffects(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).RemoveAllEffects(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayer_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFPMediaPlayer.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFPMediaPlayer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFPMediaItem_Value = Guid.initString("90eb3e6b-ecbf-45cc-b1da-c6fe3ea70d57");
pub const IID_IMFPMediaItem = &IID_IMFPMediaItem_Value;
pub const IMFPMediaItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaPlayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                ppMediaPlayer: ?*?*IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                ppMediaPlayer: ?*?*IMFPMediaPlayer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                ppwszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                ppwszURL: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                ppIUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                ppIUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pdwUserData: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pdwUserData: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUserData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                dwUserData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                dwUserData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartStopPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pguidStartPositionType: ?*Guid,
                pvStartValue: ?*PROPVARIANT,
                pguidStopPositionType: ?*Guid,
                pvStopValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pguidStartPositionType: ?*Guid,
                pvStartValue: ?*PROPVARIANT,
                pguidStopPositionType: ?*Guid,
                pvStopValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStartStopPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pguidStartPositionType: ?*const Guid,
                pvStartValue: ?*const PROPVARIANT,
                pguidStopPositionType: ?*const Guid,
                pvStopValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pguidStartPositionType: ?*const Guid,
                pvStartValue: ?*const PROPVARIANT,
                pguidStopPositionType: ?*const Guid,
                pvStopValue: ?*const PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pfHasVideo: ?*BOOL,
                pfSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pfHasVideo: ?*BOOL,
                pfSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pfHasAudio: ?*BOOL,
                pfSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pfHasAudio: ?*BOOL,
                pfSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsProtected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pfProtected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pfProtected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                guidPositionType: ?*const Guid,
                pvDurationValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                guidPositionType: ?*const Guid,
                pvDurationValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pdwStreamCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                pfEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                fEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                fEnabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresentationAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                guidMFAttribute: ?*const Guid,
                pvValue: ?*PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCharacteristics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                pCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                pCharacteristics: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                pMediaSink: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                dwStreamIndex: u32,
                pMediaSink: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaItem,
                ppMetadataStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFPMediaItem,
                ppMetadataStore: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetMediaPlayer(self: *const T, ppMediaPlayer: ?*?*IMFPMediaPlayer) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetMediaPlayer(@as(*const IMFPMediaItem, @ptrCast(self)), ppMediaPlayer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetURL(self: *const T, ppwszURL: ?*?PWSTR) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetURL(@as(*const IMFPMediaItem, @ptrCast(self)), ppwszURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetObject(self: *const T, ppIUnknown: ?*?*IUnknown) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IMFPMediaItem, @ptrCast(self)), ppIUnknown);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetUserData(self: *const T, pdwUserData: ?*usize) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetUserData(@as(*const IMFPMediaItem, @ptrCast(self)), pdwUserData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_SetUserData(self: *const T, dwUserData: usize) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).SetUserData(@as(*const IMFPMediaItem, @ptrCast(self)), dwUserData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetStartStopPosition(self: *const T, pguidStartPositionType: ?*Guid, pvStartValue: ?*PROPVARIANT, pguidStopPositionType: ?*Guid, pvStopValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetStartStopPosition(@as(*const IMFPMediaItem, @ptrCast(self)), pguidStartPositionType, pvStartValue, pguidStopPositionType, pvStopValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_SetStartStopPosition(self: *const T, pguidStartPositionType: ?*const Guid, pvStartValue: ?*const PROPVARIANT, pguidStopPositionType: ?*const Guid, pvStopValue: ?*const PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).SetStartStopPosition(@as(*const IMFPMediaItem, @ptrCast(self)), pguidStartPositionType, pvStartValue, pguidStopPositionType, pvStopValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_HasVideo(self: *const T, pfHasVideo: ?*BOOL, pfSelected: ?*BOOL) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).HasVideo(@as(*const IMFPMediaItem, @ptrCast(self)), pfHasVideo, pfSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_HasAudio(self: *const T, pfHasAudio: ?*BOOL, pfSelected: ?*BOOL) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).HasAudio(@as(*const IMFPMediaItem, @ptrCast(self)), pfHasAudio, pfSelected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_IsProtected(self: *const T, pfProtected: ?*BOOL) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).IsProtected(@as(*const IMFPMediaItem, @ptrCast(self)), pfProtected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetDuration(self: *const T, guidPositionType: ?*const Guid, pvDurationValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMFPMediaItem, @ptrCast(self)), guidPositionType, pvDurationValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetNumberOfStreams(self: *const T, pdwStreamCount: ?*u32) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IMFPMediaItem, @ptrCast(self)), pdwStreamCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetStreamSelection(self: *const T, dwStreamIndex: u32, pfEnabled: ?*BOOL) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetStreamSelection(@as(*const IMFPMediaItem, @ptrCast(self)), dwStreamIndex, pfEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_SetStreamSelection(self: *const T, dwStreamIndex: u32, fEnabled: BOOL) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).SetStreamSelection(@as(*const IMFPMediaItem, @ptrCast(self)), dwStreamIndex, fEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetStreamAttribute(self: *const T, dwStreamIndex: u32, guidMFAttribute: ?*const Guid, pvValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetStreamAttribute(@as(*const IMFPMediaItem, @ptrCast(self)), dwStreamIndex, guidMFAttribute, pvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetPresentationAttribute(self: *const T, guidMFAttribute: ?*const Guid, pvValue: ?*PROPVARIANT) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetPresentationAttribute(@as(*const IMFPMediaItem, @ptrCast(self)), guidMFAttribute, pvValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetCharacteristics(self: *const T, pCharacteristics: ?*u32) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetCharacteristics(@as(*const IMFPMediaItem, @ptrCast(self)), pCharacteristics);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_SetStreamSink(self: *const T, dwStreamIndex: u32, pMediaSink: ?*IUnknown) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).SetStreamSink(@as(*const IMFPMediaItem, @ptrCast(self)), dwStreamIndex, pMediaSink);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaItem_GetMetadata(self: *const T, ppMetadataStore: ?*?*IPropertyStore) HRESULT {
                return @as(*const IMFPMediaItem.VTable, @ptrCast(self.vtable)).GetMetadata(@as(*const IMFPMediaItem, @ptrCast(self)), ppMetadataStore);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFP_EVENT_TYPE = enum(i32) {
    PLAY = 0,
    PAUSE = 1,
    STOP = 2,
    POSITION_SET = 3,
    RATE_SET = 4,
    MEDIAITEM_CREATED = 5,
    MEDIAITEM_SET = 6,
    FRAME_STEP = 7,
    MEDIAITEM_CLEARED = 8,
    MF = 9,
    ERROR = 10,
    PLAYBACK_ENDED = 11,
    ACQUIRE_USER_CREDENTIAL = 12,
};
pub const MFP_EVENT_TYPE_PLAY = MFP_EVENT_TYPE.PLAY;
pub const MFP_EVENT_TYPE_PAUSE = MFP_EVENT_TYPE.PAUSE;
pub const MFP_EVENT_TYPE_STOP = MFP_EVENT_TYPE.STOP;
pub const MFP_EVENT_TYPE_POSITION_SET = MFP_EVENT_TYPE.POSITION_SET;
pub const MFP_EVENT_TYPE_RATE_SET = MFP_EVENT_TYPE.RATE_SET;
pub const MFP_EVENT_TYPE_MEDIAITEM_CREATED = MFP_EVENT_TYPE.MEDIAITEM_CREATED;
pub const MFP_EVENT_TYPE_MEDIAITEM_SET = MFP_EVENT_TYPE.MEDIAITEM_SET;
pub const MFP_EVENT_TYPE_FRAME_STEP = MFP_EVENT_TYPE.FRAME_STEP;
pub const MFP_EVENT_TYPE_MEDIAITEM_CLEARED = MFP_EVENT_TYPE.MEDIAITEM_CLEARED;
pub const MFP_EVENT_TYPE_MF = MFP_EVENT_TYPE.MF;
pub const MFP_EVENT_TYPE_ERROR = MFP_EVENT_TYPE.ERROR;
pub const MFP_EVENT_TYPE_PLAYBACK_ENDED = MFP_EVENT_TYPE.PLAYBACK_ENDED;
pub const MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL = MFP_EVENT_TYPE.ACQUIRE_USER_CREDENTIAL;

pub const MFP_EVENT_HEADER = extern struct {
    eEventType: MFP_EVENT_TYPE,
    hrEvent: HRESULT,
    pMediaPlayer: ?*IMFPMediaPlayer,
    eState: MFP_MEDIAPLAYER_STATE,
    pPropertyStore: ?*IPropertyStore,
};

pub const MFP_PLAY_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_PAUSE_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_STOP_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_POSITION_SET_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_RATE_SET_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
    flRate: f32,
};

pub const MFP_MEDIAITEM_CREATED_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
    dwUserData: usize,
};

pub const MFP_MEDIAITEM_SET_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_FRAME_STEP_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_MEDIAITEM_CLEARED_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_MF_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    MFEventType: u32,
    pMFMediaEvent: ?*IMFMediaEvent,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_ERROR_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
};

pub const MFP_PLAYBACK_ENDED_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: ?*IMFPMediaItem,
};

pub const MFP_ACQUIRE_USER_CREDENTIAL_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    dwUserData: usize,
    fProceedWithAuthentication: BOOL,
    hrAuthenticationStatus: HRESULT,
    pwszURL: ?[*:0]const u16,
    pwszSite: ?[*:0]const u16,
    pwszRealm: ?[*:0]const u16,
    pwszPackage: ?[*:0]const u16,
    nRetries: i32,
    flags: u32,
    pCredential: ?*IMFNetCredential,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMFPMediaPlayerCallback_Value = Guid.initString("766c8ffb-5fdb-4fea-a28d-b912996f51bd");
pub const IID_IMFPMediaPlayerCallback = &IID_IMFPMediaPlayerCallback_Value;
pub const IMFPMediaPlayerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMediaPlayerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFPMediaPlayerCallback,
                pEventHeader: ?*MFP_EVENT_HEADER,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFPMediaPlayerCallback,
                pEventHeader: ?*MFP_EVENT_HEADER,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFPMediaPlayerCallback_OnMediaPlayerEvent(self: *const T, pEventHeader: ?*MFP_EVENT_HEADER) void {
                return @as(*const IMFPMediaPlayerCallback.VTable, @ptrCast(self.vtable)).OnMediaPlayerEvent(@as(*const IMFPMediaPlayerCallback, @ptrCast(self)), pEventHeader);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEVICE_INFO = extern struct {
    pFriendlyDeviceName: ?BSTR,
    pUniqueDeviceName: ?BSTR,
    pManufacturerName: ?BSTR,
    pModelName: ?BSTR,
    pIconURL: ?BSTR,
};

pub const MF_SHARING_ENGINE_EVENT = enum(i32) {
    DISCONNECT = 2000,
    LOCALRENDERINGSTARTED = 2001,
    LOCALRENDERINGENDED = 2002,
    STOPPED = 2003,
    ERROR = 2501,
};
pub const MF_SHARING_ENGINE_EVENT_DISCONNECT = MF_SHARING_ENGINE_EVENT.DISCONNECT;
pub const MF_SHARING_ENGINE_EVENT_LOCALRENDERINGSTARTED = MF_SHARING_ENGINE_EVENT.LOCALRENDERINGSTARTED;
pub const MF_SHARING_ENGINE_EVENT_LOCALRENDERINGENDED = MF_SHARING_ENGINE_EVENT.LOCALRENDERINGENDED;
pub const MF_SHARING_ENGINE_EVENT_STOPPED = MF_SHARING_ENGINE_EVENT.STOPPED;
pub const MF_SHARING_ENGINE_EVENT_ERROR = MF_SHARING_ENGINE_EVENT.ERROR;

pub const MF_MEDIA_SHARING_ENGINE_EVENT = enum(i32) {
    T = 2000,
};
pub const MF_MEDIA_SHARING_ENGINE_EVENT_DISCONNECT = MF_MEDIA_SHARING_ENGINE_EVENT.T;

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFSharingEngineClassFactory_Value = Guid.initString("2ba61f92-8305-413b-9733-faf15f259384");
pub const IID_IMFSharingEngineClassFactory = &IID_IMFSharingEngineClassFactory_Value;
pub const IMFSharingEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSharingEngineClassFactory,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppEngine: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSharingEngineClassFactory,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppEngine: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSharingEngineClassFactory_CreateInstance(self: *const T, dwFlags: u32, pAttr: ?*IMFAttributes, ppEngine: ?*?*IUnknown) HRESULT {
                return @as(*const IMFSharingEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IMFSharingEngineClassFactory, @ptrCast(self)), dwFlags, pAttr, ppEngine);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaSharingEngine_Value = Guid.initString("8d3ce1bf-2367-40e0-9eee-40d377cc1b46");
pub const IID_IMFMediaSharingEngine = &IID_IMFMediaSharingEngine_Value;
pub const IMFMediaSharingEngine = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngine.VTable,
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSharingEngine,
                pDevice: ?*DEVICE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSharingEngine,
                pDevice: ?*DEVICE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaEngine.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSharingEngine_GetDevice(self: *const T, pDevice: ?*DEVICE_INFO) HRESULT {
                return @as(*const IMFMediaSharingEngine.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IMFMediaSharingEngine, @ptrCast(self)), pDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFMediaSharingEngineClassFactory_Value = Guid.initString("524d2bc4-b2b1-4fe5-8fac-fa4e4512b4e0");
pub const IID_IMFMediaSharingEngineClassFactory = &IID_IMFMediaSharingEngineClassFactory_Value;
pub const IMFMediaSharingEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFMediaSharingEngineClassFactory,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppEngine: ?*?*IMFMediaSharingEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFMediaSharingEngineClassFactory,
                dwFlags: u32,
                pAttr: ?*IMFAttributes,
                ppEngine: ?*?*IMFMediaSharingEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFMediaSharingEngineClassFactory_CreateInstance(self: *const T, dwFlags: u32, pAttr: ?*IMFAttributes, ppEngine: ?*?*IMFMediaSharingEngine) HRESULT {
                return @as(*const IMFMediaSharingEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IMFMediaSharingEngineClassFactory, @ptrCast(self)), dwFlags, pAttr, ppEngine);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFImageSharingEngine_Value = Guid.initString("cfa0ae8e-7e1c-44d2-ae68-fc4c148a6354");
pub const IID_IMFImageSharingEngine = &IID_IMFImageSharingEngine_Value;
pub const IMFImageSharingEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFImageSharingEngine,
                pStream: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFImageSharingEngine,
                pStream: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFImageSharingEngine,
                pDevice: ?*DEVICE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFImageSharingEngine,
                pDevice: ?*DEVICE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFImageSharingEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFImageSharingEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFImageSharingEngine_SetSource(self: *const T, pStream: ?*IUnknown) HRESULT {
                return @as(*const IMFImageSharingEngine.VTable, @ptrCast(self.vtable)).SetSource(@as(*const IMFImageSharingEngine, @ptrCast(self)), pStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFImageSharingEngine_GetDevice(self: *const T, pDevice: ?*DEVICE_INFO) HRESULT {
                return @as(*const IMFImageSharingEngine.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IMFImageSharingEngine, @ptrCast(self)), pDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFImageSharingEngine_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFImageSharingEngine.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFImageSharingEngine, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IMFImageSharingEngineClassFactory_Value = Guid.initString("1fc55727-a7fb-4fc8-83ae-8af024990af1");
pub const IID_IMFImageSharingEngineClassFactory = &IID_IMFImageSharingEngineClassFactory_Value;
pub const IMFImageSharingEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstanceFromUDN: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFImageSharingEngineClassFactory,
                pUniqueDeviceName: ?BSTR,
                ppEngine: ?*?*IMFImageSharingEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFImageSharingEngineClassFactory,
                pUniqueDeviceName: ?BSTR,
                ppEngine: ?*?*IMFImageSharingEngine,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFImageSharingEngineClassFactory_CreateInstanceFromUDN(self: *const T, pUniqueDeviceName: ?BSTR, ppEngine: ?*?*IMFImageSharingEngine) HRESULT {
                return @as(*const IMFImageSharingEngineClassFactory.VTable, @ptrCast(self.vtable)).CreateInstanceFromUDN(@as(*const IMFImageSharingEngineClassFactory, @ptrCast(self)), pUniqueDeviceName, ppEngine);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PLAYTO_SOURCE_CREATEFLAGS = enum(i32) {
    NONE = 0,
    IMAGE = 1,
    AUDIO = 2,
    VIDEO = 4,
    PROTECTED = 8,
};
pub const PLAYTO_SOURCE_NONE = PLAYTO_SOURCE_CREATEFLAGS.NONE;
pub const PLAYTO_SOURCE_IMAGE = PLAYTO_SOURCE_CREATEFLAGS.IMAGE;
pub const PLAYTO_SOURCE_AUDIO = PLAYTO_SOURCE_CREATEFLAGS.AUDIO;
pub const PLAYTO_SOURCE_VIDEO = PLAYTO_SOURCE_CREATEFLAGS.VIDEO;
pub const PLAYTO_SOURCE_PROTECTED = PLAYTO_SOURCE_CREATEFLAGS.PROTECTED;

// TODO: this type is limited to platform 'windows8.0'
const IID_IPlayToControl_Value = Guid.initString("607574eb-f4b6-45c1-b08c-cb715122901d");
pub const IID_IPlayToControl = &IID_IPlayToControl_Value;
pub const IPlayToControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPlayToControl,
                pFactory: ?*IMFSharingEngineClassFactory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPlayToControl,
                pFactory: ?*IMFSharingEngineClassFactory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPlayToControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPlayToControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPlayToControl_Connect(self: *const T, pFactory: ?*IMFSharingEngineClassFactory) HRESULT {
                return @as(*const IPlayToControl.VTable, @ptrCast(self.vtable)).Connect(@as(*const IPlayToControl, @ptrCast(self)), pFactory);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPlayToControl_Disconnect(self: *const T) HRESULT {
                return @as(*const IPlayToControl.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IPlayToControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.1'
const IID_IPlayToControlWithCapabilities_Value = Guid.initString("aa9dd80f-c50a-4220-91c1-332287f82a34");
pub const IID_IPlayToControlWithCapabilities = &IID_IPlayToControlWithCapabilities_Value;
pub const IPlayToControlWithCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IPlayToControl.VTable,
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPlayToControlWithCapabilities,
                pCapabilities: ?*PLAYTO_SOURCE_CREATEFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPlayToControlWithCapabilities,
                pCapabilities: ?*PLAYTO_SOURCE_CREATEFLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPlayToControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPlayToControlWithCapabilities_GetCapabilities(self: *const T, pCapabilities: ?*PLAYTO_SOURCE_CREATEFLAGS) HRESULT {
                return @as(*const IPlayToControlWithCapabilities.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IPlayToControlWithCapabilities, @ptrCast(self)), pCapabilities);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IPlayToSourceClassFactory_Value = Guid.initString("842b32a3-9b9b-4d1c-b3f3-49193248a554");
pub const IID_IPlayToSourceClassFactory = &IID_IPlayToSourceClassFactory_Value;
pub const IPlayToSourceClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPlayToSourceClassFactory,
                dwFlags: u32,
                pControl: ?*IPlayToControl,
                ppSource: ?*?*IInspectable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPlayToSourceClassFactory,
                dwFlags: u32,
                pControl: ?*IPlayToControl,
                ppSource: ?*?*IInspectable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPlayToSourceClassFactory_CreateInstance(self: *const T, dwFlags: u32, pControl: ?*IPlayToControl, ppSource: ?*?*IInspectable) HRESULT {
                return @as(*const IPlayToSourceClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IPlayToSourceClassFactory, @ptrCast(self)), dwFlags, pControl, ppSource);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEVRVideoStreamControl_Value = Guid.initString("d0cfe38b-93e7-4772-8957-0400c49a4485");
pub const IID_IEVRVideoStreamControl = &IID_IEVRVideoStreamControl_Value;
pub const IEVRVideoStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamActiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRVideoStreamControl,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRVideoStreamControl,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamActiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEVRVideoStreamControl,
                lpfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEVRVideoStreamControl,
                lpfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRVideoStreamControl_SetStreamActiveState(self: *const T, fActive: BOOL) HRESULT {
                return @as(*const IEVRVideoStreamControl.VTable, @ptrCast(self.vtable)).SetStreamActiveState(@as(*const IEVRVideoStreamControl, @ptrCast(self)), fActive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEVRVideoStreamControl_GetStreamActiveState(self: *const T, lpfActive: ?*BOOL) HRESULT {
                return @as(*const IEVRVideoStreamControl.VTable, @ptrCast(self.vtable)).GetStreamActiveState(@as(*const IEVRVideoStreamControl, @ptrCast(self)), lpfActive);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoProcessor_Value = Guid.initString("6ab0000c-fece-4d1f-a2ac-a9573530656e");
pub const IID_IMFVideoProcessor = &IID_IMFVideoProcessor_Value;
pub const IMFVideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableVideoProcessorModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                lpdwNumProcessingModes: ?*u32,
                ppVideoProcessingModes: ?[*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                lpdwNumProcessingModes: ?*u32,
                ppVideoProcessingModes: ?[*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                lpVideoProcessorMode: ?*Guid,
                lpVideoProcessorCaps: ?*DXVA2_VideoProcessorCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                lpVideoProcessorMode: ?*Guid,
                lpVideoProcessorCaps: ?*DXVA2_VideoProcessorCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoProcessorMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                lpMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                lpMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoProcessorMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                lpMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                lpMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAmpRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pPropRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pPropRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAmpValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                dwFlags: u32,
                Values: ?*DXVA2_ProcAmpValues,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                dwFlags: u32,
                Values: ?*DXVA2_ProcAmpValues,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcAmpValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                dwFlags: u32,
                pValues: ?*DXVA2_ProcAmpValues,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                dwFlags: u32,
                pValues: ?*DXVA2_ProcAmpValues,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteringRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pPropRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pPropRange: ?*DXVA2_ValueRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilteringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pValue: ?*DXVA2_Fixed32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pValue: ?*DXVA2_Fixed32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilteringValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pValue: ?*DXVA2_Fixed32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                dwProperty: u32,
                pValue: ?*DXVA2_Fixed32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                lpClrBkg: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                lpClrBkg: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoProcessor,
                ClrBkg: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoProcessor,
                ClrBkg: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetAvailableVideoProcessorModes(self: *const T, lpdwNumProcessingModes: ?*u32, ppVideoProcessingModes: ?[*]?*Guid) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetAvailableVideoProcessorModes(@as(*const IMFVideoProcessor, @ptrCast(self)), lpdwNumProcessingModes, ppVideoProcessingModes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetVideoProcessorCaps(self: *const T, lpVideoProcessorMode: ?*Guid, lpVideoProcessorCaps: ?*DXVA2_VideoProcessorCaps) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetVideoProcessorCaps(@as(*const IMFVideoProcessor, @ptrCast(self)), lpVideoProcessorMode, lpVideoProcessorCaps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetVideoProcessorMode(self: *const T, lpMode: ?*Guid) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetVideoProcessorMode(@as(*const IMFVideoProcessor, @ptrCast(self)), lpMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_SetVideoProcessorMode(self: *const T, lpMode: ?*Guid) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).SetVideoProcessorMode(@as(*const IMFVideoProcessor, @ptrCast(self)), lpMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetProcAmpRange(self: *const T, dwProperty: u32, pPropRange: ?*DXVA2_ValueRange) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetProcAmpRange(@as(*const IMFVideoProcessor, @ptrCast(self)), dwProperty, pPropRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetProcAmpValues(self: *const T, dwFlags: u32, Values: ?*DXVA2_ProcAmpValues) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetProcAmpValues(@as(*const IMFVideoProcessor, @ptrCast(self)), dwFlags, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_SetProcAmpValues(self: *const T, dwFlags: u32, pValues: ?*DXVA2_ProcAmpValues) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).SetProcAmpValues(@as(*const IMFVideoProcessor, @ptrCast(self)), dwFlags, pValues);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetFilteringRange(self: *const T, dwProperty: u32, pPropRange: ?*DXVA2_ValueRange) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetFilteringRange(@as(*const IMFVideoProcessor, @ptrCast(self)), dwProperty, pPropRange);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetFilteringValue(self: *const T, dwProperty: u32, pValue: ?*DXVA2_Fixed32) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetFilteringValue(@as(*const IMFVideoProcessor, @ptrCast(self)), dwProperty, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_SetFilteringValue(self: *const T, dwProperty: u32, pValue: ?*DXVA2_Fixed32) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).SetFilteringValue(@as(*const IMFVideoProcessor, @ptrCast(self)), dwProperty, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_GetBackgroundColor(self: *const T, lpClrBkg: ?*u32) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IMFVideoProcessor, @ptrCast(self)), lpClrBkg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoProcessor_SetBackgroundColor(self: *const T, ClrBkg: u32) HRESULT {
                return @as(*const IMFVideoProcessor.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IMFVideoProcessor, @ptrCast(self)), ClrBkg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoAlphaBitmapParams = extern struct {
    dwFlags: u32,
    clrSrcKey: u32,
    rcSrc: RECT,
    nrcDest: MFVideoNormalizedRect,
    fAlpha: f32,
    dwFilterMode: u32,
};

pub const MFVideoAlphaBitmap = extern struct {
    GetBitmapFromDC: BOOL,
    bitmap: extern union {
        hdc: ?HDC,
        pDDS: ?*IDirect3DSurface9,
    },
    params: MFVideoAlphaBitmapParams,
};

pub const MFVideoAlphaBitmapFlags = enum(i32) {
    EntireDDS = 1,
    SrcColorKey = 2,
    SrcRect = 4,
    DestRect = 8,
    FilterMode = 16,
    Alpha = 32,
    BitMask = 63,
};
pub const MFVideoAlphaBitmap_EntireDDS = MFVideoAlphaBitmapFlags.EntireDDS;
pub const MFVideoAlphaBitmap_SrcColorKey = MFVideoAlphaBitmapFlags.SrcColorKey;
pub const MFVideoAlphaBitmap_SrcRect = MFVideoAlphaBitmapFlags.SrcRect;
pub const MFVideoAlphaBitmap_DestRect = MFVideoAlphaBitmapFlags.DestRect;
pub const MFVideoAlphaBitmap_FilterMode = MFVideoAlphaBitmapFlags.FilterMode;
pub const MFVideoAlphaBitmap_Alpha = MFVideoAlphaBitmapFlags.Alpha;
pub const MFVideoAlphaBitmap_BitMask = MFVideoAlphaBitmapFlags.BitMask;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMFVideoMixerBitmap_Value = Guid.initString("814c7b20-0fdb-4eec-af8f-f957c8f69edc");
pub const IID_IMFVideoMixerBitmap = &IID_IMFVideoMixerBitmap_Value;
pub const IMFVideoMixerBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerBitmap,
                pBmpParms: ?*const MFVideoAlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerBitmap,
                pBmpParms: ?*const MFVideoAlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearAlphaBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAlphaBitmapParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerBitmap,
                pBmpParms: ?*const MFVideoAlphaBitmapParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerBitmap,
                pBmpParms: ?*const MFVideoAlphaBitmapParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlphaBitmapParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVideoMixerBitmap,
                pBmpParms: ?*MFVideoAlphaBitmapParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVideoMixerBitmap,
                pBmpParms: ?*MFVideoAlphaBitmapParams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerBitmap_SetAlphaBitmap(self: *const T, pBmpParms: ?*const MFVideoAlphaBitmap) HRESULT {
                return @as(*const IMFVideoMixerBitmap.VTable, @ptrCast(self.vtable)).SetAlphaBitmap(@as(*const IMFVideoMixerBitmap, @ptrCast(self)), pBmpParms);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerBitmap_ClearAlphaBitmap(self: *const T) HRESULT {
                return @as(*const IMFVideoMixerBitmap.VTable, @ptrCast(self.vtable)).ClearAlphaBitmap(@as(*const IMFVideoMixerBitmap, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerBitmap_UpdateAlphaBitmapParameters(self: *const T, pBmpParms: ?*const MFVideoAlphaBitmapParams) HRESULT {
                return @as(*const IMFVideoMixerBitmap.VTable, @ptrCast(self.vtable)).UpdateAlphaBitmapParameters(@as(*const IMFVideoMixerBitmap, @ptrCast(self)), pBmpParms);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVideoMixerBitmap_GetAlphaBitmapParameters(self: *const T, pBmpParms: ?*MFVideoAlphaBitmapParams) HRESULT {
                return @as(*const IMFVideoMixerBitmap.VTable, @ptrCast(self.vtable)).GetAlphaBitmapParameters(@as(*const IMFVideoMixerBitmap, @ptrCast(self)), pBmpParms);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAdvancedMediaCaptureInitializationSettings_Value = Guid.initString("3de21209-8ba6-4f2a-a577-2819b56ff14d");
pub const IID_IAdvancedMediaCaptureInitializationSettings = &IID_IAdvancedMediaCaptureInitializationSettings_Value;
pub const IAdvancedMediaCaptureInitializationSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectxDeviceManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdvancedMediaCaptureInitializationSettings,
                value: ?*IMFDXGIDeviceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAdvancedMediaCaptureInitializationSettings,
                value: ?*IMFDXGIDeviceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdvancedMediaCaptureInitializationSettings_SetDirectxDeviceManager(self: *const T, value: ?*IMFDXGIDeviceManager) HRESULT {
                return @as(*const IAdvancedMediaCaptureInitializationSettings.VTable, @ptrCast(self.vtable)).SetDirectxDeviceManager(@as(*const IAdvancedMediaCaptureInitializationSettings, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAdvancedMediaCaptureSettings_Value = Guid.initString("24e0485f-a33e-4aa1-b564-6019b1d14f65");
pub const IID_IAdvancedMediaCaptureSettings = &IID_IAdvancedMediaCaptureSettings_Value;
pub const IAdvancedMediaCaptureSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectxDeviceManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdvancedMediaCaptureSettings,
                value: ?*?*IMFDXGIDeviceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAdvancedMediaCaptureSettings,
                value: ?*?*IMFDXGIDeviceManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdvancedMediaCaptureSettings_GetDirectxDeviceManager(self: *const T, value: ?*?*IMFDXGIDeviceManager) HRESULT {
                return @as(*const IAdvancedMediaCaptureSettings.VTable, @ptrCast(self.vtable)).GetDirectxDeviceManager(@as(*const IAdvancedMediaCaptureSettings, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAdvancedMediaCapture_Value = Guid.initString("d0751585-d216-4344-b5bf-463b68f977bb");
pub const IID_IAdvancedMediaCapture = &IID_IAdvancedMediaCapture_Value;
pub const IAdvancedMediaCapture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdvancedMediaCaptureSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdvancedMediaCapture,
                value: ?*?*IAdvancedMediaCaptureSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAdvancedMediaCapture,
                value: ?*?*IAdvancedMediaCaptureSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdvancedMediaCapture_GetAdvancedMediaCaptureSettings(self: *const T, value: ?*?*IAdvancedMediaCaptureSettings) HRESULT {
                return @as(*const IAdvancedMediaCapture.VTable, @ptrCast(self.vtable)).GetAdvancedMediaCaptureSettings(@as(*const IAdvancedMediaCapture, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSpatialAudioObjectBuffer_Value = Guid.initString("d396ec8c-605e-4249-978d-72ad1c312872");
pub const IID_IMFSpatialAudioObjectBuffer = &IID_IMFSpatialAudioObjectBuffer_Value;
pub const IMFSpatialAudioObjectBuffer = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaBuffer.VTable,
        SetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioObjectBuffer,
                u32ID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioObjectBuffer,
                u32ID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioObjectBuffer,
                pu32ID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioObjectBuffer,
                pu32ID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioObjectBuffer,
                type: AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioObjectBuffer,
                type: AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioObjectBuffer,
                pType: ?*AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioObjectBuffer,
                pType: ?*AudioObjectType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMetadataItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioObjectBuffer,
                ppMetadataItems: ?*?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioObjectBuffer,
                ppMetadataItems: ?*?*ISpatialAudioMetadataItems,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFMediaBuffer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioObjectBuffer_SetID(self: *const T, u32ID: u32) HRESULT {
                return @as(*const IMFSpatialAudioObjectBuffer.VTable, @ptrCast(self.vtable)).SetID(@as(*const IMFSpatialAudioObjectBuffer, @ptrCast(self)), u32ID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioObjectBuffer_GetID(self: *const T, pu32ID: ?*u32) HRESULT {
                return @as(*const IMFSpatialAudioObjectBuffer.VTable, @ptrCast(self.vtable)).GetID(@as(*const IMFSpatialAudioObjectBuffer, @ptrCast(self)), pu32ID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioObjectBuffer_SetType(self: *const T, type_: AudioObjectType) HRESULT {
                return @as(*const IMFSpatialAudioObjectBuffer.VTable, @ptrCast(self.vtable)).SetType(@as(*const IMFSpatialAudioObjectBuffer, @ptrCast(self)), type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioObjectBuffer_GetType(self: *const T, pType: ?*AudioObjectType) HRESULT {
                return @as(*const IMFSpatialAudioObjectBuffer.VTable, @ptrCast(self.vtable)).GetType(@as(*const IMFSpatialAudioObjectBuffer, @ptrCast(self)), pType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioObjectBuffer_GetMetadataItems(self: *const T, ppMetadataItems: ?*?*ISpatialAudioMetadataItems) HRESULT {
                return @as(*const IMFSpatialAudioObjectBuffer.VTable, @ptrCast(self.vtable)).GetMetadataItems(@as(*const IMFSpatialAudioObjectBuffer, @ptrCast(self)), ppMetadataItems);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.15063'
const IID_IMFSpatialAudioSample_Value = Guid.initString("abf28a9b-3393-4290-ba79-5ffc46d986b2");
pub const IID_IMFSpatialAudioSample = &IID_IMFSpatialAudioSample_Value;
pub const IMFSpatialAudioSample = extern struct {
    pub const VTable = extern struct {
        base: IMFSample.VTable,
        GetObjectCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioSample,
                pdwObjectCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioSample,
                pdwObjectCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSpatialAudioObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioSample,
                pAudioObjBuffer: ?*IMFSpatialAudioObjectBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioSample,
                pAudioObjBuffer: ?*IMFSpatialAudioObjectBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpatialAudioObjectByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFSpatialAudioSample,
                dwIndex: u32,
                ppAudioObjBuffer: ?*?*IMFSpatialAudioObjectBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFSpatialAudioSample,
                dwIndex: u32,
                ppAudioObjBuffer: ?*?*IMFSpatialAudioObjectBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFSample.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioSample_GetObjectCount(self: *const T, pdwObjectCount: ?*u32) HRESULT {
                return @as(*const IMFSpatialAudioSample.VTable, @ptrCast(self.vtable)).GetObjectCount(@as(*const IMFSpatialAudioSample, @ptrCast(self)), pdwObjectCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioSample_AddSpatialAudioObject(self: *const T, pAudioObjBuffer: ?*IMFSpatialAudioObjectBuffer) HRESULT {
                return @as(*const IMFSpatialAudioSample.VTable, @ptrCast(self.vtable)).AddSpatialAudioObject(@as(*const IMFSpatialAudioSample, @ptrCast(self)), pAudioObjBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFSpatialAudioSample_GetSpatialAudioObjectByIndex(self: *const T, dwIndex: u32, ppAudioObjBuffer: ?*?*IMFSpatialAudioObjectBuffer) HRESULT {
                return @as(*const IMFSpatialAudioSample.VTable, @ptrCast(self.vtable)).GetSpatialAudioObjectByIndex(@as(*const IMFSpatialAudioSample, @ptrCast(self)), dwIndex, ppAudioObjBuffer);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFContentDecryptionModuleSession_Value = Guid.initString("4e233efd-1dd2-49e8-b577-d63eee4c0d33");
pub const IID_IMFContentDecryptionModuleSession = &IID_IMFContentDecryptionModuleSession_Value;
pub const IMFContentDecryptionModuleSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSessionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
                sessionId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
                sessionId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpiration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
                expiration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
                expiration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyStatuses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
                keyStatuses: [*]?*MFMediaKeyStatus,
                numKeyStatuses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
                keyStatuses: [*]?*MFMediaKeyStatus,
                numKeyStatuses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
                sessionId: ?[*:0]const u16,
                loaded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
                sessionId: ?[*:0]const u16,
                loaded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
                initDataType: ?[*:0]const u16,
                initData: [*:0]const u8,
                initDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
                initDataType: ?[*:0]const u16,
                initData: [*:0]const u8,
                initDataSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
                response: [*:0]const u8,
                responseSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
                response: [*:0]const u8,
                responseSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_GetSessionId(self: *const T, sessionId: ?*?PWSTR) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).GetSessionId(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)), sessionId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_GetExpiration(self: *const T, expiration: ?*f64) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).GetExpiration(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)), expiration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_GetKeyStatuses(self: *const T, keyStatuses: [*]?*MFMediaKeyStatus, numKeyStatuses: ?*u32) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).GetKeyStatuses(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)), keyStatuses, numKeyStatuses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_Load(self: *const T, sessionId: ?[*:0]const u16, loaded: ?*BOOL) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).Load(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)), sessionId, loaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_GenerateRequest(self: *const T, initDataType: ?[*:0]const u16, initData: [*:0]const u8, initDataSize: u32) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).GenerateRequest(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)), initDataType, initData, initDataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_Update(self: *const T, response: [*:0]const u8, responseSize: u32) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).Update(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)), response, responseSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_Close(self: *const T) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).Close(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSession_Remove(self: *const T) HRESULT {
                return @as(*const IMFContentDecryptionModuleSession.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMFContentDecryptionModuleSession, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFContentDecryptionModuleSessionCallbacks_Value = Guid.initString("3f96ee40-ad81-4096-8470-59a4b770f89a");
pub const IID_IMFContentDecryptionModuleSessionCallbacks = &IID_IMFContentDecryptionModuleSessionCallbacks_Value;
pub const IMFContentDecryptionModuleSessionCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSessionCallbacks,
                messageType: MF_MEDIAKEYSESSION_MESSAGETYPE,
                message: [*:0]const u8,
                messageSize: u32,
                destinationURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSessionCallbacks,
                messageType: MF_MEDIAKEYSESSION_MESSAGETYPE,
                message: [*:0]const u8,
                messageSize: u32,
                destinationURL: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeyStatusChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleSessionCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleSessionCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSessionCallbacks_KeyMessage(self: *const T, messageType: MF_MEDIAKEYSESSION_MESSAGETYPE, message: [*:0]const u8, messageSize: u32, destinationURL: ?[*:0]const u16) HRESULT {
                return @as(*const IMFContentDecryptionModuleSessionCallbacks.VTable, @ptrCast(self.vtable)).KeyMessage(@as(*const IMFContentDecryptionModuleSessionCallbacks, @ptrCast(self)), messageType, message, messageSize, destinationURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleSessionCallbacks_KeyStatusChanged(self: *const T) HRESULT {
                return @as(*const IMFContentDecryptionModuleSessionCallbacks.VTable, @ptrCast(self.vtable)).KeyStatusChanged(@as(*const IMFContentDecryptionModuleSessionCallbacks, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFContentDecryptionModule_Value = Guid.initString("87be986c-10be-4943-bf48-4b54ce1983a2");
pub const IID_IMFContentDecryptionModule = &IID_IMFContentDecryptionModule_Value;
pub const IMFContentDecryptionModule = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContentEnabler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                contentEnabler: ?*IMFContentEnabler,
                result: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                contentEnabler: ?*IMFContentEnabler,
                result: ?*IMFAsyncResult,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSuspendNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                notify: ?*?*IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                notify: ?*?*IMFCdmSuspendNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPMPHostApp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                pmpHostApp: ?*IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                pmpHostApp: ?*IMFPMPHostApp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                sessionType: MF_MEDIAKEYSESSION_TYPE,
                callbacks: ?*IMFContentDecryptionModuleSessionCallbacks,
                session: ?*?*IMFContentDecryptionModuleSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                sessionType: MF_MEDIAKEYSESSION_TYPE,
                callbacks: ?*IMFContentDecryptionModuleSessionCallbacks,
                session: ?*?*IMFContentDecryptionModuleSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetServerCertificate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                certificate: [*:0]const u8,
                certificateSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                certificate: [*:0]const u8,
                certificateSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTrustedInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                contentInitData: [*:0]const u8,
                contentInitDataSize: u32,
                trustedInput: ?*?*IMFTrustedInput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                contentInitData: [*:0]const u8,
                contentInitDataSize: u32,
                trustedInput: ?*?*IMFTrustedInput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtectionSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModule,
                systemIds: [*]?*Guid,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModule,
                systemIds: [*]?*Guid,
                count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_SetContentEnabler(self: *const T, contentEnabler: ?*IMFContentEnabler, result: ?*IMFAsyncResult) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).SetContentEnabler(@as(*const IMFContentDecryptionModule, @ptrCast(self)), contentEnabler, result);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_GetSuspendNotify(self: *const T, notify: ?*?*IMFCdmSuspendNotify) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).GetSuspendNotify(@as(*const IMFContentDecryptionModule, @ptrCast(self)), notify);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_SetPMPHostApp(self: *const T, pmpHostApp: ?*IMFPMPHostApp) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).SetPMPHostApp(@as(*const IMFContentDecryptionModule, @ptrCast(self)), pmpHostApp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_CreateSession(self: *const T, sessionType: MF_MEDIAKEYSESSION_TYPE, callbacks: ?*IMFContentDecryptionModuleSessionCallbacks, session: ?*?*IMFContentDecryptionModuleSession) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).CreateSession(@as(*const IMFContentDecryptionModule, @ptrCast(self)), sessionType, callbacks, session);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_SetServerCertificate(self: *const T, certificate: [*:0]const u8, certificateSize: u32) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).SetServerCertificate(@as(*const IMFContentDecryptionModule, @ptrCast(self)), certificate, certificateSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_CreateTrustedInput(self: *const T, contentInitData: [*:0]const u8, contentInitDataSize: u32, trustedInput: ?*?*IMFTrustedInput) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).CreateTrustedInput(@as(*const IMFContentDecryptionModule, @ptrCast(self)), contentInitData, contentInitDataSize, trustedInput);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModule_GetProtectionSystemIds(self: *const T, systemIds: [*]?*Guid, count: ?*u32) HRESULT {
                return @as(*const IMFContentDecryptionModule.VTable, @ptrCast(self.vtable)).GetProtectionSystemIds(@as(*const IMFContentDecryptionModule, @ptrCast(self)), systemIds, count);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFContentDecryptionModuleAccess_Value = Guid.initString("a853d1f4-e2a0-4303-9edc-f1a68ee43136");
pub const IID_IMFContentDecryptionModuleAccess = &IID_IMFContentDecryptionModuleAccess_Value;
pub const IMFContentDecryptionModuleAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContentDecryptionModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleAccess,
                contentDecryptionModuleProperties: ?*IPropertyStore,
                contentDecryptionModule: ?*?*IMFContentDecryptionModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleAccess,
                contentDecryptionModuleProperties: ?*IPropertyStore,
                contentDecryptionModule: ?*?*IMFContentDecryptionModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleAccess,
                configuration: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleAccess,
                configuration: ?*?*IPropertyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeySystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleAccess,
                keySystem: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleAccess,
                keySystem: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleAccess_CreateContentDecryptionModule(self: *const T, contentDecryptionModuleProperties: ?*IPropertyStore, contentDecryptionModule: ?*?*IMFContentDecryptionModule) HRESULT {
                return @as(*const IMFContentDecryptionModuleAccess.VTable, @ptrCast(self.vtable)).CreateContentDecryptionModule(@as(*const IMFContentDecryptionModuleAccess, @ptrCast(self)), contentDecryptionModuleProperties, contentDecryptionModule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleAccess_GetConfiguration(self: *const T, configuration: ?*?*IPropertyStore) HRESULT {
                return @as(*const IMFContentDecryptionModuleAccess.VTable, @ptrCast(self.vtable)).GetConfiguration(@as(*const IMFContentDecryptionModuleAccess, @ptrCast(self)), configuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleAccess_GetKeySystem(self: *const T, keySystem: ?*?PWSTR) HRESULT {
                return @as(*const IMFContentDecryptionModuleAccess.VTable, @ptrCast(self.vtable)).GetKeySystem(@as(*const IMFContentDecryptionModuleAccess, @ptrCast(self)), keySystem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows10.0.19041'
const IID_IMFContentDecryptionModuleFactory_Value = Guid.initString("7d5abf16-4cbb-4e08-b977-9ba59049943e");
pub const IID_IMFContentDecryptionModuleFactory = &IID_IMFContentDecryptionModuleFactory_Value;
pub const IMFContentDecryptionModuleFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTypeSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleFactory,
                keySystem: ?[*:0]const u16,
                contentType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IMFContentDecryptionModuleFactory,
                keySystem: ?[*:0]const u16,
                contentType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        CreateContentDecryptionModuleAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFContentDecryptionModuleFactory,
                keySystem: ?[*:0]const u16,
                configurations: [*]?*IPropertyStore,
                numConfigurations: u32,
                contentDecryptionModuleAccess: ?*?*IMFContentDecryptionModuleAccess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFContentDecryptionModuleFactory,
                keySystem: ?[*:0]const u16,
                configurations: [*]?*IPropertyStore,
                numConfigurations: u32,
                contentDecryptionModuleAccess: ?*?*IMFContentDecryptionModuleAccess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleFactory_IsTypeSupported(self: *const T, keySystem: ?[*:0]const u16, contentType: ?[*:0]const u16) BOOL {
                return @as(*const IMFContentDecryptionModuleFactory.VTable, @ptrCast(self.vtable)).IsTypeSupported(@as(*const IMFContentDecryptionModuleFactory, @ptrCast(self)), keySystem, contentType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFContentDecryptionModuleFactory_CreateContentDecryptionModuleAccess(self: *const T, keySystem: ?[*:0]const u16, configurations: [*]?*IPropertyStore, numConfigurations: u32, contentDecryptionModuleAccess: ?*?*IMFContentDecryptionModuleAccess) HRESULT {
                return @as(*const IMFContentDecryptionModuleFactory.VTable, @ptrCast(self.vtable)).CreateContentDecryptionModuleAccess(@as(*const IMFContentDecryptionModuleFactory, @ptrCast(self)), keySystem, configurations, numConfigurations, contentDecryptionModuleAccess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0001 = enum(i32) {
    e = 0,
};
pub const MFVirtualCameraType_SoftwareCameraSource = __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0001.e;

pub const __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0002 = enum(i32) {
    ession = 0,
    ystem = 1,
};
pub const MFVirtualCameraLifetime_Session = __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0002.ession;
pub const MFVirtualCameraLifetime_System = __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0002.ystem;

pub const __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0003 = enum(i32) {
    CurrentUser = 0,
    AllUsers = 1,
};
pub const MFVirtualCameraAccess_CurrentUser = __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0003.CurrentUser;
pub const MFVirtualCameraAccess_AllUsers = __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0003.AllUsers;

const IID_IMFCameraSyncObject_Value = Guid.initString("6338b23a-3042-49d2-a3ea-ec0fed815407");
pub const IID_IMFCameraSyncObject = &IID_IMFCameraSyncObject_Value;
pub const IMFCameraSyncObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitOnSignal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraSyncObject,
                timeOutInMs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFCameraSyncObject,
                timeOutInMs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFCameraSyncObject,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMFCameraSyncObject,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraSyncObject_WaitOnSignal(self: *const T, timeOutInMs: u32) HRESULT {
                return @as(*const IMFCameraSyncObject.VTable, @ptrCast(self.vtable)).WaitOnSignal(@as(*const IMFCameraSyncObject, @ptrCast(self)), timeOutInMs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFCameraSyncObject_Shutdown(self: *const T) void {
                return @as(*const IMFCameraSyncObject.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFCameraSyncObject, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVirtualCamera_Value = Guid.initString("1c08a864-ef6c-4c75-af59-5f2d68da9563");
pub const IID_IMFVirtualCamera = &IID_IMFVirtualCamera_Value;
pub const IMFVirtualCamera = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        AddDeviceSourceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                DeviceSourceInfo: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                DeviceSourceInfo: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                pKey: ?*const DEVPROPKEY,
                Type: u32,
                // TODO: what to do with BytesParamIndex 3?
                pbData: ?*const u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                pKey: ?*const DEVPROPKEY,
                Type: u32,
                // TODO: what to do with BytesParamIndex 3?
                pbData: ?*const u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRegistryEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                EntryName: ?[*:0]const u16,
                SubkeyPath: ?[*:0]const u16,
                dwRegType: u32,
                // TODO: what to do with BytesParamIndex 4?
                pbData: ?*const u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                EntryName: ?[*:0]const u16,
                SubkeyPath: ?[*:0]const u16,
                dwRegType: u32,
                // TODO: what to do with BytesParamIndex 4?
                pbData: ?*const u8,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                pCallback: ?*IMFAsyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                pCallback: ?*IMFAsyncCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                ppMediaSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                ppMediaSource: ?*?*IMFMediaSource,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendCameraProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                propertySet: ?*const Guid,
                propertyId: u32,
                propertyFlags: u32,
                // TODO: what to do with BytesParamIndex 4?
                propertyPayload: ?*anyopaque,
                propertyPayloadLength: u32,
                // TODO: what to do with BytesParamIndex 6?
                data: ?*anyopaque,
                dataLength: u32,
                dataWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                propertySet: ?*const Guid,
                propertyId: u32,
                propertyFlags: u32,
                // TODO: what to do with BytesParamIndex 4?
                propertyPayload: ?*anyopaque,
                propertyPayloadLength: u32,
                // TODO: what to do with BytesParamIndex 6?
                data: ?*anyopaque,
                dataLength: u32,
                dataWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSyncEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                kseventSet: ?*const Guid,
                kseventId: u32,
                kseventFlags: u32,
                eventHandle: ?HANDLE,
                cameraSyncObject: ?*?*IMFCameraSyncObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                kseventSet: ?*const Guid,
                kseventId: u32,
                kseventFlags: u32,
                eventHandle: ?HANDLE,
                cameraSyncObject: ?*?*IMFCameraSyncObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSyncSemaphore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
                kseventSet: ?*const Guid,
                kseventId: u32,
                kseventFlags: u32,
                semaphoreHandle: ?HANDLE,
                semaphoreAdjustment: i32,
                cameraSyncObject: ?*?*IMFCameraSyncObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
                kseventSet: ?*const Guid,
                kseventId: u32,
                kseventFlags: u32,
                semaphoreHandle: ?HANDLE,
                semaphoreAdjustment: i32,
                cameraSyncObject: ?*?*IMFCameraSyncObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMFVirtualCamera,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMFVirtualCamera,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMFAttributes.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_AddDeviceSourceInfo(self: *const T, DeviceSourceInfo: ?[*:0]const u16) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).AddDeviceSourceInfo(@as(*const IMFVirtualCamera, @ptrCast(self)), DeviceSourceInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_AddProperty(self: *const T, pKey: ?*const DEVPROPKEY, Type: u32, pbData: ?*const u8, cbData: u32) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).AddProperty(@as(*const IMFVirtualCamera, @ptrCast(self)), pKey, Type, pbData, cbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_AddRegistryEntry(self: *const T, EntryName: ?[*:0]const u16, SubkeyPath: ?[*:0]const u16, dwRegType: u32, pbData: ?*const u8, cbData: u32) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).AddRegistryEntry(@as(*const IMFVirtualCamera, @ptrCast(self)), EntryName, SubkeyPath, dwRegType, pbData, cbData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_Start(self: *const T, pCallback: ?*IMFAsyncCallback) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).Start(@as(*const IMFVirtualCamera, @ptrCast(self)), pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_Stop(self: *const T) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMFVirtualCamera, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_Remove(self: *const T) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMFVirtualCamera, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_GetMediaSource(self: *const T, ppMediaSource: ?*?*IMFMediaSource) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).GetMediaSource(@as(*const IMFVirtualCamera, @ptrCast(self)), ppMediaSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_SendCameraProperty(self: *const T, propertySet: ?*const Guid, propertyId: u32, propertyFlags: u32, propertyPayload: ?*anyopaque, propertyPayloadLength: u32, data: ?*anyopaque, dataLength: u32, dataWritten: ?*u32) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).SendCameraProperty(@as(*const IMFVirtualCamera, @ptrCast(self)), propertySet, propertyId, propertyFlags, propertyPayload, propertyPayloadLength, data, dataLength, dataWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_CreateSyncEvent(self: *const T, kseventSet: ?*const Guid, kseventId: u32, kseventFlags: u32, eventHandle: ?HANDLE, cameraSyncObject: ?*?*IMFCameraSyncObject) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).CreateSyncEvent(@as(*const IMFVirtualCamera, @ptrCast(self)), kseventSet, kseventId, kseventFlags, eventHandle, cameraSyncObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_CreateSyncSemaphore(self: *const T, kseventSet: ?*const Guid, kseventId: u32, kseventFlags: u32, semaphoreHandle: ?HANDLE, semaphoreAdjustment: i32, cameraSyncObject: ?*?*IMFCameraSyncObject) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).CreateSyncSemaphore(@as(*const IMFVirtualCamera, @ptrCast(self)), kseventSet, kseventId, kseventFlags, semaphoreHandle, semaphoreAdjustment, cameraSyncObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMFVirtualCamera_Shutdown(self: *const T) HRESULT {
                return @as(*const IMFVirtualCamera.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IMFVirtualCamera, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const OPM_HDCP_TYPE = enum(i32) {
    @"0" = 0,
    @"1" = 1,
};
pub const OPM_HDCP_TYPE_0 = OPM_HDCP_TYPE.@"0";
pub const OPM_HDCP_TYPE_1 = OPM_HDCP_TYPE.@"1";

pub const OPM_HDCP_STATUS = enum(i32) {
    N = 0,
    FF = 1,
};
pub const OPM_HDCP_STATUS_ON = OPM_HDCP_STATUS.N;
pub const OPM_HDCP_STATUS_OFF = OPM_HDCP_STATUS.FF;

pub const D3DCONTENTPROTECTIONCAPS = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Caps: u32,
        KeyExchangeType: Guid,
        BufferAlignmentStart: u32,
        BlockAlignmentSize: u32,
        ProtectedMemorySize: u64,
    },
    .X86 => extern struct {
        Caps: u32 align(4),
        KeyExchangeType: Guid align(4),
        BufferAlignmentStart: u32 align(4),
        BlockAlignmentSize: u32 align(4),
        ProtectedMemorySize: u64 align(4),
    },
};
pub const DXVA_VideoSample2 = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Size: u32,
        Reserved: u32,
        rtStart: i64,
        rtEnd: i64,
        SampleFormat: u32,
        SampleFlags: u32,
        lpDDSSrcSurface: ?*anyopaque,
        rcSrc: RECT,
        rcDst: RECT,
        Palette: [16]DXVA_AYUVsample2,
    },
    .X86 => extern struct {
        rtStart: i64,
        rtEnd: i64,
        SampleFormat: u32,
        SampleFlags: u32,
        lpDDSSrcSurface: ?*anyopaque,
        rcSrc: RECT,
        rcDst: RECT,
        Palette: [16]DXVA_AYUVsample2,
    },
};
pub const DXVA_VideoSample32 = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        rtStart: i64,
        rtEnd: i64,
        SampleFormat: u32,
        SampleFlags: u32,
        lpDDSSrcSurface: u32,
        rcSrc: RECT,
        rcDst: RECT,
        Palette: [16]DXVA_AYUVsample2,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const DXVA_DeinterlaceBltEx32 = switch (@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Size: u32,
        BackgroundColor: DXVA_AYUVsample2,
        rcTarget: RECT,
        rtTarget: i64,
        NumSourceSurfaces: u32,
        Alpha: f32,
        Source: [32]DXVA_VideoSample32,
        DestinationFormat: u32,
        DestinationFlags: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

//--------------------------------------------------------------------------------
// Section: Functions (242)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.1'
pub extern "dxva2" fn DXVAHD_CreateDevice(
    pD3DDevice: ?*IDirect3DDevice9Ex,
    pContentDesc: ?*const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    pPlugin: ?PDXVAHDSW_Plugin,
    ppDevice: ?*?*IDXVAHD_Device,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "dxva2" fn DXVA2CreateDirect3DDeviceManager9(
    pResetToken: ?*u32,
    ppDeviceManager: ?*?*IDirect3DDeviceManager9,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "dxva2" fn DXVA2CreateVideoService(
    pDD: ?*IDirect3DDevice9,
    riid: ?*const Guid,
    ppService: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "dxva2" fn OPMGetVideoOutputsFromHMONITOR(
    hMonitor: ?HMONITOR,
    vos: OPM_VIDEO_OUTPUT_SEMANTICS,
    pulNumVideoOutputs: ?*u32,
    pppOPMVideoOutputArray: ?*?*?*IOPMVideoOutput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "dxva2" fn OPMGetVideoOutputForTarget(
    pAdapterLuid: ?*LUID,
    VidPnTarget: u32,
    vos: OPM_VIDEO_OUTPUT_SEMANTICS,
    ppOPMVideoOutput: ?*?*IOPMVideoOutput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "dxva2" fn OPMGetVideoOutputsFromIDirect3DDevice9Object(
    pDirect3DDevice9: ?*IDirect3DDevice9,
    vos: OPM_VIDEO_OUTPUT_SEMANTICS,
    pulNumVideoOutputs: ?*u32,
    pppOPMVideoOutputArray: ?*?*?*IOPMVideoOutput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFSerializeAttributesToStream(
    pAttr: ?*IMFAttributes,
    dwOptions: u32,
    pStm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFDeserializeAttributesFromStream(
    pAttr: ?*IMFAttributes,
    dwOptions: u32,
    pStm: ?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFCreateTransformActivate(
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateMediaSession(
    pConfiguration: ?*IMFAttributes,
    ppMediaSession: ?*?*IMFMediaSession,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreatePMPMediaSession(
    dwCreationFlags: u32,
    pConfiguration: ?*IMFAttributes,
    ppMediaSession: ?*?*IMFMediaSession,
    ppEnablerActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateSourceResolver(
    ppISourceResolver: ?*?*IMFSourceResolver,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn CreatePropertyStore(
    ppStore: ?*?*IPropertyStore,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetSupportedSchemes(
    pPropVarSchemeArray: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetSupportedMimeTypes(
    pPropVarMimeTypeArray: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateTopology(
    ppTopo: ?*?*IMFTopology,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateTopologyNode(
    NodeType: MF_TOPOLOGY_TYPE,
    ppNode: ?*?*IMFTopologyNode,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFGetTopoNodeCurrentType(
    pNode: ?*IMFTopologyNode,
    dwStreamIndex: u32,
    fOutput: BOOL,
    ppType: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFGetService(
    punkObject: ?*IUnknown,
    guidService: ?*const Guid,
    riid: ?*const Guid,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetSystemTime() callconv(@import("std").os.windows.WINAPI) i64;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreatePresentationClock(
    ppPresentationClock: ?*?*IMFPresentationClock,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateSystemTimeSource(
    ppSystemTimeSource: ?*?*IMFPresentationTimeSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreatePresentationDescriptor(
    cStreamDescriptors: u32,
    apStreamDescriptors: ?[*]?*IMFStreamDescriptor,
    ppPresentationDescriptor: ?*?*IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFRequireProtectedEnvironment(
    pPresentationDescriptor: ?*IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFSerializePresentationDescriptor(
    pPD: ?*IMFPresentationDescriptor,
    pcbData: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    ppbData: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFDeserializePresentationDescriptor(
    cbData: u32,
    pbData: [*:0]u8,
    ppPD: ?*?*IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateStreamDescriptor(
    dwStreamIdentifier: u32,
    cMediaTypes: u32,
    apMediaTypes: [*]?*IMFMediaType,
    ppDescriptor: ?*?*IMFStreamDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateSimpleTypeHandler(
    ppHandler: ?*?*IMFMediaTypeHandler,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFShutdownObject(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateAudioRenderer(
    pAudioAttributes: ?*IMFAttributes,
    ppSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateAudioRendererActivate(
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateVideoRendererActivate(
    hwndVideo: ?HWND,
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateMPEG4MediaSink(
    pIByteStream: ?*IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreate3GPMediaSink(
    pIByteStream: ?*IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateMP3MediaSink(
    pTargetByteStream: ?*IMFByteStream,
    ppMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFCreateAC3MediaSink(
    pTargetByteStream: ?*IMFByteStream,
    pAudioMediaType: ?*IMFMediaType,
    ppMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFCreateADTSMediaSink(
    pTargetByteStream: ?*IMFByteStream,
    pAudioMediaType: ?*IMFMediaType,
    ppMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFCreateMuxSink(
    guidOutputSubType: Guid,
    pOutputAttributes: ?*IMFAttributes,
    pOutputByteStream: ?*IMFByteStream,
    ppMuxSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFCreateFMPEG4MediaSink(
    pIByteStream: ?*IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mfsrcsnk" fn MFCreateAVIMediaSink(
    pIByteStream: ?*IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.1'
pub extern "mfsrcsnk" fn MFCreateWAVEMediaSink(
    pTargetByteStream: ?*IMFByteStream,
    pAudioMediaType: ?*IMFMediaType,
    ppMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateTopoLoader(
    ppObj: ?*?*IMFTopoLoader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateSampleGrabberSinkActivate(
    pIMFMediaType: ?*IMFMediaType,
    pIMFSampleGrabberSinkCallback: ?*IMFSampleGrabberSinkCallback,
    ppIActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateStandardQualityManager(
    ppQualityManager: ?*?*IMFQualityManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateSequencerSource(
    pReserved: ?*IUnknown,
    ppSequencerSource: ?*?*IMFSequencerSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateSequencerSegmentOffset(
    dwId: u32,
    hnsOffset: i64,
    pvarSegmentOffset: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateAggregateSource(
    pSourceCollection: ?*IMFCollection,
    ppAggSource: ?*?*IMFMediaSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateCredentialCache(
    ppCache: ?*?*IMFNetCredentialCache,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateProxyLocator(
    pszProtocol: ?[*:0]const u16,
    pProxyConfig: ?*IPropertyStore,
    ppProxyLocator: ?*?*IMFNetProxyLocator,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateNetSchemePlugin(
    riid: ?*const Guid,
    ppvHandler: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreatePMPServer(
    dwCreationFlags: u32,
    ppPMPServer: ?*?*IMFPMPServer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateRemoteDesktopPlugin(
    ppPlugin: ?*?*IMFRemoteDesktopPlugin,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn CreateNamedPropertyStore(
    ppStore: ?*?*INamedPropertyStore,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateSampleCopierMFT(
    ppCopierMFT: ?*?*IMFTransform,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateTranscodeProfile(
    ppTranscodeProfile: ?*?*IMFTranscodeProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateTranscodeTopology(
    pSrc: ?*IMFMediaSource,
    pwszOutputFilePath: ?[*:0]const u16,
    pProfile: ?*IMFTranscodeProfile,
    ppTranscodeTopo: ?*?*IMFTopology,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFCreateTranscodeTopologyFromByteStream(
    pSrc: ?*IMFMediaSource,
    pOutputStream: ?*IMFByteStream,
    pProfile: ?*IMFTranscodeProfile,
    ppTranscodeTopo: ?*?*IMFTopology,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFTranscodeGetAudioOutputAvailableTypes(
    guidSubType: ?*const Guid,
    dwMFTFlags: u32,
    pCodecConfig: ?*IMFAttributes,
    ppAvailableTypes: ?*?*IMFCollection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateTranscodeSinkActivate(
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateTrackedSample(
    ppMFSample: ?*?*IMFTrackedSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFCreateMFByteStreamOnStream(
    pStream: ?*IStream,
    ppByteStream: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateStreamOnMFByteStream(
    pByteStream: ?*IMFByteStream,
    ppStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateMFByteStreamOnStreamEx(
    punkStream: ?*IUnknown,
    ppByteStream: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateStreamOnMFByteStreamEx(
    pByteStream: ?*IMFByteStream,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateMediaTypeFromProperties(
    punkStream: ?*IUnknown,
    ppMediaType: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreatePropertiesFromMediaType(
    pMediaType: ?*IMFMediaType,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFEnumDeviceSources(
    pAttributes: ?*IMFAttributes,
    pppSourceActivate: ?*?*?*IMFActivate,
    pcSourceActivate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateDeviceSource(
    pAttributes: ?*IMFAttributes,
    ppSource: ?*?*IMFMediaSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateDeviceSourceActivate(
    pAttributes: ?*IMFAttributes,
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFCreateProtectedEnvironmentAccess(
    ppAccess: ?*?*IMFProtectedEnvironmentAccess,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFLoadSignedLibrary(
    pszName: ?[*:0]const u16,
    ppLib: ?*?*IMFSignedLibrary,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFGetSystemId(
    ppId: ?*?*IMFSystemId,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mf" fn MFGetLocalId(
    // TODO: what to do with BytesParamIndex 1?
    verifier: ?*const u8,
    size: u32,
    id: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "mfplat" fn MFCreateContentProtectionDevice(
    ProtectionSystemId: ?*const Guid,
    ContentProtectionDevice: ?*?*IMFContentProtectionDevice,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "mfplat" fn MFIsContentProtectionDeviceSupported(
    ProtectionSystemId: ?*const Guid,
    isSupported: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "mfplat" fn MFCreateContentDecryptorContext(
    guidMediaProtectionSystemId: ?*const Guid,
    pD3DManager: ?*IMFDXGIDeviceManager,
    pContentProtectionDevice: ?*IMFContentProtectionDevice,
    ppContentDecryptorContext: ?*?*IMFContentDecryptorContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.14393'
pub extern "mfsensorgroup" fn MFCreateSensorGroup(
    SensorGroupSymbolicLink: ?[*:0]const u16,
    ppSensorGroup: ?*?*IMFSensorGroup,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "mfsensorgroup" fn MFCreateSensorStream(
    StreamId: u32,
    pAttributes: ?*IMFAttributes,
    pMediaTypeCollection: ?*IMFCollection,
    ppStream: ?*?*IMFSensorStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.17134'
pub extern "mfsensorgroup" fn MFCreateSensorProfile(
    ProfileType: ?*const Guid,
    ProfileIndex: u32,
    Constraints: ?[*:0]const u16,
    ppProfile: ?*?*IMFSensorProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "mfsensorgroup" fn MFCreateSensorProfileCollection(
    ppSensorProfile: ?*?*IMFSensorProfileCollection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfsensorgroup" fn MFCreateSensorActivityMonitor(
    pCallback: ?*IMFSensorActivitiesReportCallback,
    ppActivityMonitor: ?*?*IMFSensorActivityMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfcore" fn MFCreateExtendedCameraIntrinsics(
    ppExtendedCameraIntrinsics: ?*?*IMFExtendedCameraIntrinsics,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfcore" fn MFCreateExtendedCameraIntrinsicModel(
    distortionModelType: MFCameraIntrinsic_DistortionModelType,
    ppExtendedCameraIntrinsicModel: ?*?*IMFExtendedCameraIntrinsicModel,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "mfsensorgroup" fn MFCreateRelativePanelWatcher(
    videoDeviceId: ?[*:0]const u16,
    displayMonitorDeviceId: ?[*:0]const u16,
    ppRelativePanelWatcher: ?*?*IMFRelativePanelWatcher,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfsensorgroup" fn MFCreateCameraOcclusionStateMonitor(
    symbolicLink: ?[*:0]const u16,
    callback: ?*IMFCameraOcclusionStateReportCallback,
    occlusionStateMonitor: ?*?*IMFCameraOcclusionStateMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFContentInfo(
    ppIContentInfo: ?*?*IMFASFContentInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFIndexer(
    ppIIndexer: ?*?*IMFASFIndexer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFIndexerByteStream(
    pIContentByteStream: ?*IMFByteStream,
    cbIndexStartOffset: u64,
    pIIndexByteStream: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFSplitter(
    ppISplitter: ?*?*IMFASFSplitter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFProfile(
    ppIProfile: ?*?*IMFASFProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFProfileFromPresentationDescriptor(
    pIPD: ?*IMFPresentationDescriptor,
    ppIProfile: ?*?*IMFASFProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreatePresentationDescriptorFromASFProfile(
    pIProfile: ?*IMFASFProfile,
    ppIPD: ?*?*IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFMultiplexer(
    ppIMultiplexer: ?*?*IMFASFMultiplexer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFStreamSelector(
    pIASFProfile: ?*IMFASFProfile,
    ppSelector: ?*?*IMFASFStreamSelector,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFMediaSink(
    pIByteStream: ?*IMFByteStream,
    ppIMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateASFMediaSinkActivate(
    pwszFileName: ?[*:0]const u16,
    pContentInfo: ?*IMFASFContentInfo,
    ppIActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateWMVEncoderActivate(
    pMediaType: ?*IMFMediaType,
    pEncodingConfigurationProperties: ?*IPropertyStore,
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mf" fn MFCreateWMAEncoderActivate(
    pMediaType: ?*IMFMediaType,
    pEncodingConfigurationProperties: ?*IPropertyStore,
    ppActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateASFStreamingMediaSink(
    pIByteStream: ?*IMFByteStream,
    ppIMediaSink: ?*?*IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mf" fn MFCreateASFStreamingMediaSinkActivate(
    pByteStreamActivate: ?*IMFActivate,
    pContentInfo: ?*IMFASFContentInfo,
    ppIActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfplat" fn MFCreateD3D12SynchronizationObject(
    pDevice: ?*ID3D12Device,
    riid: ?*const Guid,
    ppvSyncObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFStartup(
    Version: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFShutdown() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFLockPlatform() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFUnlockPlatform() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFPutWorkItem(
    dwQueue: u32,
    pCallback: ?*IMFAsyncCallback,
    pState: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFPutWorkItem2(
    dwQueue: u32,
    Priority: i32,
    pCallback: ?*IMFAsyncCallback,
    pState: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFPutWorkItemEx(
    dwQueue: u32,
    pResult: ?*IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFPutWorkItemEx2(
    dwQueue: u32,
    Priority: i32,
    pResult: ?*IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFPutWaitingWorkItem(
    hEvent: ?HANDLE,
    Priority: i32,
    pResult: ?*IMFAsyncResult,
    pKey: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFAllocateSerialWorkQueue(
    dwWorkQueue: u32,
    pdwWorkQueue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFScheduleWorkItemEx(
    pResult: ?*IMFAsyncResult,
    Timeout: i64,
    pKey: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFScheduleWorkItem(
    pCallback: ?*IMFAsyncCallback,
    pState: ?*IUnknown,
    Timeout: i64,
    pKey: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCancelWorkItem(
    Key: u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetTimerPeriodicity(
    Periodicity: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFAddPeriodicCallback(
    Callback: ?MFPERIODICCALLBACK,
    pContext: ?*IUnknown,
    pdwKey: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFRemovePeriodicCallback(
    dwKey: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFAllocateWorkQueueEx(
    WorkQueueType: MFASYNC_WORKQUEUE_TYPE,
    pdwWorkQueue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFAllocateWorkQueue(
    pdwWorkQueue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFLockWorkQueue(
    dwWorkQueue: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFUnlockWorkQueue(
    dwWorkQueue: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFBeginRegisterWorkQueueWithMMCSS(
    dwWorkQueueId: u32,
    wszClass: ?[*:0]const u16,
    dwTaskId: u32,
    pDoneCallback: ?*IMFAsyncCallback,
    pDoneState: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFBeginRegisterWorkQueueWithMMCSSEx(
    dwWorkQueueId: u32,
    wszClass: ?[*:0]const u16,
    dwTaskId: u32,
    lPriority: i32,
    pDoneCallback: ?*IMFAsyncCallback,
    pDoneState: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFEndRegisterWorkQueueWithMMCSS(
    pResult: ?*IMFAsyncResult,
    pdwTaskId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFBeginUnregisterWorkQueueWithMMCSS(
    dwWorkQueueId: u32,
    pDoneCallback: ?*IMFAsyncCallback,
    pDoneState: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFEndUnregisterWorkQueueWithMMCSS(
    pResult: ?*IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetWorkQueueMMCSSClass(
    dwWorkQueueId: u32,
    pwszClass: ?[*:0]u16,
    pcchClass: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetWorkQueueMMCSSTaskId(
    dwWorkQueueId: u32,
    pdwTaskId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFRegisterPlatformWithMMCSS(
    wszClass: ?[*:0]const u16,
    pdwTaskId: ?*u32,
    lPriority: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFUnregisterPlatformFromMMCSS() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFLockSharedWorkQueue(
    wszClass: ?[*:0]const u16,
    BasePriority: i32,
    pdwTaskId: ?*u32,
    pID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFGetWorkQueueMMCSSPriority(
    dwWorkQueueId: u32,
    lPriority: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateAsyncResult(
    punkObject: ?*IUnknown,
    pCallback: ?*IMFAsyncCallback,
    punkState: ?*IUnknown,
    ppAsyncResult: ?*?*IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInvokeCallback(
    pAsyncResult: ?*IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateFile(
    AccessMode: MF_FILE_ACCESSMODE,
    OpenMode: MF_FILE_OPENMODE,
    fFlags: MF_FILE_FLAGS,
    pwszFileURL: ?[*:0]const u16,
    ppIByteStream: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateTempFile(
    AccessMode: MF_FILE_ACCESSMODE,
    OpenMode: MF_FILE_OPENMODE,
    fFlags: MF_FILE_FLAGS,
    ppIByteStream: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFBeginCreateFile(
    AccessMode: MF_FILE_ACCESSMODE,
    OpenMode: MF_FILE_OPENMODE,
    fFlags: MF_FILE_FLAGS,
    pwszFilePath: ?[*:0]const u16,
    pCallback: ?*IMFAsyncCallback,
    pState: ?*IUnknown,
    ppCancelCookie: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFEndCreateFile(
    pResult: ?*IMFAsyncResult,
    ppFile: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCancelCreateFile(
    pCancelCookie: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateMemoryBuffer(
    cbMaxLength: u32,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateMediaBufferWrapper(
    pBuffer: ?*IMFMediaBuffer,
    cbOffset: u32,
    dwLength: u32,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateLegacyMediaBufferOnMFMediaBuffer(
    pSample: ?*IMFSample,
    pMFMediaBuffer: ?*IMFMediaBuffer,
    cbOffset: u32,
    ppMediaBuffer: ?*?*IMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFMapDX9FormatToDXGIFormat(
    dx9: u32,
) callconv(@import("std").os.windows.WINAPI) DXGI_FORMAT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFMapDXGIFormatToDX9Format(
    dx11: DXGI_FORMAT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFLockDXGIDeviceManager(
    pResetToken: ?*u32,
    ppManager: ?*?*IMFDXGIDeviceManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFUnlockDXGIDeviceManager() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateDXSurfaceBuffer(
    riid: ?*const Guid,
    punkSurface: ?*IUnknown,
    fBottomUpWhenLinear: BOOL,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateWICBitmapBuffer(
    riid: ?*const Guid,
    punkSurface: ?*IUnknown,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateDXGISurfaceBuffer(
    riid: ?*const Guid,
    punkSurface: ?*IUnknown,
    uSubresourceIndex: u32,
    fBottomUpWhenLinear: BOOL,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateVideoSampleAllocatorEx(
    riid: ?*const Guid,
    ppSampleAllocator: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateDXGIDeviceManager(
    resetToken: ?*u32,
    ppDeviceManager: ?*?*IMFDXGIDeviceManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateAlignedMemoryBuffer(
    cbMaxLength: u32,
    cbAligment: u32,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateMediaEvent(
    met: u32,
    guidExtendedType: ?*const Guid,
    hrStatus: HRESULT,
    pvValue: ?*const PROPVARIANT,
    ppEvent: ?*?*IMFMediaEvent,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateEventQueue(
    ppMediaEventQueue: ?*?*IMFMediaEventQueue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateSample(
    ppIMFSample: ?*?*IMFSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateAttributes(
    ppMFAttributes: ?*?*IMFAttributes,
    cInitialSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitAttributesFromBlob(
    pAttributes: ?*IMFAttributes,
    // TODO: what to do with BytesParamIndex 2?
    pBuf: ?*const u8,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetAttributesAsBlobSize(
    pAttributes: ?*IMFAttributes,
    pcbBufSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetAttributesAsBlob(
    pAttributes: ?*IMFAttributes,
    // TODO: what to do with BytesParamIndex 2?
    pBuf: ?*u8,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFTRegister(
    clsidMFT: Guid,
    guidCategory: Guid,
    pszName: ?PWSTR,
    Flags: u32,
    cInputTypes: u32,
    pInputTypes: ?[*]MFT_REGISTER_TYPE_INFO,
    cOutputTypes: u32,
    pOutputTypes: ?[*]MFT_REGISTER_TYPE_INFO,
    pAttributes: ?*IMFAttributes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFTUnregister(
    clsidMFT: Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFTRegisterLocal(
    pClassFactory: ?*IClassFactory,
    guidCategory: ?*const Guid,
    pszName: ?[*:0]const u16,
    Flags: u32,
    cInputTypes: u32,
    pInputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
    cOutputTypes: u32,
    pOutputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFTUnregisterLocal(
    pClassFactory: ?*IClassFactory,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFTRegisterLocalByCLSID(
    clisdMFT: ?*const Guid,
    guidCategory: ?*const Guid,
    pszName: ?[*:0]const u16,
    Flags: u32,
    cInputTypes: u32,
    pInputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
    cOutputTypes: u32,
    pOutputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFTUnregisterLocalByCLSID(
    clsidMFT: Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFTEnum(
    guidCategory: Guid,
    Flags: u32,
    pInputType: ?*MFT_REGISTER_TYPE_INFO,
    pOutputType: ?*MFT_REGISTER_TYPE_INFO,
    pAttributes: ?*IMFAttributes,
    ppclsidMFT: ?*?*Guid,
    pcMFTs: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFTEnumEx(
    guidCategory: Guid,
    Flags: u32,
    pInputType: ?*const MFT_REGISTER_TYPE_INFO,
    pOutputType: ?*const MFT_REGISTER_TYPE_INFO,
    pppMFTActivate: ?*?*?*IMFActivate,
    pnumMFTActivate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "mfplat" fn MFTEnum2(
    guidCategory: Guid,
    Flags: u32,
    pInputType: ?*const MFT_REGISTER_TYPE_INFO,
    pOutputType: ?*const MFT_REGISTER_TYPE_INFO,
    pAttributes: ?*IMFAttributes,
    pppMFTActivate: ?*?*?*IMFActivate,
    pnumMFTActivate: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFTGetInfo(
    clsidMFT: Guid,
    pszName: ?*?PWSTR,
    ppInputTypes: ?*?*MFT_REGISTER_TYPE_INFO,
    pcInputTypes: ?*u32,
    ppOutputTypes: ?*?*MFT_REGISTER_TYPE_INFO,
    pcOutputTypes: ?*u32,
    ppAttributes: ?*?*IMFAttributes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFGetPluginControl(
    ppPluginControl: ?*?*IMFPluginControl,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFGetMFTMerit(
    pMFT: ?*IUnknown,
    cbVerifier: u32,
    // TODO: what to do with BytesParamIndex 1?
    verifier: ?*const u8,
    merit: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFRegisterLocalSchemeHandler(
    szScheme: ?[*:0]const u16,
    pActivate: ?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFRegisterLocalByteStreamHandler(
    szFileExtension: ?[*:0]const u16,
    szMimeType: ?[*:0]const u16,
    pActivate: ?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateMFByteStreamWrapper(
    pStream: ?*IMFByteStream,
    ppStreamWrapper: ?*?*IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateMediaExtensionActivate(
    szActivatableClassId: ?[*:0]const u16,
    pConfiguration: ?*IUnknown,
    riid: ?*const Guid,
    ppvObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "mfplat" fn MFCreateMuxStreamAttributes(
    pAttributesToMux: ?*IMFCollection,
    ppMuxAttribs: ?*?*IMFAttributes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "mfplat" fn MFCreateMuxStreamMediaType(
    pMediaTypesToMux: ?*IMFCollection,
    ppMuxMediaType: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "mfplat" fn MFCreateMuxStreamSample(
    pSamplesToMux: ?*IMFCollection,
    ppMuxSample: ?*?*IMFSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFValidateMediaTypeSize(
    FormatType: Guid,
    // TODO: what to do with BytesParamIndex 2?
    pBlock: ?*u8,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateMediaType(
    ppMFType: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateMFVideoFormatFromMFMediaType(
    pMFType: ?*IMFMediaType,
    ppMFVF: ?*?*MFVIDEOFORMAT,
    pcbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateWaveFormatExFromMFMediaType(
    pMFType: ?*IMFMediaType,
    ppWF: ?*?*WAVEFORMATEX,
    pcbSize: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromVideoInfoHeader(
    pMFType: ?*IMFMediaType,
    // TODO: what to do with BytesParamIndex 2?
    pVIH: ?*const VIDEOINFOHEADER,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromVideoInfoHeader2(
    pMFType: ?*IMFMediaType,
    // TODO: what to do with BytesParamIndex 2?
    pVIH2: ?*const VIDEOINFOHEADER2,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromMPEG1VideoInfo(
    pMFType: ?*IMFMediaType,
    // TODO: what to do with BytesParamIndex 2?
    pMP1VI: ?*const MPEG1VIDEOINFO,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromMPEG2VideoInfo(
    pMFType: ?*IMFMediaType,
    // TODO: what to do with BytesParamIndex 2?
    pMP2VI: ?*const MPEG2VIDEOINFO,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCalculateBitmapImageSize(
    // TODO: what to do with BytesParamIndex 1?
    pBMIH: ?*const BITMAPINFOHEADER,
    cbBufSize: u32,
    pcbImageSize: ?*u32,
    pbKnown: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCalculateImageSize(
    guidSubtype: ?*const Guid,
    unWidth: u32,
    unHeight: u32,
    pcbImageSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFFrameRateToAverageTimePerFrame(
    unNumerator: u32,
    unDenominator: u32,
    punAverageTimePerFrame: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFAverageTimePerFrameToFrameRate(
    unAverageTimePerFrame: u64,
    punNumerator: ?*u32,
    punDenominator: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromMFVideoFormat(
    pMFType: ?*IMFMediaType,
    // TODO: what to do with BytesParamIndex 2?
    pMFVF: ?*const MFVIDEOFORMAT,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromWaveFormatEx(
    pMFType: ?*IMFMediaType,
    // TODO: what to do with BytesParamIndex 2?
    pWaveFormat: ?*const WAVEFORMATEX,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitMediaTypeFromAMMediaType(
    pMFType: ?*IMFMediaType,
    pAMType: ?*const AM_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitAMMediaTypeFromMFMediaType(
    pMFType: ?*IMFMediaType,
    guidFormatBlockType: Guid,
    pAMType: ?*AM_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateAMMediaTypeFromMFMediaType(
    pMFType: ?*IMFMediaType,
    guidFormatBlockType: Guid,
    ppAMType: ?*?*AM_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCompareFullToPartialMediaType(
    pMFTypeFull: ?*IMFMediaType,
    pMFTypePartial: ?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFWrapMediaType(
    pOrig: ?*IMFMediaType,
    MajorType: ?*const Guid,
    SubType: ?*const Guid,
    ppWrap: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFUnwrapMediaType(
    pWrap: ?*IMFMediaType,
    ppOrig: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateVideoMediaType(
    pVideoFormat: ?*const MFVIDEOFORMAT,
    ppIVideoMediaType: ?*?*IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateVideoMediaTypeFromSubtype(
    pAMSubtype: ?*const Guid,
    ppIVideoMediaType: ?*?*IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "evr" fn MFIsFormatYUV(
    Format: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateVideoMediaTypeFromBitMapInfoHeader(
    pbmihBitMapInfoHeader: ?*const BITMAPINFOHEADER,
    dwPixelAspectRatioX: u32,
    dwPixelAspectRatioY: u32,
    InterlaceMode: MFVideoInterlaceMode,
    VideoFlags: u64,
    qwFramesPerSecondNumerator: u64,
    qwFramesPerSecondDenominator: u64,
    dwMaxBitRate: u32,
    ppIVideoMediaType: ?*?*IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetStrideForBitmapInfoHeader(
    format: u32,
    dwWidth: u32,
    pStride: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "evr" fn MFGetPlaneSize(
    format: u32,
    dwWidth: u32,
    dwHeight: u32,
    pdwPlaneSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(
    // TODO: what to do with BytesParamIndex 1?
    pbmihBitMapInfoHeader: ?*const BITMAPINFOHEADER,
    cbBitMapInfoHeader: u32,
    dwPixelAspectRatioX: u32,
    dwPixelAspectRatioY: u32,
    InterlaceMode: MFVideoInterlaceMode,
    VideoFlags: u64,
    dwFramesPerSecondNumerator: u32,
    dwFramesPerSecondDenominator: u32,
    dwMaxBitRate: u32,
    ppIVideoMediaType: ?*?*IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateMediaTypeFromRepresentation(
    guidRepresentation: Guid,
    pvRepresentation: ?*anyopaque,
    ppIMediaType: ?*?*IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateAudioMediaType(
    pAudioFormat: ?*const WAVEFORMATEX,
    ppIAudioMediaType: ?*?*IMFAudioMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFGetUncompressedVideoFormat(
    pVideoFormat: ?*const MFVIDEOFORMAT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitVideoFormat(
    pVideoFormat: ?*MFVIDEOFORMAT,
    type: MFStandardVideoFormat,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFInitVideoFormat_RGB(
    pVideoFormat: ?*MFVIDEOFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    D3Dfmt: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFConvertColorInfoToDXVA(
    pdwToDXVA: ?*u32,
    pFromFormat: ?*const MFVIDEOFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFConvertColorInfoFromDXVA(
    pToFormat: ?*MFVIDEOFORMAT,
    dwFromDXVA: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCopyImage(
    pDest: ?*u8,
    lDestStride: i32,
    pSrc: ?*const u8,
    lSrcStride: i32,
    dwWidthInBytes: u32,
    dwLines: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFConvertFromFP16Array(
    pDest: [*]f32,
    pSrc: [*:0]const u16,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFConvertToFP16Array(
    pDest: [*:0]u16,
    pSrc: [*]const f32,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreate2DMediaBuffer(
    dwWidth: u32,
    dwHeight: u32,
    dwFourCC: u32,
    fBottomUp: BOOL,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFCreateMediaBufferFromMediaType(
    pMediaType: ?*IMFMediaType,
    llDuration: i64,
    dwMinLength: u32,
    dwMinAlignment: u32,
    ppBuffer: ?*?*IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFCreateCollection(
    ppIMFCollection: ?*?*IMFCollection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFHeapAlloc(
    nSize: usize,
    dwFlags: u32,
    pszFile: ?PSTR,
    line: i32,
    eat: EAllocationType,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "mfplat" fn MFHeapFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfplat" fn MFllMulDiv(
    a: i64,
    b: i64,
    c: i64,
    d: i64,
) callconv(@import("std").os.windows.WINAPI) i64;

// TODO: this type is limited to platform 'windows8.0'
pub extern "mfplat" fn MFGetContentProtectionSystemCLSID(
    guidProtectionSystemID: ?*const Guid,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "mfplat" fn MFCombineSamples(
    pSample: ?*IMFSample,
    pSampleToAdd: ?*IMFSample,
    dwMaxMergedDurationInMS: u32,
    pMerged: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "mfplat" fn MFSplitSample(
    pSample: ?*IMFSample,
    pOutputSamples: [*]?*IMFSample,
    dwOutputSampleMaxCount: u32,
    pdwOutputSampleCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfreadwrite" fn MFCreateSourceReaderFromURL(
    pwszURL: ?[*:0]const u16,
    pAttributes: ?*IMFAttributes,
    ppSourceReader: ?*?*IMFSourceReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfreadwrite" fn MFCreateSourceReaderFromByteStream(
    pByteStream: ?*IMFByteStream,
    pAttributes: ?*IMFAttributes,
    ppSourceReader: ?*?*IMFSourceReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfreadwrite" fn MFCreateSourceReaderFromMediaSource(
    pMediaSource: ?*IMFMediaSource,
    pAttributes: ?*IMFAttributes,
    ppSourceReader: ?*?*IMFSourceReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfreadwrite" fn MFCreateSinkWriterFromURL(
    pwszOutputURL: ?[*:0]const u16,
    pByteStream: ?*IMFByteStream,
    pAttributes: ?*IMFAttributes,
    ppSinkWriter: ?*?*IMFSinkWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "mfreadwrite" fn MFCreateSinkWriterFromMediaSink(
    pMediaSink: ?*IMFMediaSink,
    pAttributes: ?*IMFAttributes,
    ppSinkWriter: ?*?*IMFSinkWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "evr" fn MFCreateVideoPresenter(
    pOwner: ?*IUnknown,
    riidDevice: ?*const Guid,
    riid: ?*const Guid,
    ppVideoPresenter: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "evr" fn MFCreateVideoMixer(
    pOwner: ?*IUnknown,
    riidDevice: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "evr" fn MFCreateVideoMixerAndPresenter(
    pMixerOwner: ?*IUnknown,
    pPresenterOwner: ?*IUnknown,
    riidMixer: ?*const Guid,
    ppvVideoMixer: ?*?*anyopaque,
    riidPresenter: ?*const Guid,
    ppvVideoPresenter: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mf" fn MFCreateVideoRenderer(
    riidRenderer: ?*const Guid,
    ppVideoRenderer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "evr" fn MFCreateVideoSampleFromSurface(
    pUnkSurface: ?*IUnknown,
    ppSample: ?*?*IMFSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "evr" fn MFCreateVideoSampleAllocator(
    riid: ?*const Guid,
    ppSampleAllocator: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
// This function from dll 'MFPlay' is being skipped because it has some sort of issue
pub fn MFPCreateMediaPlayer() void {
    @panic("this function is not working");
}

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "mf" fn MFCreateEncryptedMediaExtensionsStoreActivate(
    pmpHost: ?*IMFPMPHostApp,
    objectStream: ?*IStream,
    classId: ?[*:0]const u16,
    activate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfsensorgroup" fn MFCreateVirtualCamera(
    type: __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0001,
    lifetime: __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0002,
    access: __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0003,
    friendlyName: ?[*:0]const u16,
    sourceId: ?[*:0]const u16,
    categories: ?[*]const Guid,
    categoryCount: u32,
    virtualCamera: ?*?*IMFVirtualCamera,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfsensorgroup" fn MFIsVirtualCameraTypeSupported(
    type: __MIDL___MIDL_itf_mfvirtualcamera_0000_0000_0001,
    supported: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "opmxbox" fn OPMXboxEnableHDCP(
    HDCPType: OPM_HDCP_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "opmxbox" fn OPMXboxGetHDCPStatus(
    pHDCPStatus: ?*OPM_HDCP_STATUS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "opmxbox" fn OPMXboxGetHDCPStatusAndType(
    pHDCPStatus: ?*OPM_HDCP_STATUS,
    pHDCPType: ?*OPM_HDCP_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (66)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const AM_MEDIA_TYPE = @import("../media/direct_show.zig").AM_MEDIA_TYPE;
const AudioObjectType = @import("../media/audio.zig").AudioObjectType;
const BITMAPINFOHEADER = @import("../graphics/gdi.zig").BITMAPINFOHEADER;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const D3D12_COMMAND_LIST_SUPPORT_FLAGS = @import("../graphics/direct3d12.zig").D3D12_COMMAND_LIST_SUPPORT_FLAGS;
const D3D12_DISCARD_REGION = @import("../graphics/direct3d12.zig").D3D12_DISCARD_REGION;
const D3D12_PREDICATION_OP = @import("../graphics/direct3d12.zig").D3D12_PREDICATION_OP;
const D3D12_QUERY_TYPE = @import("../graphics/direct3d12.zig").D3D12_QUERY_TYPE;
const D3D12_RESOURCE_BARRIER = @import("../graphics/direct3d12.zig").D3D12_RESOURCE_BARRIER;
const D3D12_WRITEBUFFERIMMEDIATE_MODE = @import("../graphics/direct3d12.zig").D3D12_WRITEBUFFERIMMEDIATE_MODE;
const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER = @import("../graphics/direct3d12.zig").D3D12_WRITEBUFFERIMMEDIATE_PARAMETER;
const D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT = @import("../graphics/direct3d9.zig").D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT;
const D3DAUTHENTICATEDCHANNELTYPE = @import("../graphics/direct3d9.zig").D3DAUTHENTICATEDCHANNELTYPE;
const D3DDEVTYPE = @import("../graphics/direct3d9.zig").D3DDEVTYPE;
const D3DDISPLAYMODEEX = @import("../graphics/direct3d9.zig").D3DDISPLAYMODEEX;
const D3DDISPLAYROTATION = @import("../graphics/direct3d9.zig").D3DDISPLAYROTATION;
const D3DENCRYPTED_BLOCK_INFO = @import("../graphics/direct3d9.zig").D3DENCRYPTED_BLOCK_INFO;
const D3DFORMAT = @import("../graphics/direct3d9.zig").D3DFORMAT;
const D3DPOOL = @import("../graphics/direct3d9.zig").D3DPOOL;
const DEVPROPKEY = @import("../devices/properties.zig").DEVPROPKEY;
const DMO_MEDIA_TYPE = @import("../media/dx_media_objects.zig").DMO_MEDIA_TYPE;
const DXGI_COLOR_SPACE_TYPE = @import("../graphics/dxgi/common.zig").DXGI_COLOR_SPACE_TYPE;
const DXGI_FORMAT = @import("../graphics/dxgi/common.zig").DXGI_FORMAT;
const DXGI_RATIONAL = @import("../graphics/dxgi/common.zig").DXGI_RATIONAL;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HMONITOR = @import("../graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IClassFactory = @import("../system/com.zig").IClassFactory;
const ID3D12CommandAllocator = @import("../graphics/direct3d12.zig").ID3D12CommandAllocator;
const ID3D12CommandList = @import("../graphics/direct3d12.zig").ID3D12CommandList;
const ID3D12CommandQueue = @import("../graphics/direct3d12.zig").ID3D12CommandQueue;
const ID3D12Device = @import("../graphics/direct3d12.zig").ID3D12Device;
const ID3D12Pageable = @import("../graphics/direct3d12.zig").ID3D12Pageable;
const ID3D12ProtectedResourceSession = @import("../graphics/direct3d12.zig").ID3D12ProtectedResourceSession;
const ID3D12QueryHeap = @import("../graphics/direct3d12.zig").ID3D12QueryHeap;
const ID3D12Resource = @import("../graphics/direct3d12.zig").ID3D12Resource;
const IDirect3DDevice9 = @import("../graphics/direct3d9.zig").IDirect3DDevice9;
const IDirect3DDevice9Ex = @import("../graphics/direct3d9.zig").IDirect3DDevice9Ex;
const IDirect3DSurface9 = @import("../graphics/direct3d9.zig").IDirect3DSurface9;
const IInspectable = @import("../system/win_rt.zig").IInspectable;
const IMediaBuffer = @import("../media/dx_media_objects.zig").IMediaBuffer;
const IMFDeviceTransform = @import("../media/streaming.zig").IMFDeviceTransform;
const INamedPropertyStore = @import("../ui/shell/properties_system.zig").INamedPropertyStore;
const IPropertyStore = @import("../ui/shell/properties_system.zig").IPropertyStore;
const ISpatialAudioMetadataItems = @import("../media/audio.zig").ISpatialAudioMetadataItems;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LUID = @import("../foundation.zig").LUID;
const MPEG1VIDEOINFO = @import("../media/direct_show.zig").MPEG1VIDEOINFO;
const MPEG2VIDEOINFO = @import("../media/direct_show.zig").MPEG2VIDEOINFO;
const POINT = @import("../foundation.zig").POINT;
const PROPERTYKEY = @import("../ui/shell/properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("../system/com/structured_storage.zig").PROPVARIANT;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SIZE = @import("../foundation.zig").SIZE;
const VARIANT = @import("../system/com.zig").VARIANT;
const VIDEOINFOHEADER = @import("../media/direct_show.zig").VIDEOINFOHEADER;
const VIDEOINFOHEADER2 = @import("../media/direct_show.zig").VIDEOINFOHEADER2;
const WAVEFORMATEX = @import("../media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PDXVAHDSW_CreateDevice")) {
        _ = PDXVAHDSW_CreateDevice;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_ProposeVideoPrivateFormat")) {
        _ = PDXVAHDSW_ProposeVideoPrivateFormat;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessorDeviceCaps")) {
        _ = PDXVAHDSW_GetVideoProcessorDeviceCaps;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessorOutputFormats")) {
        _ = PDXVAHDSW_GetVideoProcessorOutputFormats;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessorInputFormats")) {
        _ = PDXVAHDSW_GetVideoProcessorInputFormats;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessorCaps")) {
        _ = PDXVAHDSW_GetVideoProcessorCaps;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessorCustomRates")) {
        _ = PDXVAHDSW_GetVideoProcessorCustomRates;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessorFilterRange")) {
        _ = PDXVAHDSW_GetVideoProcessorFilterRange;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_DestroyDevice")) {
        _ = PDXVAHDSW_DestroyDevice;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_CreateVideoProcessor")) {
        _ = PDXVAHDSW_CreateVideoProcessor;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_SetVideoProcessBltState")) {
        _ = PDXVAHDSW_SetVideoProcessBltState;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessBltStatePrivate")) {
        _ = PDXVAHDSW_GetVideoProcessBltStatePrivate;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_SetVideoProcessStreamState")) {
        _ = PDXVAHDSW_SetVideoProcessStreamState;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_GetVideoProcessStreamStatePrivate")) {
        _ = PDXVAHDSW_GetVideoProcessStreamStatePrivate;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_VideoProcessBltHD")) {
        _ = PDXVAHDSW_VideoProcessBltHD;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_DestroyVideoProcessor")) {
        _ = PDXVAHDSW_DestroyVideoProcessor;
    }
    if (@hasDecl(@This(), "PDXVAHDSW_Plugin")) {
        _ = PDXVAHDSW_Plugin;
    }
    if (@hasDecl(@This(), "PDXVAHD_CreateDevice")) {
        _ = PDXVAHD_CreateDevice;
    }
    if (@hasDecl(@This(), "MFPERIODICCALLBACK")) {
        _ = MFPERIODICCALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
