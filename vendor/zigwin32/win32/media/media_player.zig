//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (678)
//--------------------------------------------------------------------------------
pub const CLSID_XFeedsManager = Guid.initString("fe6b11c3-c72e-4061-86c6-9d163121f229");
pub const WMPGC_FLAGS_ALLOW_PREROLL = @as(u32, 1);
pub const WMPGC_FLAGS_SUPPRESS_DIALOGS = @as(u32, 2);
pub const WMPGC_FLAGS_IGNORE_AV_SYNC = @as(u32, 4);
pub const WMPGC_FLAGS_DISABLE_PLUGINS = @as(u32, 8);
pub const WMPGC_FLAGS_USE_CUSTOM_GRAPH = @as(u32, 16);
pub const WMPUE_EC_USER = @as(u32, 33024);
pub const WMP_MDRT_FLAGS_UNREPORTED_DELETED_ITEMS = @as(u32, 1);
pub const WMP_MDRT_FLAGS_UNREPORTED_ADDED_ITEMS = @as(u32, 2);
pub const IOCTL_WMP_METADATA_ROUND_TRIP = @as(u32, 827346263);
pub const IOCTL_WMP_DEVICE_CAN_SYNC = @as(u32, 844123479);
pub const EFFECT_CANGOFULLSCREEN = @as(u32, 1);
pub const EFFECT_HASPROPERTYPAGE = @as(u32, 2);
pub const EFFECT_VARIABLEFREQSTEP = @as(u32, 4);
pub const EFFECT_WINDOWEDONLY = @as(u32, 8);
pub const EFFECT2_FULLSCREENEXCLUSIVE = @as(u32, 16);
pub const SA_BUFFER_SIZE = @as(u32, 1024);
pub const PLUGIN_TYPE_BACKGROUND = @as(u32, 1);
pub const PLUGIN_TYPE_SEPARATEWINDOW = @as(u32, 2);
pub const PLUGIN_TYPE_DISPLAYAREA = @as(u32, 3);
pub const PLUGIN_TYPE_SETTINGSAREA = @as(u32, 4);
pub const PLUGIN_TYPE_METADATAAREA = @as(u32, 5);
pub const PLUGIN_FLAGS_HASPROPERTYPAGE = @as(u32, 2147483648);
pub const PLUGIN_FLAGS_INSTALLAUTORUN = @as(u32, 1073741824);
pub const PLUGIN_FLAGS_LAUNCHPROPERTYPAGE = @as(u32, 536870912);
pub const PLUGIN_FLAGS_ACCEPTSMEDIA = @as(u32, 268435456);
pub const PLUGIN_FLAGS_ACCEPTSPLAYLISTS = @as(u32, 134217728);
pub const PLUGIN_FLAGS_HASPRESETS = @as(u32, 67108864);
pub const PLUGIN_FLAGS_HIDDEN = @as(u32, 33554432);
pub const SUBSCRIPTION_CAP_DEVICEAVAILABLE = @as(u32, 16);
pub const SUBSCRIPTION_CAP_BACKGROUNDPROCESSING = @as(u32, 8);
pub const SUBSCRIPTION_CAP_IS_CONTENTPARTNER = @as(u32, 64);
pub const SUBSCRIPTION_CAP_ALTLOGIN = @as(u32, 128);
pub const SUBSCRIPTION_CAP_ALLOWPLAY = @as(u32, 1);
pub const SUBSCRIPTION_CAP_ALLOWCDBURN = @as(u32, 2);
pub const SUBSCRIPTION_CAP_ALLOWPDATRANSFER = @as(u32, 4);
pub const SUBSCRIPTION_CAP_PREPAREFORSYNC = @as(u32, 32);
pub const SUBSCRIPTION_V1_CAPS = @as(u32, 15);
pub const SUBSCRIPTION_CAP_UILESSMODE_ALLOWPLAY = @as(u32, 256);
pub const DISPID_FEEDS_RootFolder = @as(u32, 4096);
pub const DISPID_FEEDS_IsSubscribed = @as(u32, 4097);
pub const DISPID_FEEDS_ExistsFeed = @as(u32, 4098);
pub const DISPID_FEEDS_GetFeed = @as(u32, 4099);
pub const DISPID_FEEDS_ExistsFolder = @as(u32, 4100);
pub const DISPID_FEEDS_GetFolder = @as(u32, 4101);
pub const DISPID_FEEDS_DeleteFeed = @as(u32, 4102);
pub const DISPID_FEEDS_DeleteFolder = @as(u32, 4103);
pub const DISPID_FEEDS_GetFeedByUrl = @as(u32, 4104);
pub const DISPID_FEEDS_BackgroundSync = @as(u32, 4105);
pub const DISPID_FEEDS_BackgroundSyncStatus = @as(u32, 4106);
pub const DISPID_FEEDS_DefaultInterval = @as(u32, 4107);
pub const DISPID_FEEDS_AsyncSyncAll = @as(u32, 4108);
pub const DISPID_FEEDS_Normalize = @as(u32, 4109);
pub const DISPID_FEEDS_ItemCountLimit = @as(u32, 4110);
pub const DISPID_FEEDSENUM_Count = @as(u32, 8192);
pub const DISPID_FEEDSENUM_Item = @as(u32, 8193);
pub const DISPID_FEEDFOLDER_Feeds = @as(u32, 12288);
pub const DISPID_FEEDFOLDER_Subfolders = @as(u32, 12289);
pub const DISPID_FEEDFOLDER_CreateFeed = @as(u32, 12290);
pub const DISPID_FEEDFOLDER_CreateSubfolder = @as(u32, 12291);
pub const DISPID_FEEDFOLDER_ExistsFeed = @as(u32, 12292);
pub const DISPID_FEEDFOLDER_GetFeed = @as(u32, 12293);
pub const DISPID_FEEDFOLDER_ExistsSubfolder = @as(u32, 12294);
pub const DISPID_FEEDFOLDER_GetSubfolder = @as(u32, 12295);
pub const DISPID_FEEDFOLDER_Delete = @as(u32, 12296);
pub const DISPID_FEEDFOLDER_Name = @as(u32, 12297);
pub const DISPID_FEEDFOLDER_Rename = @as(u32, 12298);
pub const DISPID_FEEDFOLDER_Path = @as(u32, 12299);
pub const DISPID_FEEDFOLDER_Move = @as(u32, 12300);
pub const DISPID_FEEDFOLDER_Parent = @as(u32, 12301);
pub const DISPID_FEEDFOLDER_IsRoot = @as(u32, 12302);
pub const DISPID_FEEDFOLDER_TotalUnreadItemCount = @as(u32, 12303);
pub const DISPID_FEEDFOLDER_TotalItemCount = @as(u32, 12304);
pub const DISPID_FEEDFOLDER_GetWatcher = @as(u32, 12305);
pub const DISPID_FEED_Xml = @as(u32, 16384);
pub const DISPID_FEED_Name = @as(u32, 16385);
pub const DISPID_FEED_Rename = @as(u32, 16386);
pub const DISPID_FEED_Url = @as(u32, 16387);
pub const DISPID_FEED_LocalId = @as(u32, 16388);
pub const DISPID_FEED_Path = @as(u32, 16389);
pub const DISPID_FEED_Move = @as(u32, 16390);
pub const DISPID_FEED_Parent = @as(u32, 16391);
pub const DISPID_FEED_LastWriteTime = @as(u32, 16392);
pub const DISPID_FEED_Delete = @as(u32, 16393);
pub const DISPID_FEED_Download = @as(u32, 16394);
pub const DISPID_FEED_AsyncDownload = @as(u32, 16395);
pub const DISPID_FEED_CancelAsyncDownload = @as(u32, 16396);
pub const DISPID_FEED_Interval = @as(u32, 16397);
pub const DISPID_FEED_SyncSetting = @as(u32, 16398);
pub const DISPID_FEED_LastDownloadTime = @as(u32, 16399);
pub const DISPID_FEED_LocalEnclosurePath = @as(u32, 16400);
pub const DISPID_FEED_Items = @as(u32, 16401);
pub const DISPID_FEED_GetItem = @as(u32, 16402);
pub const DISPID_FEED_Title = @as(u32, 16403);
pub const DISPID_FEED_Description = @as(u32, 16404);
pub const DISPID_FEED_Link = @as(u32, 16405);
pub const DISPID_FEED_Image = @as(u32, 16406);
pub const DISPID_FEED_LastBuildDate = @as(u32, 16407);
pub const DISPID_FEED_PubDate = @as(u32, 16408);
pub const DISPID_FEED_Ttl = @as(u32, 16409);
pub const DISPID_FEED_Language = @as(u32, 16410);
pub const DISPID_FEED_Copyright = @as(u32, 16411);
pub const DISPID_FEED_DownloadEnclosuresAutomatically = @as(u32, 16412);
pub const DISPID_FEED_DownloadStatus = @as(u32, 16413);
pub const DISPID_FEED_LastDownloadError = @as(u32, 16414);
pub const DISPID_FEED_Merge = @as(u32, 16415);
pub const DISPID_FEED_DownloadUrl = @as(u32, 16416);
pub const DISPID_FEED_IsList = @as(u32, 16417);
pub const DISPID_FEED_MarkAllItemsRead = @as(u32, 16418);
pub const DISPID_FEED_GetWatcher = @as(u32, 16419);
pub const DISPID_FEED_UnreadItemCount = @as(u32, 16420);
pub const DISPID_FEED_ItemCount = @as(u32, 16421);
pub const DISPID_FEED_MaxItemCount = @as(u32, 16422);
pub const DISPID_FEED_GetItemByEffectiveId = @as(u32, 16423);
pub const DISPID_FEED_LastItemDownloadTime = @as(u32, 16424);
pub const DISPID_FEED_Username = @as(u32, 16425);
pub const DISPID_FEED_Password = @as(u32, 16426);
pub const DISPID_FEED_SetCredentials = @as(u32, 16427);
pub const DISPID_FEED_ClearCredentials = @as(u32, 16428);
pub const DISPID_FEEDITEM_Xml = @as(u32, 20480);
pub const DISPID_FEEDITEM_Title = @as(u32, 20481);
pub const DISPID_FEEDITEM_Link = @as(u32, 20482);
pub const DISPID_FEEDITEM_Guid = @as(u32, 20483);
pub const DISPID_FEEDITEM_Description = @as(u32, 20484);
pub const DISPID_FEEDITEM_PubDate = @as(u32, 20485);
pub const DISPID_FEEDITEM_Comments = @as(u32, 20486);
pub const DISPID_FEEDITEM_Author = @as(u32, 20487);
pub const DISPID_FEEDITEM_Enclosure = @as(u32, 20488);
pub const DISPID_FEEDITEM_IsRead = @as(u32, 20489);
pub const DISPID_FEEDITEM_LocalId = @as(u32, 20490);
pub const DISPID_FEEDITEM_Parent = @as(u32, 20491);
pub const DISPID_FEEDITEM_Delete = @as(u32, 20492);
pub const DISPID_FEEDITEM_DownloadUrl = @as(u32, 20493);
pub const DISPID_FEEDITEM_LastDownloadTime = @as(u32, 20494);
pub const DISPID_FEEDITEM_Modified = @as(u32, 20495);
pub const DISPID_FEEDITEM_EffectiveId = @as(u32, 20496);
pub const DISPID_FEEDENCLOSURE_Url = @as(u32, 24576);
pub const DISPID_FEEDENCLOSURE_Type = @as(u32, 24577);
pub const DISPID_FEEDENCLOSURE_Length = @as(u32, 24578);
pub const DISPID_FEEDENCLOSURE_AsyncDownload = @as(u32, 24579);
pub const DISPID_FEEDENCLOSURE_CancelAsyncDownload = @as(u32, 24580);
pub const DISPID_FEEDENCLOSURE_DownloadStatus = @as(u32, 24581);
pub const DISPID_FEEDENCLOSURE_LastDownloadError = @as(u32, 24582);
pub const DISPID_FEEDENCLOSURE_LocalPath = @as(u32, 24583);
pub const DISPID_FEEDENCLOSURE_Parent = @as(u32, 24584);
pub const DISPID_FEEDENCLOSURE_DownloadUrl = @as(u32, 24585);
pub const DISPID_FEEDENCLOSURE_DownloadMimeType = @as(u32, 24586);
pub const DISPID_FEEDENCLOSURE_RemoveFile = @as(u32, 24587);
pub const DISPID_FEEDENCLOSURE_SetFile = @as(u32, 24588);
pub const DISPID_FEEDFOLDEREVENTS_Error = @as(u32, 28672);
pub const DISPID_FEEDFOLDEREVENTS_FolderAdded = @as(u32, 28673);
pub const DISPID_FEEDFOLDEREVENTS_FolderDeleted = @as(u32, 28674);
pub const DISPID_FEEDFOLDEREVENTS_FolderRenamed = @as(u32, 28675);
pub const DISPID_FEEDFOLDEREVENTS_FolderMovedFrom = @as(u32, 28676);
pub const DISPID_FEEDFOLDEREVENTS_FolderMovedTo = @as(u32, 28677);
pub const DISPID_FEEDFOLDEREVENTS_FolderItemCountChanged = @as(u32, 28678);
pub const DISPID_FEEDFOLDEREVENTS_FeedAdded = @as(u32, 28679);
pub const DISPID_FEEDFOLDEREVENTS_FeedDeleted = @as(u32, 28680);
pub const DISPID_FEEDFOLDEREVENTS_FeedRenamed = @as(u32, 28681);
pub const DISPID_FEEDFOLDEREVENTS_FeedUrlChanged = @as(u32, 28682);
pub const DISPID_FEEDFOLDEREVENTS_FeedMovedFrom = @as(u32, 28683);
pub const DISPID_FEEDFOLDEREVENTS_FeedMovedTo = @as(u32, 28684);
pub const DISPID_FEEDFOLDEREVENTS_FeedDownloading = @as(u32, 28685);
pub const DISPID_FEEDFOLDEREVENTS_FeedDownloadCompleted = @as(u32, 28686);
pub const DISPID_FEEDFOLDEREVENTS_FeedItemCountChanged = @as(u32, 28687);
pub const DISPID_FEEDEVENTS_Error = @as(u32, 32768);
pub const DISPID_FEEDEVENTS_FeedDeleted = @as(u32, 32769);
pub const DISPID_FEEDEVENTS_FeedRenamed = @as(u32, 32770);
pub const DISPID_FEEDEVENTS_FeedUrlChanged = @as(u32, 32771);
pub const DISPID_FEEDEVENTS_FeedMoved = @as(u32, 32772);
pub const DISPID_FEEDEVENTS_FeedDownloading = @as(u32, 32773);
pub const DISPID_FEEDEVENTS_FeedDownloadCompleted = @as(u32, 32774);
pub const DISPID_FEEDEVENTS_FeedItemCountChanged = @as(u32, 32775);
pub const DISPID_DELTA = @as(u32, 50);
pub const DISPID_WMPCORE_BASE = @as(u32, 0);
pub const DISPID_WMPCORE_URL = @as(u32, 1);
pub const DISPID_WMPCORE_OPENSTATE = @as(u32, 2);
pub const DISPID_WMPCORE_CLOSE = @as(u32, 3);
pub const DISPID_WMPCORE_CONTROLS = @as(u32, 4);
pub const DISPID_WMPCORE_SETTINGS = @as(u32, 5);
pub const DISPID_WMPCORE_CURRENTMEDIA = @as(u32, 6);
pub const DISPID_WMPCORE_NETWORK = @as(u32, 7);
pub const DISPID_WMPCORE_MEDIACOLLECTION = @as(u32, 8);
pub const DISPID_WMPCORE_PLAYLISTCOLLECTION = @as(u32, 9);
pub const DISPID_WMPCORE_PLAYSTATE = @as(u32, 10);
pub const DISPID_WMPCORE_VERSIONINFO = @as(u32, 11);
pub const DISPID_WMPCORE_LAUNCHURL = @as(u32, 12);
pub const DISPID_WMPCORE_CURRENTPLAYLIST = @as(u32, 13);
pub const DISPID_WMPCORE_CDROMCOLLECTION = @as(u32, 14);
pub const DISPID_WMPCORE_CLOSEDCAPTION = @as(u32, 15);
pub const DISPID_WMPCORE_ISONLINE = @as(u32, 16);
pub const DISPID_WMPCORE_ERROR = @as(u32, 17);
pub const DISPID_WMPCORE_STATUS = @as(u32, 18);
pub const DISPID_WMPCORE_LAST = @as(u32, 18);
pub const DISPID_WMPOCX_BASE = @as(u32, 18);
pub const DISPID_WMPOCX_ENABLED = @as(u32, 19);
pub const DISPID_WMPOCX_TRANSPARENTATSTART = @as(u32, 20);
pub const DISPID_WMPOCX_FULLSCREEN = @as(u32, 21);
pub const DISPID_WMPOCX_ENABLECONTEXTMENU = @as(u32, 22);
pub const DISPID_WMPOCX_UIMODE = @as(u32, 23);
pub const DISPID_WMPOCX_LAST = @as(u32, 23);
pub const DISPID_WMPOCX2_BASE = @as(u32, 23);
pub const DISPID_WMPOCX2_STRETCHTOFIT = @as(u32, 24);
pub const DISPID_WMPOCX2_WINDOWLESSVIDEO = @as(u32, 25);
pub const DISPID_WMPOCX4_ISREMOTE = @as(u32, 26);
pub const DISPID_WMPOCX4_PLAYERAPPLICATION = @as(u32, 27);
pub const DISPID_WMPOCX4_OPENPLAYER = @as(u32, 28);
pub const DISPID_WMPCORE2_BASE = @as(u32, 39);
pub const DISPID_WMPCORE2_DVD = @as(u32, 40);
pub const DISPID_WMPCORE3_NEWPLAYLIST = @as(u32, 41);
pub const DISPID_WMPCORE3_NEWMEDIA = @as(u32, 42);
pub const DISPID_WMPCONTROLS_PLAY = @as(u32, 51);
pub const DISPID_WMPCONTROLS_STOP = @as(u32, 52);
pub const DISPID_WMPCONTROLS_PAUSE = @as(u32, 53);
pub const DISPID_WMPCONTROLS_FASTFORWARD = @as(u32, 54);
pub const DISPID_WMPCONTROLS_FASTREVERSE = @as(u32, 55);
pub const DISPID_WMPCONTROLS_CURRENTPOSITION = @as(u32, 56);
pub const DISPID_WMPCONTROLS_CURRENTPOSITIONSTRING = @as(u32, 57);
pub const DISPID_WMPCONTROLS_NEXT = @as(u32, 58);
pub const DISPID_WMPCONTROLS_PREVIOUS = @as(u32, 59);
pub const DISPID_WMPCONTROLS_CURRENTITEM = @as(u32, 60);
pub const DISPID_WMPCONTROLS_CURRENTMARKER = @as(u32, 61);
pub const DISPID_WMPCONTROLS_ISAVAILABLE = @as(u32, 62);
pub const DISPID_WMPCONTROLS_PLAYITEM = @as(u32, 63);
pub const DISPID_WMPCONTROLS2_STEP = @as(u32, 64);
pub const DISPID_WMPCONTROLS3_AUDIOLANGUAGECOUNT = @as(u32, 65);
pub const DISPID_WMPCONTROLS3_GETAUDIOLANGUAGEID = @as(u32, 66);
pub const DISPID_WMPCONTROLS3_GETAUDIOLANGUAGEDESC = @as(u32, 67);
pub const DISPID_WMPCONTROLS3_CURRENTAUDIOLANGUAGE = @as(u32, 68);
pub const DISPID_WMPCONTROLS3_CURRENTAUDIOLANGUAGEINDEX = @as(u32, 69);
pub const DISPID_WMPCONTROLS3_GETLANGUAGENAME = @as(u32, 70);
pub const DISPID_WMPCONTROLS3_CURRENTPOSITIONTIMECODE = @as(u32, 71);
pub const DISPID_WMPCONTROLSFAKE_TIMECOMPRESSION = @as(u32, 72);
pub const DISPID_WMPSETTINGS_AUTOSTART = @as(u32, 101);
pub const DISPID_WMPSETTINGS_BALANCE = @as(u32, 102);
pub const DISPID_WMPSETTINGS_INVOKEURLS = @as(u32, 103);
pub const DISPID_WMPSETTINGS_MUTE = @as(u32, 104);
pub const DISPID_WMPSETTINGS_PLAYCOUNT = @as(u32, 105);
pub const DISPID_WMPSETTINGS_RATE = @as(u32, 106);
pub const DISPID_WMPSETTINGS_VOLUME = @as(u32, 107);
pub const DISPID_WMPSETTINGS_BASEURL = @as(u32, 108);
pub const DISPID_WMPSETTINGS_DEFAULTFRAME = @as(u32, 109);
pub const DISPID_WMPSETTINGS_GETMODE = @as(u32, 110);
pub const DISPID_WMPSETTINGS_SETMODE = @as(u32, 111);
pub const DISPID_WMPSETTINGS_ENABLEERRORDIALOGS = @as(u32, 112);
pub const DISPID_WMPSETTINGS_ISAVAILABLE = @as(u32, 113);
pub const DISPID_WMPSETTINGS2_DEFAULTAUDIOLANGUAGE = @as(u32, 114);
pub const DISPID_WMPSETTINGS2_LIBRARYACCESSRIGHTS = @as(u32, 115);
pub const DISPID_WMPSETTINGS2_REQUESTLIBRARYACCESSRIGHTS = @as(u32, 116);
pub const DISPID_WMPPLAYLIST_COUNT = @as(u32, 201);
pub const DISPID_WMPPLAYLIST_NAME = @as(u32, 202);
pub const DISPID_WMPPLAYLIST_GETITEMINFO = @as(u32, 203);
pub const DISPID_WMPPLAYLIST_SETITEMINFO = @as(u32, 204);
pub const DISPID_WMPPLAYLIST_CLEAR = @as(u32, 205);
pub const DISPID_WMPPLAYLIST_INSERTITEM = @as(u32, 206);
pub const DISPID_WMPPLAYLIST_APPENDITEM = @as(u32, 207);
pub const DISPID_WMPPLAYLIST_REMOVEITEM = @as(u32, 208);
pub const DISPID_WMPPLAYLIST_MOVEITEM = @as(u32, 209);
pub const DISPID_WMPPLAYLIST_ATTRIBUTECOUNT = @as(u32, 210);
pub const DISPID_WMPPLAYLIST_ATTRIBUTENAME = @as(u32, 211);
pub const DISPID_WMPPLAYLIST_ITEM = @as(u32, 212);
pub const DISPID_WMPPLAYLIST_ISIDENTICAL = @as(u32, 213);
pub const DISPID_WMPCDROM_DRIVESPECIFIER = @as(u32, 251);
pub const DISPID_WMPCDROM_PLAYLIST = @as(u32, 252);
pub const DISPID_WMPCDROM_EJECT = @as(u32, 253);
pub const DISPID_WMPCDROMCOLLECTION_COUNT = @as(u32, 301);
pub const DISPID_WMPCDROMCOLLECTION_ITEM = @as(u32, 302);
pub const DISPID_WMPCDROMCOLLECTION_GETBYDRIVESPECIFIER = @as(u32, 303);
pub const DISPID_WMPCDROMCOLLECTION_STARTMONITORINGCDROMS = @as(u32, 304);
pub const DISPID_WMPCDROMCOLLECTION_STOPMONITORINGCDROMS = @as(u32, 305);
pub const DISPID_WMPSTRINGCOLLECTION_COUNT = @as(u32, 401);
pub const DISPID_WMPSTRINGCOLLECTION_ITEM = @as(u32, 402);
pub const DISPID_WMPMEDIACOLLECTION_ADD = @as(u32, 452);
pub const DISPID_WMPMEDIACOLLECTION_GETALL = @as(u32, 453);
pub const DISPID_WMPMEDIACOLLECTION_GETBYNAME = @as(u32, 454);
pub const DISPID_WMPMEDIACOLLECTION_GETBYGENRE = @as(u32, 455);
pub const DISPID_WMPMEDIACOLLECTION_GETBYAUTHOR = @as(u32, 456);
pub const DISPID_WMPMEDIACOLLECTION_GETBYALBUM = @as(u32, 457);
pub const DISPID_WMPMEDIACOLLECTION_GETBYATTRIBUTE = @as(u32, 458);
pub const DISPID_WMPMEDIACOLLECTION_REMOVE = @as(u32, 459);
pub const DISPID_WMPMEDIACOLLECTION_GETATTRIBUTESTRINGCOLLECTION = @as(u32, 461);
pub const DISPID_WMPMEDIACOLLECTION_NEWQUERY = @as(u32, 462);
pub const DISPID_WMPMEDIACOLLECTION_STARTMONITORING = @as(u32, 463);
pub const DISPID_WMPMEDIACOLLECTION_STOPMONITORING = @as(u32, 464);
pub const DISPID_WMPMEDIACOLLECTION_STARTCONTENTSCAN = @as(u32, 465);
pub const DISPID_WMPMEDIACOLLECTION_STOPCONTENTSCAN = @as(u32, 466);
pub const DISPID_WMPMEDIACOLLECTION_STARTSEARCH = @as(u32, 467);
pub const DISPID_WMPMEDIACOLLECTION_STOPSEARCH = @as(u32, 468);
pub const DISPID_WMPMEDIACOLLECTION_UPDATEMETADATA = @as(u32, 469);
pub const DISPID_WMPMEDIACOLLECTION_GETMEDIAATOM = @as(u32, 470);
pub const DISPID_WMPMEDIACOLLECTION_SETDELETED = @as(u32, 471);
pub const DISPID_WMPMEDIACOLLECTION_ISDELETED = @as(u32, 472);
pub const DISPID_WMPMEDIACOLLECTION_GETBYQUERYDESCRIPTION = @as(u32, 473);
pub const DISPID_WMPMEDIACOLLECTION_FREEZECOLLECTIONCHANGE = @as(u32, 474);
pub const DISPID_WMPMEDIACOLLECTION_UNFREEZECOLLECTIONCHANGE = @as(u32, 475);
pub const DISPID_WMPMEDIACOLLECTION_POSTCOLLECTIONCHANGE = @as(u32, 476);
pub const DISPID_WMPPLAYLISTARRAY_COUNT = @as(u32, 501);
pub const DISPID_WMPPLAYLISTARRAY_ITEM = @as(u32, 502);
pub const DISPID_WMPPLAYLISTCOLLECTION_NEWPLAYLIST = @as(u32, 552);
pub const DISPID_WMPPLAYLISTCOLLECTION_GETALL = @as(u32, 553);
pub const DISPID_WMPPLAYLISTCOLLECTION_GETBYNAME = @as(u32, 554);
pub const DISPID_WMPPLAYLISTCOLLECTION_GETBYQUERYDESCRIPTION = @as(u32, 555);
pub const DISPID_WMPPLAYLISTCOLLECTION_REMOVE = @as(u32, 556);
pub const DISPID_WMPPLAYLISTCOLLECTION_NEWQUERY = @as(u32, 557);
pub const DISPID_WMPPLAYLISTCOLLECTION_STARTMONITORING = @as(u32, 558);
pub const DISPID_WMPPLAYLISTCOLLECTION_STOPMONITORING = @as(u32, 559);
pub const DISPID_WMPPLAYLISTCOLLECTION_SETDELETED = @as(u32, 560);
pub const DISPID_WMPPLAYLISTCOLLECTION_ISDELETED = @as(u32, 561);
pub const DISPID_WMPPLAYLISTCOLLECTION_IMPORTPLAYLIST = @as(u32, 562);
pub const DISPID_WMPMEDIA_SOURCEURL = @as(u32, 751);
pub const DISPID_WMPMEDIA_IMAGESOURCEWIDTH = @as(u32, 752);
pub const DISPID_WMPMEDIA_IMAGESOURCEHEIGHT = @as(u32, 753);
pub const DISPID_WMPMEDIA_MARKERCOUNT = @as(u32, 754);
pub const DISPID_WMPMEDIA_GETMARKERTIME = @as(u32, 755);
pub const DISPID_WMPMEDIA_GETMARKERNAME = @as(u32, 756);
pub const DISPID_WMPMEDIA_DURATION = @as(u32, 757);
pub const DISPID_WMPMEDIA_DURATIONSTRING = @as(u32, 758);
pub const DISPID_WMPMEDIA_ATTRIBUTECOUNT = @as(u32, 759);
pub const DISPID_WMPMEDIA_GETATTRIBUTENAME = @as(u32, 760);
pub const DISPID_WMPMEDIA_GETITEMINFO = @as(u32, 761);
pub const DISPID_WMPMEDIA_SETITEMINFO = @as(u32, 762);
pub const DISPID_WMPMEDIA_ISIDENTICAL = @as(u32, 763);
pub const DISPID_WMPMEDIA_NAME = @as(u32, 764);
pub const DISPID_WMPMEDIA_GETITEMINFOBYATOM = @as(u32, 765);
pub const DISPID_WMPMEDIA_ISMEMBEROF = @as(u32, 766);
pub const DISPID_WMPMEDIA_ISREADONLYITEM = @as(u32, 767);
pub const DISPID_WMPMEDIA2_ERROR = @as(u32, 768);
pub const DISPID_WMPMEDIA3_GETATTRIBUTECOUNTBYTYPE = @as(u32, 769);
pub const DISPID_WMPMEDIA3_GETITEMINFOBYTYPE = @as(u32, 770);
pub const DISPID_WMPNETWORK_BANDWIDTH = @as(u32, 801);
pub const DISPID_WMPNETWORK_RECOVEREDPACKETS = @as(u32, 802);
pub const DISPID_WMPNETWORK_SOURCEPROTOCOL = @as(u32, 803);
pub const DISPID_WMPNETWORK_RECEIVEDPACKETS = @as(u32, 804);
pub const DISPID_WMPNETWORK_LOSTPACKETS = @as(u32, 805);
pub const DISPID_WMPNETWORK_RECEPTIONQUALITY = @as(u32, 806);
pub const DISPID_WMPNETWORK_BUFFERINGCOUNT = @as(u32, 807);
pub const DISPID_WMPNETWORK_BUFFERINGPROGRESS = @as(u32, 808);
pub const DISPID_WMPNETWORK_BUFFERINGTIME = @as(u32, 809);
pub const DISPID_WMPNETWORK_FRAMERATE = @as(u32, 810);
pub const DISPID_WMPNETWORK_MAXBITRATE = @as(u32, 811);
pub const DISPID_WMPNETWORK_BITRATE = @as(u32, 812);
pub const DISPID_WMPNETWORK_GETPROXYSETTINGS = @as(u32, 813);
pub const DISPID_WMPNETWORK_SETPROXYSETTINGS = @as(u32, 814);
pub const DISPID_WMPNETWORK_GETPROXYNAME = @as(u32, 815);
pub const DISPID_WMPNETWORK_SETPROXYNAME = @as(u32, 816);
pub const DISPID_WMPNETWORK_GETPROXYPORT = @as(u32, 817);
pub const DISPID_WMPNETWORK_SETPROXYPORT = @as(u32, 818);
pub const DISPID_WMPNETWORK_GETPROXYEXCEPTIONLIST = @as(u32, 819);
pub const DISPID_WMPNETWORK_SETPROXYEXCEPTIONLIST = @as(u32, 820);
pub const DISPID_WMPNETWORK_GETPROXYBYPASSFORLOCAL = @as(u32, 821);
pub const DISPID_WMPNETWORK_SETPROXYBYPASSFORLOCAL = @as(u32, 822);
pub const DISPID_WMPNETWORK_MAXBANDWIDTH = @as(u32, 823);
pub const DISPID_WMPNETWORK_DOWNLOADPROGRESS = @as(u32, 824);
pub const DISPID_WMPNETWORK_ENCODEDFRAMERATE = @as(u32, 825);
pub const DISPID_WMPNETWORK_FRAMESSKIPPED = @as(u32, 826);
pub const DISPID_WMPERROR_CLEARERRORQUEUE = @as(u32, 851);
pub const DISPID_WMPERROR_ERRORCOUNT = @as(u32, 852);
pub const DISPID_WMPERROR_ITEM = @as(u32, 853);
pub const DISPID_WMPERROR_WEBHELP = @as(u32, 854);
pub const DISPID_WMPERRORITEM_ERRORCODE = @as(u32, 901);
pub const DISPID_WMPERRORITEM_ERRORDESCRIPTION = @as(u32, 902);
pub const DISPID_WMPERRORITEM_ERRORCONTEXT = @as(u32, 903);
pub const DISPID_WMPERRORITEM_REMEDY = @as(u32, 904);
pub const DISPID_WMPERRORITEM_CUSTOMURL = @as(u32, 905);
pub const DISPID_WMPERRORITEM2_CONDITION = @as(u32, 906);
pub const DISPID_WMPCLOSEDCAPTION_SAMISTYLE = @as(u32, 951);
pub const DISPID_WMPCLOSEDCAPTION_SAMILANG = @as(u32, 952);
pub const DISPID_WMPCLOSEDCAPTION_SAMIFILENAME = @as(u32, 953);
pub const DISPID_WMPCLOSEDCAPTION_CAPTIONINGID = @as(u32, 954);
pub const DISPID_WMPCLOSEDCAPTION2_GETLANGCOUNT = @as(u32, 955);
pub const DISPID_WMPCLOSEDCAPTION2_GETLANGNAME = @as(u32, 956);
pub const DISPID_WMPCLOSEDCAPTION2_GETLANGID = @as(u32, 957);
pub const DISPID_WMPCLOSEDCAPTION2_GETSTYLECOUNT = @as(u32, 958);
pub const DISPID_WMPCLOSEDCAPTION2_GETSTYLENAME = @as(u32, 959);
pub const DISPID_WMPDVD_ISAVAILABLE = @as(u32, 1001);
pub const DISPID_WMPDVD_DOMAIN = @as(u32, 1002);
pub const DISPID_WMPDVD_TOPMENU = @as(u32, 1003);
pub const DISPID_WMPDVD_TITLEMENU = @as(u32, 1004);
pub const DISPID_WMPDVD_BACK = @as(u32, 1005);
pub const DISPID_WMPDVD_RESUME = @as(u32, 1006);
pub const DISPID_WMPMETADATA_PICTURE_MIMETYPE = @as(u32, 1051);
pub const DISPID_WMPMETADATA_PICTURE_PICTURETYPE = @as(u32, 1052);
pub const DISPID_WMPMETADATA_PICTURE_DESCRIPTION = @as(u32, 1053);
pub const DISPID_WMPMETADATA_PICTURE_URL = @as(u32, 1054);
pub const DISPID_WMPMETADATA_TEXT_TEXT = @as(u32, 1055);
pub const DISPID_WMPMETADATA_TEXT_DESCRIPTION = @as(u32, 1056);
pub const DISPID_WMPPLAYERAPP_SWITCHTOPLAYERAPPLICATION = @as(u32, 1101);
pub const DISPID_WMPPLAYERAPP_SWITCHTOCONTROL = @as(u32, 1102);
pub const DISPID_WMPPLAYERAPP_PLAYERDOCKED = @as(u32, 1103);
pub const DISPID_WMPPLAYERAPP_HASDISPLAY = @as(u32, 1104);
pub const DISPID_WMPPLAYERAPP_REMOTESTATUS = @as(u32, 1105);
pub const DISPID_WMPDOWNLOADMANAGER_GETDOWNLOADCOLLECTION = @as(u32, 1151);
pub const DISPID_WMPDOWNLOADMANAGER_CREATEDOWNLOADCOLLECTION = @as(u32, 1152);
pub const DISPID_WMPDOWNLOADCOLLECTION_ID = @as(u32, 1201);
pub const DISPID_WMPDOWNLOADCOLLECTION_COUNT = @as(u32, 1202);
pub const DISPID_WMPDOWNLOADCOLLECTION_ITEM = @as(u32, 1203);
pub const DISPID_WMPDOWNLOADCOLLECTION_STARTDOWNLOAD = @as(u32, 1204);
pub const DISPID_WMPDOWNLOADCOLLECTION_REMOVEITEM = @as(u32, 1205);
pub const DISPID_WMPDOWNLOADCOLLECTION_CLEAR = @as(u32, 1206);
pub const DISPID_WMPDOWNLOADITEM_SOURCEURL = @as(u32, 1251);
pub const DISPID_WMPDOWNLOADITEM_SIZE = @as(u32, 1252);
pub const DISPID_WMPDOWNLOADITEM_TYPE = @as(u32, 1253);
pub const DISPID_WMPDOWNLOADITEM_PROGRESS = @as(u32, 1254);
pub const DISPID_WMPDOWNLOADITEM_DOWNLOADSTATE = @as(u32, 1255);
pub const DISPID_WMPDOWNLOADITEM_PAUSE = @as(u32, 1256);
pub const DISPID_WMPDOWNLOADITEM_RESUME = @as(u32, 1257);
pub const DISPID_WMPDOWNLOADITEM_CANCEL = @as(u32, 1258);
pub const DISPID_WMPDOWNLOADITEM2_GETITEMINFO = @as(u32, 1301);
pub const DISPID_WMPQUERY_ADDCONDITION = @as(u32, 1351);
pub const DISPID_WMPQUERY_BEGINNEXTGROUP = @as(u32, 1352);
pub const DISPID_WMPMEDIACOLLECTION2_CREATEQUERY = @as(u32, 1401);
pub const DISPID_WMPMEDIACOLLECTION2_GETPLAYLISTBYQUERY = @as(u32, 1402);
pub const DISPID_WMPMEDIACOLLECTION2_GETSTRINGCOLLBYQUERY = @as(u32, 1403);
pub const DISPID_WMPMEDIACOLLECTION2_GETBYATTRANDMEDIATYPE = @as(u32, 1404);
pub const DISPID_WMPSTRINGCOLLECTION2_ISIDENTICAL = @as(u32, 1451);
pub const DISPID_WMPSTRINGCOLLECTION2_GETITEMINFO = @as(u32, 1452);
pub const DISPID_WMPSTRINGCOLLECTION2_GETATTRCOUNTBYTYPE = @as(u32, 1453);
pub const DISPID_WMPSTRINGCOLLECTION2_GETITEMINFOBYTYPE = @as(u32, 1454);
pub const DISPID_WMPCORE_MIN = @as(u32, 1);
pub const DISPID_WMPCORE_MAX = @as(u32, 1454);
pub const WMPCOREEVENT_BASE = @as(u32, 5000);
pub const DISPID_WMPCOREEVENT_OPENSTATECHANGE = @as(u32, 5001);
pub const DISPID_WMPCOREEVENT_STATUSCHANGE = @as(u32, 5002);
pub const WMPCOREEVENT_CONTROL_BASE = @as(u32, 5100);
pub const DISPID_WMPCOREEVENT_PLAYSTATECHANGE = @as(u32, 5101);
pub const DISPID_WMPCOREEVENT_AUDIOLANGUAGECHANGE = @as(u32, 5102);
pub const WMPCOREEVENT_SEEK_BASE = @as(u32, 5200);
pub const DISPID_WMPCOREEVENT_ENDOFSTREAM = @as(u32, 5201);
pub const DISPID_WMPCOREEVENT_POSITIONCHANGE = @as(u32, 5202);
pub const DISPID_WMPCOREEVENT_MARKERHIT = @as(u32, 5203);
pub const DISPID_WMPCOREEVENT_DURATIONUNITCHANGE = @as(u32, 5204);
pub const WMPCOREEVENT_CONTENT_BASE = @as(u32, 5300);
pub const DISPID_WMPCOREEVENT_SCRIPTCOMMAND = @as(u32, 5301);
pub const WMPCOREEVENT_NETWORK_BASE = @as(u32, 5400);
pub const DISPID_WMPCOREEVENT_DISCONNECT = @as(u32, 5401);
pub const DISPID_WMPCOREEVENT_BUFFERING = @as(u32, 5402);
pub const DISPID_WMPCOREEVENT_NEWSTREAM = @as(u32, 5403);
pub const WMPCOREEVENT_ERROR_BASE = @as(u32, 5500);
pub const DISPID_WMPCOREEVENT_ERROR = @as(u32, 5501);
pub const WMPCOREEVENT_WARNING_BASE = @as(u32, 5600);
pub const DISPID_WMPCOREEVENT_WARNING = @as(u32, 5601);
pub const WMPCOREEVENT_CDROM_BASE = @as(u32, 5700);
pub const DISPID_WMPCOREEVENT_CDROMMEDIACHANGE = @as(u32, 5701);
pub const WMPCOREEVENT_PLAYLIST_BASE = @as(u32, 5800);
pub const DISPID_WMPCOREEVENT_PLAYLISTCHANGE = @as(u32, 5801);
pub const DISPID_WMPCOREEVENT_MEDIACHANGE = @as(u32, 5802);
pub const DISPID_WMPCOREEVENT_CURRENTMEDIAITEMAVAILABLE = @as(u32, 5803);
pub const DISPID_WMPCOREEVENT_CURRENTPLAYLISTCHANGE = @as(u32, 5804);
pub const DISPID_WMPCOREEVENT_CURRENTPLAYLISTITEMAVAILABLE = @as(u32, 5805);
pub const DISPID_WMPCOREEVENT_CURRENTITEMCHANGE = @as(u32, 5806);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONCHANGE = @as(u32, 5807);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGADDED = @as(u32, 5808);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGREMOVED = @as(u32, 5809);
pub const DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONCHANGE = @as(u32, 5810);
pub const DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTADDED = @as(u32, 5811);
pub const DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTREMOVED = @as(u32, 5812);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONCONTENTSCANADDEDITEM = @as(u32, 5813);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONCONTENTSCANPROGRESS = @as(u32, 5814);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHFOUNDITEM = @as(u32, 5815);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHPROGRESS = @as(u32, 5816);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONSEARCHCOMPLETE = @as(u32, 5817);
pub const DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTSETASDELETED = @as(u32, 5818);
pub const DISPID_WMPCOREEVENT_MODECHANGE = @as(u32, 5819);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGCHANGED = @as(u32, 5820);
pub const DISPID_WMPCOREEVENT_MEDIAERROR = @as(u32, 5821);
pub const DISPID_WMPCOREEVENT_DOMAINCHANGE = @as(u32, 5822);
pub const DISPID_WMPCOREEVENT_OPENPLAYLISTSWITCH = @as(u32, 5823);
pub const DISPID_WMPCOREEVENT_STRINGCOLLECTIONCHANGE = @as(u32, 5824);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONMEDIAADDED = @as(u32, 5825);
pub const DISPID_WMPCOREEVENT_MEDIACOLLECTIONMEDIAREMOVED = @as(u32, 5826);
pub const WMPOCXEVENT_BASE = @as(u32, 6500);
pub const DISPID_WMPOCXEVENT_SWITCHEDTOPLAYERAPPLICATION = @as(u32, 6501);
pub const DISPID_WMPOCXEVENT_SWITCHEDTOCONTROL = @as(u32, 6502);
pub const DISPID_WMPOCXEVENT_PLAYERDOCKEDSTATECHANGE = @as(u32, 6503);
pub const DISPID_WMPOCXEVENT_PLAYERRECONNECT = @as(u32, 6504);
pub const DISPID_WMPOCXEVENT_CLICK = @as(u32, 6505);
pub const DISPID_WMPOCXEVENT_DOUBLECLICK = @as(u32, 6506);
pub const DISPID_WMPOCXEVENT_KEYDOWN = @as(u32, 6507);
pub const DISPID_WMPOCXEVENT_KEYPRESS = @as(u32, 6508);
pub const DISPID_WMPOCXEVENT_KEYUP = @as(u32, 6509);
pub const DISPID_WMPOCXEVENT_MOUSEDOWN = @as(u32, 6510);
pub const DISPID_WMPOCXEVENT_MOUSEMOVE = @as(u32, 6511);
pub const DISPID_WMPOCXEVENT_MOUSEUP = @as(u32, 6512);
pub const DISPID_WMPOCXEVENT_DEVICECONNECT = @as(u32, 6513);
pub const DISPID_WMPOCXEVENT_DEVICEDISCONNECT = @as(u32, 6514);
pub const DISPID_WMPOCXEVENT_DEVICESTATUSCHANGE = @as(u32, 6515);
pub const DISPID_WMPOCXEVENT_DEVICESYNCSTATECHANGE = @as(u32, 6516);
pub const DISPID_WMPOCXEVENT_DEVICESYNCERROR = @as(u32, 6517);
pub const DISPID_WMPOCXEVENT_CREATEPARTNERSHIPCOMPLETE = @as(u32, 6518);
pub const DISPID_WMPOCXEVENT_CDROMRIPSTATECHANGE = @as(u32, 6519);
pub const DISPID_WMPOCXEVENT_CDROMRIPMEDIAERROR = @as(u32, 6520);
pub const DISPID_WMPOCXEVENT_CDROMBURNSTATECHANGE = @as(u32, 6521);
pub const DISPID_WMPOCXEVENT_CDROMBURNMEDIAERROR = @as(u32, 6522);
pub const DISPID_WMPOCXEVENT_CDROMBURNERROR = @as(u32, 6523);
pub const DISPID_WMPOCXEVENT_LIBRARYCONNECT = @as(u32, 6524);
pub const DISPID_WMPOCXEVENT_LIBRARYDISCONNECT = @as(u32, 6525);
pub const DISPID_WMPOCXEVENT_FOLDERSCANSTATECHANGE = @as(u32, 6526);
pub const DISPID_WMPOCXEVENT_DEVICEESTIMATION = @as(u32, 6527);
pub const DISPID_WMPCONTROLS_BASE = @as(u32, 50);
pub const DISPID_WMPSETTINGS_BASE = @as(u32, 100);
pub const DISPID_WMPPLAYLIST_BASE = @as(u32, 200);
pub const DISPID_WMPCDROM_BASE = @as(u32, 250);
pub const DISPID_WMPCDROMCOLLECTION_BASE = @as(u32, 300);
pub const DISPID_WMPSTRINGCOLLECTION_BASE = @as(u32, 400);
pub const DISPID_WMPMEDIACOLLECTION_BASE = @as(u32, 450);
pub const DISPID_WMPPLAYLISTARRAY_BASE = @as(u32, 500);
pub const DISPID_WMPPLAYLISTCOLLECTION_BASE = @as(u32, 550);
pub const DISPID_WMPMEDIA_BASE = @as(u32, 750);
pub const DISPID_WMPNETWORK_BASE = @as(u32, 800);
pub const DISPID_WMPERROR_BASE = @as(u32, 850);
pub const DISPID_WMPERRORITEM_BASE = @as(u32, 900);
pub const DISPID_WMPCLOSEDCAPTION_BASE = @as(u32, 950);
pub const DISPID_WMPDVD_BASE = @as(u32, 1000);
pub const DISPID_WMPMETADATA_BASE = @as(u32, 1050);
pub const DISPID_WMPPLAYERAPP_BASE = @as(u32, 1100);
pub const DISPID_WMPDOWNLOADMANAGER_BASE = @as(u32, 1150);
pub const DISPID_WMPDOWNLOADCOLLECTION_BASE = @as(u32, 1200);
pub const DISPID_WMPDOWNLOADITEM_BASE = @as(u32, 1250);
pub const DISPID_WMPDOWNLOADITEM2_BASE = @as(u32, 1300);
pub const DISPID_WMPQUERY_BASE = @as(u32, 1350);
pub const DISPID_WMPMEDIACOLLECTION2_BASE = @as(u32, 1400);
pub const DISPID_WMPSTRINGCOLLECTION2_BASE = @as(u32, 1450);
pub const CLSID_WMPSkinManager = Guid.initString("b2a7fd52-301f-4348-b93a-638c6de49229");
pub const CLSID_WMPMediaPluginRegistrar = Guid.initString("5569e7f5-424b-4b93-89ca-79d17924689a");
pub const WMP_PLUGINTYPE_DSP = Guid.initString("6434baea-4954-498d-abd5-2b07123e1f04");
pub const WMP_PLUGINTYPE_DSP_OUTOFPROC = Guid.initString("ef29b174-c347-44cc-9a4f-2399118ff38c");
pub const WMP_PLUGINTYPE_RENDERING = Guid.initString("a8554541-115d-406a-a4c7-51111c330183");
pub const kfltTimedLevelMaximumFrequency = @as(f32, 22050);
pub const kfltTimedLevelMinimumFrequency = @as(f32, 20);
pub const g_szContentPartnerInfo_LoginState = "LoginState";
pub const g_szContentPartnerInfo_MediaPlayerAccountType = "MediaPlayerAccountType";
pub const g_szContentPartnerInfo_AccountType = "AccountType";
pub const g_szContentPartnerInfo_HasCachedCredentials = "HasCachedCredentials";
pub const g_szContentPartnerInfo_LicenseRefreshAdvanceWarning = "LicenseRefreshAdvanceWarning";
pub const g_szContentPartnerInfo_PurchasedTrackRequiresReDownload = "PurchasedTrackRequiresReDownload";
pub const g_szContentPartnerInfo_MaximumTrackPurchasePerPurchase = "MaximumNumberOfTracksPerPurchase";
pub const g_szContentPartnerInfo_AccountBalance = "AccountBalance";
pub const g_szContentPartnerInfo_UserName = "UserName";
pub const g_szMediaPlayerTask_Burn = "Burn";
pub const g_szMediaPlayerTask_Browse = "Browse";
pub const g_szMediaPlayerTask_Sync = "Sync";
pub const g_szItemInfo_PopupURL = "Popup";
pub const g_szItemInfo_AuthenticationSuccessURL = "AuthenticationSuccessURL";
pub const g_szItemInfo_LoginFailureURL = "LoginFailureURL";
pub const g_szItemInfo_HTMLViewURL = "HTMLViewURL";
pub const g_szItemInfo_PopupCaption = "PopupCaption";
pub const g_szItemInfo_ALTLoginURL = "ALTLoginURL";
pub const g_szItemInfo_ALTLoginCaption = "ALTLoginCaption";
pub const g_szItemInfo_ForgetPasswordURL = "ForgotPassword";
pub const g_szItemInfo_CreateAccountURL = "CreateAccount";
pub const g_szItemInfo_ArtistArtURL = "ArtistArt";
pub const g_szItemInfo_AlbumArtURL = "AlbumArt";
pub const g_szItemInfo_ListArtURL = "ListArt";
pub const g_szItemInfo_GenreArtURL = "GenreArt";
pub const g_szItemInfo_SubGenreArtURL = "SubGenreArt";
pub const g_szItemInfo_RadioArtURL = "RadioArt";
pub const g_szItemInfo_TreeListIconURL = "CPListIDIcon";
pub const g_szItemInfo_ErrorDescription = "CPErrorDescription";
pub const g_szItemInfo_ErrorURL = "CPErrorURL";
pub const g_szItemInfo_ErrorURLLinkText = "CPErrorURLLinkText";
pub const g_szUnknownLocation = "UnknownLocation";
pub const g_szRootLocation = "RootLocation";
pub const g_szFlyoutMenu = "FlyoutMenu";
pub const g_szOnlineStore = "OnlineStore";
pub const g_szVideoRecent = "VideoRecent";
pub const g_szVideoRoot = "VideoRoot";
pub const g_szCPListID = "CPListID";
pub const g_szAllCPListIDs = "AllCPListIDs";
pub const g_szCPTrackID = "CPTrackID";
pub const g_szAllCPTrackIDs = "AllCPTrackIDs";
pub const g_szCPArtistID = "CPArtistID";
pub const g_szAllCPArtistIDs = "AllCPArtistIDs";
pub const g_szCPAlbumID = "CPAlbumID";
pub const g_szAllCPAlbumIDs = "AllCPAlbumIDs";
pub const g_szCPGenreID = "CPGenreID";
pub const g_szAllCPGenreIDs = "AllCPGenreIDs";
pub const g_szCPAlbumSubGenreID = "CPAlbumSubGenreID";
pub const g_szAllCPAlbumSubGenreIDs = "AllCPAlbumSubGenreIDs";
pub const g_szReleaseDateYear = "ReleaseDateYear";
pub const g_szAllReleaseDateYears = "AllReleaseDateYears";
pub const g_szCPRadioID = "CPRadioID";
pub const g_szAllCPRadioIDs = "AllCPRadioIDs";
pub const g_szAuthor = "Author";
pub const g_szAllAuthors = "AllAuthors";
pub const g_szWMParentalRating = "WMParentalRating";
pub const g_szAllWMParentalRatings = "AllWMParentalRatings";
pub const g_szAllUserEffectiveRatingStarss = "AllUserEffectiveRatingStarss";
pub const g_szUserEffectiveRatingStars = "UserEffectiveRatingStars";
pub const g_szUserPlaylist = "UserPlaylist";
pub const g_szViewMode_Report = "ViewModeReport";
pub const g_szViewMode_Details = "ViewModeDetails";
pub const g_szViewMode_Icon = "ViewModeIcon";
pub const g_szViewMode_Tile = "ViewModeTile";
pub const g_szViewMode_OrderedList = "ViewModeOrderedList";
pub const g_szContentPrice_Unknown = "PriceUnknown";
pub const g_szContentPrice_CannotBuy = "PriceCannotBuy";
pub const g_szContentPrice_Free = "PriceFree";
pub const g_szRefreshLicensePlay = "RefreshForPlay";
pub const g_szRefreshLicenseBurn = "RefreshForBurn";
pub const g_szRefreshLicenseSync = "RefreshForSync";
pub const g_szVerifyPermissionSync = "VerifyPermissionSync";
pub const g_szStationEvent_Started = "TrackStarted";
pub const g_szStationEvent_Complete = "TrackComplete";
pub const g_szStationEvent_Skipped = "TrackSkipped";
pub const WMProfile_V40_DialUpMBR = Guid.initString("fd7f47f1-72a6-45a4-80f0-3aecefc32c07");
pub const WMProfile_V40_IntranetMBR = Guid.initString("82cd3321-a94a-4ffc-9c2b-092c10ca16e7");
pub const WMProfile_V40_2856100MBR = Guid.initString("5a1c2206-dc5e-4186-beb2-4c5a994b132e");
pub const WMProfile_V40_6VoiceAudio = Guid.initString("d508978a-11a0-4d15-b0da-acdc99d4f890");
pub const WMProfile_V40_16AMRadio = Guid.initString("0f4be81f-d57d-41e1-b2e3-2fad986bfec2");
pub const WMProfile_V40_288FMRadioMono = Guid.initString("7fa57fc8-6ea4-4645-8abf-b6e5a8f814a1");
pub const WMProfile_V40_288FMRadioStereo = Guid.initString("22fcf466-aa40-431f-a289-06d0ea1a1e40");
pub const WMProfile_V40_56DialUpStereo = Guid.initString("e8026f87-e905-4594-a3c7-00d00041d1d9");
pub const WMProfile_V40_64Audio = Guid.initString("4820b3f7-cbec-41dc-9391-78598714c8e5");
pub const WMProfile_V40_96Audio = Guid.initString("0efa0ee3-9e64-41e2-837f-3c0038f327ba");
pub const WMProfile_V40_128Audio = Guid.initString("93ddbe12-13dc-4e32-a35e-40378e34279a");
pub const WMProfile_V40_288VideoVoice = Guid.initString("bb2bc274-0eb6-4da9-b550-ecf7f2b9948f");
pub const WMProfile_V40_288VideoAudio = Guid.initString("ac617f2d-6cbe-4e84-8e9a-ce151a12a354");
pub const WMProfile_V40_288VideoWebServer = Guid.initString("abf2f00d-d555-4815-94ce-8275f3a70bfe");
pub const WMProfile_V40_56DialUpVideo = Guid.initString("e21713bb-652f-4dab-99de-71e04400270f");
pub const WMProfile_V40_56DialUpVideoWebServer = Guid.initString("b756ff10-520f-4749-a399-b780e2fc9250");
pub const WMProfile_V40_100Video = Guid.initString("8f99ddd8-6684-456b-a0a3-33e1316895f0");
pub const WMProfile_V40_250Video = Guid.initString("541841c3-9339-4f7b-9a22-b11540894e42");
pub const WMProfile_V40_512Video = Guid.initString("70440e6d-c4ef-4f84-8cd0-d5c28686e784");
pub const WMProfile_V40_1MBVideo = Guid.initString("b4482a4c-cc17-4b07-a94e-9818d5e0f13f");
pub const WMProfile_V40_3MBVideo = Guid.initString("55374ac0-309b-4396-b88f-e6e292113f28");
pub const WMProfile_V70_DialUpMBR = Guid.initString("5b16e74b-4068-45b5-b80e-7bf8c80d2c2f");
pub const WMProfile_V70_IntranetMBR = Guid.initString("045880dc-34b6-4ca9-a326-73557ed143f3");
pub const WMProfile_V70_2856100MBR = Guid.initString("07df7a25-3fe2-4a5b-8b1e-348b0721ca70");
pub const WMProfile_V70_288VideoVoice = Guid.initString("b952f38e-7dbc-4533-a9ca-b00b1c6e9800");
pub const WMProfile_V70_288VideoAudio = Guid.initString("58bba0ee-896a-4948-9953-85b736f83947");
pub const WMProfile_V70_288VideoWebServer = Guid.initString("70a32e2b-e2df-4ebd-9105-d9ca194a2d50");
pub const WMProfile_V70_56VideoWebServer = Guid.initString("def99e40-57bc-4ab3-b2d1-b6e3caf64257");
pub const WMProfile_V70_64VideoISDN = Guid.initString("c2b7a7e9-7b8e-4992-a1a1-068217a3b311");
pub const WMProfile_V70_100Video = Guid.initString("d9f3c932-5ea9-4c6d-89b4-2686e515426e");
pub const WMProfile_V70_256Video = Guid.initString("afe69b3a-403f-4a1b-8007-0e21cfb3df84");
pub const WMProfile_V70_384Video = Guid.initString("f3d45fbb-8782-44df-97c6-8678e2f9b13d");
pub const WMProfile_V70_768Video = Guid.initString("0326ebb6-f76e-4964-b0db-e729978d35ee");
pub const WMProfile_V70_1500Video = Guid.initString("0b89164a-5490-4686-9e37-5a80884e5146");
pub const WMProfile_V70_2000Video = Guid.initString("aa980124-bf10-4e4f-9afd-4329a7395cff");
pub const WMProfile_V70_700FilmContentVideo = Guid.initString("7a747920-2449-4d76-99cb-fdb0c90484d4");
pub const WMProfile_V70_1500FilmContentVideo = Guid.initString("f6a5f6df-ee3f-434c-a433-523ce55f516b");
pub const WMProfile_V70_6VoiceAudio = Guid.initString("eaba9fbf-b64f-49b3-aa0c-73fbdd150ad0");
pub const WMProfile_V70_288FMRadioMono = Guid.initString("c012a833-a03b-44a5-96dc-ed95cc65582d");
pub const WMProfile_V70_288FMRadioStereo = Guid.initString("e96d67c9-1a39-4dc4-b900-b1184dc83620");
pub const WMProfile_V70_56DialUpStereo = Guid.initString("674ee767-0949-4fac-875e-f4c9c292013b");
pub const WMProfile_V70_64AudioISDN = Guid.initString("91dea458-9d60-4212-9c59-d40919c939e4");
pub const WMProfile_V70_64Audio = Guid.initString("b29cffc6-f131-41db-b5e8-99d8b0b945f4");
pub const WMProfile_V70_96Audio = Guid.initString("a9d4b819-16cc-4a59-9f37-693dbb0302d6");
pub const WMProfile_V70_128Audio = Guid.initString("c64cf5da-df45-40d3-8027-de698d68dc66");
pub const WMProfile_V70_225VideoPDA = Guid.initString("f55ea573-4c02-42b5-9026-a8260c438a9f");
pub const WMProfile_V70_150VideoPDA = Guid.initString("0f472967-e3c6-4797-9694-f0304c5e2f17");
pub const WMProfile_V80_255VideoPDA = Guid.initString("feedbcdf-3fac-4c93-ac0d-47941ec72c0b");
pub const WMProfile_V80_150VideoPDA = Guid.initString("aee16dfa-2c14-4a2f-ad3f-a3034031784f");
pub const WMProfile_V80_28856VideoMBR = Guid.initString("d66920c4-c21f-4ec8-a0b4-95cf2bd57fc4");
pub const WMProfile_V80_100768VideoMBR = Guid.initString("5bdb5a0e-979e-47d3-9596-73b386392a55");
pub const WMProfile_V80_288100VideoMBR = Guid.initString("d8722c69-2419-4b36-b4e0-6e17b60564e5");
pub const WMProfile_V80_288Video = Guid.initString("3df678d9-1352-4186-bbf8-74f0c19b6ae2");
pub const WMProfile_V80_56Video = Guid.initString("254e8a96-2612-405c-8039-f0bf725ced7d");
pub const WMProfile_V80_100Video = Guid.initString("a2e300b4-c2d4-4fc0-b5dd-ecbd948dc0df");
pub const WMProfile_V80_256Video = Guid.initString("bbc75500-33d2-4466-b86b-122b201cc9ae");
pub const WMProfile_V80_384Video = Guid.initString("29b00c2b-09a9-48bd-ad09-cdae117d1da7");
pub const WMProfile_V80_768Video = Guid.initString("74d01102-e71a-4820-8f0d-13d2ec1e4872");
pub const WMProfile_V80_700NTSCVideo = Guid.initString("c8c2985f-e5d9-4538-9e23-9b21bf78f745");
pub const WMProfile_V80_1400NTSCVideo = Guid.initString("931d1bee-617a-4bcd-9905-ccd0786683ee");
pub const WMProfile_V80_384PALVideo = Guid.initString("9227c692-ae62-4f72-a7ea-736062d0e21e");
pub const WMProfile_V80_700PALVideo = Guid.initString("ec298949-639b-45e2-96fd-4ab32d5919c2");
pub const WMProfile_V80_288MonoAudio = Guid.initString("7ea3126d-e1ba-4716-89af-f65cee0c0c67");
pub const WMProfile_V80_288StereoAudio = Guid.initString("7e4cab5c-35dc-45bb-a7c0-19b28070d0cc");
pub const WMProfile_V80_32StereoAudio = Guid.initString("60907f9f-b352-47e5-b210-0ef1f47e9f9d");
pub const WMProfile_V80_48StereoAudio = Guid.initString("5ee06be5-492b-480a-8a8f-12f373ecf9d4");
pub const WMProfile_V80_64StereoAudio = Guid.initString("09bb5bc4-3176-457f-8dd6-3cd919123e2d");
pub const WMProfile_V80_96StereoAudio = Guid.initString("1fc81930-61f2-436f-9d33-349f2a1c0f10");
pub const WMProfile_V80_128StereoAudio = Guid.initString("407b9450-8bdc-4ee5-88b8-6f527bd941f2");
pub const WMProfile_V80_288VideoOnly = Guid.initString("8c45b4c7-4aeb-4f78-a5ec-88420b9dadef");
pub const WMProfile_V80_56VideoOnly = Guid.initString("6e2a6955-81df-4943-ba50-68a986a708f6");
pub const WMProfile_V80_FAIRVBRVideo = Guid.initString("3510a862-5850-4886-835f-d78ec6a64042");
pub const WMProfile_V80_HIGHVBRVideo = Guid.initString("0f10d9d3-3b04-4fb0-a3d3-88d4ac854acc");
pub const WMProfile_V80_BESTVBRVideo = Guid.initString("048439ba-309c-440e-9cb4-3dcca3756423");

//--------------------------------------------------------------------------------
// Section: Types (153)
//--------------------------------------------------------------------------------
const CLSID_WindowsMediaPlayer_Value = Guid.initString("6bf52a52-394a-11d3-b153-00c04f79faa6");
pub const CLSID_WindowsMediaPlayer = &CLSID_WindowsMediaPlayer_Value;

pub const WMPOpenState = enum(i32) {
    Undefined = 0,
    PlaylistChanging = 1,
    PlaylistLocating = 2,
    PlaylistConnecting = 3,
    PlaylistLoading = 4,
    PlaylistOpening = 5,
    PlaylistOpenNoMedia = 6,
    PlaylistChanged = 7,
    MediaChanging = 8,
    MediaLocating = 9,
    MediaConnecting = 10,
    MediaLoading = 11,
    MediaOpening = 12,
    MediaOpen = 13,
    BeginCodecAcquisition = 14,
    EndCodecAcquisition = 15,
    BeginLicenseAcquisition = 16,
    EndLicenseAcquisition = 17,
    BeginIndividualization = 18,
    EndIndividualization = 19,
    MediaWaiting = 20,
    OpeningUnknownURL = 21,
};
pub const wmposUndefined = WMPOpenState.Undefined;
pub const wmposPlaylistChanging = WMPOpenState.PlaylistChanging;
pub const wmposPlaylistLocating = WMPOpenState.PlaylistLocating;
pub const wmposPlaylistConnecting = WMPOpenState.PlaylistConnecting;
pub const wmposPlaylistLoading = WMPOpenState.PlaylistLoading;
pub const wmposPlaylistOpening = WMPOpenState.PlaylistOpening;
pub const wmposPlaylistOpenNoMedia = WMPOpenState.PlaylistOpenNoMedia;
pub const wmposPlaylistChanged = WMPOpenState.PlaylistChanged;
pub const wmposMediaChanging = WMPOpenState.MediaChanging;
pub const wmposMediaLocating = WMPOpenState.MediaLocating;
pub const wmposMediaConnecting = WMPOpenState.MediaConnecting;
pub const wmposMediaLoading = WMPOpenState.MediaLoading;
pub const wmposMediaOpening = WMPOpenState.MediaOpening;
pub const wmposMediaOpen = WMPOpenState.MediaOpen;
pub const wmposBeginCodecAcquisition = WMPOpenState.BeginCodecAcquisition;
pub const wmposEndCodecAcquisition = WMPOpenState.EndCodecAcquisition;
pub const wmposBeginLicenseAcquisition = WMPOpenState.BeginLicenseAcquisition;
pub const wmposEndLicenseAcquisition = WMPOpenState.EndLicenseAcquisition;
pub const wmposBeginIndividualization = WMPOpenState.BeginIndividualization;
pub const wmposEndIndividualization = WMPOpenState.EndIndividualization;
pub const wmposMediaWaiting = WMPOpenState.MediaWaiting;
pub const wmposOpeningUnknownURL = WMPOpenState.OpeningUnknownURL;

pub const WMPPlayState = enum(i32) {
    Undefined = 0,
    Stopped = 1,
    Paused = 2,
    Playing = 3,
    ScanForward = 4,
    ScanReverse = 5,
    Buffering = 6,
    Waiting = 7,
    MediaEnded = 8,
    Transitioning = 9,
    Ready = 10,
    Reconnecting = 11,
    Last = 12,
};
pub const wmppsUndefined = WMPPlayState.Undefined;
pub const wmppsStopped = WMPPlayState.Stopped;
pub const wmppsPaused = WMPPlayState.Paused;
pub const wmppsPlaying = WMPPlayState.Playing;
pub const wmppsScanForward = WMPPlayState.ScanForward;
pub const wmppsScanReverse = WMPPlayState.ScanReverse;
pub const wmppsBuffering = WMPPlayState.Buffering;
pub const wmppsWaiting = WMPPlayState.Waiting;
pub const wmppsMediaEnded = WMPPlayState.MediaEnded;
pub const wmppsTransitioning = WMPPlayState.Transitioning;
pub const wmppsReady = WMPPlayState.Ready;
pub const wmppsReconnecting = WMPPlayState.Reconnecting;
pub const wmppsLast = WMPPlayState.Last;

pub const WMPPlaylistChangeEventType = enum(i32) {
    Unknown = 0,
    Clear = 1,
    InfoChange = 2,
    Move = 3,
    Delete = 4,
    Insert = 5,
    Append = 6,
    Private = 7,
    NameChange = 8,
    Morph = 9,
    Sort = 10,
    Last = 11,
};
pub const wmplcUnknown = WMPPlaylistChangeEventType.Unknown;
pub const wmplcClear = WMPPlaylistChangeEventType.Clear;
pub const wmplcInfoChange = WMPPlaylistChangeEventType.InfoChange;
pub const wmplcMove = WMPPlaylistChangeEventType.Move;
pub const wmplcDelete = WMPPlaylistChangeEventType.Delete;
pub const wmplcInsert = WMPPlaylistChangeEventType.Insert;
pub const wmplcAppend = WMPPlaylistChangeEventType.Append;
pub const wmplcPrivate = WMPPlaylistChangeEventType.Private;
pub const wmplcNameChange = WMPPlaylistChangeEventType.NameChange;
pub const wmplcMorph = WMPPlaylistChangeEventType.Morph;
pub const wmplcSort = WMPPlaylistChangeEventType.Sort;
pub const wmplcLast = WMPPlaylistChangeEventType.Last;

const IID_IWMPErrorItem_Value = Guid.initString("3614c646-3b3b-4de7-a81e-930e3f2127b3");
pub const IID_IWMPErrorItem = &IID_IWMPErrorItem_Value;
pub const IWMPErrorItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPErrorItem,
                phr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPErrorItem,
                phr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPErrorItem,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPErrorItem,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorContext: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPErrorItem,
                pvarContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPErrorItem,
                pvarContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_remedy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPErrorItem,
                plRemedy: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPErrorItem,
                plRemedy: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_customUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPErrorItem,
                pbstrCustomUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPErrorItem,
                pbstrCustomUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPErrorItem_get_errorCode(self: *const T, phr: ?*i32) HRESULT {
                return @as(*const IWMPErrorItem.VTable, @ptrCast(self.vtable)).get_errorCode(@as(*const IWMPErrorItem, @ptrCast(self)), phr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPErrorItem_get_errorDescription(self: *const T, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IWMPErrorItem.VTable, @ptrCast(self.vtable)).get_errorDescription(@as(*const IWMPErrorItem, @ptrCast(self)), pbstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPErrorItem_get_errorContext(self: *const T, pvarContext: ?*VARIANT) HRESULT {
                return @as(*const IWMPErrorItem.VTable, @ptrCast(self.vtable)).get_errorContext(@as(*const IWMPErrorItem, @ptrCast(self)), pvarContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPErrorItem_get_remedy(self: *const T, plRemedy: ?*i32) HRESULT {
                return @as(*const IWMPErrorItem.VTable, @ptrCast(self.vtable)).get_remedy(@as(*const IWMPErrorItem, @ptrCast(self)), plRemedy);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPErrorItem_get_customUrl(self: *const T, pbstrCustomUrl: ?*?BSTR) HRESULT {
                return @as(*const IWMPErrorItem.VTable, @ptrCast(self.vtable)).get_customUrl(@as(*const IWMPErrorItem, @ptrCast(self)), pbstrCustomUrl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPError_Value = Guid.initString("a12dcf7d-14ab-4c1b-a8cd-63909f06025b");
pub const IID_IWMPError = &IID_IWMPError_Value;
pub const IWMPError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        clearErrorQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_errorCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPError,
                plNumErrors: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPError,
                plNumErrors: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPError,
                dwIndex: i32,
                ppErrorItem: ?*?*IWMPErrorItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPError,
                dwIndex: i32,
                ppErrorItem: ?*?*IWMPErrorItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        webHelp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPError_clearErrorQueue(self: *const T) HRESULT {
                return @as(*const IWMPError.VTable, @ptrCast(self.vtable)).clearErrorQueue(@as(*const IWMPError, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPError_get_errorCount(self: *const T, plNumErrors: ?*i32) HRESULT {
                return @as(*const IWMPError.VTable, @ptrCast(self.vtable)).get_errorCount(@as(*const IWMPError, @ptrCast(self)), plNumErrors);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPError_get_item(self: *const T, dwIndex: i32, ppErrorItem: ?*?*IWMPErrorItem) HRESULT {
                return @as(*const IWMPError.VTable, @ptrCast(self.vtable)).get_item(@as(*const IWMPError, @ptrCast(self)), dwIndex, ppErrorItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPError_webHelp(self: *const T) HRESULT {
                return @as(*const IWMPError.VTable, @ptrCast(self.vtable)).webHelp(@as(*const IWMPError, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMedia_Value = Guid.initString("94d55e95-3fac-11d3-b155-00c04f79faa6");
pub const IID_IWMPMedia = &IID_IWMPMedia_Value;
pub const IWMPMedia = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isIdentical: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pIWMPMedia: ?*IWMPMedia,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pIWMPMedia: ?*IWMPMedia,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sourceURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pbstrSourceURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pbstrSourceURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imageSourceWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_imageSourceHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_markerCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pMarkerCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pMarkerCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getMarkerTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                MarkerNum: i32,
                pMarkerTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                MarkerNum: i32,
                pMarkerTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getMarkerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                MarkerNum: i32,
                pbstrMarkerName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                MarkerNum: i32,
                pbstrMarkerName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_duration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pDuration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pDuration: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_durationString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                pbstrDuration: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                pbstrDuration: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributeCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttributeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                lIndex: i32,
                pbstrItemName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                lIndex: i32,
                pbstrItemName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                bstrItemName: ?BSTR,
                bstrVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                bstrItemName: ?BSTR,
                bstrVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfoByAtom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                lAtom: i32,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                lAtom: i32,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isMemberOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                pPlaylist: ?*IWMPPlaylist,
                pvarfIsMemberOf: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                pPlaylist: ?*IWMPPlaylist,
                pvarfIsMemberOf: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isReadOnlyItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia,
                bstrItemName: ?BSTR,
                pvarfIsReadOnly: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia,
                bstrItemName: ?BSTR,
                pvarfIsReadOnly: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_isIdentical(self: *const T, pIWMPMedia: ?*IWMPMedia, pvbool: ?*i16) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_isIdentical(@as(*const IWMPMedia, @ptrCast(self)), pIWMPMedia, pvbool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_sourceURL(self: *const T, pbstrSourceURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_sourceURL(@as(*const IWMPMedia, @ptrCast(self)), pbstrSourceURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_name(@as(*const IWMPMedia, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_put_name(self: *const T, bstrName: ?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).put_name(@as(*const IWMPMedia, @ptrCast(self)), bstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_imageSourceWidth(self: *const T, pWidth: ?*i32) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_imageSourceWidth(@as(*const IWMPMedia, @ptrCast(self)), pWidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_imageSourceHeight(self: *const T, pHeight: ?*i32) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_imageSourceHeight(@as(*const IWMPMedia, @ptrCast(self)), pHeight);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_markerCount(self: *const T, pMarkerCount: ?*i32) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_markerCount(@as(*const IWMPMedia, @ptrCast(self)), pMarkerCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_getMarkerTime(self: *const T, MarkerNum: i32, pMarkerTime: ?*f64) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).getMarkerTime(@as(*const IWMPMedia, @ptrCast(self)), MarkerNum, pMarkerTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_getMarkerName(self: *const T, MarkerNum: i32, pbstrMarkerName: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).getMarkerName(@as(*const IWMPMedia, @ptrCast(self)), MarkerNum, pbstrMarkerName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_duration(self: *const T, pDuration: ?*f64) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_duration(@as(*const IWMPMedia, @ptrCast(self)), pDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_durationString(self: *const T, pbstrDuration: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_durationString(@as(*const IWMPMedia, @ptrCast(self)), pbstrDuration);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_get_attributeCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).get_attributeCount(@as(*const IWMPMedia, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_getAttributeName(self: *const T, lIndex: i32, pbstrItemName: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).getAttributeName(@as(*const IWMPMedia, @ptrCast(self)), lIndex, pbstrItemName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_getItemInfo(self: *const T, bstrItemName: ?BSTR, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPMedia, @ptrCast(self)), bstrItemName, pbstrVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_setItemInfo(self: *const T, bstrItemName: ?BSTR, bstrVal: ?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).setItemInfo(@as(*const IWMPMedia, @ptrCast(self)), bstrItemName, bstrVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_getItemInfoByAtom(self: *const T, lAtom: i32, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).getItemInfoByAtom(@as(*const IWMPMedia, @ptrCast(self)), lAtom, pbstrVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_isMemberOf(self: *const T, pPlaylist: ?*IWMPPlaylist, pvarfIsMemberOf: ?*i16) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).isMemberOf(@as(*const IWMPMedia, @ptrCast(self)), pPlaylist, pvarfIsMemberOf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia_isReadOnlyItem(self: *const T, bstrItemName: ?BSTR, pvarfIsReadOnly: ?*i16) HRESULT {
                return @as(*const IWMPMedia.VTable, @ptrCast(self.vtable)).isReadOnlyItem(@as(*const IWMPMedia, @ptrCast(self)), bstrItemName, pvarfIsReadOnly);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPControls_Value = Guid.initString("74c09e02-f828-11d2-a74b-00a0c905f36e");
pub const IID_IWMPControls = &IID_IWMPControls_Value;
pub const IWMPControls = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        play: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        fastForward: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        fastReverse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                pdCurrentPosition: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                pdCurrentPosition: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                dCurrentPosition: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                dCurrentPosition: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentPositionString: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                pbstrCurrentPosition: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                pbstrCurrentPosition: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        previous: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                ppIWMPMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                ppIWMPMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentItem: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentMarker: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                plMarker: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                plMarker: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentMarker: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls,
                lMarker: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls,
                lMarker: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        playItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_get_isAvailable(self: *const T, bstrItem: ?BSTR, pIsAvailable: ?*i16) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).get_isAvailable(@as(*const IWMPControls, @ptrCast(self)), bstrItem, pIsAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_play(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).play(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_stop(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).stop(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_pause(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).pause(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_fastForward(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).fastForward(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_fastReverse(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).fastReverse(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_get_currentPosition(self: *const T, pdCurrentPosition: ?*f64) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).get_currentPosition(@as(*const IWMPControls, @ptrCast(self)), pdCurrentPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_put_currentPosition(self: *const T, dCurrentPosition: f64) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).put_currentPosition(@as(*const IWMPControls, @ptrCast(self)), dCurrentPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_get_currentPositionString(self: *const T, pbstrCurrentPosition: ?*?BSTR) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).get_currentPositionString(@as(*const IWMPControls, @ptrCast(self)), pbstrCurrentPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_next(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).next(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_previous(self: *const T) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).previous(@as(*const IWMPControls, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_get_currentItem(self: *const T, ppIWMPMedia: ?*?*IWMPMedia) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).get_currentItem(@as(*const IWMPControls, @ptrCast(self)), ppIWMPMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_put_currentItem(self: *const T, pIWMPMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).put_currentItem(@as(*const IWMPControls, @ptrCast(self)), pIWMPMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_get_currentMarker(self: *const T, plMarker: ?*i32) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).get_currentMarker(@as(*const IWMPControls, @ptrCast(self)), plMarker);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_put_currentMarker(self: *const T, lMarker: i32) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).put_currentMarker(@as(*const IWMPControls, @ptrCast(self)), lMarker);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls_playItem(self: *const T, pIWMPMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPControls.VTable, @ptrCast(self.vtable)).playItem(@as(*const IWMPControls, @ptrCast(self)), pIWMPMedia);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSettings_Value = Guid.initString("9104d1ab-80c9-4fed-abf0-2e6417a6df14");
pub const IID_IWMPSettings = &IID_IWMPSettings_Value;
pub const IWMPSettings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_autoStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pfAutoStart: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pfAutoStart: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_autoStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                fAutoStart: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                fAutoStart: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_baseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pbstrBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pbstrBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_baseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                bstrBaseURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                bstrBaseURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultFrame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pbstrDefaultFrame: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pbstrDefaultFrame: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_defaultFrame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                bstrDefaultFrame: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                bstrDefaultFrame: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_invokeURLs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pfInvokeURLs: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pfInvokeURLs: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_invokeURLs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                fInvokeURLs: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                fInvokeURLs: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mute: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pfMute: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pfMute: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_mute: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                fMute: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                fMute: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_playCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                lCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                lCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pdRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pdRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                plBalance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                plBalance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                lBalance: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                lBalance: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSettings,
                bstrMode: ?BSTR,
                pvarfMode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSettings,
                bstrMode: ?BSTR,
                pvarfMode: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSettings,
                bstrMode: ?BSTR,
                varfMode: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSettings,
                bstrMode: ?BSTR,
                varfMode: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableErrorDialogs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                pfEnableErrorDialogs: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                pfEnableErrorDialogs: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableErrorDialogs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings,
                fEnableErrorDialogs: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings,
                fEnableErrorDialogs: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_isAvailable(self: *const T, bstrItem: ?BSTR, pIsAvailable: ?*i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_isAvailable(@as(*const IWMPSettings, @ptrCast(self)), bstrItem, pIsAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_autoStart(self: *const T, pfAutoStart: ?*i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_autoStart(@as(*const IWMPSettings, @ptrCast(self)), pfAutoStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_autoStart(self: *const T, fAutoStart: i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_autoStart(@as(*const IWMPSettings, @ptrCast(self)), fAutoStart);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_baseURL(self: *const T, pbstrBaseURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_baseURL(@as(*const IWMPSettings, @ptrCast(self)), pbstrBaseURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_baseURL(self: *const T, bstrBaseURL: ?BSTR) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_baseURL(@as(*const IWMPSettings, @ptrCast(self)), bstrBaseURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_defaultFrame(self: *const T, pbstrDefaultFrame: ?*?BSTR) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_defaultFrame(@as(*const IWMPSettings, @ptrCast(self)), pbstrDefaultFrame);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_defaultFrame(self: *const T, bstrDefaultFrame: ?BSTR) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_defaultFrame(@as(*const IWMPSettings, @ptrCast(self)), bstrDefaultFrame);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_invokeURLs(self: *const T, pfInvokeURLs: ?*i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_invokeURLs(@as(*const IWMPSettings, @ptrCast(self)), pfInvokeURLs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_invokeURLs(self: *const T, fInvokeURLs: i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_invokeURLs(@as(*const IWMPSettings, @ptrCast(self)), fInvokeURLs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_mute(self: *const T, pfMute: ?*i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_mute(@as(*const IWMPSettings, @ptrCast(self)), pfMute);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_mute(self: *const T, fMute: i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_mute(@as(*const IWMPSettings, @ptrCast(self)), fMute);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_playCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_playCount(@as(*const IWMPSettings, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_playCount(self: *const T, lCount: i32) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_playCount(@as(*const IWMPSettings, @ptrCast(self)), lCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_rate(self: *const T, pdRate: ?*f64) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_rate(@as(*const IWMPSettings, @ptrCast(self)), pdRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_rate(self: *const T, dRate: f64) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_rate(@as(*const IWMPSettings, @ptrCast(self)), dRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_balance(self: *const T, plBalance: ?*i32) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_balance(@as(*const IWMPSettings, @ptrCast(self)), plBalance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_balance(self: *const T, lBalance: i32) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_balance(@as(*const IWMPSettings, @ptrCast(self)), lBalance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_volume(self: *const T, plVolume: ?*i32) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_volume(@as(*const IWMPSettings, @ptrCast(self)), plVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_volume(self: *const T, lVolume: i32) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_volume(@as(*const IWMPSettings, @ptrCast(self)), lVolume);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_getMode(self: *const T, bstrMode: ?BSTR, pvarfMode: ?*i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).getMode(@as(*const IWMPSettings, @ptrCast(self)), bstrMode, pvarfMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_setMode(self: *const T, bstrMode: ?BSTR, varfMode: i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).setMode(@as(*const IWMPSettings, @ptrCast(self)), bstrMode, varfMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_get_enableErrorDialogs(self: *const T, pfEnableErrorDialogs: ?*i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).get_enableErrorDialogs(@as(*const IWMPSettings, @ptrCast(self)), pfEnableErrorDialogs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings_put_enableErrorDialogs(self: *const T, fEnableErrorDialogs: i16) HRESULT {
                return @as(*const IWMPSettings.VTable, @ptrCast(self.vtable)).put_enableErrorDialogs(@as(*const IWMPSettings, @ptrCast(self)), fEnableErrorDialogs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPClosedCaption_Value = Guid.initString("4f2df574-c588-11d3-9ed0-00c04fb6e937");
pub const IID_IWMPClosedCaption = &IID_IWMPClosedCaption_Value;
pub const IWMPClosedCaption = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAMIStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                pbstrSAMIStyle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                pbstrSAMIStyle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SAMIStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                bstrSAMIStyle: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                bstrSAMIStyle: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAMILang: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                pbstrSAMILang: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                pbstrSAMILang: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SAMILang: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                bstrSAMILang: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                bstrSAMILang: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAMIFileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                pbstrSAMIFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                pbstrSAMIFileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SAMIFileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                bstrSAMIFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                bstrSAMIFileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_captioningId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                pbstrCaptioningID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                pbstrCaptioningID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_captioningId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption,
                bstrCaptioningID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption,
                bstrCaptioningID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_get_SAMIStyle(self: *const T, pbstrSAMIStyle: ?*?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).get_SAMIStyle(@as(*const IWMPClosedCaption, @ptrCast(self)), pbstrSAMIStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_put_SAMIStyle(self: *const T, bstrSAMIStyle: ?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).put_SAMIStyle(@as(*const IWMPClosedCaption, @ptrCast(self)), bstrSAMIStyle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_get_SAMILang(self: *const T, pbstrSAMILang: ?*?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).get_SAMILang(@as(*const IWMPClosedCaption, @ptrCast(self)), pbstrSAMILang);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_put_SAMILang(self: *const T, bstrSAMILang: ?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).put_SAMILang(@as(*const IWMPClosedCaption, @ptrCast(self)), bstrSAMILang);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_get_SAMIFileName(self: *const T, pbstrSAMIFileName: ?*?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).get_SAMIFileName(@as(*const IWMPClosedCaption, @ptrCast(self)), pbstrSAMIFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_put_SAMIFileName(self: *const T, bstrSAMIFileName: ?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).put_SAMIFileName(@as(*const IWMPClosedCaption, @ptrCast(self)), bstrSAMIFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_get_captioningId(self: *const T, pbstrCaptioningID: ?*?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).get_captioningId(@as(*const IWMPClosedCaption, @ptrCast(self)), pbstrCaptioningID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption_put_captioningId(self: *const T, bstrCaptioningID: ?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption.VTable, @ptrCast(self.vtable)).put_captioningId(@as(*const IWMPClosedCaption, @ptrCast(self)), bstrCaptioningID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlaylist_Value = Guid.initString("d5f0f4f1-130c-11d3-b14e-00c04f79faa6");
pub const IID_IWMPPlaylist = &IID_IWMPPlaylist_Value;
pub const IWMPPlaylist = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributeCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_attributeName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                lIndex: i32,
                pbstrAttributeName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                lIndex: i32,
                pbstrAttributeName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                lIndex: i32,
                ppIWMPMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                lIndex: i32,
                ppIWMPMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
                bstrName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
                bstrName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isIdentical: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylist,
                pIWMPPlaylist: ?*IWMPPlaylist,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylist,
                pIWMPPlaylist: ?*IWMPPlaylist,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        insertItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
                lIndex: i32,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
                lIndex: i32,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        appendItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
                pIWMPMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        moveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylist,
                lIndexOld: i32,
                lIndexNew: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylist,
                lIndexOld: i32,
                lIndexNew: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_get_count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).get_count(@as(*const IWMPPlaylist, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_get_name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).get_name(@as(*const IWMPPlaylist, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_put_name(self: *const T, bstrName: ?BSTR) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).put_name(@as(*const IWMPPlaylist, @ptrCast(self)), bstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_get_attributeCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).get_attributeCount(@as(*const IWMPPlaylist, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_get_attributeName(self: *const T, lIndex: i32, pbstrAttributeName: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).get_attributeName(@as(*const IWMPPlaylist, @ptrCast(self)), lIndex, pbstrAttributeName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_get_item(self: *const T, lIndex: i32, ppIWMPMedia: ?*?*IWMPMedia) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).get_item(@as(*const IWMPPlaylist, @ptrCast(self)), lIndex, ppIWMPMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_getItemInfo(self: *const T, bstrName: ?BSTR, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPPlaylist, @ptrCast(self)), bstrName, pbstrVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_setItemInfo(self: *const T, bstrName: ?BSTR, bstrValue: ?BSTR) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).setItemInfo(@as(*const IWMPPlaylist, @ptrCast(self)), bstrName, bstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_get_isIdentical(self: *const T, pIWMPPlaylist: ?*IWMPPlaylist, pvbool: ?*i16) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).get_isIdentical(@as(*const IWMPPlaylist, @ptrCast(self)), pIWMPPlaylist, pvbool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_clear(self: *const T) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).clear(@as(*const IWMPPlaylist, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_insertItem(self: *const T, lIndex: i32, pIWMPMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).insertItem(@as(*const IWMPPlaylist, @ptrCast(self)), lIndex, pIWMPMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_appendItem(self: *const T, pIWMPMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).appendItem(@as(*const IWMPPlaylist, @ptrCast(self)), pIWMPMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_removeItem(self: *const T, pIWMPMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).removeItem(@as(*const IWMPPlaylist, @ptrCast(self)), pIWMPMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylist_moveItem(self: *const T, lIndexOld: i32, lIndexNew: i32) HRESULT {
                return @as(*const IWMPPlaylist.VTable, @ptrCast(self.vtable)).moveItem(@as(*const IWMPPlaylist, @ptrCast(self)), lIndexOld, lIndexNew);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPCdrom_Value = Guid.initString("cfab6e98-8730-11d3-b388-00c04f68574b");
pub const IID_IWMPCdrom = &IID_IWMPCdrom_Value;
pub const IWMPCdrom = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_driveSpecifier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdrom,
                pbstrDrive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdrom,
                pbstrDrive: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playlist: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdrom,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdrom,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        eject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdrom,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdrom,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdrom_get_driveSpecifier(self: *const T, pbstrDrive: ?*?BSTR) HRESULT {
                return @as(*const IWMPCdrom.VTable, @ptrCast(self.vtable)).get_driveSpecifier(@as(*const IWMPCdrom, @ptrCast(self)), pbstrDrive);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdrom_get_playlist(self: *const T, ppPlaylist: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPCdrom.VTable, @ptrCast(self.vtable)).get_playlist(@as(*const IWMPCdrom, @ptrCast(self)), ppPlaylist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdrom_eject(self: *const T) HRESULT {
                return @as(*const IWMPCdrom.VTable, @ptrCast(self.vtable)).eject(@as(*const IWMPCdrom, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPCdromCollection_Value = Guid.initString("ee4c8fe2-34b2-11d3-a3bf-006097c9b344");
pub const IID_IWMPCdromCollection = &IID_IWMPCdromCollection_Value;
pub const IWMPCdromCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromCollection,
                lIndex: i32,
                ppItem: ?*?*IWMPCdrom,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromCollection,
                lIndex: i32,
                ppItem: ?*?*IWMPCdrom,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByDriveSpecifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromCollection,
                bstrDriveSpecifier: ?BSTR,
                ppCdrom: ?*?*IWMPCdrom,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromCollection,
                bstrDriveSpecifier: ?BSTR,
                ppCdrom: ?*?*IWMPCdrom,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromCollection_get_count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPCdromCollection.VTable, @ptrCast(self.vtable)).get_count(@as(*const IWMPCdromCollection, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromCollection_item(self: *const T, lIndex: i32, ppItem: ?*?*IWMPCdrom) HRESULT {
                return @as(*const IWMPCdromCollection.VTable, @ptrCast(self.vtable)).item(@as(*const IWMPCdromCollection, @ptrCast(self)), lIndex, ppItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromCollection_getByDriveSpecifier(self: *const T, bstrDriveSpecifier: ?BSTR, ppCdrom: ?*?*IWMPCdrom) HRESULT {
                return @as(*const IWMPCdromCollection.VTable, @ptrCast(self.vtable)).getByDriveSpecifier(@as(*const IWMPCdromCollection, @ptrCast(self)), bstrDriveSpecifier, ppCdrom);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPStringCollection_Value = Guid.initString("4a976298-8c0d-11d3-b389-00c04f68574b");
pub const IID_IWMPStringCollection = &IID_IWMPStringCollection_Value;
pub const IWMPStringCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPStringCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPStringCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPStringCollection,
                lIndex: i32,
                pbstrString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPStringCollection,
                lIndex: i32,
                pbstrString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPStringCollection_get_count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPStringCollection.VTable, @ptrCast(self.vtable)).get_count(@as(*const IWMPStringCollection, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPStringCollection_item(self: *const T, lIndex: i32, pbstrString: ?*?BSTR) HRESULT {
                return @as(*const IWMPStringCollection.VTable, @ptrCast(self.vtable)).item(@as(*const IWMPStringCollection, @ptrCast(self)), lIndex, pbstrString);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMediaCollection_Value = Guid.initString("8363bc22-b4b4-4b19-989d-1cd765749dd1");
pub const IID_IWMPMediaCollection = &IID_IWMPMediaCollection_Value;
pub const IWMPMediaCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrURL: ?BSTR,
                ppItem: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrURL: ?BSTR,
                ppItem: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrName: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrName: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByGenre: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrGenre: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrGenre: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByAuthor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrAuthor: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrAuthor: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByAlbum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrAlbum: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrAlbum: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrAttribute: ?BSTR,
                bstrValue: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrAttribute: ?BSTR,
                bstrValue: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                pItem: ?*IWMPMedia,
                varfDeleteFile: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                pItem: ?*IWMPMedia,
                varfDeleteFile: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttributeStringCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrAttribute: ?BSTR,
                bstrMediaType: ?BSTR,
                ppStringCollection: ?*?*IWMPStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrAttribute: ?BSTR,
                bstrMediaType: ?BSTR,
                ppStringCollection: ?*?*IWMPStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getMediaAtom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                bstrItemName: ?BSTR,
                plAtom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                bstrItemName: ?BSTR,
                plAtom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                pItem: ?*IWMPMedia,
                varfIsDeleted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                pItem: ?*IWMPMedia,
                varfIsDeleted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection,
                pItem: ?*IWMPMedia,
                pvarfIsDeleted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection,
                pItem: ?*IWMPMedia,
                pvarfIsDeleted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_add(self: *const T, bstrURL: ?BSTR, ppItem: ?*?*IWMPMedia) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).add(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrURL, ppItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getAll(self: *const T, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getAll(@as(*const IWMPMediaCollection, @ptrCast(self)), ppMediaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getByName(self: *const T, bstrName: ?BSTR, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getByName(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrName, ppMediaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getByGenre(self: *const T, bstrGenre: ?BSTR, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getByGenre(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrGenre, ppMediaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getByAuthor(self: *const T, bstrAuthor: ?BSTR, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getByAuthor(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrAuthor, ppMediaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getByAlbum(self: *const T, bstrAlbum: ?BSTR, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getByAlbum(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrAlbum, ppMediaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getByAttribute(self: *const T, bstrAttribute: ?BSTR, bstrValue: ?BSTR, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getByAttribute(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrAttribute, bstrValue, ppMediaItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_remove(self: *const T, pItem: ?*IWMPMedia, varfDeleteFile: i16) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).remove(@as(*const IWMPMediaCollection, @ptrCast(self)), pItem, varfDeleteFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getAttributeStringCollection(self: *const T, bstrAttribute: ?BSTR, bstrMediaType: ?BSTR, ppStringCollection: ?*?*IWMPStringCollection) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getAttributeStringCollection(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrAttribute, bstrMediaType, ppStringCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_getMediaAtom(self: *const T, bstrItemName: ?BSTR, plAtom: ?*i32) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).getMediaAtom(@as(*const IWMPMediaCollection, @ptrCast(self)), bstrItemName, plAtom);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_setDeleted(self: *const T, pItem: ?*IWMPMedia, varfIsDeleted: i16) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).setDeleted(@as(*const IWMPMediaCollection, @ptrCast(self)), pItem, varfIsDeleted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection_isDeleted(self: *const T, pItem: ?*IWMPMedia, pvarfIsDeleted: ?*i16) HRESULT {
                return @as(*const IWMPMediaCollection.VTable, @ptrCast(self.vtable)).isDeleted(@as(*const IWMPMediaCollection, @ptrCast(self)), pItem, pvarfIsDeleted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlaylistArray_Value = Guid.initString("679409c0-99f7-11d3-9fb7-00105aa620bb");
pub const IID_IWMPPlaylistArray = &IID_IWMPPlaylistArray_Value;
pub const IWMPPlaylistArray = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlaylistArray,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlaylistArray,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistArray,
                lIndex: i32,
                ppItem: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistArray,
                lIndex: i32,
                ppItem: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistArray_get_count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPPlaylistArray.VTable, @ptrCast(self.vtable)).get_count(@as(*const IWMPPlaylistArray, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistArray_item(self: *const T, lIndex: i32, ppItem: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPPlaylistArray.VTable, @ptrCast(self.vtable)).item(@as(*const IWMPPlaylistArray, @ptrCast(self)), lIndex, ppItem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlaylistCollection_Value = Guid.initString("10a13217-23a7-439b-b1c0-d847c79b7774");
pub const IID_IWMPPlaylistCollection = &IID_IWMPPlaylistCollection_Value;
pub const IWMPPlaylistCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        newPlaylist: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                bstrName: ?BSTR,
                ppItem: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                bstrName: ?BSTR,
                ppItem: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                ppPlaylistArray: ?*?*IWMPPlaylistArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                ppPlaylistArray: ?*?*IWMPPlaylistArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                bstrName: ?BSTR,
                ppPlaylistArray: ?*?*IWMPPlaylistArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                bstrName: ?BSTR,
                ppPlaylistArray: ?*?*IWMPPlaylistArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
                varfIsDeleted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
                varfIsDeleted: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
                pvarfIsDeleted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
                pvarfIsDeleted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        importPlaylist: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
                ppImportedItem: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlaylistCollection,
                pItem: ?*IWMPPlaylist,
                ppImportedItem: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_newPlaylist(self: *const T, bstrName: ?BSTR, ppItem: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).newPlaylist(@as(*const IWMPPlaylistCollection, @ptrCast(self)), bstrName, ppItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_getAll(self: *const T, ppPlaylistArray: ?*?*IWMPPlaylistArray) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).getAll(@as(*const IWMPPlaylistCollection, @ptrCast(self)), ppPlaylistArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_getByName(self: *const T, bstrName: ?BSTR, ppPlaylistArray: ?*?*IWMPPlaylistArray) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).getByName(@as(*const IWMPPlaylistCollection, @ptrCast(self)), bstrName, ppPlaylistArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_remove(self: *const T, pItem: ?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).remove(@as(*const IWMPPlaylistCollection, @ptrCast(self)), pItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_setDeleted(self: *const T, pItem: ?*IWMPPlaylist, varfIsDeleted: i16) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).setDeleted(@as(*const IWMPPlaylistCollection, @ptrCast(self)), pItem, varfIsDeleted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_isDeleted(self: *const T, pItem: ?*IWMPPlaylist, pvarfIsDeleted: ?*i16) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).isDeleted(@as(*const IWMPPlaylistCollection, @ptrCast(self)), pItem, pvarfIsDeleted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlaylistCollection_importPlaylist(self: *const T, pItem: ?*IWMPPlaylist, ppImportedItem: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPPlaylistCollection.VTable, @ptrCast(self.vtable)).importPlaylist(@as(*const IWMPPlaylistCollection, @ptrCast(self)), pItem, ppImportedItem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNetwork_Value = Guid.initString("ec21b779-edef-462d-bba4-ad9dde2b29a7");
pub const IID_IWMPNetwork = &IID_IWMPNetwork_Value;
pub const IWMPNetwork = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bandWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plBandwidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plBandwidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_recoveredPackets: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plRecoveredPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plRecoveredPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sourceProtocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                pbstrSourceProtocol: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                pbstrSourceProtocol: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_receivedPackets: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plReceivedPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plReceivedPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_lostPackets: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plLostPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plLostPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_receptionQuality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plReceptionQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plReceptionQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bufferingCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plBufferingCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plBufferingCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bufferingProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plBufferingProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plBufferingProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bufferingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plBufferingTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plBufferingTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_bufferingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                lBufferingTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                lBufferingTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_frameRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxBitRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plBitRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plBitRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_bitRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plBitRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plBitRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProxySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                plProxySetting: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                plProxySetting: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProxySettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                lProxySetting: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                lProxySetting: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProxyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pbstrProxyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pbstrProxyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProxyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                bstrProxyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                bstrProxyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProxyPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                lProxyPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                lProxyPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProxyPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                lProxyPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                lProxyPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProxyExceptionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pbstrExceptionList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pbstrExceptionList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProxyExceptionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pbstrExceptionList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pbstrExceptionList: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getProxyBypassForLocal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pfBypassForLocal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                pfBypassForLocal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setProxyBypassForLocal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                fBypassForLocal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNetwork,
                bstrProtocol: ?BSTR,
                fBypassForLocal: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_maxBandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                lMaxBandwidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                lMaxBandwidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_maxBandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                lMaxBandwidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                lMaxBandwidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_downloadProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plDownloadProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plDownloadProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_encodedFrameRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_framesSkipped: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPNetwork,
                plFrames: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPNetwork,
                plFrames: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_bandWidth(self: *const T, plBandwidth: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_bandWidth(@as(*const IWMPNetwork, @ptrCast(self)), plBandwidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_recoveredPackets(self: *const T, plRecoveredPackets: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_recoveredPackets(@as(*const IWMPNetwork, @ptrCast(self)), plRecoveredPackets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_sourceProtocol(self: *const T, pbstrSourceProtocol: ?*?BSTR) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_sourceProtocol(@as(*const IWMPNetwork, @ptrCast(self)), pbstrSourceProtocol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_receivedPackets(self: *const T, plReceivedPackets: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_receivedPackets(@as(*const IWMPNetwork, @ptrCast(self)), plReceivedPackets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_lostPackets(self: *const T, plLostPackets: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_lostPackets(@as(*const IWMPNetwork, @ptrCast(self)), plLostPackets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_receptionQuality(self: *const T, plReceptionQuality: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_receptionQuality(@as(*const IWMPNetwork, @ptrCast(self)), plReceptionQuality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_bufferingCount(self: *const T, plBufferingCount: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_bufferingCount(@as(*const IWMPNetwork, @ptrCast(self)), plBufferingCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_bufferingProgress(self: *const T, plBufferingProgress: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_bufferingProgress(@as(*const IWMPNetwork, @ptrCast(self)), plBufferingProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_bufferingTime(self: *const T, plBufferingTime: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_bufferingTime(@as(*const IWMPNetwork, @ptrCast(self)), plBufferingTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_put_bufferingTime(self: *const T, lBufferingTime: i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).put_bufferingTime(@as(*const IWMPNetwork, @ptrCast(self)), lBufferingTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_frameRate(self: *const T, plFrameRate: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_frameRate(@as(*const IWMPNetwork, @ptrCast(self)), plFrameRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_maxBitRate(self: *const T, plBitRate: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_maxBitRate(@as(*const IWMPNetwork, @ptrCast(self)), plBitRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_bitRate(self: *const T, plBitRate: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_bitRate(@as(*const IWMPNetwork, @ptrCast(self)), plBitRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_getProxySettings(self: *const T, bstrProtocol: ?BSTR, plProxySetting: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).getProxySettings(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, plProxySetting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_setProxySettings(self: *const T, bstrProtocol: ?BSTR, lProxySetting: i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).setProxySettings(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, lProxySetting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_getProxyName(self: *const T, bstrProtocol: ?BSTR, pbstrProxyName: ?*?BSTR) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).getProxyName(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, pbstrProxyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_setProxyName(self: *const T, bstrProtocol: ?BSTR, bstrProxyName: ?BSTR) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).setProxyName(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, bstrProxyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_getProxyPort(self: *const T, bstrProtocol: ?BSTR, lProxyPort: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).getProxyPort(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, lProxyPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_setProxyPort(self: *const T, bstrProtocol: ?BSTR, lProxyPort: i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).setProxyPort(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, lProxyPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_getProxyExceptionList(self: *const T, bstrProtocol: ?BSTR, pbstrExceptionList: ?*?BSTR) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).getProxyExceptionList(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, pbstrExceptionList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_setProxyExceptionList(self: *const T, bstrProtocol: ?BSTR, pbstrExceptionList: ?BSTR) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).setProxyExceptionList(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, pbstrExceptionList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_getProxyBypassForLocal(self: *const T, bstrProtocol: ?BSTR, pfBypassForLocal: ?*i16) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).getProxyBypassForLocal(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, pfBypassForLocal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_setProxyBypassForLocal(self: *const T, bstrProtocol: ?BSTR, fBypassForLocal: i16) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).setProxyBypassForLocal(@as(*const IWMPNetwork, @ptrCast(self)), bstrProtocol, fBypassForLocal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_maxBandwidth(self: *const T, lMaxBandwidth: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_maxBandwidth(@as(*const IWMPNetwork, @ptrCast(self)), lMaxBandwidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_put_maxBandwidth(self: *const T, lMaxBandwidth: i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).put_maxBandwidth(@as(*const IWMPNetwork, @ptrCast(self)), lMaxBandwidth);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_downloadProgress(self: *const T, plDownloadProgress: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_downloadProgress(@as(*const IWMPNetwork, @ptrCast(self)), plDownloadProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_encodedFrameRate(self: *const T, plFrameRate: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_encodedFrameRate(@as(*const IWMPNetwork, @ptrCast(self)), plFrameRate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNetwork_get_framesSkipped(self: *const T, plFrames: ?*i32) HRESULT {
                return @as(*const IWMPNetwork.VTable, @ptrCast(self.vtable)).get_framesSkipped(@as(*const IWMPNetwork, @ptrCast(self)), plFrames);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPCore_Value = Guid.initString("d84cca99-cce2-11d2-9ecc-0000f8085981");
pub const IID_IWMPCore = &IID_IWMPCore_Value;
pub const IWMPCore = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_openState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pwmpos: ?*WMPOpenState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pwmpos: ?*WMPOpenState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pwmpps: ?*WMPPlayState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pwmpps: ?*WMPPlayState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_controls: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppControl: ?*?*IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppControl: ?*?*IWMPControls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_settings: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppSettings: ?*?*IWMPSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppSettings: ?*?*IWMPSettings,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentMedia: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mediaCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppMediaCollection: ?*?*IWMPMediaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppMediaCollection: ?*?*IWMPMediaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playlistCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppPlaylistCollection: ?*?*IWMPPlaylistCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppPlaylistCollection: ?*?*IWMPPlaylistCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_versionInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pbstrVersionInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pbstrVersionInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        launchURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCore,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCore,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_network: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppQNI: ?*?*IWMPNetwork,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppQNI: ?*?*IWMPNetwork,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentPlaylist: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppPL: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppPL: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentPlaylist: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pPL: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pPL: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_cdromCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppCdromCollection: ?*?*IWMPCdromCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppCdromCollection: ?*?*IWMPCdromCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_closedCaption: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppClosedCaption: ?*?*IWMPClosedCaption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppClosedCaption: ?*?*IWMPClosedCaption,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isOnline: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pfOnline: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pfOnline: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                ppError: ?*?*IWMPError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                ppError: ?*?*IWMPError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore,
                pbstrStatus: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore,
                pbstrStatus: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_close(self: *const T) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).close(@as(*const IWMPCore, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_URL(self: *const T, pbstrURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IWMPCore, @ptrCast(self)), pbstrURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_put_URL(self: *const T, bstrURL: ?BSTR) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).put_URL(@as(*const IWMPCore, @ptrCast(self)), bstrURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_openState(self: *const T, pwmpos: ?*WMPOpenState) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_openState(@as(*const IWMPCore, @ptrCast(self)), pwmpos);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_playState(self: *const T, pwmpps: ?*WMPPlayState) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_playState(@as(*const IWMPCore, @ptrCast(self)), pwmpps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_controls(self: *const T, ppControl: ?*?*IWMPControls) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_controls(@as(*const IWMPCore, @ptrCast(self)), ppControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_settings(self: *const T, ppSettings: ?*?*IWMPSettings) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_settings(@as(*const IWMPCore, @ptrCast(self)), ppSettings);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_currentMedia(self: *const T, ppMedia: ?*?*IWMPMedia) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_currentMedia(@as(*const IWMPCore, @ptrCast(self)), ppMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_put_currentMedia(self: *const T, pMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).put_currentMedia(@as(*const IWMPCore, @ptrCast(self)), pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_mediaCollection(self: *const T, ppMediaCollection: ?*?*IWMPMediaCollection) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_mediaCollection(@as(*const IWMPCore, @ptrCast(self)), ppMediaCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_playlistCollection(self: *const T, ppPlaylistCollection: ?*?*IWMPPlaylistCollection) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_playlistCollection(@as(*const IWMPCore, @ptrCast(self)), ppPlaylistCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_versionInfo(self: *const T, pbstrVersionInfo: ?*?BSTR) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_versionInfo(@as(*const IWMPCore, @ptrCast(self)), pbstrVersionInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_launchURL(self: *const T, bstrURL: ?BSTR) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).launchURL(@as(*const IWMPCore, @ptrCast(self)), bstrURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_network(self: *const T, ppQNI: ?*?*IWMPNetwork) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_network(@as(*const IWMPCore, @ptrCast(self)), ppQNI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_currentPlaylist(self: *const T, ppPL: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_currentPlaylist(@as(*const IWMPCore, @ptrCast(self)), ppPL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_put_currentPlaylist(self: *const T, pPL: ?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).put_currentPlaylist(@as(*const IWMPCore, @ptrCast(self)), pPL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_cdromCollection(self: *const T, ppCdromCollection: ?*?*IWMPCdromCollection) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_cdromCollection(@as(*const IWMPCore, @ptrCast(self)), ppCdromCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_closedCaption(self: *const T, ppClosedCaption: ?*?*IWMPClosedCaption) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_closedCaption(@as(*const IWMPCore, @ptrCast(self)), ppClosedCaption);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_isOnline(self: *const T, pfOnline: ?*i16) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_isOnline(@as(*const IWMPCore, @ptrCast(self)), pfOnline);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_error(self: *const T, ppError: ?*?*IWMPError) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_error(@as(*const IWMPCore, @ptrCast(self)), ppError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore_get_status(self: *const T, pbstrStatus: ?*?BSTR) HRESULT {
                return @as(*const IWMPCore.VTable, @ptrCast(self.vtable)).get_status(@as(*const IWMPCore, @ptrCast(self)), pbstrStatus);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayer_Value = Guid.initString("6bf52a4f-394a-11d3-b153-00c04f79faa6");
pub const IID_IWMPPlayer = &IID_IWMPPlayer_Value;
pub const IWMPPlayer = extern struct {
    pub const VTable = extern struct {
        base: IWMPCore.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPCore.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_get_enabled(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).get_enabled(@as(*const IWMPPlayer, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_put_enabled(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).put_enabled(@as(*const IWMPPlayer, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_get_fullScreen(self: *const T, pbFullScreen: ?*i16) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).get_fullScreen(@as(*const IWMPPlayer, @ptrCast(self)), pbFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_put_fullScreen(self: *const T, bFullScreen: i16) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).put_fullScreen(@as(*const IWMPPlayer, @ptrCast(self)), bFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_get_enableContextMenu(self: *const T, pbEnableContextMenu: ?*i16) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).get_enableContextMenu(@as(*const IWMPPlayer, @ptrCast(self)), pbEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_put_enableContextMenu(self: *const T, bEnableContextMenu: i16) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).put_enableContextMenu(@as(*const IWMPPlayer, @ptrCast(self)), bEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_put_uiMode(self: *const T, bstrMode: ?BSTR) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).put_uiMode(@as(*const IWMPPlayer, @ptrCast(self)), bstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer_get_uiMode(self: *const T, pbstrMode: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlayer.VTable, @ptrCast(self.vtable)).get_uiMode(@as(*const IWMPPlayer, @ptrCast(self)), pbstrMode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayer2_Value = Guid.initString("0e6b01d1-d407-4c85-bf5f-1c01f6150280");
pub const IID_IWMPPlayer2 = &IID_IWMPPlayer2_Value;
pub const IWMPPlayer2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPCore.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stretchToFit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_stretchToFit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_windowlessVideo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_windowlessVideo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer2,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer2,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPCore.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_get_enabled(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).get_enabled(@as(*const IWMPPlayer2, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_put_enabled(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).put_enabled(@as(*const IWMPPlayer2, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_get_fullScreen(self: *const T, pbFullScreen: ?*i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).get_fullScreen(@as(*const IWMPPlayer2, @ptrCast(self)), pbFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_put_fullScreen(self: *const T, bFullScreen: i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).put_fullScreen(@as(*const IWMPPlayer2, @ptrCast(self)), bFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_get_enableContextMenu(self: *const T, pbEnableContextMenu: ?*i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).get_enableContextMenu(@as(*const IWMPPlayer2, @ptrCast(self)), pbEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_put_enableContextMenu(self: *const T, bEnableContextMenu: i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).put_enableContextMenu(@as(*const IWMPPlayer2, @ptrCast(self)), bEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_put_uiMode(self: *const T, bstrMode: ?BSTR) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).put_uiMode(@as(*const IWMPPlayer2, @ptrCast(self)), bstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_get_uiMode(self: *const T, pbstrMode: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).get_uiMode(@as(*const IWMPPlayer2, @ptrCast(self)), pbstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_get_stretchToFit(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).get_stretchToFit(@as(*const IWMPPlayer2, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_put_stretchToFit(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).put_stretchToFit(@as(*const IWMPPlayer2, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_get_windowlessVideo(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).get_windowlessVideo(@as(*const IWMPPlayer2, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer2_put_windowlessVideo(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer2.VTable, @ptrCast(self.vtable)).put_windowlessVideo(@as(*const IWMPPlayer2, @ptrCast(self)), bEnabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMedia2_Value = Guid.initString("ab7c88bb-143e-4ea4-acc3-e4350b2106c3");
pub const IID_IWMPMedia2 = &IID_IWMPMedia2_Value;
pub const IWMPMedia2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPMedia.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_error: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMedia2,
                ppIWMPErrorItem: ?*?*IWMPErrorItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMedia2,
                ppIWMPErrorItem: ?*?*IWMPErrorItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPMedia.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia2_get_error(self: *const T, ppIWMPErrorItem: ?*?*IWMPErrorItem) HRESULT {
                return @as(*const IWMPMedia2.VTable, @ptrCast(self.vtable)).get_error(@as(*const IWMPMedia2, @ptrCast(self)), ppIWMPErrorItem);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPControls2_Value = Guid.initString("6f030d25-0890-480f-9775-1f7e40ab5b8e");
pub const IID_IWMPControls2 = &IID_IWMPControls2_Value;
pub const IWMPControls2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPControls.VTable,
        step: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls2,
                lStep: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls2,
                lStep: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPControls.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls2_step(self: *const T, lStep: i32) HRESULT {
                return @as(*const IWMPControls2.VTable, @ptrCast(self.vtable)).step(@as(*const IWMPControls2, @ptrCast(self)), lStep);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPDVD_Value = Guid.initString("8da61686-4668-4a5c-ae5d-803193293dbe");
pub const IID_IWMPDVD = &IID_IWMPDVD_Value;
pub const IWMPDVD = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDVD,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDVD,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_domain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDVD,
                strDomain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDVD,
                strDomain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        topMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        titleMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        back: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        @"resume": switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDVD_get_isAvailable(self: *const T, bstrItem: ?BSTR, pIsAvailable: ?*i16) HRESULT {
                return @as(*const IWMPDVD.VTable, @ptrCast(self.vtable)).get_isAvailable(@as(*const IWMPDVD, @ptrCast(self)), bstrItem, pIsAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDVD_get_domain(self: *const T, strDomain: ?*?BSTR) HRESULT {
                return @as(*const IWMPDVD.VTable, @ptrCast(self.vtable)).get_domain(@as(*const IWMPDVD, @ptrCast(self)), strDomain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDVD_topMenu(self: *const T) HRESULT {
                return @as(*const IWMPDVD.VTable, @ptrCast(self.vtable)).topMenu(@as(*const IWMPDVD, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDVD_titleMenu(self: *const T) HRESULT {
                return @as(*const IWMPDVD.VTable, @ptrCast(self.vtable)).titleMenu(@as(*const IWMPDVD, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDVD_back(self: *const T) HRESULT {
                return @as(*const IWMPDVD.VTable, @ptrCast(self.vtable)).back(@as(*const IWMPDVD, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDVD_resume(self: *const T) HRESULT {
                return @as(*const IWMPDVD.VTable, @ptrCast(self.vtable)).@"resume"(@as(*const IWMPDVD, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPCore2_Value = Guid.initString("bc17e5b7-7561-4c18-bb90-17d485775659");
pub const IID_IWMPCore2 = &IID_IWMPCore2_Value;
pub const IWMPCore2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPCore.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dvd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCore2,
                ppDVD: ?*?*IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCore2,
                ppDVD: ?*?*IWMPDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPCore.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore2_get_dvd(self: *const T, ppDVD: ?*?*IWMPDVD) HRESULT {
                return @as(*const IWMPCore2.VTable, @ptrCast(self.vtable)).get_dvd(@as(*const IWMPCore2, @ptrCast(self)), ppDVD);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayer3_Value = Guid.initString("54062b68-052a-4c25-a39f-8b63346511d4");
pub const IID_IWMPPlayer3 = &IID_IWMPPlayer3_Value;
pub const IWMPPlayer3 = extern struct {
    pub const VTable = extern struct {
        base: IWMPCore2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stretchToFit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_stretchToFit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_windowlessVideo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_windowlessVideo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer3,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer3,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPCore2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_get_enabled(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).get_enabled(@as(*const IWMPPlayer3, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_put_enabled(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).put_enabled(@as(*const IWMPPlayer3, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_get_fullScreen(self: *const T, pbFullScreen: ?*i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).get_fullScreen(@as(*const IWMPPlayer3, @ptrCast(self)), pbFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_put_fullScreen(self: *const T, bFullScreen: i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).put_fullScreen(@as(*const IWMPPlayer3, @ptrCast(self)), bFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_get_enableContextMenu(self: *const T, pbEnableContextMenu: ?*i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).get_enableContextMenu(@as(*const IWMPPlayer3, @ptrCast(self)), pbEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_put_enableContextMenu(self: *const T, bEnableContextMenu: i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).put_enableContextMenu(@as(*const IWMPPlayer3, @ptrCast(self)), bEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_put_uiMode(self: *const T, bstrMode: ?BSTR) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).put_uiMode(@as(*const IWMPPlayer3, @ptrCast(self)), bstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_get_uiMode(self: *const T, pbstrMode: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).get_uiMode(@as(*const IWMPPlayer3, @ptrCast(self)), pbstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_get_stretchToFit(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).get_stretchToFit(@as(*const IWMPPlayer3, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_put_stretchToFit(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).put_stretchToFit(@as(*const IWMPPlayer3, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_get_windowlessVideo(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).get_windowlessVideo(@as(*const IWMPPlayer3, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer3_put_windowlessVideo(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer3.VTable, @ptrCast(self.vtable)).put_windowlessVideo(@as(*const IWMPPlayer3, @ptrCast(self)), bEnabled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPErrorItem2_Value = Guid.initString("f75ccec0-c67c-475c-931e-8719870bee7d");
pub const IID_IWMPErrorItem2 = &IID_IWMPErrorItem2_Value;
pub const IWMPErrorItem2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPErrorItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_condition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPErrorItem2,
                plCondition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPErrorItem2,
                plCondition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPErrorItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPErrorItem2_get_condition(self: *const T, plCondition: ?*i32) HRESULT {
                return @as(*const IWMPErrorItem2.VTable, @ptrCast(self.vtable)).get_condition(@as(*const IWMPErrorItem2, @ptrCast(self)), plCondition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPRemoteMediaServices_Value = Guid.initString("cbb92747-741f-44fe-ab5b-f1a48f3b2a59");
pub const IID_IWMPRemoteMediaServices = &IID_IWMPRemoteMediaServices_Value;
pub const IWMPRemoteMediaServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetServiceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPRemoteMediaServices,
                pbstrType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPRemoteMediaServices,
                pbstrType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplicationName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPRemoteMediaServices,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPRemoteMediaServices,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptableObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPRemoteMediaServices,
                pbstrName: ?*?BSTR,
                ppDispatch: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPRemoteMediaServices,
                pbstrName: ?*?BSTR,
                ppDispatch: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCustomUIMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPRemoteMediaServices,
                pbstrFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPRemoteMediaServices,
                pbstrFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPRemoteMediaServices_GetServiceType(self: *const T, pbstrType: ?*?BSTR) HRESULT {
                return @as(*const IWMPRemoteMediaServices.VTable, @ptrCast(self.vtable)).GetServiceType(@as(*const IWMPRemoteMediaServices, @ptrCast(self)), pbstrType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPRemoteMediaServices_GetApplicationName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPRemoteMediaServices.VTable, @ptrCast(self.vtable)).GetApplicationName(@as(*const IWMPRemoteMediaServices, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPRemoteMediaServices_GetScriptableObject(self: *const T, pbstrName: ?*?BSTR, ppDispatch: ?*?*IDispatch) HRESULT {
                return @as(*const IWMPRemoteMediaServices.VTable, @ptrCast(self.vtable)).GetScriptableObject(@as(*const IWMPRemoteMediaServices, @ptrCast(self)), pbstrName, ppDispatch);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPRemoteMediaServices_GetCustomUIMode(self: *const T, pbstrFile: ?*?BSTR) HRESULT {
                return @as(*const IWMPRemoteMediaServices.VTable, @ptrCast(self.vtable)).GetCustomUIMode(@as(*const IWMPRemoteMediaServices, @ptrCast(self)), pbstrFile);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSkinManager_Value = Guid.initString("076f2fa6-ed30-448b-8cc5-3f3ef3529c7a");
pub const IID_IWMPSkinManager = &IID_IWMPSkinManager_Value;
pub const IWMPSkinManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVisualStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSkinManager,
                bstrPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSkinManager,
                bstrPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSkinManager_SetVisualStyle(self: *const T, bstrPath: ?BSTR) HRESULT {
                return @as(*const IWMPSkinManager.VTable, @ptrCast(self.vtable)).SetVisualStyle(@as(*const IWMPSkinManager, @ptrCast(self)), bstrPath);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMetadataPicture_Value = Guid.initString("5c29bbe0-f87d-4c45-aa28-a70f0230ffa9");
pub const IID_IWMPMetadataPicture = &IID_IWMPMetadataPicture_Value;
pub const IWMPMetadataPicture = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mimeType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMetadataPicture,
                pbstrMimeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMetadataPicture,
                pbstrMimeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pictureType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMetadataPicture,
                pbstrPictureType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMetadataPicture,
                pbstrPictureType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMetadataPicture,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMetadataPicture,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMetadataPicture,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMetadataPicture,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMetadataPicture_get_mimeType(self: *const T, pbstrMimeType: ?*?BSTR) HRESULT {
                return @as(*const IWMPMetadataPicture.VTable, @ptrCast(self.vtable)).get_mimeType(@as(*const IWMPMetadataPicture, @ptrCast(self)), pbstrMimeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMetadataPicture_get_pictureType(self: *const T, pbstrPictureType: ?*?BSTR) HRESULT {
                return @as(*const IWMPMetadataPicture.VTable, @ptrCast(self.vtable)).get_pictureType(@as(*const IWMPMetadataPicture, @ptrCast(self)), pbstrPictureType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMetadataPicture_get_description(self: *const T, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IWMPMetadataPicture.VTable, @ptrCast(self.vtable)).get_description(@as(*const IWMPMetadataPicture, @ptrCast(self)), pbstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMetadataPicture_get_URL(self: *const T, pbstrURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPMetadataPicture.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IWMPMetadataPicture, @ptrCast(self)), pbstrURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMetadataText_Value = Guid.initString("769a72db-13d2-45e2-9c48-53ca9d5b7450");
pub const IID_IWMPMetadataText = &IID_IWMPMetadataText_Value;
pub const IWMPMetadataText = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMetadataText,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMetadataText,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_text: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPMetadataText,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPMetadataText,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMetadataText_get_description(self: *const T, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IWMPMetadataText.VTable, @ptrCast(self.vtable)).get_description(@as(*const IWMPMetadataText, @ptrCast(self)), pbstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMetadataText_get_text(self: *const T, pbstrText: ?*?BSTR) HRESULT {
                return @as(*const IWMPMetadataText.VTable, @ptrCast(self.vtable)).get_text(@as(*const IWMPMetadataText, @ptrCast(self)), pbstrText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMedia3_Value = Guid.initString("f118efc7-f03a-4fb4-99c9-1c02a5c1065b");
pub const IID_IWMPMedia3 = &IID_IWMPMedia3_Value;
pub const IWMPMedia3 = extern struct {
    pub const VTable = extern struct {
        base: IWMPMedia2.VTable,
        getAttributeCountByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia3,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia3,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfoByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMedia3,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                lIndex: i32,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMedia3,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                lIndex: i32,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPMedia2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia3_getAttributeCountByType(self: *const T, bstrType: ?BSTR, bstrLanguage: ?BSTR, plCount: ?*i32) HRESULT {
                return @as(*const IWMPMedia3.VTable, @ptrCast(self.vtable)).getAttributeCountByType(@as(*const IWMPMedia3, @ptrCast(self)), bstrType, bstrLanguage, plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMedia3_getItemInfoByType(self: *const T, bstrType: ?BSTR, bstrLanguage: ?BSTR, lIndex: i32, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const IWMPMedia3.VTable, @ptrCast(self.vtable)).getItemInfoByType(@as(*const IWMPMedia3, @ptrCast(self)), bstrType, bstrLanguage, lIndex, pvarValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSettings2_Value = Guid.initString("fda937a4-eece-4da5-a0b6-39bf89ade2c2");
pub const IID_IWMPSettings2 = &IID_IWMPSettings2_Value;
pub const IWMPSettings2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPSettings.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_defaultAudioLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings2,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings2,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mediaAccessRights: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSettings2,
                pbstrRights: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSettings2,
                pbstrRights: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        requestMediaAccessRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSettings2,
                bstrDesiredAccess: ?BSTR,
                pvbAccepted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSettings2,
                bstrDesiredAccess: ?BSTR,
                pvbAccepted: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPSettings.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings2_get_defaultAudioLanguage(self: *const T, plLangID: ?*i32) HRESULT {
                return @as(*const IWMPSettings2.VTable, @ptrCast(self.vtable)).get_defaultAudioLanguage(@as(*const IWMPSettings2, @ptrCast(self)), plLangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings2_get_mediaAccessRights(self: *const T, pbstrRights: ?*?BSTR) HRESULT {
                return @as(*const IWMPSettings2.VTable, @ptrCast(self.vtable)).get_mediaAccessRights(@as(*const IWMPSettings2, @ptrCast(self)), pbstrRights);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSettings2_requestMediaAccessRights(self: *const T, bstrDesiredAccess: ?BSTR, pvbAccepted: ?*i16) HRESULT {
                return @as(*const IWMPSettings2.VTable, @ptrCast(self.vtable)).requestMediaAccessRights(@as(*const IWMPSettings2, @ptrCast(self)), bstrDesiredAccess, pvbAccepted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPControls3_Value = Guid.initString("a1d1110e-d545-476a-9a78-ac3e4cb1e6bd");
pub const IID_IWMPControls3 = &IID_IWMPControls3_Value;
pub const IWMPControls3 = extern struct {
    pub const VTable = extern struct {
        base: IWMPControls2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_audioLanguageCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAudioLanguageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls3,
                lIndex: i32,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls3,
                lIndex: i32,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAudioLanguageDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls3,
                lIndex: i32,
                pbstrLangDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls3,
                lIndex: i32,
                pbstrLangDesc: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentAudioLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentAudioLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                lLangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                lLangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentAudioLanguageIndex: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentAudioLanguageIndex: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                lIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                lIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getLanguageName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPControls3,
                lLangID: i32,
                pbstrLangName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPControls3,
                lLangID: i32,
                pbstrLangName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentPositionTimecode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                bstrTimecode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                bstrTimecode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_currentPositionTimecode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPControls3,
                bstrTimecode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPControls3,
                bstrTimecode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPControls2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_get_audioLanguageCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).get_audioLanguageCount(@as(*const IWMPControls3, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_getAudioLanguageID(self: *const T, lIndex: i32, plLangID: ?*i32) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).getAudioLanguageID(@as(*const IWMPControls3, @ptrCast(self)), lIndex, plLangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_getAudioLanguageDescription(self: *const T, lIndex: i32, pbstrLangDesc: ?*?BSTR) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).getAudioLanguageDescription(@as(*const IWMPControls3, @ptrCast(self)), lIndex, pbstrLangDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_get_currentAudioLanguage(self: *const T, plLangID: ?*i32) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).get_currentAudioLanguage(@as(*const IWMPControls3, @ptrCast(self)), plLangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_put_currentAudioLanguage(self: *const T, lLangID: i32) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).put_currentAudioLanguage(@as(*const IWMPControls3, @ptrCast(self)), lLangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_get_currentAudioLanguageIndex(self: *const T, plIndex: ?*i32) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).get_currentAudioLanguageIndex(@as(*const IWMPControls3, @ptrCast(self)), plIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_put_currentAudioLanguageIndex(self: *const T, lIndex: i32) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).put_currentAudioLanguageIndex(@as(*const IWMPControls3, @ptrCast(self)), lIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_getLanguageName(self: *const T, lLangID: i32, pbstrLangName: ?*?BSTR) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).getLanguageName(@as(*const IWMPControls3, @ptrCast(self)), lLangID, pbstrLangName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_get_currentPositionTimecode(self: *const T, bstrTimecode: ?*?BSTR) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).get_currentPositionTimecode(@as(*const IWMPControls3, @ptrCast(self)), bstrTimecode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPControls3_put_currentPositionTimecode(self: *const T, bstrTimecode: ?BSTR) HRESULT {
                return @as(*const IWMPControls3.VTable, @ptrCast(self.vtable)).put_currentPositionTimecode(@as(*const IWMPControls3, @ptrCast(self)), bstrTimecode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPClosedCaption2_Value = Guid.initString("350ba78b-6bc8-4113-a5f5-312056934eb6");
pub const IID_IWMPClosedCaption2 = &IID_IWMPClosedCaption2_Value;
pub const IWMPClosedCaption2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPClosedCaption.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAMILangCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption2,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption2,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getSAMILangName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPClosedCaption2,
                nIndex: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPClosedCaption2,
                nIndex: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getSAMILangID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPClosedCaption2,
                nIndex: i32,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPClosedCaption2,
                nIndex: i32,
                plLangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAMIStyleCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPClosedCaption2,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPClosedCaption2,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getSAMIStyleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPClosedCaption2,
                nIndex: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPClosedCaption2,
                nIndex: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPClosedCaption.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption2_get_SAMILangCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPClosedCaption2.VTable, @ptrCast(self.vtable)).get_SAMILangCount(@as(*const IWMPClosedCaption2, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption2_getSAMILangName(self: *const T, nIndex: i32, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption2.VTable, @ptrCast(self.vtable)).getSAMILangName(@as(*const IWMPClosedCaption2, @ptrCast(self)), nIndex, pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption2_getSAMILangID(self: *const T, nIndex: i32, plLangID: ?*i32) HRESULT {
                return @as(*const IWMPClosedCaption2.VTable, @ptrCast(self.vtable)).getSAMILangID(@as(*const IWMPClosedCaption2, @ptrCast(self)), nIndex, plLangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption2_get_SAMIStyleCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPClosedCaption2.VTable, @ptrCast(self.vtable)).get_SAMIStyleCount(@as(*const IWMPClosedCaption2, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPClosedCaption2_getSAMIStyleName(self: *const T, nIndex: i32, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPClosedCaption2.VTable, @ptrCast(self.vtable)).getSAMIStyleName(@as(*const IWMPClosedCaption2, @ptrCast(self)), nIndex, pbstrName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayerApplication_Value = Guid.initString("40897764-ceab-47be-ad4a-8e28537f9bbf");
pub const IID_IWMPPlayerApplication = &IID_IWMPPlayerApplication_Value;
pub const IWMPPlayerApplication = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        switchToPlayerApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayerApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayerApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        switchToControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayerApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayerApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playerDocked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayerApplication,
                pbPlayerDocked: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayerApplication,
                pbPlayerDocked: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_hasDisplay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayerApplication,
                pbHasDisplay: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayerApplication,
                pbHasDisplay: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerApplication_switchToPlayerApplication(self: *const T) HRESULT {
                return @as(*const IWMPPlayerApplication.VTable, @ptrCast(self.vtable)).switchToPlayerApplication(@as(*const IWMPPlayerApplication, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerApplication_switchToControl(self: *const T) HRESULT {
                return @as(*const IWMPPlayerApplication.VTable, @ptrCast(self.vtable)).switchToControl(@as(*const IWMPPlayerApplication, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerApplication_get_playerDocked(self: *const T, pbPlayerDocked: ?*i16) HRESULT {
                return @as(*const IWMPPlayerApplication.VTable, @ptrCast(self.vtable)).get_playerDocked(@as(*const IWMPPlayerApplication, @ptrCast(self)), pbPlayerDocked);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerApplication_get_hasDisplay(self: *const T, pbHasDisplay: ?*i16) HRESULT {
                return @as(*const IWMPPlayerApplication.VTable, @ptrCast(self.vtable)).get_hasDisplay(@as(*const IWMPPlayerApplication, @ptrCast(self)), pbHasDisplay);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPCore3_Value = Guid.initString("7587c667-628f-499f-88e7-6a6f4e888464");
pub const IID_IWMPCore3 = &IID_IWMPCore3_Value;
pub const IWMPCore3 = extern struct {
    pub const VTable = extern struct {
        base: IWMPCore2.VTable,
        newPlaylist: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCore3,
                bstrName: ?BSTR,
                bstrURL: ?BSTR,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCore3,
                bstrName: ?BSTR,
                bstrURL: ?BSTR,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        newMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCore3,
                bstrURL: ?BSTR,
                ppMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCore3,
                bstrURL: ?BSTR,
                ppMedia: ?*?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPCore2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore3_newPlaylist(self: *const T, bstrName: ?BSTR, bstrURL: ?BSTR, ppPlaylist: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPCore3.VTable, @ptrCast(self.vtable)).newPlaylist(@as(*const IWMPCore3, @ptrCast(self)), bstrName, bstrURL, ppPlaylist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCore3_newMedia(self: *const T, bstrURL: ?BSTR, ppMedia: ?*?*IWMPMedia) HRESULT {
                return @as(*const IWMPCore3.VTable, @ptrCast(self.vtable)).newMedia(@as(*const IWMPCore3, @ptrCast(self)), bstrURL, ppMedia);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayer4_Value = Guid.initString("6c497d62-8919-413c-82db-e935fb3ec584");
pub const IID_IWMPPlayer4 = &IID_IWMPPlayer4_Value;
pub const IWMPPlayer4 = extern struct {
    pub const VTable = extern struct {
        base: IWMPCore3.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pbFullScreen: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_fullScreen: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                bFullScreen: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pbEnableContextMenu: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enableContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                bEnableContextMenu: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                bstrMode: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_uiMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pbstrMode: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_stretchToFit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_stretchToFit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_windowlessVideo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_windowlessVideo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                bEnabled: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_isRemote: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                pvarfIsRemote: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                pvarfIsRemote: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_playerApplication: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPPlayer4,
                ppIWMPPlayerApplication: ?*?*IWMPPlayerApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPPlayer4,
                ppIWMPPlayerApplication: ?*?*IWMPPlayerApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        openPlayer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayer4,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayer4,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPCore3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_enabled(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_enabled(@as(*const IWMPPlayer4, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_put_enabled(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).put_enabled(@as(*const IWMPPlayer4, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_fullScreen(self: *const T, pbFullScreen: ?*i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_fullScreen(@as(*const IWMPPlayer4, @ptrCast(self)), pbFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_put_fullScreen(self: *const T, bFullScreen: i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).put_fullScreen(@as(*const IWMPPlayer4, @ptrCast(self)), bFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_enableContextMenu(self: *const T, pbEnableContextMenu: ?*i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_enableContextMenu(@as(*const IWMPPlayer4, @ptrCast(self)), pbEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_put_enableContextMenu(self: *const T, bEnableContextMenu: i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).put_enableContextMenu(@as(*const IWMPPlayer4, @ptrCast(self)), bEnableContextMenu);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_put_uiMode(self: *const T, bstrMode: ?BSTR) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).put_uiMode(@as(*const IWMPPlayer4, @ptrCast(self)), bstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_uiMode(self: *const T, pbstrMode: ?*?BSTR) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_uiMode(@as(*const IWMPPlayer4, @ptrCast(self)), pbstrMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_stretchToFit(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_stretchToFit(@as(*const IWMPPlayer4, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_put_stretchToFit(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).put_stretchToFit(@as(*const IWMPPlayer4, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_windowlessVideo(self: *const T, pbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_windowlessVideo(@as(*const IWMPPlayer4, @ptrCast(self)), pbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_put_windowlessVideo(self: *const T, bEnabled: i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).put_windowlessVideo(@as(*const IWMPPlayer4, @ptrCast(self)), bEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_isRemote(self: *const T, pvarfIsRemote: ?*i16) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_isRemote(@as(*const IWMPPlayer4, @ptrCast(self)), pvarfIsRemote);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_get_playerApplication(self: *const T, ppIWMPPlayerApplication: ?*?*IWMPPlayerApplication) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).get_playerApplication(@as(*const IWMPPlayer4, @ptrCast(self)), ppIWMPPlayerApplication);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayer4_openPlayer(self: *const T, bstrURL: ?BSTR) HRESULT {
                return @as(*const IWMPPlayer4.VTable, @ptrCast(self.vtable)).openPlayer(@as(*const IWMPPlayer4, @ptrCast(self)), bstrURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayerServices_Value = Guid.initString("1d01fbdb-ade2-4c8d-9842-c190b95c3306");
pub const IID_IWMPPlayerServices = &IID_IWMPPlayerServices_Value;
pub const IWMPPlayerServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        activateUIPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayerServices,
                bstrPlugin: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayerServices,
                bstrPlugin: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setTaskPane: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayerServices,
                bstrTaskPane: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayerServices,
                bstrTaskPane: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setTaskPaneURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayerServices,
                bstrTaskPane: ?BSTR,
                bstrURL: ?BSTR,
                bstrFriendlyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayerServices,
                bstrTaskPane: ?BSTR,
                bstrURL: ?BSTR,
                bstrFriendlyName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerServices_activateUIPlugin(self: *const T, bstrPlugin: ?BSTR) HRESULT {
                return @as(*const IWMPPlayerServices.VTable, @ptrCast(self.vtable)).activateUIPlugin(@as(*const IWMPPlayerServices, @ptrCast(self)), bstrPlugin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerServices_setTaskPane(self: *const T, bstrTaskPane: ?BSTR) HRESULT {
                return @as(*const IWMPPlayerServices.VTable, @ptrCast(self.vtable)).setTaskPane(@as(*const IWMPPlayerServices, @ptrCast(self)), bstrTaskPane);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerServices_setTaskPaneURL(self: *const T, bstrTaskPane: ?BSTR, bstrURL: ?BSTR, bstrFriendlyName: ?BSTR) HRESULT {
                return @as(*const IWMPPlayerServices.VTable, @ptrCast(self.vtable)).setTaskPaneURL(@as(*const IWMPPlayerServices, @ptrCast(self)), bstrTaskPane, bstrURL, bstrFriendlyName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPSyncState = enum(i32) {
    Unknown = 0,
    Synchronizing = 1,
    Stopped = 2,
    Estimating = 3,
    Last = 4,
};
pub const wmpssUnknown = WMPSyncState.Unknown;
pub const wmpssSynchronizing = WMPSyncState.Synchronizing;
pub const wmpssStopped = WMPSyncState.Stopped;
pub const wmpssEstimating = WMPSyncState.Estimating;
pub const wmpssLast = WMPSyncState.Last;

pub const WMPDeviceStatus = enum(i32) {
    Unknown = 0,
    PartnershipExists = 1,
    PartnershipDeclined = 2,
    PartnershipAnother = 3,
    ManualDevice = 4,
    NewDevice = 5,
    Last = 6,
};
pub const wmpdsUnknown = WMPDeviceStatus.Unknown;
pub const wmpdsPartnershipExists = WMPDeviceStatus.PartnershipExists;
pub const wmpdsPartnershipDeclined = WMPDeviceStatus.PartnershipDeclined;
pub const wmpdsPartnershipAnother = WMPDeviceStatus.PartnershipAnother;
pub const wmpdsManualDevice = WMPDeviceStatus.ManualDevice;
pub const wmpdsNewDevice = WMPDeviceStatus.NewDevice;
pub const wmpdsLast = WMPDeviceStatus.Last;

const IID_IWMPSyncDevice_Value = Guid.initString("82a2986c-0293-4fd0-b279-b21b86c058be");
pub const IID_IWMPSyncDevice = &IID_IWMPSyncDevice_Value;
pub const IWMPSyncDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_friendlyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_friendlyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deviceName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deviceId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pbstrDeviceId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                pbstrDeviceId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_partnershipIndex: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_connected: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pvbConnected: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                pvbConnected: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pwmpds: ?*WMPDeviceStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                pwmpds: ?*WMPDeviceStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_syncState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pwmpss: ?*WMPSyncState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                pwmpss: ?*WMPSyncState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_progress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncDevice,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createPartnership: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                vbShowUI: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
                vbShowUI: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        deletePartnership: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        showSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isIdentical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice,
                pDevice: ?*IWMPSyncDevice,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice,
                pDevice: ?*IWMPSyncDevice,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_friendlyName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_friendlyName(@as(*const IWMPSyncDevice, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_put_friendlyName(self: *const T, bstrName: ?BSTR) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).put_friendlyName(@as(*const IWMPSyncDevice, @ptrCast(self)), bstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_deviceName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_deviceName(@as(*const IWMPSyncDevice, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_deviceId(self: *const T, pbstrDeviceId: ?*?BSTR) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_deviceId(@as(*const IWMPSyncDevice, @ptrCast(self)), pbstrDeviceId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_partnershipIndex(self: *const T, plIndex: ?*i32) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_partnershipIndex(@as(*const IWMPSyncDevice, @ptrCast(self)), plIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_connected(self: *const T, pvbConnected: ?*i16) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_connected(@as(*const IWMPSyncDevice, @ptrCast(self)), pvbConnected);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_status(self: *const T, pwmpds: ?*WMPDeviceStatus) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_status(@as(*const IWMPSyncDevice, @ptrCast(self)), pwmpds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_syncState(self: *const T, pwmpss: ?*WMPSyncState) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_syncState(@as(*const IWMPSyncDevice, @ptrCast(self)), pwmpss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_get_progress(self: *const T, plProgress: ?*i32) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).get_progress(@as(*const IWMPSyncDevice, @ptrCast(self)), plProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_getItemInfo(self: *const T, bstrItemName: ?BSTR, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPSyncDevice, @ptrCast(self)), bstrItemName, pbstrVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_createPartnership(self: *const T, vbShowUI: i16) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).createPartnership(@as(*const IWMPSyncDevice, @ptrCast(self)), vbShowUI);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_deletePartnership(self: *const T) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).deletePartnership(@as(*const IWMPSyncDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_start(self: *const T) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).start(@as(*const IWMPSyncDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_stop(self: *const T) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).stop(@as(*const IWMPSyncDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_showSettings(self: *const T) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).showSettings(@as(*const IWMPSyncDevice, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice_isIdentical(self: *const T, pDevice: ?*IWMPSyncDevice, pvbool: ?*i16) HRESULT {
                return @as(*const IWMPSyncDevice.VTable, @ptrCast(self.vtable)).isIdentical(@as(*const IWMPSyncDevice, @ptrCast(self)), pDevice, pvbool);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSyncServices_Value = Guid.initString("8b5050ff-e0a4-4808-b3a8-893a9e1ed894");
pub const IID_IWMPSyncServices = &IID_IWMPSyncServices_Value;
pub const IWMPSyncServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_deviceCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPSyncServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPSyncServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncServices,
                lIndex: i32,
                ppDevice: ?*?*IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncServices,
                lIndex: i32,
                ppDevice: ?*?*IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncServices_get_deviceCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPSyncServices.VTable, @ptrCast(self.vtable)).get_deviceCount(@as(*const IWMPSyncServices, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncServices_getDevice(self: *const T, lIndex: i32, ppDevice: ?*?*IWMPSyncDevice) HRESULT {
                return @as(*const IWMPSyncServices.VTable, @ptrCast(self.vtable)).getDevice(@as(*const IWMPSyncServices, @ptrCast(self)), lIndex, ppDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPlayerServices2_Value = Guid.initString("1bb1592f-f040-418a-9f71-17c7512b4d70");
pub const IID_IWMPPlayerServices2 = &IID_IWMPPlayerServices2_Value;
pub const IWMPPlayerServices2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPPlayerServices.VTable,
        setBackgroundProcessingPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlayerServices2,
                bstrPriority: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlayerServices2,
                bstrPriority: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPPlayerServices.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlayerServices2_setBackgroundProcessingPriority(self: *const T, bstrPriority: ?BSTR) HRESULT {
                return @as(*const IWMPPlayerServices2.VTable, @ptrCast(self.vtable)).setBackgroundProcessingPriority(@as(*const IWMPPlayerServices2, @ptrCast(self)), bstrPriority);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPRipState = enum(i32) {
    Unknown = 0,
    Ripping = 1,
    Stopped = 2,
};
pub const wmprsUnknown = WMPRipState.Unknown;
pub const wmprsRipping = WMPRipState.Ripping;
pub const wmprsStopped = WMPRipState.Stopped;

pub const WMPBurnFormat = enum(i32) {
    AudioCD = 0,
    DataCD = 1,
};
pub const wmpbfAudioCD = WMPBurnFormat.AudioCD;
pub const wmpbfDataCD = WMPBurnFormat.DataCD;

pub const WMPBurnState = enum(i32) {
    Unknown = 0,
    Busy = 1,
    Ready = 2,
    WaitingForDisc = 3,
    RefreshStatusPending = 4,
    PreparingToBurn = 5,
    Burning = 6,
    Stopped = 7,
    Erasing = 8,
    Downloading = 9,
};
pub const wmpbsUnknown = WMPBurnState.Unknown;
pub const wmpbsBusy = WMPBurnState.Busy;
pub const wmpbsReady = WMPBurnState.Ready;
pub const wmpbsWaitingForDisc = WMPBurnState.WaitingForDisc;
pub const wmpbsRefreshStatusPending = WMPBurnState.RefreshStatusPending;
pub const wmpbsPreparingToBurn = WMPBurnState.PreparingToBurn;
pub const wmpbsBurning = WMPBurnState.Burning;
pub const wmpbsStopped = WMPBurnState.Stopped;
pub const wmpbsErasing = WMPBurnState.Erasing;
pub const wmpbsDownloading = WMPBurnState.Downloading;

pub const WMPStringCollectionChangeEventType = enum(i32) {
    Unknown = 0,
    Insert = 1,
    Change = 2,
    Delete = 3,
    Clear = 4,
    BeginUpdates = 5,
    EndUpdates = 6,
};
pub const wmpsccetUnknown = WMPStringCollectionChangeEventType.Unknown;
pub const wmpsccetInsert = WMPStringCollectionChangeEventType.Insert;
pub const wmpsccetChange = WMPStringCollectionChangeEventType.Change;
pub const wmpsccetDelete = WMPStringCollectionChangeEventType.Delete;
pub const wmpsccetClear = WMPStringCollectionChangeEventType.Clear;
pub const wmpsccetBeginUpdates = WMPStringCollectionChangeEventType.BeginUpdates;
pub const wmpsccetEndUpdates = WMPStringCollectionChangeEventType.EndUpdates;

const IID_IWMPCdromRip_Value = Guid.initString("56e2294f-69ed-4629-a869-aea72c0dcc2c");
pub const IID_IWMPCdromRip = &IID_IWMPCdromRip_Value;
pub const IWMPCdromRip = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ripState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromRip,
                pwmprs: ?*WMPRipState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromRip,
                pwmprs: ?*WMPRipState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ripProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromRip,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromRip,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startRip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromRip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromRip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        stopRip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromRip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromRip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromRip_get_ripState(self: *const T, pwmprs: ?*WMPRipState) HRESULT {
                return @as(*const IWMPCdromRip.VTable, @ptrCast(self.vtable)).get_ripState(@as(*const IWMPCdromRip, @ptrCast(self)), pwmprs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromRip_get_ripProgress(self: *const T, plProgress: ?*i32) HRESULT {
                return @as(*const IWMPCdromRip.VTable, @ptrCast(self.vtable)).get_ripProgress(@as(*const IWMPCdromRip, @ptrCast(self)), plProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromRip_startRip(self: *const T) HRESULT {
                return @as(*const IWMPCdromRip.VTable, @ptrCast(self.vtable)).startRip(@as(*const IWMPCdromRip, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromRip_stopRip(self: *const T) HRESULT {
                return @as(*const IWMPCdromRip.VTable, @ptrCast(self.vtable)).stopRip(@as(*const IWMPCdromRip, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPCdromBurn_Value = Guid.initString("bd94dbeb-417f-4928-aa06-087d56ed9b59");
pub const IID_IWMPCdromBurn = &IID_IWMPCdromBurn_Value;
pub const IWMPCdromBurn = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        isAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromBurn,
                bstrItem: ?BSTR,
                pIsAvailable: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                bstrItem: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromBurn,
                bstrItem: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_label: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                pbstrLabel: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                pbstrLabel: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_label: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                bstrLabel: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                bstrLabel: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_burnFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                pwmpbf: ?*WMPBurnFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                pwmpbf: ?*WMPBurnFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_burnFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                wmpbf: WMPBurnFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                wmpbf: WMPBurnFormat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_burnPlaylist: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_burnPlaylist: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                pPlaylist: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                pPlaylist: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        refreshStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_burnState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                pwmpbs: ?*WMPBurnState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                pwmpbs: ?*WMPBurnState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_burnProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPCdromBurn,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPCdromBurn,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startBurn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        stopBurn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        erase: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPCdromBurn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_isAvailable(self: *const T, bstrItem: ?BSTR, pIsAvailable: ?*i16) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).isAvailable(@as(*const IWMPCdromBurn, @ptrCast(self)), bstrItem, pIsAvailable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_getItemInfo(self: *const T, bstrItem: ?BSTR, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPCdromBurn, @ptrCast(self)), bstrItem, pbstrVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_get_label(self: *const T, pbstrLabel: ?*?BSTR) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).get_label(@as(*const IWMPCdromBurn, @ptrCast(self)), pbstrLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_put_label(self: *const T, bstrLabel: ?BSTR) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).put_label(@as(*const IWMPCdromBurn, @ptrCast(self)), bstrLabel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_get_burnFormat(self: *const T, pwmpbf: ?*WMPBurnFormat) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).get_burnFormat(@as(*const IWMPCdromBurn, @ptrCast(self)), pwmpbf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_put_burnFormat(self: *const T, wmpbf: WMPBurnFormat) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).put_burnFormat(@as(*const IWMPCdromBurn, @ptrCast(self)), wmpbf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_get_burnPlaylist(self: *const T, ppPlaylist: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).get_burnPlaylist(@as(*const IWMPCdromBurn, @ptrCast(self)), ppPlaylist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_put_burnPlaylist(self: *const T, pPlaylist: ?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).put_burnPlaylist(@as(*const IWMPCdromBurn, @ptrCast(self)), pPlaylist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_refreshStatus(self: *const T) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).refreshStatus(@as(*const IWMPCdromBurn, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_get_burnState(self: *const T, pwmpbs: ?*WMPBurnState) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).get_burnState(@as(*const IWMPCdromBurn, @ptrCast(self)), pwmpbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_get_burnProgress(self: *const T, plProgress: ?*i32) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).get_burnProgress(@as(*const IWMPCdromBurn, @ptrCast(self)), plProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_startBurn(self: *const T) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).startBurn(@as(*const IWMPCdromBurn, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_stopBurn(self: *const T) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).stopBurn(@as(*const IWMPCdromBurn, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPCdromBurn_erase(self: *const T) HRESULT {
                return @as(*const IWMPCdromBurn.VTable, @ptrCast(self.vtable)).erase(@as(*const IWMPCdromBurn, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPQuery_Value = Guid.initString("a00918f3-a6b0-4bfb-9189-fd834c7bc5a5");
pub const IID_IWMPQuery = &IID_IWMPQuery_Value;
pub const IWMPQuery = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addCondition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPQuery,
                bstrAttribute: ?BSTR,
                bstrOperator: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPQuery,
                bstrAttribute: ?BSTR,
                bstrOperator: ?BSTR,
                bstrValue: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        beginNextGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPQuery_addCondition(self: *const T, bstrAttribute: ?BSTR, bstrOperator: ?BSTR, bstrValue: ?BSTR) HRESULT {
                return @as(*const IWMPQuery.VTable, @ptrCast(self.vtable)).addCondition(@as(*const IWMPQuery, @ptrCast(self)), bstrAttribute, bstrOperator, bstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPQuery_beginNextGroup(self: *const T) HRESULT {
                return @as(*const IWMPQuery.VTable, @ptrCast(self.vtable)).beginNextGroup(@as(*const IWMPQuery, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMediaCollection2_Value = Guid.initString("8ba957f5-fd8c-4791-b82d-f840401ee474");
pub const IID_IWMPMediaCollection2 = &IID_IWMPMediaCollection2_Value;
pub const IWMPMediaCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPMediaCollection.VTable,
        createQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection2,
                ppQuery: ?*?*IWMPQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection2,
                ppQuery: ?*?*IWMPQuery,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getPlaylistByQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection2,
                pQuery: ?*IWMPQuery,
                bstrMediaType: ?BSTR,
                bstrSortAttribute: ?BSTR,
                fSortAscending: i16,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection2,
                pQuery: ?*IWMPQuery,
                bstrMediaType: ?BSTR,
                bstrSortAttribute: ?BSTR,
                fSortAscending: i16,
                ppPlaylist: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getStringCollectionByQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection2,
                bstrAttribute: ?BSTR,
                pQuery: ?*IWMPQuery,
                bstrMediaType: ?BSTR,
                bstrSortAttribute: ?BSTR,
                fSortAscending: i16,
                ppStringCollection: ?*?*IWMPStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection2,
                bstrAttribute: ?BSTR,
                pQuery: ?*IWMPQuery,
                bstrMediaType: ?BSTR,
                bstrSortAttribute: ?BSTR,
                fSortAscending: i16,
                ppStringCollection: ?*?*IWMPStringCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getByAttributeAndMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaCollection2,
                bstrAttribute: ?BSTR,
                bstrValue: ?BSTR,
                bstrMediaType: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaCollection2,
                bstrAttribute: ?BSTR,
                bstrValue: ?BSTR,
                bstrMediaType: ?BSTR,
                ppMediaItems: ?*?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPMediaCollection.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection2_createQuery(self: *const T, ppQuery: ?*?*IWMPQuery) HRESULT {
                return @as(*const IWMPMediaCollection2.VTable, @ptrCast(self.vtable)).createQuery(@as(*const IWMPMediaCollection2, @ptrCast(self)), ppQuery);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection2_getPlaylistByQuery(self: *const T, pQuery: ?*IWMPQuery, bstrMediaType: ?BSTR, bstrSortAttribute: ?BSTR, fSortAscending: i16, ppPlaylist: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection2.VTable, @ptrCast(self.vtable)).getPlaylistByQuery(@as(*const IWMPMediaCollection2, @ptrCast(self)), pQuery, bstrMediaType, bstrSortAttribute, fSortAscending, ppPlaylist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection2_getStringCollectionByQuery(self: *const T, bstrAttribute: ?BSTR, pQuery: ?*IWMPQuery, bstrMediaType: ?BSTR, bstrSortAttribute: ?BSTR, fSortAscending: i16, ppStringCollection: ?*?*IWMPStringCollection) HRESULT {
                return @as(*const IWMPMediaCollection2.VTable, @ptrCast(self.vtable)).getStringCollectionByQuery(@as(*const IWMPMediaCollection2, @ptrCast(self)), bstrAttribute, pQuery, bstrMediaType, bstrSortAttribute, fSortAscending, ppStringCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaCollection2_getByAttributeAndMediaType(self: *const T, bstrAttribute: ?BSTR, bstrValue: ?BSTR, bstrMediaType: ?BSTR, ppMediaItems: ?*?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPMediaCollection2.VTable, @ptrCast(self.vtable)).getByAttributeAndMediaType(@as(*const IWMPMediaCollection2, @ptrCast(self)), bstrAttribute, bstrValue, bstrMediaType, ppMediaItems);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPStringCollection2_Value = Guid.initString("46ad648d-53f1-4a74-92e2-2a1b68d63fd4");
pub const IID_IWMPStringCollection2 = &IID_IWMPStringCollection2_Value;
pub const IWMPStringCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPStringCollection.VTable,
        isIdentical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPStringCollection2,
                pIWMPStringCollection2: ?*IWMPStringCollection2,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPStringCollection2,
                pIWMPStringCollection2: ?*IWMPStringCollection2,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPStringCollection2,
                lCollectionIndex: i32,
                bstrItemName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPStringCollection2,
                lCollectionIndex: i32,
                bstrItemName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttributeCountByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPStringCollection2,
                lCollectionIndex: i32,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPStringCollection2,
                lCollectionIndex: i32,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getItemInfoByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPStringCollection2,
                lCollectionIndex: i32,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                lAttributeIndex: i32,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPStringCollection2,
                lCollectionIndex: i32,
                bstrType: ?BSTR,
                bstrLanguage: ?BSTR,
                lAttributeIndex: i32,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPStringCollection.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPStringCollection2_isIdentical(self: *const T, pIWMPStringCollection2: ?*IWMPStringCollection2, pvbool: ?*i16) HRESULT {
                return @as(*const IWMPStringCollection2.VTable, @ptrCast(self.vtable)).isIdentical(@as(*const IWMPStringCollection2, @ptrCast(self)), pIWMPStringCollection2, pvbool);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPStringCollection2_getItemInfo(self: *const T, lCollectionIndex: i32, bstrItemName: ?BSTR, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IWMPStringCollection2.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPStringCollection2, @ptrCast(self)), lCollectionIndex, bstrItemName, pbstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPStringCollection2_getAttributeCountByType(self: *const T, lCollectionIndex: i32, bstrType: ?BSTR, bstrLanguage: ?BSTR, plCount: ?*i32) HRESULT {
                return @as(*const IWMPStringCollection2.VTable, @ptrCast(self.vtable)).getAttributeCountByType(@as(*const IWMPStringCollection2, @ptrCast(self)), lCollectionIndex, bstrType, bstrLanguage, plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPStringCollection2_getItemInfoByType(self: *const T, lCollectionIndex: i32, bstrType: ?BSTR, bstrLanguage: ?BSTR, lAttributeIndex: i32, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const IWMPStringCollection2.VTable, @ptrCast(self.vtable)).getItemInfoByType(@as(*const IWMPStringCollection2, @ptrCast(self)), lCollectionIndex, bstrType, bstrLanguage, lAttributeIndex, pvarValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPLibraryType = enum(i32) {
    Unknown = 0,
    All = 1,
    Local = 2,
    Remote = 3,
    Disc = 4,
    PortableDevice = 5,
};
pub const wmpltUnknown = WMPLibraryType.Unknown;
pub const wmpltAll = WMPLibraryType.All;
pub const wmpltLocal = WMPLibraryType.Local;
pub const wmpltRemote = WMPLibraryType.Remote;
pub const wmpltDisc = WMPLibraryType.Disc;
pub const wmpltPortableDevice = WMPLibraryType.PortableDevice;

const IID_IWMPLibrary_Value = Guid.initString("3df47861-7df1-4c1f-a81b-4c26f0f7a7c6");
pub const IID_IWMPLibrary = &IID_IWMPLibrary_Value;
pub const IWMPLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPLibrary,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPLibrary,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPLibrary,
                pwmplt: ?*WMPLibraryType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPLibrary,
                pwmplt: ?*WMPLibraryType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_mediaCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPLibrary,
                ppIWMPMediaCollection: ?*?*IWMPMediaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPLibrary,
                ppIWMPMediaCollection: ?*?*IWMPMediaCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isIdentical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibrary,
                pIWMPLibrary: ?*IWMPLibrary,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibrary,
                pIWMPLibrary: ?*IWMPLibrary,
                pvbool: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrary_get_name(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IWMPLibrary.VTable, @ptrCast(self.vtable)).get_name(@as(*const IWMPLibrary, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrary_get_type(self: *const T, pwmplt: ?*WMPLibraryType) HRESULT {
                return @as(*const IWMPLibrary.VTable, @ptrCast(self.vtable)).get_type(@as(*const IWMPLibrary, @ptrCast(self)), pwmplt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrary_get_mediaCollection(self: *const T, ppIWMPMediaCollection: ?*?*IWMPMediaCollection) HRESULT {
                return @as(*const IWMPLibrary.VTable, @ptrCast(self.vtable)).get_mediaCollection(@as(*const IWMPLibrary, @ptrCast(self)), ppIWMPMediaCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrary_isIdentical(self: *const T, pIWMPLibrary: ?*IWMPLibrary, pvbool: ?*i16) HRESULT {
                return @as(*const IWMPLibrary.VTable, @ptrCast(self.vtable)).isIdentical(@as(*const IWMPLibrary, @ptrCast(self)), pIWMPLibrary, pvbool);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPLibraryServices_Value = Guid.initString("39c2f8d5-1cf2-4d5e-ae09-d73492cf9eaa");
pub const IID_IWMPLibraryServices = &IID_IWMPLibraryServices_Value;
pub const IWMPLibraryServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        getCountByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibraryServices,
                wmplt: WMPLibraryType,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibraryServices,
                wmplt: WMPLibraryType,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getLibraryByType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibraryServices,
                wmplt: WMPLibraryType,
                lIndex: i32,
                ppIWMPLibrary: ?*?*IWMPLibrary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibraryServices,
                wmplt: WMPLibraryType,
                lIndex: i32,
                ppIWMPLibrary: ?*?*IWMPLibrary,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibraryServices_getCountByType(self: *const T, wmplt: WMPLibraryType, plCount: ?*i32) HRESULT {
                return @as(*const IWMPLibraryServices.VTable, @ptrCast(self.vtable)).getCountByType(@as(*const IWMPLibraryServices, @ptrCast(self)), wmplt, plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibraryServices_getLibraryByType(self: *const T, wmplt: WMPLibraryType, lIndex: i32, ppIWMPLibrary: ?*?*IWMPLibrary) HRESULT {
                return @as(*const IWMPLibraryServices.VTable, @ptrCast(self.vtable)).getLibraryByType(@as(*const IWMPLibraryServices, @ptrCast(self)), wmplt, lIndex, ppIWMPLibrary);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPLibrarySharingServices_Value = Guid.initString("82cba86b-9f04-474b-a365-d6dd1466e541");
pub const IID_IWMPLibrarySharingServices = &IID_IWMPLibrarySharingServices_Value;
pub const IWMPLibrarySharingServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        isLibraryShared: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibrarySharingServices,
                pvbShared: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibrarySharingServices,
                pvbShared: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isLibrarySharingEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibrarySharingServices,
                pvbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibrarySharingServices,
                pvbEnabled: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        showLibrarySharing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibrarySharingServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibrarySharingServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrarySharingServices_isLibraryShared(self: *const T, pvbShared: ?*i16) HRESULT {
                return @as(*const IWMPLibrarySharingServices.VTable, @ptrCast(self.vtable)).isLibraryShared(@as(*const IWMPLibrarySharingServices, @ptrCast(self)), pvbShared);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrarySharingServices_isLibrarySharingEnabled(self: *const T, pvbEnabled: ?*i16) HRESULT {
                return @as(*const IWMPLibrarySharingServices.VTable, @ptrCast(self.vtable)).isLibrarySharingEnabled(@as(*const IWMPLibrarySharingServices, @ptrCast(self)), pvbEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrarySharingServices_showLibrarySharing(self: *const T) HRESULT {
                return @as(*const IWMPLibrarySharingServices.VTable, @ptrCast(self.vtable)).showLibrarySharing(@as(*const IWMPLibrarySharingServices, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPFolderScanState = enum(i32) {
    Unknown = 0,
    Scanning = 1,
    Updating = 2,
    Stopped = 3,
};
pub const wmpfssUnknown = WMPFolderScanState.Unknown;
pub const wmpfssScanning = WMPFolderScanState.Scanning;
pub const wmpfssUpdating = WMPFolderScanState.Updating;
pub const wmpfssStopped = WMPFolderScanState.Stopped;

const IID_IWMPFolderMonitorServices_Value = Guid.initString("788c8743-e57f-439d-a468-5bc77f2e59c6");
pub const IID_IWMPFolderMonitorServices = &IID_IWMPFolderMonitorServices_Value;
pub const IWMPFolderMonitorServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                lIndex: i32,
                pbstrFolder: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                lIndex: i32,
                pbstrFolder: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        add: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                bstrFolder: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                bstrFolder: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                lIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                lIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scanState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                pwmpfss: ?*WMPFolderScanState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                pwmpfss: ?*WMPFolderScanState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_currentFolder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                pbstrFolder: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                pbstrFolder: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_scannedFilesCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_addedFilesCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_updateProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        stopScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPFolderMonitorServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPFolderMonitorServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_get_count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).get_count(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_item(self: *const T, lIndex: i32, pbstrFolder: ?*?BSTR) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).item(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), lIndex, pbstrFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_add(self: *const T, bstrFolder: ?BSTR) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).add(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), bstrFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_remove(self: *const T, lIndex: i32) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).remove(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), lIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_get_scanState(self: *const T, pwmpfss: ?*WMPFolderScanState) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).get_scanState(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), pwmpfss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_get_currentFolder(self: *const T, pbstrFolder: ?*?BSTR) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).get_currentFolder(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), pbstrFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_get_scannedFilesCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).get_scannedFilesCount(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_get_addedFilesCount(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).get_addedFilesCount(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_get_updateProgress(self: *const T, plProgress: ?*i32) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).get_updateProgress(@as(*const IWMPFolderMonitorServices, @ptrCast(self)), plProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_startScan(self: *const T) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).startScan(@as(*const IWMPFolderMonitorServices, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPFolderMonitorServices_stopScan(self: *const T) HRESULT {
                return @as(*const IWMPFolderMonitorServices.VTable, @ptrCast(self.vtable)).stopScan(@as(*const IWMPFolderMonitorServices, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSyncDevice2_Value = Guid.initString("88afb4b2-140a-44d2-91e6-4543da467cd1");
pub const IID_IWMPSyncDevice2 = &IID_IWMPSyncDevice2_Value;
pub const IWMPSyncDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPSyncDevice.VTable,
        setItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice2,
                bstrItemName: ?BSTR,
                bstrVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice2,
                bstrItemName: ?BSTR,
                bstrVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPSyncDevice.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice2_setItemInfo(self: *const T, bstrItemName: ?BSTR, bstrVal: ?BSTR) HRESULT {
                return @as(*const IWMPSyncDevice2.VTable, @ptrCast(self.vtable)).setItemInfo(@as(*const IWMPSyncDevice2, @ptrCast(self)), bstrItemName, bstrVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSyncDevice3_Value = Guid.initString("b22c85f9-263c-4372-a0da-b518db9b4098");
pub const IID_IWMPSyncDevice3 = &IID_IWMPSyncDevice3_Value;
pub const IWMPSyncDevice3 = extern struct {
    pub const VTable = extern struct {
        base: IWMPSyncDevice2.VTable,
        estimateSyncSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice3,
                pNonRulePlaylist: ?*IWMPPlaylist,
                pRulesPlaylist: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice3,
                pNonRulePlaylist: ?*IWMPPlaylist,
                pRulesPlaylist: ?*IWMPPlaylist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        cancelEstimation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSyncDevice3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSyncDevice3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPSyncDevice2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice3_estimateSyncSize(self: *const T, pNonRulePlaylist: ?*IWMPPlaylist, pRulesPlaylist: ?*IWMPPlaylist) HRESULT {
                return @as(*const IWMPSyncDevice3.VTable, @ptrCast(self.vtable)).estimateSyncSize(@as(*const IWMPSyncDevice3, @ptrCast(self)), pNonRulePlaylist, pRulesPlaylist);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSyncDevice3_cancelEstimation(self: *const T) HRESULT {
                return @as(*const IWMPSyncDevice3.VTable, @ptrCast(self.vtable)).cancelEstimation(@as(*const IWMPSyncDevice3, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPLibrary2_Value = Guid.initString("dd578a4e-79b1-426c-bf8f-3add9072500b");
pub const IID_IWMPLibrary2 = &IID_IWMPLibrary2_Value;
pub const IWMPLibrary2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPLibrary.VTable,
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPLibrary2,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPLibrary2,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPLibrary.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPLibrary2_getItemInfo(self: *const T, bstrItemName: ?BSTR, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPLibrary2.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPLibrary2, @ptrCast(self)), bstrItemName, pbstrVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_WMPLib_Value = Guid.initString("6bf52a50-394a-11d3-b153-00c04f79faa6");
pub const CLSID_WMPLib = &CLSID_WMPLib_Value;

const CLSID_WMPRemoteMediaServices_Value = Guid.initString("df333473-2cf7-4be2-907f-9aad5661364f");
pub const CLSID_WMPRemoteMediaServices = &CLSID_WMPRemoteMediaServices_Value;

const IID_IWMPEvents_Value = Guid.initString("19a6627b-da9e-47c1-bb23-00b5e668236a");
pub const IID_IWMPEvents = &IID_IWMPEvents_Value;
pub const IWMPEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                NewState: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                NewState: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlayStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                NewState: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                NewState: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        AudioLanguageChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                LangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                LangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        StatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ScriptCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                scType: ?BSTR,
                Param: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                scType: ?BSTR,
                Param: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        NewStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                Result: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                Result: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Buffering: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                Start: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                Start: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Warning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                WarningType: i32,
                Param: i32,
                Description: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                WarningType: i32,
                Param: i32,
                Description: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        EndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                Result: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                Result: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PositionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                oldPosition: f64,
                newPosition: f64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                oldPosition: f64,
                newPosition: f64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MarkerHit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                MarkerNum: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                MarkerNum: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DurationUnitChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                NewDurationUnit: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                NewDurationUnit: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CdromMediaChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                CdromNum: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                CdromNum: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlaylistChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                Playlist: ?*IDispatch,
                change: WMPPlaylistChangeEventType,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                Playlist: ?*IDispatch,
                change: WMPPlaylistChangeEventType,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CurrentPlaylistChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                change: WMPPlaylistChangeEventType,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                change: WMPPlaylistChangeEventType,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CurrentPlaylistItemAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrItemName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrItemName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                Item: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                Item: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CurrentMediaItemAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrItemName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrItemName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CurrentItemChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                pdispMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                pdispMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaCollectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaCollectionAttributeStringAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrAttribName: ?BSTR,
                bstrAttribVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrAttribName: ?BSTR,
                bstrAttribVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaCollectionAttributeStringRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrAttribName: ?BSTR,
                bstrAttribVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrAttribName: ?BSTR,
                bstrAttribVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaCollectionAttributeStringChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrAttribName: ?BSTR,
                bstrOldAttribVal: ?BSTR,
                bstrNewAttribVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrAttribName: ?BSTR,
                bstrOldAttribVal: ?BSTR,
                bstrNewAttribVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlaylistCollectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlaylistCollectionPlaylistAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrPlaylistName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrPlaylistName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlaylistCollectionPlaylistRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrPlaylistName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrPlaylistName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlaylistCollectionPlaylistSetAsDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                bstrPlaylistName: ?BSTR,
                varfIsDeleted: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                bstrPlaylistName: ?BSTR,
                varfIsDeleted: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ModeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                ModeName: ?BSTR,
                NewValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                ModeName: ?BSTR,
                NewValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                pMediaObject: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                pMediaObject: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OpenPlaylistSwitch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                pItem: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                pItem: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DomainChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                strDomain: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                strDomain: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SwitchedToPlayerApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SwitchedToControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlayerDockedStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PlayerReconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Click: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DoubleClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        KeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nKeyCode: i16,
                nShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nKeyCode: i16,
                nShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        KeyPress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nKeyAscii: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nKeyAscii: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        KeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nKeyCode: i16,
                nShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nKeyCode: i16,
                nShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MouseDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MouseMove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MouseUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents,
                nButton: i16,
                nShiftState: i16,
                fX: i32,
                fY: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_OpenStateChange(self: *const T, NewState: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).OpenStateChange(@as(*const IWMPEvents, @ptrCast(self)), NewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlayStateChange(self: *const T, NewState: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlayStateChange(@as(*const IWMPEvents, @ptrCast(self)), NewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_AudioLanguageChange(self: *const T, LangID: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).AudioLanguageChange(@as(*const IWMPEvents, @ptrCast(self)), LangID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_StatusChange(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).StatusChange(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_ScriptCommand(self: *const T, scType: ?BSTR, Param: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).ScriptCommand(@as(*const IWMPEvents, @ptrCast(self)), scType, Param);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_NewStream(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).NewStream(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_Disconnect(self: *const T, Result: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IWMPEvents, @ptrCast(self)), Result);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_Buffering(self: *const T, Start: i16) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).Buffering(@as(*const IWMPEvents, @ptrCast(self)), Start);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_Error(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).Error(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_Warning(self: *const T, WarningType: i32, Param: i32, Description: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).Warning(@as(*const IWMPEvents, @ptrCast(self)), WarningType, Param, Description);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_EndOfStream(self: *const T, Result: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).EndOfStream(@as(*const IWMPEvents, @ptrCast(self)), Result);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PositionChange(self: *const T, oldPosition: f64, newPosition: f64) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PositionChange(@as(*const IWMPEvents, @ptrCast(self)), oldPosition, newPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MarkerHit(self: *const T, MarkerNum: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MarkerHit(@as(*const IWMPEvents, @ptrCast(self)), MarkerNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_DurationUnitChange(self: *const T, NewDurationUnit: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).DurationUnitChange(@as(*const IWMPEvents, @ptrCast(self)), NewDurationUnit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_CdromMediaChange(self: *const T, CdromNum: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).CdromMediaChange(@as(*const IWMPEvents, @ptrCast(self)), CdromNum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlaylistChange(self: *const T, Playlist: ?*IDispatch, change: WMPPlaylistChangeEventType) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlaylistChange(@as(*const IWMPEvents, @ptrCast(self)), Playlist, change);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_CurrentPlaylistChange(self: *const T, change: WMPPlaylistChangeEventType) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).CurrentPlaylistChange(@as(*const IWMPEvents, @ptrCast(self)), change);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_CurrentPlaylistItemAvailable(self: *const T, bstrItemName: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).CurrentPlaylistItemAvailable(@as(*const IWMPEvents, @ptrCast(self)), bstrItemName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MediaChange(self: *const T, Item: ?*IDispatch) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MediaChange(@as(*const IWMPEvents, @ptrCast(self)), Item);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_CurrentMediaItemAvailable(self: *const T, bstrItemName: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).CurrentMediaItemAvailable(@as(*const IWMPEvents, @ptrCast(self)), bstrItemName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_CurrentItemChange(self: *const T, pdispMedia: ?*IDispatch) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).CurrentItemChange(@as(*const IWMPEvents, @ptrCast(self)), pdispMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MediaCollectionChange(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MediaCollectionChange(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MediaCollectionAttributeStringAdded(self: *const T, bstrAttribName: ?BSTR, bstrAttribVal: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MediaCollectionAttributeStringAdded(@as(*const IWMPEvents, @ptrCast(self)), bstrAttribName, bstrAttribVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MediaCollectionAttributeStringRemoved(self: *const T, bstrAttribName: ?BSTR, bstrAttribVal: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MediaCollectionAttributeStringRemoved(@as(*const IWMPEvents, @ptrCast(self)), bstrAttribName, bstrAttribVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MediaCollectionAttributeStringChanged(self: *const T, bstrAttribName: ?BSTR, bstrOldAttribVal: ?BSTR, bstrNewAttribVal: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MediaCollectionAttributeStringChanged(@as(*const IWMPEvents, @ptrCast(self)), bstrAttribName, bstrOldAttribVal, bstrNewAttribVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlaylistCollectionChange(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlaylistCollectionChange(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlaylistCollectionPlaylistAdded(self: *const T, bstrPlaylistName: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlaylistCollectionPlaylistAdded(@as(*const IWMPEvents, @ptrCast(self)), bstrPlaylistName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlaylistCollectionPlaylistRemoved(self: *const T, bstrPlaylistName: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlaylistCollectionPlaylistRemoved(@as(*const IWMPEvents, @ptrCast(self)), bstrPlaylistName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlaylistCollectionPlaylistSetAsDeleted(self: *const T, bstrPlaylistName: ?BSTR, varfIsDeleted: i16) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlaylistCollectionPlaylistSetAsDeleted(@as(*const IWMPEvents, @ptrCast(self)), bstrPlaylistName, varfIsDeleted);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_ModeChange(self: *const T, ModeName: ?BSTR, NewValue: i16) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).ModeChange(@as(*const IWMPEvents, @ptrCast(self)), ModeName, NewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MediaError(self: *const T, pMediaObject: ?*IDispatch) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MediaError(@as(*const IWMPEvents, @ptrCast(self)), pMediaObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_OpenPlaylistSwitch(self: *const T, pItem: ?*IDispatch) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).OpenPlaylistSwitch(@as(*const IWMPEvents, @ptrCast(self)), pItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_DomainChange(self: *const T, strDomain: ?BSTR) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).DomainChange(@as(*const IWMPEvents, @ptrCast(self)), strDomain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_SwitchedToPlayerApplication(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).SwitchedToPlayerApplication(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_SwitchedToControl(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).SwitchedToControl(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlayerDockedStateChange(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlayerDockedStateChange(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_PlayerReconnect(self: *const T) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).PlayerReconnect(@as(*const IWMPEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_Click(self: *const T, nButton: i16, nShiftState: i16, fX: i32, fY: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).Click(@as(*const IWMPEvents, @ptrCast(self)), nButton, nShiftState, fX, fY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_DoubleClick(self: *const T, nButton: i16, nShiftState: i16, fX: i32, fY: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).DoubleClick(@as(*const IWMPEvents, @ptrCast(self)), nButton, nShiftState, fX, fY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_KeyDown(self: *const T, nKeyCode: i16, nShiftState: i16) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).KeyDown(@as(*const IWMPEvents, @ptrCast(self)), nKeyCode, nShiftState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_KeyPress(self: *const T, nKeyAscii: i16) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).KeyPress(@as(*const IWMPEvents, @ptrCast(self)), nKeyAscii);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_KeyUp(self: *const T, nKeyCode: i16, nShiftState: i16) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).KeyUp(@as(*const IWMPEvents, @ptrCast(self)), nKeyCode, nShiftState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MouseDown(self: *const T, nButton: i16, nShiftState: i16, fX: i32, fY: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MouseDown(@as(*const IWMPEvents, @ptrCast(self)), nButton, nShiftState, fX, fY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MouseMove(self: *const T, nButton: i16, nShiftState: i16, fX: i32, fY: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MouseMove(@as(*const IWMPEvents, @ptrCast(self)), nButton, nShiftState, fX, fY);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents_MouseUp(self: *const T, nButton: i16, nShiftState: i16, fX: i32, fY: i32) void {
                return @as(*const IWMPEvents.VTable, @ptrCast(self.vtable)).MouseUp(@as(*const IWMPEvents, @ptrCast(self)), nButton, nShiftState, fX, fY);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPEvents2_Value = Guid.initString("1e7601fa-47ea-4107-9ea9-9004ed9684ff");
pub const IID_IWMPEvents2 = &IID_IWMPEvents2_Value;
pub const IWMPEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPEvents.VTable,
        DeviceConnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DeviceDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DeviceStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                NewStatus: WMPDeviceStatus,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                NewStatus: WMPDeviceStatus,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DeviceSyncStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                NewState: WMPSyncState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                NewState: WMPSyncState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        DeviceSyncError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                pMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                pMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreatePartnershipComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents2,
                pDevice: ?*IWMPSyncDevice,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPEvents.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents2_DeviceConnect(self: *const T, pDevice: ?*IWMPSyncDevice) void {
                return @as(*const IWMPEvents2.VTable, @ptrCast(self.vtable)).DeviceConnect(@as(*const IWMPEvents2, @ptrCast(self)), pDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents2_DeviceDisconnect(self: *const T, pDevice: ?*IWMPSyncDevice) void {
                return @as(*const IWMPEvents2.VTable, @ptrCast(self.vtable)).DeviceDisconnect(@as(*const IWMPEvents2, @ptrCast(self)), pDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents2_DeviceStatusChange(self: *const T, pDevice: ?*IWMPSyncDevice, NewStatus: WMPDeviceStatus) void {
                return @as(*const IWMPEvents2.VTable, @ptrCast(self.vtable)).DeviceStatusChange(@as(*const IWMPEvents2, @ptrCast(self)), pDevice, NewStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents2_DeviceSyncStateChange(self: *const T, pDevice: ?*IWMPSyncDevice, NewState: WMPSyncState) void {
                return @as(*const IWMPEvents2.VTable, @ptrCast(self.vtable)).DeviceSyncStateChange(@as(*const IWMPEvents2, @ptrCast(self)), pDevice, NewState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents2_DeviceSyncError(self: *const T, pDevice: ?*IWMPSyncDevice, pMedia: ?*IDispatch) void {
                return @as(*const IWMPEvents2.VTable, @ptrCast(self.vtable)).DeviceSyncError(@as(*const IWMPEvents2, @ptrCast(self)), pDevice, pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents2_CreatePartnershipComplete(self: *const T, pDevice: ?*IWMPSyncDevice, hrResult: HRESULT) void {
                return @as(*const IWMPEvents2.VTable, @ptrCast(self.vtable)).CreatePartnershipComplete(@as(*const IWMPEvents2, @ptrCast(self)), pDevice, hrResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPEvents3_Value = Guid.initString("1f504270-a66b-4223-8e96-26a06c63d69f");
pub const IID_IWMPEvents3 = &IID_IWMPEvents3_Value;
pub const IWMPEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IWMPEvents2.VTable,
        CdromRipStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pCdromRip: ?*IWMPCdromRip,
                wmprs: WMPRipState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pCdromRip: ?*IWMPCdromRip,
                wmprs: WMPRipState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CdromRipMediaError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pCdromRip: ?*IWMPCdromRip,
                pMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pCdromRip: ?*IWMPCdromRip,
                pMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CdromBurnStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pCdromBurn: ?*IWMPCdromBurn,
                wmpbs: WMPBurnState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pCdromBurn: ?*IWMPCdromBurn,
                wmpbs: WMPBurnState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CdromBurnMediaError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pCdromBurn: ?*IWMPCdromBurn,
                pMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pCdromBurn: ?*IWMPCdromBurn,
                pMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CdromBurnError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pCdromBurn: ?*IWMPCdromBurn,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pCdromBurn: ?*IWMPCdromBurn,
                hrError: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        LibraryConnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pLibrary: ?*IWMPLibrary,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pLibrary: ?*IWMPLibrary,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        LibraryDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pLibrary: ?*IWMPLibrary,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pLibrary: ?*IWMPLibrary,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FolderScanStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                wmpfss: WMPFolderScanState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                wmpfss: WMPFolderScanState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        StringCollectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pdispStringCollection: ?*IDispatch,
                change: WMPStringCollectionChangeEventType,
                lCollectionIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pdispStringCollection: ?*IDispatch,
                change: WMPStringCollectionChangeEventType,
                lCollectionIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaCollectionMediaAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pdispMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pdispMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        MediaCollectionMediaRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents3,
                pdispMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents3,
                pdispMedia: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPEvents2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_CdromRipStateChange(self: *const T, pCdromRip: ?*IWMPCdromRip, wmprs: WMPRipState) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).CdromRipStateChange(@as(*const IWMPEvents3, @ptrCast(self)), pCdromRip, wmprs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_CdromRipMediaError(self: *const T, pCdromRip: ?*IWMPCdromRip, pMedia: ?*IDispatch) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).CdromRipMediaError(@as(*const IWMPEvents3, @ptrCast(self)), pCdromRip, pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_CdromBurnStateChange(self: *const T, pCdromBurn: ?*IWMPCdromBurn, wmpbs: WMPBurnState) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).CdromBurnStateChange(@as(*const IWMPEvents3, @ptrCast(self)), pCdromBurn, wmpbs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_CdromBurnMediaError(self: *const T, pCdromBurn: ?*IWMPCdromBurn, pMedia: ?*IDispatch) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).CdromBurnMediaError(@as(*const IWMPEvents3, @ptrCast(self)), pCdromBurn, pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_CdromBurnError(self: *const T, pCdromBurn: ?*IWMPCdromBurn, hrError: HRESULT) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).CdromBurnError(@as(*const IWMPEvents3, @ptrCast(self)), pCdromBurn, hrError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_LibraryConnect(self: *const T, pLibrary: ?*IWMPLibrary) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).LibraryConnect(@as(*const IWMPEvents3, @ptrCast(self)), pLibrary);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_LibraryDisconnect(self: *const T, pLibrary: ?*IWMPLibrary) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).LibraryDisconnect(@as(*const IWMPEvents3, @ptrCast(self)), pLibrary);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_FolderScanStateChange(self: *const T, wmpfss: WMPFolderScanState) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).FolderScanStateChange(@as(*const IWMPEvents3, @ptrCast(self)), wmpfss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_StringCollectionChange(self: *const T, pdispStringCollection: ?*IDispatch, change: WMPStringCollectionChangeEventType, lCollectionIndex: i32) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).StringCollectionChange(@as(*const IWMPEvents3, @ptrCast(self)), pdispStringCollection, change, lCollectionIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_MediaCollectionMediaAdded(self: *const T, pdispMedia: ?*IDispatch) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).MediaCollectionMediaAdded(@as(*const IWMPEvents3, @ptrCast(self)), pdispMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents3_MediaCollectionMediaRemoved(self: *const T, pdispMedia: ?*IDispatch) void {
                return @as(*const IWMPEvents3.VTable, @ptrCast(self.vtable)).MediaCollectionMediaRemoved(@as(*const IWMPEvents3, @ptrCast(self)), pdispMedia);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPEvents4_Value = Guid.initString("26dabcfa-306b-404d-9a6f-630a8405048d");
pub const IID_IWMPEvents4 = &IID_IWMPEvents4_Value;
pub const IWMPEvents4 = extern struct {
    pub const VTable = extern struct {
        base: IWMPEvents3.VTable,
        DeviceEstimation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEvents4,
                pDevice: ?*IWMPSyncDevice,
                hrResult: HRESULT,
                qwEstimatedUsedSpace: i64,
                qwEstimatedSpace: i64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IWMPEvents4,
                pDevice: ?*IWMPSyncDevice,
                hrResult: HRESULT,
                qwEstimatedUsedSpace: i64,
                qwEstimatedSpace: i64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPEvents3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEvents4_DeviceEstimation(self: *const T, pDevice: ?*IWMPSyncDevice, hrResult: HRESULT, qwEstimatedUsedSpace: i64, qwEstimatedSpace: i64) void {
                return @as(*const IWMPEvents4.VTable, @ptrCast(self.vtable)).DeviceEstimation(@as(*const IWMPEvents4, @ptrCast(self)), pDevice, hrResult, qwEstimatedUsedSpace, qwEstimatedSpace);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID__WMPOCXEvents_Value = Guid.initString("6bf52a51-394a-11d3-b153-00c04f79faa6");
pub const IID__WMPOCXEvents = &IID__WMPOCXEvents_Value;
pub const _WMPOCXEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNodeRealEstate_Value = Guid.initString("42751198-5a50-4460-bcb4-709f8bdc8e59");
pub const IID_IWMPNodeRealEstate = &IID_IWMPNodeRealEstate_Value;
pub const IWMPNodeRealEstate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDesiredSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                pSrc: ?*const RECT,
                pDest: ?*const RECT,
                pClip: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                pSrc: ?*const RECT,
                pDest: ?*const RECT,
                pClip: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                pSrc: ?*RECT,
                pDest: ?*RECT,
                pClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                pSrc: ?*RECT,
                pDest: ?*RECT,
                pClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                fWindowless: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                fWindowless: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                pfWindowless: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                pfWindowless: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                fFullScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                fFullScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstate,
                pfFullScreen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstate,
                pfFullScreen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_GetDesiredSize(self: *const T, pSize: ?*SIZE) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).GetDesiredSize(@as(*const IWMPNodeRealEstate, @ptrCast(self)), pSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_SetRects(self: *const T, pSrc: ?*const RECT, pDest: ?*const RECT, pClip: ?*const RECT) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).SetRects(@as(*const IWMPNodeRealEstate, @ptrCast(self)), pSrc, pDest, pClip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_GetRects(self: *const T, pSrc: ?*RECT, pDest: ?*RECT, pClip: ?*RECT) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).GetRects(@as(*const IWMPNodeRealEstate, @ptrCast(self)), pSrc, pDest, pClip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_SetWindowless(self: *const T, fWindowless: BOOL) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).SetWindowless(@as(*const IWMPNodeRealEstate, @ptrCast(self)), fWindowless);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_GetWindowless(self: *const T, pfWindowless: ?*BOOL) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).GetWindowless(@as(*const IWMPNodeRealEstate, @ptrCast(self)), pfWindowless);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_SetFullScreen(self: *const T, fFullScreen: BOOL) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).SetFullScreen(@as(*const IWMPNodeRealEstate, @ptrCast(self)), fFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstate_GetFullScreen(self: *const T, pfFullScreen: ?*BOOL) HRESULT {
                return @as(*const IWMPNodeRealEstate.VTable, @ptrCast(self.vtable)).GetFullScreen(@as(*const IWMPNodeRealEstate, @ptrCast(self)), pfFullScreen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNodeRealEstateHost_Value = Guid.initString("1491087d-2c6b-44c8-b019-b3c929d2ada9");
pub const IID_IWMPNodeRealEstateHost = &IID_IWMPNodeRealEstateHost_Value;
pub const IWMPNodeRealEstateHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDesiredSizeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstateHost,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstateHost,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFullScreenTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeRealEstateHost,
                fFullScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeRealEstateHost,
                fFullScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstateHost_OnDesiredSizeChange(self: *const T, pSize: ?*SIZE) HRESULT {
                return @as(*const IWMPNodeRealEstateHost.VTable, @ptrCast(self.vtable)).OnDesiredSizeChange(@as(*const IWMPNodeRealEstateHost, @ptrCast(self)), pSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeRealEstateHost_OnFullScreenTransition(self: *const T, fFullScreen: BOOL) HRESULT {
                return @as(*const IWMPNodeRealEstateHost.VTable, @ptrCast(self.vtable)).OnFullScreenTransition(@as(*const IWMPNodeRealEstateHost, @ptrCast(self)), fFullScreen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNodeWindowed_Value = Guid.initString("96740bfa-c56a-45d1-a3a4-762914d4ade9");
pub const IID_IWMPNodeWindowed = &IID_IWMPNodeWindowed_Value;
pub const IWMPNodeWindowed = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOwnerWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeWindowed,
                hwnd: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeWindowed,
                hwnd: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOwnerWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeWindowed,
                phwnd: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeWindowed,
                phwnd: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeWindowed_SetOwnerWindow(self: *const T, hwnd: isize) HRESULT {
                return @as(*const IWMPNodeWindowed.VTable, @ptrCast(self.vtable)).SetOwnerWindow(@as(*const IWMPNodeWindowed, @ptrCast(self)), hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeWindowed_GetOwnerWindow(self: *const T, phwnd: ?*isize) HRESULT {
                return @as(*const IWMPNodeWindowed.VTable, @ptrCast(self.vtable)).GetOwnerWindow(@as(*const IWMPNodeWindowed, @ptrCast(self)), phwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNodeWindowedHost_Value = Guid.initString("a300415a-54aa-4081-adbf-3b13610d8958");
pub const IID_IWMPNodeWindowedHost = &IID_IWMPNodeWindowedHost_Value;
pub const IWMPNodeWindowedHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWindowMessageFromRenderer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeWindowedHost,
                uMsg: u32,
                wparam: WPARAM,
                lparam: LPARAM,
                plRet: ?*LRESULT,
                pfHandled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeWindowedHost,
                uMsg: u32,
                wparam: WPARAM,
                lparam: LPARAM,
                plRet: ?*LRESULT,
                pfHandled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeWindowedHost_OnWindowMessageFromRenderer(self: *const T, uMsg: u32, wparam: WPARAM, lparam: LPARAM, plRet: ?*LRESULT, pfHandled: ?*BOOL) HRESULT {
                return @as(*const IWMPNodeWindowedHost.VTable, @ptrCast(self.vtable)).OnWindowMessageFromRenderer(@as(*const IWMPNodeWindowedHost, @ptrCast(self)), uMsg, wparam, lparam, plRet, pfHandled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPWindowMessageSink_Value = Guid.initString("3a0daa30-908d-4789-ba87-aed879b5c49b");
pub const IID_IWMPWindowMessageSink = &IID_IWMPWindowMessageSink_Value;
pub const IWMPWindowMessageSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnWindowMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPWindowMessageSink,
                uMsg: u32,
                wparam: WPARAM,
                lparam: LPARAM,
                plRet: ?*LRESULT,
                pfHandled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPWindowMessageSink,
                uMsg: u32,
                wparam: WPARAM,
                lparam: LPARAM,
                plRet: ?*LRESULT,
                pfHandled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPWindowMessageSink_OnWindowMessage(self: *const T, uMsg: u32, wparam: WPARAM, lparam: LPARAM, plRet: ?*LRESULT, pfHandled: ?*BOOL) HRESULT {
                return @as(*const IWMPWindowMessageSink.VTable, @ptrCast(self.vtable)).OnWindowMessage(@as(*const IWMPWindowMessageSink, @ptrCast(self)), uMsg, wparam, lparam, plRet, pfHandled);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNodeWindowless_Value = Guid.initString("9b9199ad-780c-4eda-b816-261eba5d1575");
pub const IID_IWMPNodeWindowless = &IID_IWMPNodeWindowless_Value;
pub const IWMPNodeWindowless = extern struct {
    pub const VTable = extern struct {
        base: IWMPWindowMessageSink.VTable,
        OnDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeWindowless,
                hdc: isize,
                prcDraw: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeWindowless,
                hdc: isize,
                prcDraw: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPWindowMessageSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeWindowless_OnDraw(self: *const T, hdc: isize, prcDraw: ?*const RECT) HRESULT {
                return @as(*const IWMPNodeWindowless.VTable, @ptrCast(self.vtable)).OnDraw(@as(*const IWMPNodeWindowless, @ptrCast(self)), hdc, prcDraw);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPNodeWindowlessHost_Value = Guid.initString("be7017c6-ce34-4901-8106-770381aa6e3e");
pub const IID_IWMPNodeWindowlessHost = &IID_IWMPNodeWindowlessHost_Value;
pub const IWMPNodeWindowlessHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvalidateRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPNodeWindowlessHost,
                prc: ?*const RECT,
                fErase: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPNodeWindowlessHost,
                prc: ?*const RECT,
                fErase: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPNodeWindowlessHost_InvalidateRect(self: *const T, prc: ?*const RECT, fErase: BOOL) HRESULT {
                return @as(*const IWMPNodeWindowlessHost.VTable, @ptrCast(self.vtable)).InvalidateRect(@as(*const IWMPNodeWindowlessHost, @ptrCast(self)), prc, fErase);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPVideoRenderConfig_Value = Guid.initString("6d6cf803-1ec0-4c8d-b3ca-f18e27282074");
pub const IID_IWMPVideoRenderConfig = &IID_IWMPVideoRenderConfig_Value;
pub const IWMPVideoRenderConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_presenterActivate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPVideoRenderConfig,
                pActivate: ?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPVideoRenderConfig,
                pActivate: ?*IMFActivate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPVideoRenderConfig_put_presenterActivate(self: *const T, pActivate: ?*IMFActivate) HRESULT {
                return @as(*const IWMPVideoRenderConfig.VTable, @ptrCast(self.vtable)).put_presenterActivate(@as(*const IWMPVideoRenderConfig, @ptrCast(self)), pActivate);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPAudioRenderConfig_Value = Guid.initString("e79c6349-5997-4ce4-917c-22a3391ec564");
pub const IID_IWMPAudioRenderConfig = &IID_IWMPAudioRenderConfig_Value;
pub const IWMPAudioRenderConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_audioOutputDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPAudioRenderConfig,
                pbstrOutputDevice: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPAudioRenderConfig,
                pbstrOutputDevice: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_audioOutputDevice: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPAudioRenderConfig,
                bstrOutputDevice: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPAudioRenderConfig,
                bstrOutputDevice: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPAudioRenderConfig_get_audioOutputDevice(self: *const T, pbstrOutputDevice: ?*?BSTR) HRESULT {
                return @as(*const IWMPAudioRenderConfig.VTable, @ptrCast(self.vtable)).get_audioOutputDevice(@as(*const IWMPAudioRenderConfig, @ptrCast(self)), pbstrOutputDevice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPAudioRenderConfig_put_audioOutputDevice(self: *const T, bstrOutputDevice: ?BSTR) HRESULT {
                return @as(*const IWMPAudioRenderConfig.VTable, @ptrCast(self.vtable)).put_audioOutputDevice(@as(*const IWMPAudioRenderConfig, @ptrCast(self)), bstrOutputDevice);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPRenderConfig_Value = Guid.initString("959506c1-0314-4ec5-9e61-8528db5e5478");
pub const IID_IWMPRenderConfig = &IID_IWMPRenderConfig_Value;
pub const IWMPRenderConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_inProcOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPRenderConfig,
                fInProc: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPRenderConfig,
                fInProc: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_inProcOnly: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPRenderConfig,
                pfInProc: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPRenderConfig,
                pfInProc: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPRenderConfig_put_inProcOnly(self: *const T, fInProc: BOOL) HRESULT {
                return @as(*const IWMPRenderConfig.VTable, @ptrCast(self.vtable)).put_inProcOnly(@as(*const IWMPRenderConfig, @ptrCast(self)), fInProc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPRenderConfig_get_inProcOnly(self: *const T, pfInProc: ?*BOOL) HRESULT {
                return @as(*const IWMPRenderConfig.VTable, @ptrCast(self.vtable)).get_inProcOnly(@as(*const IWMPRenderConfig, @ptrCast(self)), pfInProc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPServices_StreamState = enum(i32) {
    Stop = 0,
    Pause = 1,
    Play = 2,
};
pub const WMPServices_StreamState_Stop = WMPServices_StreamState.Stop;
pub const WMPServices_StreamState_Pause = WMPServices_StreamState.Pause;
pub const WMPServices_StreamState_Play = WMPServices_StreamState.Play;

const IID_IWMPServices_Value = Guid.initString("afb6b76b-1e20-4198-83b3-191db6e0b149");
pub const IID_IWMPServices = &IID_IWMPServices_Value;
pub const IWMPServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPServices,
                prt: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPServices,
                prt: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPServices,
                pState: ?*WMPServices_StreamState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPServices,
                pState: ?*WMPServices_StreamState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPServices_GetStreamTime(self: *const T, prt: ?*i64) HRESULT {
                return @as(*const IWMPServices.VTable, @ptrCast(self.vtable)).GetStreamTime(@as(*const IWMPServices, @ptrCast(self)), prt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPServices_GetStreamState(self: *const T, pState: ?*WMPServices_StreamState) HRESULT {
                return @as(*const IWMPServices.VTable, @ptrCast(self.vtable)).GetStreamState(@as(*const IWMPServices, @ptrCast(self)), pState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPMediaPluginRegistrar_Value = Guid.initString("68e27045-05bd-40b2-9720-23088c78e390");
pub const IID_IWMPMediaPluginRegistrar = &IID_IWMPMediaPluginRegistrar_Value;
pub const IWMPMediaPluginRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WMPRegisterPlayerPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaPluginRegistrar,
                pwszFriendlyName: ?PWSTR,
                pwszDescription: ?PWSTR,
                pwszUninstallString: ?PWSTR,
                dwPriority: u32,
                guidPluginType: Guid,
                clsid: Guid,
                cMediaTypes: u32,
                pMediaTypes: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaPluginRegistrar,
                pwszFriendlyName: ?PWSTR,
                pwszDescription: ?PWSTR,
                pwszUninstallString: ?PWSTR,
                dwPriority: u32,
                guidPluginType: Guid,
                clsid: Guid,
                cMediaTypes: u32,
                pMediaTypes: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WMPUnRegisterPlayerPlugin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPMediaPluginRegistrar,
                guidPluginType: Guid,
                clsid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPMediaPluginRegistrar,
                guidPluginType: Guid,
                clsid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaPluginRegistrar_WMPRegisterPlayerPlugin(self: *const T, pwszFriendlyName: ?PWSTR, pwszDescription: ?PWSTR, pwszUninstallString: ?PWSTR, dwPriority: u32, guidPluginType: Guid, clsid: Guid, cMediaTypes: u32, pMediaTypes: ?*anyopaque) HRESULT {
                return @as(*const IWMPMediaPluginRegistrar.VTable, @ptrCast(self.vtable)).WMPRegisterPlayerPlugin(@as(*const IWMPMediaPluginRegistrar, @ptrCast(self)), pwszFriendlyName, pwszDescription, pwszUninstallString, dwPriority, guidPluginType, clsid, cMediaTypes, pMediaTypes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPMediaPluginRegistrar_WMPUnRegisterPlayerPlugin(self: *const T, guidPluginType: Guid, clsid: Guid) HRESULT {
                return @as(*const IWMPMediaPluginRegistrar.VTable, @ptrCast(self.vtable)).WMPUnRegisterPlayerPlugin(@as(*const IWMPMediaPluginRegistrar, @ptrCast(self)), guidPluginType, clsid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPPlugin_Caps = enum(i32) {
    s = 1,
};
pub const WMPPlugin_Caps_CannotConvertFormats = WMPPlugin_Caps.s;

const IID_IWMPPlugin_Value = Guid.initString("f1392a70-024c-42bb-a998-73dfdfe7d5a7");
pub const IID_IWMPPlugin = &IID_IWMPPlugin_Value;
pub const IWMPPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlugin,
                dwPlaybackContext: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlugin,
                dwPlaybackContext: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlugin,
                pGUID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlugin,
                pGUID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlugin,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlugin,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseWMPServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlugin,
                pWMPServices: ?*IWMPServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlugin,
                pWMPServices: ?*IWMPServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnAdviseWMPServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPlugin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlugin_Init(self: *const T, dwPlaybackContext: usize) HRESULT {
                return @as(*const IWMPPlugin.VTable, @ptrCast(self.vtable)).Init(@as(*const IWMPPlugin, @ptrCast(self)), dwPlaybackContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlugin_Shutdown(self: *const T) HRESULT {
                return @as(*const IWMPPlugin.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IWMPPlugin, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlugin_GetID(self: *const T, pGUID: ?*Guid) HRESULT {
                return @as(*const IWMPPlugin.VTable, @ptrCast(self.vtable)).GetID(@as(*const IWMPPlugin, @ptrCast(self)), pGUID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlugin_GetCaps(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IWMPPlugin.VTable, @ptrCast(self.vtable)).GetCaps(@as(*const IWMPPlugin, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlugin_AdviseWMPServices(self: *const T, pWMPServices: ?*IWMPServices) HRESULT {
                return @as(*const IWMPPlugin.VTable, @ptrCast(self.vtable)).AdviseWMPServices(@as(*const IWMPPlugin, @ptrCast(self)), pWMPServices);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPlugin_UnAdviseWMPServices(self: *const T) HRESULT {
                return @as(*const IWMPPlugin.VTable, @ptrCast(self.vtable)).UnAdviseWMPServices(@as(*const IWMPPlugin, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPluginEnable_Value = Guid.initString("5fca444c-7ad1-479d-a4ef-40566a5309d6");
pub const IID_IWMPPluginEnable = &IID_IWMPPluginEnable_Value;
pub const IWMPPluginEnable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginEnable,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginEnable,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginEnable,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginEnable,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginEnable_SetEnable(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IWMPPluginEnable.VTable, @ptrCast(self.vtable)).SetEnable(@as(*const IWMPPluginEnable, @ptrCast(self)), fEnable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginEnable_GetEnable(self: *const T, pfEnable: ?*BOOL) HRESULT {
                return @as(*const IWMPPluginEnable.VTable, @ptrCast(self.vtable)).GetEnable(@as(*const IWMPPluginEnable, @ptrCast(self)), pfEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPGraphCreation_Value = Guid.initString("bfb377e5-c594-4369-a970-de896d5ece74");
pub const IID_IWMPGraphCreation = &IID_IWMPGraphCreation_Value;
pub const IWMPGraphCreation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GraphCreationPreRender: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPGraphCreation,
                pFilterGraph: ?*IUnknown,
                pReserved: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPGraphCreation,
                pFilterGraph: ?*IUnknown,
                pReserved: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GraphCreationPostRender: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPGraphCreation,
                pFilterGraph: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPGraphCreation,
                pFilterGraph: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGraphCreationFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPGraphCreation,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPGraphCreation,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPGraphCreation_GraphCreationPreRender(self: *const T, pFilterGraph: ?*IUnknown, pReserved: ?*IUnknown) HRESULT {
                return @as(*const IWMPGraphCreation.VTable, @ptrCast(self.vtable)).GraphCreationPreRender(@as(*const IWMPGraphCreation, @ptrCast(self)), pFilterGraph, pReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPGraphCreation_GraphCreationPostRender(self: *const T, pFilterGraph: ?*IUnknown) HRESULT {
                return @as(*const IWMPGraphCreation.VTable, @ptrCast(self.vtable)).GraphCreationPostRender(@as(*const IWMPGraphCreation, @ptrCast(self)), pFilterGraph);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPGraphCreation_GetGraphCreationFlags(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IWMPGraphCreation.VTable, @ptrCast(self.vtable)).GetGraphCreationFlags(@as(*const IWMPGraphCreation, @ptrCast(self)), pdwFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPConvert_Value = Guid.initString("d683162f-57d4-4108-8373-4a9676d1c2e9");
pub const IID_IWMPConvert = &IID_IWMPConvert_Value;
pub const IWMPConvert = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConvertFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPConvert,
                bstrInputFile: ?BSTR,
                bstrDestinationFolder: ?BSTR,
                pbstrOutputFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPConvert,
                bstrInputFile: ?BSTR,
                bstrDestinationFolder: ?BSTR,
                pbstrOutputFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPConvert,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPConvert,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPConvert_ConvertFile(self: *const T, bstrInputFile: ?BSTR, bstrDestinationFolder: ?BSTR, pbstrOutputFile: ?*?BSTR) HRESULT {
                return @as(*const IWMPConvert.VTable, @ptrCast(self.vtable)).ConvertFile(@as(*const IWMPConvert, @ptrCast(self)), bstrInputFile, bstrDestinationFolder, pbstrOutputFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPConvert_GetErrorURL(self: *const T, pbstrURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPConvert.VTable, @ptrCast(self.vtable)).GetErrorURL(@as(*const IWMPConvert, @ptrCast(self)), pbstrURL);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPTranscodePolicy_Value = Guid.initString("b64cbac3-401c-4327-a3e8-b9feb3a8c25c");
pub const IID_IWMPTranscodePolicy = &IID_IWMPTranscodePolicy_Value;
pub const IWMPTranscodePolicy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        allowTranscode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPTranscodePolicy,
                pvbAllow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPTranscodePolicy,
                pvbAllow: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPTranscodePolicy_allowTranscode(self: *const T, pvbAllow: ?*i16) HRESULT {
                return @as(*const IWMPTranscodePolicy.VTable, @ptrCast(self.vtable)).allowTranscode(@as(*const IWMPTranscodePolicy, @ptrCast(self)), pvbAllow);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPUserEventSink_Value = Guid.initString("cfccfa72-c343-48c3-a2de-b7a4402e39f2");
pub const IID_IWMPUserEventSink = &IID_IWMPUserEventSink_Value;
pub const IWMPUserEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyUserEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPUserEventSink,
                EventCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPUserEventSink,
                EventCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPUserEventSink_NotifyUserEvent(self: *const T, EventCode: i32) HRESULT {
                return @as(*const IWMPUserEventSink.VTable, @ptrCast(self.vtable)).NotifyUserEvent(@as(*const IWMPUserEventSink, @ptrCast(self)), EventCode);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FeedsManager_Value = Guid.initString("faeb54c4-f66f-4806-83a0-805299f5e3ad");
pub const CLSID_FeedsManager = &CLSID_FeedsManager_Value;

const CLSID_FeedFolderWatcher_Value = Guid.initString("281001ed-7765-4cb0-84af-e9b387af01ff");
pub const CLSID_FeedFolderWatcher = &CLSID_FeedFolderWatcher_Value;

const CLSID_FeedWatcher_Value = Guid.initString("18a6737b-f433-4687-89bc-a1b4dfb9f123");
pub const CLSID_FeedWatcher = &CLSID_FeedWatcher_Value;

pub const FEEDS_BACKGROUNDSYNC_ACTION = enum(i32) {
    DISABLE = 0,
    ENABLE = 1,
    RUNNOW = 2,
};
pub const FBSA_DISABLE = FEEDS_BACKGROUNDSYNC_ACTION.DISABLE;
pub const FBSA_ENABLE = FEEDS_BACKGROUNDSYNC_ACTION.ENABLE;
pub const FBSA_RUNNOW = FEEDS_BACKGROUNDSYNC_ACTION.RUNNOW;

pub const FEEDS_BACKGROUNDSYNC_STATUS = enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
};
pub const FBSS_DISABLED = FEEDS_BACKGROUNDSYNC_STATUS.DISABLED;
pub const FBSS_ENABLED = FEEDS_BACKGROUNDSYNC_STATUS.ENABLED;

pub const FEEDS_EVENTS_SCOPE = enum(i32) {
    ALL = 0,
    SELF_ONLY = 1,
    SELF_AND_CHILDREN_ONLY = 2,
};
pub const FES_ALL = FEEDS_EVENTS_SCOPE.ALL;
pub const FES_SELF_ONLY = FEEDS_EVENTS_SCOPE.SELF_ONLY;
pub const FES_SELF_AND_CHILDREN_ONLY = FEEDS_EVENTS_SCOPE.SELF_AND_CHILDREN_ONLY;

pub const FEEDS_EVENTS_MASK = enum(i32) {
    OLDEREVENTS = 1,
    EEDEVENTS = 2,
};
pub const FEM_FOLDEREVENTS = FEEDS_EVENTS_MASK.OLDEREVENTS;
pub const FEM_FEEDEVENTS = FEEDS_EVENTS_MASK.EEDEVENTS;

pub const FEEDS_XML_SORT_PROPERTY = enum(i32) {
    NONE = 0,
    PUBDATE = 1,
    DOWNLOADTIME = 2,
};
pub const FXSP_NONE = FEEDS_XML_SORT_PROPERTY.NONE;
pub const FXSP_PUBDATE = FEEDS_XML_SORT_PROPERTY.PUBDATE;
pub const FXSP_DOWNLOADTIME = FEEDS_XML_SORT_PROPERTY.DOWNLOADTIME;

pub const FEEDS_XML_SORT_ORDER = enum(i32) {
    NONE = 0,
    ASCENDING = 1,
    DESCENDING = 2,
};
pub const FXSO_NONE = FEEDS_XML_SORT_ORDER.NONE;
pub const FXSO_ASCENDING = FEEDS_XML_SORT_ORDER.ASCENDING;
pub const FXSO_DESCENDING = FEEDS_XML_SORT_ORDER.DESCENDING;

pub const FEEDS_XML_FILTER_FLAGS = enum(i32) {
    ALL = 0,
    UNREAD = 1,
    READ = 2,
};
pub const FXFF_ALL = FEEDS_XML_FILTER_FLAGS.ALL;
pub const FXFF_UNREAD = FEEDS_XML_FILTER_FLAGS.UNREAD;
pub const FXFF_READ = FEEDS_XML_FILTER_FLAGS.READ;

pub const FEEDS_XML_INCLUDE_FLAGS = enum(i32) {
    NONE = 0,
    CF_EXTENSIONS = 1,
};
pub const FXIF_NONE = FEEDS_XML_INCLUDE_FLAGS.NONE;
pub const FXIF_CF_EXTENSIONS = FEEDS_XML_INCLUDE_FLAGS.CF_EXTENSIONS;

pub const FEEDS_DOWNLOAD_STATUS = enum(i32) {
    NONE = 0,
    PENDING = 1,
    DOWNLOADING = 2,
    DOWNLOADED = 3,
    DOWNLOAD_FAILED = 4,
};
pub const FDS_NONE = FEEDS_DOWNLOAD_STATUS.NONE;
pub const FDS_PENDING = FEEDS_DOWNLOAD_STATUS.PENDING;
pub const FDS_DOWNLOADING = FEEDS_DOWNLOAD_STATUS.DOWNLOADING;
pub const FDS_DOWNLOADED = FEEDS_DOWNLOAD_STATUS.DOWNLOADED;
pub const FDS_DOWNLOAD_FAILED = FEEDS_DOWNLOAD_STATUS.DOWNLOAD_FAILED;

pub const FEEDS_SYNC_SETTING = enum(i32) {
    DEFAULT = 0,
    INTERVAL = 1,
    MANUAL = 2,
    SUGGESTED = 3,
};
pub const FSS_DEFAULT = FEEDS_SYNC_SETTING.DEFAULT;
pub const FSS_INTERVAL = FEEDS_SYNC_SETTING.INTERVAL;
pub const FSS_MANUAL = FEEDS_SYNC_SETTING.MANUAL;
pub const FSS_SUGGESTED = FEEDS_SYNC_SETTING.SUGGESTED;

pub const FEEDS_DOWNLOAD_ERROR = enum(i32) {
    NONE = 0,
    DOWNLOAD_FAILED = 1,
    INVALID_FEED_FORMAT = 2,
    NORMALIZATION_FAILED = 3,
    PERSISTENCE_FAILED = 4,
    DOWNLOAD_BLOCKED = 5,
    CANCELED = 6,
    UNSUPPORTED_AUTH = 7,
    BACKGROUND_DOWNLOAD_DISABLED = 8,
    NOT_EXIST = 9,
    UNSUPPORTED_MSXML = 10,
    UNSUPPORTED_DTD = 11,
    DOWNLOAD_SIZE_LIMIT_EXCEEDED = 12,
    ACCESS_DENIED = 13,
    AUTH_FAILED = 14,
    INVALID_AUTH = 15,
};
pub const FDE_NONE = FEEDS_DOWNLOAD_ERROR.NONE;
pub const FDE_DOWNLOAD_FAILED = FEEDS_DOWNLOAD_ERROR.DOWNLOAD_FAILED;
pub const FDE_INVALID_FEED_FORMAT = FEEDS_DOWNLOAD_ERROR.INVALID_FEED_FORMAT;
pub const FDE_NORMALIZATION_FAILED = FEEDS_DOWNLOAD_ERROR.NORMALIZATION_FAILED;
pub const FDE_PERSISTENCE_FAILED = FEEDS_DOWNLOAD_ERROR.PERSISTENCE_FAILED;
pub const FDE_DOWNLOAD_BLOCKED = FEEDS_DOWNLOAD_ERROR.DOWNLOAD_BLOCKED;
pub const FDE_CANCELED = FEEDS_DOWNLOAD_ERROR.CANCELED;
pub const FDE_UNSUPPORTED_AUTH = FEEDS_DOWNLOAD_ERROR.UNSUPPORTED_AUTH;
pub const FDE_BACKGROUND_DOWNLOAD_DISABLED = FEEDS_DOWNLOAD_ERROR.BACKGROUND_DOWNLOAD_DISABLED;
pub const FDE_NOT_EXIST = FEEDS_DOWNLOAD_ERROR.NOT_EXIST;
pub const FDE_UNSUPPORTED_MSXML = FEEDS_DOWNLOAD_ERROR.UNSUPPORTED_MSXML;
pub const FDE_UNSUPPORTED_DTD = FEEDS_DOWNLOAD_ERROR.UNSUPPORTED_DTD;
pub const FDE_DOWNLOAD_SIZE_LIMIT_EXCEEDED = FEEDS_DOWNLOAD_ERROR.DOWNLOAD_SIZE_LIMIT_EXCEEDED;
pub const FDE_ACCESS_DENIED = FEEDS_DOWNLOAD_ERROR.ACCESS_DENIED;
pub const FDE_AUTH_FAILED = FEEDS_DOWNLOAD_ERROR.AUTH_FAILED;
pub const FDE_INVALID_AUTH = FEEDS_DOWNLOAD_ERROR.INVALID_AUTH;

pub const FEEDS_EVENTS_ITEM_COUNT_FLAGS = enum(i32) {
    READ_ITEM_COUNT_CHANGED = 1,
    UNREAD_ITEM_COUNT_CHANGED = 2,
};
pub const FEICF_READ_ITEM_COUNT_CHANGED = FEEDS_EVENTS_ITEM_COUNT_FLAGS.READ_ITEM_COUNT_CHANGED;
pub const FEICF_UNREAD_ITEM_COUNT_CHANGED = FEEDS_EVENTS_ITEM_COUNT_FLAGS.UNREAD_ITEM_COUNT_CHANGED;

pub const FEEDS_ERROR_CODE = enum(i32) {
    ERRORBASE = -1073479168,
    // INVALIDMSXMLPROPERTY = -1073479168, this enum value conflicts with ERRORBASE
    DOWNLOADSIZELIMITEXCEEDED = -1073479167,
};
pub const FEC_E_ERRORBASE = FEEDS_ERROR_CODE.ERRORBASE;
pub const FEC_E_INVALIDMSXMLPROPERTY = FEEDS_ERROR_CODE.ERRORBASE;
pub const FEC_E_DOWNLOADSIZELIMITEXCEEDED = FEEDS_ERROR_CODE.DOWNLOADSIZELIMITEXCEEDED;

const IID_IXFeedsManager_Value = Guid.initString("5357e238-fb12-4aca-a930-cab7832b84bf");
pub const IID_IXFeedsManager = &IID_IXFeedsManager_Value;
pub const IXFeedsManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RootFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSubscribed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszUrl: ?[*:0]const u16,
                pbSubscribed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszUrl: ?[*:0]const u16,
                pbSubscribed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                pbFeedExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                pbFeedExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeedByUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszUrl: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszUrl: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                pbFolderExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                pbFolderExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                fbsa: FEEDS_BACKGROUNDSYNC_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                fbsa: FEEDS_BACKGROUNDSYNC_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundSyncStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pfbss: ?*FEEDS_BACKGROUNDSYNC_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pfbss: ?*FEEDS_BACKGROUNDSYNC_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefaultInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                puiInterval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                puiInterval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                uiInterval: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                uiInterval: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncSyncAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Normalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                pStreamIn: ?*IStream,
                ppStreamOut: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                pStreamIn: ?*IStream,
                ppStreamOut: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemCountLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsManager,
                puiItemCountLimit: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsManager,
                puiItemCountLimit: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_RootFolder(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).RootFolder(@as(*const IXFeedsManager, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_IsSubscribed(self: *const T, pszUrl: ?[*:0]const u16, pbSubscribed: ?*BOOL) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).IsSubscribed(@as(*const IXFeedsManager, @ptrCast(self)), pszUrl, pbSubscribed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_ExistsFeed(self: *const T, pszPath: ?[*:0]const u16, pbFeedExists: ?*BOOL) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).ExistsFeed(@as(*const IXFeedsManager, @ptrCast(self)), pszPath, pbFeedExists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_GetFeed(self: *const T, pszPath: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).GetFeed(@as(*const IXFeedsManager, @ptrCast(self)), pszPath, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_GetFeedByUrl(self: *const T, pszUrl: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).GetFeedByUrl(@as(*const IXFeedsManager, @ptrCast(self)), pszUrl, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_ExistsFolder(self: *const T, pszPath: ?[*:0]const u16, pbFolderExists: ?*BOOL) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).ExistsFolder(@as(*const IXFeedsManager, @ptrCast(self)), pszPath, pbFolderExists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_GetFolder(self: *const T, pszPath: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const IXFeedsManager, @ptrCast(self)), pszPath, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_DeleteFeed(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).DeleteFeed(@as(*const IXFeedsManager, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_DeleteFolder(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).DeleteFolder(@as(*const IXFeedsManager, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_BackgroundSync(self: *const T, fbsa: FEEDS_BACKGROUNDSYNC_ACTION) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).BackgroundSync(@as(*const IXFeedsManager, @ptrCast(self)), fbsa);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_BackgroundSyncStatus(self: *const T, pfbss: ?*FEEDS_BACKGROUNDSYNC_STATUS) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).BackgroundSyncStatus(@as(*const IXFeedsManager, @ptrCast(self)), pfbss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_DefaultInterval(self: *const T, puiInterval: ?*u32) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).DefaultInterval(@as(*const IXFeedsManager, @ptrCast(self)), puiInterval);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_SetDefaultInterval(self: *const T, uiInterval: u32) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).SetDefaultInterval(@as(*const IXFeedsManager, @ptrCast(self)), uiInterval);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_AsyncSyncAll(self: *const T) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).AsyncSyncAll(@as(*const IXFeedsManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_Normalize(self: *const T, pStreamIn: ?*IStream, ppStreamOut: ?*?*IStream) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).Normalize(@as(*const IXFeedsManager, @ptrCast(self)), pStreamIn, ppStreamOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsManager_ItemCountLimit(self: *const T, puiItemCountLimit: ?*u32) HRESULT {
                return @as(*const IXFeedsManager.VTable, @ptrCast(self.vtable)).ItemCountLimit(@as(*const IXFeedsManager, @ptrCast(self)), puiItemCountLimit);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedsEnum_Value = Guid.initString("dc43a9d5-5015-4301-8c96-a47434b4d658");
pub const IID_IXFeedsEnum = &IID_IXFeedsEnum_Value;
pub const IXFeedsEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Count: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsEnum,
                puiCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsEnum,
                puiCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedsEnum,
                uiIndex: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedsEnum,
                uiIndex: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsEnum_Count(self: *const T, puiCount: ?*u32) HRESULT {
                return @as(*const IXFeedsEnum.VTable, @ptrCast(self.vtable)).Count(@as(*const IXFeedsEnum, @ptrCast(self)), puiCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedsEnum_Item(self: *const T, uiIndex: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedsEnum.VTable, @ptrCast(self.vtable)).Item(@as(*const IXFeedsEnum, @ptrCast(self)), uiIndex, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedFolder_Value = Guid.initString("4c963678-3a51-4b88-8531-98b90b6508f2");
pub const IID_IXFeedFolder = &IID_IXFeedFolder_Value;
pub const IXFeedFolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Feeds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                ppfe: ?*?*IXFeedsEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                ppfe: ?*?*IXFeedsEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Subfolders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                ppfe: ?*?*IXFeedsEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                ppfe: ?*?*IXFeedsEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                pszUrl: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                pszUrl: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSubfolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                pbFeedExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                pbFeedExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsSubfolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                pbSubfolderExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                pbSubfolderExists: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubfolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Name: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Path: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Parent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                pbIsRootFeedFolder: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                pbIsRootFeedFolder: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TotalUnreadItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                puiTotalUnreadItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                puiTotalUnreadItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TotalItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolder,
                puiTotalItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolder,
                puiTotalItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Feeds(self: *const T, ppfe: ?*?*IXFeedsEnum) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Feeds(@as(*const IXFeedFolder, @ptrCast(self)), ppfe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Subfolders(self: *const T, ppfe: ?*?*IXFeedsEnum) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Subfolders(@as(*const IXFeedFolder, @ptrCast(self)), ppfe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_CreateFeed(self: *const T, pszName: ?[*:0]const u16, pszUrl: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).CreateFeed(@as(*const IXFeedFolder, @ptrCast(self)), pszName, pszUrl, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_CreateSubfolder(self: *const T, pszName: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).CreateSubfolder(@as(*const IXFeedFolder, @ptrCast(self)), pszName, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_ExistsFeed(self: *const T, pszName: ?[*:0]const u16, pbFeedExists: ?*BOOL) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).ExistsFeed(@as(*const IXFeedFolder, @ptrCast(self)), pszName, pbFeedExists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_ExistsSubfolder(self: *const T, pszName: ?[*:0]const u16, pbSubfolderExists: ?*BOOL) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).ExistsSubfolder(@as(*const IXFeedFolder, @ptrCast(self)), pszName, pbSubfolderExists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_GetFeed(self: *const T, pszName: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).GetFeed(@as(*const IXFeedFolder, @ptrCast(self)), pszName, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_GetSubfolder(self: *const T, pszName: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).GetSubfolder(@as(*const IXFeedFolder, @ptrCast(self)), pszName, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Delete(self: *const T) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Delete(@as(*const IXFeedFolder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Name(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Name(@as(*const IXFeedFolder, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Rename(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Rename(@as(*const IXFeedFolder, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Path(self: *const T, ppszPath: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Path(@as(*const IXFeedFolder, @ptrCast(self)), ppszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Move(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Move(@as(*const IXFeedFolder, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_Parent(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).Parent(@as(*const IXFeedFolder, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_IsRoot(self: *const T, pbIsRootFeedFolder: ?*BOOL) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).IsRoot(@as(*const IXFeedFolder, @ptrCast(self)), pbIsRootFeedFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_GetWatcher(self: *const T, scope: FEEDS_EVENTS_SCOPE, mask: FEEDS_EVENTS_MASK, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).GetWatcher(@as(*const IXFeedFolder, @ptrCast(self)), scope, mask, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_TotalUnreadItemCount(self: *const T, puiTotalUnreadItemCount: ?*u32) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).TotalUnreadItemCount(@as(*const IXFeedFolder, @ptrCast(self)), puiTotalUnreadItemCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolder_TotalItemCount(self: *const T, puiTotalItemCount: ?*u32) HRESULT {
                return @as(*const IXFeedFolder.VTable, @ptrCast(self.vtable)).TotalItemCount(@as(*const IXFeedFolder, @ptrCast(self)), puiTotalItemCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedFolderEvents_Value = Guid.initString("7964b769-234a-4bb1-a5f4-90454c8ad07e");
pub const IID_IXFeedFolderEvents = &IID_IXFeedFolderEvents_Value;
pub const IXFeedFolderEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderMovedFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderMovedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderItemCountChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                feicfFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                feicfFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedUrlChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedMovedFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedMovedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloading: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloadCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                fde: FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                fde: FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedItemCountChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                feicfFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedFolderEvents,
                pszPath: ?[*:0]const u16,
                feicfFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_Error(self: *const T) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).Error(@as(*const IXFeedFolderEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FolderAdded(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderAdded(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FolderDeleted(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderDeleted(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FolderRenamed(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderRenamed(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FolderMovedFrom(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderMovedFrom(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FolderMovedTo(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderMovedTo(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FolderItemCountChanged(self: *const T, pszPath: ?[*:0]const u16, feicfFlags: i32) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderItemCountChanged(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, feicfFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedAdded(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedAdded(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedDeleted(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedDeleted(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedRenamed(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedRenamed(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedUrlChanged(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedUrlChanged(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedMovedFrom(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedMovedFrom(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedMovedTo(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedMovedTo(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedDownloading(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedDownloading(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedDownloadCompleted(self: *const T, pszPath: ?[*:0]const u16, fde: FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedDownloadCompleted(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, fde);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedFolderEvents_FeedItemCountChanged(self: *const T, pszPath: ?[*:0]const u16, feicfFlags: i32) HRESULT {
                return @as(*const IXFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedItemCountChanged(@as(*const IXFeedFolderEvents, @ptrCast(self)), pszPath, feicfFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeed_Value = Guid.initString("a44179a4-e0f6-403b-af8d-d080f425a451");
pub const IID_IXFeed = &IID_IXFeed_Value;
pub const IXFeed = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Xml: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                uiItemCount: u32,
                sortProperty: FEEDS_XML_SORT_PROPERTY,
                sortOrder: FEEDS_XML_SORT_ORDER,
                filterFlags: FEEDS_XML_FILTER_FLAGS,
                includeFlags: FEEDS_XML_INCLUDE_FLAGS,
                pps: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                uiItemCount: u32,
                sortProperty: FEEDS_XML_SORT_PROPERTY,
                sortOrder: FEEDS_XML_SORT_ORDER,
                filterFlags: FEEDS_XML_FILTER_FLAGS,
                includeFlags: FEEDS_XML_INCLUDE_FLAGS,
                pps: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Name: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Url: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LocalId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pguid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Path: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Parent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastWriteTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pstLastWriteTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pstLastWriteTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pfss: ?*FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pfss: ?*FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncSetting: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                fss: FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                fss: FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Interval: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                puiInterval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                puiInterval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                uiInterval: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                uiInterval: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastDownloadTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pstLastDownloadTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pstLastDownloadTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LocalEnclosurePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Items: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppfe: ?*?*IXFeedsEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppfe: ?*?*IXFeedsEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                uiId: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                uiId: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MarkAllItemsRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MaxItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                puiMaxItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                puiMaxItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                uiMaxItemCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                uiMaxItemCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadEnclosuresAutomatically: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pbDownloadEnclosuresAutomatically: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pbDownloadEnclosuresAutomatically: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDownloadEnclosuresAutomatically: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                bDownloadEnclosuresAutomatically: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                bDownloadEnclosuresAutomatically: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pfds: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pfds: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastDownloadError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pfde: ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pfde: ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Merge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pStream: ?*IStream,
                pszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pStream: ?*IStream,
                pszUrl: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Title: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Description: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Link: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszHomePage: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszHomePage: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Image: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszImageUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszImageUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastBuildDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pstLastBuildDate: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pstLastBuildDate: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PubDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pstPubDate: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pstPubDate: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Ttl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                puiTtl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                puiTtl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Language: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszLanguage: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszLanguage: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Copyright: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                ppszCopyright: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                ppszCopyright: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                pbIsList: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                pbIsList: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnreadItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                puiUnreadItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                puiUnreadItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed,
                puiItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed,
                puiItemCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Xml(self: *const T, uiItemCount: u32, sortProperty: FEEDS_XML_SORT_PROPERTY, sortOrder: FEEDS_XML_SORT_ORDER, filterFlags: FEEDS_XML_FILTER_FLAGS, includeFlags: FEEDS_XML_INCLUDE_FLAGS, pps: ?*?*IStream) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Xml(@as(*const IXFeed, @ptrCast(self)), uiItemCount, sortProperty, sortOrder, filterFlags, includeFlags, pps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Name(self: *const T, ppszName: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Name(@as(*const IXFeed, @ptrCast(self)), ppszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Rename(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Rename(@as(*const IXFeed, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Url(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Url(@as(*const IXFeed, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_SetUrl(self: *const T, pszUrl: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).SetUrl(@as(*const IXFeed, @ptrCast(self)), pszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_LocalId(self: *const T, pguid: ?*Guid) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).LocalId(@as(*const IXFeed, @ptrCast(self)), pguid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Path(self: *const T, ppszPath: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Path(@as(*const IXFeed, @ptrCast(self)), ppszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Move(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Move(@as(*const IXFeed, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Parent(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Parent(@as(*const IXFeed, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_LastWriteTime(self: *const T, pstLastWriteTime: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).LastWriteTime(@as(*const IXFeed, @ptrCast(self)), pstLastWriteTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Delete(self: *const T) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Delete(@as(*const IXFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Download(self: *const T) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Download(@as(*const IXFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_AsyncDownload(self: *const T) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).AsyncDownload(@as(*const IXFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_CancelAsyncDownload(self: *const T) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).CancelAsyncDownload(@as(*const IXFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_SyncSetting(self: *const T, pfss: ?*FEEDS_SYNC_SETTING) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).SyncSetting(@as(*const IXFeed, @ptrCast(self)), pfss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_SetSyncSetting(self: *const T, fss: FEEDS_SYNC_SETTING) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).SetSyncSetting(@as(*const IXFeed, @ptrCast(self)), fss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Interval(self: *const T, puiInterval: ?*u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Interval(@as(*const IXFeed, @ptrCast(self)), puiInterval);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_SetInterval(self: *const T, uiInterval: u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).SetInterval(@as(*const IXFeed, @ptrCast(self)), uiInterval);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_LastDownloadTime(self: *const T, pstLastDownloadTime: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).LastDownloadTime(@as(*const IXFeed, @ptrCast(self)), pstLastDownloadTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_LocalEnclosurePath(self: *const T, ppszPath: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).LocalEnclosurePath(@as(*const IXFeed, @ptrCast(self)), ppszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Items(self: *const T, ppfe: ?*?*IXFeedsEnum) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Items(@as(*const IXFeed, @ptrCast(self)), ppfe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_GetItem(self: *const T, uiId: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IXFeed, @ptrCast(self)), uiId, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_MarkAllItemsRead(self: *const T) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).MarkAllItemsRead(@as(*const IXFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_MaxItemCount(self: *const T, puiMaxItemCount: ?*u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).MaxItemCount(@as(*const IXFeed, @ptrCast(self)), puiMaxItemCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_SetMaxItemCount(self: *const T, uiMaxItemCount: u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).SetMaxItemCount(@as(*const IXFeed, @ptrCast(self)), uiMaxItemCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_DownloadEnclosuresAutomatically(self: *const T, pbDownloadEnclosuresAutomatically: ?*BOOL) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).DownloadEnclosuresAutomatically(@as(*const IXFeed, @ptrCast(self)), pbDownloadEnclosuresAutomatically);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_SetDownloadEnclosuresAutomatically(self: *const T, bDownloadEnclosuresAutomatically: BOOL) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).SetDownloadEnclosuresAutomatically(@as(*const IXFeed, @ptrCast(self)), bDownloadEnclosuresAutomatically);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_DownloadStatus(self: *const T, pfds: ?*FEEDS_DOWNLOAD_STATUS) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).DownloadStatus(@as(*const IXFeed, @ptrCast(self)), pfds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_LastDownloadError(self: *const T, pfde: ?*FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).LastDownloadError(@as(*const IXFeed, @ptrCast(self)), pfde);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Merge(self: *const T, pStream: ?*IStream, pszUrl: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Merge(@as(*const IXFeed, @ptrCast(self)), pStream, pszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_DownloadUrl(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).DownloadUrl(@as(*const IXFeed, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Title(self: *const T, ppszTitle: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Title(@as(*const IXFeed, @ptrCast(self)), ppszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Description(self: *const T, ppszDescription: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Description(@as(*const IXFeed, @ptrCast(self)), ppszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Link(self: *const T, ppszHomePage: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Link(@as(*const IXFeed, @ptrCast(self)), ppszHomePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Image(self: *const T, ppszImageUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Image(@as(*const IXFeed, @ptrCast(self)), ppszImageUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_LastBuildDate(self: *const T, pstLastBuildDate: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).LastBuildDate(@as(*const IXFeed, @ptrCast(self)), pstLastBuildDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_PubDate(self: *const T, pstPubDate: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).PubDate(@as(*const IXFeed, @ptrCast(self)), pstPubDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Ttl(self: *const T, puiTtl: ?*u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Ttl(@as(*const IXFeed, @ptrCast(self)), puiTtl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Language(self: *const T, ppszLanguage: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Language(@as(*const IXFeed, @ptrCast(self)), ppszLanguage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_Copyright(self: *const T, ppszCopyright: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).Copyright(@as(*const IXFeed, @ptrCast(self)), ppszCopyright);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_IsList(self: *const T, pbIsList: ?*BOOL) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).IsList(@as(*const IXFeed, @ptrCast(self)), pbIsList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_GetWatcher(self: *const T, scope: FEEDS_EVENTS_SCOPE, mask: FEEDS_EVENTS_MASK, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).GetWatcher(@as(*const IXFeed, @ptrCast(self)), scope, mask, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_UnreadItemCount(self: *const T, puiUnreadItemCount: ?*u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).UnreadItemCount(@as(*const IXFeed, @ptrCast(self)), puiUnreadItemCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed_ItemCount(self: *const T, puiItemCount: ?*u32) HRESULT {
                return @as(*const IXFeed.VTable, @ptrCast(self.vtable)).ItemCount(@as(*const IXFeed, @ptrCast(self)), puiItemCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeed2_Value = Guid.initString("ce528e77-3716-4eb7-956d-f5e37502e12a");
pub const IID_IXFeed2 = &IID_IXFeed2_Value;
pub const IXFeed2 = extern struct {
    pub const VTable = extern struct {
        base: IXFeed.VTable,
        GetItemByEffectiveId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed2,
                uiEffectiveId: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed2,
                uiEffectiveId: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastItemDownloadTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed2,
                pstLastItemDownloadTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed2,
                pstLastItemDownloadTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Username: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed2,
                ppszUsername: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed2,
                ppszUsername: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Password: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed2,
                ppszPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed2,
                ppszPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed2,
                pszUsername: ?[*:0]const u16,
                pszPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed2,
                pszUsername: ?[*:0]const u16,
                pszPassword: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeed2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeed2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXFeed.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed2_GetItemByEffectiveId(self: *const T, uiEffectiveId: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeed2.VTable, @ptrCast(self.vtable)).GetItemByEffectiveId(@as(*const IXFeed2, @ptrCast(self)), uiEffectiveId, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed2_LastItemDownloadTime(self: *const T, pstLastItemDownloadTime: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeed2.VTable, @ptrCast(self.vtable)).LastItemDownloadTime(@as(*const IXFeed2, @ptrCast(self)), pstLastItemDownloadTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed2_Username(self: *const T, ppszUsername: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed2.VTable, @ptrCast(self.vtable)).Username(@as(*const IXFeed2, @ptrCast(self)), ppszUsername);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed2_Password(self: *const T, ppszPassword: ?*?PWSTR) HRESULT {
                return @as(*const IXFeed2.VTable, @ptrCast(self.vtable)).Password(@as(*const IXFeed2, @ptrCast(self)), ppszPassword);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed2_SetCredentials(self: *const T, pszUsername: ?[*:0]const u16, pszPassword: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeed2.VTable, @ptrCast(self.vtable)).SetCredentials(@as(*const IXFeed2, @ptrCast(self)), pszUsername, pszPassword);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeed2_ClearCredentials(self: *const T) HRESULT {
                return @as(*const IXFeed2.VTable, @ptrCast(self.vtable)).ClearCredentials(@as(*const IXFeed2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedEvents_Value = Guid.initString("1630852e-1263-465b-98e5-fe60ffec4ac2");
pub const IID_IXFeedEvents = &IID_IXFeedEvents_Value;
pub const IXFeedEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedUrlChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedMoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                pszOldPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloading: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloadCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                fde: FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                fde: FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedItemCountChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                feicfFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEvents,
                pszPath: ?[*:0]const u16,
                feicfFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_Error(self: *const T) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).Error(@as(*const IXFeedEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedDeleted(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedDeleted(@as(*const IXFeedEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedRenamed(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedRenamed(@as(*const IXFeedEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedUrlChanged(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedUrlChanged(@as(*const IXFeedEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedMoved(self: *const T, pszPath: ?[*:0]const u16, pszOldPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedMoved(@as(*const IXFeedEvents, @ptrCast(self)), pszPath, pszOldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedDownloading(self: *const T, pszPath: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedDownloading(@as(*const IXFeedEvents, @ptrCast(self)), pszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedDownloadCompleted(self: *const T, pszPath: ?[*:0]const u16, fde: FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedDownloadCompleted(@as(*const IXFeedEvents, @ptrCast(self)), pszPath, fde);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEvents_FeedItemCountChanged(self: *const T, pszPath: ?[*:0]const u16, feicfFlags: i32) HRESULT {
                return @as(*const IXFeedEvents.VTable, @ptrCast(self.vtable)).FeedItemCountChanged(@as(*const IXFeedEvents, @ptrCast(self)), pszPath, feicfFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedItem_Value = Guid.initString("e757b2f5-e73e-434e-a1bf-2bd7c3e60fcb");
pub const IID_IXFeedItem = &IID_IXFeedItem_Value;
pub const IXFeedItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Xml: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                fxif: FEEDS_XML_INCLUDE_FLAGS,
                pps: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                fxif: FEEDS_XML_INCLUDE_FLAGS,
                pps: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Title: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Link: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Guid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszGuid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszGuid: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Description: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PubDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                pstPubDate: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                pstPubDate: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Comments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Author: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszAuthor: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszAuthor: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enclosure: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                pbIsRead: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                pbIsRead: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIsRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                bIsRead: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                bIsRead: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LocalId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                puiId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                puiId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Parent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastDownloadTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                pstLastDownloadTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                pstLastDownloadTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Modified: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem,
                pstModifiedTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem,
                pstModifiedTime: ?*SYSTEMTIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Xml(self: *const T, fxif: FEEDS_XML_INCLUDE_FLAGS, pps: ?*?*IStream) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Xml(@as(*const IXFeedItem, @ptrCast(self)), fxif, pps);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Title(self: *const T, ppszTitle: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Title(@as(*const IXFeedItem, @ptrCast(self)), ppszTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Link(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Link(@as(*const IXFeedItem, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Guid(self: *const T, ppszGuid: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Guid(@as(*const IXFeedItem, @ptrCast(self)), ppszGuid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Description(self: *const T, ppszDescription: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Description(@as(*const IXFeedItem, @ptrCast(self)), ppszDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_PubDate(self: *const T, pstPubDate: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).PubDate(@as(*const IXFeedItem, @ptrCast(self)), pstPubDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Comments(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Comments(@as(*const IXFeedItem, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Author(self: *const T, ppszAuthor: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Author(@as(*const IXFeedItem, @ptrCast(self)), ppszAuthor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Enclosure(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Enclosure(@as(*const IXFeedItem, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_IsRead(self: *const T, pbIsRead: ?*BOOL) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).IsRead(@as(*const IXFeedItem, @ptrCast(self)), pbIsRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_SetIsRead(self: *const T, bIsRead: BOOL) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).SetIsRead(@as(*const IXFeedItem, @ptrCast(self)), bIsRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_LocalId(self: *const T, puiId: ?*u32) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).LocalId(@as(*const IXFeedItem, @ptrCast(self)), puiId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Parent(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Parent(@as(*const IXFeedItem, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Delete(self: *const T) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Delete(@as(*const IXFeedItem, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_DownloadUrl(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).DownloadUrl(@as(*const IXFeedItem, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_LastDownloadTime(self: *const T, pstLastDownloadTime: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).LastDownloadTime(@as(*const IXFeedItem, @ptrCast(self)), pstLastDownloadTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem_Modified(self: *const T, pstModifiedTime: ?*SYSTEMTIME) HRESULT {
                return @as(*const IXFeedItem.VTable, @ptrCast(self.vtable)).Modified(@as(*const IXFeedItem, @ptrCast(self)), pstModifiedTime);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedItem2_Value = Guid.initString("6cda2dc7-9013-4522-9970-2a9dd9ead5a3");
pub const IID_IXFeedItem2 = &IID_IXFeedItem2_Value;
pub const IXFeedItem2 = extern struct {
    pub const VTable = extern struct {
        base: IXFeedItem.VTable,
        EffectiveId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedItem2,
                puiEffectiveId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedItem2,
                puiEffectiveId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IXFeedItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedItem2_EffectiveId(self: *const T, puiEffectiveId: ?*u32) HRESULT {
                return @as(*const IXFeedItem2.VTable, @ptrCast(self.vtable)).EffectiveId(@as(*const IXFeedItem2, @ptrCast(self)), puiEffectiveId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IXFeedEnclosure_Value = Guid.initString("bfbfb953-644f-4792-b69c-dfaca4cbf89a");
pub const IID_IXFeedEnclosure = &IID_IXFeedEnclosure_Value;
pub const IXFeedEnclosure = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Url: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Type: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                ppszMimeType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                ppszMimeType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Length: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                puiLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                puiLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                pfds: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                pfds: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LastDownloadError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                pfde: ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                pfde: ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LocalPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                ppszPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Parent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                ppszUrl: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadMimeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                ppszMimeType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                ppszMimeType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IXFeedEnclosure,
                pszDownloadUrl: ?[*:0]const u16,
                pszDownloadFilePath: ?[*:0]const u16,
                pszDownloadMimeType: ?[*:0]const u16,
                pszEnclosureFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IXFeedEnclosure,
                pszDownloadUrl: ?[*:0]const u16,
                pszDownloadFilePath: ?[*:0]const u16,
                pszDownloadMimeType: ?[*:0]const u16,
                pszEnclosureFilename: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_Url(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).Url(@as(*const IXFeedEnclosure, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_Type(self: *const T, ppszMimeType: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).Type(@as(*const IXFeedEnclosure, @ptrCast(self)), ppszMimeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_Length(self: *const T, puiLength: ?*u32) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).Length(@as(*const IXFeedEnclosure, @ptrCast(self)), puiLength);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_AsyncDownload(self: *const T) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).AsyncDownload(@as(*const IXFeedEnclosure, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_CancelAsyncDownload(self: *const T) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).CancelAsyncDownload(@as(*const IXFeedEnclosure, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_DownloadStatus(self: *const T, pfds: ?*FEEDS_DOWNLOAD_STATUS) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).DownloadStatus(@as(*const IXFeedEnclosure, @ptrCast(self)), pfds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_LastDownloadError(self: *const T, pfde: ?*FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).LastDownloadError(@as(*const IXFeedEnclosure, @ptrCast(self)), pfde);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_LocalPath(self: *const T, ppszPath: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).LocalPath(@as(*const IXFeedEnclosure, @ptrCast(self)), ppszPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_Parent(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).Parent(@as(*const IXFeedEnclosure, @ptrCast(self)), riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_DownloadUrl(self: *const T, ppszUrl: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).DownloadUrl(@as(*const IXFeedEnclosure, @ptrCast(self)), ppszUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_DownloadMimeType(self: *const T, ppszMimeType: ?*?PWSTR) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).DownloadMimeType(@as(*const IXFeedEnclosure, @ptrCast(self)), ppszMimeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_RemoveFile(self: *const T) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).RemoveFile(@as(*const IXFeedEnclosure, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IXFeedEnclosure_SetFile(self: *const T, pszDownloadUrl: ?[*:0]const u16, pszDownloadFilePath: ?[*:0]const u16, pszDownloadMimeType: ?[*:0]const u16, pszEnclosureFilename: ?[*:0]const u16) HRESULT {
                return @as(*const IXFeedEnclosure.VTable, @ptrCast(self.vtable)).SetFile(@as(*const IXFeedEnclosure, @ptrCast(self)), pszDownloadUrl, pszDownloadFilePath, pszDownloadMimeType, pszEnclosureFilename);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedsManager_Value = Guid.initString("a74029cc-1f1a-4906-88f0-810638d86591");
pub const IID_IFeedsManager = &IID_IFeedsManager_Value;
pub const IFeedsManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootFolder: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsManager,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsManager,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSubscribed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                feedUrl: ?BSTR,
                subscribed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                feedUrl: ?BSTR,
                subscribed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                feedPath: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                feedPath: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                feedPath: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                feedPath: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeedByUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                feedUrl: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                feedUrl: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                folderPath: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                folderPath: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                folderPath: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                folderPath: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                feedPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                feedPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                folderPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                folderPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackgroundSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                action: FEEDS_BACKGROUNDSYNC_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                action: FEEDS_BACKGROUNDSYNC_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundSyncStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsManager,
                status: ?*FEEDS_BACKGROUNDSYNC_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsManager,
                status: ?*FEEDS_BACKGROUNDSYNC_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultInterval: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsManager,
                minutes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsManager,
                minutes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultInterval: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsManager,
                minutes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsManager,
                minutes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncSyncAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Normalize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsManager,
                feedXmlIn: ?BSTR,
                feedXmlOut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsManager,
                feedXmlIn: ?BSTR,
                feedXmlOut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemCountLimit: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsManager,
                itemCountLimit: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsManager,
                itemCountLimit: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_get_RootFolder(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).get_RootFolder(@as(*const IFeedsManager, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_IsSubscribed(self: *const T, feedUrl: ?BSTR, subscribed: ?*i16) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).IsSubscribed(@as(*const IFeedsManager, @ptrCast(self)), feedUrl, subscribed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_ExistsFeed(self: *const T, feedPath: ?BSTR, exists: ?*i16) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).ExistsFeed(@as(*const IFeedsManager, @ptrCast(self)), feedPath, exists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_GetFeed(self: *const T, feedPath: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).GetFeed(@as(*const IFeedsManager, @ptrCast(self)), feedPath, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_GetFeedByUrl(self: *const T, feedUrl: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).GetFeedByUrl(@as(*const IFeedsManager, @ptrCast(self)), feedUrl, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_ExistsFolder(self: *const T, folderPath: ?BSTR, exists: ?*i16) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).ExistsFolder(@as(*const IFeedsManager, @ptrCast(self)), folderPath, exists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_GetFolder(self: *const T, folderPath: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).GetFolder(@as(*const IFeedsManager, @ptrCast(self)), folderPath, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_DeleteFeed(self: *const T, feedPath: ?BSTR) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).DeleteFeed(@as(*const IFeedsManager, @ptrCast(self)), feedPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_DeleteFolder(self: *const T, folderPath: ?BSTR) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).DeleteFolder(@as(*const IFeedsManager, @ptrCast(self)), folderPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_BackgroundSync(self: *const T, action: FEEDS_BACKGROUNDSYNC_ACTION) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).BackgroundSync(@as(*const IFeedsManager, @ptrCast(self)), action);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_get_BackgroundSyncStatus(self: *const T, status: ?*FEEDS_BACKGROUNDSYNC_STATUS) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).get_BackgroundSyncStatus(@as(*const IFeedsManager, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_get_DefaultInterval(self: *const T, minutes: ?*i32) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).get_DefaultInterval(@as(*const IFeedsManager, @ptrCast(self)), minutes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_put_DefaultInterval(self: *const T, minutes: i32) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).put_DefaultInterval(@as(*const IFeedsManager, @ptrCast(self)), minutes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_AsyncSyncAll(self: *const T) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).AsyncSyncAll(@as(*const IFeedsManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_Normalize(self: *const T, feedXmlIn: ?BSTR, feedXmlOut: ?*?BSTR) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).Normalize(@as(*const IFeedsManager, @ptrCast(self)), feedXmlIn, feedXmlOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsManager_get_ItemCountLimit(self: *const T, itemCountLimit: ?*i32) HRESULT {
                return @as(*const IFeedsManager.VTable, @ptrCast(self.vtable)).get_ItemCountLimit(@as(*const IFeedsManager, @ptrCast(self)), itemCountLimit);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedsEnum_Value = Guid.initString("e3cd0028-2eed-4c60-8fae-a3225309a836");
pub const IID_IFeedsEnum = &IID_IFeedsEnum_Value;
pub const IFeedsEnum = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsEnum,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsEnum,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedsEnum,
                index: i32,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedsEnum,
                index: i32,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedsEnum,
                enumVar: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedsEnum,
                enumVar: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsEnum_get_Count(self: *const T, count: ?*i32) HRESULT {
                return @as(*const IFeedsEnum.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IFeedsEnum, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsEnum_Item(self: *const T, index: i32, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedsEnum.VTable, @ptrCast(self.vtable)).Item(@as(*const IFeedsEnum, @ptrCast(self)), index, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedsEnum_get__NewEnum(self: *const T, enumVar: ?*?*IEnumVARIANT) HRESULT {
                return @as(*const IFeedsEnum.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IFeedsEnum, @ptrCast(self)), enumVar);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedFolder_Value = Guid.initString("81f04ad1-4194-4d7d-86d6-11813cec163c");
pub const IID_IFeedFolder = &IID_IFeedFolder_Value;
pub const IFeedFolder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Feeds: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subfolders: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                feedName: ?BSTR,
                feedUrl: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                feedName: ?BSTR,
                feedUrl: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSubfolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                feedName: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                feedName: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                feedName: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                feedName: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExistsSubfolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
                exists: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubfolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                folderName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                folderName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                folderName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                folderPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                folderPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                newParentPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                newParentPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRoot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                isRoot: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                isRoot: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalUnreadItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedFolder,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedFolder,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolder,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolder,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_Feeds(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_Feeds(@as(*const IFeedFolder, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_Subfolders(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_Subfolders(@as(*const IFeedFolder, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_CreateFeed(self: *const T, feedName: ?BSTR, feedUrl: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).CreateFeed(@as(*const IFeedFolder, @ptrCast(self)), feedName, feedUrl, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_CreateSubfolder(self: *const T, folderName: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).CreateSubfolder(@as(*const IFeedFolder, @ptrCast(self)), folderName, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_ExistsFeed(self: *const T, feedName: ?BSTR, exists: ?*i16) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).ExistsFeed(@as(*const IFeedFolder, @ptrCast(self)), feedName, exists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_GetFeed(self: *const T, feedName: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).GetFeed(@as(*const IFeedFolder, @ptrCast(self)), feedName, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_ExistsSubfolder(self: *const T, folderName: ?BSTR, exists: ?*i16) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).ExistsSubfolder(@as(*const IFeedFolder, @ptrCast(self)), folderName, exists);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_GetSubfolder(self: *const T, folderName: ?BSTR, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).GetSubfolder(@as(*const IFeedFolder, @ptrCast(self)), folderName, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_Delete(self: *const T) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).Delete(@as(*const IFeedFolder, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_Name(self: *const T, folderName: ?*?BSTR) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFeedFolder, @ptrCast(self)), folderName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_Rename(self: *const T, folderName: ?BSTR) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).Rename(@as(*const IFeedFolder, @ptrCast(self)), folderName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_Path(self: *const T, folderPath: ?*?BSTR) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IFeedFolder, @ptrCast(self)), folderPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_Move(self: *const T, newParentPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).Move(@as(*const IFeedFolder, @ptrCast(self)), newParentPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_Parent(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IFeedFolder, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_IsRoot(self: *const T, isRoot: ?*i16) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_IsRoot(@as(*const IFeedFolder, @ptrCast(self)), isRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_TotalUnreadItemCount(self: *const T, count: ?*i32) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_TotalUnreadItemCount(@as(*const IFeedFolder, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_get_TotalItemCount(self: *const T, count: ?*i32) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).get_TotalItemCount(@as(*const IFeedFolder, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolder_GetWatcher(self: *const T, scope: FEEDS_EVENTS_SCOPE, mask: FEEDS_EVENTS_MASK, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedFolder.VTable, @ptrCast(self.vtable)).GetWatcher(@as(*const IFeedFolder, @ptrCast(self)), scope, mask, disp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedFolderEvents_Value = Guid.initString("20a59fa6-a844-4630-9e98-175f70b4d55b");
pub const IID_IFeedFolderEvents = &IID_IFeedFolderEvents_Value;
pub const IFeedFolderEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderMovedFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderMovedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FolderItemCountChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                itemCountType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                itemCountType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedUrlChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedMovedFrom: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedMovedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloading: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloadCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                @"error": FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                @"error": FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedItemCountChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                itemCountType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedFolderEvents,
                path: ?BSTR,
                itemCountType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_Error(self: *const T) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).Error(@as(*const IFeedFolderEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FolderAdded(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderAdded(@as(*const IFeedFolderEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FolderDeleted(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderDeleted(@as(*const IFeedFolderEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FolderRenamed(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderRenamed(@as(*const IFeedFolderEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FolderMovedFrom(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderMovedFrom(@as(*const IFeedFolderEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FolderMovedTo(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderMovedTo(@as(*const IFeedFolderEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FolderItemCountChanged(self: *const T, path: ?BSTR, itemCountType: i32) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FolderItemCountChanged(@as(*const IFeedFolderEvents, @ptrCast(self)), path, itemCountType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedAdded(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedAdded(@as(*const IFeedFolderEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedDeleted(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedDeleted(@as(*const IFeedFolderEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedRenamed(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedRenamed(@as(*const IFeedFolderEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedUrlChanged(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedUrlChanged(@as(*const IFeedFolderEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedMovedFrom(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedMovedFrom(@as(*const IFeedFolderEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedMovedTo(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedMovedTo(@as(*const IFeedFolderEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedDownloading(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedDownloading(@as(*const IFeedFolderEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedDownloadCompleted(self: *const T, path: ?BSTR, @"error": FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedDownloadCompleted(@as(*const IFeedFolderEvents, @ptrCast(self)), path, @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedFolderEvents_FeedItemCountChanged(self: *const T, path: ?BSTR, itemCountType: i32) HRESULT {
                return @as(*const IFeedFolderEvents.VTable, @ptrCast(self.vtable)).FeedItemCountChanged(@as(*const IFeedFolderEvents, @ptrCast(self)), path, itemCountType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeed_Value = Guid.initString("f7f915d8-2ede-42bc-98e7-a5d05063a757");
pub const IID_IFeed = &IID_IFeed_Value;
pub const IFeed = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Xml: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
                count: i32,
                sortProperty: FEEDS_XML_SORT_PROPERTY,
                sortOrder: FEEDS_XML_SORT_ORDER,
                filterFlags: FEEDS_XML_FILTER_FLAGS,
                includeFlags: FEEDS_XML_INCLUDE_FLAGS,
                xml: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
                count: i32,
                sortProperty: FEEDS_XML_SORT_PROPERTY,
                sortOrder: FEEDS_XML_SORT_ORDER,
                filterFlags: FEEDS_XML_FILTER_FLAGS,
                includeFlags: FEEDS_XML_INCLUDE_FLAGS,
                xml: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                feedUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                feedUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                feedUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                feedUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                feedGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                feedGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Move: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
                newParentPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
                newParentPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastWriteTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                lastWrite: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                lastWrite: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SyncSetting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                syncSetting: ?*FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                syncSetting: ?*FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SyncSetting: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                syncSetting: FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                syncSetting: FEEDS_SYNC_SETTING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Interval: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                minutes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                minutes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Interval: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                minutes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                minutes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastDownloadTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                lastDownload: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                lastDownload: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalEnclosurePath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Items: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
                itemId: i32,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
                itemId: i32,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                title: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                title: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Link: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                homePage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                homePage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Image: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                imageUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                imageUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastBuildDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                lastBuildDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                lastBuildDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PubDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                lastPopulateDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                lastPopulateDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Ttl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                ttl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                ttl: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                language: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                language: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Copyright: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                copyright: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                copyright: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                count: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                count: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadEnclosuresAutomatically: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                downloadEnclosuresAutomatically: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                downloadEnclosuresAutomatically: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DownloadEnclosuresAutomatically: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                downloadEnclosuresAutomatically: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                downloadEnclosuresAutomatically: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                status: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                status: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastDownloadError: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                @"error": ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                @"error": ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Merge: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
                feedXml: ?BSTR,
                feedUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
                feedXml: ?BSTR,
                feedUrl: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                feedUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                feedUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsList: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                isList: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                isList: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MarkAllItemsRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed,
                scope: FEEDS_EVENTS_SCOPE,
                mask: FEEDS_EVENTS_MASK,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UnreadItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ItemCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed,
                count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_Xml(self: *const T, count: i32, sortProperty: FEEDS_XML_SORT_PROPERTY, sortOrder: FEEDS_XML_SORT_ORDER, filterFlags: FEEDS_XML_FILTER_FLAGS, includeFlags: FEEDS_XML_INCLUDE_FLAGS, xml: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).Xml(@as(*const IFeed, @ptrCast(self)), count, sortProperty, sortOrder, filterFlags, includeFlags, xml);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Name(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFeed, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_Rename(self: *const T, name: ?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).Rename(@as(*const IFeed, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Url(self: *const T, feedUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Url(@as(*const IFeed, @ptrCast(self)), feedUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_put_Url(self: *const T, feedUrl: ?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).put_Url(@as(*const IFeed, @ptrCast(self)), feedUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_LocalId(self: *const T, feedGuid: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_LocalId(@as(*const IFeed, @ptrCast(self)), feedGuid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Path(self: *const T, path: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Path(@as(*const IFeed, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_Move(self: *const T, newParentPath: ?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).Move(@as(*const IFeed, @ptrCast(self)), newParentPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Parent(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IFeed, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_LastWriteTime(self: *const T, lastWrite: ?*f64) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_LastWriteTime(@as(*const IFeed, @ptrCast(self)), lastWrite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_Delete(self: *const T) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).Delete(@as(*const IFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_Download(self: *const T) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).Download(@as(*const IFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_AsyncDownload(self: *const T) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).AsyncDownload(@as(*const IFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_CancelAsyncDownload(self: *const T) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).CancelAsyncDownload(@as(*const IFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_SyncSetting(self: *const T, syncSetting: ?*FEEDS_SYNC_SETTING) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_SyncSetting(@as(*const IFeed, @ptrCast(self)), syncSetting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_put_SyncSetting(self: *const T, syncSetting: FEEDS_SYNC_SETTING) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).put_SyncSetting(@as(*const IFeed, @ptrCast(self)), syncSetting);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Interval(self: *const T, minutes: ?*i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Interval(@as(*const IFeed, @ptrCast(self)), minutes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_put_Interval(self: *const T, minutes: i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).put_Interval(@as(*const IFeed, @ptrCast(self)), minutes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_LastDownloadTime(self: *const T, lastDownload: ?*f64) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_LastDownloadTime(@as(*const IFeed, @ptrCast(self)), lastDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_LocalEnclosurePath(self: *const T, path: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_LocalEnclosurePath(@as(*const IFeed, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Items(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Items(@as(*const IFeed, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_GetItem(self: *const T, itemId: i32, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IFeed, @ptrCast(self)), itemId, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Title(self: *const T, title: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IFeed, @ptrCast(self)), title);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Description(self: *const T, description: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IFeed, @ptrCast(self)), description);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Link(self: *const T, homePage: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Link(@as(*const IFeed, @ptrCast(self)), homePage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Image(self: *const T, imageUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Image(@as(*const IFeed, @ptrCast(self)), imageUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_LastBuildDate(self: *const T, lastBuildDate: ?*f64) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_LastBuildDate(@as(*const IFeed, @ptrCast(self)), lastBuildDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_PubDate(self: *const T, lastPopulateDate: ?*f64) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_PubDate(@as(*const IFeed, @ptrCast(self)), lastPopulateDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Ttl(self: *const T, ttl: ?*i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Ttl(@as(*const IFeed, @ptrCast(self)), ttl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Language(self: *const T, language: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Language(@as(*const IFeed, @ptrCast(self)), language);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_Copyright(self: *const T, copyright: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_Copyright(@as(*const IFeed, @ptrCast(self)), copyright);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_MaxItemCount(self: *const T, count: ?*i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_MaxItemCount(@as(*const IFeed, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_put_MaxItemCount(self: *const T, count: i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).put_MaxItemCount(@as(*const IFeed, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_DownloadEnclosuresAutomatically(self: *const T, downloadEnclosuresAutomatically: ?*i16) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_DownloadEnclosuresAutomatically(@as(*const IFeed, @ptrCast(self)), downloadEnclosuresAutomatically);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_put_DownloadEnclosuresAutomatically(self: *const T, downloadEnclosuresAutomatically: i16) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).put_DownloadEnclosuresAutomatically(@as(*const IFeed, @ptrCast(self)), downloadEnclosuresAutomatically);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_DownloadStatus(self: *const T, status: ?*FEEDS_DOWNLOAD_STATUS) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_DownloadStatus(@as(*const IFeed, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_LastDownloadError(self: *const T, @"error": ?*FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_LastDownloadError(@as(*const IFeed, @ptrCast(self)), @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_Merge(self: *const T, feedXml: ?BSTR, feedUrl: ?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).Merge(@as(*const IFeed, @ptrCast(self)), feedXml, feedUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_DownloadUrl(self: *const T, feedUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_DownloadUrl(@as(*const IFeed, @ptrCast(self)), feedUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_IsList(self: *const T, isList: ?*i16) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_IsList(@as(*const IFeed, @ptrCast(self)), isList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_MarkAllItemsRead(self: *const T) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).MarkAllItemsRead(@as(*const IFeed, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_GetWatcher(self: *const T, scope: FEEDS_EVENTS_SCOPE, mask: FEEDS_EVENTS_MASK, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).GetWatcher(@as(*const IFeed, @ptrCast(self)), scope, mask, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_UnreadItemCount(self: *const T, count: ?*i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_UnreadItemCount(@as(*const IFeed, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed_get_ItemCount(self: *const T, count: ?*i32) HRESULT {
                return @as(*const IFeed.VTable, @ptrCast(self.vtable)).get_ItemCount(@as(*const IFeed, @ptrCast(self)), count);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeed2_Value = Guid.initString("33f2ea09-1398-4ab9-b6a4-f94b49d0a42e");
pub const IID_IFeed2 = &IID_IFeed2_Value;
pub const IFeed2 = extern struct {
    pub const VTable = extern struct {
        base: IFeed.VTable,
        GetItemByEffectiveId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed2,
                itemEffectiveId: i32,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed2,
                itemEffectiveId: i32,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastItemDownloadTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed2,
                lastItemDownloadTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed2,
                lastItemDownloadTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Username: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed2,
                username: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed2,
                username: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Password: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeed2,
                password: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeed2,
                password: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed2,
                username: ?BSTR,
                password: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed2,
                username: ?BSTR,
                password: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearCredentials: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeed2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeed2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFeed.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed2_GetItemByEffectiveId(self: *const T, itemEffectiveId: i32, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeed2.VTable, @ptrCast(self.vtable)).GetItemByEffectiveId(@as(*const IFeed2, @ptrCast(self)), itemEffectiveId, disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed2_get_LastItemDownloadTime(self: *const T, lastItemDownloadTime: ?*f64) HRESULT {
                return @as(*const IFeed2.VTable, @ptrCast(self.vtable)).get_LastItemDownloadTime(@as(*const IFeed2, @ptrCast(self)), lastItemDownloadTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed2_get_Username(self: *const T, username: ?*?BSTR) HRESULT {
                return @as(*const IFeed2.VTable, @ptrCast(self.vtable)).get_Username(@as(*const IFeed2, @ptrCast(self)), username);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed2_get_Password(self: *const T, password: ?*?BSTR) HRESULT {
                return @as(*const IFeed2.VTable, @ptrCast(self.vtable)).get_Password(@as(*const IFeed2, @ptrCast(self)), password);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed2_SetCredentials(self: *const T, username: ?BSTR, password: ?BSTR) HRESULT {
                return @as(*const IFeed2.VTable, @ptrCast(self.vtable)).SetCredentials(@as(*const IFeed2, @ptrCast(self)), username, password);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeed2_ClearCredentials(self: *const T) HRESULT {
                return @as(*const IFeed2.VTable, @ptrCast(self.vtable)).ClearCredentials(@as(*const IFeed2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedEvents_Value = Guid.initString("abf35c99-0681-47ea-9a8c-1436a375a99e");
pub const IID_IFeedEvents = &IID_IFeedEvents_Value;
pub const IFeedEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Error: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedRenamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedUrlChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedMoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                oldPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloading: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedDownloadCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                @"error": FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                @"error": FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FeedItemCountChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                itemCountType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEvents,
                path: ?BSTR,
                itemCountType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_Error(self: *const T) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).Error(@as(*const IFeedEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedDeleted(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedDeleted(@as(*const IFeedEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedRenamed(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedRenamed(@as(*const IFeedEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedUrlChanged(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedUrlChanged(@as(*const IFeedEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedMoved(self: *const T, path: ?BSTR, oldPath: ?BSTR) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedMoved(@as(*const IFeedEvents, @ptrCast(self)), path, oldPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedDownloading(self: *const T, path: ?BSTR) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedDownloading(@as(*const IFeedEvents, @ptrCast(self)), path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedDownloadCompleted(self: *const T, path: ?BSTR, @"error": FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedDownloadCompleted(@as(*const IFeedEvents, @ptrCast(self)), path, @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEvents_FeedItemCountChanged(self: *const T, path: ?BSTR, itemCountType: i32) HRESULT {
                return @as(*const IFeedEvents.VTable, @ptrCast(self.vtable)).FeedItemCountChanged(@as(*const IFeedEvents, @ptrCast(self)), path, itemCountType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedItem_Value = Guid.initString("0a1e6cad-0a47-4da2-a13d-5baaa5c8bd4f");
pub const IID_IFeedItem = &IID_IFeedItem_Value;
pub const IFeedItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Xml: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedItem,
                includeFlags: FEEDS_XML_INCLUDE_FLAGS,
                xml: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedItem,
                includeFlags: FEEDS_XML_INCLUDE_FLAGS,
                xml: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                title: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                title: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Link: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                linkUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                linkUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guid: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                itemGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                itemGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PubDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                pubDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                pubDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Comments: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                comments: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                comments: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Author: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                author: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                author: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enclosure: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRead: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                isRead: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                isRead: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IsRead: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                isRead: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                isRead: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                itemId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                itemId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                itemUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                itemUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastDownloadTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                lastDownload: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                lastDownload: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Modified: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem,
                modified: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem,
                modified: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_Xml(self: *const T, includeFlags: FEEDS_XML_INCLUDE_FLAGS, xml: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).Xml(@as(*const IFeedItem, @ptrCast(self)), includeFlags, xml);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Title(self: *const T, title: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IFeedItem, @ptrCast(self)), title);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Link(self: *const T, linkUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Link(@as(*const IFeedItem, @ptrCast(self)), linkUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Guid(self: *const T, itemGuid: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Guid(@as(*const IFeedItem, @ptrCast(self)), itemGuid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Description(self: *const T, description: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IFeedItem, @ptrCast(self)), description);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_PubDate(self: *const T, pubDate: ?*f64) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_PubDate(@as(*const IFeedItem, @ptrCast(self)), pubDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Comments(self: *const T, comments: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Comments(@as(*const IFeedItem, @ptrCast(self)), comments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Author(self: *const T, author: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Author(@as(*const IFeedItem, @ptrCast(self)), author);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Enclosure(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Enclosure(@as(*const IFeedItem, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_IsRead(self: *const T, isRead: ?*i16) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_IsRead(@as(*const IFeedItem, @ptrCast(self)), isRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_put_IsRead(self: *const T, isRead: i16) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).put_IsRead(@as(*const IFeedItem, @ptrCast(self)), isRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_LocalId(self: *const T, itemId: ?*i32) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_LocalId(@as(*const IFeedItem, @ptrCast(self)), itemId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Parent(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IFeedItem, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_Delete(self: *const T) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).Delete(@as(*const IFeedItem, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_DownloadUrl(self: *const T, itemUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_DownloadUrl(@as(*const IFeedItem, @ptrCast(self)), itemUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_LastDownloadTime(self: *const T, lastDownload: ?*f64) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_LastDownloadTime(@as(*const IFeedItem, @ptrCast(self)), lastDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem_get_Modified(self: *const T, modified: ?*f64) HRESULT {
                return @as(*const IFeedItem.VTable, @ptrCast(self.vtable)).get_Modified(@as(*const IFeedItem, @ptrCast(self)), modified);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedItem2_Value = Guid.initString("79ac9ef4-f9c1-4d2b-a50b-a7ffba4dcf37");
pub const IID_IFeedItem2 = &IID_IFeedItem2_Value;
pub const IFeedItem2 = extern struct {
    pub const VTable = extern struct {
        base: IFeedItem.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EffectiveId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedItem2,
                effectiveId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedItem2,
                effectiveId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IFeedItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedItem2_get_EffectiveId(self: *const T, effectiveId: ?*i32) HRESULT {
                return @as(*const IFeedItem2.VTable, @ptrCast(self.vtable)).get_EffectiveId(@as(*const IFeedItem2, @ptrCast(self)), effectiveId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IFeedEnclosure_Value = Guid.initString("361c26f7-90a4-4e67-ae09-3a36a546436a");
pub const IID_IFeedEnclosure = &IID_IFeedEnclosure_Value;
pub const IFeedEnclosure = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Url: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                enclosureUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                enclosureUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                mimeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                mimeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                length: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelAsyncDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadStatus: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                status: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                status: ?*FEEDS_DOWNLOAD_STATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LastDownloadError: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                @"error": ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                @"error": ?*FEEDS_DOWNLOAD_ERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalPath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                localPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                localPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Parent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                disp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                enclosureUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                enclosureUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadMimeType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IFeedEnclosure,
                mimeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IFeedEnclosure,
                mimeType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEnclosure,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IFeedEnclosure,
                downloadUrl: ?BSTR,
                downloadFilePath: ?BSTR,
                downloadMimeType: ?BSTR,
                enclosureFilename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IFeedEnclosure,
                downloadUrl: ?BSTR,
                downloadFilePath: ?BSTR,
                downloadMimeType: ?BSTR,
                enclosureFilename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_Url(self: *const T, enclosureUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_Url(@as(*const IFeedEnclosure, @ptrCast(self)), enclosureUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_Type(self: *const T, mimeType: ?*?BSTR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IFeedEnclosure, @ptrCast(self)), mimeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_Length(self: *const T, length: ?*i32) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_Length(@as(*const IFeedEnclosure, @ptrCast(self)), length);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_AsyncDownload(self: *const T) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).AsyncDownload(@as(*const IFeedEnclosure, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_CancelAsyncDownload(self: *const T) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).CancelAsyncDownload(@as(*const IFeedEnclosure, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_DownloadStatus(self: *const T, status: ?*FEEDS_DOWNLOAD_STATUS) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_DownloadStatus(@as(*const IFeedEnclosure, @ptrCast(self)), status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_LastDownloadError(self: *const T, @"error": ?*FEEDS_DOWNLOAD_ERROR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_LastDownloadError(@as(*const IFeedEnclosure, @ptrCast(self)), @"error");
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_LocalPath(self: *const T, localPath: ?*?BSTR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_LocalPath(@as(*const IFeedEnclosure, @ptrCast(self)), localPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_Parent(self: *const T, disp: ?*?*IDispatch) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_Parent(@as(*const IFeedEnclosure, @ptrCast(self)), disp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_DownloadUrl(self: *const T, enclosureUrl: ?*?BSTR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_DownloadUrl(@as(*const IFeedEnclosure, @ptrCast(self)), enclosureUrl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_get_DownloadMimeType(self: *const T, mimeType: ?*?BSTR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).get_DownloadMimeType(@as(*const IFeedEnclosure, @ptrCast(self)), mimeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_RemoveFile(self: *const T) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).RemoveFile(@as(*const IFeedEnclosure, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IFeedEnclosure_SetFile(self: *const T, downloadUrl: ?BSTR, downloadFilePath: ?BSTR, downloadMimeType: ?BSTR, enclosureFilename: ?BSTR) HRESULT {
                return @as(*const IFeedEnclosure.VTable, @ptrCast(self.vtable)).SetFile(@as(*const IFeedEnclosure, @ptrCast(self)), downloadUrl, downloadFilePath, downloadMimeType, enclosureFilename);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PlayerState = enum(i32) {
    stop_state = 0,
    pause_state = 1,
    play_state = 2,
};
pub const stop_state = PlayerState.stop_state;
pub const pause_state = PlayerState.pause_state;
pub const play_state = PlayerState.play_state;

pub const TimedLevel = extern struct {
    frequency: [2048]u8,
    waveform: [2048]u8,
    state: i32,
    timeStamp: i64,
};

const IID_IWMPEffects_Value = Guid.initString("d3984c13-c3cb-48e2-8be5-5168340b4f35");
pub const IID_IWMPEffects = &IID_IWMPEffects_Value;
pub const IWMPEffects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                pLevels: ?*TimedLevel,
                hdc: ?HDC,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                pLevels: ?*TimedLevel,
                hdc: ?HDC,
                prc: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MediaInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                lChannelCount: i32,
                lSampleRate: i32,
                bstrTitle: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                lChannelCount: i32,
                lSampleRate: i32,
                bstrTitle: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                pdwCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                bstrTitle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                bstrTitle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                nPreset: i32,
                bstrPresetTitle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                nPreset: i32,
                bstrPresetTitle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPresetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                pnPresetCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                pnPresetCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentPreset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                nPreset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                nPreset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPreset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                pnPreset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                pnPreset: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayPropertyPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                hwndOwner: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GoFullscreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                fFullScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                fFullScreen: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects,
                pLevels: ?*TimedLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects,
                pLevels: ?*TimedLevel,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_Render(self: *const T, pLevels: ?*TimedLevel, hdc: ?HDC, prc: ?*RECT) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).Render(@as(*const IWMPEffects, @ptrCast(self)), pLevels, hdc, prc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_MediaInfo(self: *const T, lChannelCount: i32, lSampleRate: i32, bstrTitle: ?BSTR) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).MediaInfo(@as(*const IWMPEffects, @ptrCast(self)), lChannelCount, lSampleRate, bstrTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_GetCapabilities(self: *const T, pdwCapabilities: ?*u32) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IWMPEffects, @ptrCast(self)), pdwCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_GetTitle(self: *const T, bstrTitle: ?*?BSTR) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).GetTitle(@as(*const IWMPEffects, @ptrCast(self)), bstrTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_GetPresetTitle(self: *const T, nPreset: i32, bstrPresetTitle: ?*?BSTR) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).GetPresetTitle(@as(*const IWMPEffects, @ptrCast(self)), nPreset, bstrPresetTitle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_GetPresetCount(self: *const T, pnPresetCount: ?*i32) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).GetPresetCount(@as(*const IWMPEffects, @ptrCast(self)), pnPresetCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_SetCurrentPreset(self: *const T, nPreset: i32) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).SetCurrentPreset(@as(*const IWMPEffects, @ptrCast(self)), nPreset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_GetCurrentPreset(self: *const T, pnPreset: ?*i32) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).GetCurrentPreset(@as(*const IWMPEffects, @ptrCast(self)), pnPreset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_DisplayPropertyPage(self: *const T, hwndOwner: ?HWND) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).DisplayPropertyPage(@as(*const IWMPEffects, @ptrCast(self)), hwndOwner);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_GoFullscreen(self: *const T, fFullScreen: BOOL) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).GoFullscreen(@as(*const IWMPEffects, @ptrCast(self)), fFullScreen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects_RenderFullScreen(self: *const T, pLevels: ?*TimedLevel) HRESULT {
                return @as(*const IWMPEffects.VTable, @ptrCast(self.vtable)).RenderFullScreen(@as(*const IWMPEffects, @ptrCast(self)), pLevels);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPEffects2_Value = Guid.initString("695386ec-aa3c-4618-a5e1-dd9a8b987632");
pub const IID_IWMPEffects2 = &IID_IWMPEffects2_Value;
pub const IWMPEffects2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPEffects.VTable,
        SetCore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects2,
                pPlayer: ?*IWMPCore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects2,
                pPlayer: ?*IWMPCore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects2,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects2,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyNewMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects2,
                pMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects2,
                pMedia: ?*IWMPMedia,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnWindowMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects2,
                msg: u32,
                WParam: WPARAM,
                LParam: LPARAM,
                plResultParam: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects2,
                msg: u32,
                WParam: WPARAM,
                LParam: LPARAM,
                plResultParam: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderWindowed: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPEffects2,
                pData: ?*TimedLevel,
                fRequiredRender: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPEffects2,
                pData: ?*TimedLevel,
                fRequiredRender: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPEffects.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects2_SetCore(self: *const T, pPlayer: ?*IWMPCore) HRESULT {
                return @as(*const IWMPEffects2.VTable, @ptrCast(self.vtable)).SetCore(@as(*const IWMPEffects2, @ptrCast(self)), pPlayer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects2_Create(self: *const T, hwndParent: ?HWND) HRESULT {
                return @as(*const IWMPEffects2.VTable, @ptrCast(self.vtable)).Create(@as(*const IWMPEffects2, @ptrCast(self)), hwndParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects2_Destroy(self: *const T) HRESULT {
                return @as(*const IWMPEffects2.VTable, @ptrCast(self.vtable)).Destroy(@as(*const IWMPEffects2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects2_NotifyNewMedia(self: *const T, pMedia: ?*IWMPMedia) HRESULT {
                return @as(*const IWMPEffects2.VTable, @ptrCast(self.vtable)).NotifyNewMedia(@as(*const IWMPEffects2, @ptrCast(self)), pMedia);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects2_OnWindowMessage(self: *const T, msg: u32, WParam: WPARAM, LParam: LPARAM, plResultParam: ?*LRESULT) HRESULT {
                return @as(*const IWMPEffects2.VTable, @ptrCast(self.vtable)).OnWindowMessage(@as(*const IWMPEffects2, @ptrCast(self)), msg, WParam, LParam, plResultParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPEffects2_RenderWindowed(self: *const T, pData: ?*TimedLevel, fRequiredRender: BOOL) HRESULT {
                return @as(*const IWMPEffects2.VTable, @ptrCast(self.vtable)).RenderWindowed(@as(*const IWMPEffects2, @ptrCast(self)), pData, fRequiredRender);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPPluginUI_Value = Guid.initString("4c5e8f9f-ad3e-4bf9-9753-fcd30d6d38dd");
pub const IID_IWMPPluginUI = &IID_IWMPPluginUI_Value;
pub const IWMPPluginUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
                pCore: ?*IWMPCore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
                pCore: ?*IWMPCore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
                hwndParent: ?HWND,
                phwndWindow: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
                hwndParent: ?HWND,
                phwndWindow: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayPropertyPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
                hwndParent: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
                pwszName: ?[*:0]const u16,
                pvarProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
                pwszName: ?[*:0]const u16,
                pvarProperty: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
                pwszName: ?[*:0]const u16,
                pvarProperty: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
                pwszName: ?[*:0]const u16,
                pvarProperty: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateAccelerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPPluginUI,
                lpmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPPluginUI,
                lpmsg: ?*MSG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_SetCore(self: *const T, pCore: ?*IWMPCore) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).SetCore(@as(*const IWMPPluginUI, @ptrCast(self)), pCore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_Create(self: *const T, hwndParent: ?HWND, phwndWindow: ?*?HWND) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).Create(@as(*const IWMPPluginUI, @ptrCast(self)), hwndParent, phwndWindow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_Destroy(self: *const T) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).Destroy(@as(*const IWMPPluginUI, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_DisplayPropertyPage(self: *const T, hwndParent: ?HWND) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).DisplayPropertyPage(@as(*const IWMPPluginUI, @ptrCast(self)), hwndParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_GetProperty(self: *const T, pwszName: ?[*:0]const u16, pvarProperty: ?*VARIANT) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IWMPPluginUI, @ptrCast(self)), pwszName, pvarProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_SetProperty(self: *const T, pwszName: ?[*:0]const u16, pvarProperty: ?*const VARIANT) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IWMPPluginUI, @ptrCast(self)), pwszName, pvarProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPPluginUI_TranslateAccelerator(self: *const T, lpmsg: ?*MSG) HRESULT {
                return @as(*const IWMPPluginUI.VTable, @ptrCast(self.vtable)).TranslateAccelerator(@as(*const IWMPPluginUI, @ptrCast(self)), lpmsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPPartnerNotification = enum(i32) {
    BackgroundProcessingBegin = 1,
    BackgroundProcessingEnd = 2,
    CatalogDownloadFailure = 3,
    CatalogDownloadComplete = 4,
};
pub const wmpsnBackgroundProcessingBegin = WMPPartnerNotification.BackgroundProcessingBegin;
pub const wmpsnBackgroundProcessingEnd = WMPPartnerNotification.BackgroundProcessingEnd;
pub const wmpsnCatalogDownloadFailure = WMPPartnerNotification.CatalogDownloadFailure;
pub const wmpsnCatalogDownloadComplete = WMPPartnerNotification.CatalogDownloadComplete;

pub const WMPCallbackNotification = enum(i32) {
    LoginStateChange = 1,
    AuthResult = 2,
    LicenseUpdated = 3,
    NewCatalogAvailable = 4,
    NewPluginAvailable = 5,
    DisableRadioSkipping = 6,
};
pub const wmpcnLoginStateChange = WMPCallbackNotification.LoginStateChange;
pub const wmpcnAuthResult = WMPCallbackNotification.AuthResult;
pub const wmpcnLicenseUpdated = WMPCallbackNotification.LicenseUpdated;
pub const wmpcnNewCatalogAvailable = WMPCallbackNotification.NewCatalogAvailable;
pub const wmpcnNewPluginAvailable = WMPCallbackNotification.NewPluginAvailable;
pub const wmpcnDisableRadioSkipping = WMPCallbackNotification.DisableRadioSkipping;

pub const WMPTaskType = enum(i32) {
    Browse = 1,
    Sync = 2,
    Burn = 3,
    Current = 4,
};
pub const wmpttBrowse = WMPTaskType.Browse;
pub const wmpttSync = WMPTaskType.Sync;
pub const wmpttBurn = WMPTaskType.Burn;
pub const wmpttCurrent = WMPTaskType.Current;

pub const WMPContextMenuInfo = extern struct {
    dwID: u32,
    bstrMenuText: ?BSTR,
    bstrHelpText: ?BSTR,
};

const IID_IWMPContentContainer_Value = Guid.initString("ad7f4d9c-1a9f-4ed2-9815-ecc0b58cb616");
pub const IID_IWMPContentContainer = &IID_IWMPContentContainer_Value;
pub const IWMPContentContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainer,
                pContentID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainer,
                pContentID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainer,
                pbstrPrice: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainer,
                pbstrPrice: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainer,
                pbstrType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainer,
                pbstrType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainer,
                pcContent: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainer,
                pcContent: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentPrice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainer,
                idxContent: u32,
                pbstrPrice: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainer,
                idxContent: u32,
                pbstrPrice: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainer,
                idxContent: u32,
                pContentID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainer,
                idxContent: u32,
                pContentID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainer_GetID(self: *const T, pContentID: ?*u32) HRESULT {
                return @as(*const IWMPContentContainer.VTable, @ptrCast(self.vtable)).GetID(@as(*const IWMPContentContainer, @ptrCast(self)), pContentID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainer_GetPrice(self: *const T, pbstrPrice: ?*?BSTR) HRESULT {
                return @as(*const IWMPContentContainer.VTable, @ptrCast(self.vtable)).GetPrice(@as(*const IWMPContentContainer, @ptrCast(self)), pbstrPrice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainer_GetType(self: *const T, pbstrType: ?*?BSTR) HRESULT {
                return @as(*const IWMPContentContainer.VTable, @ptrCast(self.vtable)).GetType(@as(*const IWMPContentContainer, @ptrCast(self)), pbstrType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainer_GetContentCount(self: *const T, pcContent: ?*u32) HRESULT {
                return @as(*const IWMPContentContainer.VTable, @ptrCast(self.vtable)).GetContentCount(@as(*const IWMPContentContainer, @ptrCast(self)), pcContent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainer_GetContentPrice(self: *const T, idxContent: u32, pbstrPrice: ?*?BSTR) HRESULT {
                return @as(*const IWMPContentContainer.VTable, @ptrCast(self.vtable)).GetContentPrice(@as(*const IWMPContentContainer, @ptrCast(self)), idxContent, pbstrPrice);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainer_GetContentID(self: *const T, idxContent: u32, pContentID: ?*u32) HRESULT {
                return @as(*const IWMPContentContainer.VTable, @ptrCast(self.vtable)).GetContentID(@as(*const IWMPContentContainer, @ptrCast(self)), idxContent, pContentID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPTransactionType = enum(i32) {
    NoTransaction = 0,
    Download = 1,
    Buy = 2,
};
pub const wmpttNoTransaction = WMPTransactionType.NoTransaction;
pub const wmpttDownload = WMPTransactionType.Download;
pub const wmpttBuy = WMPTransactionType.Buy;

const IID_IWMPContentContainerList_Value = Guid.initString("a9937f78-0802-4af8-8b8d-e3f045bc8ab5");
pub const IID_IWMPContentContainerList = &IID_IWMPContentContainerList_Value;
pub const IWMPContentContainerList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransactionType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainerList,
                pwmptt: ?*WMPTransactionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainerList,
                pwmptt: ?*WMPTransactionType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainerCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainerList,
                pcContainer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainerList,
                pcContainer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentContainerList,
                idxContainer: u32,
                ppContent: ?*?*IWMPContentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentContainerList,
                idxContainer: u32,
                ppContent: ?*?*IWMPContentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainerList_GetTransactionType(self: *const T, pwmptt: ?*WMPTransactionType) HRESULT {
                return @as(*const IWMPContentContainerList.VTable, @ptrCast(self.vtable)).GetTransactionType(@as(*const IWMPContentContainerList, @ptrCast(self)), pwmptt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainerList_GetContainerCount(self: *const T, pcContainer: ?*u32) HRESULT {
                return @as(*const IWMPContentContainerList.VTable, @ptrCast(self.vtable)).GetContainerCount(@as(*const IWMPContentContainerList, @ptrCast(self)), pcContainer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentContainerList_GetContainer(self: *const T, idxContainer: u32, ppContent: ?*?*IWMPContentContainer) HRESULT {
                return @as(*const IWMPContentContainerList.VTable, @ptrCast(self.vtable)).GetContainer(@as(*const IWMPContentContainerList, @ptrCast(self)), idxContainer, ppContent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPTemplateSize = enum(i32) {
    Small = 0,
    Medium = 1,
    Large = 2,
};
pub const wmptsSmall = WMPTemplateSize.Small;
pub const wmptsMedium = WMPTemplateSize.Medium;
pub const wmptsLarge = WMPTemplateSize.Large;

pub const WMPStreamingType = enum(i32) {
    Unknown = 0,
    Music = 1,
    Video = 2,
    Radio = 3,
};
pub const wmpstUnknown = WMPStreamingType.Unknown;
pub const wmpstMusic = WMPStreamingType.Music;
pub const wmpstVideo = WMPStreamingType.Video;
pub const wmpstRadio = WMPStreamingType.Radio;

pub const WMPAccountType = enum(i32) {
    BuyOnly = 1,
    Subscription = 2,
    Janus = 3,
};
pub const wmpatBuyOnly = WMPAccountType.BuyOnly;
pub const wmpatSubscription = WMPAccountType.Subscription;
pub const wmpatJanus = WMPAccountType.Janus;

const IID_IWMPContentPartnerCallback_Value = Guid.initString("9e8f7da2-0695-403c-b697-da10fafaa676");
pub const IID_IWMPContentPartnerCallback = &IID_IWMPContentPartnerCallback_Value;
pub const IWMPContentPartnerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                type: WMPCallbackNotification,
                pContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                type: WMPCallbackNotification,
                pContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BuyComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                hrResult: HRESULT,
                dwBuyCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                hrResult: HRESULT,
                dwBuyCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadTrack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                cookie: u32,
                bstrTrackURL: ?BSTR,
                dwServiceTrackID: u32,
                bstrDownloadParams: ?BSTR,
                hrDownload: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                cookie: u32,
                bstrTrackURL: ?BSTR,
                dwServiceTrackID: u32,
                bstrDownloadParams: ?BSTR,
                hrDownload: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCatalogVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                pdwVersion: ?*u32,
                pdwSchemaVersion: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                pdwVersion: ?*u32,
                pdwSchemaVersion: ?*u32,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateDeviceComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                bstrType: ?BSTR,
                bstrID: ?BSTR,
                bstrFilter: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                bstrType: ?BSTR,
                bstrID: ?BSTR,
                bstrFilter: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddListContents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                dwListCookie: u32,
                cItems: u32,
                prgItems: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                dwListCookie: u32,
                cItems: u32,
                prgItems: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ListContentsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                dwListCookie: u32,
                hrSuccess: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                dwListCookie: u32,
                hrSuccess: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendMessageComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                bstrMsg: ?BSTR,
                bstrParam: ?BSTR,
                bstrResult: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                bstrMsg: ?BSTR,
                bstrParam: ?BSTR,
                bstrResult: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentIDsInLibrary: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                pcContentIDs: ?*u32,
                pprgIDs: ?[*]?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                pcContentIDs: ?*u32,
                pprgIDs: ?[*]?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshLicenseComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                dwCookie: u32,
                contentID: u32,
                hrRefresh: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                dwCookie: u32,
                contentID: u32,
                hrRefresh: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowPopup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                lIndex: i32,
                bstrParameters: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                lIndex: i32,
                bstrParameters: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VerifyPermissionComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartnerCallback,
                bstrPermission: ?BSTR,
                pContext: ?*VARIANT,
                hrPermission: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartnerCallback,
                bstrPermission: ?BSTR,
                pContext: ?*VARIANT,
                hrPermission: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_Notify(self: *const T, type_: WMPCallbackNotification, pContext: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).Notify(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), type_, pContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_BuyComplete(self: *const T, hrResult: HRESULT, dwBuyCookie: u32) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).BuyComplete(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), hrResult, dwBuyCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_DownloadTrack(self: *const T, cookie: u32, bstrTrackURL: ?BSTR, dwServiceTrackID: u32, bstrDownloadParams: ?BSTR, hrDownload: HRESULT) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).DownloadTrack(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), cookie, bstrTrackURL, dwServiceTrackID, bstrDownloadParams, hrDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_GetCatalogVersion(self: *const T, pdwVersion: ?*u32, pdwSchemaVersion: ?*u32, plcid: ?*u32) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).GetCatalogVersion(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), pdwVersion, pdwSchemaVersion, plcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_UpdateDeviceComplete(self: *const T, bstrDeviceName: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).UpdateDeviceComplete(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), bstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_ChangeView(self: *const T, bstrType: ?BSTR, bstrID: ?BSTR, bstrFilter: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).ChangeView(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), bstrType, bstrID, bstrFilter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_AddListContents(self: *const T, dwListCookie: u32, cItems: u32, prgItems: [*]u32) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).AddListContents(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), dwListCookie, cItems, prgItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_ListContentsComplete(self: *const T, dwListCookie: u32, hrSuccess: HRESULT) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).ListContentsComplete(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), dwListCookie, hrSuccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_SendMessageComplete(self: *const T, bstrMsg: ?BSTR, bstrParam: ?BSTR, bstrResult: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).SendMessageComplete(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), bstrMsg, bstrParam, bstrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_GetContentIDsInLibrary(self: *const T, pcContentIDs: ?*u32, pprgIDs: ?[*]?*u32) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).GetContentIDsInLibrary(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), pcContentIDs, pprgIDs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_RefreshLicenseComplete(self: *const T, dwCookie: u32, contentID: u32, hrRefresh: HRESULT) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).RefreshLicenseComplete(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), dwCookie, contentID, hrRefresh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_ShowPopup(self: *const T, lIndex: i32, bstrParameters: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).ShowPopup(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), lIndex, bstrParameters);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartnerCallback_VerifyPermissionComplete(self: *const T, bstrPermission: ?BSTR, pContext: ?*VARIANT, hrPermission: HRESULT) HRESULT {
                return @as(*const IWMPContentPartnerCallback.VTable, @ptrCast(self.vtable)).VerifyPermissionComplete(@as(*const IWMPContentPartnerCallback, @ptrCast(self)), bstrPermission, pContext, hrPermission);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPContentPartner_Value = Guid.initString("55455073-41b5-4e75-87b8-f13bdb291d08");
pub const IID_IWMPContentPartner = &IID_IWMPContentPartner_Value;
pub const IWMPContentPartner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                pCallback: ?*IWMPContentPartnerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                pCallback: ?*IWMPContentPartnerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                type: WMPPartnerNotification,
                pContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                type: WMPPartnerNotification,
                pContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                bstrInfoName: ?BSTR,
                pContext: ?*VARIANT,
                pData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                bstrInfoName: ?BSTR,
                pContext: ?*VARIANT,
                pData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentPartnerInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                bstrInfoName: ?BSTR,
                pData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                bstrInfoName: ?BSTR,
                pData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommands: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                location: ?BSTR,
                pLocationContext: ?*VARIANT,
                itemLocation: ?BSTR,
                cItemIDs: u32,
                prgItemIDs: [*]u32,
                pcItemIDs: ?*u32,
                pprgItems: ?[*]?*WMPContextMenuInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                location: ?BSTR,
                pLocationContext: ?*VARIANT,
                itemLocation: ?BSTR,
                cItemIDs: u32,
                prgItemIDs: [*]u32,
                pcItemIDs: ?*u32,
                pprgItems: ?[*]?*WMPContextMenuInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                dwCommandID: u32,
                location: ?BSTR,
                pLocationContext: ?*VARIANT,
                itemLocation: ?BSTR,
                cItemIDs: u32,
                rgItemIDs: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                dwCommandID: u32,
                location: ?BSTR,
                pLocationContext: ?*VARIANT,
                itemLocation: ?BSTR,
                cItemIDs: u32,
                rgItemIDs: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanBuySilent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                pInfo: ?*IWMPContentContainerList,
                pbstrTotalPrice: ?*?BSTR,
                pSilentOK: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                pInfo: ?*IWMPContentContainerList,
                pbstrTotalPrice: ?*?BSTR,
                pSilentOK: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Buy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                pInfo: ?*IWMPContentContainerList,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                pInfo: ?*IWMPContentContainerList,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamingURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                st: WMPStreamingType,
                pStreamContext: ?*VARIANT,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                st: WMPStreamingType,
                pStreamContext: ?*VARIANT,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                pInfo: ?*IWMPContentContainerList,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                pInfo: ?*IWMPContentContainerList,
                cookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DownloadTrackComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                hrResult: HRESULT,
                contentID: u32,
                downloadTrackParam: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                hrResult: HRESULT,
                contentID: u32,
                downloadTrackParam: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                dwCookie: u32,
                fLocal: i16,
                bstrURL: ?BSTR,
                type: WMPStreamingType,
                contentID: u32,
                bstrRefreshReason: ?BSTR,
                pReasonContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                dwCookie: u32,
                fLocal: i16,
                bstrURL: ?BSTR,
                type: WMPStreamingType,
                contentID: u32,
                bstrRefreshReason: ?BSTR,
                pReasonContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCatalogURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                dwCatalogVersion: u32,
                dwCatalogSchemaVersion: u32,
                catalogLCID: u32,
                pdwNewCatalogVersion: ?*u32,
                pbstrCatalogURL: ?*?BSTR,
                pExpirationDate: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                dwCatalogVersion: u32,
                dwCatalogSchemaVersion: u32,
                catalogLCID: u32,
                pdwNewCatalogVersion: ?*u32,
                pbstrCatalogURL: ?*?BSTR,
                pExpirationDate: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTemplate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                task: WMPTaskType,
                location: ?BSTR,
                pContext: ?*VARIANT,
                clickLocation: ?BSTR,
                pClickContext: ?*VARIANT,
                bstrFilter: ?BSTR,
                bstrViewParams: ?BSTR,
                pbstrTemplateURL: ?*?BSTR,
                pTemplateSize: ?*WMPTemplateSize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                task: WMPTaskType,
                location: ?BSTR,
                pContext: ?*VARIANT,
                clickLocation: ?BSTR,
                pClickContext: ?*VARIANT,
                bstrFilter: ?BSTR,
                bstrViewParams: ?BSTR,
                pbstrTemplateURL: ?*?BSTR,
                pTemplateSize: ?*WMPTemplateSize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                bstrDeviceName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListContents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                location: ?BSTR,
                pContext: ?*VARIANT,
                bstrListType: ?BSTR,
                bstrParams: ?BSTR,
                dwListCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                location: ?BSTR,
                pContext: ?*VARIANT,
                bstrListType: ?BSTR,
                bstrParams: ?BSTR,
                dwListCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Login: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                userInfo: BLOB,
                pwdInfo: BLOB,
                fUsedCachedCreds: i16,
                fOkToCache: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                userInfo: BLOB,
                pwdInfo: BLOB,
                fUsedCachedCreds: i16,
                fOkToCache: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Authenticate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                userInfo: BLOB,
                pwdInfo: BLOB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                userInfo: BLOB,
                pwdInfo: BLOB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Logout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                bstrMsg: ?BSTR,
                bstrParam: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                bstrMsg: ?BSTR,
                bstrParam: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StationEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                bstrStationEventType: ?BSTR,
                StationId: u32,
                PlaylistIndex: u32,
                TrackID: u32,
                TrackData: ?BSTR,
                dwSecondsPlayed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                bstrStationEventType: ?BSTR,
                StationId: u32,
                PlaylistIndex: u32,
                TrackID: u32,
                TrackData: ?BSTR,
                dwSecondsPlayed: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareContainerListPrices: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                pListBase: ?*IWMPContentContainerList,
                pListCompare: ?*IWMPContentContainerList,
                pResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                pListBase: ?*IWMPContentContainerList,
                pListCompare: ?*IWMPContentContainerList,
                pResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VerifyPermission: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPContentPartner,
                bstrPermission: ?BSTR,
                pContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPContentPartner,
                bstrPermission: ?BSTR,
                pContext: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_SetCallback(self: *const T, pCallback: ?*IWMPContentPartnerCallback) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).SetCallback(@as(*const IWMPContentPartner, @ptrCast(self)), pCallback);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_Notify(self: *const T, type_: WMPPartnerNotification, pContext: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).Notify(@as(*const IWMPContentPartner, @ptrCast(self)), type_, pContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetItemInfo(self: *const T, bstrInfoName: ?BSTR, pContext: ?*VARIANT, pData: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetItemInfo(@as(*const IWMPContentPartner, @ptrCast(self)), bstrInfoName, pContext, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetContentPartnerInfo(self: *const T, bstrInfoName: ?BSTR, pData: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetContentPartnerInfo(@as(*const IWMPContentPartner, @ptrCast(self)), bstrInfoName, pData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetCommands(self: *const T, location: ?BSTR, pLocationContext: ?*VARIANT, itemLocation: ?BSTR, cItemIDs: u32, prgItemIDs: [*]u32, pcItemIDs: ?*u32, pprgItems: ?[*]?*WMPContextMenuInfo) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetCommands(@as(*const IWMPContentPartner, @ptrCast(self)), location, pLocationContext, itemLocation, cItemIDs, prgItemIDs, pcItemIDs, pprgItems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_InvokeCommand(self: *const T, dwCommandID: u32, location: ?BSTR, pLocationContext: ?*VARIANT, itemLocation: ?BSTR, cItemIDs: u32, rgItemIDs: [*]u32) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).InvokeCommand(@as(*const IWMPContentPartner, @ptrCast(self)), dwCommandID, location, pLocationContext, itemLocation, cItemIDs, rgItemIDs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_CanBuySilent(self: *const T, pInfo: ?*IWMPContentContainerList, pbstrTotalPrice: ?*?BSTR, pSilentOK: ?*i16) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).CanBuySilent(@as(*const IWMPContentPartner, @ptrCast(self)), pInfo, pbstrTotalPrice, pSilentOK);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_Buy(self: *const T, pInfo: ?*IWMPContentContainerList, cookie: u32) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).Buy(@as(*const IWMPContentPartner, @ptrCast(self)), pInfo, cookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetStreamingURL(self: *const T, st: WMPStreamingType, pStreamContext: ?*VARIANT, pbstrURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetStreamingURL(@as(*const IWMPContentPartner, @ptrCast(self)), st, pStreamContext, pbstrURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_Download(self: *const T, pInfo: ?*IWMPContentContainerList, cookie: u32) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).Download(@as(*const IWMPContentPartner, @ptrCast(self)), pInfo, cookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_DownloadTrackComplete(self: *const T, hrResult: HRESULT, contentID: u32, downloadTrackParam: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).DownloadTrackComplete(@as(*const IWMPContentPartner, @ptrCast(self)), hrResult, contentID, downloadTrackParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_RefreshLicense(self: *const T, dwCookie: u32, fLocal: i16, bstrURL: ?BSTR, type_: WMPStreamingType, contentID: u32, bstrRefreshReason: ?BSTR, pReasonContext: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).RefreshLicense(@as(*const IWMPContentPartner, @ptrCast(self)), dwCookie, fLocal, bstrURL, type_, contentID, bstrRefreshReason, pReasonContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetCatalogURL(self: *const T, dwCatalogVersion: u32, dwCatalogSchemaVersion: u32, catalogLCID: u32, pdwNewCatalogVersion: ?*u32, pbstrCatalogURL: ?*?BSTR, pExpirationDate: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetCatalogURL(@as(*const IWMPContentPartner, @ptrCast(self)), dwCatalogVersion, dwCatalogSchemaVersion, catalogLCID, pdwNewCatalogVersion, pbstrCatalogURL, pExpirationDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetTemplate(self: *const T, task: WMPTaskType, location: ?BSTR, pContext: ?*VARIANT, clickLocation: ?BSTR, pClickContext: ?*VARIANT, bstrFilter: ?BSTR, bstrViewParams: ?BSTR, pbstrTemplateURL: ?*?BSTR, pTemplateSize: ?*WMPTemplateSize) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetTemplate(@as(*const IWMPContentPartner, @ptrCast(self)), task, location, pContext, clickLocation, pClickContext, bstrFilter, bstrViewParams, pbstrTemplateURL, pTemplateSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_UpdateDevice(self: *const T, bstrDeviceName: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).UpdateDevice(@as(*const IWMPContentPartner, @ptrCast(self)), bstrDeviceName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_GetListContents(self: *const T, location: ?BSTR, pContext: ?*VARIANT, bstrListType: ?BSTR, bstrParams: ?BSTR, dwListCookie: u32) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).GetListContents(@as(*const IWMPContentPartner, @ptrCast(self)), location, pContext, bstrListType, bstrParams, dwListCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_Login(self: *const T, userInfo: BLOB, pwdInfo: BLOB, fUsedCachedCreds: i16, fOkToCache: i16) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).Login(@as(*const IWMPContentPartner, @ptrCast(self)), userInfo, pwdInfo, fUsedCachedCreds, fOkToCache);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_Authenticate(self: *const T, userInfo: BLOB, pwdInfo: BLOB) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).Authenticate(@as(*const IWMPContentPartner, @ptrCast(self)), userInfo, pwdInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_Logout(self: *const T) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).Logout(@as(*const IWMPContentPartner, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_SendMessage(self: *const T, bstrMsg: ?BSTR, bstrParam: ?BSTR) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).SendMessage(@as(*const IWMPContentPartner, @ptrCast(self)), bstrMsg, bstrParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_StationEvent(self: *const T, bstrStationEventType: ?BSTR, StationId: u32, PlaylistIndex: u32, TrackID: u32, TrackData: ?BSTR, dwSecondsPlayed: u32) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).StationEvent(@as(*const IWMPContentPartner, @ptrCast(self)), bstrStationEventType, StationId, PlaylistIndex, TrackID, TrackData, dwSecondsPlayed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_CompareContainerListPrices(self: *const T, pListBase: ?*IWMPContentContainerList, pListCompare: ?*IWMPContentContainerList, pResult: ?*i32) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).CompareContainerListPrices(@as(*const IWMPContentPartner, @ptrCast(self)), pListBase, pListCompare, pResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPContentPartner_VerifyPermission(self: *const T, bstrPermission: ?BSTR, pContext: ?*VARIANT) HRESULT {
                return @as(*const IWMPContentPartner.VTable, @ptrCast(self.vtable)).VerifyPermission(@as(*const IWMPContentPartner, @ptrCast(self)), bstrPermission, pContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPSubscriptionServiceEvent = enum(i32) {
    CurrentBegin = 1,
    CurrentEnd = 2,
    FullBegin = 3,
    FullEnd = 4,
};
pub const wmpsseCurrentBegin = WMPSubscriptionServiceEvent.CurrentBegin;
pub const wmpsseCurrentEnd = WMPSubscriptionServiceEvent.CurrentEnd;
pub const wmpsseFullBegin = WMPSubscriptionServiceEvent.FullBegin;
pub const wmpsseFullEnd = WMPSubscriptionServiceEvent.FullEnd;

const IID_IWMPSubscriptionService_Value = Guid.initString("376055f8-2a59-4a73-9501-dca5273a7a10");
pub const IID_IWMPSubscriptionService = &IID_IWMPSubscriptionService_Value;
pub const IWMPSubscriptionService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        allowPlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
                pMedia: ?*IWMPMedia,
                pfAllowPlay: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
                pMedia: ?*IWMPMedia,
                pfAllowPlay: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        allowCDBurn: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
                pPlaylist: ?*IWMPPlaylist,
                pfAllowBurn: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
                pPlaylist: ?*IWMPPlaylist,
                pfAllowBurn: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        allowPDATransfer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
                pPlaylist: ?*IWMPPlaylist,
                pfAllowTransfer: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
                pPlaylist: ?*IWMPPlaylist,
                pfAllowTransfer: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startBackgroundProcessing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService_allowPlay(self: *const T, hwnd: ?HWND, pMedia: ?*IWMPMedia, pfAllowPlay: ?*BOOL) HRESULT {
                return @as(*const IWMPSubscriptionService.VTable, @ptrCast(self.vtable)).allowPlay(@as(*const IWMPSubscriptionService, @ptrCast(self)), hwnd, pMedia, pfAllowPlay);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService_allowCDBurn(self: *const T, hwnd: ?HWND, pPlaylist: ?*IWMPPlaylist, pfAllowBurn: ?*BOOL) HRESULT {
                return @as(*const IWMPSubscriptionService.VTable, @ptrCast(self.vtable)).allowCDBurn(@as(*const IWMPSubscriptionService, @ptrCast(self)), hwnd, pPlaylist, pfAllowBurn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService_allowPDATransfer(self: *const T, hwnd: ?HWND, pPlaylist: ?*IWMPPlaylist, pfAllowTransfer: ?*BOOL) HRESULT {
                return @as(*const IWMPSubscriptionService.VTable, @ptrCast(self.vtable)).allowPDATransfer(@as(*const IWMPSubscriptionService, @ptrCast(self)), hwnd, pPlaylist, pfAllowTransfer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService_startBackgroundProcessing(self: *const T, hwnd: ?HWND) HRESULT {
                return @as(*const IWMPSubscriptionService.VTable, @ptrCast(self.vtable)).startBackgroundProcessing(@as(*const IWMPSubscriptionService, @ptrCast(self)), hwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSubscriptionServiceCallback_Value = Guid.initString("dd01d127-2dc2-4c3a-876e-63312079f9b0");
pub const IID_IWMPSubscriptionServiceCallback = &IID_IWMPSubscriptionServiceCallback_Value;
pub const IWMPSubscriptionServiceCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionServiceCallback,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionServiceCallback,
                hrResult: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionServiceCallback_onComplete(self: *const T, hrResult: HRESULT) HRESULT {
                return @as(*const IWMPSubscriptionServiceCallback.VTable, @ptrCast(self.vtable)).onComplete(@as(*const IWMPSubscriptionServiceCallback, @ptrCast(self)), hrResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPSubscriptionService2_Value = Guid.initString("a94c120e-d600-4ec6-b05e-ec9d56d84de0");
pub const IID_IWMPSubscriptionService2 = &IID_IWMPSubscriptionService2_Value;
pub const IWMPSubscriptionService2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPSubscriptionService.VTable,
        stopBackgroundProcessing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        serviceEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService2,
                event: WMPSubscriptionServiceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService2,
                event: WMPSubscriptionServiceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        deviceAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService2,
                bstrDeviceName: ?BSTR,
                pCB: ?*IWMPSubscriptionServiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService2,
                bstrDeviceName: ?BSTR,
                pCB: ?*IWMPSubscriptionServiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        prepareForSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPSubscriptionService2,
                bstrFilename: ?BSTR,
                bstrDeviceName: ?BSTR,
                pCB: ?*IWMPSubscriptionServiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPSubscriptionService2,
                bstrFilename: ?BSTR,
                bstrDeviceName: ?BSTR,
                pCB: ?*IWMPSubscriptionServiceCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPSubscriptionService.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService2_stopBackgroundProcessing(self: *const T) HRESULT {
                return @as(*const IWMPSubscriptionService2.VTable, @ptrCast(self.vtable)).stopBackgroundProcessing(@as(*const IWMPSubscriptionService2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService2_serviceEvent(self: *const T, event: WMPSubscriptionServiceEvent) HRESULT {
                return @as(*const IWMPSubscriptionService2.VTable, @ptrCast(self.vtable)).serviceEvent(@as(*const IWMPSubscriptionService2, @ptrCast(self)), event);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService2_deviceAvailable(self: *const T, bstrDeviceName: ?BSTR, pCB: ?*IWMPSubscriptionServiceCallback) HRESULT {
                return @as(*const IWMPSubscriptionService2.VTable, @ptrCast(self.vtable)).deviceAvailable(@as(*const IWMPSubscriptionService2, @ptrCast(self)), bstrDeviceName, pCB);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPSubscriptionService2_prepareForSync(self: *const T, bstrFilename: ?BSTR, bstrDeviceName: ?BSTR, pCB: ?*IWMPSubscriptionServiceCallback) HRESULT {
                return @as(*const IWMPSubscriptionService2.VTable, @ptrCast(self.vtable)).prepareForSync(@as(*const IWMPSubscriptionService2, @ptrCast(self)), bstrFilename, bstrDeviceName, pCB);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMPSubscriptionDownloadState = enum(i32) {
    Downloading = 0,
    Paused = 1,
    Processing = 2,
    Completed = 3,
    Cancelled = 4,
};
pub const wmpsdlsDownloading = WMPSubscriptionDownloadState.Downloading;
pub const wmpsdlsPaused = WMPSubscriptionDownloadState.Paused;
pub const wmpsdlsProcessing = WMPSubscriptionDownloadState.Processing;
pub const wmpsdlsCompleted = WMPSubscriptionDownloadState.Completed;
pub const wmpsdlsCancelled = WMPSubscriptionDownloadState.Cancelled;

const IID_IWMPDownloadItem_Value = Guid.initString("c9470e8e-3f6b-46a9-a0a9-452815c34297");
pub const IID_IWMPDownloadItem = &IID_IWMPDownloadItem_Value;
pub const IWMPDownloadItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_sourceURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadItem,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadItem,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_size: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadItem,
                plSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadItem,
                plSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadItem,
                pbstrType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadItem,
                pbstrType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_progress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadItem,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadItem,
                plProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_downloadState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadItem,
                pwmpsdls: ?*WMPSubscriptionDownloadState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadItem,
                pwmpsdls: ?*WMPSubscriptionDownloadState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        @"resume": switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_get_sourceURL(self: *const T, pbstrURL: ?*?BSTR) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).get_sourceURL(@as(*const IWMPDownloadItem, @ptrCast(self)), pbstrURL);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_get_size(self: *const T, plSize: ?*i32) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).get_size(@as(*const IWMPDownloadItem, @ptrCast(self)), plSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_get_type(self: *const T, pbstrType: ?*?BSTR) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).get_type(@as(*const IWMPDownloadItem, @ptrCast(self)), pbstrType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_get_progress(self: *const T, plProgress: ?*i32) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).get_progress(@as(*const IWMPDownloadItem, @ptrCast(self)), plProgress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_get_downloadState(self: *const T, pwmpsdls: ?*WMPSubscriptionDownloadState) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).get_downloadState(@as(*const IWMPDownloadItem, @ptrCast(self)), pwmpsdls);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_pause(self: *const T) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).pause(@as(*const IWMPDownloadItem, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_resume(self: *const T) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).@"resume"(@as(*const IWMPDownloadItem, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem_cancel(self: *const T) HRESULT {
                return @as(*const IWMPDownloadItem.VTable, @ptrCast(self.vtable)).cancel(@as(*const IWMPDownloadItem, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPDownloadItem2_Value = Guid.initString("9fbb3336-6da3-479d-b8ff-67d46e20a987");
pub const IID_IWMPDownloadItem2 = &IID_IWMPDownloadItem2_Value;
pub const IWMPDownloadItem2 = extern struct {
    pub const VTable = extern struct {
        base: IWMPDownloadItem.VTable,
        getItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadItem2,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadItem2,
                bstrItemName: ?BSTR,
                pbstrVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IWMPDownloadItem.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadItem2_getItemInfo(self: *const T, bstrItemName: ?BSTR, pbstrVal: ?*?BSTR) HRESULT {
                return @as(*const IWMPDownloadItem2.VTable, @ptrCast(self.vtable)).getItemInfo(@as(*const IWMPDownloadItem2, @ptrCast(self)), bstrItemName, pbstrVal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPDownloadCollection_Value = Guid.initString("0a319c7f-85f9-436c-b88e-82fd88000e1c");
pub const IID_IWMPDownloadCollection = &IID_IWMPDownloadCollection_Value;
pub const IWMPDownloadCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_id: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadCollection,
                plId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadCollection,
                plId: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn (
                self: *const IWMPDownloadCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn (
                self: *const IWMPDownloadCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        item: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadCollection,
                lItem: i32,
                ppDownload: ?*?*IWMPDownloadItem2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadCollection,
                lItem: i32,
                ppDownload: ?*?*IWMPDownloadItem2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        startDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadCollection,
                bstrSourceURL: ?BSTR,
                bstrType: ?BSTR,
                ppDownload: ?*?*IWMPDownloadItem2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadCollection,
                bstrSourceURL: ?BSTR,
                bstrType: ?BSTR,
                ppDownload: ?*?*IWMPDownloadItem2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadCollection,
                lItem: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadCollection,
                lItem: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadCollection_get_id(self: *const T, plId: ?*i32) HRESULT {
                return @as(*const IWMPDownloadCollection.VTable, @ptrCast(self.vtable)).get_id(@as(*const IWMPDownloadCollection, @ptrCast(self)), plId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadCollection_get_count(self: *const T, plCount: ?*i32) HRESULT {
                return @as(*const IWMPDownloadCollection.VTable, @ptrCast(self.vtable)).get_count(@as(*const IWMPDownloadCollection, @ptrCast(self)), plCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadCollection_item(self: *const T, lItem: i32, ppDownload: ?*?*IWMPDownloadItem2) HRESULT {
                return @as(*const IWMPDownloadCollection.VTable, @ptrCast(self.vtable)).item(@as(*const IWMPDownloadCollection, @ptrCast(self)), lItem, ppDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadCollection_startDownload(self: *const T, bstrSourceURL: ?BSTR, bstrType: ?BSTR, ppDownload: ?*?*IWMPDownloadItem2) HRESULT {
                return @as(*const IWMPDownloadCollection.VTable, @ptrCast(self.vtable)).startDownload(@as(*const IWMPDownloadCollection, @ptrCast(self)), bstrSourceURL, bstrType, ppDownload);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadCollection_removeItem(self: *const T, lItem: i32) HRESULT {
                return @as(*const IWMPDownloadCollection.VTable, @ptrCast(self.vtable)).removeItem(@as(*const IWMPDownloadCollection, @ptrCast(self)), lItem);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadCollection_Clear(self: *const T) HRESULT {
                return @as(*const IWMPDownloadCollection.VTable, @ptrCast(self.vtable)).Clear(@as(*const IWMPDownloadCollection, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMPDownloadManager_Value = Guid.initString("e15e9ad1-8f20-4cc4-9ec7-1a328ca86a0d");
pub const IID_IWMPDownloadManager = &IID_IWMPDownloadManager_Value;
pub const IWMPDownloadManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getDownloadCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadManager,
                lCollectionId: i32,
                ppCollection: ?*?*IWMPDownloadCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadManager,
                lCollectionId: i32,
                ppCollection: ?*?*IWMPDownloadCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        createDownloadCollection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWMPDownloadManager,
                ppCollection: ?*?*IWMPDownloadCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWMPDownloadManager,
                ppCollection: ?*?*IWMPDownloadCollection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDispatch.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadManager_getDownloadCollection(self: *const T, lCollectionId: i32, ppCollection: ?*?*IWMPDownloadCollection) HRESULT {
                return @as(*const IWMPDownloadManager.VTable, @ptrCast(self.vtable)).getDownloadCollection(@as(*const IWMPDownloadManager, @ptrCast(self)), lCollectionId, ppCollection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWMPDownloadManager_createDownloadCollection(self: *const T, ppCollection: ?*?*IWMPDownloadCollection) HRESULT {
                return @as(*const IWMPDownloadManager.VTable, @ptrCast(self.vtable)).createDownloadCollection(@as(*const IWMPDownloadManager, @ptrCast(self)), ppCollection);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WMP_WMDM_METADATA_ROUND_TRIP_PC2DEVICE = extern struct {
    dwChangesSinceTransactionID: u32 align(1),
    dwResultSetStartingIndex: u32 align(1),
};

pub const WMP_WMDM_METADATA_ROUND_TRIP_DEVICE2PC = extern struct {
    dwCurrentTransactionID: u32 align(1),
    dwReturnedObjectCount: u32 align(1),
    dwUnretrievedObjectCount: u32 align(1),
    dwDeletedObjectStartingOffset: u32 align(1),
    dwFlags: u32 align(1),
    wsObjectPathnameList: [1]u16 align(1),
};

//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (21)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BLOB = @import("../system/com.zig").BLOB;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HDC = @import("../graphics/gdi.zig").HDC;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumVARIANT = @import("../system/ole.zig").IEnumVARIANT;
const IMFActivate = @import("../media/media_foundation.zig").IMFActivate;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const MSG = @import("../ui/windows_and_messaging.zig").MSG;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const SIZE = @import("../foundation.zig").SIZE;
const SYSTEMTIME = @import("../foundation.zig").SYSTEMTIME;
const VARIANT = @import("../system/com.zig").VARIANT;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
