//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (88)
//--------------------------------------------------------------------------------
pub const MMC_VER = @as(u32, 512);
pub const MMC_PROP_CHANGEAFFECTSUI = @as(u32, 1);
pub const MMC_PROP_MODIFIABLE = @as(u32, 2);
pub const MMC_PROP_REMOVABLE = @as(u32, 4);
pub const MMC_PROP_PERSIST = @as(u32, 8);
pub const MMCLV_AUTO = @as(i32, -1);
pub const MMCLV_NOPARAM = @as(i32, -2);
pub const MMCLV_NOICON = @as(i32, -1);
pub const MMCLV_VIEWSTYLE_ICON = @as(u32, 0);
pub const MMCLV_VIEWSTYLE_SMALLICON = @as(u32, 2);
pub const MMCLV_VIEWSTYLE_LIST = @as(u32, 3);
pub const MMCLV_VIEWSTYLE_REPORT = @as(u32, 1);
pub const MMCLV_VIEWSTYLE_FILTERED = @as(u32, 4);
pub const MMCLV_NOPTR = @as(u32, 0);
pub const MMCLV_UPDATE_NOINVALIDATEALL = @as(u32, 1);
pub const MMCLV_UPDATE_NOSCROLL = @as(u32, 2);
pub const MMC_IMAGECALLBACK = @as(i32, -1);
pub const RDI_STR = @as(u32, 2);
pub const RDI_IMAGE = @as(u32, 4);
pub const RDI_STATE = @as(u32, 8);
pub const RDI_PARAM = @as(u32, 16);
pub const RDI_INDEX = @as(u32, 32);
pub const RDI_INDENT = @as(u32, 64);
pub const MMC_VIEW_OPTIONS_NONE = @as(u32, 0);
pub const MMC_VIEW_OPTIONS_NOLISTVIEWS = @as(u32, 1);
pub const MMC_VIEW_OPTIONS_MULTISELECT = @as(u32, 2);
pub const MMC_VIEW_OPTIONS_OWNERDATALIST = @as(u32, 4);
pub const MMC_VIEW_OPTIONS_FILTERED = @as(u32, 8);
pub const MMC_VIEW_OPTIONS_CREATENEW = @as(u32, 16);
pub const MMC_VIEW_OPTIONS_USEFONTLINKING = @as(u32, 32);
pub const MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST = @as(u32, 64);
pub const MMC_VIEW_OPTIONS_LEXICAL_SORT = @as(u32, 128);
pub const MMC_PSO_NOAPPLYNOW = @as(u32, 1);
pub const MMC_PSO_HASHELP = @as(u32, 2);
pub const MMC_PSO_NEWWIZARDTYPE = @as(u32, 4);
pub const MMC_PSO_NO_PROPTITLE = @as(u32, 8);
pub const RFI_PARTIAL = @as(u32, 1);
pub const RFI_WRAP = @as(u32, 2);
pub const RSI_DESCENDING = @as(u32, 1);
pub const RSI_NOSORTICON = @as(u32, 2);
pub const SDI_STR = @as(u32, 2);
pub const SDI_IMAGE = @as(u32, 4);
pub const SDI_OPENIMAGE = @as(u32, 8);
pub const SDI_STATE = @as(u32, 16);
pub const SDI_PARAM = @as(u32, 32);
pub const SDI_CHILDREN = @as(u32, 64);
pub const SDI_PARENT = @as(u32, 0);
pub const SDI_PREVIOUS = @as(u32, 268435456);
pub const SDI_NEXT = @as(u32, 536870912);
pub const SDI_FIRST = @as(u32, 134217728);
pub const MMC_MULTI_SELECT_COOKIE = @as(i32, -2);
pub const MMC_WINDOW_COOKIE = @as(i32, -3);
pub const SPECIAL_COOKIE_MIN = @as(i32, -10);
pub const SPECIAL_COOKIE_MAX = @as(i32, -1);
pub const MMC_NW_OPTION_NONE = @as(u32, 0);
pub const MMC_NW_OPTION_NOSCOPEPANE = @as(u32, 1);
pub const MMC_NW_OPTION_NOTOOLBARS = @as(u32, 2);
pub const MMC_NW_OPTION_SHORTTITLE = @as(u32, 4);
pub const MMC_NW_OPTION_CUSTOMTITLE = @as(u32, 8);
pub const MMC_NW_OPTION_NOPERSIST = @as(u32, 16);
pub const MMC_NW_OPTION_NOACTIONPANE = @as(u32, 32);
pub const MMC_NODEID_SLOW_RETRIEVAL = @as(u32, 1);
pub const SPECIAL_DOBJ_MIN = @as(i32, -10);
pub const SPECIAL_DOBJ_MAX = @as(u32, 0);
pub const AUTO_WIDTH = @as(i32, -1);
pub const HIDE_COLUMN = @as(i32, -4);
pub const ILSIF_LEAVE_LARGE_ICON = @as(u32, 1073741824);
pub const ILSIF_LEAVE_SMALL_ICON = @as(u32, 536870912);
pub const HDI_HIDDEN = @as(u32, 1);
pub const RDCI_ScopeItem = @as(u32, 2147483648);
pub const RVTI_MISC_OPTIONS_NOLISTVIEWS = @as(u32, 1);
pub const RVTI_LIST_OPTIONS_NONE = @as(u32, 0);
pub const RVTI_LIST_OPTIONS_OWNERDATALIST = @as(u32, 2);
pub const RVTI_LIST_OPTIONS_MULTISELECT = @as(u32, 4);
pub const RVTI_LIST_OPTIONS_FILTERED = @as(u32, 8);
pub const RVTI_LIST_OPTIONS_USEFONTLINKING = @as(u32, 32);
pub const RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST = @as(u32, 64);
pub const RVTI_LIST_OPTIONS_LEXICAL_SORT = @as(u32, 128);
pub const RVTI_LIST_OPTIONS_ALLOWPASTE = @as(u32, 256);
pub const RVTI_HTML_OPTIONS_NONE = @as(u32, 0);
pub const RVTI_HTML_OPTIONS_NOLISTVIEW = @as(u32, 1);
pub const RVTI_OCX_OPTIONS_NONE = @as(u32, 0);
pub const RVTI_OCX_OPTIONS_NOLISTVIEW = @as(u32, 1);
pub const RVTI_OCX_OPTIONS_CACHE_OCX = @as(u32, 2);
pub const MMC_DEFAULT_OPERATION_COPY = @as(u32, 1);
pub const MMC_ITEM_OVERLAY_STATE_MASK = @as(u32, 3840);
pub const MMC_ITEM_OVERLAY_STATE_SHIFT = @as(u32, 8);
pub const MMC_ITEM_STATE_MASK = @as(u32, 255);

//--------------------------------------------------------------------------------
// Section: Types (127)
//--------------------------------------------------------------------------------
const CLSID_Application_Value = Guid.initString("49b2791a-b1ae-4c90-9b8e-e860ba07f889");
pub const CLSID_Application = &CLSID_Application_Value;

const CLSID_AppEventsDHTMLConnector_Value = Guid.initString("ade6444b-c91f-4e37-92a4-5bb430a33340");
pub const CLSID_AppEventsDHTMLConnector = &CLSID_AppEventsDHTMLConnector_Value;

pub const MMC_PROPERTY_ACTION = enum(i32) {
    DELETING = 1,
    CHANGING = 2,
    INITIALIZED = 3,
};
pub const MMC_PROPACT_DELETING = MMC_PROPERTY_ACTION.DELETING;
pub const MMC_PROPACT_CHANGING = MMC_PROPERTY_ACTION.CHANGING;
pub const MMC_PROPACT_INITIALIZED = MMC_PROPERTY_ACTION.INITIALIZED;

pub const MMC_SNAPIN_PROPERTY = extern struct {
    pszPropName: ?[*:0]const u16,
    varValue: VARIANT,
    eAction: MMC_PROPERTY_ACTION,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinProperties_Value = Guid.initString("f7889da9-4a02-4837-bf89-1a6f2a021010");
pub const IID_ISnapinProperties = &IID_ISnapinProperties_Value;
pub const ISnapinProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinProperties,
                pProperties: ?*Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinProperties,
                pProperties: ?*Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinProperties,
                pCallback: ?*ISnapinPropertiesCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinProperties,
                pCallback: ?*ISnapinPropertiesCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PropertiesChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinProperties,
                cProperties: i32,
                pProperties: [*]MMC_SNAPIN_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinProperties,
                cProperties: i32,
                pProperties: [*]MMC_SNAPIN_PROPERTY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinProperties_Initialize(self: *const T, pProperties: ?*Properties) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinProperties.VTable, self.vtable).Initialize(@ptrCast(*const ISnapinProperties, self), pProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinProperties_QueryPropertyNames(self: *const T, pCallback: ?*ISnapinPropertiesCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinProperties.VTable, self.vtable).QueryPropertyNames(@ptrCast(*const ISnapinProperties, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinProperties_PropertiesChanged(self: *const T, cProperties: i32, pProperties: [*]MMC_SNAPIN_PROPERTY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinProperties.VTable, self.vtable).PropertiesChanged(@ptrCast(*const ISnapinProperties, self), cProperties, pProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinPropertiesCallback_Value = Guid.initString("a50fa2e5-7e61-45eb-a8d4-9a07b3e851a8");
pub const IID_ISnapinPropertiesCallback = &IID_ISnapinPropertiesCallback_Value;
pub const ISnapinPropertiesCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPropertyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinPropertiesCallback,
                pszPropName: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinPropertiesCallback,
                pszPropName: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinPropertiesCallback_AddPropertyName(self: *const T, pszPropName: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinPropertiesCallback.VTable, self.vtable).AddPropertyName(@ptrCast(*const ISnapinPropertiesCallback, self), pszPropName, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _DocumentMode = enum(i32) {
    Author = 0,
    User = 1,
    User_MDI = 2,
    User_SDI = 3,
};
pub const DocumentMode_Author = _DocumentMode.Author;
pub const DocumentMode_User = _DocumentMode.User;
pub const DocumentMode_User_MDI = _DocumentMode.User_MDI;
pub const DocumentMode_User_SDI = _DocumentMode.User_SDI;

pub const _ListViewMode = enum(i32) {
    Small_Icons = 0,
    Large_Icons = 1,
    List = 2,
    Detail = 3,
    Filtered = 4,
};
pub const ListMode_Small_Icons = _ListViewMode.Small_Icons;
pub const ListMode_Large_Icons = _ListViewMode.Large_Icons;
pub const ListMode_List = _ListViewMode.List;
pub const ListMode_Detail = _ListViewMode.Detail;
pub const ListMode_Filtered = _ListViewMode.Filtered;

pub const _ViewOptions = enum(i32) {
    Default = 0,
    ScopeTreeHidden = 1,
    NoToolBars = 2,
    NotPersistable = 4,
    ActionPaneHidden = 8,
};
pub const ViewOption_Default = _ViewOptions.Default;
pub const ViewOption_ScopeTreeHidden = _ViewOptions.ScopeTreeHidden;
pub const ViewOption_NoToolBars = _ViewOptions.NoToolBars;
pub const ViewOption_NotPersistable = _ViewOptions.NotPersistable;
pub const ViewOption_ActionPaneHidden = _ViewOptions.ActionPaneHidden;

pub const _ExportListOptions = enum(i32) {
    Default = 0,
    Unicode = 1,
    TabDelimited = 2,
    SelectedItemsOnly = 4,
};
pub const ExportListOptions_Default = _ExportListOptions.Default;
pub const ExportListOptions_Unicode = _ExportListOptions.Unicode;
pub const ExportListOptions_TabDelimited = _ExportListOptions.TabDelimited;
pub const ExportListOptions_SelectedItemsOnly = _ExportListOptions.SelectedItemsOnly;

const IID__Application_Value = Guid.initString("a3afb9cc-b653-4741-86ab-f0470ec1384c");
pub const IID__Application = &IID__Application_Value;
pub const _Application = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Help: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Quit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                Document: ?*?*Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                Document: ?*?*Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _Application,
                Filename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _Application,
                Filename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                Frame: ?*?*Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                Frame: ?*?*Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                Visible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                Visible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Hide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                UserControl: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                UserControl: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                UserControl: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                UserControl: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VersionMajor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                VersionMajor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                VersionMajor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VersionMinor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const _Application,
                VersionMinor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const _Application,
                VersionMinor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Help(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const _Application.VTable, self.vtable).Help(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Quit(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const _Application.VTable, self.vtable).Quit(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_Document(self: *const T, _param_Document: ?*?*Document) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_Document(@ptrCast(*const _Application, self), _param_Document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Load(self: *const T, Filename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).Load(@ptrCast(*const _Application, self), Filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_Frame(self: *const T, _param_Frame: ?*?*Frame) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_Frame(@ptrCast(*const _Application, self), _param_Frame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_Visible(self: *const T, Visible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_Visible(@ptrCast(*const _Application, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Show(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).Show(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_Hide(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).Hide(@ptrCast(*const _Application, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_UserControl(self: *const T, UserControl: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_UserControl(@ptrCast(*const _Application, self), UserControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_put_UserControl(self: *const T, UserControl: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).put_UserControl(@ptrCast(*const _Application, self), UserControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_VersionMajor(self: *const T, VersionMajor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_VersionMajor(@ptrCast(*const _Application, self), VersionMajor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _Application_get_VersionMinor(self: *const T, VersionMinor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _Application.VTable, self.vtable).get_VersionMinor(@ptrCast(*const _Application, self), VersionMinor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__AppEvents_Value = Guid.initString("de46cbdd-53f5-4635-af54-4fe71e923d3f");
pub const IID__AppEvents = &IID__AppEvents_Value;
pub const _AppEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OnQuit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                Application: ?*_Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                Application: ?*_Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDocumentOpen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                Document: ?*Document,
                New: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                Document: ?*Document,
                New: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDocumentClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                Document: ?*Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                Document: ?*Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSnapInAdded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                Document: ?*Document,
                SnapIn: ?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                Document: ?*Document,
                SnapIn: ?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSnapInRemoved: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                Document: ?*Document,
                SnapIn: ?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                Document: ?*Document,
                SnapIn: ?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnNewView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                View: ?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                View: ?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnViewClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                View: ?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                View: ?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnViewChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                View: ?*View,
                NewOwnerNode: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                View: ?*View,
                NewOwnerNode: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSelectionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                View: ?*View,
                NewNodes: ?*Nodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                View: ?*View,
                NewNodes: ?*Nodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnContextMenuExecuted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                MenuItem: ?*MenuItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                MenuItem: ?*MenuItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnToolbarButtonClicked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnListUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _AppEvents,
                View: ?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _AppEvents,
                View: ?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnQuit(self: *const T, Application: ?*_Application) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnQuit(@ptrCast(*const _AppEvents, self), Application);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnDocumentOpen(self: *const T, _param_Document: ?*Document, New: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnDocumentOpen(@ptrCast(*const _AppEvents, self), _param_Document, New);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnDocumentClose(self: *const T, _param_Document: ?*Document) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnDocumentClose(@ptrCast(*const _AppEvents, self), _param_Document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnSnapInAdded(self: *const T, _param_Document: ?*Document, _param_SnapIn: ?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnSnapInAdded(@ptrCast(*const _AppEvents, self), _param_Document, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnSnapInRemoved(self: *const T, _param_Document: ?*Document, _param_SnapIn: ?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnSnapInRemoved(@ptrCast(*const _AppEvents, self), _param_Document, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnNewView(self: *const T, _param_View: ?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnNewView(@ptrCast(*const _AppEvents, self), _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnViewClose(self: *const T, _param_View: ?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnViewClose(@ptrCast(*const _AppEvents, self), _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnViewChange(self: *const T, _param_View: ?*View, NewOwnerNode: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnViewChange(@ptrCast(*const _AppEvents, self), _param_View, NewOwnerNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnSelectionChange(self: *const T, _param_View: ?*View, NewNodes: ?*Nodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnSelectionChange(@ptrCast(*const _AppEvents, self), _param_View, NewNodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnContextMenuExecuted(self: *const T, _param_MenuItem: ?*MenuItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnContextMenuExecuted(@ptrCast(*const _AppEvents, self), _param_MenuItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnToolbarButtonClicked(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnToolbarButtonClicked(@ptrCast(*const _AppEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _AppEvents_OnListUpdated(self: *const T, _param_View: ?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const _AppEvents.VTable, self.vtable).OnListUpdated(@ptrCast(*const _AppEvents, self), _param_View);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AppEvents_Value = Guid.initString("fc7a4252-78ac-4532-8c5a-563cfe138863");
pub const IID_AppEvents = &IID_AppEvents_Value;
pub const AppEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__EventConnector_Value = Guid.initString("c0bccd30-de44-4528-8403-a05a6a1cc8ea");
pub const IID__EventConnector = &IID__EventConnector_Value;
pub const _EventConnector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConnectTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _EventConnector,
                Application: ?*_Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _EventConnector,
                Application: ?*_Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const _EventConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const _EventConnector,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _EventConnector_ConnectTo(self: *const T, Application: ?*_Application) callconv(.Inline) HRESULT {
            return @ptrCast(*const _EventConnector.VTable, self.vtable).ConnectTo(@ptrCast(*const _EventConnector, self), Application);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _EventConnector_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const _EventConnector.VTable, self.vtable).Disconnect(@ptrCast(*const _EventConnector, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Frame_Value = Guid.initString("e5e2d970-5bb3-4306-8804-b0968a31c8e6");
pub const IID_Frame = &IID_Frame_Value;
pub const Frame = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Maximize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Minimize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Restore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                Top: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                Top: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bottom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                Bottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                Bottom: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bottom: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                bottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                bottom: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                Left: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                Left: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                left: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                left: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Right: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                Right: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                Right: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Right: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Frame,
                right: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Frame,
                right: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_Maximize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).Maximize(@ptrCast(*const Frame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_Minimize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).Minimize(@ptrCast(*const Frame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_Restore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).Restore(@ptrCast(*const Frame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Top(self: *const T, Top: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Top(@ptrCast(*const Frame, self), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Top(self: *const T, top: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Top(@ptrCast(*const Frame, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Bottom(self: *const T, Bottom: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Bottom(@ptrCast(*const Frame, self), Bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Bottom(self: *const T, bottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Bottom(@ptrCast(*const Frame, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Left(self: *const T, Left: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Left(@ptrCast(*const Frame, self), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Left(self: *const T, left: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Left(@ptrCast(*const Frame, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_get_Right(self: *const T, Right: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).get_Right(@ptrCast(*const Frame, self), Right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Frame_put_Right(self: *const T, right: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Frame.VTable, self.vtable).put_Right(@ptrCast(*const Frame, self), right);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Node_Value = Guid.initString("f81ed800-7839-4447-945d-8e15da59ca55");
pub const IID_Node = &IID_Node_Value;
pub const Node = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Node,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Node,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Property: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Node,
                PropertyName: ?BSTR,
                PropertyValue: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Node,
                PropertyName: ?BSTR,
                PropertyValue: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bookmark: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Node,
                Bookmark: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Node,
                Bookmark: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsScopeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Node,
                IsScopeNode: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Node,
                IsScopeNode: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Nodetype: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Node,
                Nodetype: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Node,
                Nodetype: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Name(@ptrCast(*const Node, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Property(self: *const T, PropertyName: ?BSTR, PropertyValue: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Property(@ptrCast(*const Node, self), PropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Bookmark(self: *const T, Bookmark: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Bookmark(@ptrCast(*const Node, self), Bookmark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_IsScopeNode(self: *const T, IsScopeNode: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).IsScopeNode(@ptrCast(*const Node, self), IsScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Node_get_Nodetype(self: *const T, Nodetype: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Node.VTable, self.vtable).get_Nodetype(@ptrCast(*const Node, self), Nodetype);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ScopeNamespace_Value = Guid.initString("ebbb48dc-1a3b-4d86-b786-c21b28389012");
pub const IID_ScopeNamespace = &IID_ScopeNamespace_Value;
pub const ScopeNamespace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
                Parent: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
                Parent: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
                Child: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
                Child: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
                Next: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
                Next: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ScopeNamespace,
                Root: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ScopeNamespace,
                Root: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ScopeNamespace,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetParent(self: *const T, _param_Node: ?*Node, Parent: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetParent(@ptrCast(*const ScopeNamespace, self), _param_Node, Parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetChild(self: *const T, _param_Node: ?*Node, Child: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetChild(@ptrCast(*const ScopeNamespace, self), _param_Node, Child);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetNext(self: *const T, _param_Node: ?*Node, Next: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetNext(@ptrCast(*const ScopeNamespace, self), _param_Node, Next);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_GetRoot(self: *const T, Root: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).GetRoot(@ptrCast(*const ScopeNamespace, self), Root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ScopeNamespace_Expand(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const ScopeNamespace.VTable, self.vtable).Expand(@ptrCast(*const ScopeNamespace, self), _param_Node);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Document_Value = Guid.initString("225120d6-1e0f-40a3-93fe-1079e6a8017b");
pub const IID_Document = &IID_Document_Value;
pub const Document = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Document,
                Filename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Document,
                Filename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Document,
                SaveChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Document,
                SaveChanges: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Views: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Views: ?*?*Views,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Views: ?*?*Views,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SnapIns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                SnapIns: ?*?*SnapIns,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                SnapIns: ?*?*SnapIns,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveView: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                View: ?*?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                View: ?*?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Location: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Location: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Location: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSaved: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                IsSaved: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                IsSaved: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Mode: ?*_DocumentMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Mode: ?*_DocumentMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Mode: _DocumentMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Mode: _DocumentMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RootNode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Node: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Node: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeNamespace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                ScopeNamespace: ?*?*ScopeNamespace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                ScopeNamespace: ?*?*ScopeNamespace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Document,
                Properties: ?*?*Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Document,
                Properties: ?*?*Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Application: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Document,
                Application: ?*?*_Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Document,
                Application: ?*?*_Application,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_Save(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).Save(@ptrCast(*const Document, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_SaveAs(self: *const T, Filename: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).SaveAs(@ptrCast(*const Document, self), Filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_Close(self: *const T, SaveChanges: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).Close(@ptrCast(*const Document, self), SaveChanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Views(self: *const T, _param_Views: ?*?*Views) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Views(@ptrCast(*const Document, self), _param_Views);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_SnapIns(self: *const T, _param_SnapIns: ?*?*SnapIns) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_SnapIns(@ptrCast(*const Document, self), _param_SnapIns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_ActiveView(self: *const T, _param_View: ?*?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_ActiveView(@ptrCast(*const Document, self), _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Name(@ptrCast(*const Document, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_put_Name(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).put_Name(@ptrCast(*const Document, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Location(self: *const T, Location: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Location(@ptrCast(*const Document, self), Location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_IsSaved(self: *const T, IsSaved: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_IsSaved(@ptrCast(*const Document, self), IsSaved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Mode(self: *const T, Mode: ?*_DocumentMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Mode(@ptrCast(*const Document, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_put_Mode(self: *const T, Mode: _DocumentMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).put_Mode(@ptrCast(*const Document, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_RootNode(self: *const T, _param_Node: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_RootNode(@ptrCast(*const Document, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_ScopeNamespace(self: *const T, _param_ScopeNamespace: ?*?*ScopeNamespace) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_ScopeNamespace(@ptrCast(*const Document, self), _param_ScopeNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_CreateProperties(self: *const T, _param_Properties: ?*?*Properties) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).CreateProperties(@ptrCast(*const Document, self), _param_Properties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Document_get_Application(self: *const T, Application: ?*?*_Application) callconv(.Inline) HRESULT {
            return @ptrCast(*const Document.VTable, self.vtable).get_Application(@ptrCast(*const Document, self), Application);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_SnapIn_Value = Guid.initString("3be910f6-3459-49c6-a1bb-41e6be9df3ea");
pub const IID_SnapIn = &IID_SnapIn_Value;
pub const SnapIn = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIn,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIn,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Vendor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIn,
                Vendor: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIn,
                Vendor: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIn,
                Version: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIn,
                Version: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Extensions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIn,
                Extensions: ?*?*Extensions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIn,
                Extensions: ?*?*Extensions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SnapinCLSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIn,
                SnapinCLSID: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIn,
                SnapinCLSID: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Properties: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIn,
                Properties: ?*?*Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIn,
                Properties: ?*?*Properties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableAllExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const SnapIn,
                Enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const SnapIn,
                Enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Name(@ptrCast(*const SnapIn, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Vendor(self: *const T, Vendor: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Vendor(@ptrCast(*const SnapIn, self), Vendor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Version(self: *const T, Version: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Version(@ptrCast(*const SnapIn, self), Version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Extensions(self: *const T, _param_Extensions: ?*?*Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Extensions(@ptrCast(*const SnapIn, self), _param_Extensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_SnapinCLSID(self: *const T, SnapinCLSID: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_SnapinCLSID(@ptrCast(*const SnapIn, self), SnapinCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_get_Properties(self: *const T, _param_Properties: ?*?*Properties) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).get_Properties(@ptrCast(*const SnapIn, self), _param_Properties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIn_EnableAllExtensions(self: *const T, Enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIn.VTable, self.vtable).EnableAllExtensions(@ptrCast(*const SnapIn, self), Enable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_SnapIns_Value = Guid.initString("2ef3de1d-b12a-49d1-92c5-0b00798768f1");
pub const IID_SnapIns = &IID_SnapIns_Value;
pub const SnapIns = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIns,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIns,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const SnapIns,
                Index: i32,
                SnapIn: ?*?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const SnapIns,
                Index: i32,
                SnapIn: ?*?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const SnapIns,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const SnapIns,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const SnapIns,
                SnapinNameOrCLSID: ?BSTR,
                ParentSnapin: VARIANT,
                Properties: VARIANT,
                SnapIn: ?*?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const SnapIns,
                SnapinNameOrCLSID: ?BSTR,
                ParentSnapin: VARIANT,
                Properties: VARIANT,
                SnapIn: ?*?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const SnapIns,
                SnapIn: ?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const SnapIns,
                SnapIn: ?*SnapIn,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).get__NewEnum(@ptrCast(*const SnapIns, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_Item(self: *const T, Index: i32, _param_SnapIn: ?*?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).Item(@ptrCast(*const SnapIns, self), Index, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).get_Count(@ptrCast(*const SnapIns, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_Add(self: *const T, SnapinNameOrCLSID: ?BSTR, ParentSnapin: VARIANT, _param_Properties: VARIANT, _param_SnapIn: ?*?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).Add(@ptrCast(*const SnapIns, self), SnapinNameOrCLSID, ParentSnapin, _param_Properties, _param_SnapIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn SnapIns_Remove(self: *const T, _param_SnapIn: ?*SnapIn) callconv(.Inline) HRESULT {
            return @ptrCast(*const SnapIns.VTable, self.vtable).Remove(@ptrCast(*const SnapIns, self), _param_SnapIn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Extension_Value = Guid.initString("ad4d6ca6-912f-409b-a26e-7fd234aef542");
pub const IID_Extension = &IID_Extension_Value;
pub const Extension = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extension,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extension,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Vendor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extension,
                Vendor: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extension,
                Vendor: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extension,
                Version: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extension,
                Version: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Extensions: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extension,
                Extensions: ?*?*Extensions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extension,
                Extensions: ?*?*Extensions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SnapinCLSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extension,
                SnapinCLSID: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extension,
                SnapinCLSID: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableAllExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Extension,
                Enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Extension,
                Enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Extension,
                Enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Extension,
                Enable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Name(@ptrCast(*const Extension, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Vendor(self: *const T, Vendor: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Vendor(@ptrCast(*const Extension, self), Vendor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Version(self: *const T, Version: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Version(@ptrCast(*const Extension, self), Version);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_Extensions(self: *const T, _param_Extensions: ?*?*Extensions) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_Extensions(@ptrCast(*const Extension, self), _param_Extensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_get_SnapinCLSID(self: *const T, SnapinCLSID: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).get_SnapinCLSID(@ptrCast(*const Extension, self), SnapinCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_EnableAllExtensions(self: *const T, Enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).EnableAllExtensions(@ptrCast(*const Extension, self), Enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extension_Enable(self: *const T, Enable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extension.VTable, self.vtable).Enable(@ptrCast(*const Extension, self), Enable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Extensions_Value = Guid.initString("82dbea43-8ca4-44bc-a2ca-d18741059ec8");
pub const IID_Extensions = &IID_Extensions_Value;
pub const Extensions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extensions,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extensions,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Extensions,
                Index: i32,
                Extension: ?*?*Extension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Extensions,
                Index: i32,
                Extension: ?*?*Extension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Extensions,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Extensions,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extensions_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extensions.VTable, self.vtable).get__NewEnum(@ptrCast(*const Extensions, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extensions_Item(self: *const T, Index: i32, _param_Extension: ?*?*Extension) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extensions.VTable, self.vtable).Item(@ptrCast(*const Extensions, self), Index, _param_Extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Extensions_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Extensions.VTable, self.vtable).get_Count(@ptrCast(*const Extensions, self), Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Columns_Value = Guid.initString("383d4d97-fc44-478b-b139-6323dc48611c");
pub const IID_Columns = &IID_Columns_Value;
pub const Columns = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Columns,
                Index: i32,
                Column: ?*?*Column,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Columns,
                Index: i32,
                Column: ?*?*Column,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Columns,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Columns,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Columns,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Columns,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Columns_Item(self: *const T, Index: i32, _param_Column: ?*?*Column) callconv(.Inline) HRESULT {
            return @ptrCast(*const Columns.VTable, self.vtable).Item(@ptrCast(*const Columns, self), Index, _param_Column);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Columns_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Columns.VTable, self.vtable).get_Count(@ptrCast(*const Columns, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Columns_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Columns.VTable, self.vtable).get__NewEnum(@ptrCast(*const Columns, self), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _ColumnSortOrder = enum(i32) {
    Ascending = 0,
    Descending = 1,
};
pub const SortOrder_Ascending = _ColumnSortOrder.Ascending;
pub const SortOrder_Descending = _ColumnSortOrder.Descending;

const IID_Column_Value = Guid.initString("fd1c5f63-2b16-4d06-9ab3-f45350b940ab");
pub const IID_Column = &IID_Column_Value;
pub const Column = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Name: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Column,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Column,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Column,
                Width: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Column,
                Width: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Column,
                Width: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Column,
                Width: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Column,
                DisplayPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Column,
                DisplayPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplayPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Column,
                Index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Column,
                Index: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Hidden: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Column,
                Hidden: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Column,
                Hidden: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Hidden: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Column,
                Hidden: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Column,
                Hidden: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAsSortColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Column,
                SortOrder: _ColumnSortOrder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Column,
                SortOrder: _ColumnSortOrder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSortColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Column,
                IsSortColumn: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Column,
                IsSortColumn: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).Name(@ptrCast(*const Column, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_get_Width(self: *const T, Width: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).get_Width(@ptrCast(*const Column, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).put_Width(@ptrCast(*const Column, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_get_DisplayPosition(self: *const T, DisplayPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).get_DisplayPosition(@ptrCast(*const Column, self), DisplayPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_put_DisplayPosition(self: *const T, Index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).put_DisplayPosition(@ptrCast(*const Column, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_get_Hidden(self: *const T, Hidden: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).get_Hidden(@ptrCast(*const Column, self), Hidden);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_put_Hidden(self: *const T, Hidden: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).put_Hidden(@ptrCast(*const Column, self), Hidden);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_SetAsSortColumn(self: *const T, SortOrder: _ColumnSortOrder) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).SetAsSortColumn(@ptrCast(*const Column, self), SortOrder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Column_IsSortColumn(self: *const T, IsSortColumn: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const Column.VTable, self.vtable).IsSortColumn(@ptrCast(*const Column, self), IsSortColumn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Views_Value = Guid.initString("d6b8c29d-a1ff-4d72-aab0-e381e9b9338d");
pub const IID_Views = &IID_Views_Value;
pub const Views = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Views,
                Index: i32,
                View: ?*?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Views,
                Index: i32,
                View: ?*?*View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Views,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Views,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Views,
                Node: ?*Node,
                viewOptions: _ViewOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Views,
                Node: ?*Node,
                viewOptions: _ViewOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Views,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Views,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_Item(self: *const T, Index: i32, _param_View: ?*?*View) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).Item(@ptrCast(*const Views, self), Index, _param_View);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).get_Count(@ptrCast(*const Views, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_Add(self: *const T, _param_Node: ?*Node, viewOptions: _ViewOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).Add(@ptrCast(*const Views, self), _param_Node, viewOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Views_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Views.VTable, self.vtable).get__NewEnum(@ptrCast(*const Views, self), retval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_View_Value = Guid.initString("6efc2da2-b38c-457e-9abb-ed2d189b8c38");
pub const IID_View = &IID_View_Value;
pub const View = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActiveScopeNode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Node: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Node: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ActiveScopeNode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Selection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Nodes: ?*?*Nodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Nodes: ?*?*Nodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ListItems: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Nodes: ?*?*Nodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Nodes: ?*?*Nodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SnapinScopeObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                ScopeNode: VARIANT,
                ScopeNodeObject: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                ScopeNode: VARIANT,
                ScopeNodeObject: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SnapinSelectionObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                SelectionObject: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                SelectionObject: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Is: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                View: ?*View,
                TheSame: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                View: ?*View,
                TheSame: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Document: ?*?*Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Document: ?*?*Document,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Select: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Deselect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                Node: ?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSelected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                Node: ?*Node,
                IsSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                Node: ?*Node,
                IsSelected: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayScopeNodePropertySheet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplaySelectionPropertySheet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyScopeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopySelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteScopeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameScopeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                NewName: ?BSTR,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                NewName: ?BSTR,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameSelectedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                NewName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                NewName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeNodeContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                ScopeNode: VARIANT,
                ContextMenu: ?*?*ContextMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                ScopeNode: VARIANT,
                ContextMenu: ?*?*ContextMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SelectionContextMenu: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                ContextMenu: ?*?*ContextMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                ContextMenu: ?*?*ContextMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshScopeNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RefreshSelection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteSelectionMenuItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                MenuItemPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                MenuItemPath: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteScopeNodeMenuItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                MenuItemPath: ?BSTR,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                MenuItemPath: ?BSTR,
                ScopeNode: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteShellCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                Command: ?BSTR,
                Directory: ?BSTR,
                Parameters: ?BSTR,
                WindowState: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                Command: ?BSTR,
                Directory: ?BSTR,
                Parameters: ?BSTR,
                WindowState: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Frame: ?*?*Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Frame: ?*?*Frame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ScopeTreeVisible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Visible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Visible: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ScopeTreeVisible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Visible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Visible: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Back: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Forward: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StatusBarText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                StatusBarText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                StatusBarText: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Memento: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Memento: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Memento: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ViewMemento: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                Memento: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                Memento: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Columns: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Columns: ?*?*Columns,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Columns: ?*?*Columns,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CellContents: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Node: ?*Node,
                Column: i32,
                CellContents: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Node: ?*Node,
                Column: i32,
                CellContents: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExportList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const View,
                File: ?BSTR,
                exportoptions: _ExportListOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const View,
                File: ?BSTR,
                exportoptions: _ExportListOptions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ListViewMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Mode: ?*_ListViewMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Mode: ?*_ListViewMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ListViewMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                mode: _ListViewMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                mode: _ListViewMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ControlObject: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const View,
                Control: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const View,
                Control: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ActiveScopeNode(self: *const T, _param_Node: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ActiveScopeNode(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_ActiveScopeNode(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_ActiveScopeNode(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Selection(self: *const T, _param_Nodes: ?*?*Nodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Selection(@ptrCast(*const View, self), _param_Nodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ListItems(self: *const T, _param_Nodes: ?*?*Nodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ListItems(@ptrCast(*const View, self), _param_Nodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_SnapinScopeObject(self: *const T, ScopeNode: VARIANT, ScopeNodeObject: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).SnapinScopeObject(@ptrCast(*const View, self), ScopeNode, ScopeNodeObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_SnapinSelectionObject(self: *const T, SelectionObject: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).SnapinSelectionObject(@ptrCast(*const View, self), SelectionObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Is(self: *const T, _param_View: ?*View, TheSame: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Is(@ptrCast(*const View, self), _param_View, TheSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Document(self: *const T, _param_Document: ?*?*Document) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Document(@ptrCast(*const View, self), _param_Document);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_SelectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).SelectAll(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Select(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Select(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Deselect(self: *const T, _param_Node: ?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Deselect(@ptrCast(*const View, self), _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_IsSelected(self: *const T, _param_Node: ?*Node, IsSelected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).IsSelected(@ptrCast(*const View, self), _param_Node, IsSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DisplayScopeNodePropertySheet(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DisplayScopeNodePropertySheet(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DisplaySelectionPropertySheet(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DisplaySelectionPropertySheet(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_CopyScopeNode(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).CopyScopeNode(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_CopySelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).CopySelection(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DeleteScopeNode(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DeleteScopeNode(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_DeleteSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).DeleteSelection(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RenameScopeNode(self: *const T, NewName: ?BSTR, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RenameScopeNode(@ptrCast(*const View, self), NewName, ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RenameSelectedItem(self: *const T, NewName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RenameSelectedItem(@ptrCast(*const View, self), NewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ScopeNodeContextMenu(self: *const T, ScopeNode: VARIANT, _param_ContextMenu: ?*?*ContextMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ScopeNodeContextMenu(@ptrCast(*const View, self), ScopeNode, _param_ContextMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_SelectionContextMenu(self: *const T, _param_ContextMenu: ?*?*ContextMenu) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_SelectionContextMenu(@ptrCast(*const View, self), _param_ContextMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RefreshScopeNode(self: *const T, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RefreshScopeNode(@ptrCast(*const View, self), ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_RefreshSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).RefreshSelection(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExecuteSelectionMenuItem(self: *const T, MenuItemPath: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExecuteSelectionMenuItem(@ptrCast(*const View, self), MenuItemPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExecuteScopeNodeMenuItem(self: *const T, MenuItemPath: ?BSTR, ScopeNode: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExecuteScopeNodeMenuItem(@ptrCast(*const View, self), MenuItemPath, ScopeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExecuteShellCommand(self: *const T, Command: ?BSTR, Directory: ?BSTR, Parameters: ?BSTR, WindowState: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExecuteShellCommand(@ptrCast(*const View, self), Command, Directory, Parameters, WindowState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Frame(self: *const T, _param_Frame: ?*?*Frame) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Frame(@ptrCast(*const View, self), _param_Frame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Close(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ScopeTreeVisible(self: *const T, Visible: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ScopeTreeVisible(@ptrCast(*const View, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_ScopeTreeVisible(self: *const T, Visible: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_ScopeTreeVisible(@ptrCast(*const View, self), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Back(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Back(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_Forward(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).Forward(@ptrCast(*const View, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_StatusBarText(self: *const T, StatusBarText: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_StatusBarText(@ptrCast(*const View, self), StatusBarText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Memento(self: *const T, Memento: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Memento(@ptrCast(*const View, self), Memento);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ViewMemento(self: *const T, Memento: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ViewMemento(@ptrCast(*const View, self), Memento);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_Columns(self: *const T, _param_Columns: ?*?*Columns) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_Columns(@ptrCast(*const View, self), _param_Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_CellContents(self: *const T, _param_Node: ?*Node, _param_Column: i32, CellContents: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_CellContents(@ptrCast(*const View, self), _param_Node, _param_Column, CellContents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_ExportList(self: *const T, File: ?BSTR, exportoptions: _ExportListOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).ExportList(@ptrCast(*const View, self), File, exportoptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ListViewMode(self: *const T, Mode: ?*_ListViewMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ListViewMode(@ptrCast(*const View, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_put_ListViewMode(self: *const T, mode: _ListViewMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).put_ListViewMode(@ptrCast(*const View, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn View_get_ControlObject(self: *const T, Control: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const View.VTable, self.vtable).get_ControlObject(@ptrCast(*const View, self), Control);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Nodes_Value = Guid.initString("313b01df-b22f-4d42-b1b8-483cdcf51d35");
pub const IID_Nodes = &IID_Nodes_Value;
pub const Nodes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Nodes,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Nodes,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Nodes,
                Index: i32,
                Node: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Nodes,
                Index: i32,
                Node: ?*?*Node,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Nodes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Nodes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Nodes_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Nodes.VTable, self.vtable).get__NewEnum(@ptrCast(*const Nodes, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Nodes_Item(self: *const T, Index: i32, _param_Node: ?*?*Node) callconv(.Inline) HRESULT {
            return @ptrCast(*const Nodes.VTable, self.vtable).Item(@ptrCast(*const Nodes, self), Index, _param_Node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Nodes_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Nodes.VTable, self.vtable).get_Count(@ptrCast(*const Nodes, self), Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ContextMenu_Value = Guid.initString("dab39ce0-25e6-4e07-8362-ba9c95706545");
pub const IID_ContextMenu = &IID_ContextMenu_Value;
pub const ContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ContextMenu,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ContextMenu,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ContextMenu,
                IndexOrPath: VARIANT,
                MenuItem: ?*?*MenuItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ContextMenu,
                IndexOrPath: VARIANT,
                MenuItem: ?*?*MenuItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ContextMenu,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ContextMenu,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ContextMenu_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ContextMenu.VTable, self.vtable).get__NewEnum(@ptrCast(*const ContextMenu, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ContextMenu_get_Item(self: *const T, IndexOrPath: VARIANT, _param_MenuItem: ?*?*MenuItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ContextMenu.VTable, self.vtable).get_Item(@ptrCast(*const ContextMenu, self), IndexOrPath, _param_MenuItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ContextMenu_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ContextMenu.VTable, self.vtable).get_Count(@ptrCast(*const ContextMenu, self), Count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_MenuItem_Value = Guid.initString("0178fad1-b361-4b27-96ad-67c57ebf2e1d");
pub const IID_MenuItem = &IID_MenuItem_Value;
pub const MenuItem = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const MenuItem,
                DisplayName: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const MenuItem,
                DisplayName: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageIndependentName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const MenuItem,
                LanguageIndependentName: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const MenuItem,
                LanguageIndependentName: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const MenuItem,
                Path: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const MenuItem,
                Path: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LanguageIndependentPath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const MenuItem,
                LanguageIndependentPath: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const MenuItem,
                LanguageIndependentPath: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const MenuItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const MenuItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const MenuItem,
                Enabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const MenuItem,
                Enabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_DisplayName(self: *const T, DisplayName: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_DisplayName(@ptrCast(*const MenuItem, self), DisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_LanguageIndependentName(self: *const T, LanguageIndependentName: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_LanguageIndependentName(@ptrCast(*const MenuItem, self), LanguageIndependentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_Path(self: *const T, Path: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_Path(@ptrCast(*const MenuItem, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_LanguageIndependentPath(self: *const T, LanguageIndependentPath: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_LanguageIndependentPath(@ptrCast(*const MenuItem, self), LanguageIndependentPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_Execute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).Execute(@ptrCast(*const MenuItem, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn MenuItem_get_Enabled(self: *const T, Enabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const MenuItem.VTable, self.vtable).get_Enabled(@ptrCast(*const MenuItem, self), Enabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Properties_Value = Guid.initString("2886abc2-a425-42b2-91c6-e25c0e04581c");
pub const IID_Properties = &IID_Properties_Value;
pub const Properties = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Properties,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Properties,
                retval: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Properties,
                Name: ?BSTR,
                Property: ?*?*Property,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Properties,
                Name: ?BSTR,
                Property: ?*?*Property,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Properties,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Properties,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Properties,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Properties,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_get__NewEnum(self: *const T, retval: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).get__NewEnum(@ptrCast(*const Properties, self), retval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_Item(self: *const T, Name: ?BSTR, _param_Property: ?*?*Property) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).Item(@ptrCast(*const Properties, self), Name, _param_Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).get_Count(@ptrCast(*const Properties, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Properties_Remove(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const Properties.VTable, self.vtable).Remove(@ptrCast(*const Properties, self), Name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Property_Value = Guid.initString("4600c3a5-e301-41d8-b6d0-ef2e4212e0ca");
pub const IID_Property = &IID_Property_Value;
pub const Property = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Property,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Property,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Property,
                Value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Property,
                Value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const Property,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const Property,
                Name: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Property_get_Value(self: *const T, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Property.VTable, self.vtable).get_Value(@ptrCast(*const Property, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Property_put_Value(self: *const T, Value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const Property.VTable, self.vtable).put_Value(@ptrCast(*const Property, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Property_get_Name(self: *const T, Name: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const Property.VTable, self.vtable).get_Name(@ptrCast(*const Property, self), Name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MMCVersionInfo_Value = Guid.initString("d6fedb1d-cf21-4bd9-af3b-c5468e9c6684");
pub const CLSID_MMCVersionInfo = &CLSID_MMCVersionInfo_Value;

const CLSID_ConsolePower_Value = Guid.initString("f0285374-dff1-11d3-b433-00c04f8ecd78");
pub const CLSID_ConsolePower = &CLSID_ConsolePower_Value;

pub const MMC_RESULT_VIEW_STYLE = enum(i32) {
    SINGLESEL = 1,
    SHOWSELALWAYS = 2,
    NOSORTHEADER = 4,
    ENSUREFOCUSVISIBLE = 8,
};
pub const MMC_SINGLESEL = MMC_RESULT_VIEW_STYLE.SINGLESEL;
pub const MMC_SHOWSELALWAYS = MMC_RESULT_VIEW_STYLE.SHOWSELALWAYS;
pub const MMC_NOSORTHEADER = MMC_RESULT_VIEW_STYLE.NOSORTHEADER;
pub const MMC_ENSUREFOCUSVISIBLE = MMC_RESULT_VIEW_STYLE.ENSUREFOCUSVISIBLE;

pub const MMC_CONTROL_TYPE = enum(i32) {
    TOOLBAR = 0,
    MENUBUTTON = 1,
    COMBOBOXBAR = 2,
};
pub const TOOLBAR = MMC_CONTROL_TYPE.TOOLBAR;
pub const MENUBUTTON = MMC_CONTROL_TYPE.MENUBUTTON;
pub const COMBOBOXBAR = MMC_CONTROL_TYPE.COMBOBOXBAR;

pub const MMC_CONSOLE_VERB = enum(i32) {
    NONE = 0,
    OPEN = 32768,
    COPY = 32769,
    PASTE = 32770,
    DELETE = 32771,
    PROPERTIES = 32772,
    RENAME = 32773,
    REFRESH = 32774,
    PRINT = 32775,
    CUT = 32776,
    MAX = 32777,
    // FIRST = 32768, this enum value conflicts with OPEN
    // LAST = 32776, this enum value conflicts with CUT
};
pub const MMC_VERB_NONE = MMC_CONSOLE_VERB.NONE;
pub const MMC_VERB_OPEN = MMC_CONSOLE_VERB.OPEN;
pub const MMC_VERB_COPY = MMC_CONSOLE_VERB.COPY;
pub const MMC_VERB_PASTE = MMC_CONSOLE_VERB.PASTE;
pub const MMC_VERB_DELETE = MMC_CONSOLE_VERB.DELETE;
pub const MMC_VERB_PROPERTIES = MMC_CONSOLE_VERB.PROPERTIES;
pub const MMC_VERB_RENAME = MMC_CONSOLE_VERB.RENAME;
pub const MMC_VERB_REFRESH = MMC_CONSOLE_VERB.REFRESH;
pub const MMC_VERB_PRINT = MMC_CONSOLE_VERB.PRINT;
pub const MMC_VERB_CUT = MMC_CONSOLE_VERB.CUT;
pub const MMC_VERB_MAX = MMC_CONSOLE_VERB.MAX;
pub const MMC_VERB_FIRST = MMC_CONSOLE_VERB.OPEN;
pub const MMC_VERB_LAST = MMC_CONSOLE_VERB.CUT;

pub const MMCBUTTON = extern struct {
    nBitmap: i32,
    idCommand: i32,
    fsState: u8,
    fsType: u8,
    lpButtonText: ?PWSTR,
    lpTooltipText: ?PWSTR,
};

pub const MMC_BUTTON_STATE = enum(i32) {
    ENABLED = 1,
    CHECKED = 2,
    HIDDEN = 4,
    INDETERMINATE = 8,
    BUTTONPRESSED = 16,
};
pub const ENABLED = MMC_BUTTON_STATE.ENABLED;
pub const CHECKED = MMC_BUTTON_STATE.CHECKED;
pub const HIDDEN = MMC_BUTTON_STATE.HIDDEN;
pub const INDETERMINATE = MMC_BUTTON_STATE.INDETERMINATE;
pub const BUTTONPRESSED = MMC_BUTTON_STATE.BUTTONPRESSED;

pub const RESULTDATAITEM = extern struct {
    mask: u32,
    bScopeItem: BOOL,
    itemID: isize,
    nIndex: i32,
    nCol: i32,
    str: ?PWSTR,
    nImage: i32,
    nState: u32,
    lParam: LPARAM,
    iIndent: i32,
};

pub const RESULTFINDINFO = extern struct {
    psz: ?PWSTR,
    nStart: i32,
    dwOptions: u32,
};

pub const SCOPEDATAITEM = extern struct {
    mask: u32,
    displayname: ?PWSTR,
    nImage: i32,
    nOpenImage: i32,
    nState: u32,
    cChildren: i32,
    lParam: LPARAM,
    relativeID: isize,
    ID: isize,
};

pub const MMC_SCOPE_ITEM_STATE = enum(i32) {
    NORMAL = 1,
    BOLD = 2,
    EXPANDEDONCE = 3,
};
pub const MMC_SCOPE_ITEM_STATE_NORMAL = MMC_SCOPE_ITEM_STATE.NORMAL;
pub const MMC_SCOPE_ITEM_STATE_BOLD = MMC_SCOPE_ITEM_STATE.BOLD;
pub const MMC_SCOPE_ITEM_STATE_EXPANDEDONCE = MMC_SCOPE_ITEM_STATE.EXPANDEDONCE;

pub const CONTEXTMENUITEM = extern struct {
    strName: ?PWSTR,
    strStatusBarText: ?PWSTR,
    lCommandID: i32,
    lInsertionPointID: i32,
    fFlags: i32,
    fSpecialFlags: i32,
};

pub const MMC_MENU_COMMAND_IDS = enum(i32) {
    T = -1,
};
pub const MMCC_STANDARD_VIEW_SELECT = MMC_MENU_COMMAND_IDS.T;

pub const MENUBUTTONDATA = extern struct {
    idCommand: i32,
    x: i32,
    y: i32,
};

pub const MMC_FILTER_TYPE = enum(i32) {
    STRING_FILTER = 0,
    INT_FILTER = 1,
    FILTER_NOVALUE = 32768,
};
pub const MMC_STRING_FILTER = MMC_FILTER_TYPE.STRING_FILTER;
pub const MMC_INT_FILTER = MMC_FILTER_TYPE.INT_FILTER;
pub const MMC_FILTER_NOVALUE = MMC_FILTER_TYPE.FILTER_NOVALUE;

pub const MMC_FILTERDATA = extern struct {
    pszText: ?PWSTR,
    cchTextMax: i32,
    lValue: i32,
};

pub const MMC_FILTER_CHANGE_CODE = enum(i32) {
    DISABLE = 0,
    ENABLE = 1,
    VALUE_CHANGE = 2,
};
pub const MFCC_DISABLE = MMC_FILTER_CHANGE_CODE.DISABLE;
pub const MFCC_ENABLE = MMC_FILTER_CHANGE_CODE.ENABLE;
pub const MFCC_VALUE_CHANGE = MMC_FILTER_CHANGE_CODE.VALUE_CHANGE;

pub const MMC_RESTORE_VIEW = extern struct {
    dwSize: u32,
    cookie: isize,
    pViewType: ?PWSTR,
    lViewOptions: i32,
};

pub const MMC_EXPANDSYNC_STRUCT = extern struct {
    bHandled: BOOL,
    bExpanding: BOOL,
    hItem: isize,
};

pub const MMC_VISIBLE_COLUMNS = extern struct {
    nVisibleColumns: i32,
    rgVisibleCols: [1]i32,
};

pub const MMC_NOTIFY_TYPE = enum(i32) {
    ACTIVATE = 32769,
    ADD_IMAGES = 32770,
    BTN_CLICK = 32771,
    CLICK = 32772,
    COLUMN_CLICK = 32773,
    CONTEXTMENU = 32774,
    CUTORMOVE = 32775,
    DBLCLICK = 32776,
    DELETE = 32777,
    DESELECT_ALL = 32778,
    EXPAND = 32779,
    HELP = 32780,
    MENU_BTNCLICK = 32781,
    MINIMIZED = 32782,
    PASTE = 32783,
    PROPERTY_CHANGE = 32784,
    QUERY_PASTE = 32785,
    REFRESH = 32786,
    REMOVE_CHILDREN = 32787,
    RENAME = 32788,
    SELECT = 32789,
    SHOW = 32790,
    VIEW_CHANGE = 32791,
    SNAPINHELP = 32792,
    CONTEXTHELP = 32793,
    INITOCX = 32794,
    FILTER_CHANGE = 32795,
    FILTERBTN_CLICK = 32796,
    RESTORE_VIEW = 32797,
    PRINT = 32798,
    PRELOAD = 32799,
    LISTPAD = 32800,
    EXPANDSYNC = 32801,
    COLUMNS_CHANGED = 32802,
    CANPASTE_OUTOFPROC = 32803,
};
pub const MMCN_ACTIVATE = MMC_NOTIFY_TYPE.ACTIVATE;
pub const MMCN_ADD_IMAGES = MMC_NOTIFY_TYPE.ADD_IMAGES;
pub const MMCN_BTN_CLICK = MMC_NOTIFY_TYPE.BTN_CLICK;
pub const MMCN_CLICK = MMC_NOTIFY_TYPE.CLICK;
pub const MMCN_COLUMN_CLICK = MMC_NOTIFY_TYPE.COLUMN_CLICK;
pub const MMCN_CONTEXTMENU = MMC_NOTIFY_TYPE.CONTEXTMENU;
pub const MMCN_CUTORMOVE = MMC_NOTIFY_TYPE.CUTORMOVE;
pub const MMCN_DBLCLICK = MMC_NOTIFY_TYPE.DBLCLICK;
pub const MMCN_DELETE = MMC_NOTIFY_TYPE.DELETE;
pub const MMCN_DESELECT_ALL = MMC_NOTIFY_TYPE.DESELECT_ALL;
pub const MMCN_EXPAND = MMC_NOTIFY_TYPE.EXPAND;
pub const MMCN_HELP = MMC_NOTIFY_TYPE.HELP;
pub const MMCN_MENU_BTNCLICK = MMC_NOTIFY_TYPE.MENU_BTNCLICK;
pub const MMCN_MINIMIZED = MMC_NOTIFY_TYPE.MINIMIZED;
pub const MMCN_PASTE = MMC_NOTIFY_TYPE.PASTE;
pub const MMCN_PROPERTY_CHANGE = MMC_NOTIFY_TYPE.PROPERTY_CHANGE;
pub const MMCN_QUERY_PASTE = MMC_NOTIFY_TYPE.QUERY_PASTE;
pub const MMCN_REFRESH = MMC_NOTIFY_TYPE.REFRESH;
pub const MMCN_REMOVE_CHILDREN = MMC_NOTIFY_TYPE.REMOVE_CHILDREN;
pub const MMCN_RENAME = MMC_NOTIFY_TYPE.RENAME;
pub const MMCN_SELECT = MMC_NOTIFY_TYPE.SELECT;
pub const MMCN_SHOW = MMC_NOTIFY_TYPE.SHOW;
pub const MMCN_VIEW_CHANGE = MMC_NOTIFY_TYPE.VIEW_CHANGE;
pub const MMCN_SNAPINHELP = MMC_NOTIFY_TYPE.SNAPINHELP;
pub const MMCN_CONTEXTHELP = MMC_NOTIFY_TYPE.CONTEXTHELP;
pub const MMCN_INITOCX = MMC_NOTIFY_TYPE.INITOCX;
pub const MMCN_FILTER_CHANGE = MMC_NOTIFY_TYPE.FILTER_CHANGE;
pub const MMCN_FILTERBTN_CLICK = MMC_NOTIFY_TYPE.FILTERBTN_CLICK;
pub const MMCN_RESTORE_VIEW = MMC_NOTIFY_TYPE.RESTORE_VIEW;
pub const MMCN_PRINT = MMC_NOTIFY_TYPE.PRINT;
pub const MMCN_PRELOAD = MMC_NOTIFY_TYPE.PRELOAD;
pub const MMCN_LISTPAD = MMC_NOTIFY_TYPE.LISTPAD;
pub const MMCN_EXPANDSYNC = MMC_NOTIFY_TYPE.EXPANDSYNC;
pub const MMCN_COLUMNS_CHANGED = MMC_NOTIFY_TYPE.COLUMNS_CHANGED;
pub const MMCN_CANPASTE_OUTOFPROC = MMC_NOTIFY_TYPE.CANPASTE_OUTOFPROC;

pub const DATA_OBJECT_TYPES = enum(i32) {
    SCOPE = 32768,
    RESULT = 32769,
    SNAPIN_MANAGER = 32770,
    UNINITIALIZED = 65535,
};
pub const CCT_SCOPE = DATA_OBJECT_TYPES.SCOPE;
pub const CCT_RESULT = DATA_OBJECT_TYPES.RESULT;
pub const CCT_SNAPIN_MANAGER = DATA_OBJECT_TYPES.SNAPIN_MANAGER;
pub const CCT_UNINITIALIZED = DATA_OBJECT_TYPES.UNINITIALIZED;

pub const SMMCDataObjects = extern struct {
    count: u32,
    lpDataObject: [1]?*IDataObject,
};

pub const SMMCObjectTypes = extern struct {
    count: u32,
    guid: [1]Guid,
};

pub const SNodeID = extern struct {
    cBytes: u32,
    id: [1]u8,
};

pub const SNodeID2 = extern struct {
    dwFlags: u32,
    cBytes: u32,
    id: [1]u8,
};

pub const SColumnSetID = extern struct {
    dwFlags: u32,
    cBytes: u32,
    id: [1]u8,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponentData_Value = Guid.initString("955ab28a-5218-11d0-a985-00c04fd8d565");
pub const IID_IComponentData = &IID_IComponentData_Value;
pub const IComponentData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
                pUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
                ppComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
                ppComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
                lpDataObject: ?*IDataObject,
                event: MMC_NOTIFY_TYPE,
                arg: LPARAM,
                param3: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
                lpDataObject: ?*IDataObject,
                event: MMC_NOTIFY_TYPE,
                arg: LPARAM,
                param3: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryDataObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
                pScopeDataItem: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
                pScopeDataItem: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData,
                lpDataObjectA: ?*IDataObject,
                lpDataObjectB: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData,
                lpDataObjectA: ?*IDataObject,
                lpDataObjectB: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_Initialize(self: *const T, pUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).Initialize(@ptrCast(*const IComponentData, self), pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_CreateComponent(self: *const T, ppComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).CreateComponent(@ptrCast(*const IComponentData, self), ppComponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_Notify(self: *const T, lpDataObject: ?*IDataObject, event: MMC_NOTIFY_TYPE, arg: LPARAM, param3: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).Notify(@ptrCast(*const IComponentData, self), lpDataObject, event, arg, param3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_Destroy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).Destroy(@ptrCast(*const IComponentData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_QueryDataObject(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDataObject: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).QueryDataObject(@ptrCast(*const IComponentData, self), cookie, type_, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_GetDisplayInfo(self: *const T, pScopeDataItem: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).GetDisplayInfo(@ptrCast(*const IComponentData, self), pScopeDataItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData_CompareObjects(self: *const T, lpDataObjectA: ?*IDataObject, lpDataObjectB: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData.VTable, self.vtable).CompareObjects(@ptrCast(*const IComponentData, self), lpDataObjectA, lpDataObjectB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent_Value = Guid.initString("43136eb2-d36c-11cf-adbc-00aa00a80033");
pub const IID_IComponent = &IID_IComponent_Value;
pub const IComponent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                lpConsole: ?*IConsole,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                lpConsole: ?*IConsole,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                lpDataObject: ?*IDataObject,
                event: MMC_NOTIFY_TYPE,
                arg: LPARAM,
                param3: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                lpDataObject: ?*IDataObject,
                event: MMC_NOTIFY_TYPE,
                arg: LPARAM,
                param3: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Destroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                cookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                cookie: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryDataObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDataObject: ?*?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResultViewType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                cookie: isize,
                ppViewType: ?*?PWSTR,
                pViewOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                cookie: isize,
                ppViewType: ?*?PWSTR,
                pViewOptions: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                pResultDataItem: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                pResultDataItem: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                lpDataObjectA: ?*IDataObject,
                lpDataObjectB: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                lpDataObjectA: ?*IDataObject,
                lpDataObjectB: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Initialize(self: *const T, lpConsole: ?*IConsole) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Initialize(@ptrCast(*const IComponent, self), lpConsole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Notify(self: *const T, lpDataObject: ?*IDataObject, event: MMC_NOTIFY_TYPE, arg: LPARAM, param3: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Notify(@ptrCast(*const IComponent, self), lpDataObject, event, arg, param3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Destroy(self: *const T, cookie: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).Destroy(@ptrCast(*const IComponent, self), cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_QueryDataObject(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDataObject: ?*?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).QueryDataObject(@ptrCast(*const IComponent, self), cookie, type_, ppDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_GetResultViewType(self: *const T, cookie: isize, ppViewType: ?*?PWSTR, pViewOptions: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).GetResultViewType(@ptrCast(*const IComponent, self), cookie, ppViewType, pViewOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_GetDisplayInfo(self: *const T, pResultDataItem: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).GetDisplayInfo(@ptrCast(*const IComponent, self), pResultDataItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_CompareObjects(self: *const T, lpDataObjectA: ?*IDataObject, lpDataObjectB: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent.VTable, self.vtable).CompareObjects(@ptrCast(*const IComponent, self), lpDataObjectA, lpDataObjectB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultDataCompare_Value = Guid.initString("e8315a52-7a1a-11d0-a2d2-00c04fd909dd");
pub const IID_IResultDataCompare = &IID_IResultDataCompare_Value;
pub const IResultDataCompare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultDataCompare,
                lUserParam: LPARAM,
                cookieA: isize,
                cookieB: isize,
                pnResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultDataCompare,
                lUserParam: LPARAM,
                cookieA: isize,
                cookieB: isize,
                pnResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultDataCompare_Compare(self: *const T, lUserParam: LPARAM, cookieA: isize, cookieB: isize, pnResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultDataCompare.VTable, self.vtable).Compare(@ptrCast(*const IResultDataCompare, self), lUserParam, cookieA, cookieB, pnResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultOwnerData_Value = Guid.initString("9cb396d8-ea83-11d0-aef1-00c04fb6dd2c");
pub const IID_IResultOwnerData = &IID_IResultOwnerData_Value;
pub const IResultOwnerData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultOwnerData,
                pFindInfo: ?*RESULTFINDINFO,
                pnFoundIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultOwnerData,
                pFindInfo: ?*RESULTFINDINFO,
                pnFoundIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CacheHint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultOwnerData,
                nStartIndex: i32,
                nEndIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultOwnerData,
                nStartIndex: i32,
                nEndIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SortItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultOwnerData,
                nColumn: i32,
                dwSortOptions: u32,
                lUserParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultOwnerData,
                nColumn: i32,
                dwSortOptions: u32,
                lUserParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultOwnerData_FindItem(self: *const T, pFindInfo: ?*RESULTFINDINFO, pnFoundIndex: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultOwnerData.VTable, self.vtable).FindItem(@ptrCast(*const IResultOwnerData, self), pFindInfo, pnFoundIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultOwnerData_CacheHint(self: *const T, nStartIndex: i32, nEndIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultOwnerData.VTable, self.vtable).CacheHint(@ptrCast(*const IResultOwnerData, self), nStartIndex, nEndIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultOwnerData_SortItems(self: *const T, nColumn: i32, dwSortOptions: u32, lUserParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultOwnerData.VTable, self.vtable).SortItems(@ptrCast(*const IResultOwnerData, self), nColumn, dwSortOptions, lUserParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsole_Value = Guid.initString("43136eb1-d36c-11cf-adbc-00aa00a80033");
pub const IID_IConsole = &IID_IConsole_Value;
pub const IConsole = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHeader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                pHeader: ?*IHeaderCtrl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                pHeader: ?*IHeaderCtrl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetToolbar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                pToolbar: ?*IToolbar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                pToolbar: ?*IToolbar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryResultView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                pUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                pUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryScopeImageList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                ppImageList: ?*?*IImageList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                ppImageList: ?*?*IImageList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryResultImageList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                ppImageList: ?*?*IImageList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                ppImageList: ?*?*IImageList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAllViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                lpDataObject: ?*IDataObject,
                data: LPARAM,
                hint: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                lpDataObject: ?*IDataObject,
                data: LPARAM,
                hint: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MessageBox: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                lpszText: ?[*:0]const u16,
                lpszTitle: ?[*:0]const u16,
                fuStyle: u32,
                piRetval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                lpszText: ?[*:0]const u16,
                lpszTitle: ?[*:0]const u16,
                fuStyle: u32,
                piRetval: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryConsoleVerb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                ppConsoleVerb: ?*?*IConsoleVerb,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                ppConsoleVerb: ?*?*IConsoleVerb,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectScopeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                hScopeItem: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                hScopeItem: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMainWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NewWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole,
                hScopeItem: isize,
                lOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole,
                hScopeItem: isize,
                lOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_SetHeader(self: *const T, pHeader: ?*IHeaderCtrl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).SetHeader(@ptrCast(*const IConsole, self), pHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_SetToolbar(self: *const T, pToolbar: ?*IToolbar) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).SetToolbar(@ptrCast(*const IConsole, self), pToolbar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryResultView(self: *const T, pUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryResultView(@ptrCast(*const IConsole, self), pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryScopeImageList(self: *const T, ppImageList: ?*?*IImageList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryScopeImageList(@ptrCast(*const IConsole, self), ppImageList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryResultImageList(self: *const T, ppImageList: ?*?*IImageList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryResultImageList(@ptrCast(*const IConsole, self), ppImageList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_UpdateAllViews(self: *const T, lpDataObject: ?*IDataObject, data: LPARAM, hint: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).UpdateAllViews(@ptrCast(*const IConsole, self), lpDataObject, data, hint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_MessageBox(self: *const T, lpszText: ?[*:0]const u16, lpszTitle: ?[*:0]const u16, fuStyle: u32, piRetval: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).MessageBox(@ptrCast(*const IConsole, self), lpszText, lpszTitle, fuStyle, piRetval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_QueryConsoleVerb(self: *const T, ppConsoleVerb: ?*?*IConsoleVerb) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).QueryConsoleVerb(@ptrCast(*const IConsole, self), ppConsoleVerb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_SelectScopeItem(self: *const T, hScopeItem: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).SelectScopeItem(@ptrCast(*const IConsole, self), hScopeItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_GetMainWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).GetMainWindow(@ptrCast(*const IConsole, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole_NewWindow(self: *const T, hScopeItem: isize, lOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole.VTable, self.vtable).NewWindow(@ptrCast(*const IConsole, self), hScopeItem, lOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IHeaderCtrl_Value = Guid.initString("43136eb3-d36c-11cf-adbc-00aa00a80033");
pub const IID_IHeaderCtrl = &IID_IHeaderCtrl_Value;
pub const IHeaderCtrl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                title: ?[*:0]const u16,
                nFormat: i32,
                nWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                title: ?[*:0]const u16,
                nFormat: i32,
                nWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl,
                nCol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl,
                nCol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumnText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                title: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                title: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                pText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                pText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumnWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                nWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                nWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl,
                nCol: i32,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_InsertColumn(self: *const T, nCol: i32, title: ?[*:0]const u16, nFormat: i32, nWidth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).InsertColumn(@ptrCast(*const IHeaderCtrl, self), nCol, title, nFormat, nWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_DeleteColumn(self: *const T, nCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).DeleteColumn(@ptrCast(*const IHeaderCtrl, self), nCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_SetColumnText(self: *const T, nCol: i32, title: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).SetColumnText(@ptrCast(*const IHeaderCtrl, self), nCol, title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_GetColumnText(self: *const T, nCol: i32, pText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).GetColumnText(@ptrCast(*const IHeaderCtrl, self), nCol, pText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_SetColumnWidth(self: *const T, nCol: i32, nWidth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).SetColumnWidth(@ptrCast(*const IHeaderCtrl, self), nCol, nWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl_GetColumnWidth(self: *const T, nCol: i32, pWidth: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl.VTable, self.vtable).GetColumnWidth(@ptrCast(*const IHeaderCtrl, self), nCol, pWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CCM_INSERTIONPOINTID = enum(i32) {
    MASK_SPECIAL = -65536,
    MASK_SHARED = -2147483648,
    MASK_CREATE_PRIMARY = 1073741824,
    MASK_ADD_PRIMARY = 536870912,
    MASK_ADD_3RDPARTY = 268435456,
    MASK_RESERVED = 268369920,
    MASK_FLAGINDEX = 31,
    PRIMARY_TOP = -1610612736,
    PRIMARY_NEW = -1610612735,
    PRIMARY_TASK = -1610612734,
    PRIMARY_VIEW = -1610612733,
    PRIMARY_HELP = -1610612732,
    @"3RDPARTY_NEW" = -1879048191,
    @"3RDPARTY_TASK" = -1879048190,
    // ROOT_MENU = -2147483648, this enum value conflicts with MASK_SHARED
};
pub const CCM_INSERTIONPOINTID_MASK_SPECIAL = CCM_INSERTIONPOINTID.MASK_SPECIAL;
pub const CCM_INSERTIONPOINTID_MASK_SHARED = CCM_INSERTIONPOINTID.MASK_SHARED;
pub const CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY = CCM_INSERTIONPOINTID.MASK_CREATE_PRIMARY;
pub const CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY = CCM_INSERTIONPOINTID.MASK_ADD_PRIMARY;
pub const CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY = CCM_INSERTIONPOINTID.MASK_ADD_3RDPARTY;
pub const CCM_INSERTIONPOINTID_MASK_RESERVED = CCM_INSERTIONPOINTID.MASK_RESERVED;
pub const CCM_INSERTIONPOINTID_MASK_FLAGINDEX = CCM_INSERTIONPOINTID.MASK_FLAGINDEX;
pub const CCM_INSERTIONPOINTID_PRIMARY_TOP = CCM_INSERTIONPOINTID.PRIMARY_TOP;
pub const CCM_INSERTIONPOINTID_PRIMARY_NEW = CCM_INSERTIONPOINTID.PRIMARY_NEW;
pub const CCM_INSERTIONPOINTID_PRIMARY_TASK = CCM_INSERTIONPOINTID.PRIMARY_TASK;
pub const CCM_INSERTIONPOINTID_PRIMARY_VIEW = CCM_INSERTIONPOINTID.PRIMARY_VIEW;
pub const CCM_INSERTIONPOINTID_PRIMARY_HELP = CCM_INSERTIONPOINTID.PRIMARY_HELP;
pub const CCM_INSERTIONPOINTID_3RDPARTY_NEW = CCM_INSERTIONPOINTID.@"3RDPARTY_NEW";
pub const CCM_INSERTIONPOINTID_3RDPARTY_TASK = CCM_INSERTIONPOINTID.@"3RDPARTY_TASK";
pub const CCM_INSERTIONPOINTID_ROOT_MENU = CCM_INSERTIONPOINTID.MASK_SHARED;

pub const CCM_INSERTIONALLOWED = enum(i32) {
    TOP = 1,
    NEW = 2,
    TASK = 4,
    VIEW = 8,
};
pub const CCM_INSERTIONALLOWED_TOP = CCM_INSERTIONALLOWED.TOP;
pub const CCM_INSERTIONALLOWED_NEW = CCM_INSERTIONALLOWED.NEW;
pub const CCM_INSERTIONALLOWED_TASK = CCM_INSERTIONALLOWED.TASK;
pub const CCM_INSERTIONALLOWED_VIEW = CCM_INSERTIONALLOWED.VIEW;

pub const CCM_COMMANDID_MASK_CONSTANTS = enum(u32) {
    D = 4294901760,
};
pub const CCM_COMMANDID_MASK_RESERVED = CCM_COMMANDID_MASK_CONSTANTS.D;

pub const CCM_SPECIAL = enum(i32) {
    SEPARATOR = 1,
    SUBMENU = 2,
    DEFAULT_ITEM = 4,
    INSERTION_POINT = 8,
    TESTONLY = 16,
};
pub const CCM_SPECIAL_SEPARATOR = CCM_SPECIAL.SEPARATOR;
pub const CCM_SPECIAL_SUBMENU = CCM_SPECIAL.SUBMENU;
pub const CCM_SPECIAL_DEFAULT_ITEM = CCM_SPECIAL.DEFAULT_ITEM;
pub const CCM_SPECIAL_INSERTION_POINT = CCM_SPECIAL.INSERTION_POINT;
pub const CCM_SPECIAL_TESTONLY = CCM_SPECIAL.TESTONLY;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuCallback_Value = Guid.initString("43136eb7-d36c-11cf-adbc-00aa00a80033");
pub const IID_IContextMenuCallback = &IID_IContextMenuCallback_Value;
pub const IContextMenuCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContextMenuCallback,
                pItem: ?*CONTEXTMENUITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContextMenuCallback,
                pItem: ?*CONTEXTMENUITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuCallback_AddItem(self: *const T, pItem: ?*CONTEXTMENUITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuCallback.VTable, self.vtable).AddItem(@ptrCast(*const IContextMenuCallback, self), pItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuProvider_Value = Guid.initString("43136eb6-d36c-11cf-adbc-00aa00a80033");
pub const IID_IContextMenuProvider = &IID_IContextMenuProvider_Value;
pub const IContextMenuProvider = extern struct {
    pub const VTable = extern struct {
        base: IContextMenuCallback.VTable,
        EmptyMenuList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContextMenuProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContextMenuProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPrimaryExtensionItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContextMenuProvider,
                piExtension: ?*IUnknown,
                piDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContextMenuProvider,
                piExtension: ?*IUnknown,
                piDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddThirdPartyExtensionItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContextMenuProvider,
                piDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContextMenuProvider,
                piDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContextMenuProvider,
                hwndParent: ?HWND,
                xPos: i32,
                yPos: i32,
                plSelected: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContextMenuProvider,
                hwndParent: ?HWND,
                xPos: i32,
                yPos: i32,
                plSelected: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IContextMenuCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_EmptyMenuList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).EmptyMenuList(@ptrCast(*const IContextMenuProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_AddPrimaryExtensionItems(self: *const T, piExtension: ?*IUnknown, piDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).AddPrimaryExtensionItems(@ptrCast(*const IContextMenuProvider, self), piExtension, piDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_AddThirdPartyExtensionItems(self: *const T, piDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).AddThirdPartyExtensionItems(@ptrCast(*const IContextMenuProvider, self), piDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuProvider_ShowContextMenu(self: *const T, hwndParent: ?HWND, xPos: i32, yPos: i32, plSelected: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuProvider.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IContextMenuProvider, self), hwndParent, xPos, yPos, plSelected);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendContextMenu_Value = Guid.initString("4f3b7a4f-cfac-11cf-b8e3-00c04fd8d5b0");
pub const IID_IExtendContextMenu = &IID_IExtendContextMenu_Value;
pub const IExtendContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMenuItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendContextMenu,
                piDataObject: ?*IDataObject,
                piCallback: ?*IContextMenuCallback,
                pInsertionAllowed: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendContextMenu,
                piDataObject: ?*IDataObject,
                piCallback: ?*IContextMenuCallback,
                pInsertionAllowed: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Command: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendContextMenu,
                lCommandID: i32,
                piDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendContextMenu,
                lCommandID: i32,
                piDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendContextMenu_AddMenuItems(self: *const T, piDataObject: ?*IDataObject, piCallback: ?*IContextMenuCallback, pInsertionAllowed: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendContextMenu.VTable, self.vtable).AddMenuItems(@ptrCast(*const IExtendContextMenu, self), piDataObject, piCallback, pInsertionAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendContextMenu_Command(self: *const T, lCommandID: i32, piDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendContextMenu.VTable, self.vtable).Command(@ptrCast(*const IExtendContextMenu, self), lCommandID, piDataObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IImageList_Value = Guid.initString("43136eb8-d36c-11cf-adbc-00aa00a80033");
pub const IID_IImageList = &IID_IImageList_Value;
pub const IImageList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ImageListSetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageList,
                pIcon: ?*isize,
                nLoc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageList,
                pIcon: ?*isize,
                nLoc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ImageListSetStrip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageList,
                pBMapSm: ?*isize,
                pBMapLg: ?*isize,
                nStartLoc: i32,
                cMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageList,
                pBMapSm: ?*isize,
                pBMapLg: ?*isize,
                nStartLoc: i32,
                cMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ImageListSetIcon(self: *const T, pIcon: ?*isize, nLoc: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ImageListSetIcon(@ptrCast(*const IImageList, self), pIcon, nLoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ImageListSetStrip(self: *const T, pBMapSm: ?*isize, pBMapLg: ?*isize, nStartLoc: i32, cMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ImageListSetStrip(@ptrCast(*const IImageList, self), pBMapSm, pBMapLg, nStartLoc, cMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultData_Value = Guid.initString("31da5fa0-e0eb-11cf-9f21-00aa003ca9f6");
pub const IID_IResultData = &IID_IResultData_Value;
pub const IResultData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                itemID: isize,
                nCol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                itemID: isize,
                nCol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindItemByLParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                lParam: LPARAM,
                pItemID: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                lParam: LPARAM,
                pItemID: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteAllRsltItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                item: ?*RESULTDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyItemState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                nIndex: i32,
                itemID: isize,
                uAdd: u32,
                uRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                nIndex: i32,
                itemID: isize,
                uAdd: u32,
                uRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyViewStyle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                add: MMC_RESULT_VIEW_STYLE,
                remove: MMC_RESULT_VIEW_STYLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                add: MMC_RESULT_VIEW_STYLE,
                remove: MMC_RESULT_VIEW_STYLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetViewMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                lViewMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                lViewMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetViewMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                lViewMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                lViewMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                itemID: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                itemID: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Sort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                nColumn: i32,
                dwSortOptions: u32,
                lUserParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                nColumn: i32,
                dwSortOptions: u32,
                lUserParam: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescBarText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                DescText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                DescText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData,
                nItemCount: i32,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData,
                nItemCount: i32,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_InsertItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).InsertItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_DeleteItem(self: *const T, itemID: isize, nCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).DeleteItem(@ptrCast(*const IResultData, self), itemID, nCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_FindItemByLParam(self: *const T, lParam: LPARAM, pItemID: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).FindItemByLParam(@ptrCast(*const IResultData, self), lParam, pItemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_DeleteAllRsltItems(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).DeleteAllRsltItems(@ptrCast(*const IResultData, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_GetItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).GetItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_GetNextItem(self: *const T, item: ?*RESULTDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).GetNextItem(@ptrCast(*const IResultData, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_ModifyItemState(self: *const T, nIndex: i32, itemID: isize, uAdd: u32, uRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).ModifyItemState(@ptrCast(*const IResultData, self), nIndex, itemID, uAdd, uRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_ModifyViewStyle(self: *const T, add: MMC_RESULT_VIEW_STYLE, remove: MMC_RESULT_VIEW_STYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).ModifyViewStyle(@ptrCast(*const IResultData, self), add, remove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetViewMode(self: *const T, lViewMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetViewMode(@ptrCast(*const IResultData, self), lViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_GetViewMode(self: *const T, lViewMode: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).GetViewMode(@ptrCast(*const IResultData, self), lViewMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_UpdateItem(self: *const T, itemID: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).UpdateItem(@ptrCast(*const IResultData, self), itemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_Sort(self: *const T, nColumn: i32, dwSortOptions: u32, lUserParam: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).Sort(@ptrCast(*const IResultData, self), nColumn, dwSortOptions, lUserParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetDescBarText(self: *const T, DescText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetDescBarText(@ptrCast(*const IResultData, self), DescText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData_SetItemCount(self: *const T, nItemCount: i32, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData.VTable, self.vtable).SetItemCount(@ptrCast(*const IResultData, self), nItemCount, dwOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsoleNameSpace_Value = Guid.initString("bedeb620-f24d-11cf-8afc-00aa003ca9f6");
pub const IID_IConsoleNameSpace = &IID_IConsoleNameSpace_Value;
pub const IConsoleNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InsertItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                item: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                item: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                hItem: isize,
                fDeleteThis: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                hItem: isize,
                fDeleteThis: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                item: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                item: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                item: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                item: ?*SCOPEDATAITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChildItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                item: isize,
                pItemChild: ?*isize,
                pCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                item: isize,
                pItemChild: ?*isize,
                pCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                item: isize,
                pItemNext: ?*isize,
                pCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                item: isize,
                pItemNext: ?*isize,
                pCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace,
                item: isize,
                pItemParent: ?*isize,
                pCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace,
                item: isize,
                pItemParent: ?*isize,
                pCookie: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_InsertItem(self: *const T, item: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).InsertItem(@ptrCast(*const IConsoleNameSpace, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_DeleteItem(self: *const T, hItem: isize, fDeleteThis: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).DeleteItem(@ptrCast(*const IConsoleNameSpace, self), hItem, fDeleteThis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_SetItem(self: *const T, item: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).SetItem(@ptrCast(*const IConsoleNameSpace, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetItem(self: *const T, item: ?*SCOPEDATAITEM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetItem(@ptrCast(*const IConsoleNameSpace, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetChildItem(self: *const T, item: isize, pItemChild: ?*isize, pCookie: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetChildItem(@ptrCast(*const IConsoleNameSpace, self), item, pItemChild, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetNextItem(self: *const T, item: isize, pItemNext: ?*isize, pCookie: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetNextItem(@ptrCast(*const IConsoleNameSpace, self), item, pItemNext, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace_GetParentItem(self: *const T, item: isize, pItemParent: ?*isize, pCookie: ?*isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace.VTable, self.vtable).GetParentItem(@ptrCast(*const IConsoleNameSpace, self), item, pItemParent, pCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsoleNameSpace2_Value = Guid.initString("255f18cc-65db-11d1-a7dc-00c04fd8d565");
pub const IID_IConsoleNameSpace2 = &IID_IConsoleNameSpace2_Value;
pub const IConsoleNameSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IConsoleNameSpace.VTable,
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace2,
                hItem: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace2,
                hItem: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleNameSpace2,
                hItem: isize,
                lpClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleNameSpace2,
                hItem: isize,
                lpClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConsoleNameSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace2_Expand(self: *const T, hItem: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace2.VTable, self.vtable).Expand(@ptrCast(*const IConsoleNameSpace2, self), hItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleNameSpace2_AddExtension(self: *const T, hItem: isize, lpClsid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleNameSpace2.VTable, self.vtable).AddExtension(@ptrCast(*const IConsoleNameSpace2, self), hItem, lpClsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPropertySheetCallback_Value = Guid.initString("85de64dd-ef21-11cf-a285-00c04fd8dbe6");
pub const IID_IPropertySheetCallback = &IID_IPropertySheetCallback_Value;
pub const IPropertySheetCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetCallback,
                hPage: ?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetCallback,
                hPage: ?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetCallback,
                hPage: ?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetCallback,
                hPage: ?HPROPSHEETPAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetCallback_AddPage(self: *const T, hPage: ?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetCallback.VTable, self.vtable).AddPage(@ptrCast(*const IPropertySheetCallback, self), hPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetCallback_RemovePage(self: *const T, hPage: ?HPROPSHEETPAGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetCallback.VTable, self.vtable).RemovePage(@ptrCast(*const IPropertySheetCallback, self), hPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IPropertySheetProvider_Value = Guid.initString("85de64de-ef21-11cf-a285-00c04fd8dbe6");
pub const IID_IPropertySheetProvider = &IID_IPropertySheetProvider_Value;
pub const IPropertySheetProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertySheet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetProvider,
                title: ?[*:0]const u16,
                type: u8,
                cookie: isize,
                pIDataObjectm: ?*IDataObject,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetProvider,
                title: ?[*:0]const u16,
                type: u8,
                cookie: isize,
                pIDataObjectm: ?*IDataObject,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindPropertySheet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetProvider,
                hItem: isize,
                lpComponent: ?*IComponent,
                lpDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetProvider,
                hItem: isize,
                lpComponent: ?*IComponent,
                lpDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPrimaryPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetProvider,
                lpUnknown: ?*IUnknown,
                bCreateHandle: BOOL,
                hNotifyWindow: ?HWND,
                bScopePane: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetProvider,
                lpUnknown: ?*IUnknown,
                bCreateHandle: BOOL,
                hNotifyWindow: ?HWND,
                bScopePane: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySheetProvider,
                window: isize,
                page: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySheetProvider,
                window: isize,
                page: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_CreatePropertySheet(self: *const T, title: ?[*:0]const u16, type_: u8, cookie: isize, pIDataObjectm: ?*IDataObject, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).CreatePropertySheet(@ptrCast(*const IPropertySheetProvider, self), title, type_, cookie, pIDataObjectm, dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_FindPropertySheet(self: *const T, hItem: isize, lpComponent: ?*IComponent, lpDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).FindPropertySheet(@ptrCast(*const IPropertySheetProvider, self), hItem, lpComponent, lpDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_AddPrimaryPages(self: *const T, lpUnknown: ?*IUnknown, bCreateHandle: BOOL, hNotifyWindow: ?HWND, bScopePane: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).AddPrimaryPages(@ptrCast(*const IPropertySheetProvider, self), lpUnknown, bCreateHandle, hNotifyWindow, bScopePane);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_AddExtensionPages(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).AddExtensionPages(@ptrCast(*const IPropertySheetProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySheetProvider_Show(self: *const T, window: isize, page: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPropertySheetProvider.VTable, self.vtable).Show(@ptrCast(*const IPropertySheetProvider, self), window, page);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendPropertySheet_Value = Guid.initString("85de64dc-ef21-11cf-a285-00c04fd8dbe6");
pub const IID_IExtendPropertySheet = &IID_IExtendPropertySheet_Value;
pub const IExtendPropertySheet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendPropertySheet,
                lpProvider: ?*IPropertySheetCallback,
                handle: isize,
                lpIDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendPropertySheet,
                lpProvider: ?*IPropertySheetCallback,
                handle: isize,
                lpIDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPagesFor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendPropertySheet,
                lpDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendPropertySheet,
                lpDataObject: ?*IDataObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendPropertySheet_CreatePropertyPages(self: *const T, lpProvider: ?*IPropertySheetCallback, handle: isize, lpIDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendPropertySheet.VTable, self.vtable).CreatePropertyPages(@ptrCast(*const IExtendPropertySheet, self), lpProvider, handle, lpIDataObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendPropertySheet_QueryPagesFor(self: *const T, lpDataObject: ?*IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendPropertySheet.VTable, self.vtable).QueryPagesFor(@ptrCast(*const IExtendPropertySheet, self), lpDataObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IControlbar_Value = Guid.initString("69fb811e-6c1c-11d0-a2cb-00c04fd909dd");
pub const IID_IControlbar = &IID_IControlbar_Value;
pub const IControlbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IControlbar,
                nType: MMC_CONTROL_TYPE,
                pExtendControlbar: ?*IExtendControlbar,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IControlbar,
                nType: MMC_CONTROL_TYPE,
                pExtendControlbar: ?*IExtendControlbar,
                ppUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IControlbar,
                nType: MMC_CONTROL_TYPE,
                lpUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IControlbar,
                nType: MMC_CONTROL_TYPE,
                lpUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IControlbar,
                lpUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IControlbar,
                lpUnknown: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlbar_Create(self: *const T, nType: MMC_CONTROL_TYPE, pExtendControlbar: ?*IExtendControlbar, ppUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlbar.VTable, self.vtable).Create(@ptrCast(*const IControlbar, self), nType, pExtendControlbar, ppUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlbar_Attach(self: *const T, nType: MMC_CONTROL_TYPE, lpUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlbar.VTable, self.vtable).Attach(@ptrCast(*const IControlbar, self), nType, lpUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IControlbar_Detach(self: *const T, lpUnknown: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IControlbar.VTable, self.vtable).Detach(@ptrCast(*const IControlbar, self), lpUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendControlbar_Value = Guid.initString("49506520-6f40-11d0-a98b-00c04fd8d565");
pub const IID_IExtendControlbar = &IID_IExtendControlbar_Value;
pub const IExtendControlbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetControlbar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendControlbar,
                pControlbar: ?*IControlbar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendControlbar,
                pControlbar: ?*IControlbar,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlbarNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendControlbar,
                event: MMC_NOTIFY_TYPE,
                arg: LPARAM,
                param2: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendControlbar,
                event: MMC_NOTIFY_TYPE,
                arg: LPARAM,
                param2: LPARAM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendControlbar_SetControlbar(self: *const T, pControlbar: ?*IControlbar) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendControlbar.VTable, self.vtable).SetControlbar(@ptrCast(*const IExtendControlbar, self), pControlbar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendControlbar_ControlbarNotify(self: *const T, event: MMC_NOTIFY_TYPE, arg: LPARAM, param2: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendControlbar.VTable, self.vtable).ControlbarNotify(@ptrCast(*const IExtendControlbar, self), event, arg, param2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IToolbar_Value = Guid.initString("43136eb9-d36c-11cf-adbc-00aa00a80033");
pub const IID_IToolbar = &IID_IToolbar_Value;
pub const IToolbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToolbar,
                nImages: i32,
                hbmp: ?HBITMAP,
                cxSize: i32,
                cySize: i32,
                crMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToolbar,
                nImages: i32,
                hbmp: ?HBITMAP,
                cxSize: i32,
                cySize: i32,
                crMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddButtons: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToolbar,
                nButtons: i32,
                lpButtons: ?*MMCBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToolbar,
                nButtons: i32,
                lpButtons: ?*MMCBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InsertButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToolbar,
                nIndex: i32,
                lpButton: ?*MMCBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToolbar,
                nIndex: i32,
                lpButton: ?*MMCBUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToolbar,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToolbar,
                nIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetButtonState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToolbar,
                idCommand: i32,
                nState: MMC_BUTTON_STATE,
                pState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToolbar,
                idCommand: i32,
                nState: MMC_BUTTON_STATE,
                pState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetButtonState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IToolbar,
                idCommand: i32,
                nState: MMC_BUTTON_STATE,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IToolbar,
                idCommand: i32,
                nState: MMC_BUTTON_STATE,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_AddBitmap(self: *const T, nImages: i32, hbmp: ?HBITMAP, cxSize: i32, cySize: i32, crMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).AddBitmap(@ptrCast(*const IToolbar, self), nImages, hbmp, cxSize, cySize, crMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_AddButtons(self: *const T, nButtons: i32, lpButtons: ?*MMCBUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).AddButtons(@ptrCast(*const IToolbar, self), nButtons, lpButtons);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_InsertButton(self: *const T, nIndex: i32, lpButton: ?*MMCBUTTON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).InsertButton(@ptrCast(*const IToolbar, self), nIndex, lpButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_DeleteButton(self: *const T, nIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).DeleteButton(@ptrCast(*const IToolbar, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_GetButtonState(self: *const T, idCommand: i32, nState: MMC_BUTTON_STATE, pState: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).GetButtonState(@ptrCast(*const IToolbar, self), idCommand, nState, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToolbar_SetButtonState(self: *const T, idCommand: i32, nState: MMC_BUTTON_STATE, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToolbar.VTable, self.vtable).SetButtonState(@ptrCast(*const IToolbar, self), idCommand, nState, bState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsoleVerb_Value = Guid.initString("e49f7a60-74af-11d0-a286-00c04fd8fe93");
pub const IID_IConsoleVerb = &IID_IConsoleVerb_Value;
pub const IConsoleVerb = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVerbState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleVerb,
                eCmdID: MMC_CONSOLE_VERB,
                nState: MMC_BUTTON_STATE,
                pState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleVerb,
                eCmdID: MMC_CONSOLE_VERB,
                nState: MMC_BUTTON_STATE,
                pState: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVerbState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleVerb,
                eCmdID: MMC_CONSOLE_VERB,
                nState: MMC_BUTTON_STATE,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleVerb,
                eCmdID: MMC_CONSOLE_VERB,
                nState: MMC_BUTTON_STATE,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultVerb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleVerb,
                eCmdID: MMC_CONSOLE_VERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleVerb,
                eCmdID: MMC_CONSOLE_VERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultVerb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsoleVerb,
                peCmdID: ?*MMC_CONSOLE_VERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsoleVerb,
                peCmdID: ?*MMC_CONSOLE_VERB,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_GetVerbState(self: *const T, eCmdID: MMC_CONSOLE_VERB, nState: MMC_BUTTON_STATE, pState: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).GetVerbState(@ptrCast(*const IConsoleVerb, self), eCmdID, nState, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_SetVerbState(self: *const T, eCmdID: MMC_CONSOLE_VERB, nState: MMC_BUTTON_STATE, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).SetVerbState(@ptrCast(*const IConsoleVerb, self), eCmdID, nState, bState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_SetDefaultVerb(self: *const T, eCmdID: MMC_CONSOLE_VERB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).SetDefaultVerb(@ptrCast(*const IConsoleVerb, self), eCmdID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsoleVerb_GetDefaultVerb(self: *const T, peCmdID: ?*MMC_CONSOLE_VERB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsoleVerb.VTable, self.vtable).GetDefaultVerb(@ptrCast(*const IConsoleVerb, self), peCmdID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinAbout_Value = Guid.initString("1245208c-a151-11d0-a7d7-00c04fd909dd");
pub const IID_ISnapinAbout = &IID_ISnapinAbout_Value;
pub const ISnapinAbout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSnapinDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinAbout,
                lpDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinAbout,
                lpDescription: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinAbout,
                lpName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinAbout,
                lpName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSnapinVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinAbout,
                lpVersion: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinAbout,
                lpVersion: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSnapinImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinAbout,
                hAppIcon: ?*?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinAbout,
                hAppIcon: ?*?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStaticFolderImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinAbout,
                hSmallImage: ?*?HBITMAP,
                hSmallImageOpen: ?*?HBITMAP,
                hLargeImage: ?*?HBITMAP,
                cMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinAbout,
                hSmallImage: ?*?HBITMAP,
                hSmallImageOpen: ?*?HBITMAP,
                hLargeImage: ?*?HBITMAP,
                cMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetSnapinDescription(self: *const T, lpDescription: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetSnapinDescription(@ptrCast(*const ISnapinAbout, self), lpDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetProvider(self: *const T, lpName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetProvider(@ptrCast(*const ISnapinAbout, self), lpName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetSnapinVersion(self: *const T, lpVersion: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetSnapinVersion(@ptrCast(*const ISnapinAbout, self), lpVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetSnapinImage(self: *const T, hAppIcon: ?*?HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetSnapinImage(@ptrCast(*const ISnapinAbout, self), hAppIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinAbout_GetStaticFolderImage(self: *const T, hSmallImage: ?*?HBITMAP, hSmallImageOpen: ?*?HBITMAP, hLargeImage: ?*?HBITMAP, cMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinAbout.VTable, self.vtable).GetStaticFolderImage(@ptrCast(*const ISnapinAbout, self), hSmallImage, hSmallImageOpen, hLargeImage, cMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMenuButton_Value = Guid.initString("951ed750-d080-11d0-b197-000000000000");
pub const IID_IMenuButton = &IID_IMenuButton_Value;
pub const IMenuButton = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMenuButton,
                idCommand: i32,
                lpButtonText: ?PWSTR,
                lpTooltipText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMenuButton,
                idCommand: i32,
                lpButtonText: ?PWSTR,
                lpTooltipText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMenuButton,
                idCommand: i32,
                lpButtonText: ?PWSTR,
                lpTooltipText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMenuButton,
                idCommand: i32,
                lpButtonText: ?PWSTR,
                lpTooltipText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetButtonState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMenuButton,
                idCommand: i32,
                nState: MMC_BUTTON_STATE,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMenuButton,
                idCommand: i32,
                nState: MMC_BUTTON_STATE,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuButton_AddButton(self: *const T, idCommand: i32, lpButtonText: ?PWSTR, lpTooltipText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuButton.VTable, self.vtable).AddButton(@ptrCast(*const IMenuButton, self), idCommand, lpButtonText, lpTooltipText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuButton_SetButton(self: *const T, idCommand: i32, lpButtonText: ?PWSTR, lpTooltipText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuButton.VTable, self.vtable).SetButton(@ptrCast(*const IMenuButton, self), idCommand, lpButtonText, lpTooltipText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMenuButton_SetButtonState(self: *const T, idCommand: i32, nState: MMC_BUTTON_STATE, bState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMenuButton.VTable, self.vtable).SetButtonState(@ptrCast(*const IMenuButton, self), idCommand, nState, bState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinHelp_Value = Guid.initString("a6b15ace-df59-11d0-a7dd-00c04fd909dd");
pub const IID_ISnapinHelp = &IID_ISnapinHelp_Value;
pub const ISnapinHelp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHelpTopic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinHelp,
                lpCompiledHelpFile: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinHelp,
                lpCompiledHelpFile: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinHelp_GetHelpTopic(self: *const T, lpCompiledHelpFile: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinHelp.VTable, self.vtable).GetHelpTopic(@ptrCast(*const ISnapinHelp, self), lpCompiledHelpFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendPropertySheet2_Value = Guid.initString("b7a87232-4a51-11d1-a7ea-00c04fd909dd");
pub const IID_IExtendPropertySheet2 = &IID_IExtendPropertySheet2_Value;
pub const IExtendPropertySheet2 = extern struct {
    pub const VTable = extern struct {
        base: IExtendPropertySheet.VTable,
        GetWatermarks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendPropertySheet2,
                lpIDataObject: ?*IDataObject,
                lphWatermark: ?*?HBITMAP,
                lphHeader: ?*?HBITMAP,
                lphPalette: ?*?HPALETTE,
                bStretch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendPropertySheet2,
                lpIDataObject: ?*IDataObject,
                lphWatermark: ?*?HBITMAP,
                lphHeader: ?*?HBITMAP,
                lphPalette: ?*?HPALETTE,
                bStretch: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IExtendPropertySheet.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendPropertySheet2_GetWatermarks(self: *const T, lpIDataObject: ?*IDataObject, lphWatermark: ?*?HBITMAP, lphHeader: ?*?HBITMAP, lphPalette: ?*?HPALETTE, bStretch: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendPropertySheet2.VTable, self.vtable).GetWatermarks(@ptrCast(*const IExtendPropertySheet2, self), lpIDataObject, lphWatermark, lphHeader, lphPalette, bStretch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IHeaderCtrl2_Value = Guid.initString("9757abb8-1b32-11d1-a7ce-00c04fd8d565");
pub const IID_IHeaderCtrl2 = &IID_IHeaderCtrl2_Value;
pub const IHeaderCtrl2 = extern struct {
    pub const VTable = extern struct {
        base: IHeaderCtrl.VTable,
        SetChangeTimeOut: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl2,
                uTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl2,
                uTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumnFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl2,
                nColumn: u32,
                dwType: u32,
                pFilterData: ?*MMC_FILTERDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl2,
                nColumn: u32,
                dwType: u32,
                pFilterData: ?*MMC_FILTERDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHeaderCtrl2,
                nColumn: u32,
                pdwType: ?*u32,
                pFilterData: ?*MMC_FILTERDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHeaderCtrl2,
                nColumn: u32,
                pdwType: ?*u32,
                pFilterData: ?*MMC_FILTERDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHeaderCtrl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl2_SetChangeTimeOut(self: *const T, uTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl2.VTable, self.vtable).SetChangeTimeOut(@ptrCast(*const IHeaderCtrl2, self), uTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl2_SetColumnFilter(self: *const T, nColumn: u32, dwType: u32, pFilterData: ?*MMC_FILTERDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl2.VTable, self.vtable).SetColumnFilter(@ptrCast(*const IHeaderCtrl2, self), nColumn, dwType, pFilterData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderCtrl2_GetColumnFilter(self: *const T, nColumn: u32, pdwType: ?*u32, pFilterData: ?*MMC_FILTERDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHeaderCtrl2.VTable, self.vtable).GetColumnFilter(@ptrCast(*const IHeaderCtrl2, self), nColumn, pdwType, pFilterData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISnapinHelp2_Value = Guid.initString("4861a010-20f9-11d2-a510-00c04fb6dd2c");
pub const IID_ISnapinHelp2 = &IID_ISnapinHelp2_Value;
pub const ISnapinHelp2 = extern struct {
    pub const VTable = extern struct {
        base: ISnapinHelp.VTable,
        GetLinkedTopics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISnapinHelp2,
                lpCompiledHelpFiles: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISnapinHelp2,
                lpCompiledHelpFiles: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISnapinHelp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISnapinHelp2_GetLinkedTopics(self: *const T, lpCompiledHelpFiles: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISnapinHelp2.VTable, self.vtable).GetLinkedTopics(@ptrCast(*const ISnapinHelp2, self), lpCompiledHelpFiles);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MMC_TASK_DISPLAY_TYPE = enum(i32) {
    UNINITIALIZED = 0,
    TYPE_SYMBOL = 1,
    TYPE_VANILLA_GIF = 2,
    TYPE_CHOCOLATE_GIF = 3,
    TYPE_BITMAP = 4,
};
pub const MMC_TASK_DISPLAY_UNINITIALIZED = MMC_TASK_DISPLAY_TYPE.UNINITIALIZED;
pub const MMC_TASK_DISPLAY_TYPE_SYMBOL = MMC_TASK_DISPLAY_TYPE.TYPE_SYMBOL;
pub const MMC_TASK_DISPLAY_TYPE_VANILLA_GIF = MMC_TASK_DISPLAY_TYPE.TYPE_VANILLA_GIF;
pub const MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF = MMC_TASK_DISPLAY_TYPE.TYPE_CHOCOLATE_GIF;
pub const MMC_TASK_DISPLAY_TYPE_BITMAP = MMC_TASK_DISPLAY_TYPE.TYPE_BITMAP;

pub const MMC_TASK_DISPLAY_SYMBOL = extern struct {
    szFontFamilyName: ?PWSTR,
    szURLtoEOT: ?PWSTR,
    szSymbolString: ?PWSTR,
};

pub const MMC_TASK_DISPLAY_BITMAP = extern struct {
    szMouseOverBitmap: ?PWSTR,
    szMouseOffBitmap: ?PWSTR,
};

pub const MMC_TASK_DISPLAY_OBJECT = extern struct {
    eDisplayType: MMC_TASK_DISPLAY_TYPE,
    Anonymous: extern union {
        uBitmap: MMC_TASK_DISPLAY_BITMAP,
        uSymbol: MMC_TASK_DISPLAY_SYMBOL,
    },
};

pub const MMC_ACTION_TYPE = enum(i32) {
    UNINITIALIZED = -1,
    ID = 0,
    LINK = 1,
    SCRIPT = 2,
};
pub const MMC_ACTION_UNINITIALIZED = MMC_ACTION_TYPE.UNINITIALIZED;
pub const MMC_ACTION_ID = MMC_ACTION_TYPE.ID;
pub const MMC_ACTION_LINK = MMC_ACTION_TYPE.LINK;
pub const MMC_ACTION_SCRIPT = MMC_ACTION_TYPE.SCRIPT;

pub const MMC_TASK = extern struct {
    sDisplayObject: MMC_TASK_DISPLAY_OBJECT,
    szText: ?PWSTR,
    szHelpString: ?PWSTR,
    eActionType: MMC_ACTION_TYPE,
    Anonymous: extern union {
        nCommandID: isize,
        szActionURL: ?PWSTR,
        szScript: ?PWSTR,
    },
};

pub const MMC_LISTPAD_INFO = extern struct {
    szTitle: ?PWSTR,
    szButtonText: ?PWSTR,
    nCommandID: isize,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IEnumTASK_Value = Guid.initString("338698b1-5a02-11d1-9fec-00600832db4a");
pub const IID_IEnumTASK = &IID_IEnumTASK_Value;
pub const IEnumTASK = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTASK,
                celt: u32,
                rgelt: [*]MMC_TASK,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTASK,
                celt: u32,
                rgelt: [*]MMC_TASK,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTASK,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTASK,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTASK,
                ppenum: ?*?*IEnumTASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTASK,
                ppenum: ?*?*IEnumTASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Next(self: *const T, celt: u32, rgelt: [*]MMC_TASK, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Next(@ptrCast(*const IEnumTASK, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Skip(@ptrCast(*const IEnumTASK, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Reset(@ptrCast(*const IEnumTASK, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTASK_Clone(self: *const T, ppenum: ?*?*IEnumTASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumTASK.VTable, self.vtable).Clone(@ptrCast(*const IEnumTASK, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendTaskPad_Value = Guid.initString("8dee6511-554d-11d1-9fea-00600832db4a");
pub const IID_IExtendTaskPad = &IID_IExtendTaskPad_Value;
pub const IExtendTaskPad = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TaskNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendTaskPad,
                pdo: ?*IDataObject,
                arg: ?*VARIANT,
                param2: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendTaskPad,
                pdo: ?*IDataObject,
                arg: ?*VARIANT,
                param2: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendTaskPad,
                pdo: ?*IDataObject,
                szTaskGroup: ?PWSTR,
                ppEnumTASK: ?*?*IEnumTASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendTaskPad,
                pdo: ?*IDataObject,
                szTaskGroup: ?PWSTR,
                ppEnumTASK: ?*?*IEnumTASK,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                pszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                pszTitle: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptiveText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                pszDescriptiveText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                pszDescriptiveText: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackground: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                pTDO: ?*MMC_TASK_DISPLAY_OBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                pTDO: ?*MMC_TASK_DISPLAY_OBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListPadInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                lpListPadInfo: ?*MMC_LISTPAD_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendTaskPad,
                pszGroup: ?PWSTR,
                lpListPadInfo: ?*MMC_LISTPAD_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_TaskNotify(self: *const T, pdo: ?*IDataObject, arg: ?*VARIANT, param2: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).TaskNotify(@ptrCast(*const IExtendTaskPad, self), pdo, arg, param2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_EnumTasks(self: *const T, pdo: ?*IDataObject, szTaskGroup: ?PWSTR, ppEnumTASK: ?*?*IEnumTASK) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).EnumTasks(@ptrCast(*const IExtendTaskPad, self), pdo, szTaskGroup, ppEnumTASK);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetTitle(self: *const T, pszGroup: ?PWSTR, pszTitle: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetTitle(@ptrCast(*const IExtendTaskPad, self), pszGroup, pszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetDescriptiveText(self: *const T, pszGroup: ?PWSTR, pszDescriptiveText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetDescriptiveText(@ptrCast(*const IExtendTaskPad, self), pszGroup, pszDescriptiveText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetBackground(self: *const T, pszGroup: ?PWSTR, pTDO: ?*MMC_TASK_DISPLAY_OBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetBackground(@ptrCast(*const IExtendTaskPad, self), pszGroup, pTDO);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendTaskPad_GetListPadInfo(self: *const T, pszGroup: ?PWSTR, lpListPadInfo: ?*MMC_LISTPAD_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendTaskPad.VTable, self.vtable).GetListPadInfo(@ptrCast(*const IExtendTaskPad, self), pszGroup, lpListPadInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsole2_Value = Guid.initString("103d842a-aa63-11d1-a7e1-00c04fd8d565");
pub const IID_IConsole2 = &IID_IConsole2_Value;
pub const IConsole2 = extern struct {
    pub const VTable = extern struct {
        base: IConsole.VTable,
        Expand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole2,
                hItem: isize,
                bExpand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole2,
                hItem: isize,
                bExpand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTaskpadViewPreferred: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStatusText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole2,
                pszStatusText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole2,
                pszStatusText: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConsole.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole2_Expand(self: *const T, hItem: isize, bExpand: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole2.VTable, self.vtable).Expand(@ptrCast(*const IConsole2, self), hItem, bExpand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole2_IsTaskpadViewPreferred(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole2.VTable, self.vtable).IsTaskpadViewPreferred(@ptrCast(*const IConsole2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole2_SetStatusText(self: *const T, pszStatusText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole2.VTable, self.vtable).SetStatusText(@ptrCast(*const IConsole2, self), pszStatusText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDisplayHelp_Value = Guid.initString("cc593830-b926-11d1-8063-0000f875a9ce");
pub const IID_IDisplayHelp = &IID_IDisplayHelp_Value;
pub const IDisplayHelp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowTopic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDisplayHelp,
                pszHelpTopic: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDisplayHelp,
                pszHelpTopic: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayHelp_ShowTopic(self: *const T, pszHelpTopic: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayHelp.VTable, self.vtable).ShowTopic(@ptrCast(*const IDisplayHelp, self), pszHelpTopic);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IRequiredExtensions_Value = Guid.initString("72782d7a-a4a0-11d1-af0f-00c04fb6dd2c");
pub const IID_IRequiredExtensions = &IID_IRequiredExtensions_Value;
pub const IRequiredExtensions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableAllExtensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRequiredExtensions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRequiredExtensions,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRequiredExtensions,
                pExtCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRequiredExtensions,
                pExtCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRequiredExtensions,
                pExtCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRequiredExtensions,
                pExtCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequiredExtensions_EnableAllExtensions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequiredExtensions.VTable, self.vtable).EnableAllExtensions(@ptrCast(*const IRequiredExtensions, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequiredExtensions_GetFirstExtension(self: *const T, pExtCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequiredExtensions.VTable, self.vtable).GetFirstExtension(@ptrCast(*const IRequiredExtensions, self), pExtCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRequiredExtensions_GetNextExtension(self: *const T, pExtCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRequiredExtensions.VTable, self.vtable).GetNextExtension(@ptrCast(*const IRequiredExtensions, self), pExtCLSID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStringTable_Value = Guid.initString("de40b7a4-0f65-11d2-8e25-00c04f8ecd78");
pub const IID_IStringTable = &IID_IStringTable_Value;
pub const IStringTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
                pszAdd: ?[*:0]const u16,
                pStringID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
                pszAdd: ?[*:0]const u16,
                pStringID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
                StringID: u32,
                cchBuffer: u32,
                lpBuffer: [*:0]u16,
                pcchOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
                StringID: u32,
                cchBuffer: u32,
                lpBuffer: [*:0]u16,
                pcchOut: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
                StringID: u32,
                pcchString: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
                StringID: u32,
                pcchString: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
                StringID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
                StringID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteAllStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
                pszFind: ?[*:0]const u16,
                pStringID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
                pszFind: ?[*:0]const u16,
                pStringID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enumerate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringTable,
                ppEnum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringTable,
                ppEnum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_AddString(self: *const T, pszAdd: ?[*:0]const u16, pStringID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).AddString(@ptrCast(*const IStringTable, self), pszAdd, pStringID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_GetString(self: *const T, StringID: u32, cchBuffer: u32, lpBuffer: [*:0]u16, pcchOut: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).GetString(@ptrCast(*const IStringTable, self), StringID, cchBuffer, lpBuffer, pcchOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_GetStringLength(self: *const T, StringID: u32, pcchString: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).GetStringLength(@ptrCast(*const IStringTable, self), StringID, pcchString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_DeleteString(self: *const T, StringID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).DeleteString(@ptrCast(*const IStringTable, self), StringID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_DeleteAllStrings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).DeleteAllStrings(@ptrCast(*const IStringTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_FindString(self: *const T, pszFind: ?[*:0]const u16, pStringID: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).FindString(@ptrCast(*const IStringTable, self), pszFind, pStringID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringTable_Enumerate(self: *const T, ppEnum: ?*?*IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringTable.VTable, self.vtable).Enumerate(@ptrCast(*const IStringTable, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MMC_COLUMN_DATA = extern struct {
    nColIndex: i32,
    dwFlags: u32,
    nWidth: i32,
    ulReserved: usize,
};

pub const MMC_COLUMN_SET_DATA = extern struct {
    cbSize: i32,
    nNumCols: i32,
    pColData: ?*MMC_COLUMN_DATA,
};

pub const MMC_SORT_DATA = extern struct {
    nColIndex: i32,
    dwSortOptions: u32,
    ulReserved: usize,
};

pub const MMC_SORT_SET_DATA = extern struct {
    cbSize: i32,
    nNumItems: i32,
    pSortData: ?*MMC_SORT_DATA,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IColumnData_Value = Guid.initString("547c1354-024d-11d3-a707-00c04f8ef4cb");
pub const IID_IColumnData = &IID_IColumnData_Value;
pub const IColumnData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnConfigData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                pColSetData: ?*MMC_COLUMN_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                pColSetData: ?*MMC_COLUMN_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnConfigData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                ppColSetData: ?*?*MMC_COLUMN_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                ppColSetData: ?*?*MMC_COLUMN_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumnSortData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                pColSortData: ?*MMC_SORT_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                pColSortData: ?*MMC_SORT_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnSortData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                ppColSortData: ?*?*MMC_SORT_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IColumnData,
                pColID: ?*SColumnSetID,
                ppColSortData: ?*?*MMC_SORT_SET_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_SetColumnConfigData(self: *const T, pColID: ?*SColumnSetID, pColSetData: ?*MMC_COLUMN_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).SetColumnConfigData(@ptrCast(*const IColumnData, self), pColID, pColSetData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_GetColumnConfigData(self: *const T, pColID: ?*SColumnSetID, ppColSetData: ?*?*MMC_COLUMN_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).GetColumnConfigData(@ptrCast(*const IColumnData, self), pColID, ppColSetData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_SetColumnSortData(self: *const T, pColID: ?*SColumnSetID, pColSortData: ?*MMC_SORT_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).SetColumnSortData(@ptrCast(*const IColumnData, self), pColID, pColSortData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnData_GetColumnSortData(self: *const T, pColID: ?*SColumnSetID, ppColSortData: ?*?*MMC_SORT_SET_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnData.VTable, self.vtable).GetColumnSortData(@ptrCast(*const IColumnData, self), pColID, ppColSortData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IconIdentifier = enum(i32) {
    None = 0,
    Error = 32513,
    Question = 32514,
    Warning = 32515,
    Information = 32516,
    // First = 32513, this enum value conflicts with Error
    // Last = 32516, this enum value conflicts with Information
};
pub const Icon_None = IconIdentifier.None;
pub const Icon_Error = IconIdentifier.Error;
pub const Icon_Question = IconIdentifier.Question;
pub const Icon_Warning = IconIdentifier.Warning;
pub const Icon_Information = IconIdentifier.Information;
pub const Icon_First = IconIdentifier.Error;
pub const Icon_Last = IconIdentifier.Information;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMessageView_Value = Guid.initString("80f94174-fccc-11d2-b991-00c04f8ecd78");
pub const IID_IMessageView = &IID_IMessageView_Value;
pub const IMessageView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTitleText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMessageView,
                pszTitleText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMessageView,
                pszTitleText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBodyText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMessageView,
                pszBodyText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMessageView,
                pszBodyText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMessageView,
                id: IconIdentifier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMessageView,
                id: IconIdentifier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMessageView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMessageView,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_SetTitleText(self: *const T, pszTitleText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).SetTitleText(@ptrCast(*const IMessageView, self), pszTitleText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_SetBodyText(self: *const T, pszBodyText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).SetBodyText(@ptrCast(*const IMessageView, self), pszBodyText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_SetIcon(self: *const T, id: IconIdentifier) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).SetIcon(@ptrCast(*const IMessageView, self), id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMessageView_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMessageView.VTable, self.vtable).Clear(@ptrCast(*const IMessageView, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RDITEMHDR = extern struct {
    dwFlags: u32,
    cookie: isize,
    lpReserved: LPARAM,
};

pub const RDCOMPARE = extern struct {
    cbSize: u32,
    dwFlags: u32,
    nColumn: i32,
    lUserParam: LPARAM,
    prdch1: ?*RDITEMHDR,
    prdch2: ?*RDITEMHDR,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultDataCompareEx_Value = Guid.initString("96933476-0251-11d3-aeb0-00c04f8ecd78");
pub const IID_IResultDataCompareEx = &IID_IResultDataCompareEx_Value;
pub const IResultDataCompareEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultDataCompareEx,
                prdc: ?*RDCOMPARE,
                pnResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultDataCompareEx,
                prdc: ?*RDCOMPARE,
                pnResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultDataCompareEx_Compare(self: *const T, prdc: ?*RDCOMPARE, pnResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultDataCompareEx.VTable, self.vtable).Compare(@ptrCast(*const IResultDataCompareEx, self), prdc, pnResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MMC_VIEW_TYPE = enum(i32) {
    LIST = 0,
    HTML = 1,
    OCX = 2,
};
pub const MMC_VIEW_TYPE_LIST = MMC_VIEW_TYPE.LIST;
pub const MMC_VIEW_TYPE_HTML = MMC_VIEW_TYPE.HTML;
pub const MMC_VIEW_TYPE_OCX = MMC_VIEW_TYPE.OCX;

pub const RESULT_VIEW_TYPE_INFO = extern struct {
    pstrPersistableViewDescription: ?PWSTR,
    eViewType: MMC_VIEW_TYPE,
    dwMiscOptions: u32,
    Anonymous: extern union {
        dwListOptions: u32,
        Anonymous1: extern struct {
            dwHTMLOptions: u32,
            pstrURL: ?PWSTR,
        },
        Anonymous2: extern struct {
            dwOCXOptions: u32,
            pUnkControl: ?*IUnknown,
        },
    },
};

pub const CONTEXTMENUITEM2 = extern struct {
    strName: ?PWSTR,
    strStatusBarText: ?PWSTR,
    lCommandID: i32,
    lInsertionPointID: i32,
    fFlags: i32,
    fSpecialFlags: i32,
    strLanguageIndependentName: ?PWSTR,
};

pub const MMC_EXT_VIEW_DATA = extern struct {
    viewID: Guid,
    pszURL: ?[*:0]const u16,
    pszViewTitle: ?[*:0]const u16,
    pszTooltipText: ?[*:0]const u16,
    bReplacesDefaultView: BOOL,
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponentData2_Value = Guid.initString("cca0f2d2-82de-41b5-bf47-3b2076273d5c");
pub const IID_IComponentData2 = &IID_IComponentData2_Value;
pub const IComponentData2 = extern struct {
    pub const VTable = extern struct {
        base: IComponentData.VTable,
        QueryDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentData2,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDispatch: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentData2,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDispatch: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponentData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentData2_QueryDispatch(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDispatch: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponentData2.VTable, self.vtable).QueryDispatch(@ptrCast(*const IComponentData2, self), cookie, type_, ppDispatch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent2_Value = Guid.initString("79a2d615-4a10-4ed4-8c65-8633f9335095");
pub const IID_IComponent2 = &IID_IComponent2_Value;
pub const IComponent2 = extern struct {
    pub const VTable = extern struct {
        base: IComponent.VTable,
        QueryDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent2,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDispatch: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent2,
                cookie: isize,
                type: DATA_OBJECT_TYPES,
                ppDispatch: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResultViewType2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent2,
                cookie: isize,
                pResultViewType: ?*RESULT_VIEW_TYPE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent2,
                cookie: isize,
                pResultViewType: ?*RESULT_VIEW_TYPE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreResultView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent2,
                cookie: isize,
                pResultViewType: ?*RESULT_VIEW_TYPE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent2,
                cookie: isize,
                pResultViewType: ?*RESULT_VIEW_TYPE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent2_QueryDispatch(self: *const T, cookie: isize, type_: DATA_OBJECT_TYPES, ppDispatch: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent2.VTable, self.vtable).QueryDispatch(@ptrCast(*const IComponent2, self), cookie, type_, ppDispatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent2_GetResultViewType2(self: *const T, cookie: isize, pResultViewType: ?*RESULT_VIEW_TYPE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent2.VTable, self.vtable).GetResultViewType2(@ptrCast(*const IComponent2, self), cookie, pResultViewType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent2_RestoreResultView(self: *const T, cookie: isize, pResultViewType: ?*RESULT_VIEW_TYPE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComponent2.VTable, self.vtable).RestoreResultView(@ptrCast(*const IComponent2, self), cookie, pResultViewType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IContextMenuCallback2_Value = Guid.initString("e178bc0e-2ed0-4b5e-8097-42c9087e8b33");
pub const IID_IContextMenuCallback2 = &IID_IContextMenuCallback2_Value;
pub const IContextMenuCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContextMenuCallback2,
                pItem: ?*CONTEXTMENUITEM2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContextMenuCallback2,
                pItem: ?*CONTEXTMENUITEM2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContextMenuCallback2_AddItem(self: *const T, pItem: ?*CONTEXTMENUITEM2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContextMenuCallback2.VTable, self.vtable).AddItem(@ptrCast(*const IContextMenuCallback2, self), pItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMMCVersionInfo_Value = Guid.initString("a8d2c5fe-cdcb-4b9d-bde5-a27343ff54bc");
pub const IID_IMMCVersionInfo = &IID_IMMCVersionInfo_Value;
pub const IMMCVersionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMMCVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMMCVersionInfo,
                pVersionMajor: ?*i32,
                pVersionMinor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMMCVersionInfo,
                pVersionMajor: ?*i32,
                pVersionMinor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMMCVersionInfo_GetMMCVersion(self: *const T, pVersionMajor: ?*i32, pVersionMinor: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMMCVersionInfo.VTable, self.vtable).GetMMCVersion(@ptrCast(*const IMMCVersionInfo, self), pVersionMajor, pVersionMinor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IExtendView_Value = Guid.initString("89995cee-d2ed-4c0e-ae5e-df7e76f3fa53");
pub const IID_IExtendView = &IID_IExtendView_Value;
pub const IExtendView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetViews: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtendView,
                pDataObject: ?*IDataObject,
                pViewExtensionCallback: ?*IViewExtensionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtendView,
                pDataObject: ?*IDataObject,
                pViewExtensionCallback: ?*IViewExtensionCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtendView_GetViews(self: *const T, pDataObject: ?*IDataObject, pViewExtensionCallback: ?*IViewExtensionCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExtendView.VTable, self.vtable).GetViews(@ptrCast(*const IExtendView, self), pDataObject, pViewExtensionCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IViewExtensionCallback_Value = Guid.initString("34dd928a-7599-41e5-9f5e-d6bc3062c2da");
pub const IID_IViewExtensionCallback = &IID_IViewExtensionCallback_Value;
pub const IViewExtensionCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewExtensionCallback,
                pExtViewData: ?*MMC_EXT_VIEW_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewExtensionCallback,
                pExtViewData: ?*MMC_EXT_VIEW_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewExtensionCallback_AddView(self: *const T, pExtViewData: ?*MMC_EXT_VIEW_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewExtensionCallback.VTable, self.vtable).AddView(@ptrCast(*const IViewExtensionCallback, self), pExtViewData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsolePower_Value = Guid.initString("1cfbdd0e-62ca-49ce-a3af-dbb2de61b068");
pub const IID_IConsolePower = &IID_IConsolePower_Value;
pub const IConsolePower = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetExecutionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsolePower,
                dwAdd: u32,
                dwRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsolePower,
                dwAdd: u32,
                dwRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetIdleTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsolePower,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsolePower,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsolePower_SetExecutionState(self: *const T, dwAdd: u32, dwRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsolePower.VTable, self.vtable).SetExecutionState(@ptrCast(*const IConsolePower, self), dwAdd, dwRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsolePower_ResetIdleTimer(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsolePower.VTable, self.vtable).ResetIdleTimer(@ptrCast(*const IConsolePower, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsolePowerSink_Value = Guid.initString("3333759f-fe4f-4975-b143-fec0a5dd6d65");
pub const IID_IConsolePowerSink = &IID_IConsolePowerSink_Value;
pub const IConsolePowerSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPowerBroadcast: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsolePowerSink,
                nEvent: u32,
                lParam: LPARAM,
                plReturn: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsolePowerSink,
                nEvent: u32,
                lParam: LPARAM,
                plReturn: ?*LRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsolePowerSink_OnPowerBroadcast(self: *const T, nEvent: u32, lParam: LPARAM, plReturn: ?*LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsolePowerSink.VTable, self.vtable).OnPowerBroadcast(@ptrCast(*const IConsolePowerSink, self), nEvent, lParam, plReturn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_INodeProperties_Value = Guid.initString("15bc4d24-a522-4406-aa55-0749537a6865");
pub const IID_INodeProperties = &IID_INodeProperties_Value;
pub const INodeProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const INodeProperties,
                pDataObject: ?*IDataObject,
                szPropertyName: ?BSTR,
                pbstrProperty: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const INodeProperties,
                pDataObject: ?*IDataObject,
                szPropertyName: ?BSTR,
                pbstrProperty: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INodeProperties_GetProperty(self: *const T, pDataObject: ?*IDataObject, szPropertyName: ?BSTR, pbstrProperty: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const INodeProperties.VTable, self.vtable).GetProperty(@ptrCast(*const INodeProperties, self), pDataObject, szPropertyName, pbstrProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IConsole3_Value = Guid.initString("4f85efdb-d0e1-498c-8d4a-d010dfdd404f");
pub const IID_IConsole3 = &IID_IConsole3_Value;
pub const IConsole3 = extern struct {
    pub const VTable = extern struct {
        base: IConsole2.VTable,
        RenameScopeItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConsole3,
                hScopeItem: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConsole3,
                hScopeItem: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConsole2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConsole3_RenameScopeItem(self: *const T, hScopeItem: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConsole3.VTable, self.vtable).RenameScopeItem(@ptrCast(*const IConsole3, self), hScopeItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IResultData2_Value = Guid.initString("0f36e0eb-a7f1-4a81-be5a-9247f7de4b1b");
pub const IID_IResultData2 = &IID_IResultData2_Value;
pub const IResultData2 = extern struct {
    pub const VTable = extern struct {
        base: IResultData.VTable,
        RenameResultItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResultData2,
                itemID: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResultData2,
                itemID: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IResultData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResultData2_RenameResultItem(self: *const T, itemID: isize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IResultData2.VTable, self.vtable).RenameResultItem(@ptrCast(*const IResultData2, self), itemID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (17)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HICON = @import("../ui/windows_and_messaging.zig").HICON;
const HPALETTE = @import("../graphics/gdi.zig").HPALETTE;
const HPROPSHEETPAGE = @import("../ui/controls.zig").HPROPSHEETPAGE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDataObject = @import("../system/com.zig").IDataObject;
const IDispatch = @import("../system/com.zig").IDispatch;
const IEnumString = @import("../system/com.zig").IEnumString;
const IUnknown = @import("../system/com.zig").IUnknown;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
