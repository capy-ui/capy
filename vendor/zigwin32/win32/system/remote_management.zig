//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (546)
//--------------------------------------------------------------------------------
pub const WSMAN_FLAG_REQUESTED_API_VERSION_1_0 = @as(u32, 0);
pub const WSMAN_FLAG_REQUESTED_API_VERSION_1_1 = @as(u32, 1);
pub const WSMAN_OPERATION_INFOV1 = @as(u32, 0);
pub const WSMAN_OPERATION_INFOV2 = @as(u32, 2864434397);
pub const WSMAN_DEFAULT_TIMEOUT_MS = @as(u32, 60000);
pub const WSMAN_STREAM_ID_STDIN = "stdin";
pub const WSMAN_STREAM_ID_STDOUT = "stdout";
pub const WSMAN_STREAM_ID_STDERR = "stderr";
pub const WSMAN_SHELL_NS = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell";
pub const WSMAN_CMDSHELL_OPTION_CODEPAGE = "WINRS_CODEPAGE";
pub const WSMAN_SHELL_OPTION_NOPROFILE = "WINRS_NOPROFILE";
pub const WSMAN_CMDSHELL_OPTION_CONSOLEMODE_STDIN = "WINRS_CONSOLEMODE_STDIN";
pub const WSMAN_CMDSHELL_OPTION_SKIP_CMD_SHELL = "WINRS_SKIP_CMD_SHELL";
pub const WSMAN_FLAG_RECEIVE_RESULT_NO_MORE_DATA = @as(u32, 1);
pub const WSMAN_FLAG_RECEIVE_FLUSH = @as(u32, 2);
pub const WSMAN_FLAG_RECEIVE_RESULT_DATA_BOUNDARY = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_MAX_ENVELOPE_SIZE = @as(u32, 1);
pub const WSMAN_PLUGIN_PARAMS_TIMEOUT = @as(u32, 2);
pub const WSMAN_PLUGIN_PARAMS_REMAINING_RESULT_SIZE = @as(u32, 3);
pub const WSMAN_PLUGIN_PARAMS_LARGEST_RESULT_SIZE = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_GET_REQUESTED_LOCALE = @as(u32, 5);
pub const WSMAN_PLUGIN_PARAMS_GET_REQUESTED_DATA_LOCALE = @as(u32, 6);
pub const WSMAN_PLUGIN_PARAMS_SHAREDHOST = @as(u32, 1);
pub const WSMAN_PLUGIN_PARAMS_RUNAS_USER = @as(u32, 2);
pub const WSMAN_PLUGIN_PARAMS_AUTORESTART = @as(u32, 3);
pub const WSMAN_PLUGIN_PARAMS_HOSTIDLETIMEOUTSECONDS = @as(u32, 4);
pub const WSMAN_PLUGIN_PARAMS_NAME = @as(u32, 5);
pub const WSMAN_PLUGIN_STARTUP_REQUEST_RECEIVED = @as(u32, 0);
pub const WSMAN_PLUGIN_STARTUP_AUTORESTARTED_REBOOT = @as(u32, 1);
pub const WSMAN_PLUGIN_STARTUP_AUTORESTARTED_CRASH = @as(u32, 2);
pub const WSMAN_PLUGIN_SHUTDOWN_SYSTEM = @as(u32, 1);
pub const WSMAN_PLUGIN_SHUTDOWN_SERVICE = @as(u32, 2);
pub const WSMAN_PLUGIN_SHUTDOWN_IISHOST = @as(u32, 3);
pub const WSMAN_PLUGIN_SHUTDOWN_IDLETIMEOUT_ELAPSED = @as(u32, 4);
pub const WSMAN_FLAG_SEND_NO_MORE_DATA = @as(u32, 1);
pub const ERROR_WSMAN_RESOURCE_NOT_FOUND = @as(u32, 2150858752);
pub const ERROR_WSMAN_INVALID_ACTIONURI = @as(u32, 2150858753);
pub const ERROR_WSMAN_INVALID_URI = @as(u32, 2150858754);
pub const ERROR_WSMAN_PROVIDER_FAILURE = @as(u32, 2150858755);
pub const ERROR_WSMAN_BATCH_COMPLETE = @as(u32, 2150858756);
pub const ERROR_WSMAN_CONFIG_CORRUPTED = @as(u32, 2150858757);
pub const ERROR_WSMAN_PULL_IN_PROGRESS = @as(u32, 2150858758);
pub const ERROR_WSMAN_ENUMERATION_CLOSED = @as(u32, 2150858759);
pub const ERROR_WSMAN_SUBSCRIPTION_CLOSED = @as(u32, 2150858760);
pub const ERROR_WSMAN_SUBSCRIPTION_CLOSE_IN_PROGRESS = @as(u32, 2150858761);
pub const ERROR_WSMAN_SUBSCRIPTION_CLIENT_DID_NOT_CALL_WITHIN_HEARTBEAT = @as(u32, 2150858762);
pub const ERROR_WSMAN_SUBSCRIPTION_NO_HEARTBEAT = @as(u32, 2150858763);
pub const ERROR_WSMAN_UNSUPPORTED_TIMEOUT = @as(u32, 2150858764);
pub const ERROR_WSMAN_SOAP_VERSION_MISMATCH = @as(u32, 2150858765);
pub const ERROR_WSMAN_SOAP_DATA_ENCODING_UNKNOWN = @as(u32, 2150858766);
pub const ERROR_WSMAN_INVALID_MESSAGE_INFORMATION_HEADER = @as(u32, 2150858767);
pub const ERROR_WSMAN_SOAP_FAULT_MUST_UNDERSTAND = @as(u32, 2150858768);
pub const ERROR_WSMAN_MESSAGE_INFORMATION_HEADER_REQUIRED = @as(u32, 2150858769);
pub const ERROR_WSMAN_DESTINATION_UNREACHABLE = @as(u32, 2150858770);
pub const ERROR_WSMAN_ACTION_NOT_SUPPORTED = @as(u32, 2150858771);
pub const ERROR_WSMAN_ENDPOINT_UNAVAILABLE = @as(u32, 2150858772);
pub const ERROR_WSMAN_INVALID_REPRESENTATION = @as(u32, 2150858773);
pub const ERROR_WSMAN_ENUMERATE_INVALID_EXPIRATION_TIME = @as(u32, 2150858774);
pub const ERROR_WSMAN_ENUMERATE_UNSUPPORTED_EXPIRATION_TIME = @as(u32, 2150858775);
pub const ERROR_WSMAN_ENUMERATE_FILTERING_NOT_SUPPORTED = @as(u32, 2150858776);
pub const ERROR_WSMAN_ENUMERATE_FILTER_DIALECT_REQUESTED_UNAVAILABLE = @as(u32, 2150858777);
pub const ERROR_WSMAN_ENUMERATE_CANNOT_PROCESS_FILTER = @as(u32, 2150858778);
pub const ERROR_WSMAN_ENUMERATE_INVALID_ENUMERATION_CONTEXT = @as(u32, 2150858779);
pub const ERROR_WSMAN_ENUMERATE_TIMED_OUT = @as(u32, 2150858780);
pub const ERROR_WSMAN_ENUMERATE_UNABLE_TO_RENEW = @as(u32, 2150858781);
pub const ERROR_WSMAN_EVENTING_DELIVERY_MODE_REQUESTED_UNAVAILABLE = @as(u32, 2150858782);
pub const ERROR_WSMAN_EVENTING_INVALID_EXPIRATION_TIME = @as(u32, 2150858783);
pub const ERROR_WSMAN_EVENTING_UNSUPPORTED_EXPIRATION_TYPE = @as(u32, 2150858784);
pub const ERROR_WSMAN_EVENTING_FILTERING_NOT_SUPPORTED = @as(u32, 2150858785);
pub const ERROR_WSMAN_EVENTING_FILTERING_REQUESTED_UNAVAILABLE = @as(u32, 2150858786);
pub const ERROR_WSMAN_EVENTING_SOURCE_UNABLE_TO_PROCESS = @as(u32, 2150858787);
pub const ERROR_WSMAN_EVENTING_UNABLE_TO_RENEW = @as(u32, 2150858788);
pub const ERROR_WSMAN_EVENTING_INVALID_MESSAGE = @as(u32, 2150858789);
pub const ERROR_WSMAN_ENVELOPE_TOO_LARGE = @as(u32, 2150858790);
pub const ERROR_WSMAN_INVALID_SOAP_BODY = @as(u32, 2150858791);
pub const ERROR_WSMAN_INVALID_RESUMPTION_CONTEXT = @as(u32, 2150858792);
pub const ERROR_WSMAN_OPERATION_TIMEDOUT = @as(u32, 2150858793);
pub const ERROR_WSMAN_RESUMPTION_NOT_SUPPORTED = @as(u32, 2150858794);
pub const ERROR_WSMAN_RESUMPTION_TYPE_NOT_SUPPORTED = @as(u32, 2150858795);
pub const ERROR_WSMAN_UNSUPPORTED_ENCODING = @as(u32, 2150858796);
pub const ERROR_WSMAN_URI_LIMIT = @as(u32, 2150858797);
pub const ERROR_WSMAN_INVALID_PROPOSED_ID = @as(u32, 2150858798);
pub const ERROR_WSMAN_INVALID_BATCH_PARAMETER = @as(u32, 2150858799);
pub const ERROR_WSMAN_NO_ACK = @as(u32, 2150858800);
pub const ERROR_WSMAN_ACTION_MISMATCH = @as(u32, 2150858801);
pub const ERROR_WSMAN_CONCURRENCY = @as(u32, 2150858802);
pub const ERROR_WSMAN_ALREADY_EXISTS = @as(u32, 2150858803);
pub const ERROR_WSMAN_DELIVERY_REFUSED = @as(u32, 2150858804);
pub const ERROR_WSMAN_ENCODING_LIMIT = @as(u32, 2150858805);
pub const ERROR_WSMAN_FAILED_AUTHENTICATION = @as(u32, 2150858806);
pub const ERROR_WSMAN_INCOMPATIBLE_EPR = @as(u32, 2150858807);
pub const ERROR_WSMAN_INVALID_BOOKMARK = @as(u32, 2150858808);
pub const ERROR_WSMAN_INVALID_OPTIONS = @as(u32, 2150858809);
pub const ERROR_WSMAN_INVALID_PARAMETER = @as(u32, 2150858810);
pub const ERROR_WSMAN_INVALID_RESOURCE_URI = @as(u32, 2150858811);
pub const ERROR_WSMAN_INVALID_SYSTEM = @as(u32, 2150858812);
pub const ERROR_WSMAN_INVALID_SELECTORS = @as(u32, 2150858813);
pub const ERROR_WSMAN_METADATA_REDIRECT = @as(u32, 2150858814);
pub const ERROR_WSMAN_QUOTA_LIMIT = @as(u32, 2150858815);
pub const ERROR_WSMAN_RENAME_FAILURE = @as(u32, 2150858816);
pub const ERROR_WSMAN_SCHEMA_VALIDATION_ERROR = @as(u32, 2150858817);
pub const ERROR_WSMAN_UNSUPPORTED_FEATURE = @as(u32, 2150858818);
pub const ERROR_WSMAN_INVALID_XML = @as(u32, 2150858819);
pub const ERROR_WSMAN_INVALID_KEY = @as(u32, 2150858820);
pub const ERROR_WSMAN_DELIVER_IN_PROGRESS = @as(u32, 2150858821);
pub const ERROR_WSMAN_SYSTEM_NOT_FOUND = @as(u32, 2150858822);
pub const ERROR_WSMAN_MAX_ENVELOPE_SIZE = @as(u32, 2150858823);
pub const ERROR_WSMAN_MAX_ENVELOPE_SIZE_EXCEEDED = @as(u32, 2150858824);
pub const ERROR_WSMAN_SERVER_ENVELOPE_LIMIT = @as(u32, 2150858825);
pub const ERROR_WSMAN_SELECTOR_LIMIT = @as(u32, 2150858826);
pub const ERROR_WSMAN_OPTION_LIMIT = @as(u32, 2150858827);
pub const ERROR_WSMAN_CHARACTER_SET = @as(u32, 2150858828);
pub const ERROR_WSMAN_UNREPORTABLE_SUCCESS = @as(u32, 2150858829);
pub const ERROR_WSMAN_WHITESPACE = @as(u32, 2150858830);
pub const ERROR_WSMAN_FILTERING_REQUIRED = @as(u32, 2150858831);
pub const ERROR_WSMAN_BOOKMARK_EXPIRED = @as(u32, 2150858832);
pub const ERROR_WSMAN_OPTIONS_NOT_SUPPORTED = @as(u32, 2150858833);
pub const ERROR_WSMAN_OPTIONS_INVALID_NAME = @as(u32, 2150858834);
pub const ERROR_WSMAN_OPTIONS_INVALID_VALUE = @as(u32, 2150858835);
pub const ERROR_WSMAN_PARAMETER_TYPE_MISMATCH = @as(u32, 2150858836);
pub const ERROR_WSMAN_INVALID_PARAMETER_NAME = @as(u32, 2150858837);
pub const ERROR_WSMAN_INVALID_XML_VALUES = @as(u32, 2150858838);
pub const ERROR_WSMAN_INVALID_XML_MISSING_VALUES = @as(u32, 2150858839);
pub const ERROR_WSMAN_INVALID_XML_NAMESPACE = @as(u32, 2150858840);
pub const ERROR_WSMAN_INVALID_XML_FRAGMENT = @as(u32, 2150858841);
pub const ERROR_WSMAN_INSUFFCIENT_SELECTORS = @as(u32, 2150858842);
pub const ERROR_WSMAN_UNEXPECTED_SELECTORS = @as(u32, 2150858843);
pub const ERROR_WSMAN_SELECTOR_TYPEMISMATCH = @as(u32, 2150858844);
pub const ERROR_WSMAN_INVALID_SELECTOR_VALUE = @as(u32, 2150858845);
pub const ERROR_WSMAN_AMBIGUOUS_SELECTORS = @as(u32, 2150858846);
pub const ERROR_WSMAN_DUPLICATE_SELECTORS = @as(u32, 2150858847);
pub const ERROR_WSMAN_INVALID_TARGET_SELECTORS = @as(u32, 2150858848);
pub const ERROR_WSMAN_INVALID_TARGET_RESOURCEURI = @as(u32, 2150858849);
pub const ERROR_WSMAN_INVALID_TARGET_SYSTEM = @as(u32, 2150858850);
pub const ERROR_WSMAN_TARGET_ALREADY_EXISTS = @as(u32, 2150858851);
pub const ERROR_WSMAN_AUTHORIZATION_MODE_NOT_SUPPORTED = @as(u32, 2150858852);
pub const ERROR_WSMAN_ACK_NOT_SUPPORTED = @as(u32, 2150858853);
pub const ERROR_WSMAN_OPERATION_TIMEOUT_NOT_SUPPORTED = @as(u32, 2150858854);
pub const ERROR_WSMAN_LOCALE_NOT_SUPPORTED = @as(u32, 2150858855);
pub const ERROR_WSMAN_EXPIRATION_TIME_NOT_SUPPORTED = @as(u32, 2150858856);
pub const ERROR_WSMAN_DELIVERY_RETRIES_NOT_SUPPORTED = @as(u32, 2150858857);
pub const ERROR_WSMAN_HEARTBEATS_NOT_SUPPORTED = @as(u32, 2150858858);
pub const ERROR_WSMAN_BOOKMARKS_NOT_SUPPORTED = @as(u32, 2150858859);
pub const ERROR_WSMAN_MAXITEMS_NOT_SUPPORTED = @as(u32, 2150858860);
pub const ERROR_WSMAN_MAXTIME_NOT_SUPPORTED = @as(u32, 2150858861);
pub const ERROR_WSMAN_MAXENVELOPE_SIZE_NOT_SUPPORTED = @as(u32, 2150858862);
pub const ERROR_WSMAN_MAXENVELOPE_POLICY_NOT_SUPPORTED = @as(u32, 2150858863);
pub const ERROR_WSMAN_FILTERING_REQUIRED_NOT_SUPPORTED = @as(u32, 2150858864);
pub const ERROR_WSMAN_INSECURE_ADDRESS_NOT_SUPPORTED = @as(u32, 2150858865);
pub const ERROR_WSMAN_FORMAT_MISMATCH_NOT_SUPPORTED = @as(u32, 2150858866);
pub const ERROR_WSMAN_FORMAT_SECURITY_TOKEN_NOT_SUPPORTED = @as(u32, 2150858867);
pub const ERROR_WSMAN_BAD_METHOD = @as(u32, 2150858868);
pub const ERROR_WSMAN_UNSUPPORTED_MEDIA = @as(u32, 2150858869);
pub const ERROR_WSMAN_UNSUPPORTED_ADDRESSING_MODE = @as(u32, 2150858870);
pub const ERROR_WSMAN_FRAGMENT_TRANSFER_NOT_SUPPORTED = @as(u32, 2150858871);
pub const ERROR_WSMAN_ENUMERATION_INITIALIZING = @as(u32, 2150858872);
pub const ERROR_WSMAN_CONNECTOR_GET = @as(u32, 2150858873);
pub const ERROR_WSMAN_URI_QUERY_STRING_SYNTAX_ERROR = @as(u32, 2150858874);
pub const ERROR_WSMAN_INEXISTENT_MAC_ADDRESS = @as(u32, 2150858875);
pub const ERROR_WSMAN_NO_UNICAST_ADDRESSES = @as(u32, 2150858876);
pub const ERROR_WSMAN_NO_DHCP_ADDRESSES = @as(u32, 2150858877);
pub const ERROR_WSMAN_MIN_ENVELOPE_SIZE = @as(u32, 2150858878);
pub const ERROR_WSMAN_EPR_NESTING_EXCEEDED = @as(u32, 2150858879);
pub const ERROR_WSMAN_REQUEST_INIT_ERROR = @as(u32, 2150858880);
pub const ERROR_WSMAN_INVALID_TIMEOUT_HEADER = @as(u32, 2150858881);
pub const ERROR_WSMAN_CERT_NOT_FOUND = @as(u32, 2150858882);
pub const ERROR_WSMAN_PLUGIN_FAILED = @as(u32, 2150858883);
pub const ERROR_WSMAN_ENUMERATION_INVALID = @as(u32, 2150858884);
pub const ERROR_WSMAN_CONFIG_CANNOT_CHANGE_MUTUAL = @as(u32, 2150858885);
pub const ERROR_WSMAN_ENUMERATION_MODE_UNSUPPORTED = @as(u32, 2150858886);
pub const ERROR_WSMAN_MUSTUNDERSTAND_ON_LOCALE_UNSUPPORTED = @as(u32, 2150858887);
pub const ERROR_WSMAN_POLICY_CORRUPTED = @as(u32, 2150858888);
pub const ERROR_WSMAN_LISTENER_ADDRESS_INVALID = @as(u32, 2150858889);
pub const ERROR_WSMAN_CONFIG_CANNOT_CHANGE_GPO_CONTROLLED_SETTING = @as(u32, 2150858890);
pub const ERROR_WSMAN_EVENTING_CONCURRENT_CLIENT_RECEIVE = @as(u32, 2150858891);
pub const ERROR_WSMAN_EVENTING_FAST_SENDER = @as(u32, 2150858892);
pub const ERROR_WSMAN_EVENTING_INSECURE_PUSHSUBSCRIPTION_CONNECTION = @as(u32, 2150858893);
pub const ERROR_WSMAN_EVENTING_INVALID_EVENTSOURCE = @as(u32, 2150858894);
pub const ERROR_WSMAN_EVENTING_NOMATCHING_LISTENER = @as(u32, 2150858895);
pub const ERROR_WSMAN_FRAGMENT_DIALECT_REQUESTED_UNAVAILABLE = @as(u32, 2150858896);
pub const ERROR_WSMAN_MISSING_FRAGMENT_PATH = @as(u32, 2150858897);
pub const ERROR_WSMAN_INVALID_FRAGMENT_DIALECT = @as(u32, 2150858898);
pub const ERROR_WSMAN_INVALID_FRAGMENT_PATH = @as(u32, 2150858899);
pub const ERROR_WSMAN_EVENTING_INCOMPATIBLE_BATCHPARAMS_AND_DELIVERYMODE = @as(u32, 2150858900);
pub const ERROR_WSMAN_EVENTING_LOOPBACK_TESTFAILED = @as(u32, 2150858901);
pub const ERROR_WSMAN_EVENTING_INVALID_ENDTO_ADDRESSS = @as(u32, 2150858902);
pub const ERROR_WSMAN_EVENTING_INVALID_INCOMING_EVENT_PACKET_HEADER = @as(u32, 2150858903);
pub const ERROR_WSMAN_SESSION_ALREADY_CLOSED = @as(u32, 2150858904);
pub const ERROR_WSMAN_SUBSCRIPTION_LISTENER_NOLONGERVALID = @as(u32, 2150858905);
pub const ERROR_WSMAN_PROVIDER_LOAD_FAILED = @as(u32, 2150858906);
pub const ERROR_WSMAN_EVENTING_SUBSCRIPTIONCLOSED_BYREMOTESERVICE = @as(u32, 2150858907);
pub const ERROR_WSMAN_EVENTING_DELIVERYFAILED_FROMSOURCE = @as(u32, 2150858908);
pub const ERROR_WSMAN_SECURITY_UNMAPPED = @as(u32, 2150858909);
pub const ERROR_WSMAN_EVENTING_SUBSCRIPTION_CANCELLED_BYSOURCE = @as(u32, 2150858910);
pub const ERROR_WSMAN_INVALID_HOSTNAME_PATTERN = @as(u32, 2150858911);
pub const ERROR_WSMAN_EVENTING_MISSING_NOTIFYTO = @as(u32, 2150858912);
pub const ERROR_WSMAN_EVENTING_MISSING_NOTIFYTO_ADDRESSS = @as(u32, 2150858913);
pub const ERROR_WSMAN_EVENTING_INVALID_NOTIFYTO_ADDRESSS = @as(u32, 2150858914);
pub const ERROR_WSMAN_EVENTING_INVALID_LOCALE_IN_DELIVERY = @as(u32, 2150858915);
pub const ERROR_WSMAN_EVENTING_INVALID_HEARTBEAT = @as(u32, 2150858916);
pub const ERROR_WSMAN_MACHINE_OPTION_REQUIRED = @as(u32, 2150858917);
pub const ERROR_WSMAN_UNSUPPORTED_FEATURE_OPTIONS = @as(u32, 2150858918);
pub const ERROR_WSMAN_BATCHSIZE_TOO_SMALL = @as(u32, 2150858919);
pub const ERROR_WSMAN_EVENTING_DELIVERY_MODE_REQUESTED_INVALID = @as(u32, 2150858920);
pub const ERROR_WSMAN_PROVSYS_NOT_SUPPORTED = @as(u32, 2150858921);
pub const ERROR_WSMAN_PUSH_SUBSCRIPTION_CONFIG_INVALID = @as(u32, 2150858922);
pub const ERROR_WSMAN_CREDS_PASSED_WITH_NO_AUTH_FLAG = @as(u32, 2150858923);
pub const ERROR_WSMAN_CLIENT_INVALID_FLAG = @as(u32, 2150858924);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_AUTH_FLAGS = @as(u32, 2150858925);
pub const ERROR_WSMAN_CLIENT_SPN_WRONG_AUTH = @as(u32, 2150858926);
pub const ERROR_WSMAN_CLIENT_CERT_UNNEEDED_CREDS = @as(u32, 2150858927);
pub const ERROR_WSMAN_CLIENT_USERNAME_PASSWORD_NEEDED = @as(u32, 2150858928);
pub const ERROR_WSMAN_CLIENT_CERT_UNNEEDED_USERNAME = @as(u32, 2150858929);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_NEEDED = @as(u32, 2150858930);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_FLAG_NEEDED = @as(u32, 2150858931);
pub const ERROR_WSMAN_CLIENT_CERT_NEEDED = @as(u32, 2150858932);
pub const ERROR_WSMAN_CLIENT_CERT_UNKNOWN_TYPE = @as(u32, 2150858933);
pub const ERROR_WSMAN_CLIENT_CERT_UNKNOWN_LOCATION = @as(u32, 2150858934);
pub const ERROR_WSMAN_CLIENT_INVALID_CERT = @as(u32, 2150858935);
pub const ERROR_WSMAN_CLIENT_LOCAL_INVALID_CREDS = @as(u32, 2150858936);
pub const ERROR_WSMAN_CLIENT_LOCAL_INVALID_CONNECTION_OPTIONS = @as(u32, 2150858937);
pub const ERROR_WSMAN_CLIENT_CREATESESSION_NULL_PARAM = @as(u32, 2150858938);
pub const ERROR_WSMAN_CLIENT_ENUMERATE_NULL_PARAM = @as(u32, 2150858939);
pub const ERROR_WSMAN_CLIENT_SUBSCRIBE_NULL_PARAM = @as(u32, 2150858940);
pub const ERROR_WSMAN_CLIENT_NULL_RESULT_PARAM = @as(u32, 2150858941);
pub const ERROR_WSMAN_CLIENT_NO_HANDLE = @as(u32, 2150858942);
pub const ERROR_WSMAN_CLIENT_BLANK_URI = @as(u32, 2150858943);
pub const ERROR_WSMAN_CLIENT_INVALID_RESOURCE_LOCATOR = @as(u32, 2150858944);
pub const ERROR_WSMAN_CLIENT_BLANK_INPUT_XML = @as(u32, 2150858945);
pub const ERROR_WSMAN_CLIENT_BATCH_ITEMS_TOO_SMALL = @as(u32, 2150858946);
pub const ERROR_WSMAN_CLIENT_MAX_CHARS_TOO_SMALL = @as(u32, 2150858947);
pub const ERROR_WSMAN_CLIENT_BLANK_ACTION_URI = @as(u32, 2150858948);
pub const ERROR_WSMAN_CLIENT_ZERO_HEARTBEAT = @as(u32, 2150858949);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_DELIVERY_MODES = @as(u32, 2150858950);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_ENVELOPE_POLICIES = @as(u32, 2150858951);
pub const ERROR_WSMAN_CLIENT_UNKNOWN_EXPIRATION_TYPE = @as(u32, 2150858952);
pub const ERROR_WSMAN_CLIENT_MISSING_EXPIRATION = @as(u32, 2150858953);
pub const ERROR_WSMAN_CLIENT_PULL_INVALID_FLAGS = @as(u32, 2150858954);
pub const ERROR_WSMAN_CLIENT_PUSH_UNSUPPORTED_TRANSPORT = @as(u32, 2150858955);
pub const ERROR_WSMAN_CLIENT_PUSH_HOST_TOO_LONG = @as(u32, 2150858956);
pub const ERROR_WSMAN_CLIENT_COMPRESSION_INVALID_OPTION = @as(u32, 2150858957);
pub const ERROR_WSMAN_CLIENT_DELIVERENDSUBSCRIPTION_NULL_PARAM = @as(u32, 2150858958);
pub const ERROR_WSMAN_CLIENT_DELIVEREVENTS_NULL_PARAM = @as(u32, 2150858959);
pub const ERROR_WSMAN_CLIENT_GETBOOKMARK_NULL_PARAM = @as(u32, 2150858960);
pub const ERROR_WSMAN_CLIENT_DECODEOBJECT_NULL_PARAM = @as(u32, 2150858961);
pub const ERROR_WSMAN_CLIENT_ENCODEOBJECT_NULL_PARAM = @as(u32, 2150858962);
pub const ERROR_WSMAN_CLIENT_ENUMERATORADDOBJECT_NULL_PARAM = @as(u32, 2150858963);
pub const ERROR_WSMAN_CLIENT_ENUMERATORNEXTOBJECT_NULL_PARAM = @as(u32, 2150858964);
pub const ERROR_WSMAN_CLIENT_CONSTRUCTERROR_NULL_PARAM = @as(u32, 2150858965);
pub const ERROR_WSMAN_SERVER_NONPULLSUBSCRIBE_NULL_PARAM = @as(u32, 2150858966);
pub const ERROR_WSMAN_CLIENT_UNENCRYPTED_HTTP_ONLY = @as(u32, 2150858967);
pub const ERROR_WSMAN_CANNOT_USE_CERTIFICATES_FOR_HTTP = @as(u32, 2150858968);
pub const ERROR_WSMAN_CONNECTIONSTR_INVALID = @as(u32, 2150858969);
pub const ERROR_WSMAN_TRANSPORT_NOT_SUPPORTED = @as(u32, 2150858970);
pub const ERROR_WSMAN_PORT_INVALID = @as(u32, 2150858971);
pub const ERROR_WSMAN_CONFIG_PORT_INVALID = @as(u32, 2150858972);
pub const ERROR_WSMAN_SENDHEARBEAT_EMPTY_ENUMERATOR = @as(u32, 2150858973);
pub const ERROR_WSMAN_CLIENT_UNENCRYPTED_DISABLED = @as(u32, 2150858974);
pub const ERROR_WSMAN_CLIENT_BASIC_AUTHENTICATION_DISABLED = @as(u32, 2150858975);
pub const ERROR_WSMAN_CLIENT_DIGEST_AUTHENTICATION_DISABLED = @as(u32, 2150858976);
pub const ERROR_WSMAN_CLIENT_NEGOTIATE_AUTHENTICATION_DISABLED = @as(u32, 2150858977);
pub const ERROR_WSMAN_CLIENT_KERBEROS_AUTHENTICATION_DISABLED = @as(u32, 2150858978);
pub const ERROR_WSMAN_CLIENT_CERTIFICATES_AUTHENTICATION_DISABLED = @as(u32, 2150858979);
pub const ERROR_WSMAN_SERVER_NOT_TRUSTED = @as(u32, 2150858980);
pub const ERROR_WSMAN_EXPLICIT_CREDENTIALS_REQUIRED = @as(u32, 2150858981);
pub const ERROR_WSMAN_CERT_THUMBPRINT_NOT_BLANK = @as(u32, 2150858982);
pub const ERROR_WSMAN_CERT_THUMBPRINT_BLANK = @as(u32, 2150858983);
pub const ERROR_WSMAN_CONFIG_CANNOT_SHARE_SSL_CONFIG = @as(u32, 2150858984);
pub const ERROR_WSMAN_CONFIG_CERT_CN_DOES_NOT_MATCH_HOSTNAME = @as(u32, 2150858985);
pub const ERROR_WSMAN_CONFIG_HOSTNAME_CHANGE_WITHOUT_CERT = @as(u32, 2150858986);
pub const ERROR_WSMAN_CONFIG_THUMBPRINT_SHOULD_BE_EMPTY = @as(u32, 2150858987);
pub const ERROR_WSMAN_INVALID_IPFILTER = @as(u32, 2150858988);
pub const ERROR_WSMAN_CANNOT_CHANGE_KEYS = @as(u32, 2150858989);
pub const ERROR_WSMAN_CERT_INVALID_USAGE = @as(u32, 2150858990);
pub const ERROR_WSMAN_RESPONSE_NO_RESULTS = @as(u32, 2150858991);
pub const ERROR_WSMAN_CREATE_RESPONSE_NO_EPR = @as(u32, 2150858992);
pub const ERROR_WSMAN_RESPONSE_INVALID_ENUMERATION_CONTEXT = @as(u32, 2150858993);
pub const ERROR_WSMAN_RESPONSE_NO_XML_FRAGMENT_WRAPPER = @as(u32, 2150858994);
pub const ERROR_WSMAN_RESPONSE_INVALID_MESSAGE_INFORMATION_HEADER = @as(u32, 2150858995);
pub const ERROR_WSMAN_RESPONSE_NO_SOAP_HEADER_BODY = @as(u32, 2150858996);
pub const ERROR_WSMAN_HTTP_NO_RESPONSE_DATA = @as(u32, 2150858997);
pub const ERROR_WSMAN_RESPONSE_INVALID_SOAP_FAULT = @as(u32, 2150858998);
pub const ERROR_WSMAN_HTTP_INVALID_CONTENT_TYPE_IN_RESPONSE_DATA = @as(u32, 2150858999);
pub const ERROR_WSMAN_HTTP_CONTENT_TYPE_MISSMATCH_RESPONSE_DATA = @as(u32, 2150859000);
pub const ERROR_WSMAN_CANNOT_DECRYPT = @as(u32, 2150859001);
pub const ERROR_WSMAN_INVALID_URI_WMI_SINGLETON = @as(u32, 2150859002);
pub const ERROR_WSMAN_INVALID_URI_WMI_ENUM_WQL = @as(u32, 2150859003);
pub const ERROR_WSMAN_NO_IDENTIFY_FOR_LOCAL_SESSION = @as(u32, 2150859004);
pub const ERROR_WSMAN_NO_PUSH_SUBSCRIPTION_FOR_LOCAL_SESSION = @as(u32, 2150859005);
pub const ERROR_WSMAN_INVALID_SUBSCRIPTION_MANAGER = @as(u32, 2150859006);
pub const ERROR_WSMAN_NON_PULL_SUBSCRIPTION_NOT_SUPPORTED = @as(u32, 2150859007);
pub const ERROR_WSMAN_WMI_MAX_NESTED = @as(u32, 2150859008);
pub const ERROR_WSMAN_REMOTE_CIMPATH_NOT_SUPPORTED = @as(u32, 2150859009);
pub const ERROR_WSMAN_WMI_PROVIDER_NOT_CAPABLE = @as(u32, 2150859010);
pub const ERROR_WSMAN_WMI_INVALID_VALUE = @as(u32, 2150859011);
pub const ERROR_WSMAN_WMI_SVC_ACCESS_DENIED = @as(u32, 2150859012);
pub const ERROR_WSMAN_WMI_PROVIDER_ACCESS_DENIED = @as(u32, 2150859013);
pub const ERROR_WSMAN_WMI_CANNOT_CONNECT_ACCESS_DENIED = @as(u32, 2150859014);
pub const ERROR_WSMAN_INVALID_FILTER_XML = @as(u32, 2150859015);
pub const ERROR_WSMAN_ENUMERATE_WMI_INVALID_KEY = @as(u32, 2150859016);
pub const ERROR_WSMAN_INVALID_FRAGMENT_PATH_BLANK = @as(u32, 2150859017);
pub const ERROR_WSMAN_INVALID_CHARACTERS_IN_RESPONSE = @as(u32, 2150859018);
pub const ERROR_WSMAN_KERBEROS_IPADDRESS = @as(u32, 2150859019);
pub const ERROR_WSMAN_CLIENT_WORKGROUP_NO_KERBEROS = @as(u32, 2150859020);
pub const ERROR_WSMAN_INVALID_BATCH_SETTINGS_PARAMETER = @as(u32, 2150859021);
pub const ERROR_WSMAN_SERVER_DESTINATION_LOCALHOST = @as(u32, 2150859022);
pub const ERROR_WSMAN_UNKNOWN_HTTP_STATUS_RETURNED = @as(u32, 2150859023);
pub const ERROR_WSMAN_UNSUPPORTED_HTTP_STATUS_REDIRECT = @as(u32, 2150859024);
pub const ERROR_WSMAN_HTTP_REQUEST_TOO_LARGE_STATUS = @as(u32, 2150859025);
pub const ERROR_WSMAN_HTTP_SERVICE_UNAVAILABLE_STATUS = @as(u32, 2150859026);
pub const ERROR_WSMAN_HTTP_NOT_FOUND_STATUS = @as(u32, 2150859027);
pub const ERROR_WSMAN_EVENTING_MISSING_LOCALE_IN_DELIVERY = @as(u32, 2150859028);
pub const ERROR_WSMAN_QUICK_CONFIG_FAILED_CERT_REQUIRED = @as(u32, 2150859029);
pub const ERROR_WSMAN_QUICK_CONFIG_FIREWALL_EXCEPTIONS_DISALLOWED = @as(u32, 2150859030);
pub const ERROR_WSMAN_QUICK_CONFIG_LOCAL_POLICY_CHANGE_DISALLOWED = @as(u32, 2150859031);
pub const ERROR_WSMAN_INVALID_SELECTOR_NAME = @as(u32, 2150859032);
pub const ERROR_WSMAN_ENCODING_TYPE = @as(u32, 2150859033);
pub const ERROR_WSMAN_ENDPOINT_UNAVAILABLE_INVALID_VALUE = @as(u32, 2150859034);
pub const ERROR_WSMAN_INVALID_HEADER = @as(u32, 2150859035);
pub const ERROR_WSMAN_ENUMERATE_UNSUPPORTED_EXPIRATION_TYPE = @as(u32, 2150859036);
pub const ERROR_WSMAN_MAX_ELEMENTS_NOT_SUPPORTED = @as(u32, 2150859037);
pub const ERROR_WSMAN_WMI_PROVIDER_INVALID_PARAMETER = @as(u32, 2150859038);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_ENUM_MODE_FLAGS = @as(u32, 2150859039);
pub const ERROR_WINRS_CLIENT_INVALID_FLAG = @as(u32, 2150859040);
pub const ERROR_WINRS_CLIENT_NULL_PARAM = @as(u32, 2150859041);
pub const ERROR_WSMAN_CANNOT_PROCESS_FILTER = @as(u32, 2150859042);
pub const ERROR_WSMAN_CLIENT_ENUMERATORADDEVENT_NULL_PARAM = @as(u32, 2150859043);
pub const ERROR_WSMAN_ADDOBJECT_MISSING_OBJECT = @as(u32, 2150859044);
pub const ERROR_WSMAN_ADDOBJECT_MISSING_EPR = @as(u32, 2150859045);
pub const ERROR_WSMAN_NETWORK_TIMEDOUT = @as(u32, 2150859046);
pub const ERROR_WINRS_RECEIVE_IN_PROGRESS = @as(u32, 2150859047);
pub const ERROR_WINRS_RECEIVE_NO_RESPONSE_DATA = @as(u32, 2150859048);
pub const ERROR_WINRS_CLIENT_CREATESHELL_NULL_PARAM = @as(u32, 2150859049);
pub const ERROR_WINRS_CLIENT_CLOSESHELL_NULL_PARAM = @as(u32, 2150859050);
pub const ERROR_WINRS_CLIENT_FREECREATESHELLRESULT_NULL_PARAM = @as(u32, 2150859051);
pub const ERROR_WINRS_CLIENT_RUNCOMMAND_NULL_PARAM = @as(u32, 2150859052);
pub const ERROR_WINRS_CLIENT_FREERUNCOMMANDRESULT_NULL_PARAM = @as(u32, 2150859053);
pub const ERROR_WINRS_CLIENT_SIGNAL_NULL_PARAM = @as(u32, 2150859054);
pub const ERROR_WINRS_CLIENT_RECEIVE_NULL_PARAM = @as(u32, 2150859055);
pub const ERROR_WINRS_CLIENT_FREEPULLRESULT_NULL_PARAM = @as(u32, 2150859056);
pub const ERROR_WINRS_CLIENT_PULL_NULL_PARAM = @as(u32, 2150859057);
pub const ERROR_WINRS_CLIENT_CLOSERECEIVEHANDLE_NULL_PARAM = @as(u32, 2150859058);
pub const ERROR_WINRS_CLIENT_SEND_NULL_PARAM = @as(u32, 2150859059);
pub const ERROR_WINRS_CLIENT_PUSH_NULL_PARAM = @as(u32, 2150859060);
pub const ERROR_WINRS_CLIENT_CLOSESENDHANDLE_NULL_PARAM = @as(u32, 2150859061);
pub const ERROR_WINRS_CLIENT_GET_NULL_PARAM = @as(u32, 2150859062);
pub const ERROR_WSMAN_POLYMORPHISM_MODE_UNSUPPORTED = @as(u32, 2150859063);
pub const ERROR_WSMAN_REQUEST_NOT_SUPPORTED_AT_SERVICE = @as(u32, 2150859064);
pub const ERROR_WSMAN_URI_NON_DMTF_CLASS = @as(u32, 2150859065);
pub const ERROR_WSMAN_URI_WRONG_DMTF_VERSION = @as(u32, 2150859066);
pub const ERROR_WSMAN_DIFFERENT_CIM_SELECTOR = @as(u32, 2150859067);
pub const ERROR_WSMAN_PUSHSUBSCRIPTION_INVALIDUSERACCOUNT = @as(u32, 2150859068);
pub const ERROR_WSMAN_EVENTING_NONDOMAINJOINED_PUBLISHER = @as(u32, 2150859069);
pub const ERROR_WSMAN_EVENTING_NONDOMAINJOINED_COLLECTOR = @as(u32, 2150859070);
pub const ERROR_WSMAN_CONFIG_READONLY_PROPERTY = @as(u32, 2150859071);
pub const ERROR_WINRS_CODE_PAGE_NOT_SUPPORTED = @as(u32, 2150859072);
pub const ERROR_WSMAN_CLIENT_DISABLE_LOOPBACK_WITH_EXPLICIT_CREDENTIALS = @as(u32, 2150859073);
pub const ERROR_WSMAN_CLIENT_INVALID_DISABLE_LOOPBACK = @as(u32, 2150859074);
pub const ERROR_WSMAN_CLIENT_ENUM_RECEIVED_TOO_MANY_ITEMS = @as(u32, 2150859075);
pub const ERROR_WSMAN_MULTIPLE_CREDENTIALS = @as(u32, 2150859076);
pub const ERROR_WSMAN_AUTHENTICATION_INVALID_FLAG = @as(u32, 2150859077);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_FOR_DEFAULT_AUTHENTICATION = @as(u32, 2150859078);
pub const ERROR_WSMAN_CLIENT_USERNAME_AND_PASSWORD_NEEDED = @as(u32, 2150859079);
pub const ERROR_WSMAN_CLIENT_INVALID_CERT_DNS_OR_UPN = @as(u32, 2150859080);
pub const ERROR_WSMAN_CREATESHELL_NULL_ENVIRONMENT_VARIABLE_NAME = @as(u32, 2150859081);
pub const ERROR_WSMAN_SHELL_ALREADY_CLOSED = @as(u32, 2150859082);
pub const ERROR_WSMAN_CREATESHELL_NULL_STREAMID = @as(u32, 2150859083);
pub const ERROR_WSMAN_SHELL_INVALID_SHELL_HANDLE = @as(u32, 2150859084);
pub const ERROR_WSMAN_SHELL_INVALID_COMMAND_HANDLE = @as(u32, 2150859085);
pub const ERROR_WSMAN_RUNSHELLCOMMAND_NULL_ARGUMENT = @as(u32, 2150859086);
pub const ERROR_WSMAN_COMMAND_ALREADY_CLOSED = @as(u32, 2150859087);
pub const ERROR_WSMAN_SENDSHELLINPUT_INVALID_STREAMID_INDEX = @as(u32, 2150859088);
pub const ERROR_WSMAN_SHELL_SYNCHRONOUS_NOT_SUPPORTED = @as(u32, 2150859089);
pub const ERROR_WSMAN_NO_CERTMAPPING_OPERATION_FOR_LOCAL_SESSION = @as(u32, 2150859090);
pub const ERROR_WSMAN_CERTMAPPING_CONFIGLIMIT_EXCEEDED = @as(u32, 2150859091);
pub const ERROR_WSMAN_CERTMAPPING_INVALIDUSERCREDENTIALS = @as(u32, 2150859092);
pub const ERROR_WSMAN_CERT_INVALID_USAGE_CLIENT = @as(u32, 2150859093);
pub const ERROR_WSMAN_CERT_MISSING_AUTH_FLAG = @as(u32, 2150859094);
pub const ERROR_WSMAN_CERT_MULTIPLE_CREDENTIALS_FLAG = @as(u32, 2150859095);
pub const ERROR_WSMAN_CONFIG_SHELL_URI_INVALID = @as(u32, 2150859096);
pub const ERROR_WSMAN_CONFIG_SHELL_URI_CMDSHELLURI_NOTPERMITTED = @as(u32, 2150859097);
pub const ERROR_WSMAN_CONFIG_SHELLURI_INVALID_PROCESSPATH = @as(u32, 2150859098);
pub const ERROR_WINRS_SHELL_URI_INVALID = @as(u32, 2150859099);
pub const ERROR_WSMAN_INVALID_SECURITY_DESCRIPTOR = @as(u32, 2150859100);
pub const ERROR_WSMAN_POLICY_TOO_COMPLEX = @as(u32, 2150859101);
pub const ERROR_WSMAN_POLICY_CANNOT_COMPLY = @as(u32, 2150859102);
pub const ERROR_WSMAN_INVALID_CONNECTIONRETRY = @as(u32, 2150859103);
pub const ERROR_WSMAN_URISECURITY_INVALIDURIKEY = @as(u32, 2150859104);
pub const ERROR_WSMAN_CERTMAPPING_INVALIDSUBJECTKEY = @as(u32, 2150859105);
pub const ERROR_WSMAN_CERTMAPPING_INVALIDISSUERKEY = @as(u32, 2150859106);
pub const ERROR_WSMAN_INVALID_PUBLISHERS_TYPE = @as(u32, 2150859107);
pub const ERROR_WSMAN_CLIENT_INVALID_DELIVERY_RETRY = @as(u32, 2150859108);
pub const ERROR_WSMAN_CLIENT_NULL_PUBLISHERS = @as(u32, 2150859109);
pub const ERROR_WSMAN_CLIENT_NULL_ISSUERS = @as(u32, 2150859110);
pub const ERROR_WSMAN_CLIENT_NO_SOURCES = @as(u32, 2150859111);
pub const ERROR_WSMAN_INVALID_SUBSCRIBE_OBJECT = @as(u32, 2150859112);
pub const ERROR_WSMAN_PUBLIC_FIREWALL_PROFILE_ACTIVE = @as(u32, 2150859113);
pub const ERROR_WSMAN_CERTMAPPING_PASSWORDTOOLONG = @as(u32, 2150859114);
pub const ERROR_WSMAN_CERTMAPPING_PASSWORDBLANK = @as(u32, 2150859115);
pub const ERROR_WSMAN_CERTMAPPING_PASSWORDUSERTUPLE = @as(u32, 2150859116);
pub const ERROR_WSMAN_INVALID_PROVIDER_RESPONSE = @as(u32, 2150859117);
pub const ERROR_WSMAN_SHELL_NOT_INITIALIZED = @as(u32, 2150859118);
pub const ERROR_WSMAN_CONFIG_SHELLURI_INVALID_OPERATION_ON_KEY = @as(u32, 2150859119);
pub const ERROR_WSMAN_HTTP_STATUS_SERVER_ERROR = @as(u32, 2150859120);
pub const ERROR_WSMAN_HTTP_STATUS_BAD_REQUEST = @as(u32, 2150859121);
pub const ERROR_WSMAN_CONFIG_CANNOT_CHANGE_CERTMAPPING_KEYS = @as(u32, 2150859122);
pub const ERROR_WSMAN_HTML_ERROR = @as(u32, 2150859123);
pub const ERROR_WSMAN_CLIENT_INITIALIZE_NULL_PARAM = @as(u32, 2150859124);
pub const ERROR_WSMAN_CLIENT_INVALID_INIT_APPLICATION_FLAG = @as(u32, 2150859125);
pub const ERROR_WSMAN_CLIENT_INVALID_DEINIT_APPLICATION_FLAG = @as(u32, 2150859126);
pub const ERROR_WSMAN_CLIENT_SETSESSIONOPTION_NULL_PARAM = @as(u32, 2150859127);
pub const ERROR_WSMAN_CLIENT_SETSESSIONOPTION_INVALID_PARAM = @as(u32, 2150859128);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_INVALID_PARAM = @as(u32, 2150859129);
pub const ERROR_WSMAN_CLIENT_CREATESHELL_NULL_PARAM = @as(u32, 2150859130);
pub const ERROR_WSMAN_CLIENT_INVALID_CREATE_SHELL_FLAG = @as(u32, 2150859131);
pub const ERROR_WSMAN_CLIENT_INVALID_CLOSE_SHELL_FLAG = @as(u32, 2150859132);
pub const ERROR_WSMAN_CLIENT_INVALID_CLOSE_COMMAND_FLAG = @as(u32, 2150859133);
pub const ERROR_WSMAN_CLIENT_CLOSESHELL_NULL_PARAM = @as(u32, 2150859134);
pub const ERROR_WSMAN_CLIENT_CLOSECOMMAND_NULL_PARAM = @as(u32, 2150859135);
pub const ERROR_WSMAN_CLIENT_RUNCOMMAND_NULL_PARAM = @as(u32, 2150859136);
pub const ERROR_WSMAN_CLIENT_INVALID_RUNCOMMAND_FLAG = @as(u32, 2150859137);
pub const ERROR_WSMAN_CLIENT_RUNCOMMAND_NOTCOMPLETED = @as(u32, 2150859138);
pub const ERROR_WSMAN_NO_COMMAND_RESPONSE = @as(u32, 2150859139);
pub const ERROR_WSMAN_INVALID_OPTIONSET = @as(u32, 2150859140);
pub const ERROR_WSMAN_NO_COMMANDID = @as(u32, 2150859141);
pub const ERROR_WSMAN_CLIENT_SIGNAL_NULL_PARAM = @as(u32, 2150859142);
pub const ERROR_WSMAN_CLIENT_INVALID_SIGNAL_SHELL_FLAG = @as(u32, 2150859143);
pub const ERROR_WSMAN_CLIENT_SEND_NULL_PARAM = @as(u32, 2150859144);
pub const ERROR_WSMAN_CLIENT_INVALID_SEND_SHELL_FLAG = @as(u32, 2150859145);
pub const ERROR_WSMAN_CLIENT_INVALID_SEND_SHELL_PARAMETER = @as(u32, 2150859146);
pub const ERROR_WSMAN_SHELL_INVALID_INPUT_STREAM = @as(u32, 2150859147);
pub const ERROR_WSMAN_CLIENT_RECEIVE_NULL_PARAM = @as(u32, 2150859148);
pub const ERROR_WSMAN_SHELL_INVALID_DESIRED_STREAMS = @as(u32, 2150859149);
pub const ERROR_WSMAN_CLIENT_INVALID_RECEIVE_SHELL_FLAG = @as(u32, 2150859150);
pub const ERROR_WSMAN_NO_RECEIVE_RESPONSE = @as(u32, 2150859151);
pub const ERROR_WSMAN_PLUGIN_CONFIGURATION_CORRUPTED = @as(u32, 2150859152);
pub const ERROR_WSMAN_INVALID_FILEPATH = @as(u32, 2150859153);
pub const ERROR_WSMAN_FILE_NOT_PRESENT = @as(u32, 2150859154);
pub const ERROR_WSMAN_IISCONFIGURATION_READ_FAILED = @as(u32, 2150859155);
pub const ERROR_WSMAN_CLIENT_INVALID_LOCALE = @as(u32, 2150859156);
pub const ERROR_WSMAN_CLIENT_INVALID_UI_LANGUAGE = @as(u32, 2150859157);
pub const ERROR_WSMAN_CLIENT_GETERRORMESSAGE_NULL_PARAM = @as(u32, 2150859158);
pub const ERROR_WSMAN_CLIENT_INVALID_LANGUAGE_CODE = @as(u32, 2150859159);
pub const ERROR_WSMAN_CLIENT_INVALID_GETERRORMESSAGE_FLAG = @as(u32, 2150859160);
pub const ERROR_WSMAN_REDIRECT_REQUESTED = @as(u32, 2150859161);
pub const ERROR_WSMAN_PROXY_AUTHENTICATION_INVALID_FLAG = @as(u32, 2150859162);
pub const ERROR_WSMAN_CLIENT_CREDENTIALS_FOR_PROXY_AUTHENTICATION = @as(u32, 2150859163);
pub const ERROR_WSMAN_PROXY_ACCESS_TYPE = @as(u32, 2150859164);
pub const ERROR_WSMAN_INVALID_OPTION_NO_PROXY_SERVER = @as(u32, 2150859165);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_DWORD_NULL_PARAM = @as(u32, 2150859166);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_DWORD_INVALID_PARAM = @as(u32, 2150859167);
pub const ERROR_WSMAN_CLIENT_GETSESSIONOPTION_STRING_INVALID_PARAM = @as(u32, 2150859168);
pub const ERROR_WSMAN_CREDSSP_USERNAME_PASSWORD_NEEDED = @as(u32, 2150859169);
pub const ERROR_WSMAN_CLIENT_CREDSSP_AUTHENTICATION_DISABLED = @as(u32, 2150859170);
pub const ERROR_WSMAN_CLIENT_ALLOWFRESHCREDENTIALS = @as(u32, 2150859171);
pub const ERROR_WSMAN_CLIENT_ALLOWFRESHCREDENTIALS_NTLMONLY = @as(u32, 2150859172);
pub const ERROR_WSMAN_QUOTA_MAX_SHELLS = @as(u32, 2150859173);
pub const ERROR_WSMAN_QUOTA_MAX_OPERATIONS = @as(u32, 2150859174);
pub const ERROR_WSMAN_QUOTA_USER = @as(u32, 2150859175);
pub const ERROR_WSMAN_QUOTA_SYSTEM = @as(u32, 2150859176);
pub const ERROR_WSMAN_DIFFERENT_AUTHZ_TOKEN = @as(u32, 2150859177);
pub const ERROR_WSMAN_REDIRECT_LOCATION_NOT_AVAILABLE = @as(u32, 2150859178);
pub const ERROR_WSMAN_QUOTA_MAX_SHELLUSERS = @as(u32, 2150859179);
pub const ERROR_WSMAN_REMOTESHELLS_NOT_ALLOWED = @as(u32, 2150859180);
pub const ERROR_WSMAN_PULL_PARAMS_NOT_SAME_AS_ENUM = @as(u32, 2150859181);
pub const ERROR_WSMAN_DEPRECATED_CONFIG_SETTING = @as(u32, 2150859182);
pub const ERROR_WSMAN_URI_SECURITY_URI = @as(u32, 2150859183);
pub const ERROR_WSMAN_CANNOT_USE_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS_FOR_HTTP = @as(u32, 2150859184);
pub const ERROR_WSMAN_CANNOT_USE_PROXY_SETTINGS_FOR_HTTP = @as(u32, 2150859185);
pub const ERROR_WSMAN_CANNOT_USE_PROXY_SETTINGS_FOR_KERBEROS = @as(u32, 2150859186);
pub const ERROR_WSMAN_CANNOT_USE_PROXY_SETTINGS_FOR_CREDSSP = @as(u32, 2150859187);
pub const ERROR_WSMAN_CLIENT_MULTIPLE_PROXY_AUTH_FLAGS = @as(u32, 2150859188);
pub const ERROR_WSMAN_INVALID_REDIRECT_ERROR = @as(u32, 2150859189);
pub const ERROR_REDIRECT_LOCATION_TOO_LONG = @as(u32, 2150859190);
pub const ERROR_REDIRECT_LOCATION_INVALID = @as(u32, 2150859191);
pub const ERROR_SERVICE_CBT_HARDENING_INVALID = @as(u32, 2150859192);
pub const ERROR_WSMAN_NAME_NOT_RESOLVED = @as(u32, 2150859193);
pub const ERROR_WSMAN_SSL_CONNECTION_ABORTED = @as(u32, 2150859194);
pub const ERROR_WSMAN_DEFAULTAUTH_IPADDRESS = @as(u32, 2150859195);
pub const ERROR_WSMAN_CUSTOMREMOTESHELL_DEPRECATED = @as(u32, 2150859196);
pub const ERROR_WSMAN_FEATURE_DEPRECATED = @as(u32, 2150859197);
pub const ERROR_WSMAN_INVALID_USESSL_PARAM = @as(u32, 2150859198);
pub const ERROR_WSMAN_INVALID_CONFIGSDDL_URL = @as(u32, 2150859199);
pub const ERROR_WSMAN_ENUMERATE_SHELLCOMAMNDS_FILTER_EXPECTED = @as(u32, 2150859200);
pub const ERROR_WSMAN_ENUMERATE_SHELLCOMMANDS_EPRS_NOTSUPPORTED = @as(u32, 2150859201);
pub const ERROR_WSMAN_CLIENT_CREATESHELL_NAME_INVALID = @as(u32, 2150859202);
pub const ERROR_WSMAN_RUNAS_INVALIDUSERCREDENTIALS = @as(u32, 2150859203);
pub const ERROR_WINRS_SHELL_DISCONNECTED = @as(u32, 2150859204);
pub const ERROR_WINRS_SHELL_DISCONNECT_NOT_SUPPORTED = @as(u32, 2150859205);
pub const ERROR_WINRS_SHELL_CLIENTSESSIONID_MISMATCH = @as(u32, 2150859206);
pub const ERROR_WSMAN_CLIENT_DISCONNECTSHELL_NULL_PARAM = @as(u32, 2150859207);
pub const ERROR_WSMAN_CLIENT_RECONNECTSHELL_NULL_PARAM = @as(u32, 2150859208);
pub const ERROR_WSMAN_CLIENT_CONNECTSHELL_NULL_PARAM = @as(u32, 2150859209);
pub const ERROR_WSMAN_CLIENT_CONNECTCOMMAND_NULL_PARAM = @as(u32, 2150859210);
pub const ERROR_WINRS_CONNECT_RESPONSE_BAD_BODY = @as(u32, 2150859211);
pub const ERROR_WSMAN_COMMAND_TERMINATED = @as(u32, 2150859212);
pub const ERROR_WINRS_SHELL_CONNECTED_TO_DIFFERENT_CLIENT = @as(u32, 2150859213);
pub const ERROR_WINRS_SHELL_DISCONNECT_OPERATION_NOT_GRACEFUL = @as(u32, 2150859214);
pub const ERROR_WINRS_SHELL_DISCONNECT_OPERATION_NOT_VALID = @as(u32, 2150859215);
pub const ERROR_WINRS_SHELL_RECONNECT_OPERATION_NOT_VALID = @as(u32, 2150859216);
pub const ERROR_WSMAN_CONFIG_GROUP_POLICY_CHANGE_NOTIFICATION_SUBSCRIPTION_FAILED = @as(u32, 2150859217);
pub const ERROR_WSMAN_CLIENT_RECONNECTSHELLCOMMAND_NULL_PARAM = @as(u32, 2150859218);
pub const ERROR_WINRS_SHELLCOMMAND_RECONNECT_OPERATION_NOT_VALID = @as(u32, 2150859219);
pub const ERROR_WINRS_SHELLCOMMAND_CLIENTID_NOT_VALID = @as(u32, 2150859220);
pub const ERROR_WINRS_SHELL_CLIENTID_NOT_VALID = @as(u32, 2150859221);
pub const ERROR_WINRS_SHELLCOMMAND_CLIENTID_RESOURCE_CONFLICT = @as(u32, 2150859222);
pub const ERROR_WINRS_SHELL_CLIENTID_RESOURCE_CONFLICT = @as(u32, 2150859223);
pub const ERROR_WINRS_SHELLCOMMAND_DISCONNECT_OPERATION_NOT_VALID = @as(u32, 2150859224);
pub const ERROR_WSMAN_SUBSCRIBE_WMI_INVALID_KEY = @as(u32, 2150859225);
pub const ERROR_WSMAN_CLIENT_INVALID_DISCONNECT_SHELL_FLAG = @as(u32, 2150859226);
pub const ERROR_WSMAN_CLIENT_INVALID_SHELL_COMMAND_PAIR = @as(u32, 2150859227);
pub const ERROR_WSMAN_SEMANTICCALLBACK_TIMEDOUT = @as(u32, 2150859228);
pub const ERROR_WSMAN_SERVICE_REMOTE_ACCESS_DISABLED = @as(u32, 2150859229);
pub const ERROR_WSMAN_SERVICE_STREAM_DISCONNECTED = @as(u32, 2150859230);
pub const ERROR_WSMAN_CREATESHELL_RUNAS_FAILED = @as(u32, 2150859231);
pub const ERROR_WSMAN_INVALID_XML_RUNAS_DISABLED = @as(u32, 2150859232);
pub const ERROR_WSMAN_WRONG_METADATA = @as(u32, 2150859233);
pub const ERROR_WSMAN_UNSUPPORTED_TYPE = @as(u32, 2150859234);
pub const ERROR_WSMAN_REMOTE_CONNECTION_NOT_ALLOWED = @as(u32, 2150859235);
pub const ERROR_WSMAN_QUOTA_MAX_SHELLS_PPQ = @as(u32, 2150859236);
pub const ERROR_WSMAN_QUOTA_MAX_USERS_PPQ = @as(u32, 2150859237);
pub const ERROR_WSMAN_QUOTA_MAX_PLUGINSHELLS_PPQ = @as(u32, 2150859238);
pub const ERROR_WSMAN_QUOTA_MAX_PLUGINOPERATIONS_PPQ = @as(u32, 2150859239);
pub const ERROR_WSMAN_QUOTA_MAX_OPERATIONS_USER_PPQ = @as(u32, 2150859240);
pub const ERROR_WSMAN_QUOTA_MAX_COMMANDS_PER_SHELL_PPQ = @as(u32, 2150859241);
pub const ERROR_WSMAN_QUOTA_MIN_REQUIREMENT_NOT_AVAILABLE_PPQ = @as(u32, 2150859242);
pub const ERROR_WSMAN_NEW_DESERIALIZER = @as(u32, 2150859243);
pub const ERROR_WSMAN_DESERIALIZE_CLASS = @as(u32, 2150859244);
pub const ERROR_WSMAN_GETCLASS = @as(u32, 2150859245);
pub const ERROR_WSMAN_NEW_SESSION = @as(u32, 2150859246);
pub const ERROR_WSMAN_NULL_KEY = @as(u32, 2150859247);
pub const ERROR_WSMAN_MUTUAL_AUTH_FAILED = @as(u32, 2150859248);
pub const ERROR_WSMAN_UNSUPPORTED_OCTETTYPE = @as(u32, 2150859249);
pub const ERROR_WINRS_IDLETIMEOUT_OUTOFBOUNDS = @as(u32, 2150859250);
pub const ERROR_WSMAN_INSUFFICIENT_METADATA_FOR_BASIC = @as(u32, 2150859251);
pub const ERROR_WSMAN_INVALID_LITERAL_URI = @as(u32, 2150859252);
pub const ERROR_WSMAN_OBJECTONLY_INVALID = @as(u32, 2150859253);
pub const ERROR_WSMAN_MISSING_CLASSNAME = @as(u32, 2150859254);
pub const ERROR_WSMAN_EVENTING_INVALID_ENCODING_IN_DELIVERY = @as(u32, 2150859255);
pub const ERROR_WSMAN_DESTINATION_INVALID = @as(u32, 2150859256);
pub const ERROR_WSMAN_UNSUPPORTED_FEATURE_IDENTIFY = @as(u32, 2150859257);
pub const ERROR_WSMAN_CLIENT_SESSION_UNUSABLE = @as(u32, 2150859258);
pub const ERROR_WSMAN_VIRTUALACCOUNT_NOTSUPPORTED = @as(u32, 2150859259);
pub const ERROR_WSMAN_VIRTUALACCOUNT_NOTSUPPORTED_DOWNLEVEL = @as(u32, 2150859260);
pub const ERROR_WSMAN_RUNASUSER_MANAGEDACCOUNT_LOGON_FAILED = @as(u32, 2150859261);
pub const ERROR_WSMAN_CERTMAPPING_CREDENTIAL_MANAGEMENT_FAILIED = @as(u32, 2150859262);

//--------------------------------------------------------------------------------
// Section: Types (76)
//--------------------------------------------------------------------------------
pub const WSMAN_DATA_TEXT = extern struct {
    bufferLength: u32,
    buffer: ?[*:0]const u16,
};

pub const WSMAN_DATA_BINARY = extern struct {
    dataLength: u32,
    data: ?*u8,
};

pub const WSManDataType = enum(i32) {
    NONE = 0,
    TYPE_TEXT = 1,
    TYPE_BINARY = 2,
    TYPE_DWORD = 4,
};
pub const WSMAN_DATA_NONE = WSManDataType.NONE;
pub const WSMAN_DATA_TYPE_TEXT = WSManDataType.TYPE_TEXT;
pub const WSMAN_DATA_TYPE_BINARY = WSManDataType.TYPE_BINARY;
pub const WSMAN_DATA_TYPE_DWORD = WSManDataType.TYPE_DWORD;

pub const WSMAN_DATA = extern struct {
    type: WSManDataType,
    Anonymous: extern union {
        text: WSMAN_DATA_TEXT,
        binaryData: WSMAN_DATA_BINARY,
        number: u32,
    },
};

pub const WSMAN_ERROR = extern struct {
    code: u32,
    errorDetail: ?[*:0]const u16,
    language: ?[*:0]const u16,
    machineName: ?[*:0]const u16,
    pluginName: ?[*:0]const u16,
};

pub const WSMAN_USERNAME_PASSWORD_CREDS = extern struct {
    username: ?[*:0]const u16,
    password: ?[*:0]const u16,
};

pub const WSManAuthenticationFlags = enum(i32) {
    DEFAULT_AUTHENTICATION = 0,
    NO_AUTHENTICATION = 1,
    AUTH_DIGEST = 2,
    AUTH_NEGOTIATE = 4,
    AUTH_BASIC = 8,
    AUTH_KERBEROS = 16,
    AUTH_CREDSSP = 128,
    AUTH_CLIENT_CERTIFICATE = 32,
};
pub const WSMAN_FLAG_DEFAULT_AUTHENTICATION = WSManAuthenticationFlags.DEFAULT_AUTHENTICATION;
pub const WSMAN_FLAG_NO_AUTHENTICATION = WSManAuthenticationFlags.NO_AUTHENTICATION;
pub const WSMAN_FLAG_AUTH_DIGEST = WSManAuthenticationFlags.AUTH_DIGEST;
pub const WSMAN_FLAG_AUTH_NEGOTIATE = WSManAuthenticationFlags.AUTH_NEGOTIATE;
pub const WSMAN_FLAG_AUTH_BASIC = WSManAuthenticationFlags.AUTH_BASIC;
pub const WSMAN_FLAG_AUTH_KERBEROS = WSManAuthenticationFlags.AUTH_KERBEROS;
pub const WSMAN_FLAG_AUTH_CREDSSP = WSManAuthenticationFlags.AUTH_CREDSSP;
pub const WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE = WSManAuthenticationFlags.AUTH_CLIENT_CERTIFICATE;

pub const WSMAN_AUTHENTICATION_CREDENTIALS = extern struct {
    authenticationMechanism: u32,
    Anonymous: extern union {
        userAccount: WSMAN_USERNAME_PASSWORD_CREDS,
        certificateThumbprint: ?[*:0]const u16,
    },
};

pub const WSMAN_OPTION = extern struct {
    name: ?[*:0]const u16,
    value: ?[*:0]const u16,
    mustComply: BOOL,
};

pub const WSMAN_OPTION_SET = extern struct {
    optionsCount: u32,
    options: ?*WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
};

pub const WSMAN_OPTION_SETEX = extern struct {
    optionsCount: u32,
    options: ?*WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
    optionTypes: ?*?PWSTR,
};

pub const WSMAN_KEY = extern struct {
    key: ?[*:0]const u16,
    value: ?[*:0]const u16,
};

pub const WSMAN_SELECTOR_SET = extern struct {
    numberKeys: u32,
    keys: ?*WSMAN_KEY,
};

pub const WSMAN_FRAGMENT = extern struct {
    path: ?[*:0]const u16,
    dialect: ?[*:0]const u16,
};

pub const WSMAN_FILTER = extern struct {
    filter: ?[*:0]const u16,
    dialect: ?[*:0]const u16,
};

pub const WSMAN_OPERATION_INFO = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SET,
    reserved: ?*anyopaque,
    version: u32,
};

pub const WSMAN_OPERATION_INFOEX = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SETEX,
    version: u32,
    uiLocale: ?[*:0]const u16,
    dataLocale: ?[*:0]const u16,
};

pub const WSMAN_API = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSManProxyAccessType = enum(i32) {
    IE_PROXY_CONFIG = 1,
    WINHTTP_PROXY_CONFIG = 2,
    AUTO_DETECT = 4,
    NO_PROXY_SERVER = 8,
};
pub const WSMAN_OPTION_PROXY_IE_PROXY_CONFIG = WSManProxyAccessType.IE_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG = WSManProxyAccessType.WINHTTP_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_AUTO_DETECT = WSManProxyAccessType.AUTO_DETECT;
pub const WSMAN_OPTION_PROXY_NO_PROXY_SERVER = WSManProxyAccessType.NO_PROXY_SERVER;

pub const WSMAN_PROXY_INFO = extern struct {
    accessType: u32,
    authenticationCredentials: WSMAN_AUTHENTICATION_CREDENTIALS,
};

pub const WSMAN_SESSION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSManSessionOption = enum(i32) {
    DEFAULT_OPERATION_TIMEOUTMS = 1,
    MAX_RETRY_TIME = 11,
    TIMEOUTMS_CREATE_SHELL = 12,
    TIMEOUTMS_RUN_SHELL_COMMAND = 13,
    TIMEOUTMS_RECEIVE_SHELL_OUTPUT = 14,
    TIMEOUTMS_SEND_SHELL_INPUT = 15,
    TIMEOUTMS_SIGNAL_SHELL = 16,
    TIMEOUTMS_CLOSE_SHELL = 17,
    SKIP_CA_CHECK = 18,
    SKIP_CN_CHECK = 19,
    UNENCRYPTED_MESSAGES = 20,
    UTF16 = 21,
    ENABLE_SPN_SERVER_PORT = 22,
    MACHINE_ID = 23,
    LOCALE = 25,
    UI_LANGUAGE = 26,
    MAX_ENVELOPE_SIZE_KB = 28,
    SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = 29,
    REDIRECT_LOCATION = 30,
    SKIP_REVOCATION_CHECK = 31,
    ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = 32,
    USE_SSL = 33,
    USE_INTEARACTIVE_TOKEN = 34,
};
pub const WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS = WSManSessionOption.DEFAULT_OPERATION_TIMEOUTMS;
pub const WSMAN_OPTION_MAX_RETRY_TIME = WSManSessionOption.MAX_RETRY_TIME;
pub const WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL = WSManSessionOption.TIMEOUTMS_CREATE_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND = WSManSessionOption.TIMEOUTMS_RUN_SHELL_COMMAND;
pub const WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT = WSManSessionOption.TIMEOUTMS_RECEIVE_SHELL_OUTPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT = WSManSessionOption.TIMEOUTMS_SEND_SHELL_INPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL = WSManSessionOption.TIMEOUTMS_SIGNAL_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL = WSManSessionOption.TIMEOUTMS_CLOSE_SHELL;
pub const WSMAN_OPTION_SKIP_CA_CHECK = WSManSessionOption.SKIP_CA_CHECK;
pub const WSMAN_OPTION_SKIP_CN_CHECK = WSManSessionOption.SKIP_CN_CHECK;
pub const WSMAN_OPTION_UNENCRYPTED_MESSAGES = WSManSessionOption.UNENCRYPTED_MESSAGES;
pub const WSMAN_OPTION_UTF16 = WSManSessionOption.UTF16;
pub const WSMAN_OPTION_ENABLE_SPN_SERVER_PORT = WSManSessionOption.ENABLE_SPN_SERVER_PORT;
pub const WSMAN_OPTION_MACHINE_ID = WSManSessionOption.MACHINE_ID;
pub const WSMAN_OPTION_LOCALE = WSManSessionOption.LOCALE;
pub const WSMAN_OPTION_UI_LANGUAGE = WSManSessionOption.UI_LANGUAGE;
pub const WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB = WSManSessionOption.MAX_ENVELOPE_SIZE_KB;
pub const WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = WSManSessionOption.SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB;
pub const WSMAN_OPTION_REDIRECT_LOCATION = WSManSessionOption.REDIRECT_LOCATION;
pub const WSMAN_OPTION_SKIP_REVOCATION_CHECK = WSManSessionOption.SKIP_REVOCATION_CHECK;
pub const WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = WSManSessionOption.ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS;
pub const WSMAN_OPTION_USE_SSL = WSManSessionOption.USE_SSL;
pub const WSMAN_OPTION_USE_INTEARACTIVE_TOKEN = WSManSessionOption.USE_INTEARACTIVE_TOKEN;

pub const WSMAN_OPERATION = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSManCallbackFlags = enum(i32) {
    END_OF_OPERATION = 1,
    END_OF_STREAM = 8,
    SHELL_SUPPORTS_DISCONNECT = 32,
    SHELL_AUTODISCONNECTED = 64,
    NETWORK_FAILURE_DETECTED = 256,
    RETRYING_AFTER_NETWORK_FAILURE = 512,
    RECONNECTED_AFTER_NETWORK_FAILURE = 1024,
    SHELL_AUTODISCONNECTING = 2048,
    RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = 4096,
    RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = 8192,
};
pub const WSMAN_FLAG_CALLBACK_END_OF_OPERATION = WSManCallbackFlags.END_OF_OPERATION;
pub const WSMAN_FLAG_CALLBACK_END_OF_STREAM = WSManCallbackFlags.END_OF_STREAM;
pub const WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT = WSManCallbackFlags.SHELL_SUPPORTS_DISCONNECT;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED = WSManCallbackFlags.SHELL_AUTODISCONNECTED;
pub const WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED = WSManCallbackFlags.NETWORK_FAILURE_DETECTED;
pub const WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE = WSManCallbackFlags.RETRYING_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE = WSManCallbackFlags.RECONNECTED_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING = WSManCallbackFlags.SHELL_AUTODISCONNECTING;
pub const WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = WSManCallbackFlags.RETRY_ABORTED_DUE_TO_INTERNAL_ERROR;
pub const WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = WSManCallbackFlags.RECEIVE_DELAY_STREAM_REQUEST_PROCESSED;

pub const WSMAN_SHELL = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_COMMAND = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const WSMAN_STREAM_ID_SET = extern struct {
    streamIDsCount: u32,
    streamIDs: ?*?PWSTR,
};

pub const WSMAN_ENVIRONMENT_VARIABLE = extern struct {
    name: ?[*:0]const u16,
    value: ?[*:0]const u16,
};

pub const WSMAN_ENVIRONMENT_VARIABLE_SET = extern struct {
    varsCount: u32,
    vars: ?*WSMAN_ENVIRONMENT_VARIABLE,
};

pub const WSMAN_SHELL_STARTUP_INFO_V10 = extern struct {
    inputStreamSet: ?*WSMAN_STREAM_ID_SET,
    outputStreamSet: ?*WSMAN_STREAM_ID_SET,
    idleTimeoutMs: u32,
    workingDirectory: ?[*:0]const u16,
    variableSet: ?*WSMAN_ENVIRONMENT_VARIABLE_SET,
};

pub const WSMAN_SHELL_STARTUP_INFO_V11 = extern struct {
    __AnonymousBase_wsman_L665_C48: WSMAN_SHELL_STARTUP_INFO_V10,
    name: ?[*:0]const u16,
};

pub const WSMAN_SHELL_DISCONNECT_INFO = extern struct {
    idleTimeoutMs: u32,
};

pub const WSManShellFlag = enum(i32) {
    NO_COMPRESSION = 1,
    DELETE_SERVER_SESSION = 2,
    SERVER_BUFFERING_MODE_DROP = 4,
    SERVER_BUFFERING_MODE_BLOCK = 8,
    RECEIVE_DELAY_OUTPUT_STREAM = 16,
};
pub const WSMAN_FLAG_NO_COMPRESSION = WSManShellFlag.NO_COMPRESSION;
pub const WSMAN_FLAG_DELETE_SERVER_SESSION = WSManShellFlag.DELETE_SERVER_SESSION;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP = WSManShellFlag.SERVER_BUFFERING_MODE_DROP;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK = WSManShellFlag.SERVER_BUFFERING_MODE_BLOCK;
pub const WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM = WSManShellFlag.RECEIVE_DELAY_OUTPUT_STREAM;

pub const WSMAN_RECEIVE_DATA_RESULT = extern struct {
    streamId: ?[*:0]const u16,
    streamData: WSMAN_DATA,
    commandState: ?[*:0]const u16,
    exitCode: u32,
};

pub const WSMAN_CONNECT_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_CREATE_SHELL_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_RESPONSE_DATA = extern union {
    receiveData: WSMAN_RECEIVE_DATA_RESULT,
    connectData: WSMAN_CONNECT_DATA,
    createData: WSMAN_CREATE_SHELL_DATA,
};

pub const WSMAN_SHELL_COMPLETION_FUNCTION = *const fn(
    operationContext: ?*anyopaque,
    flags: u32,
    @"error": ?*WSMAN_ERROR,
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    operationHandle: ?*WSMAN_OPERATION,
    data: ?*WSMAN_RESPONSE_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_SHELL_ASYNC = extern struct {
    operationContext: ?*anyopaque,
    completionFunction: ?WSMAN_SHELL_COMPLETION_FUNCTION,
};

pub const WSMAN_COMMAND_ARG_SET = extern struct {
    argsCount: u32,
    args: ?*?PWSTR,
};

pub const WSMAN_CERTIFICATE_DETAILS = extern struct {
    subject: ?[*:0]const u16,
    issuerName: ?[*:0]const u16,
    issuerThumbprint: ?[*:0]const u16,
    subjectName: ?[*:0]const u16,
};

pub const WSMAN_SENDER_DETAILS = extern struct {
    senderName: ?[*:0]const u16,
    authenticationMechanism: ?[*:0]const u16,
    certificateDetails: ?*WSMAN_CERTIFICATE_DETAILS,
    clientToken: ?HANDLE,
    httpURL: ?[*:0]const u16,
};

pub const WSMAN_PLUGIN_REQUEST = extern struct {
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    locale: ?[*:0]const u16,
    resourceUri: ?[*:0]const u16,
    operationInfo: ?*WSMAN_OPERATION_INFO,
    shutdownNotification: i32,
    shutdownNotificationHandle: ?HANDLE,
    dataLocale: ?[*:0]const u16,
};

pub const WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT = *const fn(
    shellContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT = *const fn(
    shellContext: ?*anyopaque,
    commandContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_STARTUP = *const fn(
    flags: u32,
    applicationIdentification: ?[*:0]const u16,
    extraInfo: ?[*:0]const u16,
    pluginContext: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHUTDOWN = *const fn(
    pluginContext: ?*anyopaque,
    flags: u32,
    reason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHELL = *const fn(
    pluginContext: ?*anyopaque,
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    inboundShellInformation: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_COMMAND = *const fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*anyopaque,
    commandLine: ?[*:0]const u16,
    arguments: ?*WSMAN_COMMAND_ARG_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SEND = *const fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*anyopaque,
    commandContext: ?*anyopaque,
    stream: ?[*:0]const u16,
    inboundData: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RECEIVE = *const fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*anyopaque,
    commandContext: ?*anyopaque,
    streamSet: ?*WSMAN_STREAM_ID_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SIGNAL = *const fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*anyopaque,
    commandContext: ?*anyopaque,
    code: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_CONNECT = *const fn(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: ?*anyopaque,
    commandContext: ?*anyopaque,
    inboundConnectInformation: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_AUTHZ_QUOTA = extern struct {
    maxAllowedConcurrentShells: u32,
    maxAllowedConcurrentOperations: u32,
    timeslotSize: u32,
    maxAllowedOperationsPerTimeslot: u32,
};

pub const WSMAN_PLUGIN_AUTHORIZE_USER = *const fn(
    pluginContext: ?*anyopaque,
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_OPERATION = *const fn(
    pluginContext: ?*anyopaque,
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    operation: u32,
    action: ?[*:0]const u16,
    resourceUri: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA = *const fn(
    pluginContext: ?*anyopaque,
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT = *const fn(
    userAuthorizationContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_WSMan_Value = Guid.initString("bced617b-ec03-420b-8508-977dc7a686bd");
pub const CLSID_WSMan = &CLSID_WSMan_Value;

const CLSID_WSManInternal_Value = Guid.initString("7de087a5-5dcb-4df7-bb12-0924ad8fbd9a");
pub const CLSID_WSManInternal = &CLSID_WSManInternal_Value;

pub const WSManSessionFlags = enum(i32) {
    UTF8 = 1,
    CredUsernamePassword = 4096,
    SkipCACheck = 8192,
    SkipCNCheck = 16384,
    UseNoAuthentication = 32768,
    UseDigest = 65536,
    UseNegotiate = 131072,
    UseBasic = 262144,
    UseKerberos = 524288,
    NoEncryption = 1048576,
    UseClientCertificate = 2097152,
    EnableSPNServerPort = 4194304,
    UTF16 = 8388608,
    UseCredSsp = 16777216,
    SkipRevocationCheck = 33554432,
    AllowNegotiateImplicitCredentials = 67108864,
    UseSsl = 134217728,
};
pub const WSManFlagUTF8 = WSManSessionFlags.UTF8;
pub const WSManFlagCredUsernamePassword = WSManSessionFlags.CredUsernamePassword;
pub const WSManFlagSkipCACheck = WSManSessionFlags.SkipCACheck;
pub const WSManFlagSkipCNCheck = WSManSessionFlags.SkipCNCheck;
pub const WSManFlagUseNoAuthentication = WSManSessionFlags.UseNoAuthentication;
pub const WSManFlagUseDigest = WSManSessionFlags.UseDigest;
pub const WSManFlagUseNegotiate = WSManSessionFlags.UseNegotiate;
pub const WSManFlagUseBasic = WSManSessionFlags.UseBasic;
pub const WSManFlagUseKerberos = WSManSessionFlags.UseKerberos;
pub const WSManFlagNoEncryption = WSManSessionFlags.NoEncryption;
pub const WSManFlagUseClientCertificate = WSManSessionFlags.UseClientCertificate;
pub const WSManFlagEnableSPNServerPort = WSManSessionFlags.EnableSPNServerPort;
pub const WSManFlagUTF16 = WSManSessionFlags.UTF16;
pub const WSManFlagUseCredSsp = WSManSessionFlags.UseCredSsp;
pub const WSManFlagSkipRevocationCheck = WSManSessionFlags.SkipRevocationCheck;
pub const WSManFlagAllowNegotiateImplicitCredentials = WSManSessionFlags.AllowNegotiateImplicitCredentials;
pub const WSManFlagUseSsl = WSManSessionFlags.UseSsl;

pub const WSManEnumFlags = enum(i32) {
    NonXmlText = 1,
    ReturnObject = 0,
    ReturnEPR = 2,
    ReturnObjectAndEPR = 4,
    HierarchyShallow = 32,
    HierarchyDeepBasePropsOnly = 64,
    AssociationInstance = 128,
    pub const HierarchyDeep = .ReturnObject;
    pub const AssociatedInstance = .ReturnObject;
};
pub const WSManFlagNonXmlText = WSManEnumFlags.NonXmlText;
pub const WSManFlagReturnObject = WSManEnumFlags.ReturnObject;
pub const WSManFlagReturnEPR = WSManEnumFlags.ReturnEPR;
pub const WSManFlagReturnObjectAndEPR = WSManEnumFlags.ReturnObjectAndEPR;
pub const WSManFlagHierarchyDeep = WSManEnumFlags.ReturnObject;
pub const WSManFlagHierarchyShallow = WSManEnumFlags.HierarchyShallow;
pub const WSManFlagHierarchyDeepBasePropsOnly = WSManEnumFlags.HierarchyDeepBasePropsOnly;
pub const WSManFlagAssociatedInstance = WSManEnumFlags.ReturnObject;
pub const WSManFlagAssociationInstance = WSManEnumFlags.AssociationInstance;

pub const WSManProxyAccessTypeFlags = enum(i32) {
    IEConfig = 1,
    WinHttpConfig = 2,
    AutoDetect = 4,
    NoProxyServer = 8,
};
pub const WSManProxyIEConfig = WSManProxyAccessTypeFlags.IEConfig;
pub const WSManProxyWinHttpConfig = WSManProxyAccessTypeFlags.WinHttpConfig;
pub const WSManProxyAutoDetect = WSManProxyAccessTypeFlags.AutoDetect;
pub const WSManProxyNoProxyServer = WSManProxyAccessTypeFlags.NoProxyServer;

pub const WSManProxyAuthenticationFlags = enum(i32) {
    Negotiate = 1,
    Basic = 2,
    Digest = 4,
};
pub const WSManFlagProxyAuthenticationUseNegotiate = WSManProxyAuthenticationFlags.Negotiate;
pub const WSManFlagProxyAuthenticationUseBasic = WSManProxyAuthenticationFlags.Basic;
pub const WSManFlagProxyAuthenticationUseDigest = WSManProxyAuthenticationFlags.Digest;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSMan_Value = Guid.initString("190d8637-5cd3-496d-ad24-69636bb5a3b5");
pub const IID_IWSMan = &IID_IWSMan_Value;
pub const IWSMan = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateSession: *const fn(
            self: *const IWSMan,
            connection: ?BSTR,
            flags: i32,
            connectionOptions: ?*IDispatch,
            session: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateConnectionOptions: *const fn(
            self: *const IWSMan,
            connectionOptions: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CommandLine: *const fn(
            self: *const IWSMan,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn(
            self: *const IWSMan,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn CreateSession(self: *const IWSMan, connection: ?BSTR, flags: i32, connectionOptions: ?*IDispatch, session: ?*?*IDispatch) callconv(.Inline) HRESULT {
        return self.vtable.CreateSession(self, connection, flags, connectionOptions, session);
    }
    pub fn CreateConnectionOptions(self: *const IWSMan, connectionOptions: ?*?*IDispatch) callconv(.Inline) HRESULT {
        return self.vtable.CreateConnectionOptions(self, connectionOptions);
    }
    pub fn get_CommandLine(self: *const IWSMan, value: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_CommandLine(self, value);
    }
    pub fn get_Error(self: *const IWSMan, value: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Error(self, value);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEx_Value = Guid.initString("2d53bdaa-798e-49e6-a1aa-74d01256f411");
pub const IID_IWSManEx = &IID_IWSManEx_Value;
pub const IWSManEx = extern union {
    pub const VTable = extern struct {
        base: IWSMan.VTable,
        CreateResourceLocator: *const fn(
            self: *const IWSManEx,
            strResourceLocator: ?BSTR,
            newResourceLocator: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUTF8: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagCredUsernamePassword: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCACheck: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCNCheck: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseDigest: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNegotiate: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseBasic: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseKerberos: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagNoEncryption: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagEnableSPNServerPort: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNoAuthentication: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagNonXmlText: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnEPR: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObjectAndEPR: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorMessage: *const fn(
            self: *const IWSManEx,
            errorNumber: u32,
            errorMessage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeep: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyShallow: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeepBasePropsOnly: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObject: *const fn(
            self: *const IWSManEx,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IWSMan: IWSMan,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn CreateResourceLocator(self: *const IWSManEx, strResourceLocator: ?BSTR, newResourceLocator: ?*?*IDispatch) callconv(.Inline) HRESULT {
        return self.vtable.CreateResourceLocator(self, strResourceLocator, newResourceLocator);
    }
    pub fn SessionFlagUTF8(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUTF8(self, flags);
    }
    pub fn SessionFlagCredUsernamePassword(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagCredUsernamePassword(self, flags);
    }
    pub fn SessionFlagSkipCACheck(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagSkipCACheck(self, flags);
    }
    pub fn SessionFlagSkipCNCheck(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagSkipCNCheck(self, flags);
    }
    pub fn SessionFlagUseDigest(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseDigest(self, flags);
    }
    pub fn SessionFlagUseNegotiate(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseNegotiate(self, flags);
    }
    pub fn SessionFlagUseBasic(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseBasic(self, flags);
    }
    pub fn SessionFlagUseKerberos(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseKerberos(self, flags);
    }
    pub fn SessionFlagNoEncryption(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagNoEncryption(self, flags);
    }
    pub fn SessionFlagEnableSPNServerPort(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagEnableSPNServerPort(self, flags);
    }
    pub fn SessionFlagUseNoAuthentication(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseNoAuthentication(self, flags);
    }
    pub fn EnumerationFlagNonXmlText(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagNonXmlText(self, flags);
    }
    pub fn EnumerationFlagReturnEPR(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagReturnEPR(self, flags);
    }
    pub fn EnumerationFlagReturnObjectAndEPR(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagReturnObjectAndEPR(self, flags);
    }
    pub fn GetErrorMessage(self: *const IWSManEx, errorNumber: u32, errorMessage: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.GetErrorMessage(self, errorNumber, errorMessage);
    }
    pub fn EnumerationFlagHierarchyDeep(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagHierarchyDeep(self, flags);
    }
    pub fn EnumerationFlagHierarchyShallow(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagHierarchyShallow(self, flags);
    }
    pub fn EnumerationFlagHierarchyDeepBasePropsOnly(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagHierarchyDeepBasePropsOnly(self, flags);
    }
    pub fn EnumerationFlagReturnObject(self: *const IWSManEx, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagReturnObject(self, flags);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEx2_Value = Guid.initString("1d1b5ae0-42d9-4021-8261-3987619512e9");
pub const IID_IWSManEx2 = &IID_IWSManEx2_Value;
pub const IWSManEx2 = extern union {
    pub const VTable = extern struct {
        base: IWSManEx.VTable,
        SessionFlagUseClientCertificate: *const fn(
            self: *const IWSManEx2,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IWSManEx: IWSManEx,
    IWSMan: IWSMan,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn SessionFlagUseClientCertificate(self: *const IWSManEx2, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseClientCertificate(self, flags);
    }
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWSManEx3_Value = Guid.initString("6400e966-011d-4eac-8474-049e0848afad");
pub const IID_IWSManEx3 = &IID_IWSManEx3_Value;
pub const IWSManEx3 = extern union {
    pub const VTable = extern struct {
        base: IWSManEx2.VTable,
        SessionFlagUTF16: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseCredSsp: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociationInstance: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociatedInstance: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipRevocationCheck: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagAllowNegotiateImplicitCredentials: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseSsl: *const fn(
            self: *const IWSManEx3,
            flags: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IWSManEx2: IWSManEx2,
    IWSManEx: IWSManEx,
    IWSMan: IWSMan,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn SessionFlagUTF16(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUTF16(self, flags);
    }
    pub fn SessionFlagUseCredSsp(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseCredSsp(self, flags);
    }
    pub fn EnumerationFlagAssociationInstance(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagAssociationInstance(self, flags);
    }
    pub fn EnumerationFlagAssociatedInstance(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.EnumerationFlagAssociatedInstance(self, flags);
    }
    pub fn SessionFlagSkipRevocationCheck(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagSkipRevocationCheck(self, flags);
    }
    pub fn SessionFlagAllowNegotiateImplicitCredentials(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagAllowNegotiateImplicitCredentials(self, flags);
    }
    pub fn SessionFlagUseSsl(self: *const IWSManEx3, flags: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SessionFlagUseSsl(self, flags);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManConnectionOptions_Value = Guid.initString("f704e861-9e52-464f-b786-da5eb2320fdd");
pub const IID_IWSManConnectionOptions = &IID_IWSManConnectionOptions_Value;
pub const IWSManConnectionOptions = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserName: *const fn(
            self: *const IWSManConnectionOptions,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UserName: *const fn(
            self: *const IWSManConnectionOptions,
            name: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Password: *const fn(
            self: *const IWSManConnectionOptions,
            password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_UserName(self: *const IWSManConnectionOptions, name: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_UserName(self, name);
    }
    pub fn put_UserName(self: *const IWSManConnectionOptions, name: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_UserName(self, name);
    }
    pub fn put_Password(self: *const IWSManConnectionOptions, password: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_Password(self, password);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManConnectionOptionsEx_Value = Guid.initString("ef43edf7-2a48-4d93-9526-8bd6ab6d4a6b");
pub const IID_IWSManConnectionOptionsEx = &IID_IWSManConnectionOptionsEx_Value;
pub const IWSManConnectionOptionsEx = extern union {
    pub const VTable = extern struct {
        base: IWSManConnectionOptions.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CertificateThumbprint: *const fn(
            self: *const IWSManConnectionOptionsEx,
            thumbprint: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CertificateThumbprint: *const fn(
            self: *const IWSManConnectionOptionsEx,
            thumbprint: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IWSManConnectionOptions: IWSManConnectionOptions,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_CertificateThumbprint(self: *const IWSManConnectionOptionsEx, thumbprint: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_CertificateThumbprint(self, thumbprint);
    }
    pub fn put_CertificateThumbprint(self: *const IWSManConnectionOptionsEx, thumbprint: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_CertificateThumbprint(self, thumbprint);
    }
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IWSManConnectionOptionsEx2_Value = Guid.initString("f500c9ec-24ee-48ab-b38d-fc9a164c658e");
pub const IID_IWSManConnectionOptionsEx2 = &IID_IWSManConnectionOptionsEx2_Value;
pub const IWSManConnectionOptionsEx2 = extern union {
    pub const VTable = extern struct {
        base: IWSManConnectionOptionsEx.VTable,
        SetProxy: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            accessType: i32,
            authenticationMechanism: i32,
            userName: ?BSTR,
            password: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyIEConfig: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyWinHttpConfig: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAutoDetect: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyNoProxyServer: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseNegotiate: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseBasic: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseDigest: *const fn(
            self: *const IWSManConnectionOptionsEx2,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IWSManConnectionOptionsEx: IWSManConnectionOptionsEx,
    IWSManConnectionOptions: IWSManConnectionOptions,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn SetProxy(self: *const IWSManConnectionOptionsEx2, accessType: i32, authenticationMechanism: i32, userName: ?BSTR, password: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.SetProxy(self, accessType, authenticationMechanism, userName, password);
    }
    pub fn ProxyIEConfig(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyIEConfig(self, value);
    }
    pub fn ProxyWinHttpConfig(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyWinHttpConfig(self, value);
    }
    pub fn ProxyAutoDetect(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyAutoDetect(self, value);
    }
    pub fn ProxyNoProxyServer(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyNoProxyServer(self, value);
    }
    pub fn ProxyAuthenticationUseNegotiate(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyAuthenticationUseNegotiate(self, value);
    }
    pub fn ProxyAuthenticationUseBasic(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyAuthenticationUseBasic(self, value);
    }
    pub fn ProxyAuthenticationUseDigest(self: *const IWSManConnectionOptionsEx2, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.ProxyAuthenticationUseDigest(self, value);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManSession_Value = Guid.initString("fc84fc58-1286-40c4-9da0-c8ef6ec241e0");
pub const IID_IWSManSession = &IID_IWSManSession_Value;
pub const IWSManSession = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Get: *const fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            flags: i32,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Put: *const fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            resource: ?BSTR,
            flags: i32,
            resultResource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: *const fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            resource: ?BSTR,
            flags: i32,
            newUri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: *const fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: *const fn(
            self: *const IWSManSession,
            actionUri: ?BSTR,
            resourceUri: VARIANT,
            parameters: ?BSTR,
            flags: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enumerate: *const fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            filter: ?BSTR,
            dialect: ?BSTR,
            flags: i32,
            resultSet: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Identify: *const fn(
            self: *const IWSManSession,
            flags: i32,
            result: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn(
            self: *const IWSManSession,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BatchItems: *const fn(
            self: *const IWSManSession,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BatchItems: *const fn(
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Timeout: *const fn(
            self: *const IWSManSession,
            value: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Timeout: *const fn(
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn Get(self: *const IWSManSession, resourceUri: VARIANT, flags: i32, resource: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Get(self, resourceUri, flags, resource);
    }
    pub fn Put(self: *const IWSManSession, resourceUri: VARIANT, resource: ?BSTR, flags: i32, resultResource: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Put(self, resourceUri, resource, flags, resultResource);
    }
    pub fn Create(self: *const IWSManSession, resourceUri: VARIANT, resource: ?BSTR, flags: i32, newUri: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Create(self, resourceUri, resource, flags, newUri);
    }
    pub fn Delete(self: *const IWSManSession, resourceUri: VARIANT, flags: i32) callconv(.Inline) HRESULT {
        return self.vtable.Delete(self, resourceUri, flags);
    }
    pub fn Invoke(self: *const IWSManSession, actionUri: ?BSTR, resourceUri: VARIANT, parameters: ?BSTR, flags: i32, result: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Invoke(self, actionUri, resourceUri, parameters, flags, result);
    }
    pub fn Enumerate(self: *const IWSManSession, resourceUri: VARIANT, filter: ?BSTR, dialect: ?BSTR, flags: i32, resultSet: ?*?*IDispatch) callconv(.Inline) HRESULT {
        return self.vtable.Enumerate(self, resourceUri, filter, dialect, flags, resultSet);
    }
    pub fn Identify(self: *const IWSManSession, flags: i32, result: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Identify(self, flags, result);
    }
    pub fn get_Error(self: *const IWSManSession, value: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Error(self, value);
    }
    pub fn get_BatchItems(self: *const IWSManSession, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_BatchItems(self, value);
    }
    pub fn put_BatchItems(self: *const IWSManSession, value: i32) callconv(.Inline) HRESULT {
        return self.vtable.put_BatchItems(self, value);
    }
    pub fn get_Timeout(self: *const IWSManSession, value: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_Timeout(self, value);
    }
    pub fn put_Timeout(self: *const IWSManSession, value: i32) callconv(.Inline) HRESULT {
        return self.vtable.put_Timeout(self, value);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManEnumerator_Value = Guid.initString("f3457ca9-abb9-4fa5-b850-90e8ca300e7f");
pub const IID_IWSManEnumerator = &IID_IWSManEnumerator_Value;
pub const IWSManEnumerator = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ReadItem: *const fn(
            self: *const IWSManEnumerator,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AtEndOfStream: *const fn(
            self: *const IWSManEnumerator,
            eos: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn(
            self: *const IWSManEnumerator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn ReadItem(self: *const IWSManEnumerator, resource: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ReadItem(self, resource);
    }
    pub fn get_AtEndOfStream(self: *const IWSManEnumerator, eos: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.get_AtEndOfStream(self, eos);
    }
    pub fn get_Error(self: *const IWSManEnumerator, value: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Error(self, value);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IWSManResourceLocator_Value = Guid.initString("a7a1ba28-de41-466a-ad0a-c4059ead7428");
pub const IID_IWSManResourceLocator = &IID_IWSManResourceLocator_Value;
pub const IWSManResourceLocator = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ResourceURI: *const fn(
            self: *const IWSManResourceLocator,
            uri: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ResourceURI: *const fn(
            self: *const IWSManResourceLocator,
            uri: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSelector: *const fn(
            self: *const IWSManResourceLocator,
            resourceSelName: ?BSTR,
            selValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearSelectors: *const fn(
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentPath: *const fn(
            self: *const IWSManResourceLocator,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FragmentPath: *const fn(
            self: *const IWSManResourceLocator,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FragmentDialect: *const fn(
            self: *const IWSManResourceLocator,
            text: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FragmentDialect: *const fn(
            self: *const IWSManResourceLocator,
            text: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddOption: *const fn(
            self: *const IWSManResourceLocator,
            OptionName: ?BSTR,
            OptionValue: VARIANT,
            mustComply: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MustUnderstandOptions: *const fn(
            self: *const IWSManResourceLocator,
            mustUnderstand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MustUnderstandOptions: *const fn(
            self: *const IWSManResourceLocator,
            mustUnderstand: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearOptions: *const fn(
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Error: *const fn(
            self: *const IWSManResourceLocator,
            value: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn put_ResourceURI(self: *const IWSManResourceLocator, uri: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_ResourceURI(self, uri);
    }
    pub fn get_ResourceURI(self: *const IWSManResourceLocator, uri: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ResourceURI(self, uri);
    }
    pub fn AddSelector(self: *const IWSManResourceLocator, resourceSelName: ?BSTR, selValue: VARIANT) callconv(.Inline) HRESULT {
        return self.vtable.AddSelector(self, resourceSelName, selValue);
    }
    pub fn ClearSelectors(self: *const IWSManResourceLocator) callconv(.Inline) HRESULT {
        return self.vtable.ClearSelectors(self);
    }
    pub fn get_FragmentPath(self: *const IWSManResourceLocator, text: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_FragmentPath(self, text);
    }
    pub fn put_FragmentPath(self: *const IWSManResourceLocator, text: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_FragmentPath(self, text);
    }
    pub fn get_FragmentDialect(self: *const IWSManResourceLocator, text: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_FragmentDialect(self, text);
    }
    pub fn put_FragmentDialect(self: *const IWSManResourceLocator, text: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.put_FragmentDialect(self, text);
    }
    pub fn AddOption(self: *const IWSManResourceLocator, OptionName: ?BSTR, OptionValue: VARIANT, mustComply: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.AddOption(self, OptionName, OptionValue, mustComply);
    }
    pub fn put_MustUnderstandOptions(self: *const IWSManResourceLocator, mustUnderstand: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.put_MustUnderstandOptions(self, mustUnderstand);
    }
    pub fn get_MustUnderstandOptions(self: *const IWSManResourceLocator, mustUnderstand: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_MustUnderstandOptions(self, mustUnderstand);
    }
    pub fn ClearOptions(self: *const IWSManResourceLocator) callconv(.Inline) HRESULT {
        return self.vtable.ClearOptions(self);
    }
    pub fn get_Error(self: *const IWSManResourceLocator, value: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Error(self, value);
    }
};

const IID_IWSManResourceLocatorInternal_Value = Guid.initString("effaead7-7ec8-4716-b9be-f2e7e9fb4adb");
pub const IID_IWSManResourceLocatorInternal = &IID_IWSManResourceLocatorInternal_Value;
pub const IWSManResourceLocatorInternal = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
};

const IID_IWSManInternal_Value = Guid.initString("04ae2b1d-9954-4d99-94a9-a961e72c3a13");
pub const IID_IWSManInternal = &IID_IWSManInternal_Value;
pub const IWSManInternal = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConfigSDDL: *const fn(
            self: *const IWSManInternal,
            session: ?*IDispatch,
            resourceUri: VARIANT,
            flags: i32,
            resource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn ConfigSDDL(self: *const IWSManInternal, session: ?*IDispatch, resourceUri: VARIANT, flags: i32, resource: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ConfigSDDL(self, session, resourceUri, flags, resource);
    }
};


//--------------------------------------------------------------------------------
// Section: Functions (33)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManInitialize(
    flags: u32,
    apiHandle: ?*?*WSMAN_API,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManDeinitialize(
    apiHandle: ?*WSMAN_API,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManGetErrorMessage(
    apiHandle: ?*WSMAN_API,
    flags: u32,
    languageCode: ?[*:0]const u16,
    errorCode: u32,
    messageLength: u32,
    message: ?[*:0]u16,
    messageLengthUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCreateSession(
    apiHandle: ?*WSMAN_API,
    connection: ?[*:0]const u16,
    flags: u32,
    serverAuthenticationCredentials: ?*WSMAN_AUTHENTICATION_CREDENTIALS,
    proxyInfo: ?*WSMAN_PROXY_INFO,
    session: ?*?*WSMAN_SESSION,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseSession(
    session: ?*WSMAN_SESSION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManSetSessionOption(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManGetSessionOptionAsDword(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManGetSessionOptionAsString(
    session: ?*WSMAN_SESSION,
    option: WSManSessionOption,
    stringLength: u32,
    string: ?[*:0]u16,
    stringLengthUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseOperation(
    operationHandle: ?*WSMAN_OPERATION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCreateShell(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resourceUri: ?[*:0]const u16,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    createXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManRunShellCommand(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    commandLine: ?[*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManSignalShell(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    code: ?[*:0]const u16,
    @"async": ?*WSMAN_SHELL_ASYNC,
    signalOperation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManReceiveShellOutput(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    desiredStreamSet: ?*WSMAN_STREAM_ID_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    receiveOperation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManSendShellInput(
    shell: ?*WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    streamId: ?[*:0]const u16,
    streamData: ?*WSMAN_DATA,
    endOfStream: BOOL,
    @"async": ?*WSMAN_SHELL_ASYNC,
    sendOperation: ?*?*WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseCommand(
    commandHandle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManCloseShell(
    shellHandle: ?*WSMAN_SHELL,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManCreateShellEx(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resourceUri: ?[*:0]const u16,
    shellId: ?[*:0]const u16,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    createXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManRunShellCommandEx(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    commandId: ?[*:0]const u16,
    commandLine: ?[*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManDisconnectShell(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    disconnectInfo: ?*WSMAN_SHELL_DISCONNECT_INFO,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManReconnectShell(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManReconnectShellCommand(
    commandHandle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": ?*WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManConnectShell(
    session: ?*WSMAN_SESSION,
    flags: u32,
    resourceUri: ?[*:0]const u16,
    shellID: ?[*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connectXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    shell: ?*?*WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "wsmsvc" fn WSManConnectShellCommand(
    shell: ?*WSMAN_SHELL,
    flags: u32,
    commandID: ?[*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connectXml: ?*WSMAN_DATA,
    @"async": ?*WSMAN_SHELL_ASYNC,
    command: ?*?*WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginReportContext(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginReceiveResult(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    stream: ?[*:0]const u16,
    streamResult: ?*WSMAN_DATA,
    commandState: ?[*:0]const u16,
    exitCode: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginOperationComplete(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    errorCode: u32,
    extendedInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginGetOperationParameters(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
    flags: u32,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wsmsvc" fn WSManPluginGetConfiguration(
    pluginContext: ?*anyopaque,
    flags: u32,
    data: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "wsmsvc" fn WSManPluginReportCompletion(
    pluginContext: ?*anyopaque,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginFreeRequestDetails(
    requestDetails: ?*WSMAN_PLUGIN_REQUEST,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginAuthzUserComplete(
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    userAuthorizationContext: ?*anyopaque,
    impersonationToken: ?HANDLE,
    userIsAdministrator: BOOL,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginAuthzOperationComplete(
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    userAuthorizationContext: ?*anyopaque,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "wsmsvc" fn WSManPluginAuthzQueryQuotaComplete(
    senderDetails: ?*WSMAN_SENDER_DETAILS,
    flags: u32,
    quota: ?*WSMAN_AUTHZ_QUOTA,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HANDLE = @import("../foundation.zig").HANDLE;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PWSTR = @import("../foundation.zig").PWSTR;
const VARIANT = @import("../system/com.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "WSMAN_SHELL_COMPLETION_FUNCTION")) { _ = WSMAN_SHELL_COMPLETION_FUNCTION; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT")) { _ = WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT")) { _ = WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_STARTUP")) { _ = WSMAN_PLUGIN_STARTUP; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SHUTDOWN")) { _ = WSMAN_PLUGIN_SHUTDOWN; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SHELL")) { _ = WSMAN_PLUGIN_SHELL; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_COMMAND")) { _ = WSMAN_PLUGIN_COMMAND; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SEND")) { _ = WSMAN_PLUGIN_SEND; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_RECEIVE")) { _ = WSMAN_PLUGIN_RECEIVE; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_SIGNAL")) { _ = WSMAN_PLUGIN_SIGNAL; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_CONNECT")) { _ = WSMAN_PLUGIN_CONNECT; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_USER")) { _ = WSMAN_PLUGIN_AUTHORIZE_USER; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_OPERATION")) { _ = WSMAN_PLUGIN_AUTHORIZE_OPERATION; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA")) { _ = WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA; }
    if (@hasDecl(@This(), "WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT")) { _ = WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
