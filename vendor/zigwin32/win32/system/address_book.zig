//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (208)
//--------------------------------------------------------------------------------
pub const PROP_ID_SECURE_MIN = @as(u32, 26608);
pub const PROP_ID_SECURE_MAX = @as(u32, 26623);
pub const MAPI_DIM = @as(u32, 1);
pub const MAPI_P1 = @as(u32, 268435456);
pub const MAPI_SUBMITTED = @as(u32, 2147483648);
pub const MAPI_SHORTTERM = @as(u32, 128);
pub const MAPI_NOTRECIP = @as(u32, 64);
pub const MAPI_THISSESSION = @as(u32, 32);
pub const MAPI_NOW = @as(u32, 16);
pub const MAPI_NOTRESERVED = @as(u32, 8);
pub const MAPI_COMPOUND = @as(u32, 128);
pub const MV_FLAG = @as(u32, 4096);
pub const PROP_ID_NULL = @as(u32, 0);
pub const PROP_ID_INVALID = @as(u32, 65535);
pub const MV_INSTANCE = @as(u32, 8192);
pub const TABLE_CHANGED = @as(u32, 1);
pub const TABLE_ERROR = @as(u32, 2);
pub const TABLE_ROW_ADDED = @as(u32, 3);
pub const TABLE_ROW_DELETED = @as(u32, 4);
pub const TABLE_ROW_MODIFIED = @as(u32, 5);
pub const TABLE_SORT_DONE = @as(u32, 6);
pub const TABLE_RESTRICT_DONE = @as(u32, 7);
pub const TABLE_SETCOL_DONE = @as(u32, 8);
pub const TABLE_RELOAD = @as(u32, 9);
pub const MAPI_ERROR_VERSION = @as(i32, 0);
pub const MAPI_USE_DEFAULT = @as(u32, 64);
pub const MNID_ID = @as(u32, 0);
pub const MNID_STRING = @as(u32, 1);
pub const WAB_LOCAL_CONTAINERS = @as(u32, 1048576);
pub const WAB_PROFILE_CONTENTS = @as(u32, 2097152);
pub const WAB_IGNORE_PROFILES = @as(u32, 8388608);
pub const MAPI_ONE_OFF_NO_RICH_INFO = @as(u32, 1);
pub const UI_SERVICE = @as(u32, 2);
pub const SERVICE_UI_ALWAYS = @as(u32, 2);
pub const SERVICE_UI_ALLOWED = @as(u32, 16);
pub const UI_CURRENT_PROVIDER_FIRST = @as(u32, 4);
pub const WABOBJECT_LDAPURL_RETURN_MAILUSER = @as(u32, 1);
pub const WABOBJECT_ME_NEW = @as(u32, 1);
pub const WABOBJECT_ME_NOCREATE = @as(u32, 2);
pub const WAB_VCARD_FILE = @as(u32, 0);
pub const WAB_VCARD_STREAM = @as(u32, 1);
pub const WAB_USE_OE_SENDMAIL = @as(u32, 1);
pub const WAB_ENABLE_PROFILES = @as(u32, 4194304);
pub const WAB_DISPLAY_LDAPURL = @as(u32, 1);
pub const WAB_CONTEXT_ADRLIST = @as(u32, 2);
pub const WAB_DISPLAY_ISNTDS = @as(u32, 4);
pub const E_IMAPI_REQUEST_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600702));
pub const E_IMAPI_RECORDER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600701));
pub const S_IMAPI_SPEEDADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141124));
pub const S_IMAPI_ROTATIONADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141125));
pub const S_IMAPI_BOTHADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141126));
pub const E_IMAPI_BURN_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600697));
pub const S_IMAPI_COMMAND_HAS_SENSE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141632));
pub const E_IMAPI_RECORDER_NO_SUCH_MODE_PAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600191));
pub const E_IMAPI_RECORDER_MEDIA_NO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600190));
pub const E_IMAPI_RECORDER_MEDIA_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600189));
pub const E_IMAPI_RECORDER_MEDIA_UPSIDE_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600188));
pub const E_IMAPI_RECORDER_MEDIA_BECOMING_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600187));
pub const E_IMAPI_RECORDER_MEDIA_FORMAT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600186));
pub const E_IMAPI_RECORDER_MEDIA_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600185));
pub const E_IMAPI_RECORDER_INVALID_MODE_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600184));
pub const E_IMAPI_RECORDER_MEDIA_WRITE_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600183));
pub const E_IMAPI_RECORDER_NO_SUCH_FEATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600182));
pub const E_IMAPI_RECORDER_FEATURE_IS_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600181));
pub const E_IMAPI_RECORDER_GET_CONFIGURATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600180));
pub const E_IMAPI_RECORDER_COMMAND_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600179));
pub const E_IMAPI_RECORDER_DVD_STRUCTURE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600178));
pub const E_IMAPI_RECORDER_MEDIA_SPEED_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600177));
pub const E_IMAPI_RECORDER_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600176));
pub const E_IMAPI_RECORDER_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600175));
pub const E_IMAPI_RECORDER_MEDIA_NOT_FORMATTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600174));
pub const E_IMAPI_RECORDER_INVALID_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599937));
pub const E_IMAPI_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599936));
pub const E_IMAPI_UNEXPECTED_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599935));
pub const S_IMAPI_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141890));
pub const E_IMAPI_DF2DATA_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599680));
pub const E_IMAPI_DF2DATA_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599679));
pub const E_IMAPI_DF2DATA_INVALID_MEDIA_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599678));
pub const E_IMAPI_DF2DATA_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599677));
pub const E_IMAPI_DF2DATA_STREAM_TOO_LARGE_FOR_CURRENT_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599676));
pub const E_IMAPI_DF2DATA_MEDIA_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599675));
pub const E_IMAPI_DF2DATA_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599674));
pub const E_IMAPI_DF2DATA_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599673));
pub const E_IMAPI_DF2DATA_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599672));
pub const E_IMAPI_DF2TAO_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599424));
pub const E_IMAPI_DF2TAO_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599423));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599422));
pub const E_IMAPI_DF2TAO_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599421));
pub const E_IMAPI_DF2TAO_PROPERTY_FOR_BLANK_MEDIA_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599420));
pub const E_IMAPI_DF2TAO_TABLE_OF_CONTENTS_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599419));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599418));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599417));
pub const E_IMAPI_DF2TAO_TRACK_LIMIT_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599416));
pub const E_IMAPI_DF2TAO_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599415));
pub const E_IMAPI_DF2TAO_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599414));
pub const E_IMAPI_DF2TAO_INVALID_ISRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599413));
pub const E_IMAPI_DF2TAO_INVALID_MCN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599412));
pub const E_IMAPI_DF2TAO_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599411));
pub const E_IMAPI_DF2TAO_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599410));
pub const E_IMAPI_DF2TAO_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599409));
pub const E_IMAPI_DF2RAW_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599168));
pub const E_IMAPI_DF2RAW_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599167));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599166));
pub const E_IMAPI_DF2RAW_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599165));
pub const E_IMAPI_DF2RAW_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599164));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599162));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599161));
pub const E_IMAPI_DF2RAW_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599159));
pub const E_IMAPI_DF2RAW_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599158));
pub const E_IMAPI_DF2RAW_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599155));
pub const E_IMAPI_DF2RAW_DATA_BLOCK_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599154));
pub const E_IMAPI_DF2RAW_STREAM_LEADIN_TOO_SHORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599153));
pub const E_IMAPI_DF2RAW_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599152));
pub const E_IMAPI_ERASE_RECORDER_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340224));
pub const E_IMAPI_ERASE_ONLY_ONE_RECORDER_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340223));
pub const E_IMAPI_ERASE_DISC_INFORMATION_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340222));
pub const E_IMAPI_ERASE_MODE_PAGE_2A_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340221));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_ERASABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340220));
pub const E_IMAPI_ERASE_DRIVE_FAILED_ERASE_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340219));
pub const E_IMAPI_ERASE_TOOK_LONGER_THAN_ONE_HOUR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340218));
pub const E_IMAPI_ERASE_UNEXPECTED_DRIVE_RESPONSE_DURING_ERASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340217));
pub const E_IMAPI_ERASE_DRIVE_FAILED_SPINUP_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340216));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598391));
pub const E_IMAPI_ERASE_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598390));
pub const E_IMAPI_ERASE_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598389));
pub const E_IMAPI_RAW_IMAGE_IS_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339968));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339967));
pub const E_IMAPI_RAW_IMAGE_SECTOR_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339966));
pub const E_IMAPI_RAW_IMAGE_NO_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339965));
pub const E_IMAPI_RAW_IMAGE_TRACKS_ALREADY_ADDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339964));
pub const E_IMAPI_RAW_IMAGE_INSUFFICIENT_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339963));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACK_INDEXES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339962));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339961));
pub const S_IMAPI_RAW_IMAGE_TRACK_INDEX_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11143688));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_OFFSET_ZERO_CANNOT_BE_CLEARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339959));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_TOO_CLOSE_TO_OTHER_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339958));
pub const FACILITY_IMAPI2 = @as(u32, 170);
pub const IMAPI_E_FSI_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555392));
pub const IMAPI_E_INVALID_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555391));
pub const IMAPI_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555390));
pub const IMAPI_E_NO_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555389));
pub const IMAPI_E_INVALID_VOLUME_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555388));
pub const IMAPI_E_INVALID_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555387));
pub const IMAPI_E_FILE_SYSTEM_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555386));
pub const IMAPI_E_NOT_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555384));
pub const IMAPI_E_NOT_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555383));
pub const IMAPI_E_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555382));
pub const IMAPI_E_NOT_IN_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555381));
pub const IMAPI_E_INVALID_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555376));
pub const IMAPI_E_RESTRICTED_NAME_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555375));
pub const IMAPI_E_DUP_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555374));
pub const IMAPI_E_NO_UNIQUE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555373));
pub const IMAPI_E_ITEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555368));
pub const IMAPI_E_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555367));
pub const IMAPI_E_DIR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555366));
pub const IMAPI_E_IMAGE_SIZE_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555360));
pub const IMAPI_E_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555359));
pub const IMAPI_E_DATA_STREAM_INCONSISTENCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555352));
pub const IMAPI_E_DATA_STREAM_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555351));
pub const IMAPI_E_DATA_STREAM_CREATE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555350));
pub const IMAPI_E_DIRECTORY_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555349));
pub const IMAPI_E_TOO_MANY_DIRS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555344));
pub const IMAPI_E_ISO9660_LEVELS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555343));
pub const IMAPI_E_DATA_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555342));
pub const IMAPI_E_INCOMPATIBLE_PREVIOUS_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555341));
pub const IMAPI_E_STASHFILE_OPEN_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555336));
pub const IMAPI_E_STASHFILE_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555335));
pub const IMAPI_E_STASHFILE_WRITE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555334));
pub const IMAPI_E_STASHFILE_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555333));
pub const IMAPI_E_INVALID_WORKING_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555328));
pub const IMAPI_E_WORKING_DIRECTORY_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555327));
pub const IMAPI_E_STASHFILE_MOVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555326));
pub const IMAPI_E_BOOT_IMAGE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555320));
pub const IMAPI_E_BOOT_OBJECT_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555319));
pub const IMAPI_E_BOOT_EMULATION_IMAGE_SIZE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555318));
pub const IMAPI_E_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555312));
pub const IMAPI_E_NO_SUPPORTED_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555311));
pub const IMAPI_E_FILE_SYSTEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555310));
pub const IMAPI_E_FILE_SYSTEM_READ_CONSISTENCY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555309));
pub const IMAPI_E_FILE_SYSTEM_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555308));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_FILE_EXISTS_AS_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555307));
pub const IMAPI_E_IMPORT_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555306));
pub const IMAPI_E_IMPORT_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555305));
pub const IMAPI_E_DISC_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555304));
pub const IMAPI_E_IMPORT_MEDIA_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555303));
pub const IMAPI_E_UDF_NOT_WRITE_COMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555302));
pub const IMAPI_E_INCOMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555301));
pub const IMAPI_E_NO_COMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555300));
pub const IMAPI_E_MULTISESSION_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555299));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_DIRECTORY_EXISTS_AS_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555298));
pub const IMAPI_S_IMAGE_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11186527));
pub const IMAPI_E_PROPERTY_NOT_ACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555296));
pub const IMAPI_E_UDF_REVISION_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555295));
pub const IMAPI_E_BAD_MULTISESSION_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555294));
pub const IMAPI_E_FILE_SYSTEM_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555293));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555136));
pub const IMAPI_E_IMAGEMANAGER_NO_VALID_VD_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555135));
pub const IMAPI_E_IMAGEMANAGER_NO_IMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555134));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555133));
pub const MAPI_E_CALL_FAILED = @as(i32, -2147467259);
pub const MAPI_E_NOT_ENOUGH_MEMORY = @as(i32, -2147024882);
pub const MAPI_E_INVALID_PARAMETER = @as(i32, -2147024809);
pub const MAPI_E_INTERFACE_NOT_SUPPORTED = @as(i32, -2147467262);
pub const MAPI_E_NO_ACCESS = @as(i32, -2147024891);
pub const TAD_ALL_ROWS = @as(u32, 1);
pub const PRILOWEST = @as(i32, -32768);
pub const PRIHIGHEST = @as(u32, 32767);
pub const PRIUSER = @as(u32, 0);

//--------------------------------------------------------------------------------
// Section: Types (129)
//--------------------------------------------------------------------------------
pub const ENTRYID = extern struct {
    abFlags: [4]u8,
    ab: [1]u8,
};

pub const MAPIUID = extern struct {
    ab: [16]u8,
};

pub const SPropTagArray = extern struct {
    cValues: u32,
    aulPropTag: [1]u32,
};

pub const SBinary = extern struct {
    cb: u32,
    lpb: ?*u8,
};

pub const SShortArray = extern struct {
    cValues: u32,
    lpi: ?*i16,
};

pub const SGuidArray = extern struct {
    cValues: u32,
    lpguid: ?*Guid,
};

pub const SRealArray = extern struct {
    cValues: u32,
    lpflt: ?*f32,
};

pub const SLongArray = extern struct {
    cValues: u32,
    lpl: ?*i32,
};

pub const SLargeIntegerArray = extern struct {
    cValues: u32,
    lpli: ?*LARGE_INTEGER,
};

pub const SDateTimeArray = extern struct {
    cValues: u32,
    lpft: ?*FILETIME,
};

pub const SAppTimeArray = extern struct {
    cValues: u32,
    lpat: ?*f64,
};

pub const SCurrencyArray = extern struct {
    cValues: u32,
    lpcur: ?*CY,
};

pub const SBinaryArray = extern struct {
    cValues: u32,
    lpbin: ?*SBinary,
};

pub const SDoubleArray = extern struct {
    cValues: u32,
    lpdbl: ?*f64,
};

pub const SWStringArray = extern struct {
    cValues: u32,
    lppszW: ?*?PWSTR,
};

pub const SLPSTRArray = extern struct {
    cValues: u32,
    lppszA: ?*?PSTR,
};

pub const _PV = extern union {
    i: i16,
    l: i32,
    ul: u32,
    flt: f32,
    dbl: f64,
    b: u16,
    cur: CY,
    at: f64,
    ft: FILETIME,
    lpszA: ?PSTR,
    bin: SBinary,
    lpszW: ?PWSTR,
    lpguid: ?*Guid,
    li: LARGE_INTEGER,
    MVi: SShortArray,
    MVl: SLongArray,
    MVflt: SRealArray,
    MVdbl: SDoubleArray,
    MVcur: SCurrencyArray,
    MVat: SAppTimeArray,
    MVft: SDateTimeArray,
    MVbin: SBinaryArray,
    MVszA: SLPSTRArray,
    MVszW: SWStringArray,
    MVguid: SGuidArray,
    MVli: SLargeIntegerArray,
    err: i32,
    x: i32,
};

pub const SPropValue = extern struct {
    ulPropTag: u32,
    dwAlignPad: u32,
    Value: _PV,
};

pub const SPropProblem = extern struct {
    ulIndex: u32,
    ulPropTag: u32,
    scode: i32,
};

pub const SPropProblemArray = extern struct {
    cProblem: u32,
    aProblem: [1]SPropProblem,
};

pub const FLATENTRY = extern struct {
    cb: u32,
    abEntry: [1]u8,
};

pub const FLATENTRYLIST = extern struct {
    cEntries: u32,
    cbEntries: u32,
    abEntries: [1]u8,
};

pub const MTSID = extern struct {
    cb: u32,
    ab: [1]u8,
};

pub const FLATMTSIDLIST = extern struct {
    cMTSIDs: u32,
    cbMTSIDs: u32,
    abMTSIDs: [1]u8,
};

pub const ADRENTRY = extern struct {
    ulReserved1: u32,
    cValues: u32,
    rgPropVals: ?*SPropValue,
};

pub const ADRLIST = extern struct {
    cEntries: u32,
    aEntries: [1]ADRENTRY,
};

pub const SRow = extern struct {
    ulAdrEntryPad: u32,
    cValues: u32,
    lpProps: ?*SPropValue,
};

pub const SRowSet = extern struct {
    cRows: u32,
    aRow: [1]SRow,
};

pub const LPALLOCATEBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        cbSize: u32,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        cbSize: u32,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const LPALLOCATEMORE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        cbSize: u32,
        lpObject: ?*anyopaque,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        cbSize: u32,
        lpObject: ?*anyopaque,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const LPFREEBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpBuffer: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        lpBuffer: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const MAPIERROR = extern struct {
    ulVersion: u32,
    lpszError: ?*i8,
    lpszComponent: ?*i8,
    ulLowLevelError: u32,
    ulContext: u32,
};

pub const ERROR_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    scode: i32,
    ulFlags: u32,
    lpMAPIError: ?*MAPIERROR,
};

pub const NEWMAIL_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    ulFlags: u32,
    lpszMessageClass: ?*i8,
    ulMessageFlags: u32,
};

pub const OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    ulObjType: u32,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    cbOldID: u32,
    lpOldID: ?*ENTRYID,
    cbOldParentID: u32,
    lpOldParentID: ?*ENTRYID,
    lpPropTagArray: ?*SPropTagArray,
};

pub const TABLE_NOTIFICATION = extern struct {
    ulTableEvent: u32,
    hResult: HRESULT,
    propIndex: SPropValue,
    propPrior: SPropValue,
    row: SRow,
    ulPad: u32,
};

pub const EXTENDED_NOTIFICATION = extern struct {
    ulEvent: u32,
    cb: u32,
    pbEventParameters: ?*u8,
};

pub const STATUS_OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cValues: u32,
    lpPropVals: ?*SPropValue,
};

pub const NOTIFICATION = extern struct {
    ulEventType: u32,
    ulAlignPad: u32,
    info: extern union {
        err: ERROR_NOTIFICATION,
        newmail: NEWMAIL_NOTIFICATION,
        obj: OBJECT_NOTIFICATION,
        tab: TABLE_NOTIFICATION,
        ext: EXTENDED_NOTIFICATION,
        statobj: STATUS_OBJECT_NOTIFICATION,
    },
};

pub const IMAPIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIAdviseSink,
                cNotif: u32,
                lpNotifications: ?*NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IMAPIAdviseSink,
                cNotif: u32,
                lpNotifications: ?*NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIAdviseSink_OnNotify(self: *const T, cNotif: u32, lpNotifications: ?*NOTIFICATION) u32 {
                return @as(*const IMAPIAdviseSink.VTable, @ptrCast(self.vtable)).OnNotify(@as(*const IMAPIAdviseSink, @ptrCast(self)), cNotif, lpNotifications);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPNOTIFCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpvContext: ?*anyopaque,
        cNotification: u32,
        lpNotifications: ?*NOTIFICATION,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        lpvContext: ?*anyopaque,
        cNotification: u32,
        lpNotifications: ?*NOTIFICATION,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const IMAPIProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProgress,
                ulValue: u32,
                ulCount: u32,
                ulTotal: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProgress,
                ulValue: u32,
                ulCount: u32,
                ulTotal: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProgress,
                lpulFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProgress,
                lpulFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProgress,
                lpulMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProgress,
                lpulMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMin: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProgress,
                lpulMin: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProgress,
                lpulMin: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProgress,
                lpulMin: ?*u32,
                lpulMax: ?*u32,
                lpulFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProgress,
                lpulMin: ?*u32,
                lpulMax: ?*u32,
                lpulFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProgress_Progress(self: *const T, ulValue: u32, ulCount: u32, ulTotal: u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).Progress(@as(*const IMAPIProgress, @ptrCast(self)), ulValue, ulCount, ulTotal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProgress_GetFlags(self: *const T, lpulFlags: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IMAPIProgress, @ptrCast(self)), lpulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProgress_GetMax(self: *const T, lpulMax: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).GetMax(@as(*const IMAPIProgress, @ptrCast(self)), lpulMax);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProgress_GetMin(self: *const T, lpulMin: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).GetMin(@as(*const IMAPIProgress, @ptrCast(self)), lpulMin);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProgress_SetLimits(self: *const T, lpulMin: ?*u32, lpulMax: ?*u32, lpulFlags: ?*u32) HRESULT {
                return @as(*const IMAPIProgress.VTable, @ptrCast(self.vtable)).SetLimits(@as(*const IMAPIProgress, @ptrCast(self)), lpulMin, lpulMax, lpulFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MAPINAMEID = extern struct {
    lpguid: ?*Guid,
    ulKind: u32,
    Kind: extern union {
        lID: i32,
        lpwstrName: ?PWSTR,
    },
};

pub const IMAPIProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
                lpcValues: ?*u32,
                lppPropArray: ?*?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
                lpcValues: ?*u32,
                lppPropArray: ?*?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                ulFlags: u32,
                lppPropTagArray: ?*?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                ulFlags: u32,
                lppPropTagArray: ?*?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                ulPropTag: u32,
                lpiid: ?*Guid,
                ulInterfaceOptions: u32,
                ulFlags: u32,
                lppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                ulPropTag: u32,
                lpiid: ?*Guid,
                ulInterfaceOptions: u32,
                ulFlags: u32,
                lppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                cValues: u32,
                lpPropArray: ?*SPropValue,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                cValues: u32,
                lpPropArray: ?*SPropValue,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                lpPropTagArray: ?*SPropTagArray,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                lpPropTagArray: ?*SPropTagArray,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                ciidExclude: u32,
                rgiidExclude: ?*Guid,
                lpExcludeProps: ?*SPropTagArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                lpInterface: ?*Guid,
                lpDestObj: ?*anyopaque,
                ulFlags: u32,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                ciidExclude: u32,
                rgiidExclude: ?*Guid,
                lpExcludeProps: ?*SPropTagArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                lpInterface: ?*Guid,
                lpDestObj: ?*anyopaque,
                ulFlags: u32,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                lpIncludeProps: ?*SPropTagArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                lpInterface: ?*Guid,
                lpDestObj: ?*anyopaque,
                ulFlags: u32,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                lpIncludeProps: ?*SPropTagArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                lpInterface: ?*Guid,
                lpDestObj: ?*anyopaque,
                ulFlags: u32,
                lppProblems: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamesFromIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                lppPropTags: ?*?*SPropTagArray,
                lpPropSetGuid: ?*Guid,
                ulFlags: u32,
                lpcPropNames: ?*u32,
                lpppPropNames: ?*?*?*MAPINAMEID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                lppPropTags: ?*?*SPropTagArray,
                lpPropSetGuid: ?*Guid,
                ulFlags: u32,
                lpcPropNames: ?*u32,
                lpppPropNames: ?*?*?*MAPINAMEID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDsFromNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIProp,
                cPropNames: u32,
                lppPropNames: ?*?*MAPINAMEID,
                ulFlags: u32,
                lppPropTags: ?*?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIProp,
                cPropNames: u32,
                lppPropNames: ?*?*MAPINAMEID,
                ulFlags: u32,
                lppPropTags: ?*?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IMAPIProp, @ptrCast(self)), hResult, ulFlags, lppMAPIError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_SaveChanges(self: *const T, ulFlags: u32) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).SaveChanges(@as(*const IMAPIProp, @ptrCast(self)), ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_GetProps(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpcValues: ?*u32, lppPropArray: ?*?*SPropValue) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetProps(@as(*const IMAPIProp, @ptrCast(self)), lpPropTagArray, ulFlags, lpcValues, lppPropArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_GetPropList(self: *const T, ulFlags: u32, lppPropTagArray: ?*?*SPropTagArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetPropList(@as(*const IMAPIProp, @ptrCast(self)), ulFlags, lppPropTagArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_OpenProperty(self: *const T, ulPropTag: u32, lpiid: ?*Guid, ulInterfaceOptions: u32, ulFlags: u32, lppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).OpenProperty(@as(*const IMAPIProp, @ptrCast(self)), ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_SetProps(self: *const T, cValues: u32, lpPropArray: ?*SPropValue, lppProblems: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).SetProps(@as(*const IMAPIProp, @ptrCast(self)), cValues, lpPropArray, lppProblems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_DeleteProps(self: *const T, lpPropTagArray: ?*SPropTagArray, lppProblems: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).DeleteProps(@as(*const IMAPIProp, @ptrCast(self)), lpPropTagArray, lppProblems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_CopyTo(self: *const T, ciidExclude: u32, rgiidExclude: ?*Guid, lpExcludeProps: ?*SPropTagArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, lpInterface: ?*Guid, lpDestObj: ?*anyopaque, ulFlags: u32, lppProblems: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IMAPIProp, @ptrCast(self)), ciidExclude, rgiidExclude, lpExcludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_CopyProps(self: *const T, lpIncludeProps: ?*SPropTagArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, lpInterface: ?*Guid, lpDestObj: ?*anyopaque, ulFlags: u32, lppProblems: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).CopyProps(@as(*const IMAPIProp, @ptrCast(self)), lpIncludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_GetNamesFromIDs(self: *const T, lppPropTags: ?*?*SPropTagArray, lpPropSetGuid: ?*Guid, ulFlags: u32, lpcPropNames: ?*u32, lpppPropNames: ?*?*?*MAPINAMEID) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetNamesFromIDs(@as(*const IMAPIProp, @ptrCast(self)), lppPropTags, lpPropSetGuid, ulFlags, lpcPropNames, lpppPropNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIProp_GetIDsFromNames(self: *const T, cPropNames: u32, lppPropNames: ?*?*MAPINAMEID, ulFlags: u32, lppPropTags: ?*?*SPropTagArray) HRESULT {
                return @as(*const IMAPIProp.VTable, @ptrCast(self.vtable)).GetIDsFromNames(@as(*const IMAPIProp, @ptrCast(self)), cPropNames, lppPropNames, ulFlags, lppPropTags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SSortOrder = extern struct {
    ulPropTag: u32,
    ulOrder: u32,
};

pub const SSortOrderSet = extern struct {
    cSorts: u32,
    cCategories: u32,
    cExpanded: u32,
    aSort: [1]SSortOrder,
};

pub const SAndRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SOrRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SNotRestriction = extern struct {
    ulReserved: u32,
    lpRes: ?*SRestriction,
};

pub const SContentRestriction = extern struct {
    ulFuzzyLevel: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SBitMaskRestriction = extern struct {
    relBMR: u32,
    ulPropTag: u32,
    ulMask: u32,
};

pub const SPropertyRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SComparePropsRestriction = extern struct {
    relop: u32,
    ulPropTag1: u32,
    ulPropTag2: u32,
};

pub const SSizeRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    cb: u32,
};

pub const SExistRestriction = extern struct {
    ulReserved1: u32,
    ulPropTag: u32,
    ulReserved2: u32,
};

pub const SSubRestriction = extern struct {
    ulSubObject: u32,
    lpRes: ?*SRestriction,
};

pub const SCommentRestriction = extern struct {
    cValues: u32,
    lpRes: ?*SRestriction,
    lpProp: ?*SPropValue,
};

pub const SRestriction = extern struct {
    rt: u32,
    res: extern union {
        resCompareProps: SComparePropsRestriction,
        resAnd: SAndRestriction,
        resOr: SOrRestriction,
        resNot: SNotRestriction,
        resContent: SContentRestriction,
        resProperty: SPropertyRestriction,
        resBitMask: SBitMaskRestriction,
        resSize: SSizeRestriction,
        resExist: SExistRestriction,
        resSub: SSubRestriction,
        resComment: SCommentRestriction,
    },
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMAPITable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulEventMask: u32,
                lpAdviseSink: ?*IMAPIAdviseSink,
                lpulConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulEventMask: u32,
                lpAdviseSink: ?*IMAPIAdviseSink,
                lpulConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpulTableStatus: ?*u32,
                lpulTableType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpulTableStatus: ?*u32,
                lpulTableType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryColumns: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulFlags: u32,
                lpPropTagArray: ?*?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulFlags: u32,
                lpPropTagArray: ?*?*SPropTagArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRowCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulFlags: u32,
                lpulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulFlags: u32,
                lpulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SeekRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                bkOrigin: u32,
                lRowCount: i32,
                lplRowsSought: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                bkOrigin: u32,
                lRowCount: i32,
                lplRowsSought: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SeekRowApprox: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulNumerator: u32,
                ulDenominator: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulNumerator: u32,
                ulDenominator: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpulRow: ?*u32,
                lpulNumerator: ?*u32,
                lpulDenominator: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpulRow: ?*u32,
                lpulNumerator: ?*u32,
                lpulDenominator: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpRestriction: ?*SRestriction,
                bkOrigin: u32,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpRestriction: ?*SRestriction,
                bkOrigin: u32,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Restrict: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpRestriction: ?*SRestriction,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpRestriction: ?*SRestriction,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpbkPosition: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpbkPosition: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                bkPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                bkPosition: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SortTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lpSortCriteria: ?*SSortOrderSet,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lpSortCriteria: ?*SSortOrderSet,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QuerySortOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lppSortCriteria: ?*?*SSortOrderSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lppSortCriteria: ?*?*SSortOrderSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                lRowCount: i32,
                ulFlags: u32,
                lppRows: ?*?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                lRowCount: i32,
                ulFlags: u32,
                lppRows: ?*?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                cbInstanceKey: u32,
                pbInstanceKey: ?*u8,
                ulRowCount: u32,
                ulFlags: u32,
                lppRows: ?*?*SRowSet,
                lpulMoreRows: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                cbInstanceKey: u32,
                pbInstanceKey: ?*u8,
                ulRowCount: u32,
                ulFlags: u32,
                lppRows: ?*?*SRowSet,
                lpulMoreRows: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CollapseRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                cbInstanceKey: u32,
                pbInstanceKey: ?*u8,
                ulFlags: u32,
                lpulRowCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                cbInstanceKey: u32,
                pbInstanceKey: ?*u8,
                ulFlags: u32,
                lpulRowCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForCompletion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulFlags: u32,
                ulTimeout: u32,
                lpulTableStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulFlags: u32,
                ulTimeout: u32,
                lpulTableStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCollapseState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulFlags: u32,
                cbInstanceKey: u32,
                lpbInstanceKey: ?*u8,
                lpcbCollapseState: ?*u32,
                lppbCollapseState: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulFlags: u32,
                cbInstanceKey: u32,
                lpbInstanceKey: ?*u8,
                lpcbCollapseState: ?*u32,
                lppbCollapseState: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCollapseState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPITable,
                ulFlags: u32,
                cbCollapseState: u32,
                pbCollapseState: ?*u8,
                lpbkLocation: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPITable,
                ulFlags: u32,
                cbCollapseState: u32,
                pbCollapseState: ?*u8,
                lpbkLocation: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IMAPITable, @ptrCast(self)), hResult, ulFlags, lppMAPIError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_Advise(self: *const T, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Advise(@as(*const IMAPITable, @ptrCast(self)), ulEventMask, lpAdviseSink, lpulConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_Unadvise(self: *const T, ulConnection: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IMAPITable, @ptrCast(self)), ulConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_GetStatus(self: *const T, lpulTableStatus: ?*u32, lpulTableType: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMAPITable, @ptrCast(self)), lpulTableStatus, lpulTableType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_SetColumns(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SetColumns(@as(*const IMAPITable, @ptrCast(self)), lpPropTagArray, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_QueryColumns(self: *const T, ulFlags: u32, lpPropTagArray: ?*?*SPropTagArray) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QueryColumns(@as(*const IMAPITable, @ptrCast(self)), ulFlags, lpPropTagArray);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_GetRowCount(self: *const T, ulFlags: u32, lpulCount: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetRowCount(@as(*const IMAPITable, @ptrCast(self)), ulFlags, lpulCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_SeekRow(self: *const T, bkOrigin: u32, lRowCount: i32, lplRowsSought: ?*i32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SeekRow(@as(*const IMAPITable, @ptrCast(self)), bkOrigin, lRowCount, lplRowsSought);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_SeekRowApprox(self: *const T, ulNumerator: u32, ulDenominator: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SeekRowApprox(@as(*const IMAPITable, @ptrCast(self)), ulNumerator, ulDenominator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_QueryPosition(self: *const T, lpulRow: ?*u32, lpulNumerator: ?*u32, lpulDenominator: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QueryPosition(@as(*const IMAPITable, @ptrCast(self)), lpulRow, lpulNumerator, lpulDenominator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_FindRow(self: *const T, lpRestriction: ?*SRestriction, bkOrigin: u32, ulFlags: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).FindRow(@as(*const IMAPITable, @ptrCast(self)), lpRestriction, bkOrigin, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_Restrict(self: *const T, lpRestriction: ?*SRestriction, ulFlags: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Restrict(@as(*const IMAPITable, @ptrCast(self)), lpRestriction, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_CreateBookmark(self: *const T, lpbkPosition: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).CreateBookmark(@as(*const IMAPITable, @ptrCast(self)), lpbkPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_FreeBookmark(self: *const T, bkPosition: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).FreeBookmark(@as(*const IMAPITable, @ptrCast(self)), bkPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_SortTable(self: *const T, lpSortCriteria: ?*SSortOrderSet, ulFlags: u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SortTable(@as(*const IMAPITable, @ptrCast(self)), lpSortCriteria, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_QuerySortOrder(self: *const T, lppSortCriteria: ?*?*SSortOrderSet) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QuerySortOrder(@as(*const IMAPITable, @ptrCast(self)), lppSortCriteria);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_QueryRows(self: *const T, lRowCount: i32, ulFlags: u32, lppRows: ?*?*SRowSet) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).QueryRows(@as(*const IMAPITable, @ptrCast(self)), lRowCount, ulFlags, lppRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_Abort(self: *const T) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).Abort(@as(*const IMAPITable, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_ExpandRow(self: *const T, cbInstanceKey: u32, pbInstanceKey: ?*u8, ulRowCount: u32, ulFlags: u32, lppRows: ?*?*SRowSet, lpulMoreRows: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).ExpandRow(@as(*const IMAPITable, @ptrCast(self)), cbInstanceKey, pbInstanceKey, ulRowCount, ulFlags, lppRows, lpulMoreRows);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_CollapseRow(self: *const T, cbInstanceKey: u32, pbInstanceKey: ?*u8, ulFlags: u32, lpulRowCount: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).CollapseRow(@as(*const IMAPITable, @ptrCast(self)), cbInstanceKey, pbInstanceKey, ulFlags, lpulRowCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_WaitForCompletion(self: *const T, ulFlags: u32, ulTimeout: u32, lpulTableStatus: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).WaitForCompletion(@as(*const IMAPITable, @ptrCast(self)), ulFlags, ulTimeout, lpulTableStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_GetCollapseState(self: *const T, ulFlags: u32, cbInstanceKey: u32, lpbInstanceKey: ?*u8, lpcbCollapseState: ?*u32, lppbCollapseState: ?*?*u8) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).GetCollapseState(@as(*const IMAPITable, @ptrCast(self)), ulFlags, cbInstanceKey, lpbInstanceKey, lpcbCollapseState, lppbCollapseState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPITable_SetCollapseState(self: *const T, ulFlags: u32, cbCollapseState: u32, pbCollapseState: ?*u8, lpbkLocation: ?*u32) HRESULT {
                return @as(*const IMAPITable.VTable, @ptrCast(self.vtable)).SetCollapseState(@as(*const IMAPITable, @ptrCast(self)), ulFlags, cbCollapseState, pbCollapseState, lpbkLocation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IProfSect = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIStatus = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        ValidateState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIStatus,
                ulUIParam: usize,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIStatus,
                ulUIParam: usize,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SettingsDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIStatus,
                ulUIParam: usize,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIStatus,
                ulUIParam: usize,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangePassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIStatus,
                lpOldPass: ?*i8,
                lpNewPass: ?*i8,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIStatus,
                lpOldPass: ?*i8,
                lpNewPass: ?*i8,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushQueues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIStatus,
                ulUIParam: usize,
                cbTargetTransport: u32,
                lpTargetTransport: ?[*]ENTRYID,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIStatus,
                ulUIParam: usize,
                cbTargetTransport: u32,
                lpTargetTransport: ?[*]ENTRYID,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIStatus_ValidateState(self: *const T, ulUIParam: usize, ulFlags: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).ValidateState(@as(*const IMAPIStatus, @ptrCast(self)), ulUIParam, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIStatus_SettingsDialog(self: *const T, ulUIParam: usize, ulFlags: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).SettingsDialog(@as(*const IMAPIStatus, @ptrCast(self)), ulUIParam, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIStatus_ChangePassword(self: *const T, lpOldPass: ?*i8, lpNewPass: ?*i8, ulFlags: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).ChangePassword(@as(*const IMAPIStatus, @ptrCast(self)), lpOldPass, lpNewPass, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIStatus_FlushQueues(self: *const T, ulUIParam: usize, cbTargetTransport: u32, lpTargetTransport: ?[*]ENTRYID, ulFlags: u32) HRESULT {
                return @as(*const IMAPIStatus.VTable, @ptrCast(self.vtable)).FlushQueues(@as(*const IMAPIStatus, @ptrCast(self)), ulUIParam, cbTargetTransport, lpTargetTransport, ulFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIContainer = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetContentsTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIContainer,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIContainer,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHierarchyTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIContainer,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIContainer,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIContainer,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulObjType: ?*u32,
                lppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIContainer,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulObjType: ?*u32,
                lppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSearchCriteria: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIContainer,
                lpRestriction: ?*SRestriction,
                lpContainerList: ?*SBinaryArray,
                ulSearchFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIContainer,
                lpRestriction: ?*SRestriction,
                lpContainerList: ?*SBinaryArray,
                ulSearchFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSearchCriteria: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIContainer,
                ulFlags: u32,
                lppRestriction: ?*?*SRestriction,
                lppContainerList: ?*?*SBinaryArray,
                lpulSearchState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIContainer,
                ulFlags: u32,
                lppRestriction: ?*?*SRestriction,
                lppContainerList: ?*?*SBinaryArray,
                lpulSearchState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIContainer_GetContentsTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).GetContentsTable(@as(*const IMAPIContainer, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIContainer_GetHierarchyTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).GetHierarchyTable(@as(*const IMAPIContainer, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIContainer_OpenEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, lppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).OpenEntry(@as(*const IMAPIContainer, @ptrCast(self)), cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, lppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIContainer_SetSearchCriteria(self: *const T, lpRestriction: ?*SRestriction, lpContainerList: ?*SBinaryArray, ulSearchFlags: u32) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).SetSearchCriteria(@as(*const IMAPIContainer, @ptrCast(self)), lpRestriction, lpContainerList, ulSearchFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIContainer_GetSearchCriteria(self: *const T, ulFlags: u32, lppRestriction: ?*?*SRestriction, lppContainerList: ?*?*SBinaryArray, lpulSearchState: ?*u32) HRESULT {
                return @as(*const IMAPIContainer.VTable, @ptrCast(self.vtable)).GetSearchCriteria(@as(*const IMAPIContainer, @ptrCast(self)), ulFlags, lppRestriction, lppContainerList, lpulSearchState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _flaglist = extern struct {
    cFlags: u32,
    ulFlag: [1]u32,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IABContainer = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IABContainer,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulCreateFlags: u32,
                lppMAPIPropEntry: ?*?*IMAPIProp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IABContainer,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulCreateFlags: u32,
                lppMAPIPropEntry: ?*?*IMAPIProp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IABContainer,
                lpEntries: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IABContainer,
                lpEntries: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IABContainer,
                lpEntries: ?*SBinaryArray,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IABContainer,
                lpEntries: ?*SBinaryArray,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IABContainer,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
                lpAdrList: ?*ADRLIST,
                lpFlagList: ?*_flaglist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IABContainer,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
                lpAdrList: ?*ADRLIST,
                lpFlagList: ?*_flaglist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIContainer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IABContainer_CreateEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulCreateFlags: u32, lppMAPIPropEntry: ?*?*IMAPIProp) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).CreateEntry(@as(*const IABContainer, @ptrCast(self)), cbEntryID, lpEntryID, ulCreateFlags, lppMAPIPropEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IABContainer_CopyEntries(self: *const T, lpEntries: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).CopyEntries(@as(*const IABContainer, @ptrCast(self)), lpEntries, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IABContainer_DeleteEntries(self: *const T, lpEntries: ?*SBinaryArray, ulFlags: u32) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).DeleteEntries(@as(*const IABContainer, @ptrCast(self)), lpEntries, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IABContainer_ResolveNames(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpAdrList: ?*ADRLIST, lpFlagList: ?*_flaglist) HRESULT {
                return @as(*const IABContainer.VTable, @ptrCast(self.vtable)).ResolveNames(@as(*const IABContainer, @ptrCast(self)), lpPropTagArray, ulFlags, lpAdrList, lpFlagList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMailUser = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IDistList = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDistList,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulCreateFlags: u32,
                lppMAPIPropEntry: ?*?*IMAPIProp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDistList,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulCreateFlags: u32,
                lppMAPIPropEntry: ?*?*IMAPIProp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDistList,
                lpEntries: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDistList,
                lpEntries: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDistList,
                lpEntries: ?*SBinaryArray,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDistList,
                lpEntries: ?*SBinaryArray,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDistList,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
                lpAdrList: ?*ADRLIST,
                lpFlagList: ?*_flaglist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDistList,
                lpPropTagArray: ?*SPropTagArray,
                ulFlags: u32,
                lpAdrList: ?*ADRLIST,
                lpFlagList: ?*_flaglist,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIContainer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDistList_CreateEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulCreateFlags: u32, lppMAPIPropEntry: ?*?*IMAPIProp) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).CreateEntry(@as(*const IDistList, @ptrCast(self)), cbEntryID, lpEntryID, ulCreateFlags, lppMAPIPropEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDistList_CopyEntries(self: *const T, lpEntries: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).CopyEntries(@as(*const IDistList, @ptrCast(self)), lpEntries, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDistList_DeleteEntries(self: *const T, lpEntries: ?*SBinaryArray, ulFlags: u32) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).DeleteEntries(@as(*const IDistList, @ptrCast(self)), lpEntries, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDistList_ResolveNames(self: *const T, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpAdrList: ?*ADRLIST, lpFlagList: ?*_flaglist) HRESULT {
                return @as(*const IDistList.VTable, @ptrCast(self.vtable)).ResolveNames(@as(*const IDistList, @ptrCast(self)), lpPropTagArray, ulFlags, lpAdrList, lpFlagList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAPIFolder = extern struct {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppMessage: ?*?*IMessage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppMessage: ?*?*IMessage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                lpMsgList: ?*SBinaryArray,
                lpInterface: ?*Guid,
                lpDestFolder: ?*anyopaque,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                lpMsgList: ?*SBinaryArray,
                lpInterface: ?*Guid,
                lpDestFolder: ?*anyopaque,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteMessages: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                lpMsgList: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                lpMsgList: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                ulFolderType: u32,
                lpszFolderName: ?*i8,
                lpszFolderComment: ?*i8,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppFolder: ?*?*IMAPIFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                ulFolderType: u32,
                lpszFolderName: ?*i8,
                lpszFolderComment: ?*i8,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppFolder: ?*?*IMAPIFolder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                lpDestFolder: ?*anyopaque,
                lpszNewFolderName: ?*i8,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                lpDestFolder: ?*anyopaque,
                lpszNewFolderName: ?*i8,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReadFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                lpMsgList: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                lpMsgList: ?*SBinaryArray,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMessageStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulFlags: u32,
                lpulMessageStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulFlags: u32,
                lpulMessageStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMessageStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulNewStatus: u32,
                ulNewStatusMask: u32,
                lpulOldStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulNewStatus: u32,
                ulNewStatusMask: u32,
                lpulOldStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveContentsSort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                lpSortCriteria: ?*SSortOrderSet,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                lpSortCriteria: ?*SSortOrderSet,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EmptyFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIFolder,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIFolder,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIContainer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_CreateMessage(self: *const T, lpInterface: ?*Guid, ulFlags: u32, lppMessage: ?*?*IMessage) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CreateMessage(@as(*const IMAPIFolder, @ptrCast(self)), lpInterface, ulFlags, lppMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_CopyMessages(self: *const T, lpMsgList: ?*SBinaryArray, lpInterface: ?*Guid, lpDestFolder: ?*anyopaque, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CopyMessages(@as(*const IMAPIFolder, @ptrCast(self)), lpMsgList, lpInterface, lpDestFolder, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_DeleteMessages(self: *const T, lpMsgList: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).DeleteMessages(@as(*const IMAPIFolder, @ptrCast(self)), lpMsgList, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_CreateFolder(self: *const T, ulFolderType: u32, lpszFolderName: ?*i8, lpszFolderComment: ?*i8, lpInterface: ?*Guid, ulFlags: u32, lppFolder: ?*?*IMAPIFolder) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CreateFolder(@as(*const IMAPIFolder, @ptrCast(self)), ulFolderType, lpszFolderName, lpszFolderComment, lpInterface, ulFlags, lppFolder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_CopyFolder(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, lpDestFolder: ?*anyopaque, lpszNewFolderName: ?*i8, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).CopyFolder(@as(*const IMAPIFolder, @ptrCast(self)), cbEntryID, lpEntryID, lpInterface, lpDestFolder, lpszNewFolderName, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_DeleteFolder(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).DeleteFolder(@as(*const IMAPIFolder, @ptrCast(self)), cbEntryID, lpEntryID, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_SetReadFlags(self: *const T, lpMsgList: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).SetReadFlags(@as(*const IMAPIFolder, @ptrCast(self)), lpMsgList, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_GetMessageStatus(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulFlags: u32, lpulMessageStatus: ?*u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).GetMessageStatus(@as(*const IMAPIFolder, @ptrCast(self)), cbEntryID, lpEntryID, ulFlags, lpulMessageStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_SetMessageStatus(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulNewStatus: u32, ulNewStatusMask: u32, lpulOldStatus: ?*u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).SetMessageStatus(@as(*const IMAPIFolder, @ptrCast(self)), cbEntryID, lpEntryID, ulNewStatus, ulNewStatusMask, lpulOldStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_SaveContentsSort(self: *const T, lpSortCriteria: ?*SSortOrderSet, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).SaveContentsSort(@as(*const IMAPIFolder, @ptrCast(self)), lpSortCriteria, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIFolder_EmptyFolder(self: *const T, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMAPIFolder.VTable, @ptrCast(self.vtable)).EmptyFolder(@as(*const IMAPIFolder, @ptrCast(self)), ulUIParam, lpProgress, ulFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMsgStore = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulEventMask: u32,
                lpAdviseSink: ?*IMAPIAdviseSink,
                lpulConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulEventMask: u32,
                lpAdviseSink: ?*IMAPIAdviseSink,
                lpulConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                ulConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                ulConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareEntryIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                cbEntryID1: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID1: ?*ENTRYID,
                cbEntryID2: u32,
                // TODO: what to do with BytesParamIndex 2?
                lpEntryID2: ?*ENTRYID,
                ulFlags: u32,
                lpulResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                cbEntryID1: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID1: ?*ENTRYID,
                cbEntryID2: u32,
                // TODO: what to do with BytesParamIndex 2?
                lpEntryID2: ?*ENTRYID,
                ulFlags: u32,
                lpulResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulObjType: ?*u32,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulObjType: ?*u32,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReceiveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                lpszMessageClass: ?*i8,
                ulFlags: u32,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 2?
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                lpszMessageClass: ?*i8,
                ulFlags: u32,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 2?
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReceiveFolder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                lpszMessageClass: ?*i8,
                ulFlags: u32,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
                lppszExplicitClass: ?*?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                lpszMessageClass: ?*i8,
                ulFlags: u32,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
                lppszExplicitClass: ?*?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReceiveFolderTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StoreLogoff: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                lpulFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                lpulFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbortSubmit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 0?
                lpEntryID: ?*ENTRYID,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutgoingQueue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLockState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                lpMessage: ?*IMessage,
                ulLockState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                lpMessage: ?*IMessage,
                ulLockState: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinishedMsg: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                ulFlags: u32,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 1?
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                ulFlags: u32,
                cbEntryID: u32,
                // TODO: what to do with BytesParamIndex 1?
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyNewMail: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMsgStore,
                lpNotification: ?*NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMsgStore,
                lpNotification: ?*NOTIFICATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_Advise(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).Advise(@as(*const IMsgStore, @ptrCast(self)), cbEntryID, lpEntryID, ulEventMask, lpAdviseSink, lpulConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_Unadvise(self: *const T, ulConnection: u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IMsgStore, @ptrCast(self)), ulConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_CompareEntryIDs(self: *const T, cbEntryID1: u32, lpEntryID1: ?*ENTRYID, cbEntryID2: u32, lpEntryID2: ?*ENTRYID, ulFlags: u32, lpulResult: ?*u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).CompareEntryIDs(@as(*const IMsgStore, @ptrCast(self)), cbEntryID1, lpEntryID1, cbEntryID2, lpEntryID2, ulFlags, lpulResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_OpenEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, ppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).OpenEntry(@as(*const IMsgStore, @ptrCast(self)), cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, ppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_SetReceiveFolder(self: *const T, lpszMessageClass: ?*i8, ulFlags: u32, cbEntryID: u32, lpEntryID: ?*ENTRYID) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).SetReceiveFolder(@as(*const IMsgStore, @ptrCast(self)), lpszMessageClass, ulFlags, cbEntryID, lpEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_GetReceiveFolder(self: *const T, lpszMessageClass: ?*i8, ulFlags: u32, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID, lppszExplicitClass: ?*?*i8) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).GetReceiveFolder(@as(*const IMsgStore, @ptrCast(self)), lpszMessageClass, ulFlags, lpcbEntryID, lppEntryID, lppszExplicitClass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_GetReceiveFolderTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).GetReceiveFolderTable(@as(*const IMsgStore, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_StoreLogoff(self: *const T, lpulFlags: ?*u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).StoreLogoff(@as(*const IMsgStore, @ptrCast(self)), lpulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_AbortSubmit(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulFlags: u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).AbortSubmit(@as(*const IMsgStore, @ptrCast(self)), cbEntryID, lpEntryID, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_GetOutgoingQueue(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).GetOutgoingQueue(@as(*const IMsgStore, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_SetLockState(self: *const T, lpMessage: ?*IMessage, ulLockState: u32) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).SetLockState(@as(*const IMsgStore, @ptrCast(self)), lpMessage, ulLockState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_FinishedMsg(self: *const T, ulFlags: u32, cbEntryID: u32, lpEntryID: ?*ENTRYID) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).FinishedMsg(@as(*const IMsgStore, @ptrCast(self)), ulFlags, cbEntryID, lpEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMsgStore_NotifyNewMail(self: *const T, lpNotification: ?*NOTIFICATION) HRESULT {
                return @as(*const IMsgStore.VTable, @ptrCast(self.vtable)).NotifyNewMail(@as(*const IMsgStore, @ptrCast(self)), lpNotification);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMessage = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetAttachmentTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulAttachmentNum: u32,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppAttach: ?*?*IAttach,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulAttachmentNum: u32,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppAttach: ?*?*IAttach,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulAttachmentNum: ?*u32,
                lppAttach: ?*?*IAttach,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulAttachmentNum: ?*u32,
                lppAttach: ?*?*IAttach,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulAttachmentNum: u32,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulAttachmentNum: u32,
                ulUIParam: usize,
                lpProgress: ?*IMAPIProgress,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecipientTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModifyRecipients: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulFlags: u32,
                lpMods: ?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulFlags: u32,
                lpMods: ?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SubmitMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetReadFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMessage,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMessage,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_GetAttachmentTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).GetAttachmentTable(@as(*const IMessage, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_OpenAttach(self: *const T, ulAttachmentNum: u32, lpInterface: ?*Guid, ulFlags: u32, lppAttach: ?*?*IAttach) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).OpenAttach(@as(*const IMessage, @ptrCast(self)), ulAttachmentNum, lpInterface, ulFlags, lppAttach);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_CreateAttach(self: *const T, lpInterface: ?*Guid, ulFlags: u32, lpulAttachmentNum: ?*u32, lppAttach: ?*?*IAttach) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).CreateAttach(@as(*const IMessage, @ptrCast(self)), lpInterface, ulFlags, lpulAttachmentNum, lppAttach);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_DeleteAttach(self: *const T, ulAttachmentNum: u32, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).DeleteAttach(@as(*const IMessage, @ptrCast(self)), ulAttachmentNum, ulUIParam, lpProgress, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_GetRecipientTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).GetRecipientTable(@as(*const IMessage, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_ModifyRecipients(self: *const T, ulFlags: u32, lpMods: ?*ADRLIST) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).ModifyRecipients(@as(*const IMessage, @ptrCast(self)), ulFlags, lpMods);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_SubmitMessage(self: *const T, ulFlags: u32) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).SubmitMessage(@as(*const IMessage, @ptrCast(self)), ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMessage_SetReadFlag(self: *const T, ulFlags: u32) HRESULT {
                return @as(*const IMessage.VTable, @ptrCast(self.vtable)).SetReadFlag(@as(*const IMessage, @ptrCast(self)), ulFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IAttach = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPFNABSDI = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ulUIParam: usize,
        lpvmsg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        ulUIParam: usize,
        lpvmsg: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const LPFNDISMISS = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ulUIParam: usize,
        lpvContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        ulUIParam: usize,
        lpvContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const LPFNBUTTON = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ulUIParam: usize,
        lpvContext: ?*anyopaque,
        cbEntryID: u32,
        lpSelection: ?*ENTRYID,
        ulFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        ulUIParam: usize,
        lpvContext: ?*anyopaque,
        cbEntryID: u32,
        lpSelection: ?*ENTRYID,
        ulFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const ADRPARM = extern struct {
    cbABContEntryID: u32,
    lpABContEntryID: ?*ENTRYID,
    ulFlags: u32,
    lpReserved: ?*anyopaque,
    ulHelpContext: u32,
    lpszHelpFileName: ?*i8,
    lpfnABSDI: ?LPFNABSDI,
    lpfnDismiss: ?LPFNDISMISS,
    lpvDismissContext: ?*anyopaque,
    lpszCaption: ?*i8,
    lpszNewEntryTitle: ?*i8,
    lpszDestWellsTitle: ?*i8,
    cDestFields: u32,
    nDestFieldFocus: u32,
    lppszDestTitles: ?*?*i8,
    lpulDestComps: ?*u32,
    lpContRestriction: ?*SRestriction,
    lpHierRestriction: ?*SRestriction,
};

pub const IMAPIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIControl,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIControl,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Activate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIControl,
                ulFlags: u32,
                ulUIParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIControl,
                ulFlags: u32,
                ulUIParam: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMAPIControl,
                ulFlags: u32,
                lpulState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMAPIControl,
                ulFlags: u32,
                lpulState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIControl_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) HRESULT {
                return @as(*const IMAPIControl.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IMAPIControl, @ptrCast(self)), hResult, ulFlags, lppMAPIError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIControl_Activate(self: *const T, ulFlags: u32, ulUIParam: usize) HRESULT {
                return @as(*const IMAPIControl.VTable, @ptrCast(self.vtable)).Activate(@as(*const IMAPIControl, @ptrCast(self)), ulFlags, ulUIParam);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMAPIControl_GetState(self: *const T, ulFlags: u32, lpulState: ?*u32) HRESULT {
                return @as(*const IMAPIControl.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMAPIControl, @ptrCast(self)), ulFlags, lpulState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DTBLLABEL = extern struct {
    ulbLpszLabelName: u32,
    ulFlags: u32,
};

pub const DTBLEDIT = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPropTag: u32,
};

pub const DTBLLBX = extern struct {
    ulFlags: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCOMBOBOX = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPRPropertyName: u32,
    ulPRTableName: u32,
};

pub const DTBLDDLBX = extern struct {
    ulFlags: u32,
    ulPRDisplayProperty: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCHECKBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRPropertyName: u32,
};

pub const DTBLGROUPBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
};

pub const DTBLBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRControl: u32,
};

pub const DTBLPAGE = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulbLpszComponent: u32,
    ulContext: u32,
};

pub const DTBLRADIOBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulcButtons: u32,
    ulPropTag: u32,
    lReturnValue: i32,
};

pub const DTBLMVLISTBOX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const DTBLMVDDLBX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const IProviderAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProviderAdmin,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProviderAdmin,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProviderTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProviderAdmin,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProviderAdmin,
                ulFlags: u32,
                lppTable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProviderAdmin,
                lpszProvider: ?*i8,
                cValues: u32,
                lpProps: [*]SPropValue,
                ulUIParam: usize,
                ulFlags: u32,
                lpUID: ?*MAPIUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProviderAdmin,
                lpszProvider: ?*i8,
                cValues: u32,
                lpProps: [*]SPropValue,
                ulUIParam: usize,
                ulFlags: u32,
                lpUID: ?*MAPIUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProviderAdmin,
                lpUID: ?*MAPIUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProviderAdmin,
                lpUID: ?*MAPIUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenProfileSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProviderAdmin,
                lpUID: ?*MAPIUID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppProfSect: ?*?*IProfSect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProviderAdmin,
                lpUID: ?*MAPIUID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lppProfSect: ?*?*IProfSect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProviderAdmin_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IProviderAdmin, @ptrCast(self)), hResult, ulFlags, lppMAPIError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProviderAdmin_GetProviderTable(self: *const T, ulFlags: u32, lppTable: ?*?*IMAPITable) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).GetProviderTable(@as(*const IProviderAdmin, @ptrCast(self)), ulFlags, lppTable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProviderAdmin_CreateProvider(self: *const T, lpszProvider: ?*i8, cValues: u32, lpProps: [*]SPropValue, ulUIParam: usize, ulFlags: u32, lpUID: ?*MAPIUID) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).CreateProvider(@as(*const IProviderAdmin, @ptrCast(self)), lpszProvider, cValues, lpProps, ulUIParam, ulFlags, lpUID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProviderAdmin_DeleteProvider(self: *const T, lpUID: ?*MAPIUID) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).DeleteProvider(@as(*const IProviderAdmin, @ptrCast(self)), lpUID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProviderAdmin_OpenProfileSection(self: *const T, lpUID: ?*MAPIUID, lpInterface: ?*Guid, ulFlags: u32, lppProfSect: ?*?*IProfSect) HRESULT {
                return @as(*const IProviderAdmin.VTable, @ptrCast(self.vtable)).OpenProfileSection(@as(*const IProviderAdmin, @ptrCast(self)), lpUID, lpInterface, ulFlags, lppProfSect);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const Gender = enum(i32) {
    Unspecified = 0,
    Female = 1,
    Male = 2,
};
pub const genderUnspecified = Gender.Unspecified;
pub const genderFemale = Gender.Female;
pub const genderMale = Gender.Male;

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const CALLERRELEASE = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const ITableData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HrGetView: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                lpSSortOrderSet: ?*SSortOrderSet,
                lpfCallerRelease: ?*?CALLERRELEASE,
                ulCallerData: u32,
                lppMAPITable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                lpSSortOrderSet: ?*SSortOrderSet,
                lpfCallerRelease: ?*?CALLERRELEASE,
                ulCallerData: u32,
                lppMAPITable: ?*?*IMAPITable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrModifyRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                param0: ?*SRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                param0: ?*SRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrDeleteRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                lpSPropValue: ?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                lpSPropValue: ?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrQueryRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                lpsPropValue: ?*SPropValue,
                lppSRow: ?*?*SRow,
                lpuliRow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                lpsPropValue: ?*SPropValue,
                lppSRow: ?*?*SRow,
                lpuliRow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrEnumRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                ulRowNumber: u32,
                lppSRow: ?*?*SRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                ulRowNumber: u32,
                lppSRow: ?*?*SRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                ulFlags: u32,
                cValues: u32,
                lpSPropValue: ?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                ulFlags: u32,
                cValues: u32,
                lpSPropValue: ?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrInsertRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                uliRow: u32,
                lpSRow: ?*SRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                uliRow: u32,
                lpSRow: ?*SRow,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrModifyRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                ulFlags: u32,
                lpSRowSet: ?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                ulFlags: u32,
                lpSRowSet: ?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrDeleteRows: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITableData,
                ulFlags: u32,
                lprowsetToDelete: ?*SRowSet,
                cRowsDeleted: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITableData,
                ulFlags: u32,
                lprowsetToDelete: ?*SRowSet,
                cRowsDeleted: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrGetView(self: *const T, lpSSortOrderSet: ?*SSortOrderSet, lpfCallerRelease: ?*?CALLERRELEASE, ulCallerData: u32, lppMAPITable: ?*?*IMAPITable) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrGetView(@as(*const ITableData, @ptrCast(self)), lpSSortOrderSet, lpfCallerRelease, ulCallerData, lppMAPITable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrModifyRow(self: *const T, param0: ?*SRow) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrModifyRow(@as(*const ITableData, @ptrCast(self)), param0);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrDeleteRow(self: *const T, lpSPropValue: ?*SPropValue) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrDeleteRow(@as(*const ITableData, @ptrCast(self)), lpSPropValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrQueryRow(self: *const T, lpsPropValue: ?*SPropValue, lppSRow: ?*?*SRow, lpuliRow: ?*u32) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrQueryRow(@as(*const ITableData, @ptrCast(self)), lpsPropValue, lppSRow, lpuliRow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrEnumRow(self: *const T, ulRowNumber: u32, lppSRow: ?*?*SRow) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrEnumRow(@as(*const ITableData, @ptrCast(self)), ulRowNumber, lppSRow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrNotify(self: *const T, ulFlags: u32, cValues: u32, lpSPropValue: ?*SPropValue) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrNotify(@as(*const ITableData, @ptrCast(self)), ulFlags, cValues, lpSPropValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrInsertRow(self: *const T, uliRow: u32, lpSRow: ?*SRow) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrInsertRow(@as(*const ITableData, @ptrCast(self)), uliRow, lpSRow);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrModifyRows(self: *const T, ulFlags: u32, lpSRowSet: ?*SRowSet) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrModifyRows(@as(*const ITableData, @ptrCast(self)), ulFlags, lpSRowSet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITableData_HrDeleteRows(self: *const T, ulFlags: u32, lprowsetToDelete: ?*SRowSet, cRowsDeleted: ?*u32) HRESULT {
                return @as(*const ITableData.VTable, @ptrCast(self.vtable)).HrDeleteRows(@as(*const ITableData, @ptrCast(self)), ulFlags, lprowsetToDelete, cRowsDeleted);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IPropData = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        HrSetObjAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropData,
                ulAccess: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropData,
                ulAccess: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrSetPropAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropData,
                lpPropTagArray: ?*SPropTagArray,
                rgulAccess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropData,
                lpPropTagArray: ?*SPropTagArray,
                rgulAccess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrGetPropAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropData,
                lppPropTagArray: ?*?*SPropTagArray,
                lprgulAccess: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropData,
                lppPropTagArray: ?*?*SPropTagArray,
                lprgulAccess: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HrAddObjProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPropData,
                lppPropTagArray: ?*SPropTagArray,
                lprgulAccess: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPropData,
                lppPropTagArray: ?*SPropTagArray,
                lprgulAccess: ?*?*SPropProblemArray,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropData_HrSetObjAccess(self: *const T, ulAccess: u32) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrSetObjAccess(@as(*const IPropData, @ptrCast(self)), ulAccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropData_HrSetPropAccess(self: *const T, lpPropTagArray: ?*SPropTagArray, rgulAccess: ?*u32) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrSetPropAccess(@as(*const IPropData, @ptrCast(self)), lpPropTagArray, rgulAccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropData_HrGetPropAccess(self: *const T, lppPropTagArray: ?*?*SPropTagArray, lprgulAccess: ?*?*u32) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrGetPropAccess(@as(*const IPropData, @ptrCast(self)), lppPropTagArray, lprgulAccess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPropData_HrAddObjProps(self: *const T, lppPropTagArray: ?*SPropTagArray, lprgulAccess: ?*?*SPropProblemArray) HRESULT {
                return @as(*const IPropData.VTable, @ptrCast(self.vtable)).HrAddObjProps(@as(*const IPropData, @ptrCast(self)), lppPropTagArray, lprgulAccess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const FNIDLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFNIDLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const LPOPENSTREAMONFILE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpAllocateBuffer: ?LPALLOCATEBUFFER,
        lpFreeBuffer: ?LPFREEBUFFER,
        ulFlags: u32,
        lpszFileName: ?*i8,
        lpszPrefix: ?*i8,
        lppStream: ?*?*IStream,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpAllocateBuffer: ?LPALLOCATEBUFFER,
        lpFreeBuffer: ?LPFREEBUFFER,
        ulFlags: u32,
        lpszFileName: ?*i8,
        lpszPrefix: ?*i8,
        lppStream: ?*?*IStream,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const DTCTL = extern struct {
    ulCtlType: u32,
    ulCtlFlags: u32,
    lpbNotif: ?*u8,
    cbNotif: u32,
    lpszFilter: ?*i8,
    ulItemID: u32,
    ctl: extern union {
        lpv: ?*anyopaque,
        lplabel: ?*DTBLLABEL,
        lpedit: ?*DTBLEDIT,
        lplbx: ?*DTBLLBX,
        lpcombobox: ?*DTBLCOMBOBOX,
        lpddlbx: ?*DTBLDDLBX,
        lpcheckbox: ?*DTBLCHECKBOX,
        lpgroupbox: ?*DTBLGROUPBOX,
        lpbutton: ?*DTBLBUTTON,
        lpradiobutton: ?*DTBLRADIOBUTTON,
        lpmvlbx: ?*DTBLMVLISTBOX,
        lpmvddlbx: ?*DTBLMVDDLBX,
        lppage: ?*DTBLPAGE,
    },
};

pub const DTPAGE = extern struct {
    cctl: u32,
    lpszResourceName: ?*i8,
    Anonymous: extern union {
        lpszComponent: ?*i8,
        ulItemID: u32,
    },
    lpctl: ?*DTCTL,
};

pub const LPDISPATCHNOTIFICATIONS = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ulFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        ulFlags: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const LPCREATECONVERSATIONINDEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        cbParent: u32,
        lpbParent: ?*u8,
        lpcbConvIndex: ?*u32,
        lppbConvIndex: ?*?*u8,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        cbParent: u32,
        lpbParent: ?*u8,
        lpcbConvIndex: ?*u32,
        lppbConvIndex: ?*?*u8,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IAddrBook = extern struct {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        OpenEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulObjType: ?*u32,
                lppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
                lpInterface: ?*Guid,
                ulFlags: u32,
                lpulObjType: ?*u32,
                lppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareEntryIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                cbEntryID1: u32,
                lpEntryID1: ?*ENTRYID,
                cbEntryID2: u32,
                lpEntryID2: ?*ENTRYID,
                ulFlags: u32,
                lpulResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                cbEntryID1: u32,
                lpEntryID1: ?*ENTRYID,
                cbEntryID2: u32,
                lpEntryID2: ?*ENTRYID,
                ulFlags: u32,
                lpulResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
                ulEventMask: u32,
                lpAdviseSink: ?*IMAPIAdviseSink,
                lpulConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
                ulEventMask: u32,
                lpAdviseSink: ?*IMAPIAdviseSink,
                lpulConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateOneOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                lpszName: ?*i8,
                lpszAdrType: ?*i8,
                lpszAddress: ?*i8,
                ulFlags: u32,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                lpszName: ?*i8,
                lpszAdrType: ?*i8,
                lpszAddress: ?*i8,
                ulFlags: u32,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NewEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulUIParam: u32,
                ulFlags: u32,
                cbEIDContainer: u32,
                lpEIDContainer: ?*ENTRYID,
                cbEIDNewEntryTpl: u32,
                lpEIDNewEntryTpl: ?*ENTRYID,
                lpcbEIDNewEntry: ?*u32,
                lppEIDNewEntry: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulUIParam: u32,
                ulFlags: u32,
                cbEIDContainer: u32,
                lpEIDContainer: ?*ENTRYID,
                cbEIDNewEntryTpl: u32,
                lpEIDNewEntryTpl: ?*ENTRYID,
                lpcbEIDNewEntry: ?*u32,
                lppEIDNewEntry: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulUIParam: usize,
                ulFlags: u32,
                lpszNewEntryTitle: ?*i8,
                lpAdrList: ?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulUIParam: usize,
                ulFlags: u32,
                lpszNewEntryTitle: ?*i8,
                lpAdrList: ?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Address: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                lpulUIParam: ?*u32,
                lpAdrParms: ?*ADRPARM,
                lppAdrList: ?*?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                lpulUIParam: ?*u32,
                lpAdrParms: ?*ADRPARM,
                lppAdrList: ?*?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Details: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                lpulUIParam: ?*usize,
                lpfnDismiss: ?LPFNDISMISS,
                lpvDismissContext: ?*anyopaque,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
                lpfButtonCallback: ?LPFNBUTTON,
                lpvButtonContext: ?*anyopaque,
                lpszButtonText: ?*i8,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                lpulUIParam: ?*usize,
                lpfnDismiss: ?LPFNDISMISS,
                lpvDismissContext: ?*anyopaque,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
                lpfButtonCallback: ?LPFNBUTTON,
                lpvButtonContext: ?*anyopaque,
                lpszButtonText: ?*i8,
                ulFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RecipOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulUIParam: u32,
                ulFlags: u32,
                lpRecip: ?*ADRENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulUIParam: u32,
                ulFlags: u32,
                lpRecip: ?*ADRENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryDefaultRecipOpt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                lpszAdrType: ?*i8,
                ulFlags: u32,
                lpcValues: ?*u32,
                lppOptions: ?*?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                lpszAdrType: ?*i8,
                ulFlags: u32,
                lpcValues: ?*u32,
                lppOptions: ?*?*SPropValue,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPAB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPAB: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultDir: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                lpcbEntryID: ?*u32,
                lppEntryID: ?*?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultDir: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                cbEntryID: u32,
                lpEntryID: ?*ENTRYID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSearchPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulFlags: u32,
                lppSearchPath: ?*?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulFlags: u32,
                lppSearchPath: ?*?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSearchPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulFlags: u32,
                lpSearchPath: ?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulFlags: u32,
                lpSearchPath: ?*SRowSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareRecips: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrBook,
                ulFlags: u32,
                lpPropTagArray: ?*SPropTagArray,
                lpRecipList: ?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrBook,
                ulFlags: u32,
                lpPropTagArray: ?*SPropTagArray,
                lpRecipList: ?*ADRLIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IMAPIProp.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_OpenEntry(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, lppUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).OpenEntry(@as(*const IAddrBook, @ptrCast(self)), cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, lppUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_CompareEntryIDs(self: *const T, cbEntryID1: u32, lpEntryID1: ?*ENTRYID, cbEntryID2: u32, lpEntryID2: ?*ENTRYID, ulFlags: u32, lpulResult: ?*u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).CompareEntryIDs(@as(*const IAddrBook, @ptrCast(self)), cbEntryID1, lpEntryID1, cbEntryID2, lpEntryID2, ulFlags, lpulResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_Advise(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Advise(@as(*const IAddrBook, @ptrCast(self)), cbEntryID, lpEntryID, ulEventMask, lpAdviseSink, lpulConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_Unadvise(self: *const T, ulConnection: u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IAddrBook, @ptrCast(self)), ulConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_CreateOneOff(self: *const T, lpszName: ?*i8, lpszAdrType: ?*i8, lpszAddress: ?*i8, ulFlags: u32, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).CreateOneOff(@as(*const IAddrBook, @ptrCast(self)), lpszName, lpszAdrType, lpszAddress, ulFlags, lpcbEntryID, lppEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_NewEntry(self: *const T, ulUIParam: u32, ulFlags: u32, cbEIDContainer: u32, lpEIDContainer: ?*ENTRYID, cbEIDNewEntryTpl: u32, lpEIDNewEntryTpl: ?*ENTRYID, lpcbEIDNewEntry: ?*u32, lppEIDNewEntry: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).NewEntry(@as(*const IAddrBook, @ptrCast(self)), ulUIParam, ulFlags, cbEIDContainer, lpEIDContainer, cbEIDNewEntryTpl, lpEIDNewEntryTpl, lpcbEIDNewEntry, lppEIDNewEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_ResolveName(self: *const T, ulUIParam: usize, ulFlags: u32, lpszNewEntryTitle: ?*i8, lpAdrList: ?*ADRLIST) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).ResolveName(@as(*const IAddrBook, @ptrCast(self)), ulUIParam, ulFlags, lpszNewEntryTitle, lpAdrList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_Address(self: *const T, lpulUIParam: ?*u32, lpAdrParms: ?*ADRPARM, lppAdrList: ?*?*ADRLIST) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Address(@as(*const IAddrBook, @ptrCast(self)), lpulUIParam, lpAdrParms, lppAdrList);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_Details(self: *const T, lpulUIParam: ?*usize, lpfnDismiss: ?LPFNDISMISS, lpvDismissContext: ?*anyopaque, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpfButtonCallback: ?LPFNBUTTON, lpvButtonContext: ?*anyopaque, lpszButtonText: ?*i8, ulFlags: u32) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).Details(@as(*const IAddrBook, @ptrCast(self)), lpulUIParam, lpfnDismiss, lpvDismissContext, cbEntryID, lpEntryID, lpfButtonCallback, lpvButtonContext, lpszButtonText, ulFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_RecipOptions(self: *const T, ulUIParam: u32, ulFlags: u32, lpRecip: ?*ADRENTRY) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).RecipOptions(@as(*const IAddrBook, @ptrCast(self)), ulUIParam, ulFlags, lpRecip);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_QueryDefaultRecipOpt(self: *const T, lpszAdrType: ?*i8, ulFlags: u32, lpcValues: ?*u32, lppOptions: ?*?*SPropValue) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).QueryDefaultRecipOpt(@as(*const IAddrBook, @ptrCast(self)), lpszAdrType, ulFlags, lpcValues, lppOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_GetPAB(self: *const T, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).GetPAB(@as(*const IAddrBook, @ptrCast(self)), lpcbEntryID, lppEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_SetPAB(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).SetPAB(@as(*const IAddrBook, @ptrCast(self)), cbEntryID, lpEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_GetDefaultDir(self: *const T, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).GetDefaultDir(@as(*const IAddrBook, @ptrCast(self)), lpcbEntryID, lppEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_SetDefaultDir(self: *const T, cbEntryID: u32, lpEntryID: ?*ENTRYID) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).SetDefaultDir(@as(*const IAddrBook, @ptrCast(self)), cbEntryID, lpEntryID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_GetSearchPath(self: *const T, ulFlags: u32, lppSearchPath: ?*?*SRowSet) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).GetSearchPath(@as(*const IAddrBook, @ptrCast(self)), ulFlags, lppSearchPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_SetSearchPath(self: *const T, ulFlags: u32, lpSearchPath: ?*SRowSet) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).SetSearchPath(@as(*const IAddrBook, @ptrCast(self)), ulFlags, lpSearchPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrBook_PrepareRecips(self: *const T, ulFlags: u32, lpPropTagArray: ?*SPropTagArray, lpRecipList: ?*ADRLIST) HRESULT {
                return @as(*const IAddrBook.VTable, @ptrCast(self.vtable)).PrepareRecips(@as(*const IAddrBook, @ptrCast(self)), ulFlags, lpPropTagArray, lpRecipList);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _WABACTIONITEM = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type is limited to platform 'windows5.0'
pub const IWABObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                cbSize: u32,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                cbSize: u32,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateMore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                cbSize: u32,
                lpObject: ?*anyopaque,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                cbSize: u32,
                lpObject: ?*anyopaque,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpBuffer: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpBuffer: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Backup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpWIP: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpWIP: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Find: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VCardDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                lpszFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                lpszFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LDAPUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                ulFlags: u32,
                lpszURL: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                ulFlags: u32,
                lpszURL: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VCardCreate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lpMailUser: ?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lpMailUser: ?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VCardRetrieve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpdwAction: ?*u32,
                lpsbEID: ?*SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpdwAction: ?*u32,
                lpsbEID: ?*SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                sbEID: SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABObject,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                sbEID: SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IWABObject, @ptrCast(self)), hResult, ulFlags, lppMAPIError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_AllocateBuffer(self: *const T, cbSize: u32, lppBuffer: ?*?*anyopaque) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).AllocateBuffer(@as(*const IWABObject, @ptrCast(self)), cbSize, lppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_AllocateMore(self: *const T, cbSize: u32, lpObject: ?*anyopaque, lppBuffer: ?*?*anyopaque) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).AllocateMore(@as(*const IWABObject, @ptrCast(self)), cbSize, lpObject, lppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_FreeBuffer(self: *const T, lpBuffer: ?*anyopaque) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).FreeBuffer(@as(*const IWABObject, @ptrCast(self)), lpBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_Backup(self: *const T, lpFileName: ?PSTR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).Backup(@as(*const IWABObject, @ptrCast(self)), lpFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_Import(self: *const T, lpWIP: ?PSTR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).Import(@as(*const IWABObject, @ptrCast(self)), lpWIP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_Find(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).Find(@as(*const IWABObject, @ptrCast(self)), lpIAB, hWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_VCardDisplay(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, lpszFileName: ?PSTR) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).VCardDisplay(@as(*const IWABObject, @ptrCast(self)), lpIAB, hWnd, lpszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_LDAPUrl(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, ulFlags: u32, lpszURL: ?PSTR, lppMailUser: ?*?*IMailUser) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).LDAPUrl(@as(*const IWABObject, @ptrCast(self)), lpIAB, hWnd, ulFlags, lpszURL, lppMailUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_VCardCreate(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lpMailUser: ?*IMailUser) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).VCardCreate(@as(*const IWABObject, @ptrCast(self)), lpIAB, ulFlags, lpszVCard, lpMailUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_VCardRetrieve(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lppMailUser: ?*?*IMailUser) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).VCardRetrieve(@as(*const IWABObject, @ptrCast(self)), lpIAB, ulFlags, lpszVCard, lppMailUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_GetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpdwAction: ?*u32, lpsbEID: ?*SBinary, hwnd: ?HWND) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).GetMe(@as(*const IWABObject, @ptrCast(self)), lpIAB, ulFlags, lpdwAction, lpsbEID, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABObject_SetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, sbEID: SBinary, hwnd: ?HWND) HRESULT {
                return @as(*const IWABObject.VTable, @ptrCast(self.vtable)).SetMe(@as(*const IWABObject, @ptrCast(self)), lpIAB, ulFlags, sbEID, hwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IWABOBJECT_QueryInterface_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        riid: ?*const Guid,
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        riid: ?*const Guid,
        ppvObj: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_AddRef_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) u32,
};

pub const IWABOBJECT_Release_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) u32,
};

pub const IWABOBJECT_GetLastError_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hResult: HRESULT,
        ulFlags: u32,
        lppMAPIError: ?*?*MAPIERROR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        hResult: HRESULT,
        ulFlags: u32,
        lppMAPIError: ?*?*MAPIERROR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_AllocateBuffer_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        cbSize: u32,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        cbSize: u32,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_AllocateMore_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        cbSize: u32,
        lpObject: ?*anyopaque,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        cbSize: u32,
        lpObject: ?*anyopaque,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_FreeBuffer_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpBuffer: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpBuffer: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_Backup_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpFileName: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpFileName: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_Import_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpWIP: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpWIP: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_Find_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        hWnd: ?HWND,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        hWnd: ?HWND,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_VCardDisplay_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        hWnd: ?HWND,
        lpszFileName: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        hWnd: ?HWND,
        lpszFileName: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_LDAPUrl_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        hWnd: ?HWND,
        ulFlags: u32,
        lpszURL: ?PSTR,
        lppMailUser: ?*?*IMailUser,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        hWnd: ?HWND,
        ulFlags: u32,
        lpszURL: ?PSTR,
        lppMailUser: ?*?*IMailUser,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_VCardCreate_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        lpszVCard: ?PSTR,
        lpMailUser: ?*IMailUser,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        lpszVCard: ?PSTR,
        lpMailUser: ?*IMailUser,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_VCardRetrieve_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        lpszVCard: ?PSTR,
        lppMailUser: ?*?*IMailUser,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        lpszVCard: ?PSTR,
        lppMailUser: ?*?*IMailUser,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_GetMe_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        lpdwAction: ?*u32,
        lpsbEID: ?*SBinary,
        hwnd: ?HWND,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        lpdwAction: ?*u32,
        lpsbEID: ?*SBinary,
        hwnd: ?HWND,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_SetMe_METHOD = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        sbEID: SBinary,
        hwnd: ?HWND,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lpIAB: ?*IAddrBook,
        ulFlags: u32,
        sbEID: SBinary,
        hwnd: ?HWND,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const IWABOBJECT_ = extern struct {
    pub const VTable = extern struct {
        QueryInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IWABOBJECT_,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Release: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IWABOBJECT_,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetLastError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                hResult: HRESULT,
                ulFlags: u32,
                lppMAPIError: ?*?*MAPIERROR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                cbSize: u32,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                cbSize: u32,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateMore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                cbSize: u32,
                lpObject: ?*anyopaque,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                cbSize: u32,
                lpObject: ?*anyopaque,
                lppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpBuffer: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpBuffer: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Backup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Import: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpWIP: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpWIP: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Find: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VCardDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                lpszFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                lpszFileName: ?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LDAPUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                ulFlags: u32,
                lpszURL: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                hWnd: ?HWND,
                ulFlags: u32,
                lpszURL: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VCardCreate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lpMailUser: ?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lpMailUser: ?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VCardRetrieve: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpszVCard: ?PSTR,
                lppMailUser: ?*?*IMailUser,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpdwAction: ?*u32,
                lpsbEID: ?*SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                lpdwAction: ?*u32,
                lpsbEID: ?*SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMe: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                sbEID: SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABOBJECT_,
                lpIAB: ?*IAddrBook,
                ulFlags: u32,
                sbEID: SBinary,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__QueryInterface(self: *const T, riid: ?*const Guid, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).QueryInterface(@as(*const IWABOBJECT_, @ptrCast(self)), riid, ppvObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__AddRef(self: *const T) u32 {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).AddRef(@as(*const IWABOBJECT_, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__Release(self: *const T) u32 {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Release(@as(*const IWABOBJECT_, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__GetLastError(self: *const T, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).GetLastError(@as(*const IWABOBJECT_, @ptrCast(self)), hResult, ulFlags, lppMAPIError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__AllocateBuffer(self: *const T, cbSize: u32, lppBuffer: ?*?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).AllocateBuffer(@as(*const IWABOBJECT_, @ptrCast(self)), cbSize, lppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__AllocateMore(self: *const T, cbSize: u32, lpObject: ?*anyopaque, lppBuffer: ?*?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).AllocateMore(@as(*const IWABOBJECT_, @ptrCast(self)), cbSize, lpObject, lppBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__FreeBuffer(self: *const T, lpBuffer: ?*anyopaque) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).FreeBuffer(@as(*const IWABOBJECT_, @ptrCast(self)), lpBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__Backup(self: *const T, lpFileName: ?PSTR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Backup(@as(*const IWABOBJECT_, @ptrCast(self)), lpFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__Import(self: *const T, lpWIP: ?PSTR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Import(@as(*const IWABOBJECT_, @ptrCast(self)), lpWIP);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__Find(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).Find(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, hWnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__VCardDisplay(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, lpszFileName: ?PSTR) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).VCardDisplay(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, hWnd, lpszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__LDAPUrl(self: *const T, lpIAB: ?*IAddrBook, hWnd: ?HWND, ulFlags: u32, lpszURL: ?PSTR, lppMailUser: ?*?*IMailUser) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).LDAPUrl(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, hWnd, ulFlags, lpszURL, lppMailUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__VCardCreate(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lpMailUser: ?*IMailUser) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).VCardCreate(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, ulFlags, lpszVCard, lpMailUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__VCardRetrieve(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lppMailUser: ?*?*IMailUser) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).VCardRetrieve(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, ulFlags, lpszVCard, lppMailUser);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__GetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, lpdwAction: ?*u32, lpsbEID: ?*SBinary, hwnd: ?HWND) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).GetMe(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, ulFlags, lpdwAction, lpsbEID, hwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABOBJECT__SetMe(self: *const T, lpIAB: ?*IAddrBook, ulFlags: u32, sbEID: SBinary, hwnd: ?HWND) HRESULT {
                return @as(*const IWABOBJECT_.VTable, @ptrCast(self.vtable)).SetMe(@as(*const IWABOBJECT_, @ptrCast(self)), lpIAB, ulFlags, sbEID, hwnd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WAB_PARAM = extern struct {
    cbSize: u32,
    hwnd: ?HWND,
    szFileName: ?PSTR,
    ulFlags: u32,
    guidPSExt: Guid,
};

pub const LPWABOPEN = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lppAdrBook: ?*?*IAddrBook,
        lppWABObject: ?*?*IWABObject,
        lpWP: ?*WAB_PARAM,
        Reserved2: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lppAdrBook: ?*?*IAddrBook,
        lppWABObject: ?*?*IWABObject,
        lpWP: ?*WAB_PARAM,
        Reserved2: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const LPWABOPENEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lppAdrBook: ?*?*IAddrBook,
        lppWABObject: ?*?*IWABObject,
        lpWP: ?*WAB_PARAM,
        Reserved: u32,
        fnAllocateBuffer: ?LPALLOCATEBUFFER,
        fnAllocateMore: ?LPALLOCATEMORE,
        fnFreeBuffer: ?LPFREEBUFFER,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        lppAdrBook: ?*?*IAddrBook,
        lppWABObject: ?*?*IWABObject,
        lpWP: ?*WAB_PARAM,
        Reserved: u32,
        fnAllocateBuffer: ?LPALLOCATEBUFFER,
        fnAllocateMore: ?LPALLOCATEMORE,
        fnFreeBuffer: ?LPFREEBUFFER,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const WABIMPORTPARAM = extern struct {
    cbSize: u32,
    lpAdrBook: ?*IAddrBook,
    hWnd: ?HWND,
    ulFlags: u32,
    lpszFileName: ?PSTR,
};

pub const WABEXTDISPLAY = extern struct {
    cbSize: u32,
    lpWABObject: ?*IWABObject,
    lpAdrBook: ?*IAddrBook,
    lpPropObj: ?*IMAPIProp,
    fReadOnly: BOOL,
    fDataChanged: BOOL,
    ulFlags: u32,
    lpv: ?*anyopaque,
    lpsz: ?*i8,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWABExtInit_Value = Guid.initString("ea22ebf0-87a4-11d1-9acf-00a0c91f9c8b");
pub const IID_IWABExtInit = &IID_IWABExtInit_Value;
pub const IWABExtInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWABExtInit,
                lpWABExtDisplay: ?*WABEXTDISPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWABExtInit,
                lpWABExtDisplay: ?*WABEXTDISPLAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWABExtInit_Initialize(self: *const T, lpWABExtDisplay: ?*WABEXTDISPLAY) HRESULT {
                return @as(*const IWABExtInit.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWABExtInit, @ptrCast(self)), lpWABExtDisplay);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const LPWABALLOCATEBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpWABObject: ?*IWABObject,
        cbSize: u32,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        lpWABObject: ?*IWABObject,
        cbSize: u32,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const LPWABALLOCATEMORE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpWABObject: ?*IWABObject,
        cbSize: u32,
        lpObject: ?*anyopaque,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        lpWABObject: ?*IWABObject,
        cbSize: u32,
        lpObject: ?*anyopaque,
        lppBuffer: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const LPWABFREEBUFFER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpWABObject: ?*IWABObject,
        lpBuffer: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        lpWABObject: ?*IWABObject,
        lpBuffer: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const NOTIFKEY = extern struct {
    cb: u32,
    ab: [1]u8,
};

//--------------------------------------------------------------------------------
// Section: Functions (57)
//--------------------------------------------------------------------------------
pub extern "rtm" fn CreateTable(
    lpInterface: ?*Guid,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpvReserved: ?*anyopaque,
    ulTableType: u32,
    ulPropTagIndexColumn: u32,
    lpSPropTagArrayColumns: ?*SPropTagArray,
    lppTableData: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn CreateIProp(
    lpInterface: ?*Guid,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpvReserved: ?*anyopaque,
    lppPropData: ?*?*IPropData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn MAPIInitIdle(
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn MAPIDeinitIdle() callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtgRegisterIdleRoutine(
    lpfnIdle: ?PFNIDLE,
    lpvIdleParam: ?*anyopaque,
    priIdle: i16,
    csecIdle: u32,
    iroIdle: u16,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "mapi32" fn DeregisterIdleRoutine(
    ftg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn EnableIdleRoutine(
    ftg: ?*anyopaque,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn ChangeIdleRoutine(
    ftg: ?*anyopaque,
    lpfnIdle: ?PFNIDLE,
    lpvIdleParam: ?*anyopaque,
    priIdle: i16,
    csecIdle: u32,
    iroIdle: u16,
    ircIdle: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn MAPIGetDefaultMalloc() callconv(@import("std").os.windows.WINAPI) ?*IMalloc;

pub extern "mapi32" fn OpenStreamOnFile(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    ulFlags: u32,
    lpszFileName: ?*i8,
    lpszPrefix: ?*i8,
    lppStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn PropCopyMore(
    lpSPropValueDest: ?*SPropValue,
    lpSPropValueSrc: ?*SPropValue,
    lpfAllocMore: ?LPALLOCATEMORE,
    lpvObject: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn UlPropSize(
    lpSPropValue: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn FEqualNames(
    lpName1: ?*MAPINAMEID,
    lpName2: ?*MAPINAMEID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn FPropContainsProp(
    lpSPropValueDst: ?*SPropValue,
    lpSPropValueSrc: ?*SPropValue,
    ulFuzzyLevel: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn FPropCompareProp(
    lpSPropValue1: ?*SPropValue,
    ulRelOp: u32,
    lpSPropValue2: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn LPropCompareProp(
    lpSPropValueA: ?*SPropValue,
    lpSPropValueB: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn HrAddColumns(
    lptbl: ?*IMAPITable,
    lpproptagColumnsNew: ?*SPropTagArray,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrAddColumnsEx(
    lptbl: ?*IMAPITable,
    lpproptagColumnsNew: ?*SPropTagArray,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpfnFilterColumns: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrAllocAdviseSink(
    lpfnCallback: ?LPNOTIFCALLBACK,
    lpvContext: ?*anyopaque,
    lppAdviseSink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrThisThreadAdviseSink(
    lpAdviseSink: ?*IMAPIAdviseSink,
    lppAdviseSink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrDispatchNotifications(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn BuildDisplayTable(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpMalloc: ?*IMalloc,
    hInstance: ?HINSTANCE,
    cPages: u32,
    lpPage: ?*DTPAGE,
    ulFlags: u32,
    lppTable: ?*?*IMAPITable,
    lppTblData: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn ScCountNotifications(
    cNotifications: i32,
    lpNotifications: ?*NOTIFICATION,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScCopyNotifications(
    cNotification: i32,
    lpNotifications: ?*NOTIFICATION,
    lpvDst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScRelocNotifications(
    cNotification: i32,
    lpNotifications: ?*NOTIFICATION,
    lpvBaseOld: ?*anyopaque,
    lpvBaseNew: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScCountProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn LpValFindProp(
    ulPropTag: u32,
    cValues: u32,
    lpPropArray: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "mapi32" fn ScCopyProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpvDst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScRelocProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpvBaseOld: ?*anyopaque,
    lpvBaseNew: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScDupPropset(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lppPropArray: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn UlAddRef(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn UlRelease(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn HrGetOneProp(
    lpMapiProp: ?*IMAPIProp,
    ulPropTag: u32,
    lppProp: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrSetOneProp(
    lpMapiProp: ?*IMAPIProp,
    lpProp: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn FPropExists(
    lpMapiProp: ?*IMAPIProp,
    ulPropTag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn PpropFindProp(
    lpPropArray: ?*SPropValue,
    cValues: u32,
    ulPropTag: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "mapi32" fn FreePadrlist(
    lpAdrlist: ?*ADRLIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FreeProws(
    lpRows: ?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn HrQueryAllRows(
    lpTable: ?*IMAPITable,
    lpPropTags: ?*SPropTagArray,
    lpRestriction: ?*SRestriction,
    lpSortOrderSet: ?*SSortOrderSet,
    crowsMax: i32,
    lppRows: ?*?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn SzFindCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn SzFindLastCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn SzFindSz(
    lpsz: ?*i8,
    lpszKey: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn UFromSz(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn ScUNCFromLocalPath(
    lpszLocal: ?PSTR,
    lpszUNC: [*:0]u8,
    cchUNC: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScLocalPathFromUNC(
    lpszUNC: ?PSTR,
    lpszLocal: [*:0]u8,
    cchLocal: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn FtAddFt(
    ftAddend1: FILETIME,
    ftAddend2: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtMulDwDw(
    ftMultiplicand: u32,
    ftMultiplier: u32,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtMulDw(
    ftMultiplier: u32,
    ftMultiplicand: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtSubFt(
    ftMinuend: FILETIME,
    ftSubtrahend: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtNegFt(
    ft: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn ScCreateConversationIndex(
    cbParent: u32,
    lpbParent: ?*u8,
    lpcbConvIndex: ?*u32,
    lppbConvIndex: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn WrapStoreEntryID(
    ulFlags: u32,
    lpszDLLName: ?*i8,
    cbOrigEntry: u32,
    // TODO: what to do with BytesParamIndex 2?
    lpOrigEntry: ?*ENTRYID,
    lpcbWrappedEntry: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    lppWrappedEntry: ?*?*ENTRYID,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn RTFSync(
    lpMessage: ?*IMessage,
    ulFlags: u32,
    lpfMessageUpdated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn WrapCompressedRTFStream(
    lpCompressedRTFStream: ?*IStream,
    ulFlags: u32,
    lpUncompressedRTFStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrIStorageFromStream(
    lpUnkIn: ?*IUnknown,
    lpInterface: ?*Guid,
    ulFlags: u32,
    lppStorageOut: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn ScInitMapiUtil(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn DeinitMapiUtil() callconv(@import("std").os.windows.WINAPI) void;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CY = @import("../system/com.zig").CY;
const FILETIME = @import("../foundation.zig").FILETIME;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMalloc = @import("../system/com.zig").IMalloc;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPALLOCATEBUFFER")) {
        _ = LPALLOCATEBUFFER;
    }
    if (@hasDecl(@This(), "LPALLOCATEMORE")) {
        _ = LPALLOCATEMORE;
    }
    if (@hasDecl(@This(), "LPFREEBUFFER")) {
        _ = LPFREEBUFFER;
    }
    if (@hasDecl(@This(), "LPNOTIFCALLBACK")) {
        _ = LPNOTIFCALLBACK;
    }
    if (@hasDecl(@This(), "LPFNABSDI")) {
        _ = LPFNABSDI;
    }
    if (@hasDecl(@This(), "LPFNDISMISS")) {
        _ = LPFNDISMISS;
    }
    if (@hasDecl(@This(), "LPFNBUTTON")) {
        _ = LPFNBUTTON;
    }
    if (@hasDecl(@This(), "FNIDLE")) {
        _ = FNIDLE;
    }
    if (@hasDecl(@This(), "PFNIDLE")) {
        _ = PFNIDLE;
    }
    if (@hasDecl(@This(), "LPOPENSTREAMONFILE")) {
        _ = LPOPENSTREAMONFILE;
    }
    if (@hasDecl(@This(), "LPDISPATCHNOTIFICATIONS")) {
        _ = LPDISPATCHNOTIFICATIONS;
    }
    if (@hasDecl(@This(), "LPCREATECONVERSATIONINDEX")) {
        _ = LPCREATECONVERSATIONINDEX;
    }
    if (@hasDecl(@This(), "IWABOBJECT_QueryInterface_METHOD")) {
        _ = IWABOBJECT_QueryInterface_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_AddRef_METHOD")) {
        _ = IWABOBJECT_AddRef_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Release_METHOD")) {
        _ = IWABOBJECT_Release_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_GetLastError_METHOD")) {
        _ = IWABOBJECT_GetLastError_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateBuffer_METHOD")) {
        _ = IWABOBJECT_AllocateBuffer_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateMore_METHOD")) {
        _ = IWABOBJECT_AllocateMore_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_FreeBuffer_METHOD")) {
        _ = IWABOBJECT_FreeBuffer_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Backup_METHOD")) {
        _ = IWABOBJECT_Backup_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Import_METHOD")) {
        _ = IWABOBJECT_Import_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_Find_METHOD")) {
        _ = IWABOBJECT_Find_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_VCardDisplay_METHOD")) {
        _ = IWABOBJECT_VCardDisplay_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_LDAPUrl_METHOD")) {
        _ = IWABOBJECT_LDAPUrl_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_VCardCreate_METHOD")) {
        _ = IWABOBJECT_VCardCreate_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_VCardRetrieve_METHOD")) {
        _ = IWABOBJECT_VCardRetrieve_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_GetMe_METHOD")) {
        _ = IWABOBJECT_GetMe_METHOD;
    }
    if (@hasDecl(@This(), "IWABOBJECT_SetMe_METHOD")) {
        _ = IWABOBJECT_SetMe_METHOD;
    }
    if (@hasDecl(@This(), "LPWABOPEN")) {
        _ = LPWABOPEN;
    }
    if (@hasDecl(@This(), "LPWABOPENEX")) {
        _ = LPWABOPENEX;
    }
    if (@hasDecl(@This(), "LPWABALLOCATEBUFFER")) {
        _ = LPWABALLOCATEBUFFER;
    }
    if (@hasDecl(@This(), "LPWABALLOCATEMORE")) {
        _ = LPWABALLOCATEMORE;
    }
    if (@hasDecl(@This(), "LPWABFREEBUFFER")) {
        _ = LPWABFREEBUFFER;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
