//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (218)
//--------------------------------------------------------------------------------
pub const PROP_ID_SECURE_MIN = @as(u32, 26608);
pub const PROP_ID_SECURE_MAX = @as(u32, 26623);
pub const MAPI_DIM = @as(u32, 1);
pub const fMapiUnicode = @as(u32, 0);
pub const hrSuccess = @as(u32, 0);
pub const MAPI_P1 = @as(u32, 268435456);
pub const MAPI_SUBMITTED = @as(u32, 2147483648);
pub const MAPI_SHORTTERM = @as(u32, 128);
pub const MAPI_NOTRECIP = @as(u32, 64);
pub const MAPI_THISSESSION = @as(u32, 32);
pub const MAPI_NOW = @as(u32, 16);
pub const MAPI_NOTRESERVED = @as(u32, 8);
pub const MAPI_COMPOUND = @as(u32, 128);
pub const cchProfileNameMax = @as(u32, 64);
pub const cchProfilePassMax = @as(u32, 64);
pub const MV_FLAG = @as(u32, 4096);
pub const PROP_ID_NULL = @as(u32, 0);
pub const PROP_ID_INVALID = @as(u32, 65535);
pub const MV_INSTANCE = @as(u32, 8192);
pub const TABLE_CHANGED = @as(u32, 1);
pub const TABLE_ERROR = @as(u32, 2);
pub const TABLE_ROW_ADDED = @as(u32, 3);
pub const TABLE_ROW_DELETED = @as(u32, 4);
pub const TABLE_ROW_MODIFIED = @as(u32, 5);
pub const TABLE_SORT_DONE = @as(u32, 6);
pub const TABLE_RESTRICT_DONE = @as(u32, 7);
pub const TABLE_SETCOL_DONE = @as(u32, 8);
pub const TABLE_RELOAD = @as(u32, 9);
pub const szMAPINotificationMsg = "MAPI Notify window message";
pub const MAPI_ERROR_VERSION = @as(i32, 0);
pub const MAPI_USE_DEFAULT = @as(u32, 64);
pub const MNID_ID = @as(u32, 0);
pub const MNID_STRING = @as(u32, 1);
pub const WAB_LOCAL_CONTAINERS = @as(u32, 1048576);
pub const WAB_PROFILE_CONTENTS = @as(u32, 2097152);
pub const WAB_IGNORE_PROFILES = @as(u32, 8388608);
pub const MAPI_ONE_OFF_NO_RICH_INFO = @as(u32, 1);
pub const UI_SERVICE = @as(u32, 2);
pub const SERVICE_UI_ALWAYS = @as(u32, 2);
pub const SERVICE_UI_ALLOWED = @as(u32, 16);
pub const UI_CURRENT_PROVIDER_FIRST = @as(u32, 4);
pub const WABOBJECT_LDAPURL_RETURN_MAILUSER = @as(u32, 1);
pub const WABOBJECT_ME_NEW = @as(u32, 1);
pub const WABOBJECT_ME_NOCREATE = @as(u32, 2);
pub const WAB_VCARD_FILE = @as(u32, 0);
pub const WAB_VCARD_STREAM = @as(u32, 1);
pub const WAB_USE_OE_SENDMAIL = @as(u32, 1);
pub const WAB_ENABLE_PROFILES = @as(u32, 4194304);
pub const WAB_DISPLAY_LDAPURL = @as(u32, 1);
pub const WAB_CONTEXT_ADRLIST = @as(u32, 2);
pub const WAB_DISPLAY_ISNTDS = @as(u32, 4);
pub const WAB_DLL_NAME = "WAB32.DLL";
pub const WAB_DLL_PATH_KEY = "Software\\Microsoft\\WAB\\DLLPath";
pub const E_IMAPI_REQUEST_CANCELLED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600702));
pub const E_IMAPI_RECORDER_REQUIRED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600701));
pub const S_IMAPI_SPEEDADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141124));
pub const S_IMAPI_ROTATIONADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141125));
pub const S_IMAPI_BOTHADJUSTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141126));
pub const E_IMAPI_BURN_VERIFICATION_FAILED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600697));
pub const S_IMAPI_COMMAND_HAS_SENSE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141632));
pub const E_IMAPI_RECORDER_NO_SUCH_MODE_PAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600191));
pub const E_IMAPI_RECORDER_MEDIA_NO_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600190));
pub const E_IMAPI_RECORDER_MEDIA_INCOMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600189));
pub const E_IMAPI_RECORDER_MEDIA_UPSIDE_DOWN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600188));
pub const E_IMAPI_RECORDER_MEDIA_BECOMING_READY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600187));
pub const E_IMAPI_RECORDER_MEDIA_FORMAT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600186));
pub const E_IMAPI_RECORDER_MEDIA_BUSY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600185));
pub const E_IMAPI_RECORDER_INVALID_MODE_PARAMETERS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600184));
pub const E_IMAPI_RECORDER_MEDIA_WRITE_PROTECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600183));
pub const E_IMAPI_RECORDER_NO_SUCH_FEATURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600182));
pub const E_IMAPI_RECORDER_FEATURE_IS_NOT_CURRENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600181));
pub const E_IMAPI_RECORDER_GET_CONFIGURATION_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600180));
pub const E_IMAPI_RECORDER_COMMAND_TIMEOUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600179));
pub const E_IMAPI_RECORDER_DVD_STRUCTURE_NOT_PRESENT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600178));
pub const E_IMAPI_RECORDER_MEDIA_SPEED_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600177));
pub const E_IMAPI_RECORDER_LOCKED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600176));
pub const E_IMAPI_RECORDER_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600175));
pub const E_IMAPI_RECORDER_MEDIA_NOT_FORMATTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062600174));
pub const E_IMAPI_RECORDER_INVALID_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599937));
pub const E_IMAPI_LOSS_OF_STREAMING = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599936));
pub const E_IMAPI_UNEXPECTED_RESPONSE_FROM_DEVICE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599935));
pub const S_IMAPI_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11141890));
pub const E_IMAPI_DF2DATA_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599680));
pub const E_IMAPI_DF2DATA_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599679));
pub const E_IMAPI_DF2DATA_INVALID_MEDIA_STATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599678));
pub const E_IMAPI_DF2DATA_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599677));
pub const E_IMAPI_DF2DATA_STREAM_TOO_LARGE_FOR_CURRENT_MEDIA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599676));
pub const E_IMAPI_DF2DATA_MEDIA_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599675));
pub const E_IMAPI_DF2DATA_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599674));
pub const E_IMAPI_DF2DATA_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599673));
pub const E_IMAPI_DF2DATA_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599672));
pub const E_IMAPI_DF2TAO_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599424));
pub const E_IMAPI_DF2TAO_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599423));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599422));
pub const E_IMAPI_DF2TAO_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599421));
pub const E_IMAPI_DF2TAO_PROPERTY_FOR_BLANK_MEDIA_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599420));
pub const E_IMAPI_DF2TAO_TABLE_OF_CONTENTS_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599419));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599418));
pub const E_IMAPI_DF2TAO_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599417));
pub const E_IMAPI_DF2TAO_TRACK_LIMIT_REACHED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599416));
pub const E_IMAPI_DF2TAO_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599415));
pub const E_IMAPI_DF2TAO_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599414));
pub const E_IMAPI_DF2TAO_INVALID_ISRC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599413));
pub const E_IMAPI_DF2TAO_INVALID_MCN = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599412));
pub const E_IMAPI_DF2TAO_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599411));
pub const E_IMAPI_DF2TAO_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599410));
pub const E_IMAPI_DF2TAO_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599409));
pub const E_IMAPI_DF2RAW_WRITE_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599168));
pub const E_IMAPI_DF2RAW_WRITE_NOT_IN_PROGRESS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599167));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599166));
pub const E_IMAPI_DF2RAW_MEDIA_IS_PREPARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599165));
pub const E_IMAPI_DF2RAW_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599164));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_BLANK = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599162));
pub const E_IMAPI_DF2RAW_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599161));
pub const E_IMAPI_DF2RAW_NOT_ENOUGH_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599159));
pub const E_IMAPI_DF2RAW_NO_RECORDER_SPECIFIED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599158));
pub const E_IMAPI_DF2RAW_STREAM_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599155));
pub const E_IMAPI_DF2RAW_DATA_BLOCK_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599154));
pub const E_IMAPI_DF2RAW_STREAM_LEADIN_TOO_SHORT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599153));
pub const E_IMAPI_DF2RAW_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062599152));
pub const E_IMAPI_ERASE_RECORDER_IN_USE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340224));
pub const E_IMAPI_ERASE_ONLY_ONE_RECORDER_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340223));
pub const E_IMAPI_ERASE_DISC_INFORMATION_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340222));
pub const E_IMAPI_ERASE_MODE_PAGE_2A_TOO_SMALL = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340221));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_ERASABLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340220));
pub const E_IMAPI_ERASE_DRIVE_FAILED_ERASE_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340219));
pub const E_IMAPI_ERASE_TOOK_LONGER_THAN_ONE_HOUR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340218));
pub const E_IMAPI_ERASE_UNEXPECTED_DRIVE_RESPONSE_DURING_ERASE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340217));
pub const E_IMAPI_ERASE_DRIVE_FAILED_SPINUP_COMMAND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136340216));
pub const E_IMAPI_ERASE_MEDIA_IS_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598391));
pub const E_IMAPI_ERASE_RECORDER_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598390));
pub const E_IMAPI_ERASE_CLIENT_NAME_IS_NOT_VALID = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062598389));
pub const E_IMAPI_RAW_IMAGE_IS_READ_ONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339968));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339967));
pub const E_IMAPI_RAW_IMAGE_SECTOR_TYPE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339966));
pub const E_IMAPI_RAW_IMAGE_NO_TRACKS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339965));
pub const E_IMAPI_RAW_IMAGE_TRACKS_ALREADY_ADDED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339964));
pub const E_IMAPI_RAW_IMAGE_INSUFFICIENT_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339963));
pub const E_IMAPI_RAW_IMAGE_TOO_MANY_TRACK_INDEXES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339962));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339961));
pub const S_IMAPI_RAW_IMAGE_TRACK_INDEX_ALREADY_EXISTS = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11143688));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_OFFSET_ZERO_CANNOT_BE_CLEARED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339959));
pub const E_IMAPI_RAW_IMAGE_TRACK_INDEX_TOO_CLOSE_TO_OTHER_INDEX = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2136339958));
pub const FACILITY_IMAPI2 = @as(u32, 170);
pub const IMAPI_E_FSI_INTERNAL_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555392));
pub const IMAPI_E_INVALID_PARAM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555391));
pub const IMAPI_E_READONLY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555390));
pub const IMAPI_E_NO_OUTPUT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555389));
pub const IMAPI_E_INVALID_VOLUME_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555388));
pub const IMAPI_E_INVALID_DATE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555387));
pub const IMAPI_E_FILE_SYSTEM_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555386));
pub const IMAPI_E_NOT_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555384));
pub const IMAPI_E_NOT_DIR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555383));
pub const IMAPI_E_DIR_NOT_EMPTY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555382));
pub const IMAPI_E_NOT_IN_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555381));
pub const IMAPI_E_INVALID_PATH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555376));
pub const IMAPI_E_RESTRICTED_NAME_VIOLATION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555375));
pub const IMAPI_E_DUP_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555374));
pub const IMAPI_E_NO_UNIQUE_NAME = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555373));
pub const IMAPI_E_ITEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555368));
pub const IMAPI_E_FILE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555367));
pub const IMAPI_E_DIR_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555366));
pub const IMAPI_E_IMAGE_SIZE_LIMIT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555360));
pub const IMAPI_E_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555359));
pub const IMAPI_E_DATA_STREAM_INCONSISTENCY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555352));
pub const IMAPI_E_DATA_STREAM_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555351));
pub const IMAPI_E_DATA_STREAM_CREATE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555350));
pub const IMAPI_E_DIRECTORY_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555349));
pub const IMAPI_E_TOO_MANY_DIRS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555344));
pub const IMAPI_E_ISO9660_LEVELS = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555343));
pub const IMAPI_E_DATA_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555342));
pub const IMAPI_E_INCOMPATIBLE_PREVIOUS_SESSION = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555341));
pub const IMAPI_E_STASHFILE_OPEN_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555336));
pub const IMAPI_E_STASHFILE_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555335));
pub const IMAPI_E_STASHFILE_WRITE_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555334));
pub const IMAPI_E_STASHFILE_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555333));
pub const IMAPI_E_INVALID_WORKING_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555328));
pub const IMAPI_E_WORKING_DIRECTORY_SPACE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555327));
pub const IMAPI_E_STASHFILE_MOVE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555326));
pub const IMAPI_E_BOOT_IMAGE_DATA = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555320));
pub const IMAPI_E_BOOT_OBJECT_CONFLICT = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555319));
pub const IMAPI_E_BOOT_EMULATION_IMAGE_SIZE_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555318));
pub const IMAPI_E_EMPTY_DISC = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555312));
pub const IMAPI_E_NO_SUPPORTED_FILE_SYSTEM = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555311));
pub const IMAPI_E_FILE_SYSTEM_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555310));
pub const IMAPI_E_FILE_SYSTEM_READ_CONSISTENCY_ERROR = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555309));
pub const IMAPI_E_FILE_SYSTEM_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555308));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_FILE_EXISTS_AS_DIRECTORY = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555307));
pub const IMAPI_E_IMPORT_SEEK_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555306));
pub const IMAPI_E_IMPORT_READ_FAILURE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555305));
pub const IMAPI_E_DISC_MISMATCH = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555304));
pub const IMAPI_E_IMPORT_MEDIA_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555303));
pub const IMAPI_E_UDF_NOT_WRITE_COMPATIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555302));
pub const IMAPI_E_INCOMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555301));
pub const IMAPI_E_NO_COMPATIBLE_MULTISESSION_TYPE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555300));
pub const IMAPI_E_MULTISESSION_NOT_SET = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555299));
pub const IMAPI_E_IMPORT_TYPE_COLLISION_DIRECTORY_EXISTS_AS_FILE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555298));
pub const IMAPI_S_IMAGE_FEATURE_NOT_SUPPORTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, 11186527));
pub const IMAPI_E_PROPERTY_NOT_ACCESSIBLE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555296));
pub const IMAPI_E_UDF_REVISION_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555295));
pub const IMAPI_E_BAD_MULTISESSION_PARAMETER = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555294));
pub const IMAPI_E_FILE_SYSTEM_CHANGE_NOT_ALLOWED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555293));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_NOT_ALIGNED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555136));
pub const IMAPI_E_IMAGEMANAGER_NO_VALID_VD_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555135));
pub const IMAPI_E_IMAGEMANAGER_NO_IMAGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555134));
pub const IMAPI_E_IMAGEMANAGER_IMAGE_TOO_BIG = @import("../zig.zig").typedConst(HRESULT, @as(i32, -1062555133));
pub const MAPI_E_CALL_FAILED = @as(i32, -2147467259);
pub const MAPI_E_NOT_ENOUGH_MEMORY = @as(i32, -2147024882);
pub const MAPI_E_INVALID_PARAMETER = @as(i32, -2147024809);
pub const MAPI_E_INTERFACE_NOT_SUPPORTED = @as(i32, -2147467262);
pub const MAPI_E_NO_ACCESS = @as(i32, -2147024891);
pub const TAD_ALL_ROWS = @as(u32, 1);
pub const PRILOWEST = @as(i32, -32768);
pub const PRIHIGHEST = @as(u32, 32767);
pub const PRIUSER = @as(u32, 0);
pub const OPENSTREAMONFILE = "OpenStreamOnFile";
pub const szHrDispatchNotifications = "HrDispatchNotifications";
pub const szScCreateConversationIndex = "ScCreateConversationIndex";

//--------------------------------------------------------------------------------
// Section: Types (128)
//--------------------------------------------------------------------------------
pub const ENTRYID = extern struct {
    abFlags: [4]u8,
    ab: [1]u8,
};

pub const MAPIUID = extern struct {
    ab: [16]u8,
};

pub const SPropTagArray = extern struct {
    cValues: u32,
    aulPropTag: [1]u32,
};

pub const SBinary = extern struct {
    cb: u32,
    lpb: ?*u8,
};

pub const SShortArray = extern struct {
    cValues: u32,
    lpi: ?*i16,
};

pub const SGuidArray = extern struct {
    cValues: u32,
    lpguid: ?*Guid,
};

pub const SRealArray = extern struct {
    cValues: u32,
    lpflt: ?*f32,
};

pub const SLongArray = extern struct {
    cValues: u32,
    lpl: ?*i32,
};

pub const SLargeIntegerArray = extern struct {
    cValues: u32,
    lpli: ?*LARGE_INTEGER,
};

pub const SDateTimeArray = extern struct {
    cValues: u32,
    lpft: ?*FILETIME,
};

pub const SAppTimeArray = extern struct {
    cValues: u32,
    lpat: ?*f64,
};

pub const SCurrencyArray = extern struct {
    cValues: u32,
    lpcur: ?*CY,
};

pub const SBinaryArray = extern struct {
    cValues: u32,
    lpbin: ?*SBinary,
};

pub const SDoubleArray = extern struct {
    cValues: u32,
    lpdbl: ?*f64,
};

pub const SWStringArray = extern struct {
    cValues: u32,
    lppszW: ?*?PWSTR,
};

pub const SLPSTRArray = extern struct {
    cValues: u32,
    lppszA: ?*?PSTR,
};

pub const _PV = extern union {
    i: i16,
    l: i32,
    ul: u32,
    flt: f32,
    dbl: f64,
    b: u16,
    cur: CY,
    at: f64,
    ft: FILETIME,
    lpszA: ?PSTR,
    bin: SBinary,
    lpszW: ?PWSTR,
    lpguid: ?*Guid,
    li: LARGE_INTEGER,
    MVi: SShortArray,
    MVl: SLongArray,
    MVflt: SRealArray,
    MVdbl: SDoubleArray,
    MVcur: SCurrencyArray,
    MVat: SAppTimeArray,
    MVft: SDateTimeArray,
    MVbin: SBinaryArray,
    MVszA: SLPSTRArray,
    MVszW: SWStringArray,
    MVguid: SGuidArray,
    MVli: SLargeIntegerArray,
    err: i32,
    x: i32,
};

pub const SPropValue = extern struct {
    ulPropTag: u32,
    dwAlignPad: u32,
    Value: _PV,
};

pub const SPropProblem = extern struct {
    ulIndex: u32,
    ulPropTag: u32,
    scode: i32,
};

pub const SPropProblemArray = extern struct {
    cProblem: u32,
    aProblem: [1]SPropProblem,
};

pub const FLATENTRY = extern struct {
    cb: u32,
    abEntry: [1]u8,
};

pub const FLATENTRYLIST = extern struct {
    cEntries: u32,
    cbEntries: u32,
    abEntries: [1]u8,
};

pub const MTSID = extern struct {
    cb: u32,
    ab: [1]u8,
};

pub const FLATMTSIDLIST = extern struct {
    cMTSIDs: u32,
    cbMTSIDs: u32,
    abMTSIDs: [1]u8,
};

pub const ADRENTRY = extern struct {
    ulReserved1: u32,
    cValues: u32,
    rgPropVals: ?*SPropValue,
};

pub const ADRLIST = extern struct {
    cEntries: u32,
    aEntries: [1]ADRENTRY,
};

pub const SRow = extern struct {
    ulAdrEntryPad: u32,
    cValues: u32,
    lpProps: ?*SPropValue,
};

pub const SRowSet = extern struct {
    cRows: u32,
    aRow: [1]SRow,
};

pub const LPALLOCATEBUFFER = *const fn(
    cbSize: u32,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPALLOCATEMORE = *const fn(
    cbSize: u32,
    lpObject: ?*anyopaque,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFREEBUFFER = *const fn(
    lpBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const MAPIERROR = extern struct {
    ulVersion: u32,
    lpszError: ?*i8,
    lpszComponent: ?*i8,
    ulLowLevelError: u32,
    ulContext: u32,
};

pub const ERROR_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    scode: i32,
    ulFlags: u32,
    lpMAPIError: ?*MAPIERROR,
};

pub const NEWMAIL_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    ulFlags: u32,
    lpszMessageClass: ?*i8,
    ulMessageFlags: u32,
};

pub const OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    ulObjType: u32,
    cbParentID: u32,
    lpParentID: ?*ENTRYID,
    cbOldID: u32,
    lpOldID: ?*ENTRYID,
    cbOldParentID: u32,
    lpOldParentID: ?*ENTRYID,
    lpPropTagArray: ?*SPropTagArray,
};

pub const TABLE_NOTIFICATION = extern struct {
    ulTableEvent: u32,
    hResult: HRESULT,
    propIndex: SPropValue,
    propPrior: SPropValue,
    row: SRow,
    ulPad: u32,
};

pub const EXTENDED_NOTIFICATION = extern struct {
    ulEvent: u32,
    cb: u32,
    pbEventParameters: ?*u8,
};

pub const STATUS_OBJECT_NOTIFICATION = extern struct {
    cbEntryID: u32,
    lpEntryID: ?*ENTRYID,
    cValues: u32,
    lpPropVals: ?*SPropValue,
};

pub const NOTIFICATION = extern struct {
    ulEventType: u32,
    ulAlignPad: u32,
    info: extern union {
        err: ERROR_NOTIFICATION,
        newmail: NEWMAIL_NOTIFICATION,
        obj: OBJECT_NOTIFICATION,
        tab: TABLE_NOTIFICATION,
        ext: EXTENDED_NOTIFICATION,
        statobj: STATUS_OBJECT_NOTIFICATION,
    },
};

pub const IMAPIAdviseSink = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: *const fn(
            self: *const IMAPIAdviseSink,
            cNotif: u32,
            lpNotifications: ?*NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OnNotify(self: *const IMAPIAdviseSink, cNotif: u32, lpNotifications: ?*NOTIFICATION) callconv(.Inline) u32 {
        return self.vtable.OnNotify(self, cNotif, lpNotifications);
    }
};

pub const LPNOTIFCALLBACK = *const fn(
    lpvContext: ?*anyopaque,
    cNotification: u32,
    lpNotifications: ?*NOTIFICATION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IMAPIProgress = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: *const fn(
            self: *const IMAPIProgress,
            ulValue: u32,
            ulCount: u32,
            ulTotal: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: *const fn(
            self: *const IMAPIProgress,
            lpulFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMax: *const fn(
            self: *const IMAPIProgress,
            lpulMax: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMin: *const fn(
            self: *const IMAPIProgress,
            lpulMin: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLimits: *const fn(
            self: *const IMAPIProgress,
            lpulMin: ?*u32,
            lpulMax: ?*u32,
            lpulFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Progress(self: *const IMAPIProgress, ulValue: u32, ulCount: u32, ulTotal: u32) callconv(.Inline) HRESULT {
        return self.vtable.Progress(self, ulValue, ulCount, ulTotal);
    }
    pub fn GetFlags(self: *const IMAPIProgress, lpulFlags: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetFlags(self, lpulFlags);
    }
    pub fn GetMax(self: *const IMAPIProgress, lpulMax: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetMax(self, lpulMax);
    }
    pub fn GetMin(self: *const IMAPIProgress, lpulMin: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetMin(self, lpulMin);
    }
    pub fn SetLimits(self: *const IMAPIProgress, lpulMin: ?*u32, lpulMax: ?*u32, lpulFlags: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.SetLimits(self, lpulMin, lpulMax, lpulFlags);
    }
};

pub const MAPINAMEID = extern struct {
    lpguid: ?*Guid,
    ulKind: u32,
    Kind: extern union {
        lID: i32,
        lpwstrName: ?PWSTR,
    },
};

pub const IMAPIProp = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn(
            self: *const IMAPIProp,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveChanges: *const fn(
            self: *const IMAPIProp,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProps: *const fn(
            self: *const IMAPIProp,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
            lpcValues: ?*u32,
            lppPropArray: ?*?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropList: *const fn(
            self: *const IMAPIProp,
            ulFlags: u32,
            lppPropTagArray: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenProperty: *const fn(
            self: *const IMAPIProp,
            ulPropTag: u32,
            lpiid: ?*Guid,
            ulInterfaceOptions: u32,
            ulFlags: u32,
            lppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProps: *const fn(
            self: *const IMAPIProp,
            cValues: u32,
            lpPropArray: ?*SPropValue,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProps: *const fn(
            self: *const IMAPIProp,
            lpPropTagArray: ?*SPropTagArray,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyTo: *const fn(
            self: *const IMAPIProp,
            ciidExclude: u32,
            rgiidExclude: ?*Guid,
            lpExcludeProps: ?*SPropTagArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            lpInterface: ?*Guid,
            lpDestObj: ?*anyopaque,
            ulFlags: u32,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyProps: *const fn(
            self: *const IMAPIProp,
            lpIncludeProps: ?*SPropTagArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            lpInterface: ?*Guid,
            lpDestObj: ?*anyopaque,
            ulFlags: u32,
            lppProblems: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamesFromIDs: *const fn(
            self: *const IMAPIProp,
            lppPropTags: ?*?*SPropTagArray,
            lpPropSetGuid: ?*Guid,
            ulFlags: u32,
            lpcPropNames: ?*u32,
            lpppPropNames: ?*?*?*MAPINAMEID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIDsFromNames: *const fn(
            self: *const IMAPIProp,
            cPropNames: u32,
            lppPropNames: ?*?*MAPINAMEID,
            ulFlags: u32,
            lppPropTags: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetLastError(self: *const IMAPIProp, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
        return self.vtable.GetLastError(self, hResult, ulFlags, lppMAPIError);
    }
    pub fn SaveChanges(self: *const IMAPIProp, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SaveChanges(self, ulFlags);
    }
    pub fn GetProps(self: *const IMAPIProp, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpcValues: ?*u32, lppPropArray: ?*?*SPropValue) callconv(.Inline) HRESULT {
        return self.vtable.GetProps(self, lpPropTagArray, ulFlags, lpcValues, lppPropArray);
    }
    pub fn GetPropList(self: *const IMAPIProp, ulFlags: u32, lppPropTagArray: ?*?*SPropTagArray) callconv(.Inline) HRESULT {
        return self.vtable.GetPropList(self, ulFlags, lppPropTagArray);
    }
    pub fn OpenProperty(self: *const IMAPIProp, ulPropTag: u32, lpiid: ?*Guid, ulInterfaceOptions: u32, ulFlags: u32, lppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenProperty(self, ulPropTag, lpiid, ulInterfaceOptions, ulFlags, lppUnk);
    }
    pub fn SetProps(self: *const IMAPIProp, cValues: u32, lpPropArray: ?*SPropValue, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
        return self.vtable.SetProps(self, cValues, lpPropArray, lppProblems);
    }
    pub fn DeleteProps(self: *const IMAPIProp, lpPropTagArray: ?*SPropTagArray, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
        return self.vtable.DeleteProps(self, lpPropTagArray, lppProblems);
    }
    pub fn CopyTo(self: *const IMAPIProp, ciidExclude: u32, rgiidExclude: ?*Guid, lpExcludeProps: ?*SPropTagArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, lpInterface: ?*Guid, lpDestObj: ?*anyopaque, ulFlags: u32, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
        return self.vtable.CopyTo(self, ciidExclude, rgiidExclude, lpExcludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
    }
    pub fn CopyProps(self: *const IMAPIProp, lpIncludeProps: ?*SPropTagArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, lpInterface: ?*Guid, lpDestObj: ?*anyopaque, ulFlags: u32, lppProblems: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
        return self.vtable.CopyProps(self, lpIncludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems);
    }
    pub fn GetNamesFromIDs(self: *const IMAPIProp, lppPropTags: ?*?*SPropTagArray, lpPropSetGuid: ?*Guid, ulFlags: u32, lpcPropNames: ?*u32, lpppPropNames: ?*?*?*MAPINAMEID) callconv(.Inline) HRESULT {
        return self.vtable.GetNamesFromIDs(self, lppPropTags, lpPropSetGuid, ulFlags, lpcPropNames, lpppPropNames);
    }
    pub fn GetIDsFromNames(self: *const IMAPIProp, cPropNames: u32, lppPropNames: ?*?*MAPINAMEID, ulFlags: u32, lppPropTags: ?*?*SPropTagArray) callconv(.Inline) HRESULT {
        return self.vtable.GetIDsFromNames(self, cPropNames, lppPropNames, ulFlags, lppPropTags);
    }
};

pub const SSortOrder = extern struct {
    ulPropTag: u32,
    ulOrder: u32,
};

pub const SSortOrderSet = extern struct {
    cSorts: u32,
    cCategories: u32,
    cExpanded: u32,
    aSort: [1]SSortOrder,
};

pub const SAndRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SOrRestriction = extern struct {
    cRes: u32,
    lpRes: ?*SRestriction,
};

pub const SNotRestriction = extern struct {
    ulReserved: u32,
    lpRes: ?*SRestriction,
};

pub const SContentRestriction = extern struct {
    ulFuzzyLevel: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SBitMaskRestriction = extern struct {
    relBMR: u32,
    ulPropTag: u32,
    ulMask: u32,
};

pub const SPropertyRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    lpProp: ?*SPropValue,
};

pub const SComparePropsRestriction = extern struct {
    relop: u32,
    ulPropTag1: u32,
    ulPropTag2: u32,
};

pub const SSizeRestriction = extern struct {
    relop: u32,
    ulPropTag: u32,
    cb: u32,
};

pub const SExistRestriction = extern struct {
    ulReserved1: u32,
    ulPropTag: u32,
    ulReserved2: u32,
};

pub const SSubRestriction = extern struct {
    ulSubObject: u32,
    lpRes: ?*SRestriction,
};

pub const SCommentRestriction = extern struct {
    cValues: u32,
    lpRes: ?*SRestriction,
    lpProp: ?*SPropValue,
};

pub const SRestriction = extern struct {
    rt: u32,
    res: extern union {
        resCompareProps: SComparePropsRestriction,
        resAnd: SAndRestriction,
        resOr: SOrRestriction,
        resNot: SNotRestriction,
        resContent: SContentRestriction,
        resProperty: SPropertyRestriction,
        resBitMask: SBitMaskRestriction,
        resSize: SSizeRestriction,
        resExist: SExistRestriction,
        resSub: SSubRestriction,
        resComment: SCommentRestriction,
    },
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMAPITable = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn(
            self: *const IMAPITable,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn(
            self: *const IMAPITable,
            ulEventMask: u32,
            lpAdviseSink: ?*IMAPIAdviseSink,
            lpulConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn(
            self: *const IMAPITable,
            ulConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: *const fn(
            self: *const IMAPITable,
            lpulTableStatus: ?*u32,
            lpulTableType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumns: *const fn(
            self: *const IMAPITable,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryColumns: *const fn(
            self: *const IMAPITable,
            ulFlags: u32,
            lpPropTagArray: ?*?*SPropTagArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowCount: *const fn(
            self: *const IMAPITable,
            ulFlags: u32,
            lpulCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekRow: *const fn(
            self: *const IMAPITable,
            bkOrigin: u32,
            lRowCount: i32,
            lplRowsSought: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SeekRowApprox: *const fn(
            self: *const IMAPITable,
            ulNumerator: u32,
            ulDenominator: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPosition: *const fn(
            self: *const IMAPITable,
            lpulRow: ?*u32,
            lpulNumerator: ?*u32,
            lpulDenominator: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindRow: *const fn(
            self: *const IMAPITable,
            lpRestriction: ?*SRestriction,
            bkOrigin: u32,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Restrict: *const fn(
            self: *const IMAPITable,
            lpRestriction: ?*SRestriction,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBookmark: *const fn(
            self: *const IMAPITable,
            lpbkPosition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBookmark: *const fn(
            self: *const IMAPITable,
            bkPosition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SortTable: *const fn(
            self: *const IMAPITable,
            lpSortCriteria: ?*SSortOrderSet,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySortOrder: *const fn(
            self: *const IMAPITable,
            lppSortCriteria: ?*?*SSortOrderSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRows: *const fn(
            self: *const IMAPITable,
            lRowCount: i32,
            ulFlags: u32,
            lppRows: ?*?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: *const fn(
            self: *const IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandRow: *const fn(
            self: *const IMAPITable,
            cbInstanceKey: u32,
            pbInstanceKey: ?*u8,
            ulRowCount: u32,
            ulFlags: u32,
            lppRows: ?*?*SRowSet,
            lpulMoreRows: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CollapseRow: *const fn(
            self: *const IMAPITable,
            cbInstanceKey: u32,
            pbInstanceKey: ?*u8,
            ulFlags: u32,
            lpulRowCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForCompletion: *const fn(
            self: *const IMAPITable,
            ulFlags: u32,
            ulTimeout: u32,
            lpulTableStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCollapseState: *const fn(
            self: *const IMAPITable,
            ulFlags: u32,
            cbInstanceKey: u32,
            lpbInstanceKey: ?*u8,
            lpcbCollapseState: ?*u32,
            lppbCollapseState: ?*?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCollapseState: *const fn(
            self: *const IMAPITable,
            ulFlags: u32,
            cbCollapseState: u32,
            pbCollapseState: ?*u8,
            lpbkLocation: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetLastError(self: *const IMAPITable, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
        return self.vtable.GetLastError(self, hResult, ulFlags, lppMAPIError);
    }
    pub fn Advise(self: *const IMAPITable, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Advise(self, ulEventMask, lpAdviseSink, lpulConnection);
    }
    pub fn Unadvise(self: *const IMAPITable, ulConnection: u32) callconv(.Inline) HRESULT {
        return self.vtable.Unadvise(self, ulConnection);
    }
    pub fn GetStatus(self: *const IMAPITable, lpulTableStatus: ?*u32, lpulTableType: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetStatus(self, lpulTableStatus, lpulTableType);
    }
    pub fn SetColumns(self: *const IMAPITable, lpPropTagArray: ?*SPropTagArray, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetColumns(self, lpPropTagArray, ulFlags);
    }
    pub fn QueryColumns(self: *const IMAPITable, ulFlags: u32, lpPropTagArray: ?*?*SPropTagArray) callconv(.Inline) HRESULT {
        return self.vtable.QueryColumns(self, ulFlags, lpPropTagArray);
    }
    pub fn GetRowCount(self: *const IMAPITable, ulFlags: u32, lpulCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetRowCount(self, ulFlags, lpulCount);
    }
    pub fn SeekRow(self: *const IMAPITable, bkOrigin: u32, lRowCount: i32, lplRowsSought: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.SeekRow(self, bkOrigin, lRowCount, lplRowsSought);
    }
    pub fn SeekRowApprox(self: *const IMAPITable, ulNumerator: u32, ulDenominator: u32) callconv(.Inline) HRESULT {
        return self.vtable.SeekRowApprox(self, ulNumerator, ulDenominator);
    }
    pub fn QueryPosition(self: *const IMAPITable, lpulRow: ?*u32, lpulNumerator: ?*u32, lpulDenominator: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.QueryPosition(self, lpulRow, lpulNumerator, lpulDenominator);
    }
    pub fn FindRow(self: *const IMAPITable, lpRestriction: ?*SRestriction, bkOrigin: u32, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.FindRow(self, lpRestriction, bkOrigin, ulFlags);
    }
    pub fn Restrict(self: *const IMAPITable, lpRestriction: ?*SRestriction, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.Restrict(self, lpRestriction, ulFlags);
    }
    pub fn CreateBookmark(self: *const IMAPITable, lpbkPosition: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.CreateBookmark(self, lpbkPosition);
    }
    pub fn FreeBookmark(self: *const IMAPITable, bkPosition: u32) callconv(.Inline) HRESULT {
        return self.vtable.FreeBookmark(self, bkPosition);
    }
    pub fn SortTable(self: *const IMAPITable, lpSortCriteria: ?*SSortOrderSet, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SortTable(self, lpSortCriteria, ulFlags);
    }
    pub fn QuerySortOrder(self: *const IMAPITable, lppSortCriteria: ?*?*SSortOrderSet) callconv(.Inline) HRESULT {
        return self.vtable.QuerySortOrder(self, lppSortCriteria);
    }
    pub fn QueryRows(self: *const IMAPITable, lRowCount: i32, ulFlags: u32, lppRows: ?*?*SRowSet) callconv(.Inline) HRESULT {
        return self.vtable.QueryRows(self, lRowCount, ulFlags, lppRows);
    }
    pub fn Abort(self: *const IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.Abort(self);
    }
    pub fn ExpandRow(self: *const IMAPITable, cbInstanceKey: u32, pbInstanceKey: ?*u8, ulRowCount: u32, ulFlags: u32, lppRows: ?*?*SRowSet, lpulMoreRows: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.ExpandRow(self, cbInstanceKey, pbInstanceKey, ulRowCount, ulFlags, lppRows, lpulMoreRows);
    }
    pub fn CollapseRow(self: *const IMAPITable, cbInstanceKey: u32, pbInstanceKey: ?*u8, ulFlags: u32, lpulRowCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.CollapseRow(self, cbInstanceKey, pbInstanceKey, ulFlags, lpulRowCount);
    }
    pub fn WaitForCompletion(self: *const IMAPITable, ulFlags: u32, ulTimeout: u32, lpulTableStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.WaitForCompletion(self, ulFlags, ulTimeout, lpulTableStatus);
    }
    pub fn GetCollapseState(self: *const IMAPITable, ulFlags: u32, cbInstanceKey: u32, lpbInstanceKey: ?*u8, lpcbCollapseState: ?*u32, lppbCollapseState: ?*?*u8) callconv(.Inline) HRESULT {
        return self.vtable.GetCollapseState(self, ulFlags, cbInstanceKey, lpbInstanceKey, lpcbCollapseState, lppbCollapseState);
    }
    pub fn SetCollapseState(self: *const IMAPITable, ulFlags: u32, cbCollapseState: u32, pbCollapseState: ?*u8, lpbkLocation: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.SetCollapseState(self, ulFlags, cbCollapseState, pbCollapseState, lpbkLocation);
    }
};

pub const IProfSect = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
};

pub const IMAPIStatus = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        ValidateState: *const fn(
            self: *const IMAPIStatus,
            ulUIParam: usize,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SettingsDialog: *const fn(
            self: *const IMAPIStatus,
            ulUIParam: usize,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangePassword: *const fn(
            self: *const IMAPIStatus,
            lpOldPass: ?*i8,
            lpNewPass: ?*i8,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushQueues: *const fn(
            self: *const IMAPIStatus,
            ulUIParam: usize,
            cbTargetTransport: u32,
            lpTargetTransport: ?[*]ENTRYID,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn ValidateState(self: *const IMAPIStatus, ulUIParam: usize, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.ValidateState(self, ulUIParam, ulFlags);
    }
    pub fn SettingsDialog(self: *const IMAPIStatus, ulUIParam: usize, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SettingsDialog(self, ulUIParam, ulFlags);
    }
    pub fn ChangePassword(self: *const IMAPIStatus, lpOldPass: ?*i8, lpNewPass: ?*i8, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.ChangePassword(self, lpOldPass, lpNewPass, ulFlags);
    }
    pub fn FlushQueues(self: *const IMAPIStatus, ulUIParam: usize, cbTargetTransport: u32, lpTargetTransport: ?[*]ENTRYID, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.FlushQueues(self, ulUIParam, cbTargetTransport, lpTargetTransport, ulFlags);
    }
};

pub const IMAPIContainer = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetContentsTable: *const fn(
            self: *const IMAPIContainer,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHierarchyTable: *const fn(
            self: *const IMAPIContainer,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenEntry: *const fn(
            self: *const IMAPIContainer,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulObjType: ?*u32,
            lppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchCriteria: *const fn(
            self: *const IMAPIContainer,
            lpRestriction: ?*SRestriction,
            lpContainerList: ?*SBinaryArray,
            ulSearchFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchCriteria: *const fn(
            self: *const IMAPIContainer,
            ulFlags: u32,
            lppRestriction: ?*?*SRestriction,
            lppContainerList: ?*?*SBinaryArray,
            lpulSearchState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn GetContentsTable(self: *const IMAPIContainer, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetContentsTable(self, ulFlags, lppTable);
    }
    pub fn GetHierarchyTable(self: *const IMAPIContainer, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetHierarchyTable(self, ulFlags, lppTable);
    }
    pub fn OpenEntry(self: *const IMAPIContainer, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, lppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenEntry(self, cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, lppUnk);
    }
    pub fn SetSearchCriteria(self: *const IMAPIContainer, lpRestriction: ?*SRestriction, lpContainerList: ?*SBinaryArray, ulSearchFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetSearchCriteria(self, lpRestriction, lpContainerList, ulSearchFlags);
    }
    pub fn GetSearchCriteria(self: *const IMAPIContainer, ulFlags: u32, lppRestriction: ?*?*SRestriction, lppContainerList: ?*?*SBinaryArray, lpulSearchState: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetSearchCriteria(self, ulFlags, lppRestriction, lppContainerList, lpulSearchState);
    }
};

pub const _flaglist = extern struct {
    cFlags: u32,
    ulFlag: [1]u32,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IABContainer = extern union {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: *const fn(
            self: *const IABContainer,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulCreateFlags: u32,
            lppMAPIPropEntry: ?*?*IMAPIProp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyEntries: *const fn(
            self: *const IABContainer,
            lpEntries: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteEntries: *const fn(
            self: *const IABContainer,
            lpEntries: ?*SBinaryArray,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveNames: *const fn(
            self: *const IABContainer,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
            lpAdrList: ?*ADRLIST,
            lpFlagList: ?*_flaglist,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIContainer: IMAPIContainer,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn CreateEntry(self: *const IABContainer, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulCreateFlags: u32, lppMAPIPropEntry: ?*?*IMAPIProp) callconv(.Inline) HRESULT {
        return self.vtable.CreateEntry(self, cbEntryID, lpEntryID, ulCreateFlags, lppMAPIPropEntry);
    }
    pub fn CopyEntries(self: *const IABContainer, lpEntries: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.CopyEntries(self, lpEntries, ulUIParam, lpProgress, ulFlags);
    }
    pub fn DeleteEntries(self: *const IABContainer, lpEntries: ?*SBinaryArray, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteEntries(self, lpEntries, ulFlags);
    }
    pub fn ResolveNames(self: *const IABContainer, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpAdrList: ?*ADRLIST, lpFlagList: ?*_flaglist) callconv(.Inline) HRESULT {
        return self.vtable.ResolveNames(self, lpPropTagArray, ulFlags, lpAdrList, lpFlagList);
    }
};

// TODO: this type is limited to platform 'windows5.0'
pub const IMailUser = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
};

// TODO: this type is limited to platform 'windows5.0'
pub const IDistList = extern union {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateEntry: *const fn(
            self: *const IDistList,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulCreateFlags: u32,
            lppMAPIPropEntry: ?*?*IMAPIProp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyEntries: *const fn(
            self: *const IDistList,
            lpEntries: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteEntries: *const fn(
            self: *const IDistList,
            lpEntries: ?*SBinaryArray,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveNames: *const fn(
            self: *const IDistList,
            lpPropTagArray: ?*SPropTagArray,
            ulFlags: u32,
            lpAdrList: ?*ADRLIST,
            lpFlagList: ?*_flaglist,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIContainer: IMAPIContainer,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn CreateEntry(self: *const IDistList, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulCreateFlags: u32, lppMAPIPropEntry: ?*?*IMAPIProp) callconv(.Inline) HRESULT {
        return self.vtable.CreateEntry(self, cbEntryID, lpEntryID, ulCreateFlags, lppMAPIPropEntry);
    }
    pub fn CopyEntries(self: *const IDistList, lpEntries: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.CopyEntries(self, lpEntries, ulUIParam, lpProgress, ulFlags);
    }
    pub fn DeleteEntries(self: *const IDistList, lpEntries: ?*SBinaryArray, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteEntries(self, lpEntries, ulFlags);
    }
    pub fn ResolveNames(self: *const IDistList, lpPropTagArray: ?*SPropTagArray, ulFlags: u32, lpAdrList: ?*ADRLIST, lpFlagList: ?*_flaglist) callconv(.Inline) HRESULT {
        return self.vtable.ResolveNames(self, lpPropTagArray, ulFlags, lpAdrList, lpFlagList);
    }
};

pub const IMAPIFolder = extern union {
    pub const VTable = extern struct {
        base: IMAPIContainer.VTable,
        CreateMessage: *const fn(
            self: *const IMAPIFolder,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppMessage: ?*?*IMessage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyMessages: *const fn(
            self: *const IMAPIFolder,
            lpMsgList: ?*SBinaryArray,
            lpInterface: ?*Guid,
            lpDestFolder: ?*anyopaque,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMessages: *const fn(
            self: *const IMAPIFolder,
            lpMsgList: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFolder: *const fn(
            self: *const IMAPIFolder,
            ulFolderType: u32,
            lpszFolderName: ?*i8,
            lpszFolderComment: ?*i8,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppFolder: ?*?*IMAPIFolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyFolder: *const fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            lpDestFolder: ?*anyopaque,
            lpszNewFolderName: ?*i8,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteFolder: *const fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReadFlags: *const fn(
            self: *const IMAPIFolder,
            lpMsgList: ?*SBinaryArray,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMessageStatus: *const fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulFlags: u32,
            lpulMessageStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMessageStatus: *const fn(
            self: *const IMAPIFolder,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulNewStatus: u32,
            ulNewStatusMask: u32,
            lpulOldStatus: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveContentsSort: *const fn(
            self: *const IMAPIFolder,
            lpSortCriteria: ?*SSortOrderSet,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EmptyFolder: *const fn(
            self: *const IMAPIFolder,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIContainer: IMAPIContainer,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn CreateMessage(self: *const IMAPIFolder, lpInterface: ?*Guid, ulFlags: u32, lppMessage: ?*?*IMessage) callconv(.Inline) HRESULT {
        return self.vtable.CreateMessage(self, lpInterface, ulFlags, lppMessage);
    }
    pub fn CopyMessages(self: *const IMAPIFolder, lpMsgList: ?*SBinaryArray, lpInterface: ?*Guid, lpDestFolder: ?*anyopaque, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.CopyMessages(self, lpMsgList, lpInterface, lpDestFolder, ulUIParam, lpProgress, ulFlags);
    }
    pub fn DeleteMessages(self: *const IMAPIFolder, lpMsgList: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteMessages(self, lpMsgList, ulUIParam, lpProgress, ulFlags);
    }
    pub fn CreateFolder(self: *const IMAPIFolder, ulFolderType: u32, lpszFolderName: ?*i8, lpszFolderComment: ?*i8, lpInterface: ?*Guid, ulFlags: u32, lppFolder: ?*?*IMAPIFolder) callconv(.Inline) HRESULT {
        return self.vtable.CreateFolder(self, ulFolderType, lpszFolderName, lpszFolderComment, lpInterface, ulFlags, lppFolder);
    }
    pub fn CopyFolder(self: *const IMAPIFolder, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, lpDestFolder: ?*anyopaque, lpszNewFolderName: ?*i8, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.CopyFolder(self, cbEntryID, lpEntryID, lpInterface, lpDestFolder, lpszNewFolderName, ulUIParam, lpProgress, ulFlags);
    }
    pub fn DeleteFolder(self: *const IMAPIFolder, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteFolder(self, cbEntryID, lpEntryID, ulUIParam, lpProgress, ulFlags);
    }
    pub fn SetReadFlags(self: *const IMAPIFolder, lpMsgList: ?*SBinaryArray, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetReadFlags(self, lpMsgList, ulUIParam, lpProgress, ulFlags);
    }
    pub fn GetMessageStatus(self: *const IMAPIFolder, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulFlags: u32, lpulMessageStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetMessageStatus(self, cbEntryID, lpEntryID, ulFlags, lpulMessageStatus);
    }
    pub fn SetMessageStatus(self: *const IMAPIFolder, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulNewStatus: u32, ulNewStatusMask: u32, lpulOldStatus: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.SetMessageStatus(self, cbEntryID, lpEntryID, ulNewStatus, ulNewStatusMask, lpulOldStatus);
    }
    pub fn SaveContentsSort(self: *const IMAPIFolder, lpSortCriteria: ?*SSortOrderSet, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SaveContentsSort(self, lpSortCriteria, ulFlags);
    }
    pub fn EmptyFolder(self: *const IMAPIFolder, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.EmptyFolder(self, ulUIParam, lpProgress, ulFlags);
    }
};

pub const IMsgStore = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        Advise: *const fn(
            self: *const IMsgStore,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulEventMask: u32,
            lpAdviseSink: ?*IMAPIAdviseSink,
            lpulConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn(
            self: *const IMsgStore,
            ulConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEntryIDs: *const fn(
            self: *const IMsgStore,
            cbEntryID1: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID1: ?*ENTRYID,
            cbEntryID2: u32,
            // TODO: what to do with BytesParamIndex 2?
            lpEntryID2: ?*ENTRYID,
            ulFlags: u32,
            lpulResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenEntry: *const fn(
            self: *const IMsgStore,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulObjType: ?*u32,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReceiveFolder: *const fn(
            self: *const IMsgStore,
            lpszMessageClass: ?*i8,
            ulFlags: u32,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 2?
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReceiveFolder: *const fn(
            self: *const IMsgStore,
            lpszMessageClass: ?*i8,
            ulFlags: u32,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
            lppszExplicitClass: ?*?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReceiveFolderTable: *const fn(
            self: *const IMsgStore,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoreLogoff: *const fn(
            self: *const IMsgStore,
            lpulFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortSubmit: *const fn(
            self: *const IMsgStore,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 0?
            lpEntryID: ?*ENTRYID,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutgoingQueue: *const fn(
            self: *const IMsgStore,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLockState: *const fn(
            self: *const IMsgStore,
            lpMessage: ?*IMessage,
            ulLockState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinishedMsg: *const fn(
            self: *const IMsgStore,
            ulFlags: u32,
            cbEntryID: u32,
            // TODO: what to do with BytesParamIndex 1?
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyNewMail: *const fn(
            self: *const IMsgStore,
            lpNotification: ?*NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn Advise(self: *const IMsgStore, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Advise(self, cbEntryID, lpEntryID, ulEventMask, lpAdviseSink, lpulConnection);
    }
    pub fn Unadvise(self: *const IMsgStore, ulConnection: u32) callconv(.Inline) HRESULT {
        return self.vtable.Unadvise(self, ulConnection);
    }
    pub fn CompareEntryIDs(self: *const IMsgStore, cbEntryID1: u32, lpEntryID1: ?*ENTRYID, cbEntryID2: u32, lpEntryID2: ?*ENTRYID, ulFlags: u32, lpulResult: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.CompareEntryIDs(self, cbEntryID1, lpEntryID1, cbEntryID2, lpEntryID2, ulFlags, lpulResult);
    }
    pub fn OpenEntry(self: *const IMsgStore, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenEntry(self, cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, ppUnk);
    }
    pub fn SetReceiveFolder(self: *const IMsgStore, lpszMessageClass: ?*i8, ulFlags: u32, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.SetReceiveFolder(self, lpszMessageClass, ulFlags, cbEntryID, lpEntryID);
    }
    pub fn GetReceiveFolder(self: *const IMsgStore, lpszMessageClass: ?*i8, ulFlags: u32, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID, lppszExplicitClass: ?*?*i8) callconv(.Inline) HRESULT {
        return self.vtable.GetReceiveFolder(self, lpszMessageClass, ulFlags, lpcbEntryID, lppEntryID, lppszExplicitClass);
    }
    pub fn GetReceiveFolderTable(self: *const IMsgStore, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetReceiveFolderTable(self, ulFlags, lppTable);
    }
    pub fn StoreLogoff(self: *const IMsgStore, lpulFlags: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.StoreLogoff(self, lpulFlags);
    }
    pub fn AbortSubmit(self: *const IMsgStore, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.AbortSubmit(self, cbEntryID, lpEntryID, ulFlags);
    }
    pub fn GetOutgoingQueue(self: *const IMsgStore, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetOutgoingQueue(self, ulFlags, lppTable);
    }
    pub fn SetLockState(self: *const IMsgStore, lpMessage: ?*IMessage, ulLockState: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetLockState(self, lpMessage, ulLockState);
    }
    pub fn FinishedMsg(self: *const IMsgStore, ulFlags: u32, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.FinishedMsg(self, ulFlags, cbEntryID, lpEntryID);
    }
    pub fn NotifyNewMail(self: *const IMsgStore, lpNotification: ?*NOTIFICATION) callconv(.Inline) HRESULT {
        return self.vtable.NotifyNewMail(self, lpNotification);
    }
};

pub const IMessage = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        GetAttachmentTable: *const fn(
            self: *const IMessage,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenAttach: *const fn(
            self: *const IMessage,
            ulAttachmentNum: u32,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppAttach: ?*?*IAttach,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAttach: *const fn(
            self: *const IMessage,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulAttachmentNum: ?*u32,
            lppAttach: ?*?*IAttach,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAttach: *const fn(
            self: *const IMessage,
            ulAttachmentNum: u32,
            ulUIParam: usize,
            lpProgress: ?*IMAPIProgress,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecipientTable: *const fn(
            self: *const IMessage,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyRecipients: *const fn(
            self: *const IMessage,
            ulFlags: u32,
            lpMods: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitMessage: *const fn(
            self: *const IMessage,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReadFlag: *const fn(
            self: *const IMessage,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn GetAttachmentTable(self: *const IMessage, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetAttachmentTable(self, ulFlags, lppTable);
    }
    pub fn OpenAttach(self: *const IMessage, ulAttachmentNum: u32, lpInterface: ?*Guid, ulFlags: u32, lppAttach: ?*?*IAttach) callconv(.Inline) HRESULT {
        return self.vtable.OpenAttach(self, ulAttachmentNum, lpInterface, ulFlags, lppAttach);
    }
    pub fn CreateAttach(self: *const IMessage, lpInterface: ?*Guid, ulFlags: u32, lpulAttachmentNum: ?*u32, lppAttach: ?*?*IAttach) callconv(.Inline) HRESULT {
        return self.vtable.CreateAttach(self, lpInterface, ulFlags, lpulAttachmentNum, lppAttach);
    }
    pub fn DeleteAttach(self: *const IMessage, ulAttachmentNum: u32, ulUIParam: usize, lpProgress: ?*IMAPIProgress, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.DeleteAttach(self, ulAttachmentNum, ulUIParam, lpProgress, ulFlags);
    }
    pub fn GetRecipientTable(self: *const IMessage, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetRecipientTable(self, ulFlags, lppTable);
    }
    pub fn ModifyRecipients(self: *const IMessage, ulFlags: u32, lpMods: ?*ADRLIST) callconv(.Inline) HRESULT {
        return self.vtable.ModifyRecipients(self, ulFlags, lpMods);
    }
    pub fn SubmitMessage(self: *const IMessage, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SubmitMessage(self, ulFlags);
    }
    pub fn SetReadFlag(self: *const IMessage, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetReadFlag(self, ulFlags);
    }
};

pub const IAttach = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
};

pub const LPFNABSDI = *const fn(
    ulUIParam: usize,
    lpvmsg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFNDISMISS = *const fn(
    ulUIParam: usize,
    lpvContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPFNBUTTON = *const fn(
    ulUIParam: usize,
    lpvContext: ?*anyopaque,
    cbEntryID: u32,
    lpSelection: ?*ENTRYID,
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ADRPARM = extern struct {
    cbABContEntryID: u32,
    lpABContEntryID: ?*ENTRYID,
    ulFlags: u32,
    lpReserved: ?*anyopaque,
    ulHelpContext: u32,
    lpszHelpFileName: ?*i8,
    lpfnABSDI: ?LPFNABSDI,
    lpfnDismiss: ?LPFNDISMISS,
    lpvDismissContext: ?*anyopaque,
    lpszCaption: ?*i8,
    lpszNewEntryTitle: ?*i8,
    lpszDestWellsTitle: ?*i8,
    cDestFields: u32,
    nDestFieldFocus: u32,
    lppszDestTitles: ?*?*i8,
    lpulDestComps: ?*u32,
    lpContRestriction: ?*SRestriction,
    lpHierRestriction: ?*SRestriction,
};

pub const IMAPIControl = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn(
            self: *const IMAPIControl,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Activate: *const fn(
            self: *const IMAPIControl,
            ulFlags: u32,
            ulUIParam: usize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: *const fn(
            self: *const IMAPIControl,
            ulFlags: u32,
            lpulState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetLastError(self: *const IMAPIControl, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
        return self.vtable.GetLastError(self, hResult, ulFlags, lppMAPIError);
    }
    pub fn Activate(self: *const IMAPIControl, ulFlags: u32, ulUIParam: usize) callconv(.Inline) HRESULT {
        return self.vtable.Activate(self, ulFlags, ulUIParam);
    }
    pub fn GetState(self: *const IMAPIControl, ulFlags: u32, lpulState: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetState(self, ulFlags, lpulState);
    }
};

pub const DTBLLABEL = extern struct {
    ulbLpszLabelName: u32,
    ulFlags: u32,
};

pub const DTBLEDIT = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPropTag: u32,
};

pub const DTBLLBX = extern struct {
    ulFlags: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCOMBOBOX = extern struct {
    ulbLpszCharsAllowed: u32,
    ulFlags: u32,
    ulNumCharsAllowed: u32,
    ulPRPropertyName: u32,
    ulPRTableName: u32,
};

pub const DTBLDDLBX = extern struct {
    ulFlags: u32,
    ulPRDisplayProperty: u32,
    ulPRSetProperty: u32,
    ulPRTableName: u32,
};

pub const DTBLCHECKBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRPropertyName: u32,
};

pub const DTBLGROUPBOX = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
};

pub const DTBLBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulPRControl: u32,
};

pub const DTBLPAGE = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulbLpszComponent: u32,
    ulContext: u32,
};

pub const DTBLRADIOBUTTON = extern struct {
    ulbLpszLabel: u32,
    ulFlags: u32,
    ulcButtons: u32,
    ulPropTag: u32,
    lReturnValue: i32,
};

pub const DTBLMVLISTBOX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const DTBLMVDDLBX = extern struct {
    ulFlags: u32,
    ulMVPropTag: u32,
};

pub const IProviderAdmin = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn(
            self: *const IProviderAdmin,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderTable: *const fn(
            self: *const IProviderAdmin,
            ulFlags: u32,
            lppTable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProvider: *const fn(
            self: *const IProviderAdmin,
            lpszProvider: ?*i8,
            cValues: u32,
            lpProps: [*]SPropValue,
            ulUIParam: usize,
            ulFlags: u32,
            lpUID: ?*MAPIUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProvider: *const fn(
            self: *const IProviderAdmin,
            lpUID: ?*MAPIUID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenProfileSection: *const fn(
            self: *const IProviderAdmin,
            lpUID: ?*MAPIUID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lppProfSect: ?*?*IProfSect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetLastError(self: *const IProviderAdmin, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
        return self.vtable.GetLastError(self, hResult, ulFlags, lppMAPIError);
    }
    pub fn GetProviderTable(self: *const IProviderAdmin, ulFlags: u32, lppTable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.GetProviderTable(self, ulFlags, lppTable);
    }
    pub fn CreateProvider(self: *const IProviderAdmin, lpszProvider: ?*i8, cValues: u32, lpProps: [*]SPropValue, ulUIParam: usize, ulFlags: u32, lpUID: ?*MAPIUID) callconv(.Inline) HRESULT {
        return self.vtable.CreateProvider(self, lpszProvider, cValues, lpProps, ulUIParam, ulFlags, lpUID);
    }
    pub fn DeleteProvider(self: *const IProviderAdmin, lpUID: ?*MAPIUID) callconv(.Inline) HRESULT {
        return self.vtable.DeleteProvider(self, lpUID);
    }
    pub fn OpenProfileSection(self: *const IProviderAdmin, lpUID: ?*MAPIUID, lpInterface: ?*Guid, ulFlags: u32, lppProfSect: ?*?*IProfSect) callconv(.Inline) HRESULT {
        return self.vtable.OpenProfileSection(self, lpUID, lpInterface, ulFlags, lppProfSect);
    }
};

pub const Gender = enum(i32) {
    Unspecified = 0,
    Female = 1,
    Male = 2,
};
pub const genderUnspecified = Gender.Unspecified;
pub const genderFemale = Gender.Female;
pub const genderMale = Gender.Male;

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const CALLERRELEASE = *const fn() callconv(@import("std").os.windows.WINAPI) void;

pub const ITableData = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HrGetView: *const fn(
            self: *const ITableData,
            lpSSortOrderSet: ?*SSortOrderSet,
            lpfCallerRelease: ?*?CALLERRELEASE,
            ulCallerData: u32,
            lppMAPITable: ?*?*IMAPITable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrModifyRow: *const fn(
            self: *const ITableData,
            param0: ?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrDeleteRow: *const fn(
            self: *const ITableData,
            lpSPropValue: ?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrQueryRow: *const fn(
            self: *const ITableData,
            lpsPropValue: ?*SPropValue,
            lppSRow: ?*?*SRow,
            lpuliRow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrEnumRow: *const fn(
            self: *const ITableData,
            ulRowNumber: u32,
            lppSRow: ?*?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrNotify: *const fn(
            self: *const ITableData,
            ulFlags: u32,
            cValues: u32,
            lpSPropValue: ?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrInsertRow: *const fn(
            self: *const ITableData,
            uliRow: u32,
            lpSRow: ?*SRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrModifyRows: *const fn(
            self: *const ITableData,
            ulFlags: u32,
            lpSRowSet: ?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrDeleteRows: *const fn(
            self: *const ITableData,
            ulFlags: u32,
            lprowsetToDelete: ?*SRowSet,
            cRowsDeleted: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn HrGetView(self: *const ITableData, lpSSortOrderSet: ?*SSortOrderSet, lpfCallerRelease: ?*?CALLERRELEASE, ulCallerData: u32, lppMAPITable: ?*?*IMAPITable) callconv(.Inline) HRESULT {
        return self.vtable.HrGetView(self, lpSSortOrderSet, lpfCallerRelease, ulCallerData, lppMAPITable);
    }
    pub fn HrModifyRow(self: *const ITableData, param0: ?*SRow) callconv(.Inline) HRESULT {
        return self.vtable.HrModifyRow(self, param0);
    }
    pub fn HrDeleteRow(self: *const ITableData, lpSPropValue: ?*SPropValue) callconv(.Inline) HRESULT {
        return self.vtable.HrDeleteRow(self, lpSPropValue);
    }
    pub fn HrQueryRow(self: *const ITableData, lpsPropValue: ?*SPropValue, lppSRow: ?*?*SRow, lpuliRow: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.HrQueryRow(self, lpsPropValue, lppSRow, lpuliRow);
    }
    pub fn HrEnumRow(self: *const ITableData, ulRowNumber: u32, lppSRow: ?*?*SRow) callconv(.Inline) HRESULT {
        return self.vtable.HrEnumRow(self, ulRowNumber, lppSRow);
    }
    pub fn HrNotify(self: *const ITableData, ulFlags: u32, cValues: u32, lpSPropValue: ?*SPropValue) callconv(.Inline) HRESULT {
        return self.vtable.HrNotify(self, ulFlags, cValues, lpSPropValue);
    }
    pub fn HrInsertRow(self: *const ITableData, uliRow: u32, lpSRow: ?*SRow) callconv(.Inline) HRESULT {
        return self.vtable.HrInsertRow(self, uliRow, lpSRow);
    }
    pub fn HrModifyRows(self: *const ITableData, ulFlags: u32, lpSRowSet: ?*SRowSet) callconv(.Inline) HRESULT {
        return self.vtable.HrModifyRows(self, ulFlags, lpSRowSet);
    }
    pub fn HrDeleteRows(self: *const ITableData, ulFlags: u32, lprowsetToDelete: ?*SRowSet, cRowsDeleted: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.HrDeleteRows(self, ulFlags, lprowsetToDelete, cRowsDeleted);
    }
};

pub const IPropData = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        HrSetObjAccess: *const fn(
            self: *const IPropData,
            ulAccess: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrSetPropAccess: *const fn(
            self: *const IPropData,
            lpPropTagArray: ?*SPropTagArray,
            rgulAccess: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrGetPropAccess: *const fn(
            self: *const IPropData,
            lppPropTagArray: ?*?*SPropTagArray,
            lprgulAccess: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HrAddObjProps: *const fn(
            self: *const IPropData,
            lppPropTagArray: ?*SPropTagArray,
            lprgulAccess: ?*?*SPropProblemArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn HrSetObjAccess(self: *const IPropData, ulAccess: u32) callconv(.Inline) HRESULT {
        return self.vtable.HrSetObjAccess(self, ulAccess);
    }
    pub fn HrSetPropAccess(self: *const IPropData, lpPropTagArray: ?*SPropTagArray, rgulAccess: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.HrSetPropAccess(self, lpPropTagArray, rgulAccess);
    }
    pub fn HrGetPropAccess(self: *const IPropData, lppPropTagArray: ?*?*SPropTagArray, lprgulAccess: ?*?*u32) callconv(.Inline) HRESULT {
        return self.vtable.HrGetPropAccess(self, lppPropTagArray, lprgulAccess);
    }
    pub fn HrAddObjProps(self: *const IPropData, lppPropTagArray: ?*SPropTagArray, lprgulAccess: ?*?*SPropProblemArray) callconv(.Inline) HRESULT {
        return self.vtable.HrAddObjProps(self, lppPropTagArray, lprgulAccess);
    }
};

pub const PFNIDLE = *const fn(
    param0: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPOPENSTREAMONFILE = *const fn(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    ulFlags: u32,
    lpszFileName: ?*i8,
    lpszPrefix: ?*i8,
    lppStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DTCTL = extern struct {
    ulCtlType: u32,
    ulCtlFlags: u32,
    lpbNotif: ?*u8,
    cbNotif: u32,
    lpszFilter: ?*i8,
    ulItemID: u32,
    ctl: extern union {
        lpv: ?*anyopaque,
        lplabel: ?*DTBLLABEL,
        lpedit: ?*DTBLEDIT,
        lplbx: ?*DTBLLBX,
        lpcombobox: ?*DTBLCOMBOBOX,
        lpddlbx: ?*DTBLDDLBX,
        lpcheckbox: ?*DTBLCHECKBOX,
        lpgroupbox: ?*DTBLGROUPBOX,
        lpbutton: ?*DTBLBUTTON,
        lpradiobutton: ?*DTBLRADIOBUTTON,
        lpmvlbx: ?*DTBLMVLISTBOX,
        lpmvddlbx: ?*DTBLMVDDLBX,
        lppage: ?*DTBLPAGE,
    },
};

pub const DTPAGE = extern struct {
    cctl: u32,
    lpszResourceName: ?*i8,
    Anonymous: extern union {
        lpszComponent: ?*i8,
        ulItemID: u32,
    },
    lpctl: ?*DTCTL,
};

pub const LPDISPATCHNOTIFICATIONS = *const fn(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPCREATECONVERSATIONINDEX = *const fn(
    cbParent: u32,
    lpbParent: ?*u8,
    lpcbConvIndex: ?*u32,
    lppbConvIndex: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub const IAddrBook = extern union {
    pub const VTable = extern struct {
        base: IMAPIProp.VTable,
        OpenEntry: *const fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
            lpInterface: ?*Guid,
            ulFlags: u32,
            lpulObjType: ?*u32,
            lppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEntryIDs: *const fn(
            self: *const IAddrBook,
            cbEntryID1: u32,
            lpEntryID1: ?*ENTRYID,
            cbEntryID2: u32,
            lpEntryID2: ?*ENTRYID,
            ulFlags: u32,
            lpulResult: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: *const fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
            ulEventMask: u32,
            lpAdviseSink: ?*IMAPIAdviseSink,
            lpulConnection: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: *const fn(
            self: *const IAddrBook,
            ulConnection: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOneOff: *const fn(
            self: *const IAddrBook,
            lpszName: ?*i8,
            lpszAdrType: ?*i8,
            lpszAddress: ?*i8,
            ulFlags: u32,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewEntry: *const fn(
            self: *const IAddrBook,
            ulUIParam: u32,
            ulFlags: u32,
            cbEIDContainer: u32,
            lpEIDContainer: ?*ENTRYID,
            cbEIDNewEntryTpl: u32,
            lpEIDNewEntryTpl: ?*ENTRYID,
            lpcbEIDNewEntry: ?*u32,
            lppEIDNewEntry: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveName: *const fn(
            self: *const IAddrBook,
            ulUIParam: usize,
            ulFlags: u32,
            lpszNewEntryTitle: ?*i8,
            lpAdrList: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Address: *const fn(
            self: *const IAddrBook,
            lpulUIParam: ?*u32,
            lpAdrParms: ?*ADRPARM,
            lppAdrList: ?*?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Details: *const fn(
            self: *const IAddrBook,
            lpulUIParam: ?*usize,
            lpfnDismiss: ?LPFNDISMISS,
            lpvDismissContext: ?*anyopaque,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
            lpfButtonCallback: ?LPFNBUTTON,
            lpvButtonContext: ?*anyopaque,
            lpszButtonText: ?*i8,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecipOptions: *const fn(
            self: *const IAddrBook,
            ulUIParam: u32,
            ulFlags: u32,
            lpRecip: ?*ADRENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDefaultRecipOpt: *const fn(
            self: *const IAddrBook,
            lpszAdrType: ?*i8,
            ulFlags: u32,
            lpcValues: ?*u32,
            lppOptions: ?*?*SPropValue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPAB: *const fn(
            self: *const IAddrBook,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPAB: *const fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultDir: *const fn(
            self: *const IAddrBook,
            lpcbEntryID: ?*u32,
            lppEntryID: ?*?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultDir: *const fn(
            self: *const IAddrBook,
            cbEntryID: u32,
            lpEntryID: ?*ENTRYID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSearchPath: *const fn(
            self: *const IAddrBook,
            ulFlags: u32,
            lppSearchPath: ?*?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSearchPath: *const fn(
            self: *const IAddrBook,
            ulFlags: u32,
            lpSearchPath: ?*SRowSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareRecips: *const fn(
            self: *const IAddrBook,
            ulFlags: u32,
            lpPropTagArray: ?*SPropTagArray,
            lpRecipList: ?*ADRLIST,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IMAPIProp: IMAPIProp,
    IUnknown: IUnknown,
    pub fn OpenEntry(self: *const IAddrBook, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpInterface: ?*Guid, ulFlags: u32, lpulObjType: ?*u32, lppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.OpenEntry(self, cbEntryID, lpEntryID, lpInterface, ulFlags, lpulObjType, lppUnk);
    }
    pub fn CompareEntryIDs(self: *const IAddrBook, cbEntryID1: u32, lpEntryID1: ?*ENTRYID, cbEntryID2: u32, lpEntryID2: ?*ENTRYID, ulFlags: u32, lpulResult: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.CompareEntryIDs(self, cbEntryID1, lpEntryID1, cbEntryID2, lpEntryID2, ulFlags, lpulResult);
    }
    pub fn Advise(self: *const IAddrBook, cbEntryID: u32, lpEntryID: ?*ENTRYID, ulEventMask: u32, lpAdviseSink: ?*IMAPIAdviseSink, lpulConnection: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Advise(self, cbEntryID, lpEntryID, ulEventMask, lpAdviseSink, lpulConnection);
    }
    pub fn Unadvise(self: *const IAddrBook, ulConnection: u32) callconv(.Inline) HRESULT {
        return self.vtable.Unadvise(self, ulConnection);
    }
    pub fn CreateOneOff(self: *const IAddrBook, lpszName: ?*i8, lpszAdrType: ?*i8, lpszAddress: ?*i8, ulFlags: u32, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.CreateOneOff(self, lpszName, lpszAdrType, lpszAddress, ulFlags, lpcbEntryID, lppEntryID);
    }
    pub fn NewEntry(self: *const IAddrBook, ulUIParam: u32, ulFlags: u32, cbEIDContainer: u32, lpEIDContainer: ?*ENTRYID, cbEIDNewEntryTpl: u32, lpEIDNewEntryTpl: ?*ENTRYID, lpcbEIDNewEntry: ?*u32, lppEIDNewEntry: ?*?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.NewEntry(self, ulUIParam, ulFlags, cbEIDContainer, lpEIDContainer, cbEIDNewEntryTpl, lpEIDNewEntryTpl, lpcbEIDNewEntry, lppEIDNewEntry);
    }
    pub fn ResolveName(self: *const IAddrBook, ulUIParam: usize, ulFlags: u32, lpszNewEntryTitle: ?*i8, lpAdrList: ?*ADRLIST) callconv(.Inline) HRESULT {
        return self.vtable.ResolveName(self, ulUIParam, ulFlags, lpszNewEntryTitle, lpAdrList);
    }
    pub fn Address(self: *const IAddrBook, lpulUIParam: ?*u32, lpAdrParms: ?*ADRPARM, lppAdrList: ?*?*ADRLIST) callconv(.Inline) HRESULT {
        return self.vtable.Address(self, lpulUIParam, lpAdrParms, lppAdrList);
    }
    pub fn Details(self: *const IAddrBook, lpulUIParam: ?*usize, lpfnDismiss: ?LPFNDISMISS, lpvDismissContext: ?*anyopaque, cbEntryID: u32, lpEntryID: ?*ENTRYID, lpfButtonCallback: ?LPFNBUTTON, lpvButtonContext: ?*anyopaque, lpszButtonText: ?*i8, ulFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.Details(self, lpulUIParam, lpfnDismiss, lpvDismissContext, cbEntryID, lpEntryID, lpfButtonCallback, lpvButtonContext, lpszButtonText, ulFlags);
    }
    pub fn RecipOptions(self: *const IAddrBook, ulUIParam: u32, ulFlags: u32, lpRecip: ?*ADRENTRY) callconv(.Inline) HRESULT {
        return self.vtable.RecipOptions(self, ulUIParam, ulFlags, lpRecip);
    }
    pub fn QueryDefaultRecipOpt(self: *const IAddrBook, lpszAdrType: ?*i8, ulFlags: u32, lpcValues: ?*u32, lppOptions: ?*?*SPropValue) callconv(.Inline) HRESULT {
        return self.vtable.QueryDefaultRecipOpt(self, lpszAdrType, ulFlags, lpcValues, lppOptions);
    }
    pub fn GetPAB(self: *const IAddrBook, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.GetPAB(self, lpcbEntryID, lppEntryID);
    }
    pub fn SetPAB(self: *const IAddrBook, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.SetPAB(self, cbEntryID, lpEntryID);
    }
    pub fn GetDefaultDir(self: *const IAddrBook, lpcbEntryID: ?*u32, lppEntryID: ?*?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.GetDefaultDir(self, lpcbEntryID, lppEntryID);
    }
    pub fn SetDefaultDir(self: *const IAddrBook, cbEntryID: u32, lpEntryID: ?*ENTRYID) callconv(.Inline) HRESULT {
        return self.vtable.SetDefaultDir(self, cbEntryID, lpEntryID);
    }
    pub fn GetSearchPath(self: *const IAddrBook, ulFlags: u32, lppSearchPath: ?*?*SRowSet) callconv(.Inline) HRESULT {
        return self.vtable.GetSearchPath(self, ulFlags, lppSearchPath);
    }
    pub fn SetSearchPath(self: *const IAddrBook, ulFlags: u32, lpSearchPath: ?*SRowSet) callconv(.Inline) HRESULT {
        return self.vtable.SetSearchPath(self, ulFlags, lpSearchPath);
    }
    pub fn PrepareRecips(self: *const IAddrBook, ulFlags: u32, lpPropTagArray: ?*SPropTagArray, lpRecipList: ?*ADRLIST) callconv(.Inline) HRESULT {
        return self.vtable.PrepareRecips(self, ulFlags, lpPropTagArray, lpRecipList);
    }
};

pub const _WABACTIONITEM = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

// TODO: this type is limited to platform 'windows5.0'
pub const IWABObject = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLastError: *const fn(
            self: *const IWABObject,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateBuffer: *const fn(
            self: *const IWABObject,
            cbSize: u32,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateMore: *const fn(
            self: *const IWABObject,
            cbSize: u32,
            lpObject: ?*anyopaque,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: *const fn(
            self: *const IWABObject,
            lpBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backup: *const fn(
            self: *const IWABObject,
            lpFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: *const fn(
            self: *const IWABObject,
            lpWIP: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardDisplay: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            lpszFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LDAPUrl: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            ulFlags: u32,
            lpszURL: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardCreate: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lpMailUser: ?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardRetrieve: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMe: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpdwAction: ?*u32,
            lpsbEID: ?*SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMe: *const fn(
            self: *const IWABObject,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            sbEID: SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn GetLastError(self: *const IWABObject, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
        return self.vtable.GetLastError(self, hResult, ulFlags, lppMAPIError);
    }
    pub fn AllocateBuffer(self: *const IWABObject, cbSize: u32, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.AllocateBuffer(self, cbSize, lppBuffer);
    }
    pub fn AllocateMore(self: *const IWABObject, cbSize: u32, lpObject: ?*anyopaque, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.AllocateMore(self, cbSize, lpObject, lppBuffer);
    }
    pub fn FreeBuffer(self: *const IWABObject, lpBuffer: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.FreeBuffer(self, lpBuffer);
    }
    pub fn Backup(self: *const IWABObject, lpFileName: ?PSTR) callconv(.Inline) HRESULT {
        return self.vtable.Backup(self, lpFileName);
    }
    pub fn Import(self: *const IWABObject, lpWIP: ?PSTR) callconv(.Inline) HRESULT {
        return self.vtable.Import(self, lpWIP);
    }
    pub fn Find(self: *const IWABObject, lpIAB: ?*IAddrBook, hWnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.Find(self, lpIAB, hWnd);
    }
    pub fn VCardDisplay(self: *const IWABObject, lpIAB: ?*IAddrBook, hWnd: ?HWND, lpszFileName: ?PSTR) callconv(.Inline) HRESULT {
        return self.vtable.VCardDisplay(self, lpIAB, hWnd, lpszFileName);
    }
    pub fn LDAPUrl(self: *const IWABObject, lpIAB: ?*IAddrBook, hWnd: ?HWND, ulFlags: u32, lpszURL: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
        return self.vtable.LDAPUrl(self, lpIAB, hWnd, ulFlags, lpszURL, lppMailUser);
    }
    pub fn VCardCreate(self: *const IWABObject, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lpMailUser: ?*IMailUser) callconv(.Inline) HRESULT {
        return self.vtable.VCardCreate(self, lpIAB, ulFlags, lpszVCard, lpMailUser);
    }
    pub fn VCardRetrieve(self: *const IWABObject, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
        return self.vtable.VCardRetrieve(self, lpIAB, ulFlags, lpszVCard, lppMailUser);
    }
    pub fn GetMe(self: *const IWABObject, lpIAB: ?*IAddrBook, ulFlags: u32, lpdwAction: ?*u32, lpsbEID: ?*SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.GetMe(self, lpIAB, ulFlags, lpdwAction, lpsbEID, hwnd);
    }
    pub fn SetMe(self: *const IWABObject, lpIAB: ?*IAddrBook, ulFlags: u32, sbEID: SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.SetMe(self, lpIAB, ulFlags, sbEID, hwnd);
    }
};

pub const IWABOBJECT_QueryInterface_METHOD = *const fn(
    riid: ?*const Guid,
    ppvObj: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AddRef_METHOD = *const fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const IWABOBJECT_Release_METHOD = *const fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const IWABOBJECT_GetLastError_METHOD = *const fn(
    hResult: HRESULT,
    ulFlags: u32,
    lppMAPIError: ?*?*MAPIERROR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AllocateBuffer_METHOD = *const fn(
    cbSize: u32,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_AllocateMore_METHOD = *const fn(
    cbSize: u32,
    lpObject: ?*anyopaque,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_FreeBuffer_METHOD = *const fn(
    lpBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Backup_METHOD = *const fn(
    lpFileName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Import_METHOD = *const fn(
    lpWIP: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_Find_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    hWnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardDisplay_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    hWnd: ?HWND,
    lpszFileName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_LDAPUrl_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    hWnd: ?HWND,
    ulFlags: u32,
    lpszURL: ?PSTR,
    lppMailUser: ?*?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardCreate_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    lpszVCard: ?PSTR,
    lpMailUser: ?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_VCardRetrieve_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    lpszVCard: ?PSTR,
    lppMailUser: ?*?*IMailUser,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_GetMe_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    lpdwAction: ?*u32,
    lpsbEID: ?*SBinary,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_SetMe_METHOD = *const fn(
    lpIAB: ?*IAddrBook,
    ulFlags: u32,
    sbEID: SBinary,
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const IWABOBJECT_ = extern union {
    pub const VTable = extern struct {
        QueryInterface: *const fn(
            self: *const IWABOBJECT_,
            riid: ?*const Guid,
            ppvObj: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: *const fn(
            self: *const IWABOBJECT_,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: *const fn(
            self: *const IWABOBJECT_,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetLastError: *const fn(
            self: *const IWABOBJECT_,
            hResult: HRESULT,
            ulFlags: u32,
            lppMAPIError: ?*?*MAPIERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateBuffer: *const fn(
            self: *const IWABOBJECT_,
            cbSize: u32,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateMore: *const fn(
            self: *const IWABOBJECT_,
            cbSize: u32,
            lpObject: ?*anyopaque,
            lppBuffer: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: *const fn(
            self: *const IWABOBJECT_,
            lpBuffer: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Backup: *const fn(
            self: *const IWABOBJECT_,
            lpFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: *const fn(
            self: *const IWABOBJECT_,
            lpWIP: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardDisplay: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            lpszFileName: ?PSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LDAPUrl: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            hWnd: ?HWND,
            ulFlags: u32,
            lpszURL: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardCreate: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lpMailUser: ?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VCardRetrieve: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpszVCard: ?PSTR,
            lppMailUser: ?*?*IMailUser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMe: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            lpdwAction: ?*u32,
            lpsbEID: ?*SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMe: *const fn(
            self: *const IWABOBJECT_,
            lpIAB: ?*IAddrBook,
            ulFlags: u32,
            sbEID: SBinary,
            hwnd: ?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn QueryInterface(self: *const IWABOBJECT_, riid: ?*const Guid, ppvObj: ?*?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.QueryInterface(self, riid, ppvObj);
    }
    pub fn AddRef(self: *const IWABOBJECT_) callconv(.Inline) u32 {
        return self.vtable.AddRef(self);
    }
    pub fn Release(self: *const IWABOBJECT_) callconv(.Inline) u32 {
        return self.vtable.Release(self);
    }
    pub fn GetLastError(self: *const IWABOBJECT_, hResult: HRESULT, ulFlags: u32, lppMAPIError: ?*?*MAPIERROR) callconv(.Inline) HRESULT {
        return self.vtable.GetLastError(self, hResult, ulFlags, lppMAPIError);
    }
    pub fn AllocateBuffer(self: *const IWABOBJECT_, cbSize: u32, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.AllocateBuffer(self, cbSize, lppBuffer);
    }
    pub fn AllocateMore(self: *const IWABOBJECT_, cbSize: u32, lpObject: ?*anyopaque, lppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.AllocateMore(self, cbSize, lpObject, lppBuffer);
    }
    pub fn FreeBuffer(self: *const IWABOBJECT_, lpBuffer: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.FreeBuffer(self, lpBuffer);
    }
    pub fn Backup(self: *const IWABOBJECT_, lpFileName: ?PSTR) callconv(.Inline) HRESULT {
        return self.vtable.Backup(self, lpFileName);
    }
    pub fn Import(self: *const IWABOBJECT_, lpWIP: ?PSTR) callconv(.Inline) HRESULT {
        return self.vtable.Import(self, lpWIP);
    }
    pub fn Find(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, hWnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.Find(self, lpIAB, hWnd);
    }
    pub fn VCardDisplay(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, hWnd: ?HWND, lpszFileName: ?PSTR) callconv(.Inline) HRESULT {
        return self.vtable.VCardDisplay(self, lpIAB, hWnd, lpszFileName);
    }
    pub fn LDAPUrl(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, hWnd: ?HWND, ulFlags: u32, lpszURL: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
        return self.vtable.LDAPUrl(self, lpIAB, hWnd, ulFlags, lpszURL, lppMailUser);
    }
    pub fn VCardCreate(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lpMailUser: ?*IMailUser) callconv(.Inline) HRESULT {
        return self.vtable.VCardCreate(self, lpIAB, ulFlags, lpszVCard, lpMailUser);
    }
    pub fn VCardRetrieve(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, ulFlags: u32, lpszVCard: ?PSTR, lppMailUser: ?*?*IMailUser) callconv(.Inline) HRESULT {
        return self.vtable.VCardRetrieve(self, lpIAB, ulFlags, lpszVCard, lppMailUser);
    }
    pub fn GetMe(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, ulFlags: u32, lpdwAction: ?*u32, lpsbEID: ?*SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.GetMe(self, lpIAB, ulFlags, lpdwAction, lpsbEID, hwnd);
    }
    pub fn SetMe(self: *const IWABOBJECT_, lpIAB: ?*IAddrBook, ulFlags: u32, sbEID: SBinary, hwnd: ?HWND) callconv(.Inline) HRESULT {
        return self.vtable.SetMe(self, lpIAB, ulFlags, sbEID, hwnd);
    }
};

pub const WAB_PARAM = extern struct {
    cbSize: u32,
    hwnd: ?HWND,
    szFileName: ?PSTR,
    ulFlags: u32,
    guidPSExt: Guid,
};

pub const LPWABOPEN = *const fn(
    lppAdrBook: ?*?*IAddrBook,
    lppWABObject: ?*?*IWABObject,
    lpWP: ?*WAB_PARAM,
    Reserved2: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPWABOPENEX = *const fn(
    lppAdrBook: ?*?*IAddrBook,
    lppWABObject: ?*?*IWABObject,
    lpWP: ?*WAB_PARAM,
    Reserved: u32,
    fnAllocateBuffer: ?LPALLOCATEBUFFER,
    fnAllocateMore: ?LPALLOCATEMORE,
    fnFreeBuffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const WABIMPORTPARAM = extern struct {
    cbSize: u32,
    lpAdrBook: ?*IAddrBook,
    hWnd: ?HWND,
    ulFlags: u32,
    lpszFileName: ?PSTR,
};

pub const WABEXTDISPLAY = extern struct {
    cbSize: u32,
    lpWABObject: ?*IWABObject,
    lpAdrBook: ?*IAddrBook,
    lpPropObj: ?*IMAPIProp,
    fReadOnly: BOOL,
    fDataChanged: BOOL,
    ulFlags: u32,
    lpv: ?*anyopaque,
    lpsz: ?*i8,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IWABExtInit_Value = Guid.initString("ea22ebf0-87a4-11d1-9acf-00a0c91f9c8b");
pub const IID_IWABExtInit = &IID_IWABExtInit_Value;
pub const IWABExtInit = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: *const fn(
            self: *const IWABExtInit,
            lpWABExtDisplay: ?*WABEXTDISPLAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Initialize(self: *const IWABExtInit, lpWABExtDisplay: ?*WABEXTDISPLAY) callconv(.Inline) HRESULT {
        return self.vtable.Initialize(self, lpWABExtDisplay);
    }
};

pub const LPWABALLOCATEBUFFER = *const fn(
    lpWABObject: ?*IWABObject,
    cbSize: u32,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWABALLOCATEMORE = *const fn(
    lpWABObject: ?*IWABObject,
    cbSize: u32,
    lpObject: ?*anyopaque,
    lppBuffer: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWABFREEBUFFER = *const fn(
    lpWABObject: ?*IWABObject,
    lpBuffer: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const NOTIFKEY = extern struct {
    cb: u32,
    ab: [1]u8,
};


//--------------------------------------------------------------------------------
// Section: Functions (57)
//--------------------------------------------------------------------------------
pub extern "rtm" fn CreateTable(
    lpInterface: ?*Guid,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpvReserved: ?*anyopaque,
    ulTableType: u32,
    ulPropTagIndexColumn: u32,
    lpSPropTagArrayColumns: ?*SPropTagArray,
    lppTableData: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn CreateIProp(
    lpInterface: ?*Guid,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpvReserved: ?*anyopaque,
    lppPropData: ?*?*IPropData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn MAPIInitIdle(
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn MAPIDeinitIdle(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FtgRegisterIdleRoutine(
    lpfnIdle: ?PFNIDLE,
    lpvIdleParam: ?*anyopaque,
    priIdle: i16,
    csecIdle: u32,
    iroIdle: u16,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "mapi32" fn DeregisterIdleRoutine(
    ftg: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn EnableIdleRoutine(
    ftg: ?*anyopaque,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn ChangeIdleRoutine(
    ftg: ?*anyopaque,
    lpfnIdle: ?PFNIDLE,
    lpvIdleParam: ?*anyopaque,
    priIdle: i16,
    csecIdle: u32,
    iroIdle: u16,
    ircIdle: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn MAPIGetDefaultMalloc(
) callconv(@import("std").os.windows.WINAPI) ?*IMalloc;

pub extern "mapi32" fn OpenStreamOnFile(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    ulFlags: u32,
    lpszFileName: ?*i8,
    lpszPrefix: ?*i8,
    lppStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn PropCopyMore(
    lpSPropValueDest: ?*SPropValue,
    lpSPropValueSrc: ?*SPropValue,
    lpfAllocMore: ?LPALLOCATEMORE,
    lpvObject: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn UlPropSize(
    lpSPropValue: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn FEqualNames(
    lpName1: ?*MAPINAMEID,
    lpName2: ?*MAPINAMEID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn FPropContainsProp(
    lpSPropValueDst: ?*SPropValue,
    lpSPropValueSrc: ?*SPropValue,
    ulFuzzyLevel: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn FPropCompareProp(
    lpSPropValue1: ?*SPropValue,
    ulRelOp: u32,
    lpSPropValue2: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn LPropCompareProp(
    lpSPropValueA: ?*SPropValue,
    lpSPropValueB: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn HrAddColumns(
    lptbl: ?*IMAPITable,
    lpproptagColumnsNew: ?*SPropTagArray,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrAddColumnsEx(
    lptbl: ?*IMAPITable,
    lpproptagColumnsNew: ?*SPropTagArray,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpfnFilterColumns: isize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrAllocAdviseSink(
    lpfnCallback: ?LPNOTIFCALLBACK,
    lpvContext: ?*anyopaque,
    lppAdviseSink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrThisThreadAdviseSink(
    lpAdviseSink: ?*IMAPIAdviseSink,
    lppAdviseSink: ?*?*IMAPIAdviseSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrDispatchNotifications(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn BuildDisplayTable(
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lpAllocateMore: ?LPALLOCATEMORE,
    lpFreeBuffer: ?LPFREEBUFFER,
    lpMalloc: ?*IMalloc,
    hInstance: ?HINSTANCE,
    cPages: u32,
    lpPage: ?*DTPAGE,
    ulFlags: u32,
    lppTable: ?*?*IMAPITable,
    lppTblData: ?*?*ITableData,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn ScCountNotifications(
    cNotifications: i32,
    lpNotifications: ?*NOTIFICATION,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScCopyNotifications(
    cNotification: i32,
    lpNotifications: ?*NOTIFICATION,
    lpvDst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScRelocNotifications(
    cNotification: i32,
    lpNotifications: ?*NOTIFICATION,
    lpvBaseOld: ?*anyopaque,
    lpvBaseNew: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScCountProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn LpValFindProp(
    ulPropTag: u32,
    cValues: u32,
    lpPropArray: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "mapi32" fn ScCopyProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpvDst: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScRelocProps(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpvBaseOld: ?*anyopaque,
    lpvBaseNew: ?*anyopaque,
    lpcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScDupPropset(
    cValues: i32,
    lpPropArray: ?*SPropValue,
    lpAllocateBuffer: ?LPALLOCATEBUFFER,
    lppPropArray: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn UlAddRef(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn UlRelease(
    lpunk: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn HrGetOneProp(
    lpMapiProp: ?*IMAPIProp,
    ulPropTag: u32,
    lppProp: ?*?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrSetOneProp(
    lpMapiProp: ?*IMAPIProp,
    lpProp: ?*SPropValue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn FPropExists(
    lpMapiProp: ?*IMAPIProp,
    ulPropTag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mapi32" fn PpropFindProp(
    lpPropArray: ?*SPropValue,
    cValues: u32,
    ulPropTag: u32,
) callconv(@import("std").os.windows.WINAPI) ?*SPropValue;

pub extern "mapi32" fn FreePadrlist(
    lpAdrlist: ?*ADRLIST,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn FreeProws(
    lpRows: ?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "mapi32" fn HrQueryAllRows(
    lpTable: ?*IMAPITable,
    lpPropTags: ?*SPropTagArray,
    lpRestriction: ?*SRestriction,
    lpSortOrderSet: ?*SSortOrderSet,
    crowsMax: i32,
    lppRows: ?*?*SRowSet,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn SzFindCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn SzFindLastCh(
    lpsz: ?*i8,
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn SzFindSz(
    lpsz: ?*i8,
    lpszKey: ?*i8,
) callconv(@import("std").os.windows.WINAPI) ?*i8;

pub extern "mapi32" fn UFromSz(
    lpsz: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "mapi32" fn ScUNCFromLocalPath(
    lpszLocal: ?PSTR,
    lpszUNC: [*:0]u8,
    cchUNC: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn ScLocalPathFromUNC(
    lpszUNC: ?PSTR,
    lpszLocal: [*:0]u8,
    cchLocal: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn FtAddFt(
    ftAddend1: FILETIME,
    ftAddend2: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtMulDwDw(
    ftMultiplicand: u32,
    ftMultiplier: u32,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtMulDw(
    ftMultiplier: u32,
    ftMultiplicand: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtSubFt(
    ftMinuend: FILETIME,
    ftSubtrahend: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn FtNegFt(
    ft: FILETIME,
) callconv(@import("std").os.windows.WINAPI) FILETIME;

pub extern "mapi32" fn ScCreateConversationIndex(
    cbParent: u32,
    lpbParent: ?*u8,
    lpcbConvIndex: ?*u32,
    lppbConvIndex: ?*?*u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn WrapStoreEntryID(
    ulFlags: u32,
    lpszDLLName: ?*i8,
    cbOrigEntry: u32,
    // TODO: what to do with BytesParamIndex 2?
    lpOrigEntry: ?*ENTRYID,
    lpcbWrappedEntry: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    lppWrappedEntry: ?*?*ENTRYID,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn RTFSync(
    lpMessage: ?*IMessage,
    ulFlags: u32,
    lpfMessageUpdated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn WrapCompressedRTFStream(
    lpCompressedRTFStream: ?*IStream,
    ulFlags: u32,
    lpUncompressedRTFStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn HrIStorageFromStream(
    lpUnkIn: ?*IUnknown,
    lpInterface: ?*Guid,
    ulFlags: u32,
    lppStorageOut: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mapi32" fn ScInitMapiUtil(
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "mapi32" fn DeinitMapiUtil(
) callconv(@import("std").os.windows.WINAPI) void;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
//--------------------------------------------------------------------------------
// Section: Imports (14)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const CY = @import("../system/com.zig").CY;
const FILETIME = @import("../foundation.zig").FILETIME;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IMalloc = @import("../system/com.zig").IMalloc;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPALLOCATEBUFFER")) { _ = LPALLOCATEBUFFER; }
    if (@hasDecl(@This(), "LPALLOCATEMORE")) { _ = LPALLOCATEMORE; }
    if (@hasDecl(@This(), "LPFREEBUFFER")) { _ = LPFREEBUFFER; }
    if (@hasDecl(@This(), "LPNOTIFCALLBACK")) { _ = LPNOTIFCALLBACK; }
    if (@hasDecl(@This(), "LPFNABSDI")) { _ = LPFNABSDI; }
    if (@hasDecl(@This(), "LPFNDISMISS")) { _ = LPFNDISMISS; }
    if (@hasDecl(@This(), "LPFNBUTTON")) { _ = LPFNBUTTON; }
    if (@hasDecl(@This(), "PFNIDLE")) { _ = PFNIDLE; }
    if (@hasDecl(@This(), "LPOPENSTREAMONFILE")) { _ = LPOPENSTREAMONFILE; }
    if (@hasDecl(@This(), "LPDISPATCHNOTIFICATIONS")) { _ = LPDISPATCHNOTIFICATIONS; }
    if (@hasDecl(@This(), "LPCREATECONVERSATIONINDEX")) { _ = LPCREATECONVERSATIONINDEX; }
    if (@hasDecl(@This(), "IWABOBJECT_QueryInterface_METHOD")) { _ = IWABOBJECT_QueryInterface_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_AddRef_METHOD")) { _ = IWABOBJECT_AddRef_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Release_METHOD")) { _ = IWABOBJECT_Release_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_GetLastError_METHOD")) { _ = IWABOBJECT_GetLastError_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateBuffer_METHOD")) { _ = IWABOBJECT_AllocateBuffer_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_AllocateMore_METHOD")) { _ = IWABOBJECT_AllocateMore_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_FreeBuffer_METHOD")) { _ = IWABOBJECT_FreeBuffer_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Backup_METHOD")) { _ = IWABOBJECT_Backup_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Import_METHOD")) { _ = IWABOBJECT_Import_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_Find_METHOD")) { _ = IWABOBJECT_Find_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_VCardDisplay_METHOD")) { _ = IWABOBJECT_VCardDisplay_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_LDAPUrl_METHOD")) { _ = IWABOBJECT_LDAPUrl_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_VCardCreate_METHOD")) { _ = IWABOBJECT_VCardCreate_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_VCardRetrieve_METHOD")) { _ = IWABOBJECT_VCardRetrieve_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_GetMe_METHOD")) { _ = IWABOBJECT_GetMe_METHOD; }
    if (@hasDecl(@This(), "IWABOBJECT_SetMe_METHOD")) { _ = IWABOBJECT_SetMe_METHOD; }
    if (@hasDecl(@This(), "LPWABOPEN")) { _ = LPWABOPEN; }
    if (@hasDecl(@This(), "LPWABOPENEX")) { _ = LPWABOPENEX; }
    if (@hasDecl(@This(), "LPWABALLOCATEBUFFER")) { _ = LPWABALLOCATEBUFFER; }
    if (@hasDecl(@This(), "LPWABALLOCATEMORE")) { _ = LPWABALLOCATEMORE; }
    if (@hasDecl(@This(), "LPWABFREEBUFFER")) { _ = LPWABFREEBUFFER; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
