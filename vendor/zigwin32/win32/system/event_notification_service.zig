//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (12)
//--------------------------------------------------------------------------------
pub const NETWORK_ALIVE_LAN = @as(u32, 1);
pub const NETWORK_ALIVE_WAN = @as(u32, 2);
pub const NETWORK_ALIVE_AOL = @as(u32, 4);
pub const NETWORK_ALIVE_INTERNET = @as(u32, 8);
pub const CONNECTION_AOL = @as(u32, 4);
pub const SENSGUID_PUBLISHER = Guid.initString("5fee1bd6-5b9b-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_SUBSCRIBER_LCE = Guid.initString("d3938ab0-5b9d-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_SUBSCRIBER_WININET = Guid.initString("d3938ab5-5b9d-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_NETWORK = Guid.initString("d5978620-5b9f-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_LOGON = Guid.initString("d5978630-5b9f-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_ONNOW = Guid.initString("d5978640-5b9f-11d1-8dd2-00aa004abd5e");
pub const SENSGUID_EVENTCLASS_LOGON2 = Guid.initString("d5978650-5b9f-11d1-8dd2-00aa004abd5e");

//--------------------------------------------------------------------------------
// Section: Types (8)
//--------------------------------------------------------------------------------
pub const SENS_CONNECTION_TYPE = enum(u32) {
    LAN = 0,
    WAN = 1,
};
pub const CONNECTION_LAN = SENS_CONNECTION_TYPE.LAN;
pub const CONNECTION_WAN = SENS_CONNECTION_TYPE.WAN;

pub const QOCINFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwInSpeed: u32,
    dwOutSpeed: u32,
};

const CLSID_SENS_Value = Guid.initString("d597cafe-5b9f-11d1-8dd2-00aa004abd5e");
pub const CLSID_SENS = &CLSID_SENS_Value;

pub const SENS_QOCINFO = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwOutSpeed: u32,
    dwInSpeed: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensNetwork_Value = Guid.initString("d597bab1-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensNetwork = &IID_ISensNetwork_Value;
pub const ISensNetwork = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConnectionMade: *const fn(
            self: *const ISensNetwork,
            bstrConnection: ?BSTR,
            ulType: u32,
            lpQOCInfo: ?*SENS_QOCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionMadeNoQOCInfo: *const fn(
            self: *const ISensNetwork,
            bstrConnection: ?BSTR,
            ulType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectionLost: *const fn(
            self: *const ISensNetwork,
            bstrConnection: ?BSTR,
            ulType: SENS_CONNECTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestinationReachable: *const fn(
            self: *const ISensNetwork,
            bstrDestination: ?BSTR,
            bstrConnection: ?BSTR,
            ulType: u32,
            lpQOCInfo: ?*SENS_QOCINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestinationReachableNoQOCInfo: *const fn(
            self: *const ISensNetwork,
            bstrDestination: ?BSTR,
            bstrConnection: ?BSTR,
            ulType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn ConnectionMade(self: *const ISensNetwork, bstrConnection: ?BSTR, ulType: u32, lpQOCInfo: ?*SENS_QOCINFO) callconv(.Inline) HRESULT {
        return self.vtable.ConnectionMade(self, bstrConnection, ulType, lpQOCInfo);
    }
    pub fn ConnectionMadeNoQOCInfo(self: *const ISensNetwork, bstrConnection: ?BSTR, ulType: u32) callconv(.Inline) HRESULT {
        return self.vtable.ConnectionMadeNoQOCInfo(self, bstrConnection, ulType);
    }
    pub fn ConnectionLost(self: *const ISensNetwork, bstrConnection: ?BSTR, ulType: SENS_CONNECTION_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.ConnectionLost(self, bstrConnection, ulType);
    }
    pub fn DestinationReachable(self: *const ISensNetwork, bstrDestination: ?BSTR, bstrConnection: ?BSTR, ulType: u32, lpQOCInfo: ?*SENS_QOCINFO) callconv(.Inline) HRESULT {
        return self.vtable.DestinationReachable(self, bstrDestination, bstrConnection, ulType, lpQOCInfo);
    }
    pub fn DestinationReachableNoQOCInfo(self: *const ISensNetwork, bstrDestination: ?BSTR, bstrConnection: ?BSTR, ulType: u32) callconv(.Inline) HRESULT {
        return self.vtable.DestinationReachableNoQOCInfo(self, bstrDestination, bstrConnection, ulType);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensOnNow_Value = Guid.initString("d597bab2-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensOnNow = &IID_ISensOnNow_Value;
pub const ISensOnNow = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OnACPower: *const fn(
            self: *const ISensOnNow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBatteryPower: *const fn(
            self: *const ISensOnNow,
            dwBatteryLifePercent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BatteryLow: *const fn(
            self: *const ISensOnNow,
            dwBatteryLifePercent: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn OnACPower(self: *const ISensOnNow) callconv(.Inline) HRESULT {
        return self.vtable.OnACPower(self);
    }
    pub fn OnBatteryPower(self: *const ISensOnNow, dwBatteryLifePercent: u32) callconv(.Inline) HRESULT {
        return self.vtable.OnBatteryPower(self, dwBatteryLifePercent);
    }
    pub fn BatteryLow(self: *const ISensOnNow, dwBatteryLifePercent: u32) callconv(.Inline) HRESULT {
        return self.vtable.BatteryLow(self, dwBatteryLifePercent);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensLogon_Value = Guid.initString("d597bab3-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensLogon = &IID_ISensLogon_Value;
pub const ISensLogon = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Logon: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logoff: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartShell: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayLock: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisplayUnlock: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartScreenSaver: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopScreenSaver: *const fn(
            self: *const ISensLogon,
            bstrUserName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn Logon(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Logon(self, bstrUserName);
    }
    pub fn Logoff(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Logoff(self, bstrUserName);
    }
    pub fn StartShell(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.StartShell(self, bstrUserName);
    }
    pub fn DisplayLock(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.DisplayLock(self, bstrUserName);
    }
    pub fn DisplayUnlock(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.DisplayUnlock(self, bstrUserName);
    }
    pub fn StartScreenSaver(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.StartScreenSaver(self, bstrUserName);
    }
    pub fn StopScreenSaver(self: *const ISensLogon, bstrUserName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.StopScreenSaver(self, bstrUserName);
    }
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISensLogon2_Value = Guid.initString("d597bab4-5b9f-11d1-8dd2-00aa004abd5e");
pub const IID_ISensLogon2 = &IID_ISensLogon2_Value;
pub const ISensLogon2 = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Logon: *const fn(
            self: *const ISensLogon2,
            bstrUserName: ?BSTR,
            dwSessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Logoff: *const fn(
            self: *const ISensLogon2,
            bstrUserName: ?BSTR,
            dwSessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionDisconnect: *const fn(
            self: *const ISensLogon2,
            bstrUserName: ?BSTR,
            dwSessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionReconnect: *const fn(
            self: *const ISensLogon2,
            bstrUserName: ?BSTR,
            dwSessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostShell: *const fn(
            self: *const ISensLogon2,
            bstrUserName: ?BSTR,
            dwSessionId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn Logon(self: *const ISensLogon2, bstrUserName: ?BSTR, dwSessionId: u32) callconv(.Inline) HRESULT {
        return self.vtable.Logon(self, bstrUserName, dwSessionId);
    }
    pub fn Logoff(self: *const ISensLogon2, bstrUserName: ?BSTR, dwSessionId: u32) callconv(.Inline) HRESULT {
        return self.vtable.Logoff(self, bstrUserName, dwSessionId);
    }
    pub fn SessionDisconnect(self: *const ISensLogon2, bstrUserName: ?BSTR, dwSessionId: u32) callconv(.Inline) HRESULT {
        return self.vtable.SessionDisconnect(self, bstrUserName, dwSessionId);
    }
    pub fn SessionReconnect(self: *const ISensLogon2, bstrUserName: ?BSTR, dwSessionId: u32) callconv(.Inline) HRESULT {
        return self.vtable.SessionReconnect(self, bstrUserName, dwSessionId);
    }
    pub fn PostShell(self: *const ISensLogon2, bstrUserName: ?BSTR, dwSessionId: u32) callconv(.Inline) HRESULT {
        return self.vtable.PostShell(self, bstrUserName, dwSessionId);
    }
};


//--------------------------------------------------------------------------------
// Section: Functions (3)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sensapi" fn IsDestinationReachableA(
    lpszDestination: ?[*:0]const u8,
    lpQOCInfo: ?*QOCINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sensapi" fn IsDestinationReachableW(
    lpszDestination: ?[*:0]const u16,
    lpQOCInfo: ?*QOCINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sensapi" fn IsNetworkAlive(
    lpdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (1)
//--------------------------------------------------------------------------------
pub const IsDestinationReachable = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().IsDestinationReachableA,
    .wide => @This().IsDestinationReachableW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'IsDestinationReachable' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const HRESULT = @import("../foundation.zig").HRESULT;
const IDispatch = @import("../system/com.zig").IDispatch;
const IUnknown = @import("../system/com.zig").IUnknown;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
