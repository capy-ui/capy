//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (14)
//--------------------------------------------------------------------------------
pub const FIND_RESOURCE_DIRECTORY_TYPES = @as(u32, 256);
pub const FIND_RESOURCE_DIRECTORY_NAMES = @as(u32, 512);
pub const FIND_RESOURCE_DIRECTORY_LANGUAGES = @as(u32, 1024);
pub const RESOURCE_ENUM_LN = @as(u32, 1);
pub const RESOURCE_ENUM_MUI = @as(u32, 2);
pub const RESOURCE_ENUM_MUI_SYSTEM = @as(u32, 4);
pub const RESOURCE_ENUM_VALIDATE = @as(u32, 8);
pub const RESOURCE_ENUM_MODULE_EXACT = @as(u32, 16);
pub const SUPPORT_LANG_NUMBER = @as(u32, 32);
pub const GET_MODULE_HANDLE_EX_FLAG_PIN = @as(u32, 1);
pub const GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = @as(u32, 2);
pub const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = @as(u32, 4);
pub const CURRENT_IMPORT_REDIRECTION_VERSION = @as(u32, 1);
pub const LOAD_LIBRARY_OS_INTEGRITY_CONTINUITY = @as(u32, 32768);

//--------------------------------------------------------------------------------
// Section: Types (12)
//--------------------------------------------------------------------------------
pub const LOAD_LIBRARY_FLAGS = packed struct(u32) {
    DONT_RESOLVE_DLL_REFERENCES: u1 = 0,
    LOAD_LIBRARY_AS_DATAFILE: u1 = 0,
    _2: u1 = 0,
    LOAD_WITH_ALTERED_SEARCH_PATH: u1 = 0,
    LOAD_IGNORE_CODE_AUTHZ_LEVEL: u1 = 0,
    LOAD_LIBRARY_AS_IMAGE_RESOURCE: u1 = 0,
    LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE: u1 = 0,
    LOAD_LIBRARY_REQUIRE_SIGNED_TARGET: u1 = 0,
    LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR: u1 = 0,
    LOAD_LIBRARY_SEARCH_APPLICATION_DIR: u1 = 0,
    LOAD_LIBRARY_SEARCH_USER_DIRS: u1 = 0,
    LOAD_LIBRARY_SEARCH_SYSTEM32: u1 = 0,
    LOAD_LIBRARY_SEARCH_DEFAULT_DIRS: u1 = 0,
    LOAD_LIBRARY_SAFE_CURRENT_DIRS: u1 = 0,
    LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const DONT_RESOLVE_DLL_REFERENCES = LOAD_LIBRARY_FLAGS{ .DONT_RESOLVE_DLL_REFERENCES = 1 };
pub const LOAD_LIBRARY_AS_DATAFILE = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_AS_DATAFILE = 1 };
pub const LOAD_WITH_ALTERED_SEARCH_PATH = LOAD_LIBRARY_FLAGS{ .LOAD_WITH_ALTERED_SEARCH_PATH = 1 };
pub const LOAD_IGNORE_CODE_AUTHZ_LEVEL = LOAD_LIBRARY_FLAGS{ .LOAD_IGNORE_CODE_AUTHZ_LEVEL = 1 };
pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_AS_IMAGE_RESOURCE = 1 };
pub const LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 1 };
pub const LOAD_LIBRARY_REQUIRE_SIGNED_TARGET = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_REQUIRE_SIGNED_TARGET = 1 };
pub const LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 1 };
pub const LOAD_LIBRARY_SEARCH_APPLICATION_DIR = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 1 };
pub const LOAD_LIBRARY_SEARCH_USER_DIRS = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SEARCH_USER_DIRS = 1 };
pub const LOAD_LIBRARY_SEARCH_SYSTEM32 = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SEARCH_SYSTEM32 = 1 };
pub const LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 1 };
pub const LOAD_LIBRARY_SAFE_CURRENT_DIRS = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SAFE_CURRENT_DIRS = 1 };
pub const LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER = LOAD_LIBRARY_FLAGS{ .LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER = 1 };

pub const ENUMUILANG = extern struct {
    NumOfEnumUILang: u32,
    SizeOfEnumUIBuffer: u32,
    pEnumUIBuffer: ?*u16,
};

pub const ENUMRESLANGPROCA = *const fn(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    wLanguage: u16,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESLANGPROCW = *const fn(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpName: ?[*:0]const u16,
    wLanguage: u16,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESNAMEPROCA = *const fn(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpName: ?PSTR,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESNAMEPROCW = *const fn(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpName: ?PWSTR,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESTYPEPROCA = *const fn(
    hModule: ?HINSTANCE,
    lpType: ?PSTR,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESTYPEPROCW = *const fn(
    hModule: ?HINSTANCE,
    lpType: ?PWSTR,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PGET_MODULE_HANDLE_EXA = *const fn(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u8,
    phModule: ?*?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PGET_MODULE_HANDLE_EXW = *const fn(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u16,
    phModule: ?*?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const REDIRECTION_FUNCTION_DESCRIPTOR = extern struct {
    DllName: ?[*:0]const u8,
    FunctionName: ?[*:0]const u8,
    RedirectionTarget: ?*anyopaque,
};

pub const REDIRECTION_DESCRIPTOR = extern struct {
    Version: u32,
    FunctionCount: u32,
    Redirections: ?*REDIRECTION_FUNCTION_DESCRIPTOR,
};


//--------------------------------------------------------------------------------
// Section: Functions (49)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DisableThreadLibraryCalls(
    hLibModule: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn FindResourceExW(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpName: ?[*:0]align(1) const u16,
    wLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) ?HRSRC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FreeLibrary(
    hLibModule: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FreeLibraryAndExitThread(
    hLibModule: ?HINSTANCE,
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) noreturn;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn FreeResource(
    hResData: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetModuleFileNameA(
    hModule: ?HINSTANCE,
    lpFilename: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetModuleFileNameW(
    hModule: ?HINSTANCE,
    lpFilename: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetModuleHandleA(
    lpModuleName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetModuleHandleW(
    lpModuleName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetModuleHandleExA(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u8,
    phModule: ?*?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetModuleHandleExW(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u16,
    phModule: ?*?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetProcAddress(
    hModule: ?HINSTANCE,
    lpProcName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?FARPROC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LoadLibraryExA(
    lpLibFileName: ?[*:0]const u8,
    hFile: ?HANDLE,
    dwFlags: LOAD_LIBRARY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LoadLibraryExW(
    lpLibFileName: ?[*:0]const u16,
    hFile: ?HANDLE,
    dwFlags: LOAD_LIBRARY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn LoadResource(
    hModule: ?HINSTANCE,
    hResInfo: ?HRSRC,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn LockResource(
    hResData: isize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn SizeofResource(
    hModule: ?HINSTANCE,
    hResInfo: ?HRSRC,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn AddDllDirectory(
    NewDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn RemoveDllDirectory(
    Cookie: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn SetDefaultDllDirectories(
    DirectoryFlags: LOAD_LIBRARY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumResourceLanguagesExA(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    lpEnumFunc: ?ENUMRESLANGPROCA,
    lParam: isize,
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumResourceLanguagesExW(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpName: ?[*:0]const u16,
    lpEnumFunc: ?ENUMRESLANGPROCW,
    lParam: isize,
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumResourceNamesExA(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpEnumFunc: ?ENUMRESNAMEPROCA,
    lParam: isize,
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumResourceNamesExW(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpEnumFunc: ?ENUMRESNAMEPROCW,
    lParam: isize,
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumResourceTypesExA(
    hModule: ?HINSTANCE,
    lpEnumFunc: ?ENUMRESTYPEPROCA,
    lParam: isize,
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn EnumResourceTypesExW(
    hModule: ?HINSTANCE,
    lpEnumFunc: ?ENUMRESTYPEPROCW,
    lParam: isize,
    dwFlags: u32,
    LangId: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn FindResourceW(
    hModule: ?HINSTANCE,
    lpName: ?[*:0]align(1) const u16,
    lpType: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) ?HRSRC;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LoadLibraryA(
    lpLibFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LoadLibraryW(
    lpLibFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

pub extern "kernel32" fn EnumResourceNamesW(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpEnumFunc: ?ENUMRESNAMEPROCW,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumResourceNamesA(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpEnumFunc: ?ENUMRESNAMEPROCA,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn LoadModule(
    lpModuleName: ?[*:0]const u8,
    lpParameterBlock: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn LoadPackagedLibrary(
    lpwLibFileName: ?[*:0]const u16,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn FindResourceA(
    hModule: ?HINSTANCE,
    lpName: ?[*:0]const u8,
    lpType: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HRSRC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn FindResourceExA(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    wLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) ?HRSRC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumResourceTypesA(
    hModule: ?HINSTANCE,
    lpEnumFunc: ?ENUMRESTYPEPROCA,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumResourceTypesW(
    hModule: ?HINSTANCE,
    lpEnumFunc: ?ENUMRESTYPEPROCW,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumResourceLanguagesA(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    lpEnumFunc: ?ENUMRESLANGPROCA,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EnumResourceLanguagesW(
    hModule: ?HINSTANCE,
    lpType: ?[*:0]align(1) const u16,
    lpName: ?[*:0]const u16,
    lpEnumFunc: ?ENUMRESLANGPROCW,
    lParam: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn BeginUpdateResourceA(
    pFileName: ?[*:0]const u8,
    bDeleteExistingResources: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn BeginUpdateResourceW(
    pFileName: ?[*:0]const u16,
    bDeleteExistingResources: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn UpdateResourceA(
    hUpdate: ?HANDLE,
    lpType: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    wLanguage: u16,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn UpdateResourceW(
    hUpdate: ?HANDLE,
    lpType: ?[*:0]align(1) const u16,
    lpName: ?[*:0]align(1) const u16,
    wLanguage: u16,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EndUpdateResourceA(
    hUpdate: ?HANDLE,
    fDiscard: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn EndUpdateResourceW(
    hUpdate: ?HANDLE,
    fDiscard: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetDllDirectoryA(
    lpPathName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetDllDirectoryW(
    lpPathName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetDllDirectoryA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetDllDirectoryW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (22)
//--------------------------------------------------------------------------------
pub const ENUMRESLANGPROC = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ENUMRESLANGPROCA,
    .wide => @This().ENUMRESLANGPROCW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ENUMRESLANGPROC' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ENUMRESNAMEPROC = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ENUMRESNAMEPROCA,
    .wide => @This().ENUMRESNAMEPROCW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ENUMRESNAMEPROC' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ENUMRESTYPEPROC = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ENUMRESTYPEPROCA,
    .wide => @This().ENUMRESTYPEPROCW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ENUMRESTYPEPROC' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const PGET_MODULE_HANDLE_EX = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().PGET_MODULE_HANDLE_EXA,
    .wide => @This().PGET_MODULE_HANDLE_EXW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'PGET_MODULE_HANDLE_EX' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindResourceEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindResourceExA,
    .wide => @This().FindResourceExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindResourceEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetModuleFileName = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetModuleFileNameA,
    .wide => @This().GetModuleFileNameW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetModuleFileName' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetModuleHandle = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetModuleHandleA,
    .wide => @This().GetModuleHandleW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetModuleHandle' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetModuleHandleEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetModuleHandleExA,
    .wide => @This().GetModuleHandleExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetModuleHandleEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const LoadLibraryEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().LoadLibraryExA,
    .wide => @This().LoadLibraryExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'LoadLibraryEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumResourceLanguagesEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumResourceLanguagesExA,
    .wide => @This().EnumResourceLanguagesExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumResourceLanguagesEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumResourceNamesEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumResourceNamesExA,
    .wide => @This().EnumResourceNamesExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumResourceNamesEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumResourceTypesEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumResourceTypesExA,
    .wide => @This().EnumResourceTypesExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumResourceTypesEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindResource = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindResourceA,
    .wide => @This().FindResourceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindResource' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const LoadLibrary = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().LoadLibraryA,
    .wide => @This().LoadLibraryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'LoadLibrary' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumResourceNames = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumResourceNamesA,
    .wide => @This().EnumResourceNamesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumResourceNames' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumResourceTypes = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumResourceTypesA,
    .wide => @This().EnumResourceTypesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumResourceTypes' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EnumResourceLanguages = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EnumResourceLanguagesA,
    .wide => @This().EnumResourceLanguagesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EnumResourceLanguages' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const BeginUpdateResource = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().BeginUpdateResourceA,
    .wide => @This().BeginUpdateResourceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'BeginUpdateResource' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const UpdateResource = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().UpdateResourceA,
    .wide => @This().UpdateResourceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'UpdateResource' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const EndUpdateResource = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().EndUpdateResourceA,
    .wide => @This().EndUpdateResourceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'EndUpdateResource' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const SetDllDirectory = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().SetDllDirectoryA,
    .wide => @This().SetDllDirectoryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'SetDllDirectory' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetDllDirectory = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetDllDirectoryA,
    .wide => @This().GetDllDirectoryW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetDllDirectory' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (7)
//--------------------------------------------------------------------------------
const BOOL = @import("../foundation.zig").BOOL;
const FARPROC = @import("../foundation.zig").FARPROC;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRSRC = @import("../foundation.zig").HRSRC;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "ENUMRESLANGPROCA")) { _ = ENUMRESLANGPROCA; }
    if (@hasDecl(@This(), "ENUMRESLANGPROCW")) { _ = ENUMRESLANGPROCW; }
    if (@hasDecl(@This(), "ENUMRESNAMEPROCA")) { _ = ENUMRESNAMEPROCA; }
    if (@hasDecl(@This(), "ENUMRESNAMEPROCW")) { _ = ENUMRESNAMEPROCW; }
    if (@hasDecl(@This(), "ENUMRESTYPEPROCA")) { _ = ENUMRESTYPEPROCA; }
    if (@hasDecl(@This(), "ENUMRESTYPEPROCW")) { _ = ENUMRESTYPEPROCW; }
    if (@hasDecl(@This(), "PGET_MODULE_HANDLE_EXA")) { _ = PGET_MODULE_HANDLE_EXA; }
    if (@hasDecl(@This(), "PGET_MODULE_HANDLE_EXW")) { _ = PGET_MODULE_HANDLE_EXW; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
