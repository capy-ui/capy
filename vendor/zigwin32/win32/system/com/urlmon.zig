//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (301)
//--------------------------------------------------------------------------------
pub const MKSYS_URLMONIKER = @as(u32, 6);
pub const URL_MK_LEGACY = @as(u32, 0);
pub const URL_MK_UNIFORM = @as(u32, 1);
pub const URL_MK_NO_CANONICALIZE = @as(u32, 2);
pub const FIEF_FLAG_FORCE_JITUI = @as(u32, 1);
pub const FIEF_FLAG_PEEK = @as(u32, 2);
pub const FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK = @as(u32, 4);
pub const FIEF_FLAG_RESERVED_0 = @as(u32, 8);
pub const FMFD_DEFAULT = @as(u32, 0);
pub const FMFD_URLASFILENAME = @as(u32, 1);
pub const FMFD_ENABLEMIMESNIFFING = @as(u32, 2);
pub const FMFD_IGNOREMIMETEXTPLAIN = @as(u32, 4);
pub const FMFD_SERVERMIME = @as(u32, 8);
pub const FMFD_RESPECTTEXTPLAIN = @as(u32, 16);
pub const FMFD_RETURNUPDATEDIMGMIMES = @as(u32, 32);
pub const FMFD_RESERVED_1 = @as(u32, 64);
pub const FMFD_RESERVED_2 = @as(u32, 128);
pub const UAS_EXACTLEGACY = @as(u32, 4096);
pub const URLMON_OPTION_USERAGENT = @as(u32, 268435457);
pub const URLMON_OPTION_USERAGENT_REFRESH = @as(u32, 268435458);
pub const URLMON_OPTION_URL_ENCODING = @as(u32, 268435460);
pub const URLMON_OPTION_USE_BINDSTRINGCREDS = @as(u32, 268435464);
pub const URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS = @as(u32, 268435472);
pub const CF_NULL = @as(u32, 0);
pub const MK_S_ASYNCHRONOUS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, 262632));
pub const S_ASYNCHRONOUS = @as(i32, 262632);
pub const E_PENDING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147483638));
pub const INET_E_INVALID_URL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697214));
pub const INET_E_NO_SESSION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697213));
pub const INET_E_CANNOT_CONNECT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697212));
pub const INET_E_RESOURCE_NOT_FOUND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697211));
pub const INET_E_OBJECT_NOT_FOUND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697210));
pub const INET_E_DATA_NOT_AVAILABLE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697209));
pub const INET_E_DOWNLOAD_FAILURE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697208));
pub const INET_E_AUTHENTICATION_REQUIRED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697207));
pub const INET_E_NO_VALID_MEDIA = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697206));
pub const INET_E_CONNECTION_TIMEOUT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697205));
pub const INET_E_INVALID_REQUEST = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697204));
pub const INET_E_UNKNOWN_PROTOCOL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697203));
pub const INET_E_SECURITY_PROBLEM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697202));
pub const INET_E_CANNOT_LOAD_DATA = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697201));
pub const INET_E_CANNOT_INSTANTIATE_OBJECT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697200));
pub const INET_E_INVALID_CERTIFICATE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697191));
pub const INET_E_REDIRECT_FAILED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697196));
pub const INET_E_REDIRECT_TO_DIR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697195));
pub const INET_E_CANNOT_LOCK_REQUEST = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697194));
pub const INET_E_USE_EXTEND_BINDING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697193));
pub const INET_E_TERMINATED_BIND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697192));
pub const INET_E_RESERVED_1 = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697190));
pub const INET_E_BLOCKED_REDIRECT_XSECURITYID = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697189));
pub const INET_E_DOMINJECTIONVALIDATION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697188));
pub const INET_E_VTAB_SWITCH_FORCE_ENGINE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697187));
pub const INET_E_HSTS_CERTIFICATE_ERROR = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697186));
pub const INET_E_RESERVED_2 = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697185));
pub const INET_E_RESERVED_3 = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697184));
pub const INET_E_RESERVED_4 = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697183));
pub const INET_E_RESERVED_5 = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697182));
pub const INET_E_ERROR_FIRST = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697214));
pub const INET_E_CODE_DOWNLOAD_DECLINED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146696960));
pub const INET_E_RESULT_DISPATCHED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146696704));
pub const INET_E_CANNOT_REPLACE_SFP_FILE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146696448));
pub const INET_E_CODE_INSTALL_SUPPRESSED = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146696192));
pub const INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695936));
pub const INET_E_DOWNLOAD_BLOCKED_BY_INPRIVATE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695935));
pub const INET_E_CODE_INSTALL_BLOCKED_IMMERSIVE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695934));
pub const INET_E_FORBIDFRAMING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695933));
pub const INET_E_CODE_INSTALL_BLOCKED_ARM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695932));
pub const INET_E_BLOCKED_PLUGGABLE_PROTOCOL = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695931));
pub const INET_E_BLOCKED_ENHANCEDPROTECTEDMODE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695930));
pub const INET_E_CODE_INSTALL_BLOCKED_BITNESS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695929));
pub const INET_E_DOWNLOAD_BLOCKED_BY_CSP = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146695928));
pub const INET_E_ERROR_LAST = @as(i32, -2146695928);
pub const Uri_DISPLAY_NO_FRAGMENT = @as(u32, 1);
pub const Uri_PUNYCODE_IDN_HOST = @as(u32, 2);
pub const Uri_DISPLAY_IDN_HOST = @as(u32, 4);
pub const Uri_DISPLAY_NO_PUNYCODE = @as(u32, 8);
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 = @as(u32, 1);
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_CP = @as(u32, 2);
pub const Uri_ENCODING_HOST_IS_IDN = @as(u32, 4);
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 = @as(u32, 8);
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP = @as(u32, 16);
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8 = @as(u32, 32);
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP = @as(u32, 64);
pub const UriBuilder_USE_ORIGINAL_FLAGS = @as(u32, 1);
pub const WININETINFO_OPTION_LOCK_HANDLE = @as(u32, 65534);
pub const URLOSTRM_USECACHEDCOPY_ONLY = @as(u32, 1);
pub const URLOSTRM_USECACHEDCOPY = @as(u32, 2);
pub const URLOSTRM_GETNEWESTVERSION = @as(u32, 3);
pub const SET_FEATURE_ON_THREAD = @as(u32, 1);
pub const SET_FEATURE_ON_PROCESS = @as(u32, 2);
pub const SET_FEATURE_IN_REGISTRY = @as(u32, 4);
pub const SET_FEATURE_ON_THREAD_LOCALMACHINE = @as(u32, 8);
pub const SET_FEATURE_ON_THREAD_INTRANET = @as(u32, 16);
pub const SET_FEATURE_ON_THREAD_TRUSTED = @as(u32, 32);
pub const SET_FEATURE_ON_THREAD_INTERNET = @as(u32, 64);
pub const SET_FEATURE_ON_THREAD_RESTRICTED = @as(u32, 128);
pub const GET_FEATURE_FROM_THREAD = @as(u32, 1);
pub const GET_FEATURE_FROM_PROCESS = @as(u32, 2);
pub const GET_FEATURE_FROM_REGISTRY = @as(u32, 4);
pub const GET_FEATURE_FROM_THREAD_LOCALMACHINE = @as(u32, 8);
pub const GET_FEATURE_FROM_THREAD_INTRANET = @as(u32, 16);
pub const GET_FEATURE_FROM_THREAD_TRUSTED = @as(u32, 32);
pub const GET_FEATURE_FROM_THREAD_INTERNET = @as(u32, 64);
pub const GET_FEATURE_FROM_THREAD_RESTRICTED = @as(u32, 128);
pub const INET_E_USE_DEFAULT_PROTOCOLHANDLER = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697199));
pub const INET_E_USE_DEFAULT_SETTING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697198));
pub const INET_E_DEFAULT_ACTION = @as(i32, -2146697199);
pub const INET_E_QUERYOPTION_UNKNOWN = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697197));
pub const INET_E_REDIRECTING = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2146697196));
pub const PROTOCOLFLAG_NO_PICS_CHECK = @as(u32, 1);
pub const MUTZ_NOSAVEDFILECHECK = @as(u32, 1);
pub const MUTZ_ISFILE = @as(u32, 2);
pub const MUTZ_ACCEPT_WILDCARD_SCHEME = @as(u32, 128);
pub const MUTZ_ENFORCERESTRICTED = @as(u32, 256);
pub const MUTZ_RESERVED = @as(u32, 512);
pub const MUTZ_REQUIRESAVEDFILECHECK = @as(u32, 1024);
pub const MUTZ_DONT_UNESCAPE = @as(u32, 2048);
pub const MUTZ_DONT_USE_CACHE = @as(u32, 4096);
pub const MUTZ_FORCE_INTRANET_FLAGS = @as(u32, 8192);
pub const MUTZ_IGNORE_ZONE_MAPPINGS = @as(u32, 16384);
pub const MAX_SIZE_SECURITY_ID = @as(u32, 512);
pub const URLACTION_MIN = @as(u32, 4096);
pub const URLACTION_DOWNLOAD_MIN = @as(u32, 4096);
pub const URLACTION_DOWNLOAD_SIGNED_ACTIVEX = @as(u32, 4097);
pub const URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX = @as(u32, 4100);
pub const URLACTION_DOWNLOAD_CURR_MAX = @as(u32, 4100);
pub const URLACTION_DOWNLOAD_MAX = @as(u32, 4607);
pub const URLACTION_ACTIVEX_MIN = @as(u32, 4608);
pub const URLACTION_ACTIVEX_RUN = @as(u32, 4608);
pub const URLPOLICY_ACTIVEX_CHECK_LIST = @as(u32, 65536);
pub const URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY = @as(u32, 4609);
pub const URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY = @as(u32, 4610);
pub const URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY = @as(u32, 4611);
pub const URLACTION_SCRIPT_OVERRIDE_SAFETY = @as(u32, 5121);
pub const URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY = @as(u32, 4612);
pub const URLACTION_ACTIVEX_TREATASUNTRUSTED = @as(u32, 4613);
pub const URLACTION_ACTIVEX_NO_WEBOC_SCRIPT = @as(u32, 4614);
pub const URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION = @as(u32, 4615);
pub const URLACTION_ACTIVEX_OVERRIDE_OPTIN = @as(u32, 4616);
pub const URLACTION_ACTIVEX_SCRIPTLET_RUN = @as(u32, 4617);
pub const URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION = @as(u32, 4618);
pub const URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST = @as(u32, 4619);
pub const URLACTION_ACTIVEX_ALLOW_TDC = @as(u32, 4620);
pub const URLACTION_ACTIVEX_CURR_MAX = @as(u32, 4620);
pub const URLACTION_ACTIVEX_MAX = @as(u32, 5119);
pub const URLACTION_SCRIPT_MIN = @as(u32, 5120);
pub const URLACTION_SCRIPT_RUN = @as(u32, 5120);
pub const URLACTION_SCRIPT_JAVA_USE = @as(u32, 5122);
pub const URLACTION_SCRIPT_SAFE_ACTIVEX = @as(u32, 5125);
pub const URLACTION_CROSS_DOMAIN_DATA = @as(u32, 5126);
pub const URLACTION_SCRIPT_PASTE = @as(u32, 5127);
pub const URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE = @as(u32, 5128);
pub const URLACTION_SCRIPT_XSSFILTER = @as(u32, 5129);
pub const URLACTION_SCRIPT_NAVIGATE = @as(u32, 5130);
pub const URLACTION_PLUGGABLE_PROTOCOL_XHR = @as(u32, 5131);
pub const URLACTION_ALLOW_VBSCRIPT_IE = @as(u32, 5132);
pub const URLACTION_ALLOW_JSCRIPT_IE = @as(u32, 5133);
pub const URLACTION_SCRIPT_CURR_MAX = @as(u32, 5133);
pub const URLACTION_SCRIPT_MAX = @as(u32, 5631);
pub const URLACTION_HTML_MIN = @as(u32, 5632);
pub const URLACTION_HTML_SUBMIT_FORMS = @as(u32, 5633);
pub const URLACTION_HTML_SUBMIT_FORMS_FROM = @as(u32, 5634);
pub const URLACTION_HTML_SUBMIT_FORMS_TO = @as(u32, 5635);
pub const URLACTION_HTML_FONT_DOWNLOAD = @as(u32, 5636);
pub const URLACTION_HTML_JAVA_RUN = @as(u32, 5637);
pub const URLACTION_HTML_USERDATA_SAVE = @as(u32, 5638);
pub const URLACTION_HTML_SUBFRAME_NAVIGATE = @as(u32, 5639);
pub const URLACTION_HTML_META_REFRESH = @as(u32, 5640);
pub const URLACTION_HTML_MIXED_CONTENT = @as(u32, 5641);
pub const URLACTION_HTML_INCLUDE_FILE_PATH = @as(u32, 5642);
pub const URLACTION_HTML_ALLOW_INJECTED_DYNAMIC_HTML = @as(u32, 5643);
pub const URLACTION_HTML_REQUIRE_UTF8_DOCUMENT_CODEPAGE = @as(u32, 5644);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_CANVAS = @as(u32, 5645);
pub const URLACTION_HTML_ALLOW_WINDOW_CLOSE = @as(u32, 5646);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_WEBWORKER = @as(u32, 5647);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_TEXTTRACK = @as(u32, 5648);
pub const URLACTION_HTML_ALLOW_INDEXEDDB = @as(u32, 5649);
pub const URLACTION_HTML_MAX = @as(u32, 6143);
pub const URLACTION_SHELL_MIN = @as(u32, 6144);
pub const URLACTION_SHELL_INSTALL_DTITEMS = @as(u32, 6144);
pub const URLACTION_SHELL_MOVE_OR_COPY = @as(u32, 6146);
pub const URLACTION_SHELL_FILE_DOWNLOAD = @as(u32, 6147);
pub const URLACTION_SHELL_VERB = @as(u32, 6148);
pub const URLACTION_SHELL_WEBVIEW_VERB = @as(u32, 6149);
pub const URLACTION_SHELL_SHELLEXECUTE = @as(u32, 6150);
pub const URLACTION_SHELL_EXECUTE_HIGHRISK = @as(u32, 6150);
pub const URLACTION_SHELL_EXECUTE_MODRISK = @as(u32, 6151);
pub const URLACTION_SHELL_EXECUTE_LOWRISK = @as(u32, 6152);
pub const URLACTION_SHELL_POPUPMGR = @as(u32, 6153);
pub const URLACTION_SHELL_RTF_OBJECTS_LOAD = @as(u32, 6154);
pub const URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY = @as(u32, 6155);
pub const URLACTION_SHELL_EXTENSIONSECURITY = @as(u32, 6156);
pub const URLACTION_SHELL_SECURE_DRAGSOURCE = @as(u32, 6157);
pub const URLACTION_SHELL_REMOTEQUERY = @as(u32, 6158);
pub const URLACTION_SHELL_PREVIEW = @as(u32, 6159);
pub const URLACTION_SHELL_SHARE = @as(u32, 6160);
pub const URLACTION_SHELL_ALLOW_CROSS_SITE_SHARE = @as(u32, 6161);
pub const URLACTION_SHELL_TOCTOU_RISK = @as(u32, 6162);
pub const URLACTION_SHELL_CURR_MAX = @as(u32, 6162);
pub const URLACTION_SHELL_MAX = @as(u32, 6655);
pub const URLACTION_NETWORK_MIN = @as(u32, 6656);
pub const URLACTION_CREDENTIALS_USE = @as(u32, 6656);
pub const URLPOLICY_CREDENTIALS_SILENT_LOGON_OK = @as(u32, 0);
pub const URLPOLICY_CREDENTIALS_MUST_PROMPT_USER = @as(u32, 65536);
pub const URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT = @as(u32, 131072);
pub const URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY = @as(u32, 196608);
pub const URLACTION_AUTHENTICATE_CLIENT = @as(u32, 6657);
pub const URLPOLICY_AUTHENTICATE_CLEARTEXT_OK = @as(u32, 0);
pub const URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE = @as(u32, 65536);
pub const URLPOLICY_AUTHENTICATE_MUTUAL_ONLY = @as(u32, 196608);
pub const URLACTION_COOKIES = @as(u32, 6658);
pub const URLACTION_COOKIES_SESSION = @as(u32, 6659);
pub const URLACTION_CLIENT_CERT_PROMPT = @as(u32, 6660);
pub const URLACTION_COOKIES_THIRD_PARTY = @as(u32, 6661);
pub const URLACTION_COOKIES_SESSION_THIRD_PARTY = @as(u32, 6662);
pub const URLACTION_COOKIES_ENABLED = @as(u32, 6672);
pub const URLACTION_NETWORK_CURR_MAX = @as(u32, 6672);
pub const URLACTION_NETWORK_MAX = @as(u32, 7167);
pub const URLACTION_JAVA_MIN = @as(u32, 7168);
pub const URLACTION_JAVA_PERMISSIONS = @as(u32, 7168);
pub const URLPOLICY_JAVA_PROHIBIT = @as(u32, 0);
pub const URLPOLICY_JAVA_HIGH = @as(u32, 65536);
pub const URLPOLICY_JAVA_MEDIUM = @as(u32, 131072);
pub const URLPOLICY_JAVA_LOW = @as(u32, 196608);
pub const URLPOLICY_JAVA_CUSTOM = @as(u32, 8388608);
pub const URLACTION_JAVA_CURR_MAX = @as(u32, 7168);
pub const URLACTION_JAVA_MAX = @as(u32, 7423);
pub const URLACTION_INFODELIVERY_MIN = @as(u32, 7424);
pub const URLACTION_INFODELIVERY_NO_ADDING_CHANNELS = @as(u32, 7424);
pub const URLACTION_INFODELIVERY_NO_EDITING_CHANNELS = @as(u32, 7425);
pub const URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS = @as(u32, 7426);
pub const URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS = @as(u32, 7427);
pub const URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS = @as(u32, 7428);
pub const URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS = @as(u32, 7429);
pub const URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING = @as(u32, 7430);
pub const URLACTION_INFODELIVERY_CURR_MAX = @as(u32, 7430);
pub const URLACTION_INFODELIVERY_MAX = @as(u32, 7679);
pub const URLACTION_CHANNEL_SOFTDIST_MIN = @as(u32, 7680);
pub const URLACTION_CHANNEL_SOFTDIST_PERMISSIONS = @as(u32, 7685);
pub const URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT = @as(u32, 65536);
pub const URLPOLICY_CHANNEL_SOFTDIST_PRECACHE = @as(u32, 131072);
pub const URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL = @as(u32, 196608);
pub const URLACTION_CHANNEL_SOFTDIST_MAX = @as(u32, 7935);
pub const URLACTION_DOTNET_USERCONTROLS = @as(u32, 8197);
pub const URLACTION_BEHAVIOR_MIN = @as(u32, 8192);
pub const URLACTION_BEHAVIOR_RUN = @as(u32, 8192);
pub const URLPOLICY_BEHAVIOR_CHECK_LIST = @as(u32, 65536);
pub const URLACTION_FEATURE_MIN = @as(u32, 8448);
pub const URLACTION_FEATURE_MIME_SNIFFING = @as(u32, 8448);
pub const URLACTION_FEATURE_ZONE_ELEVATION = @as(u32, 8449);
pub const URLACTION_FEATURE_WINDOW_RESTRICTIONS = @as(u32, 8450);
pub const URLACTION_FEATURE_SCRIPT_STATUS_BAR = @as(u32, 8451);
pub const URLACTION_FEATURE_FORCE_ADDR_AND_STATUS = @as(u32, 8452);
pub const URLACTION_FEATURE_BLOCK_INPUT_PROMPTS = @as(u32, 8453);
pub const URLACTION_FEATURE_DATA_BINDING = @as(u32, 8454);
pub const URLACTION_FEATURE_CROSSDOMAIN_FOCUS_CHANGE = @as(u32, 8455);
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN = @as(u32, 8704);
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI = @as(u32, 8704);
pub const URLACTION_AUTOMATIC_ACTIVEX_UI = @as(u32, 8705);
pub const URLACTION_ALLOW_RESTRICTEDPROTOCOLS = @as(u32, 8960);
pub const URLACTION_ALLOW_APEVALUATION = @as(u32, 8961);
pub const URLACTION_ALLOW_XHR_EVALUATION = @as(u32, 8962);
pub const URLACTION_WINDOWS_BROWSER_APPLICATIONS = @as(u32, 9216);
pub const URLACTION_XPS_DOCUMENTS = @as(u32, 9217);
pub const URLACTION_LOOSE_XAML = @as(u32, 9218);
pub const URLACTION_LOWRIGHTS = @as(u32, 9472);
pub const URLACTION_WINFX_SETUP = @as(u32, 9728);
pub const URLACTION_INPRIVATE_BLOCKING = @as(u32, 9984);
pub const URLACTION_ALLOW_AUDIO_VIDEO = @as(u32, 9985);
pub const URLACTION_ALLOW_ACTIVEX_FILTERING = @as(u32, 9986);
pub const URLACTION_ALLOW_STRUCTURED_STORAGE_SNIFFING = @as(u32, 9987);
pub const URLACTION_ALLOW_AUDIO_VIDEO_PLUGINS = @as(u32, 9988);
pub const URLACTION_ALLOW_ZONE_ELEVATION_VIA_OPT_OUT = @as(u32, 9989);
pub const URLACTION_ALLOW_ZONE_ELEVATION_OPT_OUT_ADDITION = @as(u32, 9990);
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_WITHIN_WINDOW = @as(u32, 9992);
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_ACROSS_WINDOWS = @as(u32, 9993);
pub const URLACTION_ALLOW_CROSSDOMAIN_APPCACHE_MANIFEST = @as(u32, 9994);
pub const URLACTION_ALLOW_RENDER_LEGACY_DXTFILTERS = @as(u32, 9995);
pub const URLACTION_ALLOW_ANTIMALWARE_SCANNING_OF_ACTIVEX = @as(u32, 9996);
pub const URLACTION_ALLOW_CSS_EXPRESSIONS = @as(u32, 9997);
pub const URLPOLICY_ALLOW = @as(u32, 0);
pub const URLPOLICY_QUERY = @as(u32, 1);
pub const URLPOLICY_DISALLOW = @as(u32, 3);
pub const URLPOLICY_NOTIFY_ON_ALLOW = @as(u32, 16);
pub const URLPOLICY_NOTIFY_ON_DISALLOW = @as(u32, 32);
pub const URLPOLICY_LOG_ON_ALLOW = @as(u32, 64);
pub const URLPOLICY_LOG_ON_DISALLOW = @as(u32, 128);
pub const URLPOLICY_MASK_PERMISSIONS = @as(u32, 15);
pub const URLPOLICY_DONTCHECKDLGBOX = @as(u32, 256);
pub const URLZONE_ESC_FLAG = @as(u32, 256);
pub const SECURITY_IE_STATE_GREEN = @as(u32, 0);
pub const SECURITY_IE_STATE_RED = @as(u32, 1);
pub const SOFTDIST_FLAG_USAGE_EMAIL = @as(u32, 1);
pub const SOFTDIST_FLAG_USAGE_PRECACHE = @as(u32, 2);
pub const SOFTDIST_FLAG_USAGE_AUTOINSTALL = @as(u32, 4);
pub const SOFTDIST_FLAG_DELETE_SUBSCRIPTION = @as(u32, 8);
pub const SOFTDIST_ADSTATE_NONE = @as(u32, 0);
pub const SOFTDIST_ADSTATE_AVAILABLE = @as(u32, 1);
pub const SOFTDIST_ADSTATE_DOWNLOADED = @as(u32, 2);
pub const SOFTDIST_ADSTATE_INSTALLED = @as(u32, 3);
pub const CONFIRMSAFETYACTION_LOADOBJECT = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (88)
//--------------------------------------------------------------------------------
pub const IEObjectType = enum(i32) {
    EVENT = 0,
    MUTEX = 1,
    SEMAPHORE = 2,
    SHARED_MEMORY = 3,
    WAITABLE_TIMER = 4,
    FILE = 5,
    NAMED_PIPE = 6,
    REGISTRY = 7,
};
pub const IE_EPM_OBJECT_EVENT = IEObjectType.EVENT;
pub const IE_EPM_OBJECT_MUTEX = IEObjectType.MUTEX;
pub const IE_EPM_OBJECT_SEMAPHORE = IEObjectType.SEMAPHORE;
pub const IE_EPM_OBJECT_SHARED_MEMORY = IEObjectType.SHARED_MEMORY;
pub const IE_EPM_OBJECT_WAITABLE_TIMER = IEObjectType.WAITABLE_TIMER;
pub const IE_EPM_OBJECT_FILE = IEObjectType.FILE;
pub const IE_EPM_OBJECT_NAMED_PIPE = IEObjectType.NAMED_PIPE;
pub const IE_EPM_OBJECT_REGISTRY = IEObjectType.REGISTRY;

const IID_IPersistMoniker_Value = Guid.initString("79eac9c9-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IPersistMoniker = &IID_IPersistMoniker_Value;
pub const IPersistMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMoniker,
                pClassID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMoniker,
                pClassID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMoniker,
                fFullyAvailable: BOOL,
                pimkName: ?*IMoniker,
                pibc: ?*IBindCtx,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMoniker,
                fFullyAvailable: BOOL,
                pimkName: ?*IMoniker,
                pibc: ?*IBindCtx,
                grfMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMoniker,
                pimkName: ?*IMoniker,
                pbc: ?*IBindCtx,
                fRemember: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMoniker,
                pimkName: ?*IMoniker,
                pbc: ?*IBindCtx,
                fRemember: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMoniker,
                pimkName: ?*IMoniker,
                pibc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMoniker,
                pimkName: ?*IMoniker,
                pibc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMoniker,
                ppimkName: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMoniker,
                ppimkName: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_GetClassID(self: *const T, pClassID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).GetClassID(@ptrCast(*const IPersistMoniker, self), pClassID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).IsDirty(@ptrCast(*const IPersistMoniker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_Load(self: *const T, fFullyAvailable: BOOL, pimkName: ?*IMoniker, pibc: ?*IBindCtx, grfMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).Load(@ptrCast(*const IPersistMoniker, self), fFullyAvailable, pimkName, pibc, grfMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_Save(self: *const T, pimkName: ?*IMoniker, pbc: ?*IBindCtx, fRemember: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).Save(@ptrCast(*const IPersistMoniker, self), pimkName, pbc, fRemember);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_SaveCompleted(self: *const T, pimkName: ?*IMoniker, pibc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).SaveCompleted(@ptrCast(*const IPersistMoniker, self), pimkName, pibc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMoniker_GetCurMoniker(self: *const T, ppimkName: ?*?*IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPersistMoniker.VTable, self.vtable).GetCurMoniker(@ptrCast(*const IPersistMoniker, self), ppimkName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MONIKERPROPERTY = enum(i32) {
    MIMETYPEPROP = 0,
    USE_SRC_URL = 1,
    CLASSIDPROP = 2,
    TRUSTEDDOWNLOADPROP = 3,
    POPUPLEVELPROP = 4,
};
pub const MIMETYPEPROP = MONIKERPROPERTY.MIMETYPEPROP;
pub const USE_SRC_URL = MONIKERPROPERTY.USE_SRC_URL;
pub const CLASSIDPROP = MONIKERPROPERTY.CLASSIDPROP;
pub const TRUSTEDDOWNLOADPROP = MONIKERPROPERTY.TRUSTEDDOWNLOADPROP;
pub const POPUPLEVELPROP = MONIKERPROPERTY.POPUPLEVELPROP;

const IID_IMonikerProp_Value = Guid.initString("a5ca5f7f-1847-4d87-9c5b-918509f7511d");
pub const IID_IMonikerProp = &IID_IMonikerProp_Value;
pub const IMonikerProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMonikerProp,
                mkp: MONIKERPROPERTY,
                val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMonikerProp,
                mkp: MONIKERPROPERTY,
                val: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMonikerProp_PutProperty(self: *const T, mkp: MONIKERPROPERTY, val: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMonikerProp.VTable, self.vtable).PutProperty(@ptrCast(*const IMonikerProp, self), mkp, val);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindProtocol_Value = Guid.initString("79eac9cd-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBindProtocol = &IID_IBindProtocol_Value;
pub const IBindProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateBinding: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBindProtocol,
                szUrl: ?[*:0]const u16,
                pbc: ?*IBindCtx,
                ppb: ?*?*IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBindProtocol,
                szUrl: ?[*:0]const u16,
                pbc: ?*IBindCtx,
                ppb: ?*?*IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindProtocol_CreateBinding(self: *const T, szUrl: ?[*:0]const u16, pbc: ?*IBindCtx, ppb: ?*?*IBinding) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindProtocol.VTable, self.vtable).CreateBinding(@ptrCast(*const IBindProtocol, self), szUrl, pbc, ppb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDVERB = enum(i32) {
    GET = 0,
    POST = 1,
    PUT = 2,
    CUSTOM = 3,
    RESERVED1 = 4,
};
pub const BINDVERB_GET = BINDVERB.GET;
pub const BINDVERB_POST = BINDVERB.POST;
pub const BINDVERB_PUT = BINDVERB.PUT;
pub const BINDVERB_CUSTOM = BINDVERB.CUSTOM;
pub const BINDVERB_RESERVED1 = BINDVERB.RESERVED1;

pub const BINDF = enum(i32) {
    ASYNCHRONOUS = 1,
    ASYNCSTORAGE = 2,
    NOPROGRESSIVERENDERING = 4,
    OFFLINEOPERATION = 8,
    GETNEWESTVERSION = 16,
    NOWRITECACHE = 32,
    NEEDFILE = 64,
    PULLDATA = 128,
    IGNORESECURITYPROBLEM = 256,
    RESYNCHRONIZE = 512,
    HYPERLINK = 1024,
    NO_UI = 2048,
    SILENTOPERATION = 4096,
    PRAGMA_NO_CACHE = 8192,
    GETCLASSOBJECT = 16384,
    RESERVED_1 = 32768,
    FREE_THREADED = 65536,
    DIRECT_READ = 131072,
    FORMS_SUBMIT = 262144,
    GETFROMCACHE_IF_NET_FAIL = 524288,
    FROMURLMON = 1048576,
    FWD_BACK = 2097152,
    PREFERDEFAULTHANDLER = 4194304,
    ENFORCERESTRICTED = 8388608,
    RESERVED_2 = -2147483648,
    RESERVED_3 = 16777216,
    RESERVED_4 = 33554432,
    RESERVED_5 = 67108864,
    RESERVED_6 = 134217728,
    RESERVED_7 = 1073741824,
    RESERVED_8 = 536870912,
};
pub const BINDF_ASYNCHRONOUS = BINDF.ASYNCHRONOUS;
pub const BINDF_ASYNCSTORAGE = BINDF.ASYNCSTORAGE;
pub const BINDF_NOPROGRESSIVERENDERING = BINDF.NOPROGRESSIVERENDERING;
pub const BINDF_OFFLINEOPERATION = BINDF.OFFLINEOPERATION;
pub const BINDF_GETNEWESTVERSION = BINDF.GETNEWESTVERSION;
pub const BINDF_NOWRITECACHE = BINDF.NOWRITECACHE;
pub const BINDF_NEEDFILE = BINDF.NEEDFILE;
pub const BINDF_PULLDATA = BINDF.PULLDATA;
pub const BINDF_IGNORESECURITYPROBLEM = BINDF.IGNORESECURITYPROBLEM;
pub const BINDF_RESYNCHRONIZE = BINDF.RESYNCHRONIZE;
pub const BINDF_HYPERLINK = BINDF.HYPERLINK;
pub const BINDF_NO_UI = BINDF.NO_UI;
pub const BINDF_SILENTOPERATION = BINDF.SILENTOPERATION;
pub const BINDF_PRAGMA_NO_CACHE = BINDF.PRAGMA_NO_CACHE;
pub const BINDF_GETCLASSOBJECT = BINDF.GETCLASSOBJECT;
pub const BINDF_RESERVED_1 = BINDF.RESERVED_1;
pub const BINDF_FREE_THREADED = BINDF.FREE_THREADED;
pub const BINDF_DIRECT_READ = BINDF.DIRECT_READ;
pub const BINDF_FORMS_SUBMIT = BINDF.FORMS_SUBMIT;
pub const BINDF_GETFROMCACHE_IF_NET_FAIL = BINDF.GETFROMCACHE_IF_NET_FAIL;
pub const BINDF_FROMURLMON = BINDF.FROMURLMON;
pub const BINDF_FWD_BACK = BINDF.FWD_BACK;
pub const BINDF_PREFERDEFAULTHANDLER = BINDF.PREFERDEFAULTHANDLER;
pub const BINDF_ENFORCERESTRICTED = BINDF.ENFORCERESTRICTED;
pub const BINDF_RESERVED_2 = BINDF.RESERVED_2;
pub const BINDF_RESERVED_3 = BINDF.RESERVED_3;
pub const BINDF_RESERVED_4 = BINDF.RESERVED_4;
pub const BINDF_RESERVED_5 = BINDF.RESERVED_5;
pub const BINDF_RESERVED_6 = BINDF.RESERVED_6;
pub const BINDF_RESERVED_7 = BINDF.RESERVED_7;
pub const BINDF_RESERVED_8 = BINDF.RESERVED_8;

pub const URL_ENCODING = enum(i32) {
    NONE = 0,
    ENABLE_UTF8 = 268435456,
    DISABLE_UTF8 = 536870912,
};
pub const URL_ENCODING_NONE = URL_ENCODING.NONE;
pub const URL_ENCODING_ENABLE_UTF8 = URL_ENCODING.ENABLE_UTF8;
pub const URL_ENCODING_DISABLE_UTF8 = URL_ENCODING.DISABLE_UTF8;

pub const REMSECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: u32,
    bInheritHandle: BOOL,
};

pub const RemBINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?PWSTR,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?PWSTR,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: REMSECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: ?*IUnknown,
    dwReserved: u32,
};

pub const RemFORMATETC = extern struct {
    cfFormat: u32,
    ptd: u32,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};

pub const BINDINFO_OPTIONS = enum(i32) {
    OPTIONS_WININETFLAG = 65536,
    OPTIONS_ENABLE_UTF8 = 131072,
    OPTIONS_DISABLE_UTF8 = 262144,
    OPTIONS_USE_IE_ENCODING = 524288,
    OPTIONS_BINDTOOBJECT = 1048576,
    OPTIONS_SECURITYOPTOUT = 2097152,
    OPTIONS_IGNOREMIMETEXTPLAIN = 4194304,
    OPTIONS_USEBINDSTRINGCREDS = 8388608,
    OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 16777216,
    OPTIONS_IGNORE_SSLERRORS_ONCE = 33554432,
    WPC_DOWNLOADBLOCKED = 134217728,
    WPC_LOGGING_ENABLED = 268435456,
    OPTIONS_ALLOWCONNECTDATA = 536870912,
    OPTIONS_DISABLEAUTOREDIRECTS = 1073741824,
    OPTIONS_SHDOCVW_NAVIGATE = -2147483648,
};
pub const BINDINFO_OPTIONS_WININETFLAG = BINDINFO_OPTIONS.OPTIONS_WININETFLAG;
pub const BINDINFO_OPTIONS_ENABLE_UTF8 = BINDINFO_OPTIONS.OPTIONS_ENABLE_UTF8;
pub const BINDINFO_OPTIONS_DISABLE_UTF8 = BINDINFO_OPTIONS.OPTIONS_DISABLE_UTF8;
pub const BINDINFO_OPTIONS_USE_IE_ENCODING = BINDINFO_OPTIONS.OPTIONS_USE_IE_ENCODING;
pub const BINDINFO_OPTIONS_BINDTOOBJECT = BINDINFO_OPTIONS.OPTIONS_BINDTOOBJECT;
pub const BINDINFO_OPTIONS_SECURITYOPTOUT = BINDINFO_OPTIONS.OPTIONS_SECURITYOPTOUT;
pub const BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = BINDINFO_OPTIONS.OPTIONS_IGNOREMIMETEXTPLAIN;
pub const BINDINFO_OPTIONS_USEBINDSTRINGCREDS = BINDINFO_OPTIONS.OPTIONS_USEBINDSTRINGCREDS;
pub const BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = BINDINFO_OPTIONS.OPTIONS_IGNOREHTTPHTTPSREDIRECTS;
pub const BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = BINDINFO_OPTIONS.OPTIONS_IGNORE_SSLERRORS_ONCE;
pub const BINDINFO_WPC_DOWNLOADBLOCKED = BINDINFO_OPTIONS.WPC_DOWNLOADBLOCKED;
pub const BINDINFO_WPC_LOGGING_ENABLED = BINDINFO_OPTIONS.WPC_LOGGING_ENABLED;
pub const BINDINFO_OPTIONS_ALLOWCONNECTDATA = BINDINFO_OPTIONS.OPTIONS_ALLOWCONNECTDATA;
pub const BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = BINDINFO_OPTIONS.OPTIONS_DISABLEAUTOREDIRECTS;
pub const BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = BINDINFO_OPTIONS.OPTIONS_SHDOCVW_NAVIGATE;

pub const BSCF = enum(i32) {
    FIRSTDATANOTIFICATION = 1,
    INTERMEDIATEDATANOTIFICATION = 2,
    LASTDATANOTIFICATION = 4,
    DATAFULLYAVAILABLE = 8,
    AVAILABLEDATASIZEUNKNOWN = 16,
    SKIPDRAINDATAFORFILEURLS = 32,
    @"64BITLENGTHDOWNLOAD" = 64,
};
pub const BSCF_FIRSTDATANOTIFICATION = BSCF.FIRSTDATANOTIFICATION;
pub const BSCF_INTERMEDIATEDATANOTIFICATION = BSCF.INTERMEDIATEDATANOTIFICATION;
pub const BSCF_LASTDATANOTIFICATION = BSCF.LASTDATANOTIFICATION;
pub const BSCF_DATAFULLYAVAILABLE = BSCF.DATAFULLYAVAILABLE;
pub const BSCF_AVAILABLEDATASIZEUNKNOWN = BSCF.AVAILABLEDATASIZEUNKNOWN;
pub const BSCF_SKIPDRAINDATAFORFILEURLS = BSCF.SKIPDRAINDATAFORFILEURLS;
pub const BSCF_64BITLENGTHDOWNLOAD = BSCF.@"64BITLENGTHDOWNLOAD";

pub const BINDSTATUS = enum(i32) {
    FINDINGRESOURCE = 1,
    CONNECTING = 2,
    REDIRECTING = 3,
    BEGINDOWNLOADDATA = 4,
    DOWNLOADINGDATA = 5,
    ENDDOWNLOADDATA = 6,
    BEGINDOWNLOADCOMPONENTS = 7,
    INSTALLINGCOMPONENTS = 8,
    ENDDOWNLOADCOMPONENTS = 9,
    USINGCACHEDCOPY = 10,
    SENDINGREQUEST = 11,
    CLASSIDAVAILABLE = 12,
    MIMETYPEAVAILABLE = 13,
    CACHEFILENAMEAVAILABLE = 14,
    BEGINSYNCOPERATION = 15,
    ENDSYNCOPERATION = 16,
    BEGINUPLOADDATA = 17,
    UPLOADINGDATA = 18,
    ENDUPLOADDATA = 19,
    PROTOCOLCLASSID = 20,
    ENCODING = 21,
    VERIFIEDMIMETYPEAVAILABLE = 22,
    CLASSINSTALLLOCATION = 23,
    DECODING = 24,
    LOADINGMIMEHANDLER = 25,
    CONTENTDISPOSITIONATTACH = 26,
    FILTERREPORTMIMETYPE = 27,
    CLSIDCANINSTANTIATE = 28,
    IUNKNOWNAVAILABLE = 29,
    DIRECTBIND = 30,
    RAWMIMETYPE = 31,
    PROXYDETECTING = 32,
    ACCEPTRANGES = 33,
    COOKIE_SENT = 34,
    COMPACT_POLICY_RECEIVED = 35,
    COOKIE_SUPPRESSED = 36,
    COOKIE_STATE_UNKNOWN = 37,
    COOKIE_STATE_ACCEPT = 38,
    COOKIE_STATE_REJECT = 39,
    COOKIE_STATE_PROMPT = 40,
    COOKIE_STATE_LEASH = 41,
    COOKIE_STATE_DOWNGRADE = 42,
    POLICY_HREF = 43,
    P3P_HEADER = 44,
    SESSION_COOKIE_RECEIVED = 45,
    PERSISTENT_COOKIE_RECEIVED = 46,
    SESSION_COOKIES_ALLOWED = 47,
    CACHECONTROL = 48,
    CONTENTDISPOSITIONFILENAME = 49,
    MIMETEXTPLAINMISMATCH = 50,
    PUBLISHERAVAILABLE = 51,
    DISPLAYNAMEAVAILABLE = 52,
    SSLUX_NAVBLOCKED = 53,
    SERVER_MIMETYPEAVAILABLE = 54,
    SNIFFED_CLASSIDAVAILABLE = 55,
    @"64BIT_PROGRESS" = 56,
    // LAST = 56, this enum value conflicts with @"64BIT_PROGRESS"
    RESERVED_0 = 57,
    RESERVED_1 = 58,
    RESERVED_2 = 59,
    RESERVED_3 = 60,
    RESERVED_4 = 61,
    RESERVED_5 = 62,
    RESERVED_6 = 63,
    RESERVED_7 = 64,
    RESERVED_8 = 65,
    RESERVED_9 = 66,
    RESERVED_A = 67,
    RESERVED_B = 68,
    RESERVED_C = 69,
    RESERVED_D = 70,
    RESERVED_E = 71,
    RESERVED_F = 72,
    RESERVED_10 = 73,
    RESERVED_11 = 74,
    RESERVED_12 = 75,
    RESERVED_13 = 76,
    RESERVED_14 = 77,
    // LAST_PRIVATE = 77, this enum value conflicts with RESERVED_14
};
pub const BINDSTATUS_FINDINGRESOURCE = BINDSTATUS.FINDINGRESOURCE;
pub const BINDSTATUS_CONNECTING = BINDSTATUS.CONNECTING;
pub const BINDSTATUS_REDIRECTING = BINDSTATUS.REDIRECTING;
pub const BINDSTATUS_BEGINDOWNLOADDATA = BINDSTATUS.BEGINDOWNLOADDATA;
pub const BINDSTATUS_DOWNLOADINGDATA = BINDSTATUS.DOWNLOADINGDATA;
pub const BINDSTATUS_ENDDOWNLOADDATA = BINDSTATUS.ENDDOWNLOADDATA;
pub const BINDSTATUS_BEGINDOWNLOADCOMPONENTS = BINDSTATUS.BEGINDOWNLOADCOMPONENTS;
pub const BINDSTATUS_INSTALLINGCOMPONENTS = BINDSTATUS.INSTALLINGCOMPONENTS;
pub const BINDSTATUS_ENDDOWNLOADCOMPONENTS = BINDSTATUS.ENDDOWNLOADCOMPONENTS;
pub const BINDSTATUS_USINGCACHEDCOPY = BINDSTATUS.USINGCACHEDCOPY;
pub const BINDSTATUS_SENDINGREQUEST = BINDSTATUS.SENDINGREQUEST;
pub const BINDSTATUS_CLASSIDAVAILABLE = BINDSTATUS.CLASSIDAVAILABLE;
pub const BINDSTATUS_MIMETYPEAVAILABLE = BINDSTATUS.MIMETYPEAVAILABLE;
pub const BINDSTATUS_CACHEFILENAMEAVAILABLE = BINDSTATUS.CACHEFILENAMEAVAILABLE;
pub const BINDSTATUS_BEGINSYNCOPERATION = BINDSTATUS.BEGINSYNCOPERATION;
pub const BINDSTATUS_ENDSYNCOPERATION = BINDSTATUS.ENDSYNCOPERATION;
pub const BINDSTATUS_BEGINUPLOADDATA = BINDSTATUS.BEGINUPLOADDATA;
pub const BINDSTATUS_UPLOADINGDATA = BINDSTATUS.UPLOADINGDATA;
pub const BINDSTATUS_ENDUPLOADDATA = BINDSTATUS.ENDUPLOADDATA;
pub const BINDSTATUS_PROTOCOLCLASSID = BINDSTATUS.PROTOCOLCLASSID;
pub const BINDSTATUS_ENCODING = BINDSTATUS.ENCODING;
pub const BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = BINDSTATUS.VERIFIEDMIMETYPEAVAILABLE;
pub const BINDSTATUS_CLASSINSTALLLOCATION = BINDSTATUS.CLASSINSTALLLOCATION;
pub const BINDSTATUS_DECODING = BINDSTATUS.DECODING;
pub const BINDSTATUS_LOADINGMIMEHANDLER = BINDSTATUS.LOADINGMIMEHANDLER;
pub const BINDSTATUS_CONTENTDISPOSITIONATTACH = BINDSTATUS.CONTENTDISPOSITIONATTACH;
pub const BINDSTATUS_FILTERREPORTMIMETYPE = BINDSTATUS.FILTERREPORTMIMETYPE;
pub const BINDSTATUS_CLSIDCANINSTANTIATE = BINDSTATUS.CLSIDCANINSTANTIATE;
pub const BINDSTATUS_IUNKNOWNAVAILABLE = BINDSTATUS.IUNKNOWNAVAILABLE;
pub const BINDSTATUS_DIRECTBIND = BINDSTATUS.DIRECTBIND;
pub const BINDSTATUS_RAWMIMETYPE = BINDSTATUS.RAWMIMETYPE;
pub const BINDSTATUS_PROXYDETECTING = BINDSTATUS.PROXYDETECTING;
pub const BINDSTATUS_ACCEPTRANGES = BINDSTATUS.ACCEPTRANGES;
pub const BINDSTATUS_COOKIE_SENT = BINDSTATUS.COOKIE_SENT;
pub const BINDSTATUS_COMPACT_POLICY_RECEIVED = BINDSTATUS.COMPACT_POLICY_RECEIVED;
pub const BINDSTATUS_COOKIE_SUPPRESSED = BINDSTATUS.COOKIE_SUPPRESSED;
pub const BINDSTATUS_COOKIE_STATE_UNKNOWN = BINDSTATUS.COOKIE_STATE_UNKNOWN;
pub const BINDSTATUS_COOKIE_STATE_ACCEPT = BINDSTATUS.COOKIE_STATE_ACCEPT;
pub const BINDSTATUS_COOKIE_STATE_REJECT = BINDSTATUS.COOKIE_STATE_REJECT;
pub const BINDSTATUS_COOKIE_STATE_PROMPT = BINDSTATUS.COOKIE_STATE_PROMPT;
pub const BINDSTATUS_COOKIE_STATE_LEASH = BINDSTATUS.COOKIE_STATE_LEASH;
pub const BINDSTATUS_COOKIE_STATE_DOWNGRADE = BINDSTATUS.COOKIE_STATE_DOWNGRADE;
pub const BINDSTATUS_POLICY_HREF = BINDSTATUS.POLICY_HREF;
pub const BINDSTATUS_P3P_HEADER = BINDSTATUS.P3P_HEADER;
pub const BINDSTATUS_SESSION_COOKIE_RECEIVED = BINDSTATUS.SESSION_COOKIE_RECEIVED;
pub const BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = BINDSTATUS.PERSISTENT_COOKIE_RECEIVED;
pub const BINDSTATUS_SESSION_COOKIES_ALLOWED = BINDSTATUS.SESSION_COOKIES_ALLOWED;
pub const BINDSTATUS_CACHECONTROL = BINDSTATUS.CACHECONTROL;
pub const BINDSTATUS_CONTENTDISPOSITIONFILENAME = BINDSTATUS.CONTENTDISPOSITIONFILENAME;
pub const BINDSTATUS_MIMETEXTPLAINMISMATCH = BINDSTATUS.MIMETEXTPLAINMISMATCH;
pub const BINDSTATUS_PUBLISHERAVAILABLE = BINDSTATUS.PUBLISHERAVAILABLE;
pub const BINDSTATUS_DISPLAYNAMEAVAILABLE = BINDSTATUS.DISPLAYNAMEAVAILABLE;
pub const BINDSTATUS_SSLUX_NAVBLOCKED = BINDSTATUS.SSLUX_NAVBLOCKED;
pub const BINDSTATUS_SERVER_MIMETYPEAVAILABLE = BINDSTATUS.SERVER_MIMETYPEAVAILABLE;
pub const BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = BINDSTATUS.SNIFFED_CLASSIDAVAILABLE;
pub const BINDSTATUS_64BIT_PROGRESS = BINDSTATUS.@"64BIT_PROGRESS";
pub const BINDSTATUS_LAST = BINDSTATUS.@"64BIT_PROGRESS";
pub const BINDSTATUS_RESERVED_0 = BINDSTATUS.RESERVED_0;
pub const BINDSTATUS_RESERVED_1 = BINDSTATUS.RESERVED_1;
pub const BINDSTATUS_RESERVED_2 = BINDSTATUS.RESERVED_2;
pub const BINDSTATUS_RESERVED_3 = BINDSTATUS.RESERVED_3;
pub const BINDSTATUS_RESERVED_4 = BINDSTATUS.RESERVED_4;
pub const BINDSTATUS_RESERVED_5 = BINDSTATUS.RESERVED_5;
pub const BINDSTATUS_RESERVED_6 = BINDSTATUS.RESERVED_6;
pub const BINDSTATUS_RESERVED_7 = BINDSTATUS.RESERVED_7;
pub const BINDSTATUS_RESERVED_8 = BINDSTATUS.RESERVED_8;
pub const BINDSTATUS_RESERVED_9 = BINDSTATUS.RESERVED_9;
pub const BINDSTATUS_RESERVED_A = BINDSTATUS.RESERVED_A;
pub const BINDSTATUS_RESERVED_B = BINDSTATUS.RESERVED_B;
pub const BINDSTATUS_RESERVED_C = BINDSTATUS.RESERVED_C;
pub const BINDSTATUS_RESERVED_D = BINDSTATUS.RESERVED_D;
pub const BINDSTATUS_RESERVED_E = BINDSTATUS.RESERVED_E;
pub const BINDSTATUS_RESERVED_F = BINDSTATUS.RESERVED_F;
pub const BINDSTATUS_RESERVED_10 = BINDSTATUS.RESERVED_10;
pub const BINDSTATUS_RESERVED_11 = BINDSTATUS.RESERVED_11;
pub const BINDSTATUS_RESERVED_12 = BINDSTATUS.RESERVED_12;
pub const BINDSTATUS_RESERVED_13 = BINDSTATUS.RESERVED_13;
pub const BINDSTATUS_RESERVED_14 = BINDSTATUS.RESERVED_14;
pub const BINDSTATUS_LAST_PRIVATE = BINDSTATUS.RESERVED_14;

pub const BINDF2 = enum(i32) {
    DISABLEBASICOVERHTTP = 1,
    DISABLEAUTOCOOKIEHANDLING = 2,
    READ_DATA_GREATER_THAN_4GB = 4,
    DISABLE_HTTP_REDIRECT_XSECURITYID = 8,
    SETDOWNLOADMODE = 32,
    DISABLE_HTTP_REDIRECT_CACHING = 64,
    KEEP_CALLBACK_MODULE_LOADED = 128,
    ALLOW_PROXY_CRED_PROMPT = 256,
    RESERVED_17 = 512,
    RESERVED_16 = 1024,
    RESERVED_15 = 2048,
    RESERVED_14 = 4096,
    RESERVED_13 = 8192,
    RESERVED_12 = 16384,
    RESERVED_11 = 32768,
    RESERVED_10 = 65536,
    RESERVED_F = 131072,
    RESERVED_E = 262144,
    RESERVED_D = 524288,
    RESERVED_C = 1048576,
    RESERVED_B = 2097152,
    RESERVED_A = 4194304,
    RESERVED_9 = 8388608,
    RESERVED_8 = 16777216,
    RESERVED_7 = 33554432,
    RESERVED_6 = 67108864,
    RESERVED_5 = 134217728,
    RESERVED_4 = 268435456,
    RESERVED_3 = 536870912,
    RESERVED_2 = 1073741824,
    RESERVED_1 = -2147483648,
};
pub const BINDF2_DISABLEBASICOVERHTTP = BINDF2.DISABLEBASICOVERHTTP;
pub const BINDF2_DISABLEAUTOCOOKIEHANDLING = BINDF2.DISABLEAUTOCOOKIEHANDLING;
pub const BINDF2_READ_DATA_GREATER_THAN_4GB = BINDF2.READ_DATA_GREATER_THAN_4GB;
pub const BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = BINDF2.DISABLE_HTTP_REDIRECT_XSECURITYID;
pub const BINDF2_SETDOWNLOADMODE = BINDF2.SETDOWNLOADMODE;
pub const BINDF2_DISABLE_HTTP_REDIRECT_CACHING = BINDF2.DISABLE_HTTP_REDIRECT_CACHING;
pub const BINDF2_KEEP_CALLBACK_MODULE_LOADED = BINDF2.KEEP_CALLBACK_MODULE_LOADED;
pub const BINDF2_ALLOW_PROXY_CRED_PROMPT = BINDF2.ALLOW_PROXY_CRED_PROMPT;
pub const BINDF2_RESERVED_17 = BINDF2.RESERVED_17;
pub const BINDF2_RESERVED_16 = BINDF2.RESERVED_16;
pub const BINDF2_RESERVED_15 = BINDF2.RESERVED_15;
pub const BINDF2_RESERVED_14 = BINDF2.RESERVED_14;
pub const BINDF2_RESERVED_13 = BINDF2.RESERVED_13;
pub const BINDF2_RESERVED_12 = BINDF2.RESERVED_12;
pub const BINDF2_RESERVED_11 = BINDF2.RESERVED_11;
pub const BINDF2_RESERVED_10 = BINDF2.RESERVED_10;
pub const BINDF2_RESERVED_F = BINDF2.RESERVED_F;
pub const BINDF2_RESERVED_E = BINDF2.RESERVED_E;
pub const BINDF2_RESERVED_D = BINDF2.RESERVED_D;
pub const BINDF2_RESERVED_C = BINDF2.RESERVED_C;
pub const BINDF2_RESERVED_B = BINDF2.RESERVED_B;
pub const BINDF2_RESERVED_A = BINDF2.RESERVED_A;
pub const BINDF2_RESERVED_9 = BINDF2.RESERVED_9;
pub const BINDF2_RESERVED_8 = BINDF2.RESERVED_8;
pub const BINDF2_RESERVED_7 = BINDF2.RESERVED_7;
pub const BINDF2_RESERVED_6 = BINDF2.RESERVED_6;
pub const BINDF2_RESERVED_5 = BINDF2.RESERVED_5;
pub const BINDF2_RESERVED_4 = BINDF2.RESERVED_4;
pub const BINDF2_RESERVED_3 = BINDF2.RESERVED_3;
pub const BINDF2_RESERVED_2 = BINDF2.RESERVED_2;
pub const BINDF2_RESERVED_1 = BINDF2.RESERVED_1;

pub const AUTHENTICATEF = enum(i32) {
    PROXY = 1,
    BASIC = 2,
    HTTP = 4,
};
pub const AUTHENTICATEF_PROXY = AUTHENTICATEF.PROXY;
pub const AUTHENTICATEF_BASIC = AUTHENTICATEF.BASIC;
pub const AUTHENTICATEF_HTTP = AUTHENTICATEF.HTTP;

const IID_IHttpNegotiate_Value = Guid.initString("79eac9d2-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IHttpNegotiate = &IID_IHttpNegotiate_Value;
pub const IHttpNegotiate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginningTransaction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHttpNegotiate,
                szURL: ?[*:0]const u16,
                szHeaders: ?[*:0]const u16,
                dwReserved: u32,
                pszAdditionalHeaders: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHttpNegotiate,
                szURL: ?[*:0]const u16,
                szHeaders: ?[*:0]const u16,
                dwReserved: u32,
                pszAdditionalHeaders: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHttpNegotiate,
                dwResponseCode: u32,
                szResponseHeaders: ?[*:0]const u16,
                szRequestHeaders: ?[*:0]const u16,
                pszAdditionalRequestHeaders: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHttpNegotiate,
                dwResponseCode: u32,
                szResponseHeaders: ?[*:0]const u16,
                szRequestHeaders: ?[*:0]const u16,
                pszAdditionalRequestHeaders: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate_BeginningTransaction(self: *const T, szURL: ?[*:0]const u16, szHeaders: ?[*:0]const u16, dwReserved: u32, pszAdditionalHeaders: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate.VTable, self.vtable).BeginningTransaction(@ptrCast(*const IHttpNegotiate, self), szURL, szHeaders, dwReserved, pszAdditionalHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate_OnResponse(self: *const T, dwResponseCode: u32, szResponseHeaders: ?[*:0]const u16, szRequestHeaders: ?[*:0]const u16, pszAdditionalRequestHeaders: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate.VTable, self.vtable).OnResponse(@ptrCast(*const IHttpNegotiate, self), dwResponseCode, szResponseHeaders, szRequestHeaders, pszAdditionalRequestHeaders);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpNegotiate2_Value = Guid.initString("4f9f9fcb-e0f4-48eb-b7ab-fa2ea9365cb4");
pub const IID_IHttpNegotiate2 = &IID_IHttpNegotiate2_Value;
pub const IHttpNegotiate2 = extern struct {
    pub const VTable = extern struct {
        base: IHttpNegotiate.VTable,
        GetRootSecurityId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHttpNegotiate2,
                pbSecurityId: [*:0]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHttpNegotiate2,
                pbSecurityId: [*:0]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHttpNegotiate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate2_GetRootSecurityId(self: *const T, pbSecurityId: [*:0]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate2.VTable, self.vtable).GetRootSecurityId(@ptrCast(*const IHttpNegotiate2, self), pbSecurityId, pcbSecurityId, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpNegotiate3_Value = Guid.initString("57b6c80a-34c2-4602-bc26-66a02fc57153");
pub const IID_IHttpNegotiate3 = &IID_IHttpNegotiate3_Value;
pub const IHttpNegotiate3 = extern struct {
    pub const VTable = extern struct {
        base: IHttpNegotiate2.VTable,
        GetSerializedClientCertContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHttpNegotiate3,
                ppbCert: [*]?*u8,
                pcbCert: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHttpNegotiate3,
                ppbCert: [*]?*u8,
                pcbCert: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHttpNegotiate2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpNegotiate3_GetSerializedClientCertContext(self: *const T, ppbCert: [*]?*u8, pcbCert: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpNegotiate3.VTable, self.vtable).GetSerializedClientCertContext(@ptrCast(*const IHttpNegotiate3, self), ppbCert, pcbCert);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetFileStream_Value = Guid.initString("f134c4b7-b1f8-4e75-b886-74b90943becb");
pub const IID_IWinInetFileStream = &IID_IWinInetFileStream_Value;
pub const IWinInetFileStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHandleForUnlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetFileStream,
                hWinInetLockHandle: usize,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetFileStream,
                hWinInetLockHandle: usize,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeleteFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetFileStream,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetFileStream,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetFileStream_SetHandleForUnlock(self: *const T, hWinInetLockHandle: usize, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetFileStream.VTable, self.vtable).SetHandleForUnlock(@ptrCast(*const IWinInetFileStream, self), hWinInetLockHandle, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetFileStream_SetDeleteFile(self: *const T, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetFileStream.VTable, self.vtable).SetDeleteFile(@ptrCast(*const IWinInetFileStream, self), dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWindowForBindingUI_Value = Guid.initString("79eac9d5-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IWindowForBindingUI = &IID_IWindowForBindingUI_Value;
pub const IWindowForBindingUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowForBindingUI,
                rguidReason: ?*const Guid,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowForBindingUI,
                rguidReason: ?*const Guid,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowForBindingUI_GetWindow(self: *const T, rguidReason: ?*const Guid, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowForBindingUI.VTable, self.vtable).GetWindow(@ptrCast(*const IWindowForBindingUI, self), rguidReason, phwnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CIP_STATUS = enum(i32) {
    DISK_FULL = 0,
    ACCESS_DENIED = 1,
    NEWER_VERSION_EXISTS = 2,
    OLDER_VERSION_EXISTS = 3,
    NAME_CONFLICT = 4,
    TRUST_VERIFICATION_COMPONENT_MISSING = 5,
    EXE_SELF_REGISTERATION_TIMEOUT = 6,
    UNSAFE_TO_ABORT = 7,
    NEED_REBOOT = 8,
    NEED_REBOOT_UI_PERMISSION = 9,
};
pub const CIP_DISK_FULL = CIP_STATUS.DISK_FULL;
pub const CIP_ACCESS_DENIED = CIP_STATUS.ACCESS_DENIED;
pub const CIP_NEWER_VERSION_EXISTS = CIP_STATUS.NEWER_VERSION_EXISTS;
pub const CIP_OLDER_VERSION_EXISTS = CIP_STATUS.OLDER_VERSION_EXISTS;
pub const CIP_NAME_CONFLICT = CIP_STATUS.NAME_CONFLICT;
pub const CIP_TRUST_VERIFICATION_COMPONENT_MISSING = CIP_STATUS.TRUST_VERIFICATION_COMPONENT_MISSING;
pub const CIP_EXE_SELF_REGISTERATION_TIMEOUT = CIP_STATUS.EXE_SELF_REGISTERATION_TIMEOUT;
pub const CIP_UNSAFE_TO_ABORT = CIP_STATUS.UNSAFE_TO_ABORT;
pub const CIP_NEED_REBOOT = CIP_STATUS.NEED_REBOOT;
pub const CIP_NEED_REBOOT_UI_PERMISSION = CIP_STATUS.NEED_REBOOT_UI_PERMISSION;

const IID_ICodeInstall_Value = Guid.initString("79eac9d1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_ICodeInstall = &IID_ICodeInstall_Value;
pub const ICodeInstall = extern struct {
    pub const VTable = extern struct {
        base: IWindowForBindingUI.VTable,
        OnCodeInstallProblem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICodeInstall,
                ulStatusCode: u32,
                szDestination: ?[*:0]const u16,
                szSource: ?[*:0]const u16,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICodeInstall,
                ulStatusCode: u32,
                szDestination: ?[*:0]const u16,
                szSource: ?[*:0]const u16,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowForBindingUI.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodeInstall_OnCodeInstallProblem(self: *const T, ulStatusCode: u32, szDestination: ?[*:0]const u16, szSource: ?[*:0]const u16, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodeInstall.VTable, self.vtable).OnCodeInstallProblem(@ptrCast(*const ICodeInstall, self), ulStatusCode, szDestination, szSource, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Uri_HOST_TYPE = enum(i32) {
    UNKNOWN = 0,
    DNS = 1,
    IPV4 = 2,
    IPV6 = 3,
    IDN = 4,
};
pub const Uri_HOST_UNKNOWN = Uri_HOST_TYPE.UNKNOWN;
pub const Uri_HOST_DNS = Uri_HOST_TYPE.DNS;
pub const Uri_HOST_IPV4 = Uri_HOST_TYPE.IPV4;
pub const Uri_HOST_IPV6 = Uri_HOST_TYPE.IPV6;
pub const Uri_HOST_IDN = Uri_HOST_TYPE.IDN;

const IID_IUriContainer_Value = Guid.initString("a158a630-ed6f-45fb-b987-f68676f57752");
pub const IID_IUriContainer = &IID_IUriContainer_Value;
pub const IUriContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUriContainer,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUriContainer,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriContainer_GetIUri(self: *const T, ppIUri: ?*?*IUri) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriContainer.VTable, self.vtable).GetIUri(@ptrCast(*const IUriContainer, self), ppIUri);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriBuilderFactory_Value = Guid.initString("e982ce48-0b96-440c-bc37-0c869b27a29e");
pub const IID_IUriBuilderFactory = &IID_IUriBuilderFactory_Value;
pub const IUriBuilderFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIUriBuilder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUriBuilderFactory,
                dwFlags: u32,
                dwReserved: usize,
                ppIUriBuilder: ?*?*IUriBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUriBuilderFactory,
                dwFlags: u32,
                dwReserved: usize,
                ppIUriBuilder: ?*?*IUriBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInitializedIUriBuilder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUriBuilderFactory,
                dwFlags: u32,
                dwReserved: usize,
                ppIUriBuilder: ?*?*IUriBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUriBuilderFactory,
                dwFlags: u32,
                dwReserved: usize,
                ppIUriBuilder: ?*?*IUriBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilderFactory_CreateIUriBuilder(self: *const T, dwFlags: u32, dwReserved: usize, ppIUriBuilder: ?*?*IUriBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilderFactory.VTable, self.vtable).CreateIUriBuilder(@ptrCast(*const IUriBuilderFactory, self), dwFlags, dwReserved, ppIUriBuilder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUriBuilderFactory_CreateInitializedIUriBuilder(self: *const T, dwFlags: u32, dwReserved: usize, ppIUriBuilder: ?*?*IUriBuilder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUriBuilderFactory.VTable, self.vtable).CreateInitializedIUriBuilder(@ptrCast(*const IUriBuilderFactory, self), dwFlags, dwReserved, ppIUriBuilder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetInfo_Value = Guid.initString("79eac9d6-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IWinInetInfo = &IID_IWinInetInfo_Value;
pub const IWinInetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetInfo,
                dwOption: u32,
                pBuffer: [*]u8,
                pcbBuf: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetInfo,
                dwOption: u32,
                pBuffer: [*]u8,
                pcbBuf: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetInfo_QueryOption(self: *const T, dwOption: u32, pBuffer: [*]u8, pcbBuf: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetInfo.VTable, self.vtable).QueryOption(@ptrCast(*const IWinInetInfo, self), dwOption, pBuffer, pcbBuf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHttpSecurity_Value = Guid.initString("79eac9d7-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IHttpSecurity = &IID_IHttpSecurity_Value;
pub const IHttpSecurity = extern struct {
    pub const VTable = extern struct {
        base: IWindowForBindingUI.VTable,
        OnSecurityProblem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHttpSecurity,
                dwProblem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHttpSecurity,
                dwProblem: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWindowForBindingUI.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHttpSecurity_OnSecurityProblem(self: *const T, dwProblem: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHttpSecurity.VTable, self.vtable).OnSecurityProblem(@ptrCast(*const IHttpSecurity, self), dwProblem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetHttpInfo_Value = Guid.initString("79eac9d8-bafa-11ce-8c82-00aa004ba90b");
pub const IID_IWinInetHttpInfo = &IID_IWinInetHttpInfo_Value;
pub const IWinInetHttpInfo = extern struct {
    pub const VTable = extern struct {
        base: IWinInetInfo.VTable,
        QueryInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetHttpInfo,
                dwOption: u32,
                pBuffer: [*]u8,
                pcbBuf: ?*u32,
                pdwFlags: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetHttpInfo,
                dwOption: u32,
                pBuffer: [*]u8,
                pcbBuf: ?*u32,
                pdwFlags: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWinInetInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetHttpInfo_QueryInfo(self: *const T, dwOption: u32, pBuffer: [*]u8, pcbBuf: ?*u32, pdwFlags: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetHttpInfo.VTable, self.vtable).QueryInfo(@ptrCast(*const IWinInetHttpInfo, self), dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetHttpTimeouts_Value = Guid.initString("f286fa56-c1fd-4270-8e67-b3eb790a81e8");
pub const IID_IWinInetHttpTimeouts = &IID_IWinInetHttpTimeouts_Value;
pub const IWinInetHttpTimeouts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequestTimeouts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetHttpTimeouts,
                pdwConnectTimeout: ?*u32,
                pdwSendTimeout: ?*u32,
                pdwReceiveTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetHttpTimeouts,
                pdwConnectTimeout: ?*u32,
                pdwSendTimeout: ?*u32,
                pdwReceiveTimeout: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetHttpTimeouts_GetRequestTimeouts(self: *const T, pdwConnectTimeout: ?*u32, pdwSendTimeout: ?*u32, pdwReceiveTimeout: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetHttpTimeouts.VTable, self.vtable).GetRequestTimeouts(@ptrCast(*const IWinInetHttpTimeouts, self), pdwConnectTimeout, pdwSendTimeout, pdwReceiveTimeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetCacheHints_Value = Guid.initString("dd1ec3b3-8391-4fdb-a9e6-347c3caaa7dd");
pub const IID_IWinInetCacheHints = &IID_IWinInetCacheHints_Value;
pub const IWinInetCacheHints = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCacheExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetCacheHints,
                pwzExt: ?[*:0]const u16,
                pszCacheFile: [*]u8,
                pcbCacheFile: ?*u32,
                pdwWinInetError: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetCacheHints,
                pwzExt: ?[*:0]const u16,
                pszCacheFile: [*]u8,
                pcbCacheFile: ?*u32,
                pdwWinInetError: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetCacheHints_SetCacheExtension(self: *const T, pwzExt: ?[*:0]const u16, pszCacheFile: [*]u8, pcbCacheFile: ?*u32, pdwWinInetError: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetCacheHints.VTable, self.vtable).SetCacheExtension(@ptrCast(*const IWinInetCacheHints, self), pwzExt, pszCacheFile, pcbCacheFile, pdwWinInetError, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWinInetCacheHints2_Value = Guid.initString("7857aeac-d31f-49bf-884e-dd46df36780a");
pub const IID_IWinInetCacheHints2 = &IID_IWinInetCacheHints2_Value;
pub const IWinInetCacheHints2 = extern struct {
    pub const VTable = extern struct {
        base: IWinInetCacheHints.VTable,
        SetCacheExtension2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWinInetCacheHints2,
                pwzExt: ?[*:0]const u16,
                pwzCacheFile: ?PWSTR,
                pcchCacheFile: ?*u32,
                pdwWinInetError: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWinInetCacheHints2,
                pwzExt: ?[*:0]const u16,
                pwzCacheFile: ?PWSTR,
                pcchCacheFile: ?*u32,
                pdwWinInetError: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWinInetCacheHints.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWinInetCacheHints2_SetCacheExtension2(self: *const T, pwzExt: ?[*:0]const u16, pwzCacheFile: ?PWSTR, pcchCacheFile: ?*u32, pdwWinInetError: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWinInetCacheHints2.VTable, self.vtable).SetCacheExtension2(@ptrCast(*const IWinInetCacheHints2, self), pwzExt, pwzCacheFile, pcchCacheFile, pdwWinInetError, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternet_Value = Guid.initString("79eac9e0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternet = &IID_IInternet_Value;
pub const IInternet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDSTRING = enum(i32) {
    HEADERS = 1,
    ACCEPT_MIMES = 2,
    EXTRA_URL = 3,
    LANGUAGE = 4,
    USERNAME = 5,
    PASSWORD = 6,
    UA_PIXELS = 7,
    UA_COLOR = 8,
    OS = 9,
    USER_AGENT = 10,
    ACCEPT_ENCODINGS = 11,
    POST_COOKIE = 12,
    POST_DATA_MIME = 13,
    URL = 14,
    IID = 15,
    FLAG_BIND_TO_OBJECT = 16,
    PTR_BIND_CONTEXT = 17,
    XDR_ORIGIN = 18,
    DOWNLOADPATH = 19,
    ROOTDOC_URL = 20,
    INITIAL_FILENAME = 21,
    PROXY_USERNAME = 22,
    PROXY_PASSWORD = 23,
    ENTERPRISE_ID = 24,
    DOC_URL = 25,
    SAMESITE_COOKIE_LEVEL = 26,
};
pub const BINDSTRING_HEADERS = BINDSTRING.HEADERS;
pub const BINDSTRING_ACCEPT_MIMES = BINDSTRING.ACCEPT_MIMES;
pub const BINDSTRING_EXTRA_URL = BINDSTRING.EXTRA_URL;
pub const BINDSTRING_LANGUAGE = BINDSTRING.LANGUAGE;
pub const BINDSTRING_USERNAME = BINDSTRING.USERNAME;
pub const BINDSTRING_PASSWORD = BINDSTRING.PASSWORD;
pub const BINDSTRING_UA_PIXELS = BINDSTRING.UA_PIXELS;
pub const BINDSTRING_UA_COLOR = BINDSTRING.UA_COLOR;
pub const BINDSTRING_OS = BINDSTRING.OS;
pub const BINDSTRING_USER_AGENT = BINDSTRING.USER_AGENT;
pub const BINDSTRING_ACCEPT_ENCODINGS = BINDSTRING.ACCEPT_ENCODINGS;
pub const BINDSTRING_POST_COOKIE = BINDSTRING.POST_COOKIE;
pub const BINDSTRING_POST_DATA_MIME = BINDSTRING.POST_DATA_MIME;
pub const BINDSTRING_URL = BINDSTRING.URL;
pub const BINDSTRING_IID = BINDSTRING.IID;
pub const BINDSTRING_FLAG_BIND_TO_OBJECT = BINDSTRING.FLAG_BIND_TO_OBJECT;
pub const BINDSTRING_PTR_BIND_CONTEXT = BINDSTRING.PTR_BIND_CONTEXT;
pub const BINDSTRING_XDR_ORIGIN = BINDSTRING.XDR_ORIGIN;
pub const BINDSTRING_DOWNLOADPATH = BINDSTRING.DOWNLOADPATH;
pub const BINDSTRING_ROOTDOC_URL = BINDSTRING.ROOTDOC_URL;
pub const BINDSTRING_INITIAL_FILENAME = BINDSTRING.INITIAL_FILENAME;
pub const BINDSTRING_PROXY_USERNAME = BINDSTRING.PROXY_USERNAME;
pub const BINDSTRING_PROXY_PASSWORD = BINDSTRING.PROXY_PASSWORD;
pub const BINDSTRING_ENTERPRISE_ID = BINDSTRING.ENTERPRISE_ID;
pub const BINDSTRING_DOC_URL = BINDSTRING.DOC_URL;
pub const BINDSTRING_SAMESITE_COOKIE_LEVEL = BINDSTRING.SAMESITE_COOKIE_LEVEL;

const IID_IInternetBindInfo_Value = Guid.initString("79eac9e1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetBindInfo = &IID_IInternetBindInfo_Value;
pub const IInternetBindInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBindInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetBindInfo,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetBindInfo,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetBindInfo,
                ulStringType: u32,
                ppwzStr: ?*?PWSTR,
                cEl: u32,
                pcElFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetBindInfo,
                ulStringType: u32,
                ppwzStr: ?*?PWSTR,
                cEl: u32,
                pcElFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetBindInfo_GetBindInfo(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetBindInfo.VTable, self.vtable).GetBindInfo(@ptrCast(*const IInternetBindInfo, self), grfBINDF, pbindinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetBindInfo_GetBindString(self: *const T, ulStringType: u32, ppwzStr: ?*?PWSTR, cEl: u32, pcElFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetBindInfo.VTable, self.vtable).GetBindString(@ptrCast(*const IInternetBindInfo, self), ulStringType, ppwzStr, cEl, pcElFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetBindInfoEx_Value = Guid.initString("a3e015b7-a82c-4dcd-a150-569aeeed36ab");
pub const IID_IInternetBindInfoEx = &IID_IInternetBindInfoEx_Value;
pub const IInternetBindInfoEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetBindInfo.VTable,
        GetBindInfoEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetBindInfoEx,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
                grfBINDF2: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetBindInfoEx,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
                grfBINDF2: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetBindInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetBindInfoEx_GetBindInfoEx(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO, grfBINDF2: ?*u32, pdwReserved: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetBindInfoEx.VTable, self.vtable).GetBindInfoEx(@ptrCast(*const IInternetBindInfoEx, self), grfBINDF, pbindinfo, grfBINDF2, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PI_FLAGS = enum(i32) {
    I_PARSE_URL = 1,
    I_FILTER_MODE = 2,
    I_FORCE_ASYNC = 4,
    I_USE_WORKERTHREAD = 8,
    I_MIMEVERIFICATION = 16,
    I_CLSIDLOOKUP = 32,
    I_DATAPROGRESS = 64,
    I_SYNCHRONOUS = 128,
    I_APARTMENTTHREADED = 256,
    I_CLASSINSTALL = 512,
    I_PASSONBINDCTX = 8192,
    I_NOMIMEHANDLER = 32768,
    I_LOADAPPDIRECT = 16384,
    D_FORCE_SWITCH = 65536,
    I_PREFERDEFAULTHANDLER = 131072,
};
pub const PI_PARSE_URL = PI_FLAGS.I_PARSE_URL;
pub const PI_FILTER_MODE = PI_FLAGS.I_FILTER_MODE;
pub const PI_FORCE_ASYNC = PI_FLAGS.I_FORCE_ASYNC;
pub const PI_USE_WORKERTHREAD = PI_FLAGS.I_USE_WORKERTHREAD;
pub const PI_MIMEVERIFICATION = PI_FLAGS.I_MIMEVERIFICATION;
pub const PI_CLSIDLOOKUP = PI_FLAGS.I_CLSIDLOOKUP;
pub const PI_DATAPROGRESS = PI_FLAGS.I_DATAPROGRESS;
pub const PI_SYNCHRONOUS = PI_FLAGS.I_SYNCHRONOUS;
pub const PI_APARTMENTTHREADED = PI_FLAGS.I_APARTMENTTHREADED;
pub const PI_CLASSINSTALL = PI_FLAGS.I_CLASSINSTALL;
pub const PI_PASSONBINDCTX = PI_FLAGS.I_PASSONBINDCTX;
pub const PI_NOMIMEHANDLER = PI_FLAGS.I_NOMIMEHANDLER;
pub const PI_LOADAPPDIRECT = PI_FLAGS.I_LOADAPPDIRECT;
pub const PD_FORCE_SWITCH = PI_FLAGS.D_FORCE_SWITCH;
pub const PI_PREFERDEFAULTHANDLER = PI_FLAGS.I_PREFERDEFAULTHANDLER;

pub const PROTOCOLDATA = extern struct {
    grfFlags: u32,
    dwState: u32,
    pData: ?*anyopaque,
    cbData: u32,
};

pub const StartParam = extern struct {
    iid: Guid,
    pIBindCtx: ?*IBindCtx,
    pItf: ?*IUnknown,
};

const IID_IInternetProtocolRoot_Value = Guid.initString("79eac9e3-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolRoot = &IID_IInternetProtocolRoot_Value;
pub const IInternetProtocolRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolRoot,
                szUrl: ?[*:0]const u16,
                pOIProtSink: ?*IInternetProtocolSink,
                pOIBindInfo: ?*IInternetBindInfo,
                grfPI: u32,
                dwReserved: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolRoot,
                szUrl: ?[*:0]const u16,
                pOIProtSink: ?*IInternetProtocolSink,
                pOIBindInfo: ?*IInternetBindInfo,
                grfPI: u32,
                dwReserved: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Continue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolRoot,
                pProtocolData: ?*PROTOCOLDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolRoot,
                pProtocolData: ?*PROTOCOLDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolRoot,
                hrReason: HRESULT,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolRoot,
                hrReason: HRESULT,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolRoot,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolRoot,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolRoot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Start(self: *const T, szUrl: ?[*:0]const u16, pOIProtSink: ?*IInternetProtocolSink, pOIBindInfo: ?*IInternetBindInfo, grfPI: u32, dwReserved: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Start(@ptrCast(*const IInternetProtocolRoot, self), szUrl, pOIProtSink, pOIBindInfo, grfPI, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Continue(self: *const T, pProtocolData: ?*PROTOCOLDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Continue(@ptrCast(*const IInternetProtocolRoot, self), pProtocolData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Abort(self: *const T, hrReason: HRESULT, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Abort(@ptrCast(*const IInternetProtocolRoot, self), hrReason, dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Terminate(self: *const T, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Terminate(@ptrCast(*const IInternetProtocolRoot, self), dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Suspend(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Suspend(@ptrCast(*const IInternetProtocolRoot, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolRoot_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolRoot.VTable, self.vtable).Resume(@ptrCast(*const IInternetProtocolRoot, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocol_Value = Guid.initString("79eac9e4-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocol = &IID_IInternetProtocol_Value;
pub const IInternetProtocol = extern struct {
    pub const VTable = extern struct {
        base: IInternetProtocolRoot.VTable,
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocol,
                pv: [*]u8,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocol,
                pv: [*]u8,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocol,
                dlibMove: LARGE_INTEGER,
                dwOrigin: u32,
                plibNewPosition: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocol,
                dlibMove: LARGE_INTEGER,
                dwOrigin: u32,
                plibNewPosition: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocol,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocol,
                dwOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetProtocolRoot.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_Read(self: *const T, pv: [*]u8, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).Read(@ptrCast(*const IInternetProtocol, self), pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_Seek(self: *const T, dlibMove: LARGE_INTEGER, dwOrigin: u32, plibNewPosition: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).Seek(@ptrCast(*const IInternetProtocol, self), dlibMove, dwOrigin, plibNewPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_LockRequest(self: *const T, dwOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).LockRequest(@ptrCast(*const IInternetProtocol, self), dwOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocol_UnlockRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocol.VTable, self.vtable).UnlockRequest(@ptrCast(*const IInternetProtocol, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocolEx_Value = Guid.initString("c7a98e66-1010-492c-a1c8-c809e1f75905");
pub const IID_IInternetProtocolEx = &IID_IInternetProtocolEx_Value;
pub const IInternetProtocolEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetProtocol.VTable,
        StartEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolEx,
                pUri: ?*IUri,
                pOIProtSink: ?*IInternetProtocolSink,
                pOIBindInfo: ?*IInternetBindInfo,
                grfPI: u32,
                dwReserved: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolEx,
                pUri: ?*IUri,
                pOIProtSink: ?*IInternetProtocolSink,
                pOIBindInfo: ?*IInternetBindInfo,
                grfPI: u32,
                dwReserved: HANDLE_PTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetProtocol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolEx_StartEx(self: *const T, pUri: ?*IUri, pOIProtSink: ?*IInternetProtocolSink, pOIBindInfo: ?*IInternetBindInfo, grfPI: u32, dwReserved: HANDLE_PTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolEx.VTable, self.vtable).StartEx(@ptrCast(*const IInternetProtocolEx, self), pUri, pOIProtSink, pOIBindInfo, grfPI, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocolSink_Value = Guid.initString("79eac9e5-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolSink = &IID_IInternetProtocolSink_Value;
pub const IInternetProtocolSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Switch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSink,
                pProtocolData: ?*PROTOCOLDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSink,
                pProtocolData: ?*PROTOCOLDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReportProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSink,
                ulStatusCode: u32,
                szStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSink,
                ulStatusCode: u32,
                szStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReportData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSink,
                grfBSCF: u32,
                ulProgress: u32,
                ulProgressMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSink,
                grfBSCF: u32,
                ulProgress: u32,
                ulProgressMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReportResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSink,
                hrResult: HRESULT,
                dwError: u32,
                szResult: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSink,
                hrResult: HRESULT,
                dwError: u32,
                szResult: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_Switch(self: *const T, pProtocolData: ?*PROTOCOLDATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).Switch(@ptrCast(*const IInternetProtocolSink, self), pProtocolData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_ReportProgress(self: *const T, ulStatusCode: u32, szStatusText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).ReportProgress(@ptrCast(*const IInternetProtocolSink, self), ulStatusCode, szStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_ReportData(self: *const T, grfBSCF: u32, ulProgress: u32, ulProgressMax: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).ReportData(@ptrCast(*const IInternetProtocolSink, self), grfBSCF, ulProgress, ulProgressMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSink_ReportResult(self: *const T, hrResult: HRESULT, dwError: u32, szResult: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSink.VTable, self.vtable).ReportResult(@ptrCast(*const IInternetProtocolSink, self), hrResult, dwError, szResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetProtocolSinkStackable_Value = Guid.initString("79eac9f0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolSinkStackable = &IID_IInternetProtocolSinkStackable_Value;
pub const IInternetProtocolSinkStackable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSinkStackable,
                pOIProtSink: ?*IInternetProtocolSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSinkStackable,
                pOIProtSink: ?*IInternetProtocolSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitSwitch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSinkStackable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSinkStackable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RollbackSwitch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolSinkStackable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolSinkStackable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSinkStackable_SwitchSink(self: *const T, pOIProtSink: ?*IInternetProtocolSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSinkStackable.VTable, self.vtable).SwitchSink(@ptrCast(*const IInternetProtocolSinkStackable, self), pOIProtSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSinkStackable_CommitSwitch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSinkStackable.VTable, self.vtable).CommitSwitch(@ptrCast(*const IInternetProtocolSinkStackable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolSinkStackable_RollbackSwitch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolSinkStackable.VTable, self.vtable).RollbackSwitch(@ptrCast(*const IInternetProtocolSinkStackable, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OIBDG_FLAGS = enum(i32) {
    APARTMENTTHREADED = 256,
    DATAONLY = 4096,
};
pub const OIBDG_APARTMENTTHREADED = OIBDG_FLAGS.APARTMENTTHREADED;
pub const OIBDG_DATAONLY = OIBDG_FLAGS.DATAONLY;

const IID_IInternetSession_Value = Guid.initString("79eac9e7-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetSession = &IID_IInternetSession_Value;
pub const IInternetSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterNameSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                rclsid: ?*const Guid,
                pwzProtocol: ?[*:0]const u16,
                cPatterns: u32,
                ppwzPatterns: ?*const ?PWSTR,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                rclsid: ?*const Guid,
                pwzProtocol: ?[*:0]const u16,
                cPatterns: u32,
                ppwzPatterns: ?*const ?PWSTR,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterNameSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                pszProtocol: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                pszProtocol: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterMimeFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                rclsid: ?*const Guid,
                pwzType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                rclsid: ?*const Guid,
                pwzType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterMimeFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                pwzType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                pCF: ?*IClassFactory,
                pwzType: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBinding: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                pBC: ?*IBindCtx,
                szUrl: ?[*:0]const u16,
                pUnkOuter: ?*IUnknown,
                ppUnk: ?*?*IUnknown,
                ppOInetProt: ?*?*IInternetProtocol,
                dwOption: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                pBC: ?*IBindCtx,
                szUrl: ?[*:0]const u16,
                pUnkOuter: ?*IUnknown,
                ppUnk: ?*?*IUnknown,
                ppOInetProt: ?*?*IInternetProtocol,
                dwOption: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSessionOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                dwOption: u32,
                pBuffer: ?*anyopaque,
                dwBufferLength: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                dwOption: u32,
                pBuffer: ?*anyopaque,
                dwBufferLength: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSessionOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSession,
                dwOption: u32,
                pBuffer: ?*anyopaque,
                pdwBufferLength: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSession,
                dwOption: u32,
                pBuffer: ?*anyopaque,
                pdwBufferLength: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_RegisterNameSpace(self: *const T, pCF: ?*IClassFactory, rclsid: ?*const Guid, pwzProtocol: ?[*:0]const u16, cPatterns: u32, ppwzPatterns: ?*const ?PWSTR, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).RegisterNameSpace(@ptrCast(*const IInternetSession, self), pCF, rclsid, pwzProtocol, cPatterns, ppwzPatterns, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_UnregisterNameSpace(self: *const T, pCF: ?*IClassFactory, pszProtocol: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).UnregisterNameSpace(@ptrCast(*const IInternetSession, self), pCF, pszProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_RegisterMimeFilter(self: *const T, pCF: ?*IClassFactory, rclsid: ?*const Guid, pwzType: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).RegisterMimeFilter(@ptrCast(*const IInternetSession, self), pCF, rclsid, pwzType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_UnregisterMimeFilter(self: *const T, pCF: ?*IClassFactory, pwzType: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).UnregisterMimeFilter(@ptrCast(*const IInternetSession, self), pCF, pwzType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_CreateBinding(self: *const T, pBC: ?*IBindCtx, szUrl: ?[*:0]const u16, pUnkOuter: ?*IUnknown, ppUnk: ?*?*IUnknown, ppOInetProt: ?*?*IInternetProtocol, dwOption: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).CreateBinding(@ptrCast(*const IInternetSession, self), pBC, szUrl, pUnkOuter, ppUnk, ppOInetProt, dwOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_SetSessionOption(self: *const T, dwOption: u32, pBuffer: ?*anyopaque, dwBufferLength: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).SetSessionOption(@ptrCast(*const IInternetSession, self), dwOption, pBuffer, dwBufferLength, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSession_GetSessionOption(self: *const T, dwOption: u32, pBuffer: ?*anyopaque, pdwBufferLength: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSession.VTable, self.vtable).GetSessionOption(@ptrCast(*const IInternetSession, self), dwOption, pBuffer, pdwBufferLength, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetThreadSwitch_Value = Guid.initString("79eac9e8-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetThreadSwitch = &IID_IInternetThreadSwitch_Value;
pub const IInternetThreadSwitch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Prepare: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetThreadSwitch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetThreadSwitch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Continue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetThreadSwitch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetThreadSwitch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetThreadSwitch_Prepare(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetThreadSwitch.VTable, self.vtable).Prepare(@ptrCast(*const IInternetThreadSwitch, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetThreadSwitch_Continue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetThreadSwitch.VTable, self.vtable).Continue(@ptrCast(*const IInternetThreadSwitch, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetPriority_Value = Guid.initString("79eac9eb-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetPriority = &IID_IInternetPriority_Value;
pub const IInternetPriority = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetPriority,
                nPriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetPriority,
                nPriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetPriority,
                pnPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetPriority,
                pnPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetPriority_SetPriority(self: *const T, nPriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetPriority.VTable, self.vtable).SetPriority(@ptrCast(*const IInternetPriority, self), nPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetPriority_GetPriority(self: *const T, pnPriority: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetPriority.VTable, self.vtable).GetPriority(@ptrCast(*const IInternetPriority, self), pnPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PARSEACTION = enum(i32) {
    CANONICALIZE = 1,
    FRIENDLY = 2,
    SECURITY_URL = 3,
    ROOTDOCUMENT = 4,
    DOCUMENT = 5,
    ANCHOR = 6,
    ENCODE_IS_UNESCAPE = 7,
    DECODE_IS_ESCAPE = 8,
    PATH_FROM_URL = 9,
    URL_FROM_PATH = 10,
    MIME = 11,
    SERVER = 12,
    SCHEMA = 13,
    SITE = 14,
    DOMAIN = 15,
    LOCATION = 16,
    SECURITY_DOMAIN = 17,
    ESCAPE = 18,
    UNESCAPE = 19,
};
pub const PARSE_CANONICALIZE = PARSEACTION.CANONICALIZE;
pub const PARSE_FRIENDLY = PARSEACTION.FRIENDLY;
pub const PARSE_SECURITY_URL = PARSEACTION.SECURITY_URL;
pub const PARSE_ROOTDOCUMENT = PARSEACTION.ROOTDOCUMENT;
pub const PARSE_DOCUMENT = PARSEACTION.DOCUMENT;
pub const PARSE_ANCHOR = PARSEACTION.ANCHOR;
pub const PARSE_ENCODE_IS_UNESCAPE = PARSEACTION.ENCODE_IS_UNESCAPE;
pub const PARSE_DECODE_IS_ESCAPE = PARSEACTION.DECODE_IS_ESCAPE;
pub const PARSE_PATH_FROM_URL = PARSEACTION.PATH_FROM_URL;
pub const PARSE_URL_FROM_PATH = PARSEACTION.URL_FROM_PATH;
pub const PARSE_MIME = PARSEACTION.MIME;
pub const PARSE_SERVER = PARSEACTION.SERVER;
pub const PARSE_SCHEMA = PARSEACTION.SCHEMA;
pub const PARSE_SITE = PARSEACTION.SITE;
pub const PARSE_DOMAIN = PARSEACTION.DOMAIN;
pub const PARSE_LOCATION = PARSEACTION.LOCATION;
pub const PARSE_SECURITY_DOMAIN = PARSEACTION.SECURITY_DOMAIN;
pub const PARSE_ESCAPE = PARSEACTION.ESCAPE;
pub const PARSE_UNESCAPE = PARSEACTION.UNESCAPE;

pub const PSUACTION = enum(i32) {
    DEFAULT = 1,
    SECURITY_URL_ONLY = 2,
};
pub const PSU_DEFAULT = PSUACTION.DEFAULT;
pub const PSU_SECURITY_URL_ONLY = PSUACTION.SECURITY_URL_ONLY;

pub const QUERYOPTION = enum(i32) {
    EXPIRATION_DATE = 1,
    TIME_OF_LAST_CHANGE = 2,
    CONTENT_ENCODING = 3,
    CONTENT_TYPE = 4,
    REFRESH = 5,
    RECOMBINE = 6,
    CAN_NAVIGATE = 7,
    USES_NETWORK = 8,
    IS_CACHED = 9,
    IS_INSTALLEDENTRY = 10,
    IS_CACHED_OR_MAPPED = 11,
    USES_CACHE = 12,
    IS_SECURE = 13,
    IS_SAFE = 14,
    USES_HISTORYFOLDER = 15,
    IS_CACHED_AND_USABLE_OFFLINE = 16,
};
pub const QUERY_EXPIRATION_DATE = QUERYOPTION.EXPIRATION_DATE;
pub const QUERY_TIME_OF_LAST_CHANGE = QUERYOPTION.TIME_OF_LAST_CHANGE;
pub const QUERY_CONTENT_ENCODING = QUERYOPTION.CONTENT_ENCODING;
pub const QUERY_CONTENT_TYPE = QUERYOPTION.CONTENT_TYPE;
pub const QUERY_REFRESH = QUERYOPTION.REFRESH;
pub const QUERY_RECOMBINE = QUERYOPTION.RECOMBINE;
pub const QUERY_CAN_NAVIGATE = QUERYOPTION.CAN_NAVIGATE;
pub const QUERY_USES_NETWORK = QUERYOPTION.USES_NETWORK;
pub const QUERY_IS_CACHED = QUERYOPTION.IS_CACHED;
pub const QUERY_IS_INSTALLEDENTRY = QUERYOPTION.IS_INSTALLEDENTRY;
pub const QUERY_IS_CACHED_OR_MAPPED = QUERYOPTION.IS_CACHED_OR_MAPPED;
pub const QUERY_USES_CACHE = QUERYOPTION.USES_CACHE;
pub const QUERY_IS_SECURE = QUERYOPTION.IS_SECURE;
pub const QUERY_IS_SAFE = QUERYOPTION.IS_SAFE;
pub const QUERY_USES_HISTORYFOLDER = QUERYOPTION.USES_HISTORYFOLDER;
pub const QUERY_IS_CACHED_AND_USABLE_OFFLINE = QUERYOPTION.IS_CACHED_AND_USABLE_OFFLINE;

const IID_IInternetProtocolInfo_Value = Guid.initString("79eac9ec-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetProtocolInfo = &IID_IInternetProtocolInfo_Value;
pub const IInternetProtocolInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolInfo,
                pwzUrl: ?[*:0]const u16,
                ParseAction: PARSEACTION,
                dwParseFlags: u32,
                pwzResult: ?PWSTR,
                cchResult: u32,
                pcchResult: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolInfo,
                pwzUrl: ?[*:0]const u16,
                ParseAction: PARSEACTION,
                dwParseFlags: u32,
                pwzResult: ?PWSTR,
                cchResult: u32,
                pcchResult: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CombineUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolInfo,
                pwzBaseUrl: ?[*:0]const u16,
                pwzRelativeUrl: ?[*:0]const u16,
                dwCombineFlags: u32,
                pwzResult: ?PWSTR,
                cchResult: u32,
                pcchResult: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolInfo,
                pwzBaseUrl: ?[*:0]const u16,
                pwzRelativeUrl: ?[*:0]const u16,
                dwCombineFlags: u32,
                pwzResult: ?PWSTR,
                cchResult: u32,
                pcchResult: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolInfo,
                pwzUrl1: ?[*:0]const u16,
                pwzUrl2: ?[*:0]const u16,
                dwCompareFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolInfo,
                pwzUrl1: ?[*:0]const u16,
                pwzUrl2: ?[*:0]const u16,
                dwCompareFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetProtocolInfo,
                pwzUrl: ?[*:0]const u16,
                OueryOption: QUERYOPTION,
                dwQueryFlags: u32,
                pBuffer: [*]u8,
                cbBuffer: u32,
                pcbBuf: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetProtocolInfo,
                pwzUrl: ?[*:0]const u16,
                OueryOption: QUERYOPTION,
                dwQueryFlags: u32,
                pBuffer: [*]u8,
                cbBuffer: u32,
                pcbBuf: ?*u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_ParseUrl(self: *const T, pwzUrl: ?[*:0]const u16, ParseAction: PARSEACTION, dwParseFlags: u32, pwzResult: ?PWSTR, cchResult: u32, pcchResult: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).ParseUrl(@ptrCast(*const IInternetProtocolInfo, self), pwzUrl, ParseAction, dwParseFlags, pwzResult, cchResult, pcchResult, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_CombineUrl(self: *const T, pwzBaseUrl: ?[*:0]const u16, pwzRelativeUrl: ?[*:0]const u16, dwCombineFlags: u32, pwzResult: ?PWSTR, cchResult: u32, pcchResult: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).CombineUrl(@ptrCast(*const IInternetProtocolInfo, self), pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pwzResult, cchResult, pcchResult, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_CompareUrl(self: *const T, pwzUrl1: ?[*:0]const u16, pwzUrl2: ?[*:0]const u16, dwCompareFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).CompareUrl(@ptrCast(*const IInternetProtocolInfo, self), pwzUrl1, pwzUrl2, dwCompareFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetProtocolInfo_QueryInfo(self: *const T, pwzUrl: ?[*:0]const u16, OueryOption: QUERYOPTION, dwQueryFlags: u32, pBuffer: [*]u8, cbBuffer: u32, pcbBuf: ?*u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetProtocolInfo.VTable, self.vtable).QueryInfo(@ptrCast(*const IInternetProtocolInfo, self), pwzUrl, OueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const INTERNETFEATURELIST = enum(i32) {
    OBJECT_CACHING = 0,
    ZONE_ELEVATION = 1,
    MIME_HANDLING = 2,
    MIME_SNIFFING = 3,
    WINDOW_RESTRICTIONS = 4,
    WEBOC_POPUPMANAGEMENT = 5,
    BEHAVIORS = 6,
    DISABLE_MK_PROTOCOL = 7,
    LOCALMACHINE_LOCKDOWN = 8,
    SECURITYBAND = 9,
    RESTRICT_ACTIVEXINSTALL = 10,
    VALIDATE_NAVIGATE_URL = 11,
    RESTRICT_FILEDOWNLOAD = 12,
    ADDON_MANAGEMENT = 13,
    PROTOCOL_LOCKDOWN = 14,
    HTTP_USERNAME_PASSWORD_DISABLE = 15,
    SAFE_BINDTOOBJECT = 16,
    UNC_SAVEDFILECHECK = 17,
    GET_URL_DOM_FILEPATH_UNENCODED = 18,
    TABBED_BROWSING = 19,
    SSLUX = 20,
    DISABLE_NAVIGATION_SOUNDS = 21,
    DISABLE_LEGACY_COMPRESSION = 22,
    FORCE_ADDR_AND_STATUS = 23,
    XMLHTTP = 24,
    DISABLE_TELNET_PROTOCOL = 25,
    FEEDS = 26,
    BLOCK_INPUT_PROMPTS = 27,
    ENTRY_COUNT = 28,
};
pub const FEATURE_OBJECT_CACHING = INTERNETFEATURELIST.OBJECT_CACHING;
pub const FEATURE_ZONE_ELEVATION = INTERNETFEATURELIST.ZONE_ELEVATION;
pub const FEATURE_MIME_HANDLING = INTERNETFEATURELIST.MIME_HANDLING;
pub const FEATURE_MIME_SNIFFING = INTERNETFEATURELIST.MIME_SNIFFING;
pub const FEATURE_WINDOW_RESTRICTIONS = INTERNETFEATURELIST.WINDOW_RESTRICTIONS;
pub const FEATURE_WEBOC_POPUPMANAGEMENT = INTERNETFEATURELIST.WEBOC_POPUPMANAGEMENT;
pub const FEATURE_BEHAVIORS = INTERNETFEATURELIST.BEHAVIORS;
pub const FEATURE_DISABLE_MK_PROTOCOL = INTERNETFEATURELIST.DISABLE_MK_PROTOCOL;
pub const FEATURE_LOCALMACHINE_LOCKDOWN = INTERNETFEATURELIST.LOCALMACHINE_LOCKDOWN;
pub const FEATURE_SECURITYBAND = INTERNETFEATURELIST.SECURITYBAND;
pub const FEATURE_RESTRICT_ACTIVEXINSTALL = INTERNETFEATURELIST.RESTRICT_ACTIVEXINSTALL;
pub const FEATURE_VALIDATE_NAVIGATE_URL = INTERNETFEATURELIST.VALIDATE_NAVIGATE_URL;
pub const FEATURE_RESTRICT_FILEDOWNLOAD = INTERNETFEATURELIST.RESTRICT_FILEDOWNLOAD;
pub const FEATURE_ADDON_MANAGEMENT = INTERNETFEATURELIST.ADDON_MANAGEMENT;
pub const FEATURE_PROTOCOL_LOCKDOWN = INTERNETFEATURELIST.PROTOCOL_LOCKDOWN;
pub const FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = INTERNETFEATURELIST.HTTP_USERNAME_PASSWORD_DISABLE;
pub const FEATURE_SAFE_BINDTOOBJECT = INTERNETFEATURELIST.SAFE_BINDTOOBJECT;
pub const FEATURE_UNC_SAVEDFILECHECK = INTERNETFEATURELIST.UNC_SAVEDFILECHECK;
pub const FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = INTERNETFEATURELIST.GET_URL_DOM_FILEPATH_UNENCODED;
pub const FEATURE_TABBED_BROWSING = INTERNETFEATURELIST.TABBED_BROWSING;
pub const FEATURE_SSLUX = INTERNETFEATURELIST.SSLUX;
pub const FEATURE_DISABLE_NAVIGATION_SOUNDS = INTERNETFEATURELIST.DISABLE_NAVIGATION_SOUNDS;
pub const FEATURE_DISABLE_LEGACY_COMPRESSION = INTERNETFEATURELIST.DISABLE_LEGACY_COMPRESSION;
pub const FEATURE_FORCE_ADDR_AND_STATUS = INTERNETFEATURELIST.FORCE_ADDR_AND_STATUS;
pub const FEATURE_XMLHTTP = INTERNETFEATURELIST.XMLHTTP;
pub const FEATURE_DISABLE_TELNET_PROTOCOL = INTERNETFEATURELIST.DISABLE_TELNET_PROTOCOL;
pub const FEATURE_FEEDS = INTERNETFEATURELIST.FEEDS;
pub const FEATURE_BLOCK_INPUT_PROMPTS = INTERNETFEATURELIST.BLOCK_INPUT_PROMPTS;
pub const FEATURE_ENTRY_COUNT = INTERNETFEATURELIST.ENTRY_COUNT;

const IID_IInternetSecurityMgrSite_Value = Guid.initString("79eac9ed-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetSecurityMgrSite = &IID_IInternetSecurityMgrSite_Value;
pub const IInternetSecurityMgrSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityMgrSite,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityMgrSite,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityMgrSite,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityMgrSite,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityMgrSite_GetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityMgrSite.VTable, self.vtable).GetWindow(@ptrCast(*const IInternetSecurityMgrSite, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityMgrSite_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityMgrSite.VTable, self.vtable).EnableModeless(@ptrCast(*const IInternetSecurityMgrSite, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PUAF = enum(i32) {
    DEFAULT = 0,
    NOUI = 1,
    ISFILE = 2,
    WARN_IF_DENIED = 4,
    FORCEUI_FOREGROUND = 8,
    CHECK_TIFS = 16,
    DONTCHECKBOXINDIALOG = 32,
    TRUSTED = 64,
    ACCEPT_WILDCARD_SCHEME = 128,
    ENFORCERESTRICTED = 256,
    NOSAVEDFILECHECK = 512,
    REQUIRESAVEDFILECHECK = 1024,
    DONT_USE_CACHE = 4096,
    RESERVED1 = 8192,
    RESERVED2 = 16384,
    LMZ_UNLOCKED = 65536,
    LMZ_LOCKED = 131072,
    DEFAULTZONEPOL = 262144,
    NPL_USE_LOCKED_IF_RESTRICTED = 524288,
    NOUIIFLOCKED = 1048576,
    DRAGPROTOCOLCHECK = 2097152,
};
pub const PUAF_DEFAULT = PUAF.DEFAULT;
pub const PUAF_NOUI = PUAF.NOUI;
pub const PUAF_ISFILE = PUAF.ISFILE;
pub const PUAF_WARN_IF_DENIED = PUAF.WARN_IF_DENIED;
pub const PUAF_FORCEUI_FOREGROUND = PUAF.FORCEUI_FOREGROUND;
pub const PUAF_CHECK_TIFS = PUAF.CHECK_TIFS;
pub const PUAF_DONTCHECKBOXINDIALOG = PUAF.DONTCHECKBOXINDIALOG;
pub const PUAF_TRUSTED = PUAF.TRUSTED;
pub const PUAF_ACCEPT_WILDCARD_SCHEME = PUAF.ACCEPT_WILDCARD_SCHEME;
pub const PUAF_ENFORCERESTRICTED = PUAF.ENFORCERESTRICTED;
pub const PUAF_NOSAVEDFILECHECK = PUAF.NOSAVEDFILECHECK;
pub const PUAF_REQUIRESAVEDFILECHECK = PUAF.REQUIRESAVEDFILECHECK;
pub const PUAF_DONT_USE_CACHE = PUAF.DONT_USE_CACHE;
pub const PUAF_RESERVED1 = PUAF.RESERVED1;
pub const PUAF_RESERVED2 = PUAF.RESERVED2;
pub const PUAF_LMZ_UNLOCKED = PUAF.LMZ_UNLOCKED;
pub const PUAF_LMZ_LOCKED = PUAF.LMZ_LOCKED;
pub const PUAF_DEFAULTZONEPOL = PUAF.DEFAULTZONEPOL;
pub const PUAF_NPL_USE_LOCKED_IF_RESTRICTED = PUAF.NPL_USE_LOCKED_IF_RESTRICTED;
pub const PUAF_NOUIIFLOCKED = PUAF.NOUIIFLOCKED;
pub const PUAF_DRAGPROTOCOLCHECK = PUAF.DRAGPROTOCOLCHECK;

pub const PUAFOUT = enum(i32) {
    DEFAULT = 0,
    ISLOCKZONEPOLICY = 1,
};
pub const PUAFOUT_DEFAULT = PUAFOUT.DEFAULT;
pub const PUAFOUT_ISLOCKZONEPOLICY = PUAFOUT.ISLOCKZONEPOLICY;

pub const SZM_FLAGS = enum(i32) {
    CREATE = 0,
    DELETE = 1,
};
pub const SZM_CREATE = SZM_FLAGS.CREATE;
pub const SZM_DELETE = SZM_FLAGS.DELETE;

const IID_IInternetSecurityManager_Value = Guid.initString("79eac9ee-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetSecurityManager = &IID_IInternetSecurityManager_Value;
pub const IInternetSecurityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSecuritySite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                pSite: ?*IInternetSecurityMgrSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                pSite: ?*IInternetSecurityMgrSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecuritySite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                ppSite: ?*?*IInternetSecurityMgrSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                ppSite: ?*?*IInternetSecurityMgrSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapUrlToZone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                pdwZone: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                pdwZone: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecurityId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                pbSecurityId: *[512]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                pbSecurityId: *[512]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessUrlAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                pContext: ?*u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                pContext: ?*u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCustomPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                guidKey: ?*const Guid,
                ppPolicy: [*]?*u8,
                pcbPolicy: ?*u32,
                pContext: ?*u8,
                cbContext: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                pwszUrl: ?[*:0]const u16,
                guidKey: ?*const Guid,
                ppPolicy: [*]?*u8,
                pcbPolicy: ?*u32,
                pContext: ?*u8,
                cbContext: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZoneMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                dwZone: u32,
                lpszPattern: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                dwZone: u32,
                lpszPattern: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZoneMappings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManager,
                dwZone: u32,
                ppenumString: ?*?*IEnumString,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManager,
                dwZone: u32,
                ppenumString: ?*?*IEnumString,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_SetSecuritySite(self: *const T, pSite: ?*IInternetSecurityMgrSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).SetSecuritySite(@ptrCast(*const IInternetSecurityManager, self), pSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_GetSecuritySite(self: *const T, ppSite: ?*?*IInternetSecurityMgrSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).GetSecuritySite(@ptrCast(*const IInternetSecurityManager, self), ppSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_MapUrlToZone(self: *const T, pwszUrl: ?[*:0]const u16, pdwZone: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).MapUrlToZone(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, pdwZone, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_GetSecurityId(self: *const T, pwszUrl: ?[*:0]const u16, pbSecurityId: *[512]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).GetSecurityId(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, pbSecurityId, pcbSecurityId, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_ProcessUrlAction(self: *const T, pwszUrl: ?[*:0]const u16, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, pContext: ?*u8, cbContext: u32, dwFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).ProcessUrlAction(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_QueryCustomPolicy(self: *const T, pwszUrl: ?[*:0]const u16, guidKey: ?*const Guid, ppPolicy: [*]?*u8, pcbPolicy: ?*u32, pContext: ?*u8, cbContext: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).QueryCustomPolicy(@ptrCast(*const IInternetSecurityManager, self), pwszUrl, guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_SetZoneMapping(self: *const T, dwZone: u32, lpszPattern: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).SetZoneMapping(@ptrCast(*const IInternetSecurityManager, self), dwZone, lpszPattern, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManager_GetZoneMappings(self: *const T, dwZone: u32, ppenumString: ?*?*IEnumString, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManager.VTable, self.vtable).GetZoneMappings(@ptrCast(*const IInternetSecurityManager, self), dwZone, ppenumString, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetSecurityManagerEx_Value = Guid.initString("f164edf1-cc7c-4f0d-9a94-34222625c393");
pub const IID_IInternetSecurityManagerEx = &IID_IInternetSecurityManagerEx_Value;
pub const IInternetSecurityManagerEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetSecurityManager.VTable,
        ProcessUrlActionEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManagerEx,
                pwszUrl: ?[*:0]const u16,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                pContext: ?*u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: u32,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManagerEx,
                pwszUrl: ?[*:0]const u16,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                pContext: ?*u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: u32,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetSecurityManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx_ProcessUrlActionEx(self: *const T, pwszUrl: ?[*:0]const u16, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, pContext: ?*u8, cbContext: u32, dwFlags: u32, dwReserved: u32, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx.VTable, self.vtable).ProcessUrlActionEx(@ptrCast(*const IInternetSecurityManagerEx, self), pwszUrl, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved, pdwOutFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetSecurityManagerEx2_Value = Guid.initString("f1e50292-a795-4117-8e09-2b560a72ac60");
pub const IID_IInternetSecurityManagerEx2 = &IID_IInternetSecurityManagerEx2_Value;
pub const IInternetSecurityManagerEx2 = extern struct {
    pub const VTable = extern struct {
        base: IInternetSecurityManagerEx.VTable,
        MapUrlToZoneEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                pdwZone: ?*u32,
                dwFlags: u32,
                ppwszMappedUrl: ?*?PWSTR,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                pdwZone: ?*u32,
                dwFlags: u32,
                ppwszMappedUrl: ?*?PWSTR,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessUrlActionEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                pContext: ?*u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: usize,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                pContext: ?*u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: usize,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecurityIdEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                pbSecurityId: *[512]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                pbSecurityId: *[512]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCustomPolicyEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                guidKey: ?*const Guid,
                ppPolicy: [*]?*u8,
                pcbPolicy: ?*u32,
                pContext: ?*u8,
                cbContext: u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetSecurityManagerEx2,
                pUri: ?*IUri,
                guidKey: ?*const Guid,
                ppPolicy: [*]?*u8,
                pcbPolicy: ?*u32,
                pContext: ?*u8,
                cbContext: u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetSecurityManagerEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_MapUrlToZoneEx2(self: *const T, pUri: ?*IUri, pdwZone: ?*u32, dwFlags: u32, ppwszMappedUrl: ?*?PWSTR, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).MapUrlToZoneEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, pdwZone, dwFlags, ppwszMappedUrl, pdwOutFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_ProcessUrlActionEx2(self: *const T, pUri: ?*IUri, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, pContext: ?*u8, cbContext: u32, dwFlags: u32, dwReserved: usize, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).ProcessUrlActionEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved, pdwOutFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_GetSecurityIdEx2(self: *const T, pUri: ?*IUri, pbSecurityId: *[512]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).GetSecurityIdEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, pbSecurityId, pcbSecurityId, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetSecurityManagerEx2_QueryCustomPolicyEx2(self: *const T, pUri: ?*IUri, guidKey: ?*const Guid, ppPolicy: [*]?*u8, pcbPolicy: ?*u32, pContext: ?*u8, cbContext: u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetSecurityManagerEx2.VTable, self.vtable).QueryCustomPolicyEx2(@ptrCast(*const IInternetSecurityManagerEx2, self), pUri, guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IZoneIdentifier_Value = Guid.initString("cd45f185-1b21-48e2-967b-ead743a8914e");
pub const IID_IZoneIdentifier = &IID_IZoneIdentifier_Value;
pub const IZoneIdentifier = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier,
                pdwZone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier,
                pdwZone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier,
                dwZone: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier,
                dwZone: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier_GetId(self: *const T, pdwZone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier.VTable, self.vtable).GetId(@ptrCast(*const IZoneIdentifier, self), pdwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier_SetId(self: *const T, dwZone: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier.VTable, self.vtable).SetId(@ptrCast(*const IZoneIdentifier, self), dwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier_Remove(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier.VTable, self.vtable).Remove(@ptrCast(*const IZoneIdentifier, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IZoneIdentifier2_Value = Guid.initString("eb5e760c-09ef-45c0-b510-70830ce31e6a");
pub const IID_IZoneIdentifier2 = &IID_IZoneIdentifier2_Value;
pub const IZoneIdentifier2 = extern struct {
    pub const VTable = extern struct {
        base: IZoneIdentifier.VTable,
        GetLastWriterPackageFamilyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier2,
                packageFamilyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier2,
                packageFamilyName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLastWriterPackageFamilyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier2,
                packageFamilyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier2,
                packageFamilyName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveLastWriterPackageFamilyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppZoneId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier2,
                zone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier2,
                zone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAppZoneId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier2,
                zone: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier2,
                zone: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAppZoneId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IZoneIdentifier2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IZoneIdentifier2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IZoneIdentifier.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_GetLastWriterPackageFamilyName(self: *const T, packageFamilyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).GetLastWriterPackageFamilyName(@ptrCast(*const IZoneIdentifier2, self), packageFamilyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_SetLastWriterPackageFamilyName(self: *const T, packageFamilyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).SetLastWriterPackageFamilyName(@ptrCast(*const IZoneIdentifier2, self), packageFamilyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_RemoveLastWriterPackageFamilyName(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).RemoveLastWriterPackageFamilyName(@ptrCast(*const IZoneIdentifier2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_GetAppZoneId(self: *const T, zone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).GetAppZoneId(@ptrCast(*const IZoneIdentifier2, self), zone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_SetAppZoneId(self: *const T, zone: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).SetAppZoneId(@ptrCast(*const IZoneIdentifier2, self), zone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IZoneIdentifier2_RemoveAppZoneId(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IZoneIdentifier2.VTable, self.vtable).RemoveAppZoneId(@ptrCast(*const IZoneIdentifier2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetHostSecurityManager_Value = Guid.initString("3af280b6-cb3f-11d0-891e-00c04fb6bfc4");
pub const IID_IInternetHostSecurityManager = &IID_IInternetHostSecurityManager_Value;
pub const IInternetHostSecurityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecurityId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetHostSecurityManager,
                pbSecurityId: [*:0]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetHostSecurityManager,
                pbSecurityId: [*:0]u8,
                pcbSecurityId: ?*u32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessUrlAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetHostSecurityManager,
                dwAction: u32,
                pPolicy: ?*u8,
                cbPolicy: u32,
                pContext: ?[*:0]u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetHostSecurityManager,
                dwAction: u32,
                pPolicy: ?*u8,
                cbPolicy: u32,
                pContext: ?[*:0]u8,
                cbContext: u32,
                dwFlags: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCustomPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetHostSecurityManager,
                guidKey: ?*const Guid,
                ppPolicy: ?[*]?*u8,
                pcbPolicy: ?*u32,
                pContext: [*:0]u8,
                cbContext: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetHostSecurityManager,
                guidKey: ?*const Guid,
                ppPolicy: ?[*]?*u8,
                pcbPolicy: ?*u32,
                pContext: [*:0]u8,
                cbContext: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetHostSecurityManager_GetSecurityId(self: *const T, pbSecurityId: [*:0]u8, pcbSecurityId: ?*u32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetHostSecurityManager.VTable, self.vtable).GetSecurityId(@ptrCast(*const IInternetHostSecurityManager, self), pbSecurityId, pcbSecurityId, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetHostSecurityManager_ProcessUrlAction(self: *const T, dwAction: u32, pPolicy: ?*u8, cbPolicy: u32, pContext: ?[*:0]u8, cbContext: u32, dwFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetHostSecurityManager.VTable, self.vtable).ProcessUrlAction(@ptrCast(*const IInternetHostSecurityManager, self), dwAction, pPolicy, cbPolicy, pContext, cbContext, dwFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetHostSecurityManager_QueryCustomPolicy(self: *const T, guidKey: ?*const Guid, ppPolicy: ?[*]?*u8, pcbPolicy: ?*u32, pContext: [*:0]u8, cbContext: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetHostSecurityManager.VTable, self.vtable).QueryCustomPolicy(@ptrCast(*const IInternetHostSecurityManager, self), guidKey, ppPolicy, pcbPolicy, pContext, cbContext, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const URLZONE = enum(i32) {
    INVALID = -1,
    PREDEFINED_MIN = 0,
    // LOCAL_MACHINE = 0, this enum value conflicts with PREDEFINED_MIN
    INTRANET = 1,
    TRUSTED = 2,
    INTERNET = 3,
    UNTRUSTED = 4,
    PREDEFINED_MAX = 999,
    USER_MIN = 1000,
    USER_MAX = 10000,
};
pub const URLZONE_INVALID = URLZONE.INVALID;
pub const URLZONE_PREDEFINED_MIN = URLZONE.PREDEFINED_MIN;
pub const URLZONE_LOCAL_MACHINE = URLZONE.PREDEFINED_MIN;
pub const URLZONE_INTRANET = URLZONE.INTRANET;
pub const URLZONE_TRUSTED = URLZONE.TRUSTED;
pub const URLZONE_INTERNET = URLZONE.INTERNET;
pub const URLZONE_UNTRUSTED = URLZONE.UNTRUSTED;
pub const URLZONE_PREDEFINED_MAX = URLZONE.PREDEFINED_MAX;
pub const URLZONE_USER_MIN = URLZONE.USER_MIN;
pub const URLZONE_USER_MAX = URLZONE.USER_MAX;

pub const URLTEMPLATE = enum(i32) {
    CUSTOM = 0,
    PREDEFINED_MIN = 65536,
    // LOW = 65536, this enum value conflicts with PREDEFINED_MIN
    MEDLOW = 66816,
    MEDIUM = 69632,
    MEDHIGH = 70912,
    HIGH = 73728,
    PREDEFINED_MAX = 131072,
};
pub const URLTEMPLATE_CUSTOM = URLTEMPLATE.CUSTOM;
pub const URLTEMPLATE_PREDEFINED_MIN = URLTEMPLATE.PREDEFINED_MIN;
pub const URLTEMPLATE_LOW = URLTEMPLATE.PREDEFINED_MIN;
pub const URLTEMPLATE_MEDLOW = URLTEMPLATE.MEDLOW;
pub const URLTEMPLATE_MEDIUM = URLTEMPLATE.MEDIUM;
pub const URLTEMPLATE_MEDHIGH = URLTEMPLATE.MEDHIGH;
pub const URLTEMPLATE_HIGH = URLTEMPLATE.HIGH;
pub const URLTEMPLATE_PREDEFINED_MAX = URLTEMPLATE.PREDEFINED_MAX;

pub const INET_ZONE_MANAGER_CONSTANTS = enum(i32) {
    PATH = 260,
    DESCRIPTION = 200,
};
pub const MAX_ZONE_PATH = INET_ZONE_MANAGER_CONSTANTS.PATH;
pub const MAX_ZONE_DESCRIPTION = INET_ZONE_MANAGER_CONSTANTS.DESCRIPTION;

pub const ZAFLAGS = enum(i32) {
    CUSTOM_EDIT = 1,
    ADD_SITES = 2,
    REQUIRE_VERIFICATION = 4,
    INCLUDE_PROXY_OVERRIDE = 8,
    INCLUDE_INTRANET_SITES = 16,
    NO_UI = 32,
    SUPPORTS_VERIFICATION = 64,
    UNC_AS_INTRANET = 128,
    DETECT_INTRANET = 256,
    USE_LOCKED_ZONES = 65536,
    VERIFY_TEMPLATE_SETTINGS = 131072,
    NO_CACHE = 262144,
};
pub const ZAFLAGS_CUSTOM_EDIT = ZAFLAGS.CUSTOM_EDIT;
pub const ZAFLAGS_ADD_SITES = ZAFLAGS.ADD_SITES;
pub const ZAFLAGS_REQUIRE_VERIFICATION = ZAFLAGS.REQUIRE_VERIFICATION;
pub const ZAFLAGS_INCLUDE_PROXY_OVERRIDE = ZAFLAGS.INCLUDE_PROXY_OVERRIDE;
pub const ZAFLAGS_INCLUDE_INTRANET_SITES = ZAFLAGS.INCLUDE_INTRANET_SITES;
pub const ZAFLAGS_NO_UI = ZAFLAGS.NO_UI;
pub const ZAFLAGS_SUPPORTS_VERIFICATION = ZAFLAGS.SUPPORTS_VERIFICATION;
pub const ZAFLAGS_UNC_AS_INTRANET = ZAFLAGS.UNC_AS_INTRANET;
pub const ZAFLAGS_DETECT_INTRANET = ZAFLAGS.DETECT_INTRANET;
pub const ZAFLAGS_USE_LOCKED_ZONES = ZAFLAGS.USE_LOCKED_ZONES;
pub const ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = ZAFLAGS.VERIFY_TEMPLATE_SETTINGS;
pub const ZAFLAGS_NO_CACHE = ZAFLAGS.NO_CACHE;

pub const ZONEATTRIBUTES = extern struct {
    cbSize: u32,
    szDisplayName: [260]u16,
    szDescription: [200]u16,
    szIconPath: [260]u16,
    dwTemplateMinLevel: u32,
    dwTemplateRecommended: u32,
    dwTemplateCurrentLevel: u32,
    dwFlags: u32,
};

pub const URLZONEREG = enum(i32) {
    DEFAULT = 0,
    HKLM = 1,
    HKCU = 2,
};
pub const URLZONEREG_DEFAULT = URLZONEREG.DEFAULT;
pub const URLZONEREG_HKLM = URLZONEREG.HKLM;
pub const URLZONEREG_HKCU = URLZONEREG.HKCU;

const IID_IInternetZoneManager_Value = Guid.initString("79eac9ef-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IInternetZoneManager = &IID_IInternetZoneManager_Value;
pub const IInternetZoneManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetZoneAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                pZoneAttributes: ?*ZONEATTRIBUTES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                pZoneAttributes: ?*ZONEATTRIBUTES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZoneAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                pZoneAttributes: ?*ZONEATTRIBUTES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                pZoneAttributes: ?*ZONEATTRIBUTES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZoneCustomPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                guidKey: ?*const Guid,
                ppPolicy: ?*?*u8,
                pcbPolicy: ?*u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                guidKey: ?*const Guid,
                ppPolicy: ?*?*u8,
                pcbPolicy: ?*u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZoneCustomPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                guidKey: ?*const Guid,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                guidKey: ?*const Guid,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZoneActionPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZoneActionPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PromptAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwAction: u32,
                hwndParent: ?HWND,
                pwszUrl: ?[*:0]const u16,
                pwszText: ?[*:0]const u16,
                dwPromptFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwAction: u32,
                hwndParent: ?HWND,
                pwszUrl: ?[*:0]const u16,
                pwszText: ?[*:0]const u16,
                dwPromptFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LogAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwAction: u32,
                pwszUrl: ?[*:0]const u16,
                pwszText: ?[*:0]const u16,
                dwLogFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwAction: u32,
                pwszUrl: ?[*:0]const u16,
                pwszText: ?[*:0]const u16,
                dwLogFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateZoneEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                pdwEnum: ?*u32,
                pdwCount: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                pdwEnum: ?*u32,
                pdwCount: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZoneAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwEnum: u32,
                dwIndex: u32,
                pdwZone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwEnum: u32,
                dwIndex: u32,
                pdwZone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyZoneEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwEnum: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwEnum: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyTemplatePoliciesToZone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManager,
                dwTemplate: u32,
                dwZone: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManager,
                dwTemplate: u32,
                dwZone: u32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneAttributes(self: *const T, dwZone: u32, pZoneAttributes: ?*ZONEATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneAttributes(@ptrCast(*const IInternetZoneManager, self), dwZone, pZoneAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_SetZoneAttributes(self: *const T, dwZone: u32, pZoneAttributes: ?*ZONEATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).SetZoneAttributes(@ptrCast(*const IInternetZoneManager, self), dwZone, pZoneAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneCustomPolicy(self: *const T, dwZone: u32, guidKey: ?*const Guid, ppPolicy: ?*?*u8, pcbPolicy: ?*u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneCustomPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, guidKey, ppPolicy, pcbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_SetZoneCustomPolicy(self: *const T, dwZone: u32, guidKey: ?*const Guid, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).SetZoneCustomPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, guidKey, pPolicy, cbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneActionPolicy(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneActionPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_SetZoneActionPolicy(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).SetZoneActionPolicy(@ptrCast(*const IInternetZoneManager, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_PromptAction(self: *const T, dwAction: u32, hwndParent: ?HWND, pwszUrl: ?[*:0]const u16, pwszText: ?[*:0]const u16, dwPromptFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).PromptAction(@ptrCast(*const IInternetZoneManager, self), dwAction, hwndParent, pwszUrl, pwszText, dwPromptFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_LogAction(self: *const T, dwAction: u32, pwszUrl: ?[*:0]const u16, pwszText: ?[*:0]const u16, dwLogFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).LogAction(@ptrCast(*const IInternetZoneManager, self), dwAction, pwszUrl, pwszText, dwLogFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_CreateZoneEnumerator(self: *const T, pdwEnum: ?*u32, pdwCount: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).CreateZoneEnumerator(@ptrCast(*const IInternetZoneManager, self), pdwEnum, pdwCount, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_GetZoneAt(self: *const T, dwEnum: u32, dwIndex: u32, pdwZone: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).GetZoneAt(@ptrCast(*const IInternetZoneManager, self), dwEnum, dwIndex, pdwZone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_DestroyZoneEnumerator(self: *const T, dwEnum: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).DestroyZoneEnumerator(@ptrCast(*const IInternetZoneManager, self), dwEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManager_CopyTemplatePoliciesToZone(self: *const T, dwTemplate: u32, dwZone: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManager.VTable, self.vtable).CopyTemplatePoliciesToZone(@ptrCast(*const IInternetZoneManager, self), dwTemplate, dwZone, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetZoneManagerEx_Value = Guid.initString("a4c23339-8e06-431e-9bf4-7e711c085648");
pub const IID_IInternetZoneManagerEx = &IID_IInternetZoneManagerEx_Value;
pub const IInternetZoneManagerEx = extern struct {
    pub const VTable = extern struct {
        base: IInternetZoneManager.VTable,
        GetZoneActionPolicyEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManagerEx,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManagerEx,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZoneActionPolicyEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManagerEx,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManagerEx,
                dwZone: u32,
                dwAction: u32,
                pPolicy: [*:0]u8,
                cbPolicy: u32,
                urlZoneReg: URLZONEREG,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetZoneManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx_GetZoneActionPolicyEx(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx.VTable, self.vtable).GetZoneActionPolicyEx(@ptrCast(*const IInternetZoneManagerEx, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx_SetZoneActionPolicyEx(self: *const T, dwZone: u32, dwAction: u32, pPolicy: [*:0]u8, cbPolicy: u32, urlZoneReg: URLZONEREG, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx.VTable, self.vtable).SetZoneActionPolicyEx(@ptrCast(*const IInternetZoneManagerEx, self), dwZone, dwAction, pPolicy, cbPolicy, urlZoneReg, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetZoneManagerEx2_Value = Guid.initString("edc17559-dd5d-4846-8eef-8becba5a4abf");
pub const IID_IInternetZoneManagerEx2 = &IID_IInternetZoneManagerEx2_Value;
pub const IInternetZoneManagerEx2 = extern struct {
    pub const VTable = extern struct {
        base: IInternetZoneManagerEx.VTable,
        GetZoneAttributesEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManagerEx2,
                dwZone: u32,
                pZoneAttributes: ?*ZONEATTRIBUTES,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManagerEx2,
                dwZone: u32,
                pZoneAttributes: ?*ZONEATTRIBUTES,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZoneSecurityState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManagerEx2,
                dwZoneIndex: u32,
                fRespectPolicy: BOOL,
                pdwState: ?*u32,
                pfPolicyEncountered: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManagerEx2,
                dwZoneIndex: u32,
                fRespectPolicy: BOOL,
                pdwState: ?*u32,
                pfPolicyEncountered: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIESecurityState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManagerEx2,
                fRespectPolicy: BOOL,
                pdwState: ?*u32,
                pfPolicyEncountered: ?*BOOL,
                fNoCache: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManagerEx2,
                fRespectPolicy: BOOL,
                pdwState: ?*u32,
                pfPolicyEncountered: ?*BOOL,
                fNoCache: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FixUnsecureSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetZoneManagerEx2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetZoneManagerEx2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IInternetZoneManagerEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_GetZoneAttributesEx(self: *const T, dwZone: u32, pZoneAttributes: ?*ZONEATTRIBUTES, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).GetZoneAttributesEx(@ptrCast(*const IInternetZoneManagerEx2, self), dwZone, pZoneAttributes, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_GetZoneSecurityState(self: *const T, dwZoneIndex: u32, fRespectPolicy: BOOL, pdwState: ?*u32, pfPolicyEncountered: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).GetZoneSecurityState(@ptrCast(*const IInternetZoneManagerEx2, self), dwZoneIndex, fRespectPolicy, pdwState, pfPolicyEncountered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_GetIESecurityState(self: *const T, fRespectPolicy: BOOL, pdwState: ?*u32, pfPolicyEncountered: ?*BOOL, fNoCache: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).GetIESecurityState(@ptrCast(*const IInternetZoneManagerEx2, self), fRespectPolicy, pdwState, pfPolicyEncountered, fNoCache);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetZoneManagerEx2_FixUnsecureSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternetZoneManagerEx2.VTable, self.vtable).FixUnsecureSettings(@ptrCast(*const IInternetZoneManagerEx2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CODEBASEHOLD = extern struct {
    cbSize: u32,
    szDistUnit: ?PWSTR,
    szCodeBase: ?PWSTR,
    dwVersionMS: u32,
    dwVersionLS: u32,
    dwStyle: u32,
};

pub const SOFTDISTINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwAdState: u32,
    szTitle: ?PWSTR,
    szAbstract: ?PWSTR,
    szHREF: ?PWSTR,
    dwInstalledVersionMS: u32,
    dwInstalledVersionLS: u32,
    dwUpdateVersionMS: u32,
    dwUpdateVersionLS: u32,
    dwAdvertisedVersionMS: u32,
    dwAdvertisedVersionLS: u32,
    dwReserved: u32,
};

const IID_ISoftDistExt_Value = Guid.initString("b15b8dc1-c7e1-11d0-8680-00aa00bdcb71");
pub const IID_ISoftDistExt = &IID_ISoftDistExt_Value;
pub const ISoftDistExt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProcessSoftDist: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISoftDistExt,
                szCDFURL: ?[*:0]const u16,
                pSoftDistElement: ?*IXMLElement,
                lpsdi: ?*SOFTDISTINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISoftDistExt,
                szCDFURL: ?[*:0]const u16,
                pSoftDistElement: ?*IXMLElement,
                lpsdi: ?*SOFTDISTINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFirstCodeBase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISoftDistExt,
                szCodeBase: ?*?PWSTR,
                dwMaxSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISoftDistExt,
                szCodeBase: ?*?PWSTR,
                dwMaxSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextCodeBase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISoftDistExt,
                szCodeBase: ?*?PWSTR,
                dwMaxSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISoftDistExt,
                szCodeBase: ?*?PWSTR,
                dwMaxSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsyncInstallDistributionUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISoftDistExt,
                pbc: ?*IBindCtx,
                pvReserved: ?*anyopaque,
                flags: u32,
                lpcbh: ?*CODEBASEHOLD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISoftDistExt,
                pbc: ?*IBindCtx,
                pvReserved: ?*anyopaque,
                flags: u32,
                lpcbh: ?*CODEBASEHOLD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_ProcessSoftDist(self: *const T, szCDFURL: ?[*:0]const u16, pSoftDistElement: ?*IXMLElement, lpsdi: ?*SOFTDISTINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).ProcessSoftDist(@ptrCast(*const ISoftDistExt, self), szCDFURL, pSoftDistElement, lpsdi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_GetFirstCodeBase(self: *const T, szCodeBase: ?*?PWSTR, dwMaxSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).GetFirstCodeBase(@ptrCast(*const ISoftDistExt, self), szCodeBase, dwMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_GetNextCodeBase(self: *const T, szCodeBase: ?*?PWSTR, dwMaxSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).GetNextCodeBase(@ptrCast(*const ISoftDistExt, self), szCodeBase, dwMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISoftDistExt_AsyncInstallDistributionUnit(self: *const T, pbc: ?*IBindCtx, pvReserved: ?*anyopaque, flags: u32, lpcbh: ?*CODEBASEHOLD) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISoftDistExt.VTable, self.vtable).AsyncInstallDistributionUnit(@ptrCast(*const ISoftDistExt, self), pbc, pvReserved, flags, lpcbh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICatalogFileInfo_Value = Guid.initString("711c7600-6b48-11d1-b403-00aa00b92af1");
pub const IID_ICatalogFileInfo = &IID_ICatalogFileInfo_Value;
pub const ICatalogFileInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCatalogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICatalogFileInfo,
                ppszCatalogFile: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICatalogFileInfo,
                ppszCatalogFile: ?*?PSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetJavaTrust: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICatalogFileInfo,
                ppJavaTrust: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICatalogFileInfo,
                ppJavaTrust: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatalogFileInfo_GetCatalogFile(self: *const T, ppszCatalogFile: ?*?PSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatalogFileInfo.VTable, self.vtable).GetCatalogFile(@ptrCast(*const ICatalogFileInfo, self), ppszCatalogFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatalogFileInfo_GetJavaTrust(self: *const T, ppJavaTrust: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICatalogFileInfo.VTable, self.vtable).GetJavaTrust(@ptrCast(*const ICatalogFileInfo, self), ppJavaTrust);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataFilter_Value = Guid.initString("69d14c80-c18e-11d0-a9ce-006097942311");
pub const IID_IDataFilter = &IID_IDataFilter_Value;
pub const IDataFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoEncode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataFilter,
                dwFlags: u32,
                lInBufferSize: i32,
                pbInBuffer: [*:0]u8,
                lOutBufferSize: i32,
                pbOutBuffer: [*:0]u8,
                lInBytesAvailable: i32,
                plInBytesRead: ?*i32,
                plOutBytesWritten: ?*i32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataFilter,
                dwFlags: u32,
                lInBufferSize: i32,
                pbInBuffer: [*:0]u8,
                lOutBufferSize: i32,
                pbOutBuffer: [*:0]u8,
                lInBytesAvailable: i32,
                plInBytesRead: ?*i32,
                plOutBytesWritten: ?*i32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoDecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataFilter,
                dwFlags: u32,
                lInBufferSize: i32,
                pbInBuffer: [*:0]u8,
                lOutBufferSize: i32,
                pbOutBuffer: [*:0]u8,
                lInBytesAvailable: i32,
                plInBytesRead: ?*i32,
                plOutBytesWritten: ?*i32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataFilter,
                dwFlags: u32,
                lInBufferSize: i32,
                pbInBuffer: [*:0]u8,
                lOutBufferSize: i32,
                pbOutBuffer: [*:0]u8,
                lInBytesAvailable: i32,
                plInBytesRead: ?*i32,
                plOutBytesWritten: ?*i32,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEncodingLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataFilter,
                dwEncLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataFilter,
                dwEncLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataFilter_DoEncode(self: *const T, dwFlags: u32, lInBufferSize: i32, pbInBuffer: [*:0]u8, lOutBufferSize: i32, pbOutBuffer: [*:0]u8, lInBytesAvailable: i32, plInBytesRead: ?*i32, plOutBytesWritten: ?*i32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataFilter.VTable, self.vtable).DoEncode(@ptrCast(*const IDataFilter, self), dwFlags, lInBufferSize, pbInBuffer, lOutBufferSize, pbOutBuffer, lInBytesAvailable, plInBytesRead, plOutBytesWritten, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataFilter_DoDecode(self: *const T, dwFlags: u32, lInBufferSize: i32, pbInBuffer: [*:0]u8, lOutBufferSize: i32, pbOutBuffer: [*:0]u8, lInBytesAvailable: i32, plInBytesRead: ?*i32, plOutBytesWritten: ?*i32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataFilter.VTable, self.vtable).DoDecode(@ptrCast(*const IDataFilter, self), dwFlags, lInBufferSize, pbInBuffer, lOutBufferSize, pbOutBuffer, lInBytesAvailable, plInBytesRead, plOutBytesWritten, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataFilter_SetEncodingLevel(self: *const T, dwEncLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataFilter.VTable, self.vtable).SetEncodingLevel(@ptrCast(*const IDataFilter, self), dwEncLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROTOCOLFILTERDATA = extern struct {
    cbSize: u32,
    pProtocolSink: ?*IInternetProtocolSink,
    pProtocol: ?*IInternetProtocol,
    pUnk: ?*IUnknown,
    dwFilterFlags: u32,
};

pub const DATAINFO = extern struct {
    ulTotalSize: u32,
    ulavrPacketSize: u32,
    ulConnectSpeed: u32,
    ulProcessorSpeed: u32,
};

const IID_IEncodingFilterFactory_Value = Guid.initString("70bdde00-c18e-11d0-a9ce-006097942311");
pub const IID_IEncodingFilterFactory = &IID_IEncodingFilterFactory_Value;
pub const IEncodingFilterFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindBestFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncodingFilterFactory,
                pwzCodeIn: ?[*:0]const u16,
                pwzCodeOut: ?[*:0]const u16,
                info: DATAINFO,
                ppDF: ?*?*IDataFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncodingFilterFactory,
                pwzCodeIn: ?[*:0]const u16,
                pwzCodeOut: ?[*:0]const u16,
                info: DATAINFO,
                ppDF: ?*?*IDataFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncodingFilterFactory,
                pwzCodeIn: ?[*:0]const u16,
                pwzCodeOut: ?[*:0]const u16,
                ppDF: ?*?*IDataFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncodingFilterFactory,
                pwzCodeIn: ?[*:0]const u16,
                pwzCodeOut: ?[*:0]const u16,
                ppDF: ?*?*IDataFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncodingFilterFactory_FindBestFilter(self: *const T, pwzCodeIn: ?[*:0]const u16, pwzCodeOut: ?[*:0]const u16, info: DATAINFO, ppDF: ?*?*IDataFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncodingFilterFactory.VTable, self.vtable).FindBestFilter(@ptrCast(*const IEncodingFilterFactory, self), pwzCodeIn, pwzCodeOut, info, ppDF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncodingFilterFactory_GetDefaultFilter(self: *const T, pwzCodeIn: ?[*:0]const u16, pwzCodeOut: ?[*:0]const u16, ppDF: ?*?*IDataFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEncodingFilterFactory.VTable, self.vtable).GetDefaultFilter(@ptrCast(*const IEncodingFilterFactory, self), pwzCodeIn, pwzCodeOut, ppDF);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HIT_LOGGING_INFO = extern struct {
    dwStructSize: u32,
    lpszLoggedUrlName: ?PSTR,
    StartTime: SYSTEMTIME,
    EndTime: SYSTEMTIME,
    lpszExtendedInfo: ?PSTR,
};

pub const CONFIRMSAFETY = extern struct {
    clsid: Guid,
    pUnk: ?*IUnknown,
    dwFlags: u32,
};

const IID_IWrappedProtocol_Value = Guid.initString("53c84785-8425-4dc5-971b-e58d9c19f9b6");
pub const IID_IWrappedProtocol = &IID_IWrappedProtocol_Value;
pub const IWrappedProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWrapperCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWrappedProtocol,
                pnCode: ?*i32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWrappedProtocol,
                pnCode: ?*i32,
                dwReserved: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWrappedProtocol_GetWrapperCode(self: *const T, pnCode: ?*i32, dwReserved: usize) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWrappedProtocol.VTable, self.vtable).GetWrapperCode(@ptrCast(*const IWrappedProtocol, self), pnCode, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BINDHANDLETYPES = enum(i32) {
    APPCACHE = 0,
    DEPENDENCY = 1,
    COUNT = 2,
};
pub const BINDHANDLETYPES_APPCACHE = BINDHANDLETYPES.APPCACHE;
pub const BINDHANDLETYPES_DEPENDENCY = BINDHANDLETYPES.DEPENDENCY;
pub const BINDHANDLETYPES_COUNT = BINDHANDLETYPES.COUNT;

const IID_IGetBindHandle_Value = Guid.initString("af0ff408-129d-4b20-91f0-02bd23d88352");
pub const IID_IGetBindHandle = &IID_IGetBindHandle_Value;
pub const IGetBindHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBindHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGetBindHandle,
                enumRequestedHandle: BINDHANDLETYPES,
                pRetHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGetBindHandle,
                enumRequestedHandle: BINDHANDLETYPES,
                pRetHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetBindHandle_GetBindHandle(self: *const T, enumRequestedHandle: BINDHANDLETYPES, pRetHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetBindHandle.VTable, self.vtable).GetBindHandle(@ptrCast(*const IGetBindHandle, self), enumRequestedHandle, pRetHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROTOCOL_ARGUMENT = extern struct {
    szMethod: ?[*:0]const u16,
    szTargetUrl: ?[*:0]const u16,
};

const IID_IBindCallbackRedirect_Value = Guid.initString("11c81bc2-121e-4ed5-b9c4-b430bd54f2c0");
pub const IID_IBindCallbackRedirect = &IID_IBindCallbackRedirect_Value;
pub const IBindCallbackRedirect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Redirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBindCallbackRedirect,
                lpcUrl: ?[*:0]const u16,
                vbCancel: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBindCallbackRedirect,
                lpcUrl: ?[*:0]const u16,
                vbCancel: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindCallbackRedirect_Redirect(self: *const T, lpcUrl: ?[*:0]const u16, vbCancel: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindCallbackRedirect.VTable, self.vtable).Redirect(@ptrCast(*const IBindCallbackRedirect, self), lpcUrl, vbCancel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindHttpSecurity_Value = Guid.initString("a9eda967-f50e-4a33-b358-206f6ef3086d");
pub const IID_IBindHttpSecurity = &IID_IBindHttpSecurity_Value;
pub const IBindHttpSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIgnoreCertMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBindHttpSecurity,
                pdwIgnoreCertMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBindHttpSecurity,
                pdwIgnoreCertMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindHttpSecurity_GetIgnoreCertMask(self: *const T, pdwIgnoreCertMask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindHttpSecurity.VTable, self.vtable).GetIgnoreCertMask(@ptrCast(*const IBindHttpSecurity, self), pdwIgnoreCertMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (73)
//--------------------------------------------------------------------------------
pub extern "urlmon" fn CreateURLMoniker(
    pMkCtx: ?*IMoniker,
    szURL: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateURLMonikerEx(
    pMkCtx: ?*IMoniker,
    szURL: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetClassURL(
    szURL: ?[*:0]const u16,
    pClsID: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "urlmon" fn CreateAsyncBindCtx(
    reserved: u32,
    pBSCb: ?*IBindStatusCallback,
    pEFetc: ?*IEnumFORMATETC,
    ppBC: ?*?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateURLMonikerEx2(
    pMkCtx: ?*IMoniker,
    pUri: ?*IUri,
    ppmk: ?*?*IMoniker,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateAsyncBindCtxEx(
    pbc: ?*IBindCtx,
    dwOptions: u32,
    pBSCb: ?*IBindStatusCallback,
    pEnum: ?*IEnumFORMATETC,
    ppBC: ?*?*IBindCtx,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn MkParseDisplayNameEx(
    pbc: ?*IBindCtx,
    szDisplayName: ?[*:0]const u16,
    pchEaten: ?*u32,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterBindStatusCallback(
    pBC: ?*IBindCtx,
    pBSCb: ?*IBindStatusCallback,
    ppBSCBPrev: ?*?*IBindStatusCallback,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RevokeBindStatusCallback(
    pBC: ?*IBindCtx,
    pBSCb: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetClassFileOrMime(
    pBC: ?*IBindCtx,
    szFilename: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    cbSize: u32,
    szMime: ?[*:0]const u16,
    dwReserved: u32,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IsValidURL(
    pBC: ?*IBindCtx,
    szURL: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoGetClassObjectFromURL(
    rCLASSID: ?*const Guid,
    szCODE: ?[*:0]const u16,
    dwFileVersionMS: u32,
    dwFileVersionLS: u32,
    szTYPE: ?[*:0]const u16,
    pBindCtx: ?*IBindCtx,
    dwClsContext: CLSCTX,
    pvReserved: ?*anyopaque,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IEInstallScope(
    pdwScope: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FaultInIEFeature(
    hWnd: ?HWND,
    pClassSpec: ?*uCLSSPEC,
    pQuery: ?*QUERYCONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetComponentIDFromCLSSPEC(
    pClassspec: ?*uCLSSPEC,
    ppszComponentID: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IsAsyncMoniker(
    pmk: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterMediaTypes(
    ctypes: u32,
    rgszTypes: [*]const ?[*:0]const u8,
    rgcfTypes: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FindMediaType(
    rgszTypes: ?[*:0]const u8,
    rgcfTypes: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "urlmon" fn CreateFormatEnumerator(
    cfmtetc: u32,
    rgfmtetc: [*]FORMATETC,
    ppenumfmtetc: ?*?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterFormatEnumerator(
    pBC: ?*IBindCtx,
    pEFetc: ?*IEnumFORMATETC,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RevokeFormatEnumerator(
    pBC: ?*IBindCtx,
    pEFetc: ?*IEnumFORMATETC,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn RegisterMediaTypeClass(
    pBC: ?*IBindCtx,
    ctypes: u32,
    rgszTypes: [*]const ?[*:0]const u8,
    rgclsID: [*]Guid,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FindMediaTypeClass(
    pBC: ?*IBindCtx,
    szType: ?[*:0]const u8,
    pclsID: ?*Guid,
    reserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn UrlMkSetSessionOption(
    dwOption: u32,
    // TODO: what to do with BytesParamIndex 2?
    pBuffer: ?*anyopaque,
    dwBufferLength: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn UrlMkGetSessionOption(
    dwOption: u32,
    // TODO: what to do with BytesParamIndex 2?
    pBuffer: ?*anyopaque,
    dwBufferLength: u32,
    pdwBufferLengthOut: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn FindMimeFromData(
    pBC: ?*IBindCtx,
    pwzUrl: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    cbSize: u32,
    pwzMimeProposed: ?[*:0]const u16,
    dwMimeFlags: u32,
    ppwzMimeOut: ?*?PWSTR,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn ObtainUserAgentString(
    dwOption: u32,
    pszUAOut: [*:0]u8,
    cbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CompareSecurityIds(
    pbSecurityId1: [*:0]u8,
    dwLen1: u32,
    pbSecurityId2: [*:0]u8,
    dwLen2: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CompatFlagsFromClsid(
    pclsid: ?*Guid,
    pdwCompatFlags: ?*u32,
    pdwMiscStatusFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn SetAccessForIEAppContainer(
    hObject: ?HANDLE,
    ieObjectType: IEObjectType,
    dwAccessMask: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkSimpleNavigateToString(
    szTarget: ?[*:0]const u16,
    szLocation: ?[*:0]const u16,
    szTargetFrameName: ?[*:0]const u16,
    pUnk: ?*IUnknown,
    pbc: ?*IBindCtx,
    param5: ?*IBindStatusCallback,
    grfHLNF: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkSimpleNavigateToMoniker(
    pmkTarget: ?*IMoniker,
    szLocation: ?[*:0]const u16,
    szTargetFrameName: ?[*:0]const u16,
    pUnk: ?*IUnknown,
    pbc: ?*IBindCtx,
    param5: ?*IBindStatusCallback,
    grfHLNF: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenStreamA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenStreamW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenPullStreamA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenPullStreamW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToFileA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToFileW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToCacheFileA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: [*:0]u8,
    cchFileName: u32,
    param4: u32,
    param5: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLDownloadToCacheFileW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: [*:0]u16,
    cchFileName: u32,
    param4: u32,
    param5: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenBlockingStreamA(
    param0: ?*IUnknown,
    param1: ?[*:0]const u8,
    param2: ?*?*IStream,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn URLOpenBlockingStreamW(
    param0: ?*IUnknown,
    param1: ?[*:0]const u16,
    param2: ?*?*IStream,
    param3: u32,
    param4: ?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkGoBack(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkGoForward(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkNavigateString(
    pUnk: ?*IUnknown,
    szTarget: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn HlinkNavigateMoniker(
    pUnk: ?*IUnknown,
    pmkTarget: ?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetParseUrl(
    pwzUrl: ?[*:0]const u16,
    ParseAction: PARSEACTION,
    dwFlags: u32,
    pszResult: [*:0]u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetParseIUri(
    pIUri: ?*IUri,
    ParseAction: PARSEACTION,
    dwFlags: u32,
    pwzResult: [*:0]u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCombineUrl(
    pwzBaseUrl: ?[*:0]const u16,
    pwzRelativeUrl: ?[*:0]const u16,
    dwCombineFlags: u32,
    pszResult: [*:0]u16,
    cchResult: u32,
    pcchResult: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCombineUrlEx(
    pBaseUri: ?*IUri,
    pwzRelativeUrl: ?[*:0]const u16,
    dwCombineFlags: u32,
    ppCombinedUri: ?*?*IUri,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCombineIUri(
    pBaseUri: ?*IUri,
    pRelativeUri: ?*IUri,
    dwCombineFlags: u32,
    ppCombinedUri: ?*?*IUri,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCompareUrl(
    pwzUrl1: ?[*:0]const u16,
    pwzUrl2: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetProtocolFlags(
    pwzUrl: ?[*:0]const u16,
    pdwFlags: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetQueryInfo(
    pwzUrl: ?[*:0]const u16,
    QueryOptions: QUERYOPTION,
    dwQueryFlags: u32,
    // TODO: what to do with BytesParamIndex 4?
    pvBuffer: ?*anyopaque,
    cbBuffer: u32,
    pcbBuffer: ?*u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetSession(
    dwSessionMode: u32,
    ppIInternetSession: ?*?*IInternetSession,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetSecurityUrl(
    pwszUrl: ?[*:0]const u16,
    ppwszSecUrl: ?*?PWSTR,
    psuAction: PSUACTION,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetGetSecurityUrlEx(
    pUri: ?*IUri,
    ppSecUri: ?*?*IUri,
    psuAction: PSUACTION,
    dwReserved: usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetSetFeatureEnabled(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureEnabled(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureEnabledForUrl(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    szURL: ?[*:0]const u16,
    pSecMgr: ?*IInternetSecurityManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureEnabledForIUri(
    FeatureEntry: INTERNETFEATURELIST,
    dwFlags: u32,
    pIUri: ?*IUri,
    pSecMgr: ?*IInternetSecurityManagerEx2,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetIsFeatureZoneElevationEnabled(
    szFromURL: ?[*:0]const u16,
    szToURL: ?[*:0]const u16,
    pSecMgr: ?*IInternetSecurityManager,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CopyStgMedium(
    pcstgmedSrc: ?*const STGMEDIUM,
    pstgmedDest: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CopyBindInfo(
    pcbiSrc: ?*const BINDINFO,
    pbiDest: ?*BINDINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn ReleaseBindInfo(
    pbindinfo: ?*BINDINFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "urlmon" fn IEGetUserPrivateNamespaceName(
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "urlmon" fn CoInternetCreateSecurityManager(
    pSP: ?*IServiceProvider,
    ppSM: ?*?*IInternetSecurityManager,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CoInternetCreateZoneManager(
    pSP: ?*IServiceProvider,
    ppZM: ?*?*IInternetZoneManager,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn GetSoftwareUpdateInfo(
    szDistUnit: ?[*:0]const u16,
    psdi: ?*SOFTDISTINFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn SetSoftwareUpdateAdvertisementState(
    szDistUnit: ?[*:0]const u16,
    dwAdState: u32,
    dwAdvertisedVersionMS: u32,
    dwAdvertisedVersionLS: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn IsLoggingEnabledA(
    pszUrl: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "urlmon" fn IsLoggingEnabledW(
    pwszUrl: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "urlmon" fn WriteHitLogging(
    lpLogginginfo: ?*HIT_LOGGING_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (6)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const URLOpenStream = thismodule.URLOpenStreamA;
        pub const URLOpenPullStream = thismodule.URLOpenPullStreamA;
        pub const URLDownloadToFile = thismodule.URLDownloadToFileA;
        pub const URLDownloadToCacheFile = thismodule.URLDownloadToCacheFileA;
        pub const URLOpenBlockingStream = thismodule.URLOpenBlockingStreamA;
        pub const IsLoggingEnabled = thismodule.IsLoggingEnabledA;
    },
    .wide => struct {
        pub const URLOpenStream = thismodule.URLOpenStreamW;
        pub const URLOpenPullStream = thismodule.URLOpenPullStreamW;
        pub const URLDownloadToFile = thismodule.URLDownloadToFileW;
        pub const URLDownloadToCacheFile = thismodule.URLDownloadToCacheFileW;
        pub const URLOpenBlockingStream = thismodule.URLOpenBlockingStreamW;
        pub const IsLoggingEnabled = thismodule.IsLoggingEnabledW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const URLOpenStream = *opaque{};
        pub const URLOpenPullStream = *opaque{};
        pub const URLDownloadToFile = *opaque{};
        pub const URLDownloadToCacheFile = *opaque{};
        pub const URLOpenBlockingStream = *opaque{};
        pub const IsLoggingEnabled = *opaque{};
    } else struct {
        pub const URLOpenStream = @compileError("'URLOpenStream' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenPullStream = @compileError("'URLOpenPullStream' requires that UNICODE be set to true or false in the root module");
        pub const URLDownloadToFile = @compileError("'URLDownloadToFile' requires that UNICODE be set to true or false in the root module");
        pub const URLDownloadToCacheFile = @compileError("'URLDownloadToCacheFile' requires that UNICODE be set to true or false in the root module");
        pub const URLOpenBlockingStream = @compileError("'URLOpenBlockingStream' requires that UNICODE be set to true or false in the root module");
        pub const IsLoggingEnabled = @compileError("'IsLoggingEnabled' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (30)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BINDINFO = @import("../../system/com.zig").BINDINFO;
const BOOL = @import("../../foundation.zig").BOOL;
const CLSCTX = @import("../../system/com.zig").CLSCTX;
const FORMATETC = @import("../../system/com.zig").FORMATETC;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HANDLE_PTR = @import("../../foundation.zig").HANDLE_PTR;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IBindCtx = @import("../../system/com.zig").IBindCtx;
const IBinding = @import("../../system/com.zig").IBinding;
const IBindStatusCallback = @import("../../system/com.zig").IBindStatusCallback;
const IClassFactory = @import("../../system/com.zig").IClassFactory;
const IEnumFORMATETC = @import("../../system/com.zig").IEnumFORMATETC;
const IEnumString = @import("../../system/com.zig").IEnumString;
const IMoniker = @import("../../system/com.zig").IMoniker;
const IServiceProvider = @import("../../system/com.zig").IServiceProvider;
const IStream = @import("../../system/com.zig").IStream;
const IUnknown = @import("../../system/com.zig").IUnknown;
const IUri = @import("../../system/com.zig").IUri;
const IUriBuilder = @import("../../system/com.zig").IUriBuilder;
const IXMLElement = @import("../../data/xml/ms_xml.zig").IXMLElement;
const LARGE_INTEGER = @import("../../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const QUERYCONTEXT = @import("../../system/com.zig").QUERYCONTEXT;
const STGMEDIUM = @import("../../system/com.zig").STGMEDIUM;
const SYSTEMTIME = @import("../../foundation.zig").SYSTEMTIME;
const uCLSSPEC = @import("../../system/com.zig").uCLSSPEC;
const ULARGE_INTEGER = @import("../../foundation.zig").ULARGE_INTEGER;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
