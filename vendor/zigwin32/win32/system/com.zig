//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (39)
//--------------------------------------------------------------------------------
pub const MARSHALINTERFACE_MIN = @as(u32, 500);
pub const ASYNC_MODE_COMPATIBILITY = @as(i32, 1);
pub const ASYNC_MODE_DEFAULT = @as(i32, 0);
pub const STGTY_REPEAT = @as(i32, 256);
pub const STG_TOEND = @as(i32, -1);
pub const STG_LAYOUT_SEQUENTIAL = @as(i32, 0);
pub const STG_LAYOUT_INTERLEAVED = @as(i32, 1);
pub const COM_RIGHTS_EXECUTE = @as(u32, 1);
pub const COM_RIGHTS_EXECUTE_LOCAL = @as(u32, 2);
pub const COM_RIGHTS_EXECUTE_REMOTE = @as(u32, 4);
pub const COM_RIGHTS_ACTIVATE_LOCAL = @as(u32, 8);
pub const COM_RIGHTS_ACTIVATE_REMOTE = @as(u32, 16);
pub const COM_RIGHTS_RESERVED1 = @as(u32, 32);
pub const COM_RIGHTS_RESERVED2 = @as(u32, 64);
pub const CWMO_MAX_HANDLES = @as(u32, 56);
pub const ROTREGFLAGS_ALLOWANYCLIENT = @as(u32, 1);
pub const APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP = @as(u32, 1);
pub const APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND = @as(u32, 2);
pub const APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY = @as(u32, 4);
pub const APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN = @as(u32, 8);
pub const APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION = @as(u32, 16);
pub const APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY = @as(u32, 32);
pub const APPIDREGFLAGS_RESERVED1 = @as(u32, 64);
pub const APPIDREGFLAGS_RESERVED2 = @as(u32, 128);
pub const APPIDREGFLAGS_RESERVED3 = @as(u32, 256);
pub const APPIDREGFLAGS_RESERVED4 = @as(u32, 512);
pub const APPIDREGFLAGS_RESERVED5 = @as(u32, 1024);
pub const APPIDREGFLAGS_AAA_NO_IMPLICIT_ACTIVATE_AS_IU = @as(u32, 2048);
pub const APPIDREGFLAGS_RESERVED7 = @as(u32, 4096);
pub const APPIDREGFLAGS_RESERVED8 = @as(u32, 8192);
pub const APPIDREGFLAGS_RESERVED9 = @as(u32, 16384);
pub const DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES = @as(u32, 1);
pub const DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL = @as(u32, 2);
pub const DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES = @as(u32, 4);
pub const DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL = @as(u32, 8);
pub const DCOMSCM_PING_USE_MID_AUTHNSERVICE = @as(u32, 16);
pub const DCOMSCM_PING_DISALLOW_UNSECURE_CALL = @as(u32, 32);
pub const MAXLSN = @as(u64, 9223372036854775807);
pub const DMUS_ERRBASE = @as(u32, 4096);

//--------------------------------------------------------------------------------
// Section: Types (232)
//--------------------------------------------------------------------------------
// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const LPEXCEPFINO_DEFERRED_FILLIN = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const URI_CREATE_FLAGS = enum(u32) {
    ALLOW_RELATIVE = 1,
    ALLOW_IMPLICIT_WILDCARD_SCHEME = 2,
    ALLOW_IMPLICIT_FILE_SCHEME = 4,
    NOFRAG = 8,
    NO_CANONICALIZE = 16,
    CANONICALIZE = 256,
    FILE_USE_DOS_PATH = 32,
    DECODE_EXTRA_INFO = 64,
    NO_DECODE_EXTRA_INFO = 128,
    CRACK_UNKNOWN_SCHEMES = 512,
    NO_CRACK_UNKNOWN_SCHEMES = 1024,
    PRE_PROCESS_HTML_URI = 2048,
    NO_PRE_PROCESS_HTML_URI = 4096,
    IE_SETTINGS = 8192,
    NO_IE_SETTINGS = 16384,
    NO_ENCODE_FORBIDDEN_CHARACTERS = 32768,
    NORMALIZE_INTL_CHARACTERS = 65536,
    CANONICALIZE_ABSOLUTE = 131072,
    _,
    pub fn initFlags(o: struct {
        ALLOW_RELATIVE: u1 = 0,
        ALLOW_IMPLICIT_WILDCARD_SCHEME: u1 = 0,
        ALLOW_IMPLICIT_FILE_SCHEME: u1 = 0,
        NOFRAG: u1 = 0,
        NO_CANONICALIZE: u1 = 0,
        CANONICALIZE: u1 = 0,
        FILE_USE_DOS_PATH: u1 = 0,
        DECODE_EXTRA_INFO: u1 = 0,
        NO_DECODE_EXTRA_INFO: u1 = 0,
        CRACK_UNKNOWN_SCHEMES: u1 = 0,
        NO_CRACK_UNKNOWN_SCHEMES: u1 = 0,
        PRE_PROCESS_HTML_URI: u1 = 0,
        NO_PRE_PROCESS_HTML_URI: u1 = 0,
        IE_SETTINGS: u1 = 0,
        NO_IE_SETTINGS: u1 = 0,
        NO_ENCODE_FORBIDDEN_CHARACTERS: u1 = 0,
        NORMALIZE_INTL_CHARACTERS: u1 = 0,
        CANONICALIZE_ABSOLUTE: u1 = 0,
    }) URI_CREATE_FLAGS {
        return @as(URI_CREATE_FLAGS, @enumFromInt((if (o.ALLOW_RELATIVE == 1) @intFromEnum(URI_CREATE_FLAGS.ALLOW_RELATIVE) else 0) | (if (o.ALLOW_IMPLICIT_WILDCARD_SCHEME == 1) @intFromEnum(URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME) else 0) | (if (o.ALLOW_IMPLICIT_FILE_SCHEME == 1) @intFromEnum(URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME) else 0) | (if (o.NOFRAG == 1) @intFromEnum(URI_CREATE_FLAGS.NOFRAG) else 0) | (if (o.NO_CANONICALIZE == 1) @intFromEnum(URI_CREATE_FLAGS.NO_CANONICALIZE) else 0) | (if (o.CANONICALIZE == 1) @intFromEnum(URI_CREATE_FLAGS.CANONICALIZE) else 0) | (if (o.FILE_USE_DOS_PATH == 1) @intFromEnum(URI_CREATE_FLAGS.FILE_USE_DOS_PATH) else 0) | (if (o.DECODE_EXTRA_INFO == 1) @intFromEnum(URI_CREATE_FLAGS.DECODE_EXTRA_INFO) else 0) | (if (o.NO_DECODE_EXTRA_INFO == 1) @intFromEnum(URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO) else 0) | (if (o.CRACK_UNKNOWN_SCHEMES == 1) @intFromEnum(URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES) else 0) | (if (o.NO_CRACK_UNKNOWN_SCHEMES == 1) @intFromEnum(URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES) else 0) | (if (o.PRE_PROCESS_HTML_URI == 1) @intFromEnum(URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI) else 0) | (if (o.NO_PRE_PROCESS_HTML_URI == 1) @intFromEnum(URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI) else 0) | (if (o.IE_SETTINGS == 1) @intFromEnum(URI_CREATE_FLAGS.IE_SETTINGS) else 0) | (if (o.NO_IE_SETTINGS == 1) @intFromEnum(URI_CREATE_FLAGS.NO_IE_SETTINGS) else 0) | (if (o.NO_ENCODE_FORBIDDEN_CHARACTERS == 1) @intFromEnum(URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS) else 0) | (if (o.NORMALIZE_INTL_CHARACTERS == 1) @intFromEnum(URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS) else 0) | (if (o.CANONICALIZE_ABSOLUTE == 1) @intFromEnum(URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE) else 0)));
    }
};
pub const Uri_CREATE_ALLOW_RELATIVE = URI_CREATE_FLAGS.ALLOW_RELATIVE;
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_WILDCARD_SCHEME;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME = URI_CREATE_FLAGS.ALLOW_IMPLICIT_FILE_SCHEME;
pub const Uri_CREATE_NOFRAG = URI_CREATE_FLAGS.NOFRAG;
pub const Uri_CREATE_NO_CANONICALIZE = URI_CREATE_FLAGS.NO_CANONICALIZE;
pub const Uri_CREATE_CANONICALIZE = URI_CREATE_FLAGS.CANONICALIZE;
pub const Uri_CREATE_FILE_USE_DOS_PATH = URI_CREATE_FLAGS.FILE_USE_DOS_PATH;
pub const Uri_CREATE_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.DECODE_EXTRA_INFO;
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO = URI_CREATE_FLAGS.NO_DECODE_EXTRA_INFO;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES = URI_CREATE_FLAGS.NO_CRACK_UNKNOWN_SCHEMES;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI = URI_CREATE_FLAGS.NO_PRE_PROCESS_HTML_URI;
pub const Uri_CREATE_IE_SETTINGS = URI_CREATE_FLAGS.IE_SETTINGS;
pub const Uri_CREATE_NO_IE_SETTINGS = URI_CREATE_FLAGS.NO_IE_SETTINGS;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS = URI_CREATE_FLAGS.NO_ENCODE_FORBIDDEN_CHARACTERS;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS = URI_CREATE_FLAGS.NORMALIZE_INTL_CHARACTERS;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE = URI_CREATE_FLAGS.CANONICALIZE_ABSOLUTE;

pub const RPC_C_AUTHN_LEVEL = enum(u32) {
    DEFAULT = 0,
    NONE = 1,
    CONNECT = 2,
    CALL = 3,
    PKT = 4,
    PKT_INTEGRITY = 5,
    PKT_PRIVACY = 6,
};
pub const RPC_C_AUTHN_LEVEL_DEFAULT = RPC_C_AUTHN_LEVEL.DEFAULT;
pub const RPC_C_AUTHN_LEVEL_NONE = RPC_C_AUTHN_LEVEL.NONE;
pub const RPC_C_AUTHN_LEVEL_CONNECT = RPC_C_AUTHN_LEVEL.CONNECT;
pub const RPC_C_AUTHN_LEVEL_CALL = RPC_C_AUTHN_LEVEL.CALL;
pub const RPC_C_AUTHN_LEVEL_PKT = RPC_C_AUTHN_LEVEL.PKT;
pub const RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = RPC_C_AUTHN_LEVEL.PKT_INTEGRITY;
pub const RPC_C_AUTHN_LEVEL_PKT_PRIVACY = RPC_C_AUTHN_LEVEL.PKT_PRIVACY;

pub const RPC_C_IMP_LEVEL = enum(u32) {
    DEFAULT = 0,
    ANONYMOUS = 1,
    IDENTIFY = 2,
    IMPERSONATE = 3,
    DELEGATE = 4,
};
pub const RPC_C_IMP_LEVEL_DEFAULT = RPC_C_IMP_LEVEL.DEFAULT;
pub const RPC_C_IMP_LEVEL_ANONYMOUS = RPC_C_IMP_LEVEL.ANONYMOUS;
pub const RPC_C_IMP_LEVEL_IDENTIFY = RPC_C_IMP_LEVEL.IDENTIFY;
pub const RPC_C_IMP_LEVEL_IMPERSONATE = RPC_C_IMP_LEVEL.IMPERSONATE;
pub const RPC_C_IMP_LEVEL_DELEGATE = RPC_C_IMP_LEVEL.DELEGATE;

pub const CO_MTA_USAGE_COOKIE = isize;

pub const CO_DEVICE_CATALOG_COOKIE = isize;

pub const DVASPECT = enum(i32) {
    CONTENT = 1,
    THUMBNAIL = 2,
    ICON = 4,
    DOCPRINT = 8,
};
pub const DVASPECT_CONTENT = DVASPECT.CONTENT;
pub const DVASPECT_THUMBNAIL = DVASPECT.THUMBNAIL;
pub const DVASPECT_ICON = DVASPECT.ICON;
pub const DVASPECT_DOCPRINT = DVASPECT.DOCPRINT;

pub const CY = extern union {
    Anonymous: extern struct {
        Lo: u32,
        Hi: i32,
    },
    int64: i64,
};

pub const CSPLATFORM = extern struct {
    dwPlatformId: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
    dwProcessorArch: u32,
};

pub const QUERYCONTEXT = extern struct {
    dwContext: u32,
    Platform: CSPLATFORM,
    Locale: u32,
    dwVersionHi: u32,
    dwVersionLo: u32,
};

pub const TYSPEC = enum(i32) {
    CLSID = 0,
    FILEEXT = 1,
    MIMETYPE = 2,
    FILENAME = 3,
    PROGID = 4,
    PACKAGENAME = 5,
    OBJECTID = 6,
};
pub const TYSPEC_CLSID = TYSPEC.CLSID;
pub const TYSPEC_FILEEXT = TYSPEC.FILEEXT;
pub const TYSPEC_MIMETYPE = TYSPEC.MIMETYPE;
pub const TYSPEC_FILENAME = TYSPEC.FILENAME;
pub const TYSPEC_PROGID = TYSPEC.PROGID;
pub const TYSPEC_PACKAGENAME = TYSPEC.PACKAGENAME;
pub const TYSPEC_OBJECTID = TYSPEC.OBJECTID;

pub const uCLSSPEC = extern struct {
    tyspec: u32,
    tagged_union: extern struct {
        clsid: Guid,
        pFileExt: ?PWSTR,
        pMimeType: ?PWSTR,
        pProgId: ?PWSTR,
        pFileName: ?PWSTR,
        ByName: extern struct {
            pPackageName: ?PWSTR,
            PolicyId: Guid,
        },
        ByObjectId: extern struct {
            ObjectId: Guid,
            PolicyId: Guid,
        },
    },
};

pub const REGCLS = enum(i32) {
    SINGLEUSE = 0,
    MULTIPLEUSE = 1,
    MULTI_SEPARATE = 2,
    SUSPENDED = 4,
    SURROGATE = 8,
    AGILE = 16,
};
pub const REGCLS_SINGLEUSE = REGCLS.SINGLEUSE;
pub const REGCLS_MULTIPLEUSE = REGCLS.MULTIPLEUSE;
pub const REGCLS_MULTI_SEPARATE = REGCLS.MULTI_SEPARATE;
pub const REGCLS_SUSPENDED = REGCLS.SUSPENDED;
pub const REGCLS_SURROGATE = REGCLS.SURROGATE;
pub const REGCLS_AGILE = REGCLS.AGILE;

pub const COINITBASE = enum(i32) {
    D = 0,
};
pub const COINITBASE_MULTITHREADED = COINITBASE.D;

pub const COAUTHIDENTITY = extern struct {
    User: ?*u16,
    UserLength: u32,
    Domain: ?*u16,
    DomainLength: u32,
    Password: ?*u16,
    PasswordLength: u32,
    Flags: u32,
};

pub const COAUTHINFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pwszServerPrincName: ?PWSTR,
    dwAuthnLevel: u32,
    dwImpersonationLevel: u32,
    pAuthIdentityData: ?*COAUTHIDENTITY,
    dwCapabilities: u32,
};

pub const MEMCTX = enum(i32) {
    TASK = 1,
    SHARED = 2,
    MACSYSTEM = 3,
    UNKNOWN = -1,
    SAME = -2,
};
pub const MEMCTX_TASK = MEMCTX.TASK;
pub const MEMCTX_SHARED = MEMCTX.SHARED;
pub const MEMCTX_MACSYSTEM = MEMCTX.MACSYSTEM;
pub const MEMCTX_UNKNOWN = MEMCTX.UNKNOWN;
pub const MEMCTX_SAME = MEMCTX.SAME;

pub const CLSCTX = enum(u32) {
    INPROC_SERVER = 1,
    INPROC_HANDLER = 2,
    LOCAL_SERVER = 4,
    INPROC_SERVER16 = 8,
    REMOTE_SERVER = 16,
    INPROC_HANDLER16 = 32,
    RESERVED1 = 64,
    RESERVED2 = 128,
    RESERVED3 = 256,
    RESERVED4 = 512,
    NO_CODE_DOWNLOAD = 1024,
    RESERVED5 = 2048,
    NO_CUSTOM_MARSHAL = 4096,
    ENABLE_CODE_DOWNLOAD = 8192,
    NO_FAILURE_LOG = 16384,
    DISABLE_AAA = 32768,
    ENABLE_AAA = 65536,
    FROM_DEFAULT_CONTEXT = 131072,
    ACTIVATE_X86_SERVER = 262144,
    // ACTIVATE_32_BIT_SERVER = 262144, this enum value conflicts with ACTIVATE_X86_SERVER
    ACTIVATE_64_BIT_SERVER = 524288,
    ENABLE_CLOAKING = 1048576,
    APPCONTAINER = 4194304,
    ACTIVATE_AAA_AS_IU = 8388608,
    RESERVED6 = 16777216,
    ACTIVATE_ARM32_SERVER = 33554432,
    PS_DLL = 2147483648,
    ALL = 23,
    SERVER = 21,
    _,
    pub fn initFlags(o: struct {
        INPROC_SERVER: u1 = 0,
        INPROC_HANDLER: u1 = 0,
        LOCAL_SERVER: u1 = 0,
        INPROC_SERVER16: u1 = 0,
        REMOTE_SERVER: u1 = 0,
        INPROC_HANDLER16: u1 = 0,
        RESERVED1: u1 = 0,
        RESERVED2: u1 = 0,
        RESERVED3: u1 = 0,
        RESERVED4: u1 = 0,
        NO_CODE_DOWNLOAD: u1 = 0,
        RESERVED5: u1 = 0,
        NO_CUSTOM_MARSHAL: u1 = 0,
        ENABLE_CODE_DOWNLOAD: u1 = 0,
        NO_FAILURE_LOG: u1 = 0,
        DISABLE_AAA: u1 = 0,
        ENABLE_AAA: u1 = 0,
        FROM_DEFAULT_CONTEXT: u1 = 0,
        ACTIVATE_X86_SERVER: u1 = 0,
        ACTIVATE_64_BIT_SERVER: u1 = 0,
        ENABLE_CLOAKING: u1 = 0,
        APPCONTAINER: u1 = 0,
        ACTIVATE_AAA_AS_IU: u1 = 0,
        RESERVED6: u1 = 0,
        ACTIVATE_ARM32_SERVER: u1 = 0,
        PS_DLL: u1 = 0,
        ALL: u1 = 0,
        SERVER: u1 = 0,
    }) CLSCTX {
        return @as(CLSCTX, @enumFromInt((if (o.INPROC_SERVER == 1) @intFromEnum(CLSCTX.INPROC_SERVER) else 0) | (if (o.INPROC_HANDLER == 1) @intFromEnum(CLSCTX.INPROC_HANDLER) else 0) | (if (o.LOCAL_SERVER == 1) @intFromEnum(CLSCTX.LOCAL_SERVER) else 0) | (if (o.INPROC_SERVER16 == 1) @intFromEnum(CLSCTX.INPROC_SERVER16) else 0) | (if (o.REMOTE_SERVER == 1) @intFromEnum(CLSCTX.REMOTE_SERVER) else 0) | (if (o.INPROC_HANDLER16 == 1) @intFromEnum(CLSCTX.INPROC_HANDLER16) else 0) | (if (o.RESERVED1 == 1) @intFromEnum(CLSCTX.RESERVED1) else 0) | (if (o.RESERVED2 == 1) @intFromEnum(CLSCTX.RESERVED2) else 0) | (if (o.RESERVED3 == 1) @intFromEnum(CLSCTX.RESERVED3) else 0) | (if (o.RESERVED4 == 1) @intFromEnum(CLSCTX.RESERVED4) else 0) | (if (o.NO_CODE_DOWNLOAD == 1) @intFromEnum(CLSCTX.NO_CODE_DOWNLOAD) else 0) | (if (o.RESERVED5 == 1) @intFromEnum(CLSCTX.RESERVED5) else 0) | (if (o.NO_CUSTOM_MARSHAL == 1) @intFromEnum(CLSCTX.NO_CUSTOM_MARSHAL) else 0) | (if (o.ENABLE_CODE_DOWNLOAD == 1) @intFromEnum(CLSCTX.ENABLE_CODE_DOWNLOAD) else 0) | (if (o.NO_FAILURE_LOG == 1) @intFromEnum(CLSCTX.NO_FAILURE_LOG) else 0) | (if (o.DISABLE_AAA == 1) @intFromEnum(CLSCTX.DISABLE_AAA) else 0) | (if (o.ENABLE_AAA == 1) @intFromEnum(CLSCTX.ENABLE_AAA) else 0) | (if (o.FROM_DEFAULT_CONTEXT == 1) @intFromEnum(CLSCTX.FROM_DEFAULT_CONTEXT) else 0) | (if (o.ACTIVATE_X86_SERVER == 1) @intFromEnum(CLSCTX.ACTIVATE_X86_SERVER) else 0) | (if (o.ACTIVATE_64_BIT_SERVER == 1) @intFromEnum(CLSCTX.ACTIVATE_64_BIT_SERVER) else 0) | (if (o.ENABLE_CLOAKING == 1) @intFromEnum(CLSCTX.ENABLE_CLOAKING) else 0) | (if (o.APPCONTAINER == 1) @intFromEnum(CLSCTX.APPCONTAINER) else 0) | (if (o.ACTIVATE_AAA_AS_IU == 1) @intFromEnum(CLSCTX.ACTIVATE_AAA_AS_IU) else 0) | (if (o.RESERVED6 == 1) @intFromEnum(CLSCTX.RESERVED6) else 0) | (if (o.ACTIVATE_ARM32_SERVER == 1) @intFromEnum(CLSCTX.ACTIVATE_ARM32_SERVER) else 0) | (if (o.PS_DLL == 1) @intFromEnum(CLSCTX.PS_DLL) else 0) | (if (o.ALL == 1) @intFromEnum(CLSCTX.ALL) else 0) | (if (o.SERVER == 1) @intFromEnum(CLSCTX.SERVER) else 0)));
    }
};
pub const CLSCTX_INPROC_SERVER = CLSCTX.INPROC_SERVER;
pub const CLSCTX_INPROC_HANDLER = CLSCTX.INPROC_HANDLER;
pub const CLSCTX_LOCAL_SERVER = CLSCTX.LOCAL_SERVER;
pub const CLSCTX_INPROC_SERVER16 = CLSCTX.INPROC_SERVER16;
pub const CLSCTX_REMOTE_SERVER = CLSCTX.REMOTE_SERVER;
pub const CLSCTX_INPROC_HANDLER16 = CLSCTX.INPROC_HANDLER16;
pub const CLSCTX_RESERVED1 = CLSCTX.RESERVED1;
pub const CLSCTX_RESERVED2 = CLSCTX.RESERVED2;
pub const CLSCTX_RESERVED3 = CLSCTX.RESERVED3;
pub const CLSCTX_RESERVED4 = CLSCTX.RESERVED4;
pub const CLSCTX_NO_CODE_DOWNLOAD = CLSCTX.NO_CODE_DOWNLOAD;
pub const CLSCTX_RESERVED5 = CLSCTX.RESERVED5;
pub const CLSCTX_NO_CUSTOM_MARSHAL = CLSCTX.NO_CUSTOM_MARSHAL;
pub const CLSCTX_ENABLE_CODE_DOWNLOAD = CLSCTX.ENABLE_CODE_DOWNLOAD;
pub const CLSCTX_NO_FAILURE_LOG = CLSCTX.NO_FAILURE_LOG;
pub const CLSCTX_DISABLE_AAA = CLSCTX.DISABLE_AAA;
pub const CLSCTX_ENABLE_AAA = CLSCTX.ENABLE_AAA;
pub const CLSCTX_FROM_DEFAULT_CONTEXT = CLSCTX.FROM_DEFAULT_CONTEXT;
pub const CLSCTX_ACTIVATE_X86_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_32_BIT_SERVER = CLSCTX.ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_64_BIT_SERVER = CLSCTX.ACTIVATE_64_BIT_SERVER;
pub const CLSCTX_ENABLE_CLOAKING = CLSCTX.ENABLE_CLOAKING;
pub const CLSCTX_APPCONTAINER = CLSCTX.APPCONTAINER;
pub const CLSCTX_ACTIVATE_AAA_AS_IU = CLSCTX.ACTIVATE_AAA_AS_IU;
pub const CLSCTX_RESERVED6 = CLSCTX.RESERVED6;
pub const CLSCTX_ACTIVATE_ARM32_SERVER = CLSCTX.ACTIVATE_ARM32_SERVER;
pub const CLSCTX_PS_DLL = CLSCTX.PS_DLL;
pub const CLSCTX_ALL = CLSCTX.ALL;
pub const CLSCTX_SERVER = CLSCTX.SERVER;

pub const MSHLFLAGS = enum(i32) {
    NORMAL = 0,
    TABLESTRONG = 1,
    TABLEWEAK = 2,
    NOPING = 4,
    RESERVED1 = 8,
    RESERVED2 = 16,
    RESERVED3 = 32,
    RESERVED4 = 64,
};
pub const MSHLFLAGS_NORMAL = MSHLFLAGS.NORMAL;
pub const MSHLFLAGS_TABLESTRONG = MSHLFLAGS.TABLESTRONG;
pub const MSHLFLAGS_TABLEWEAK = MSHLFLAGS.TABLEWEAK;
pub const MSHLFLAGS_NOPING = MSHLFLAGS.NOPING;
pub const MSHLFLAGS_RESERVED1 = MSHLFLAGS.RESERVED1;
pub const MSHLFLAGS_RESERVED2 = MSHLFLAGS.RESERVED2;
pub const MSHLFLAGS_RESERVED3 = MSHLFLAGS.RESERVED3;
pub const MSHLFLAGS_RESERVED4 = MSHLFLAGS.RESERVED4;

pub const MSHCTX = enum(i32) {
    LOCAL = 0,
    NOSHAREDMEM = 1,
    DIFFERENTMACHINE = 2,
    INPROC = 3,
    CROSSCTX = 4,
    CONTAINER = 5,
};
pub const MSHCTX_LOCAL = MSHCTX.LOCAL;
pub const MSHCTX_NOSHAREDMEM = MSHCTX.NOSHAREDMEM;
pub const MSHCTX_DIFFERENTMACHINE = MSHCTX.DIFFERENTMACHINE;
pub const MSHCTX_INPROC = MSHCTX.INPROC;
pub const MSHCTX_CROSSCTX = MSHCTX.CROSSCTX;
pub const MSHCTX_CONTAINER = MSHCTX.CONTAINER;

pub const BYTE_BLOB = extern struct {
    clSize: u32,
    abData: [1]u8,
};

pub const WORD_BLOB = extern struct {
    clSize: u32,
    asData: [1]u16,
};

pub const DWORD_BLOB = extern struct {
    clSize: u32,
    alData: [1]u32,
};

pub const FLAGGED_BYTE_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    abData: [1]u8,
};

pub const FLAGGED_WORD_BLOB = extern struct {
    fFlags: u32,
    clSize: u32,
    asData: [1]u16,
};

pub const BYTE_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u8,
};

pub const SHORT_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u16,
};

pub const LONG_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*u32,
};

pub const HYPER_SIZEDARR = extern struct {
    clSize: u32,
    pData: ?*i64,
};

pub const BLOB = extern struct {
    cbSize: u32,
    pBlobData: ?*u8,
};

pub const IEnumContextProps = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const IContext = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

const IID_IUnknown_Value = Guid.initString("00000000-0000-0000-c000-000000000046");
pub const IID_IUnknown = &IID_IUnknown_Value;
pub const IUnknown = extern struct {
    pub const VTable = extern struct {
        QueryInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUnknown,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUnknown,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Release: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUnknown_QueryInterface(self: *const T, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IUnknown.VTable, @ptrCast(self.vtable)).QueryInterface(@as(*const IUnknown, @ptrCast(self)), riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUnknown_AddRef(self: *const T) u32 {
                return @as(*const IUnknown.VTable, @ptrCast(self.vtable)).AddRef(@as(*const IUnknown, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUnknown_Release(self: *const T) u32 {
                return @as(*const IUnknown.VTable, @ptrCast(self.vtable)).Release(@as(*const IUnknown, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIUnknown_Value = Guid.initString("000e0000-0000-0000-c000-000000000046");
pub const IID_AsyncIUnknown = &IID_AsyncIUnknown_Value;
pub const AsyncIUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIUnknown,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIUnknown,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_QueryInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIUnknown,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIUnknown,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_AddRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_AddRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Begin_Release: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Release: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const AsyncIUnknown,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIUnknown_Begin_QueryInterface(self: *const T, riid: ?*const Guid) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Begin_QueryInterface(@as(*const AsyncIUnknown, @ptrCast(self)), riid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIUnknown_Finish_QueryInterface(self: *const T, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Finish_QueryInterface(@as(*const AsyncIUnknown, @ptrCast(self)), ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIUnknown_Begin_AddRef(self: *const T) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Begin_AddRef(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIUnknown_Finish_AddRef(self: *const T) u32 {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Finish_AddRef(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIUnknown_Begin_Release(self: *const T) HRESULT {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Begin_Release(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIUnknown_Finish_Release(self: *const T) u32 {
                return @as(*const AsyncIUnknown.VTable, @ptrCast(self.vtable)).Finish_Release(@as(*const AsyncIUnknown, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassFactory_Value = Guid.initString("00000001-0000-0000-c000-000000000046");
pub const IID_IClassFactory = &IID_IClassFactory_Value;
pub const IClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClassFactory,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClassFactory,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClassFactory,
                fLock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClassFactory,
                fLock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClassFactory_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IClassFactory.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const IClassFactory, @ptrCast(self)), pUnkOuter, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClassFactory_LockServer(self: *const T, fLock: BOOL) HRESULT {
                return @as(*const IClassFactory.VTable, @ptrCast(self.vtable)).LockServer(@as(*const IClassFactory, @ptrCast(self)), fLock);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COSERVERINFO = extern struct {
    dwReserved1: u32,
    pwszName: ?PWSTR,
    pAuthInfo: ?*COAUTHINFO,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows8.0'
const IID_INoMarshal_Value = Guid.initString("ecc8691b-c1db-4dc0-855e-65f6c551af49");
pub const IID_INoMarshal = &IID_INoMarshal_Value;
pub const INoMarshal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IAgileObject_Value = Guid.initString("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90");
pub const IID_IAgileObject = &IID_IAgileObject_Value;
pub const IAgileObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActivationFilter_Value = Guid.initString("00000017-0000-0000-c000-000000000046");
pub const IID_IActivationFilter = &IID_IActivationFilter_Value;
pub const IActivationFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleActivation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActivationFilter,
                dwActivationType: u32,
                rclsid: ?*const Guid,
                pReplacementClsId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActivationFilter,
                dwActivationType: u32,
                rclsid: ?*const Guid,
                pReplacementClsId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActivationFilter_HandleActivation(self: *const T, dwActivationType: u32, rclsid: ?*const Guid, pReplacementClsId: ?*Guid) HRESULT {
                return @as(*const IActivationFilter.VTable, @ptrCast(self.vtable)).HandleActivation(@as(*const IActivationFilter, @ptrCast(self)), dwActivationType, rclsid, pReplacementClsId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMalloc_Value = Guid.initString("00000002-0000-0000-c000-000000000046");
pub const IID_IMalloc = &IID_IMalloc_Value;
pub const IMalloc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMalloc,
                cb: usize,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMalloc,
                cb: usize,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        Realloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
                cb: usize,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
                cb: usize,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        Free: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        DidAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const IMalloc,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        HeapMinimize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMalloc,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMalloc,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMalloc_Alloc(self: *const T, cb: usize) ?*anyopaque {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).Alloc(@as(*const IMalloc, @ptrCast(self)), cb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMalloc_Realloc(self: *const T, pv: ?*anyopaque, cb: usize) ?*anyopaque {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).Realloc(@as(*const IMalloc, @ptrCast(self)), pv, cb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMalloc_Free(self: *const T, pv: ?*anyopaque) void {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).Free(@as(*const IMalloc, @ptrCast(self)), pv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMalloc_GetSize(self: *const T, pv: ?*anyopaque) usize {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IMalloc, @ptrCast(self)), pv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMalloc_DidAlloc(self: *const T, pv: ?*anyopaque) i32 {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).DidAlloc(@as(*const IMalloc, @ptrCast(self)), pv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMalloc_HeapMinimize(self: *const T) void {
                return @as(*const IMalloc.VTable, @ptrCast(self.vtable)).HeapMinimize(@as(*const IMalloc, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStdMarshalInfo_Value = Guid.initString("00000018-0000-0000-c000-000000000046");
pub const IID_IStdMarshalInfo = &IID_IStdMarshalInfo_Value;
pub const IStdMarshalInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassForHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStdMarshalInfo,
                dwDestContext: u32,
                pvDestContext: ?*anyopaque,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStdMarshalInfo,
                dwDestContext: u32,
                pvDestContext: ?*anyopaque,
                pClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStdMarshalInfo_GetClassForHandler(self: *const T, dwDestContext: u32, pvDestContext: ?*anyopaque, pClsid: ?*Guid) HRESULT {
                return @as(*const IStdMarshalInfo.VTable, @ptrCast(self.vtable)).GetClassForHandler(@as(*const IStdMarshalInfo, @ptrCast(self)), dwDestContext, pvDestContext, pClsid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const EXTCONN = enum(i32) {
    STRONG = 1,
    WEAK = 2,
    CALLABLE = 4,
};
pub const EXTCONN_STRONG = EXTCONN.STRONG;
pub const EXTCONN_WEAK = EXTCONN.WEAK;
pub const EXTCONN_CALLABLE = EXTCONN.CALLABLE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IExternalConnection_Value = Guid.initString("00000019-0000-0000-c000-000000000046");
pub const IID_IExternalConnection = &IID_IExternalConnection_Value;
pub const IExternalConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExternalConnection,
                extconn: u32,
                reserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IExternalConnection,
                extconn: u32,
                reserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        ReleaseConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IExternalConnection,
                extconn: u32,
                reserved: u32,
                fLastReleaseCloses: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IExternalConnection,
                extconn: u32,
                reserved: u32,
                fLastReleaseCloses: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExternalConnection_AddConnection(self: *const T, extconn: u32, reserved: u32) u32 {
                return @as(*const IExternalConnection.VTable, @ptrCast(self.vtable)).AddConnection(@as(*const IExternalConnection, @ptrCast(self)), extconn, reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IExternalConnection_ReleaseConnection(self: *const T, extconn: u32, reserved: u32, fLastReleaseCloses: BOOL) u32 {
                return @as(*const IExternalConnection.VTable, @ptrCast(self.vtable)).ReleaseConnection(@as(*const IExternalConnection, @ptrCast(self)), extconn, reserved, fLastReleaseCloses);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MULTI_QI = extern struct {
    pIID: ?*const Guid,
    pItf: ?*IUnknown,
    hr: HRESULT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMultiQI_Value = Guid.initString("00000020-0000-0000-c000-000000000046");
pub const IID_IMultiQI = &IID_IMultiQI_Value;
pub const IMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryMultipleInterfaces: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMultiQI,
                cMQIs: u32,
                pMQIs: [*]MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMultiQI,
                cMQIs: u32,
                pMQIs: [*]MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMultiQI_QueryMultipleInterfaces(self: *const T, cMQIs: u32, pMQIs: [*]MULTI_QI) HRESULT {
                return @as(*const IMultiQI.VTable, @ptrCast(self.vtable)).QueryMultipleInterfaces(@as(*const IMultiQI, @ptrCast(self)), cMQIs, pMQIs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIMultiQI_Value = Guid.initString("000e0020-0000-0000-c000-000000000046");
pub const IID_AsyncIMultiQI = &IID_AsyncIMultiQI_Value;
pub const AsyncIMultiQI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_QueryMultipleInterfaces: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIMultiQI,
                cMQIs: u32,
                pMQIs: [*]MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIMultiQI,
                cMQIs: u32,
                pMQIs: [*]MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_QueryMultipleInterfaces: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIMultiQI,
                pMQIs: ?*MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIMultiQI,
                pMQIs: ?*MULTI_QI,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIMultiQI_Begin_QueryMultipleInterfaces(self: *const T, cMQIs: u32, pMQIs: [*]MULTI_QI) HRESULT {
                return @as(*const AsyncIMultiQI.VTable, @ptrCast(self.vtable)).Begin_QueryMultipleInterfaces(@as(*const AsyncIMultiQI, @ptrCast(self)), cMQIs, pMQIs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIMultiQI_Finish_QueryMultipleInterfaces(self: *const T, pMQIs: ?*MULTI_QI) HRESULT {
                return @as(*const AsyncIMultiQI.VTable, @ptrCast(self.vtable)).Finish_QueryMultipleInterfaces(@as(*const AsyncIMultiQI, @ptrCast(self)), pMQIs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IInternalUnknown_Value = Guid.initString("00000021-0000-0000-c000-000000000046");
pub const IID_IInternalUnknown = &IID_IInternalUnknown_Value;
pub const IInternalUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryInternalInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInternalUnknown,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInternalUnknown,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInternalUnknown_QueryInternalInterface(self: *const T, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IInternalUnknown.VTable, @ptrCast(self.vtable)).QueryInternalInterface(@as(*const IInternalUnknown, @ptrCast(self)), riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumUnknown_Value = Guid.initString("00000100-0000-0000-c000-000000000046");
pub const IID_IEnumUnknown = &IID_IEnumUnknown_Value;
pub const IEnumUnknown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumUnknown,
                celt: u32,
                rgelt: [*]?*IUnknown,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumUnknown,
                celt: u32,
                rgelt: [*]?*IUnknown,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumUnknown,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumUnknown,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumUnknown,
                ppenum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumUnknown,
                ppenum: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumUnknown_Next(self: *const T, celt: u32, rgelt: [*]?*IUnknown, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumUnknown, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumUnknown_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumUnknown, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumUnknown_Reset(self: *const T) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumUnknown, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumUnknown_Clone(self: *const T, ppenum: ?*?*IEnumUnknown) HRESULT {
                return @as(*const IEnumUnknown.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumUnknown, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumString_Value = Guid.initString("00000101-0000-0000-c000-000000000046");
pub const IID_IEnumString = &IID_IEnumString_Value;
pub const IEnumString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumString,
                celt: u32,
                rgelt: [*]?PWSTR,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumString,
                celt: u32,
                rgelt: [*]?PWSTR,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumString,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumString,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumString,
                ppenum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumString,
                ppenum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumString_Next(self: *const T, celt: u32, rgelt: [*]?PWSTR, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumString, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumString_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumString, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumString_Reset(self: *const T) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumString, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumString_Clone(self: *const T, ppenum: ?*?*IEnumString) HRESULT {
                return @as(*const IEnumString.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumString, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISequentialStream_Value = Guid.initString("0c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ISequentialStream = &IID_ISequentialStream_Value;
pub const ISequentialStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISequentialStream,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISequentialStream,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISequentialStream,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISequentialStream,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISequentialStream_Read(self: *const T, pv: ?*anyopaque, cb: u32, pcbRead: ?*u32) HRESULT {
                return @as(*const ISequentialStream.VTable, @ptrCast(self.vtable)).Read(@as(*const ISequentialStream, @ptrCast(self)), pv, cb, pcbRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISequentialStream_Write(self: *const T, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) HRESULT {
                return @as(*const ISequentialStream.VTable, @ptrCast(self.vtable)).Write(@as(*const ISequentialStream, @ptrCast(self)), pv, cb, pcbWritten);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const STATSTG = extern struct {
    pwcsName: ?PWSTR,
    type: u32,
    cbSize: ULARGE_INTEGER,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    grfMode: u32,
    grfLocksSupported: u32,
    clsid: Guid,
    grfStateBits: u32,
    reserved: u32,
};

pub const STGTY = enum(i32) {
    STORAGE = 1,
    STREAM = 2,
    LOCKBYTES = 3,
    PROPERTY = 4,
};
pub const STGTY_STORAGE = STGTY.STORAGE;
pub const STGTY_STREAM = STGTY.STREAM;
pub const STGTY_LOCKBYTES = STGTY.LOCKBYTES;
pub const STGTY_PROPERTY = STGTY.PROPERTY;

pub const STREAM_SEEK = enum(u32) {
    SET = 0,
    CUR = 1,
    END = 2,
};
pub const STREAM_SEEK_SET = STREAM_SEEK.SET;
pub const STREAM_SEEK_CUR = STREAM_SEEK.CUR;
pub const STREAM_SEEK_END = STREAM_SEEK.END;

// TODO: this type is limited to platform 'windows5.0'
const IID_IStream_Value = Guid.initString("0000000c-0000-0000-c000-000000000046");
pub const IID_IStream = &IID_IStream_Value;
pub const IStream = extern struct {
    pub const VTable = extern struct {
        base: ISequentialStream.VTable,
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                dlibMove: LARGE_INTEGER,
                dwOrigin: STREAM_SEEK,
                plibNewPosition: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                dlibMove: LARGE_INTEGER,
                dwOrigin: STREAM_SEEK,
                plibNewPosition: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                libNewSize: ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                libNewSize: ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                pstm: ?*IStream,
                cb: ULARGE_INTEGER,
                pcbRead: ?*ULARGE_INTEGER,
                pcbWritten: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                pstm: ?*IStream,
                cb: ULARGE_INTEGER,
                pcbRead: ?*ULARGE_INTEGER,
                pcbWritten: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revert: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                libOffset: ULARGE_INTEGER,
                cb: ULARGE_INTEGER,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStream,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStream,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISequentialStream.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_Seek(self: *const T, dlibMove: LARGE_INTEGER, dwOrigin: STREAM_SEEK, plibNewPosition: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Seek(@as(*const IStream, @ptrCast(self)), dlibMove, dwOrigin, plibNewPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_SetSize(self: *const T, libNewSize: ULARGE_INTEGER) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).SetSize(@as(*const IStream, @ptrCast(self)), libNewSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_CopyTo(self: *const T, pstm: ?*IStream, cb: ULARGE_INTEGER, pcbRead: ?*ULARGE_INTEGER, pcbWritten: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IStream, @ptrCast(self)), pstm, cb, pcbRead, pcbWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_Commit(self: *const T, grfCommitFlags: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Commit(@as(*const IStream, @ptrCast(self)), grfCommitFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_Revert(self: *const T) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Revert(@as(*const IStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_LockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).LockRegion(@as(*const IStream, @ptrCast(self)), libOffset, cb, dwLockType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_UnlockRegion(self: *const T, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, dwLockType: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).UnlockRegion(@as(*const IStream, @ptrCast(self)), libOffset, cb, dwLockType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_Stat(self: *const T, pstatstg: ?*STATSTG, grfStatFlag: u32) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Stat(@as(*const IStream, @ptrCast(self)), pstatstg, grfStatFlag);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStream_Clone(self: *const T, ppstm: ?*?*IStream) HRESULT {
                return @as(*const IStream.VTable, @ptrCast(self.vtable)).Clone(@as(*const IStream, @ptrCast(self)), ppstm);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOLEMESSAGE = extern struct {
    reserved1: ?*anyopaque,
    dataRepresentation: u32,
    Buffer: ?*anyopaque,
    cbBuffer: u32,
    iMethod: u32,
    reserved2: [5]?*anyopaque,
    rpcFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcChannelBuffer_Value = Guid.initString("d5f56b60-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcChannelBuffer = &IID_IRpcChannelBuffer_Value;
pub const IRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer,
                pMessage: ?*RPCOLEMESSAGE,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer,
                pMessage: ?*RPCOLEMESSAGE,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendReceive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer,
                pMessage: ?*RPCOLEMESSAGE,
                pStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer,
                pMessage: ?*RPCOLEMESSAGE,
                pStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer,
                pMessage: ?*RPCOLEMESSAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer,
                pMessage: ?*RPCOLEMESSAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestCtx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer,
                pdwDestContext: ?*u32,
                ppvDestContext: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer,
                pdwDestContext: ?*u32,
                ppvDestContext: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsConnected: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer_GetBuffer(self: *const T, pMessage: ?*RPCOLEMESSAGE, riid: ?*const Guid) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IRpcChannelBuffer, @ptrCast(self)), pMessage, riid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer_SendReceive(self: *const T, pMessage: ?*RPCOLEMESSAGE, pStatus: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).SendReceive(@as(*const IRpcChannelBuffer, @ptrCast(self)), pMessage, pStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer_FreeBuffer(self: *const T, pMessage: ?*RPCOLEMESSAGE) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).FreeBuffer(@as(*const IRpcChannelBuffer, @ptrCast(self)), pMessage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer_GetDestCtx(self: *const T, pdwDestContext: ?*u32, ppvDestContext: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).GetDestCtx(@as(*const IRpcChannelBuffer, @ptrCast(self)), pdwDestContext, ppvDestContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer_IsConnected(self: *const T) HRESULT {
                return @as(*const IRpcChannelBuffer.VTable, @ptrCast(self.vtable)).IsConnected(@as(*const IRpcChannelBuffer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer2_Value = Guid.initString("594f31d0-7f19-11d0-b194-00a0c90dc8bf");
pub const IID_IRpcChannelBuffer2 = &IID_IRpcChannelBuffer2_Value;
pub const IRpcChannelBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer.VTable,
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer2,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer2,
                pdwVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRpcChannelBuffer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer2_GetProtocolVersion(self: *const T, pdwVersion: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer2.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IRpcChannelBuffer2, @ptrCast(self)), pdwVersion);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAsyncRpcChannelBuffer_Value = Guid.initString("a5029fb6-3c34-11d1-9c99-00c04fb998aa");
pub const IID_IAsyncRpcChannelBuffer = &IID_IAsyncRpcChannelBuffer_Value;
pub const IAsyncRpcChannelBuffer = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAsyncRpcChannelBuffer,
                pMsg: ?*RPCOLEMESSAGE,
                pSync: ?*ISynchronize,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAsyncRpcChannelBuffer,
                pMsg: ?*RPCOLEMESSAGE,
                pSync: ?*ISynchronize,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Receive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAsyncRpcChannelBuffer,
                pMsg: ?*RPCOLEMESSAGE,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAsyncRpcChannelBuffer,
                pMsg: ?*RPCOLEMESSAGE,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestCtxEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAsyncRpcChannelBuffer,
                pMsg: ?*RPCOLEMESSAGE,
                pdwDestContext: ?*u32,
                ppvDestContext: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAsyncRpcChannelBuffer,
                pMsg: ?*RPCOLEMESSAGE,
                pdwDestContext: ?*u32,
                ppvDestContext: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAsyncRpcChannelBuffer_Send(self: *const T, pMsg: ?*RPCOLEMESSAGE, pSync: ?*ISynchronize, pulStatus: ?*u32) HRESULT {
                return @as(*const IAsyncRpcChannelBuffer.VTable, @ptrCast(self.vtable)).Send(@as(*const IAsyncRpcChannelBuffer, @ptrCast(self)), pMsg, pSync, pulStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAsyncRpcChannelBuffer_Receive(self: *const T, pMsg: ?*RPCOLEMESSAGE, pulStatus: ?*u32) HRESULT {
                return @as(*const IAsyncRpcChannelBuffer.VTable, @ptrCast(self.vtable)).Receive(@as(*const IAsyncRpcChannelBuffer, @ptrCast(self)), pMsg, pulStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAsyncRpcChannelBuffer_GetDestCtxEx(self: *const T, pMsg: ?*RPCOLEMESSAGE, pdwDestContext: ?*u32, ppvDestContext: ?*?*anyopaque) HRESULT {
                return @as(*const IAsyncRpcChannelBuffer.VTable, @ptrCast(self.vtable)).GetDestCtxEx(@as(*const IAsyncRpcChannelBuffer, @ptrCast(self)), pMsg, pdwDestContext, ppvDestContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcChannelBuffer3_Value = Guid.initString("25b15600-0115-11d0-bf0d-00aa00b8dfd2");
pub const IID_IRpcChannelBuffer3 = &IID_IRpcChannelBuffer3_Value;
pub const IRpcChannelBuffer3 = extern struct {
    pub const VTable = extern struct {
        base: IRpcChannelBuffer2.VTable,
        Send: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Receive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                ulSize: u32,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                ulSize: u32,
                pulStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCallContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                riid: ?*const Guid,
                pInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                riid: ?*const Guid,
                pInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestCtxEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pdwDestContext: ?*u32,
                ppvDestContext: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pdwDestContext: ?*u32,
                ppvDestContext: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterAsync: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pAsyncMgr: ?*IAsyncManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcChannelBuffer3,
                pMsg: ?*RPCOLEMESSAGE,
                pAsyncMgr: ?*IAsyncManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRpcChannelBuffer2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_Send(self: *const T, pMsg: ?*RPCOLEMESSAGE, pulStatus: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).Send(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg, pulStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_Receive(self: *const T, pMsg: ?*RPCOLEMESSAGE, ulSize: u32, pulStatus: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).Receive(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg, ulSize, pulStatus);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_Cancel(self: *const T, pMsg: ?*RPCOLEMESSAGE) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_GetCallContext(self: *const T, pMsg: ?*RPCOLEMESSAGE, riid: ?*const Guid, pInterface: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).GetCallContext(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg, riid, pInterface);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_GetDestCtxEx(self: *const T, pMsg: ?*RPCOLEMESSAGE, pdwDestContext: ?*u32, ppvDestContext: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).GetDestCtxEx(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg, pdwDestContext, ppvDestContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_GetState(self: *const T, pMsg: ?*RPCOLEMESSAGE, pState: ?*u32) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).GetState(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg, pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcChannelBuffer3_RegisterAsync(self: *const T, pMsg: ?*RPCOLEMESSAGE, pAsyncMgr: ?*IAsyncManager) HRESULT {
                return @as(*const IRpcChannelBuffer3.VTable, @ptrCast(self.vtable)).RegisterAsync(@as(*const IRpcChannelBuffer3, @ptrCast(self)), pMsg, pAsyncMgr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcSyntaxNegotiate_Value = Guid.initString("58a08519-24c8-4935-b482-3fd823333a4f");
pub const IID_IRpcSyntaxNegotiate = &IID_IRpcSyntaxNegotiate_Value;
pub const IRpcSyntaxNegotiate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NegotiateSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcSyntaxNegotiate,
                pMsg: ?*RPCOLEMESSAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcSyntaxNegotiate,
                pMsg: ?*RPCOLEMESSAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcSyntaxNegotiate_NegotiateSyntax(self: *const T, pMsg: ?*RPCOLEMESSAGE) HRESULT {
                return @as(*const IRpcSyntaxNegotiate.VTable, @ptrCast(self.vtable)).NegotiateSyntax(@as(*const IRpcSyntaxNegotiate, @ptrCast(self)), pMsg);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcProxyBuffer_Value = Guid.initString("d5f56a34-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcProxyBuffer = &IID_IRpcProxyBuffer_Value;
pub const IRpcProxyBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcProxyBuffer,
                pRpcChannelBuffer: ?*IRpcChannelBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcProxyBuffer,
                pRpcChannelBuffer: ?*IRpcChannelBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcProxyBuffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IRpcProxyBuffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcProxyBuffer_Connect(self: *const T, pRpcChannelBuffer: ?*IRpcChannelBuffer) HRESULT {
                return @as(*const IRpcProxyBuffer.VTable, @ptrCast(self.vtable)).Connect(@as(*const IRpcProxyBuffer, @ptrCast(self)), pRpcChannelBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcProxyBuffer_Disconnect(self: *const T) void {
                return @as(*const IRpcProxyBuffer.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IRpcProxyBuffer, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcStubBuffer_Value = Guid.initString("d5f56afc-593b-101a-b569-08002b2dbf7a");
pub const IID_IRpcStubBuffer = &IID_IRpcStubBuffer_Value;
pub const IRpcStubBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
                pUnkServer: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcStubBuffer,
                pUnkServer: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IRpcStubBuffer,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
                _prpcmsg: ?*RPCOLEMESSAGE,
                _pRpcChannelBuffer: ?*IRpcChannelBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcStubBuffer,
                _prpcmsg: ?*RPCOLEMESSAGE,
                _pRpcChannelBuffer: ?*IRpcChannelBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsIIDSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) ?*IRpcStubBuffer,
            else => *const fn (
                self: *const IRpcStubBuffer,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) ?*IRpcStubBuffer,
        },
        CountRefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IRpcStubBuffer,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        DebugServerQueryInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcStubBuffer,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DebugServerRelease: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcStubBuffer,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IRpcStubBuffer,
                pv: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_Connect(self: *const T, pUnkServer: ?*IUnknown) HRESULT {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).Connect(@as(*const IRpcStubBuffer, @ptrCast(self)), pUnkServer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_Disconnect(self: *const T) void {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IRpcStubBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_Invoke(self: *const T, _prpcmsg: ?*RPCOLEMESSAGE, _pRpcChannelBuffer: ?*IRpcChannelBuffer) HRESULT {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IRpcStubBuffer, @ptrCast(self)), _prpcmsg, _pRpcChannelBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_IsIIDSupported(self: *const T, riid: ?*const Guid) ?*IRpcStubBuffer {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).IsIIDSupported(@as(*const IRpcStubBuffer, @ptrCast(self)), riid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_CountRefs(self: *const T) u32 {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).CountRefs(@as(*const IRpcStubBuffer, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_DebugServerQueryInterface(self: *const T, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).DebugServerQueryInterface(@as(*const IRpcStubBuffer, @ptrCast(self)), ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcStubBuffer_DebugServerRelease(self: *const T, pv: ?*anyopaque) void {
                return @as(*const IRpcStubBuffer.VTable, @ptrCast(self.vtable)).DebugServerRelease(@as(*const IRpcStubBuffer, @ptrCast(self)), pv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPSFactoryBuffer_Value = Guid.initString("d5f569d0-593b-101a-b569-08002b2dbf7a");
pub const IID_IPSFactoryBuffer = &IID_IPSFactoryBuffer_Value;
pub const IPSFactoryBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPSFactoryBuffer,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppProxy: ?*?*IRpcProxyBuffer,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPSFactoryBuffer,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppProxy: ?*?*IRpcProxyBuffer,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStub: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPSFactoryBuffer,
                riid: ?*const Guid,
                pUnkServer: ?*IUnknown,
                ppStub: ?*?*IRpcStubBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPSFactoryBuffer,
                riid: ?*const Guid,
                pUnkServer: ?*IUnknown,
                ppStub: ?*?*IRpcStubBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPSFactoryBuffer_CreateProxy(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppProxy: ?*?*IRpcProxyBuffer, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IPSFactoryBuffer.VTable, @ptrCast(self.vtable)).CreateProxy(@as(*const IPSFactoryBuffer, @ptrCast(self)), pUnkOuter, riid, ppProxy, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPSFactoryBuffer_CreateStub(self: *const T, riid: ?*const Guid, pUnkServer: ?*IUnknown, ppStub: ?*?*IRpcStubBuffer) HRESULT {
                return @as(*const IPSFactoryBuffer.VTable, @ptrCast(self.vtable)).CreateStub(@as(*const IPSFactoryBuffer, @ptrCast(self)), riid, pUnkServer, ppStub);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SChannelHookCallInfo = extern struct {
    iid: Guid,
    cbSize: u32,
    uCausality: Guid,
    dwServerPid: u32,
    iMethod: u32,
    pObject: ?*anyopaque,
};

const IID_IChannelHook_Value = Guid.initString("1008c4a0-7613-11cf-9af1-0020af6e72f4");
pub const IID_IChannelHook = &IID_IChannelHook_Value;
pub const IChannelHook = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClientGetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                pDataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                pDataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ClientFillBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                pDataSize: ?*u32,
                pDataBuffer: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                pDataSize: ?*u32,
                pDataBuffer: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ClientNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                cbDataSize: u32,
                pDataBuffer: ?*anyopaque,
                lDataRep: u32,
                hrFault: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                cbDataSize: u32,
                pDataBuffer: ?*anyopaque,
                lDataRep: u32,
                hrFault: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ServerNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                cbDataSize: u32,
                pDataBuffer: ?*anyopaque,
                lDataRep: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                cbDataSize: u32,
                pDataBuffer: ?*anyopaque,
                lDataRep: u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ServerGetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                hrFault: HRESULT,
                pDataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                hrFault: HRESULT,
                pDataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ServerFillBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                pDataSize: ?*u32,
                pDataBuffer: ?*anyopaque,
                hrFault: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IChannelHook,
                uExtent: ?*const Guid,
                riid: ?*const Guid,
                pDataSize: ?*u32,
                pDataBuffer: ?*anyopaque,
                hrFault: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelHook_ClientGetSize(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ClientGetSize(@as(*const IChannelHook, @ptrCast(self)), uExtent, riid, pDataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelHook_ClientFillBuffer(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32, pDataBuffer: ?*anyopaque) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ClientFillBuffer(@as(*const IChannelHook, @ptrCast(self)), uExtent, riid, pDataSize, pDataBuffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelHook_ClientNotify(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, cbDataSize: u32, pDataBuffer: ?*anyopaque, lDataRep: u32, hrFault: HRESULT) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ClientNotify(@as(*const IChannelHook, @ptrCast(self)), uExtent, riid, cbDataSize, pDataBuffer, lDataRep, hrFault);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelHook_ServerNotify(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, cbDataSize: u32, pDataBuffer: ?*anyopaque, lDataRep: u32) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ServerNotify(@as(*const IChannelHook, @ptrCast(self)), uExtent, riid, cbDataSize, pDataBuffer, lDataRep);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelHook_ServerGetSize(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, hrFault: HRESULT, pDataSize: ?*u32) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ServerGetSize(@as(*const IChannelHook, @ptrCast(self)), uExtent, riid, hrFault, pDataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IChannelHook_ServerFillBuffer(self: *const T, uExtent: ?*const Guid, riid: ?*const Guid, pDataSize: ?*u32, pDataBuffer: ?*anyopaque, hrFault: HRESULT) void {
                return @as(*const IChannelHook.VTable, @ptrCast(self.vtable)).ServerFillBuffer(@as(*const IChannelHook, @ptrCast(self)), uExtent, riid, pDataSize, pDataBuffer, hrFault);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SOLE_AUTHENTICATION_SERVICE = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pPrincipalName: ?PWSTR,
    hr: HRESULT,
};

pub const EOLE_AUTHENTICATION_CAPABILITIES = enum(i32) {
    NONE = 0,
    MUTUAL_AUTH = 1,
    STATIC_CLOAKING = 32,
    DYNAMIC_CLOAKING = 64,
    ANY_AUTHORITY = 128,
    MAKE_FULLSIC = 256,
    DEFAULT = 2048,
    SECURE_REFS = 2,
    ACCESS_CONTROL = 4,
    APPID = 8,
    DYNAMIC = 16,
    REQUIRE_FULLSIC = 512,
    AUTO_IMPERSONATE = 1024,
    DISABLE_AAA = 4096,
    NO_CUSTOM_MARSHAL = 8192,
    RESERVED1 = 16384,
};
pub const EOAC_NONE = EOLE_AUTHENTICATION_CAPABILITIES.NONE;
pub const EOAC_MUTUAL_AUTH = EOLE_AUTHENTICATION_CAPABILITIES.MUTUAL_AUTH;
pub const EOAC_STATIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.STATIC_CLOAKING;
pub const EOAC_DYNAMIC_CLOAKING = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC_CLOAKING;
pub const EOAC_ANY_AUTHORITY = EOLE_AUTHENTICATION_CAPABILITIES.ANY_AUTHORITY;
pub const EOAC_MAKE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.MAKE_FULLSIC;
pub const EOAC_DEFAULT = EOLE_AUTHENTICATION_CAPABILITIES.DEFAULT;
pub const EOAC_SECURE_REFS = EOLE_AUTHENTICATION_CAPABILITIES.SECURE_REFS;
pub const EOAC_ACCESS_CONTROL = EOLE_AUTHENTICATION_CAPABILITIES.ACCESS_CONTROL;
pub const EOAC_APPID = EOLE_AUTHENTICATION_CAPABILITIES.APPID;
pub const EOAC_DYNAMIC = EOLE_AUTHENTICATION_CAPABILITIES.DYNAMIC;
pub const EOAC_REQUIRE_FULLSIC = EOLE_AUTHENTICATION_CAPABILITIES.REQUIRE_FULLSIC;
pub const EOAC_AUTO_IMPERSONATE = EOLE_AUTHENTICATION_CAPABILITIES.AUTO_IMPERSONATE;
pub const EOAC_DISABLE_AAA = EOLE_AUTHENTICATION_CAPABILITIES.DISABLE_AAA;
pub const EOAC_NO_CUSTOM_MARSHAL = EOLE_AUTHENTICATION_CAPABILITIES.NO_CUSTOM_MARSHAL;
pub const EOAC_RESERVED1 = EOLE_AUTHENTICATION_CAPABILITIES.RESERVED1;

pub const SOLE_AUTHENTICATION_INFO = extern struct {
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pAuthInfo: ?*anyopaque,
};

pub const SOLE_AUTHENTICATION_LIST = extern struct {
    cAuthInfo: u32,
    aAuthInfo: ?*SOLE_AUTHENTICATION_INFO,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClientSecurity_Value = Guid.initString("0000013d-0000-0000-c000-000000000046");
pub const IID_IClientSecurity = &IID_IClientSecurity_Value;
pub const IClientSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClientSecurity,
                pProxy: ?*IUnknown,
                pAuthnSvc: ?*u32,
                pAuthzSvc: ?*u32,
                pServerPrincName: ?*?*u16,
                pAuthnLevel: ?*RPC_C_AUTHN_LEVEL,
                pImpLevel: ?*RPC_C_IMP_LEVEL,
                pAuthInfo: ?*?*anyopaque,
                pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClientSecurity,
                pProxy: ?*IUnknown,
                pAuthnSvc: ?*u32,
                pAuthzSvc: ?*u32,
                pServerPrincName: ?*?*u16,
                pAuthnLevel: ?*RPC_C_AUTHN_LEVEL,
                pImpLevel: ?*RPC_C_IMP_LEVEL,
                pAuthInfo: ?*?*anyopaque,
                pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBlanket: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClientSecurity,
                pProxy: ?*IUnknown,
                dwAuthnSvc: u32,
                dwAuthzSvc: u32,
                pServerPrincName: ?PWSTR,
                dwAuthnLevel: RPC_C_AUTHN_LEVEL,
                dwImpLevel: RPC_C_IMP_LEVEL,
                pAuthInfo: ?*anyopaque,
                dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClientSecurity,
                pProxy: ?*IUnknown,
                dwAuthnSvc: u32,
                dwAuthzSvc: u32,
                pServerPrincName: ?PWSTR,
                dwAuthnLevel: RPC_C_AUTHN_LEVEL,
                dwImpLevel: RPC_C_IMP_LEVEL,
                pAuthInfo: ?*anyopaque,
                dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyProxy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClientSecurity,
                pProxy: ?*IUnknown,
                ppCopy: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClientSecurity,
                pProxy: ?*IUnknown,
                ppCopy: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClientSecurity_QueryBlanket(self: *const T, pProxy: ?*IUnknown, pAuthnSvc: ?*u32, pAuthzSvc: ?*u32, pServerPrincName: ?*?*u16, pAuthnLevel: ?*RPC_C_AUTHN_LEVEL, pImpLevel: ?*RPC_C_IMP_LEVEL, pAuthInfo: ?*?*anyopaque, pCapabilites: ?*EOLE_AUTHENTICATION_CAPABILITIES) HRESULT {
                return @as(*const IClientSecurity.VTable, @ptrCast(self.vtable)).QueryBlanket(@as(*const IClientSecurity, @ptrCast(self)), pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, pAuthInfo, pCapabilites);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClientSecurity_SetBlanket(self: *const T, pProxy: ?*IUnknown, dwAuthnSvc: u32, dwAuthzSvc: u32, pServerPrincName: ?PWSTR, dwAuthnLevel: RPC_C_AUTHN_LEVEL, dwImpLevel: RPC_C_IMP_LEVEL, pAuthInfo: ?*anyopaque, dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES) HRESULT {
                return @as(*const IClientSecurity.VTable, @ptrCast(self.vtable)).SetBlanket(@as(*const IClientSecurity, @ptrCast(self)), pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClientSecurity_CopyProxy(self: *const T, pProxy: ?*IUnknown, ppCopy: ?*?*IUnknown) HRESULT {
                return @as(*const IClientSecurity.VTable, @ptrCast(self.vtable)).CopyProxy(@as(*const IClientSecurity, @ptrCast(self)), pProxy, ppCopy);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IServerSecurity_Value = Guid.initString("0000013e-0000-0000-c000-000000000046");
pub const IID_IServerSecurity = &IID_IServerSecurity_Value;
pub const IServerSecurity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryBlanket: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IServerSecurity,
                pAuthnSvc: ?*u32,
                pAuthzSvc: ?*u32,
                pServerPrincName: ?*?*u16,
                pAuthnLevel: ?*u32,
                pImpLevel: ?*u32,
                pPrivs: ?*?*anyopaque,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IServerSecurity,
                pAuthnSvc: ?*u32,
                pAuthzSvc: ?*u32,
                pServerPrincName: ?*?*u16,
                pAuthnLevel: ?*u32,
                pImpLevel: ?*u32,
                pPrivs: ?*?*anyopaque,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ImpersonateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IServerSecurity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IServerSecurity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevertToSelf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IServerSecurity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IServerSecurity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsImpersonating: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IServerSecurity,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IServerSecurity,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IServerSecurity_QueryBlanket(self: *const T, pAuthnSvc: ?*u32, pAuthzSvc: ?*u32, pServerPrincName: ?*?*u16, pAuthnLevel: ?*u32, pImpLevel: ?*u32, pPrivs: ?*?*anyopaque, pCapabilities: ?*u32) HRESULT {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).QueryBlanket(@as(*const IServerSecurity, @ptrCast(self)), pAuthnSvc, pAuthzSvc, pServerPrincName, pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IServerSecurity_ImpersonateClient(self: *const T) HRESULT {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).ImpersonateClient(@as(*const IServerSecurity, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IServerSecurity_RevertToSelf(self: *const T) HRESULT {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).RevertToSelf(@as(*const IServerSecurity, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IServerSecurity_IsImpersonating(self: *const T) BOOL {
                return @as(*const IServerSecurity.VTable, @ptrCast(self.vtable)).IsImpersonating(@as(*const IServerSecurity, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RPCOPT_PROPERTIES = enum(i32) {
    RPCTIMEOUT = 1,
    SERVER_LOCALITY = 2,
    RESERVED1 = 4,
    RESERVED2 = 5,
    RESERVED3 = 8,
    RESERVED4 = 16,
};
pub const COMBND_RPCTIMEOUT = RPCOPT_PROPERTIES.RPCTIMEOUT;
pub const COMBND_SERVER_LOCALITY = RPCOPT_PROPERTIES.SERVER_LOCALITY;
pub const COMBND_RESERVED1 = RPCOPT_PROPERTIES.RESERVED1;
pub const COMBND_RESERVED2 = RPCOPT_PROPERTIES.RESERVED2;
pub const COMBND_RESERVED3 = RPCOPT_PROPERTIES.RESERVED3;
pub const COMBND_RESERVED4 = RPCOPT_PROPERTIES.RESERVED4;

pub const RPCOPT_SERVER_LOCALITY_VALUES = enum(i32) {
    PROCESS_LOCAL = 0,
    MACHINE_LOCAL = 1,
    REMOTE = 2,
};
pub const SERVER_LOCALITY_PROCESS_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.PROCESS_LOCAL;
pub const SERVER_LOCALITY_MACHINE_LOCAL = RPCOPT_SERVER_LOCALITY_VALUES.MACHINE_LOCAL;
pub const SERVER_LOCALITY_REMOTE = RPCOPT_SERVER_LOCALITY_VALUES.REMOTE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IRpcOptions_Value = Guid.initString("00000144-0000-0000-c000-000000000046");
pub const IID_IRpcOptions = &IID_IRpcOptions_Value;
pub const IRpcOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcOptions,
                pPrx: ?*IUnknown,
                dwProperty: RPCOPT_PROPERTIES,
                dwValue: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcOptions,
                pPrx: ?*IUnknown,
                dwProperty: RPCOPT_PROPERTIES,
                dwValue: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Query: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcOptions,
                pPrx: ?*IUnknown,
                dwProperty: RPCOPT_PROPERTIES,
                pdwValue: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcOptions,
                pPrx: ?*IUnknown,
                dwProperty: RPCOPT_PROPERTIES,
                pdwValue: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcOptions_Set(self: *const T, pPrx: ?*IUnknown, dwProperty: RPCOPT_PROPERTIES, dwValue: usize) HRESULT {
                return @as(*const IRpcOptions.VTable, @ptrCast(self.vtable)).Set(@as(*const IRpcOptions, @ptrCast(self)), pPrx, dwProperty, dwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcOptions_Query(self: *const T, pPrx: ?*IUnknown, dwProperty: RPCOPT_PROPERTIES, pdwValue: ?*usize) HRESULT {
                return @as(*const IRpcOptions.VTable, @ptrCast(self.vtable)).Query(@as(*const IRpcOptions, @ptrCast(self)), pPrx, dwProperty, pdwValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const GLOBALOPT_PROPERTIES = enum(i32) {
    EXCEPTION_HANDLING = 1,
    APPID = 2,
    RPC_THREADPOOL_SETTING = 3,
    RO_SETTINGS = 4,
    UNMARSHALING_POLICY = 5,
    PROPERTIES_RESERVED1 = 6,
    PROPERTIES_RESERVED2 = 7,
    PROPERTIES_RESERVED3 = 8,
};
pub const COMGLB_EXCEPTION_HANDLING = GLOBALOPT_PROPERTIES.EXCEPTION_HANDLING;
pub const COMGLB_APPID = GLOBALOPT_PROPERTIES.APPID;
pub const COMGLB_RPC_THREADPOOL_SETTING = GLOBALOPT_PROPERTIES.RPC_THREADPOOL_SETTING;
pub const COMGLB_RO_SETTINGS = GLOBALOPT_PROPERTIES.RO_SETTINGS;
pub const COMGLB_UNMARSHALING_POLICY = GLOBALOPT_PROPERTIES.UNMARSHALING_POLICY;
pub const COMGLB_PROPERTIES_RESERVED1 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED1;
pub const COMGLB_PROPERTIES_RESERVED2 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED2;
pub const COMGLB_PROPERTIES_RESERVED3 = GLOBALOPT_PROPERTIES.PROPERTIES_RESERVED3;

pub const GLOBALOPT_EH_VALUES = enum(i32) {
    HANDLE = 0,
    DONOT_HANDLE_FATAL = 1,
    // DONOT_HANDLE = 1, this enum value conflicts with DONOT_HANDLE_FATAL
    DONOT_HANDLE_ANY = 2,
};
pub const COMGLB_EXCEPTION_HANDLE = GLOBALOPT_EH_VALUES.HANDLE;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE = GLOBALOPT_EH_VALUES.DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_ANY = GLOBALOPT_EH_VALUES.DONOT_HANDLE_ANY;

pub const GLOBALOPT_RPCTP_VALUES = enum(i32) {
    DEFAULT_POOL = 0,
    PRIVATE_POOL = 1,
};
pub const COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = GLOBALOPT_RPCTP_VALUES.DEFAULT_POOL;
pub const COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = GLOBALOPT_RPCTP_VALUES.PRIVATE_POOL;

pub const GLOBALOPT_RO_FLAGS = enum(i32) {
    STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 1,
    STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 2,
    STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 4,
    FAST_RUNDOWN = 8,
    RESERVED1 = 16,
    RESERVED2 = 32,
    RESERVED3 = 64,
    STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 128,
    RESERVED4 = 256,
    RESERVED5 = 512,
    RESERVED6 = 1024,
};
pub const COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_REMOVE_TOUCH_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES;
pub const COMGLB_FAST_RUNDOWN = GLOBALOPT_RO_FLAGS.FAST_RUNDOWN;
pub const COMGLB_RESERVED1 = GLOBALOPT_RO_FLAGS.RESERVED1;
pub const COMGLB_RESERVED2 = GLOBALOPT_RO_FLAGS.RESERVED2;
pub const COMGLB_RESERVED3 = GLOBALOPT_RO_FLAGS.RESERVED3;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = GLOBALOPT_RO_FLAGS.STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES;
pub const COMGLB_RESERVED4 = GLOBALOPT_RO_FLAGS.RESERVED4;
pub const COMGLB_RESERVED5 = GLOBALOPT_RO_FLAGS.RESERVED5;
pub const COMGLB_RESERVED6 = GLOBALOPT_RO_FLAGS.RESERVED6;

pub const GLOBALOPT_UNMARSHALING_POLICY_VALUES = enum(i32) {
    NORMAL = 0,
    STRONG = 1,
    HYBRID = 2,
};
pub const COMGLB_UNMARSHALING_POLICY_NORMAL = GLOBALOPT_UNMARSHALING_POLICY_VALUES.NORMAL;
pub const COMGLB_UNMARSHALING_POLICY_STRONG = GLOBALOPT_UNMARSHALING_POLICY_VALUES.STRONG;
pub const COMGLB_UNMARSHALING_POLICY_HYBRID = GLOBALOPT_UNMARSHALING_POLICY_VALUES.HYBRID;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IGlobalOptions_Value = Guid.initString("0000015b-0000-0000-c000-000000000046");
pub const IID_IGlobalOptions = &IID_IGlobalOptions_Value;
pub const IGlobalOptions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGlobalOptions,
                dwProperty: GLOBALOPT_PROPERTIES,
                dwValue: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGlobalOptions,
                dwProperty: GLOBALOPT_PROPERTIES,
                dwValue: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Query: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGlobalOptions,
                dwProperty: GLOBALOPT_PROPERTIES,
                pdwValue: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGlobalOptions,
                dwProperty: GLOBALOPT_PROPERTIES,
                pdwValue: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGlobalOptions_Set(self: *const T, dwProperty: GLOBALOPT_PROPERTIES, dwValue: usize) HRESULT {
                return @as(*const IGlobalOptions.VTable, @ptrCast(self.vtable)).Set(@as(*const IGlobalOptions, @ptrCast(self)), dwProperty, dwValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGlobalOptions_Query(self: *const T, dwProperty: GLOBALOPT_PROPERTIES, pdwValue: ?*usize) HRESULT {
                return @as(*const IGlobalOptions.VTable, @ptrCast(self.vtable)).Query(@as(*const IGlobalOptions, @ptrCast(self)), dwProperty, pdwValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogate_Value = Guid.initString("00000022-0000-0000-c000-000000000046");
pub const IID_ISurrogate = &IID_ISurrogate_Value;
pub const ISurrogate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadDllServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogate,
                Clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogate,
                Clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeSurrogate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogate_LoadDllServer(self: *const T, Clsid: ?*const Guid) HRESULT {
                return @as(*const ISurrogate.VTable, @ptrCast(self.vtable)).LoadDllServer(@as(*const ISurrogate, @ptrCast(self)), Clsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogate_FreeSurrogate(self: *const T) HRESULT {
                return @as(*const ISurrogate.VTable, @ptrCast(self.vtable)).FreeSurrogate(@as(*const ISurrogate, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGlobalInterfaceTable_Value = Guid.initString("00000146-0000-0000-c000-000000000046");
pub const IID_IGlobalInterfaceTable = &IID_IGlobalInterfaceTable_Value;
pub const IGlobalInterfaceTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterInterfaceInGlobal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGlobalInterfaceTable,
                pUnk: ?*IUnknown,
                riid: ?*const Guid,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGlobalInterfaceTable,
                pUnk: ?*IUnknown,
                riid: ?*const Guid,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeInterfaceFromGlobal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGlobalInterfaceTable,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGlobalInterfaceTable,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterfaceFromGlobal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IGlobalInterfaceTable,
                dwCookie: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IGlobalInterfaceTable,
                dwCookie: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGlobalInterfaceTable_RegisterInterfaceInGlobal(self: *const T, pUnk: ?*IUnknown, riid: ?*const Guid, pdwCookie: ?*u32) HRESULT {
                return @as(*const IGlobalInterfaceTable.VTable, @ptrCast(self.vtable)).RegisterInterfaceInGlobal(@as(*const IGlobalInterfaceTable, @ptrCast(self)), pUnk, riid, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGlobalInterfaceTable_RevokeInterfaceFromGlobal(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IGlobalInterfaceTable.VTable, @ptrCast(self.vtable)).RevokeInterfaceFromGlobal(@as(*const IGlobalInterfaceTable, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IGlobalInterfaceTable_GetInterfaceFromGlobal(self: *const T, dwCookie: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IGlobalInterfaceTable.VTable, @ptrCast(self.vtable)).GetInterfaceFromGlobal(@as(*const IGlobalInterfaceTable, @ptrCast(self)), dwCookie, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronize_Value = Guid.initString("00000030-0000-0000-c000-000000000046");
pub const IID_ISynchronize = &IID_ISynchronize_Value;
pub const ISynchronize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronize,
                dwFlags: u32,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronize,
                dwFlags: u32,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Signal: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronize_Wait(self: *const T, dwFlags: u32, dwMilliseconds: u32) HRESULT {
                return @as(*const ISynchronize.VTable, @ptrCast(self.vtable)).Wait(@as(*const ISynchronize, @ptrCast(self)), dwFlags, dwMilliseconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronize_Signal(self: *const T) HRESULT {
                return @as(*const ISynchronize.VTable, @ptrCast(self.vtable)).Signal(@as(*const ISynchronize, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronize_Reset(self: *const T) HRESULT {
                return @as(*const ISynchronize.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISynchronize, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeHandle_Value = Guid.initString("00000031-0000-0000-c000-000000000046");
pub const IID_ISynchronizeHandle = &IID_ISynchronizeHandle_Value;
pub const ISynchronizeHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronizeHandle,
                ph: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronizeHandle,
                ph: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronizeHandle_GetHandle(self: *const T, ph: ?*?HANDLE) HRESULT {
                return @as(*const ISynchronizeHandle.VTable, @ptrCast(self.vtable)).GetHandle(@as(*const ISynchronizeHandle, @ptrCast(self)), ph);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeEvent_Value = Guid.initString("00000032-0000-0000-c000-000000000046");
pub const IID_ISynchronizeEvent = &IID_ISynchronizeEvent_Value;
pub const ISynchronizeEvent = extern struct {
    pub const VTable = extern struct {
        base: ISynchronizeHandle.VTable,
        SetEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronizeEvent,
                ph: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronizeEvent,
                ph: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISynchronizeHandle.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronizeEvent_SetEventHandle(self: *const T, ph: ?*?HANDLE) HRESULT {
                return @as(*const ISynchronizeEvent.VTable, @ptrCast(self.vtable)).SetEventHandle(@as(*const ISynchronizeEvent, @ptrCast(self)), ph);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISynchronizeContainer_Value = Guid.initString("00000033-0000-0000-c000-000000000046");
pub const IID_ISynchronizeContainer = &IID_ISynchronizeContainer_Value;
pub const ISynchronizeContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSynchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronizeContainer,
                pSync: ?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronizeContainer,
                pSync: ?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronizeContainer,
                dwFlags: u32,
                dwTimeOut: u32,
                ppSync: ?*?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronizeContainer,
                dwFlags: u32,
                dwTimeOut: u32,
                ppSync: ?*?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronizeContainer_AddSynchronize(self: *const T, pSync: ?*ISynchronize) HRESULT {
                return @as(*const ISynchronizeContainer.VTable, @ptrCast(self.vtable)).AddSynchronize(@as(*const ISynchronizeContainer, @ptrCast(self)), pSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronizeContainer_WaitMultiple(self: *const T, dwFlags: u32, dwTimeOut: u32, ppSync: ?*?*ISynchronize) HRESULT {
                return @as(*const ISynchronizeContainer.VTable, @ptrCast(self.vtable)).WaitMultiple(@as(*const ISynchronizeContainer, @ptrCast(self)), dwFlags, dwTimeOut, ppSync);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISynchronizeMutex_Value = Guid.initString("00000025-0000-0000-c000-000000000046");
pub const IID_ISynchronizeMutex = &IID_ISynchronizeMutex_Value;
pub const ISynchronizeMutex = extern struct {
    pub const VTable = extern struct {
        base: ISynchronize.VTable,
        ReleaseMutex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISynchronizeMutex,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISynchronizeMutex,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ISynchronize.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISynchronizeMutex_ReleaseMutex(self: *const T) HRESULT {
                return @as(*const ISynchronizeMutex.VTable, @ptrCast(self.vtable)).ReleaseMutex(@as(*const ISynchronizeMutex, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICancelMethodCalls_Value = Guid.initString("00000029-0000-0000-c000-000000000046");
pub const IID_ICancelMethodCalls = &IID_ICancelMethodCalls_Value;
pub const ICancelMethodCalls = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICancelMethodCalls,
                ulSeconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICancelMethodCalls,
                ulSeconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestCancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICancelMethodCalls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICancelMethodCalls,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICancelMethodCalls_Cancel(self: *const T, ulSeconds: u32) HRESULT {
                return @as(*const ICancelMethodCalls.VTable, @ptrCast(self.vtable)).Cancel(@as(*const ICancelMethodCalls, @ptrCast(self)), ulSeconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICancelMethodCalls_TestCancel(self: *const T) HRESULT {
                return @as(*const ICancelMethodCalls.VTable, @ptrCast(self.vtable)).TestCancel(@as(*const ICancelMethodCalls, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DCOM_CALL_STATE = enum(i32) {
    NONE = 0,
    CALL_COMPLETE = 1,
    CALL_CANCELED = 2,
};
pub const DCOM_NONE = DCOM_CALL_STATE.NONE;
pub const DCOM_CALL_COMPLETE = DCOM_CALL_STATE.CALL_COMPLETE;
pub const DCOM_CALL_CANCELED = DCOM_CALL_STATE.CALL_CANCELED;

const IID_IAsyncManager_Value = Guid.initString("0000002a-0000-0000-c000-000000000046");
pub const IID_IAsyncManager = &IID_IAsyncManager_Value;
pub const IAsyncManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAsyncManager,
                Result: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAsyncManager,
                Result: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCallContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAsyncManager,
                riid: ?*const Guid,
                pInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAsyncManager,
                riid: ?*const Guid,
                pInterface: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAsyncManager,
                pulStateFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAsyncManager,
                pulStateFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAsyncManager_CompleteCall(self: *const T, Result: HRESULT) HRESULT {
                return @as(*const IAsyncManager.VTable, @ptrCast(self.vtable)).CompleteCall(@as(*const IAsyncManager, @ptrCast(self)), Result);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAsyncManager_GetCallContext(self: *const T, riid: ?*const Guid, pInterface: ?*?*anyopaque) HRESULT {
                return @as(*const IAsyncManager.VTable, @ptrCast(self.vtable)).GetCallContext(@as(*const IAsyncManager, @ptrCast(self)), riid, pInterface);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAsyncManager_GetState(self: *const T, pulStateFlags: ?*u32) HRESULT {
                return @as(*const IAsyncManager.VTable, @ptrCast(self.vtable)).GetState(@as(*const IAsyncManager, @ptrCast(self)), pulStateFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICallFactory_Value = Guid.initString("1c733a30-2a1c-11ce-ade5-00aa0044773d");
pub const IID_ICallFactory = &IID_ICallFactory_Value;
pub const ICallFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICallFactory,
                riid: ?*const Guid,
                pCtrlUnk: ?*IUnknown,
                riid2: ?*const Guid,
                ppv: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICallFactory,
                riid: ?*const Guid,
                pCtrlUnk: ?*IUnknown,
                riid2: ?*const Guid,
                ppv: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICallFactory_CreateCall(self: *const T, riid: ?*const Guid, pCtrlUnk: ?*IUnknown, riid2: ?*const Guid, ppv: ?*?*IUnknown) HRESULT {
                return @as(*const ICallFactory.VTable, @ptrCast(self.vtable)).CreateCall(@as(*const ICallFactory, @ptrCast(self)), riid, pCtrlUnk, riid2, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRpcHelper_Value = Guid.initString("00000149-0000-0000-c000-000000000046");
pub const IID_IRpcHelper = &IID_IRpcHelper_Value;
pub const IRpcHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDCOMProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcHelper,
                pComVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcHelper,
                pComVersion: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIIDFromOBJREF: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRpcHelper,
                pObjRef: ?*anyopaque,
                piid: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRpcHelper,
                pObjRef: ?*anyopaque,
                piid: ?*?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcHelper_GetDCOMProtocolVersion(self: *const T, pComVersion: ?*u32) HRESULT {
                return @as(*const IRpcHelper.VTable, @ptrCast(self.vtable)).GetDCOMProtocolVersion(@as(*const IRpcHelper, @ptrCast(self)), pComVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRpcHelper_GetIIDFromOBJREF(self: *const T, pObjRef: ?*anyopaque, piid: ?*?*Guid) HRESULT {
                return @as(*const IRpcHelper.VTable, @ptrCast(self.vtable)).GetIIDFromOBJREF(@as(*const IRpcHelper, @ptrCast(self)), pObjRef, piid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IReleaseMarshalBuffers_Value = Guid.initString("eb0cb9e8-7996-11d2-872e-0000f8080859");
pub const IID_IReleaseMarshalBuffers = &IID_IReleaseMarshalBuffers_Value;
pub const IReleaseMarshalBuffers = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReleaseMarshalBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IReleaseMarshalBuffers,
                pMsg: ?*RPCOLEMESSAGE,
                dwFlags: u32,
                pChnl: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IReleaseMarshalBuffers,
                pMsg: ?*RPCOLEMESSAGE,
                dwFlags: u32,
                pChnl: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IReleaseMarshalBuffers_ReleaseMarshalBuffer(self: *const T, pMsg: ?*RPCOLEMESSAGE, dwFlags: u32, pChnl: ?*IUnknown) HRESULT {
                return @as(*const IReleaseMarshalBuffers.VTable, @ptrCast(self.vtable)).ReleaseMarshalBuffer(@as(*const IReleaseMarshalBuffers, @ptrCast(self)), pMsg, dwFlags, pChnl);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWaitMultiple_Value = Guid.initString("0000002b-0000-0000-c000-000000000046");
pub const IID_IWaitMultiple = &IID_IWaitMultiple_Value;
pub const IWaitMultiple = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWaitMultiple,
                timeout: u32,
                pSync: ?*?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWaitMultiple,
                timeout: u32,
                pSync: ?*?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSynchronize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWaitMultiple,
                pSync: ?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWaitMultiple,
                pSync: ?*ISynchronize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWaitMultiple_WaitMultiple(self: *const T, timeout: u32, pSync: ?*?*ISynchronize) HRESULT {
                return @as(*const IWaitMultiple.VTable, @ptrCast(self.vtable)).WaitMultiple(@as(*const IWaitMultiple, @ptrCast(self)), timeout, pSync);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWaitMultiple_AddSynchronize(self: *const T, pSync: ?*ISynchronize) HRESULT {
                return @as(*const IWaitMultiple.VTable, @ptrCast(self.vtable)).AddSynchronize(@as(*const IWaitMultiple, @ptrCast(self)), pSync);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrTrackingControl_Value = Guid.initString("00000147-0000-0000-c000-000000000046");
pub const IID_IAddrTrackingControl = &IID_IAddrTrackingControl_Value;
pub const IAddrTrackingControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableCOMDynamicAddrTracking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrTrackingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrTrackingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableCOMDynamicAddrTracking: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrTrackingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrTrackingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrTrackingControl_EnableCOMDynamicAddrTracking(self: *const T) HRESULT {
                return @as(*const IAddrTrackingControl.VTable, @ptrCast(self.vtable)).EnableCOMDynamicAddrTracking(@as(*const IAddrTrackingControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrTrackingControl_DisableCOMDynamicAddrTracking(self: *const T) HRESULT {
                return @as(*const IAddrTrackingControl.VTable, @ptrCast(self.vtable)).DisableCOMDynamicAddrTracking(@as(*const IAddrTrackingControl, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAddrExclusionControl_Value = Guid.initString("00000148-0000-0000-c000-000000000046");
pub const IID_IAddrExclusionControl = &IID_IAddrExclusionControl_Value;
pub const IAddrExclusionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentAddrExclusionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrExclusionControl,
                riid: ?*const Guid,
                ppEnumerator: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrExclusionControl,
                riid: ?*const Guid,
                ppEnumerator: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAddrExclusionList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAddrExclusionControl,
                pEnumerator: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAddrExclusionControl,
                pEnumerator: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrExclusionControl_GetCurrentAddrExclusionList(self: *const T, riid: ?*const Guid, ppEnumerator: ?*?*anyopaque) HRESULT {
                return @as(*const IAddrExclusionControl.VTable, @ptrCast(self.vtable)).GetCurrentAddrExclusionList(@as(*const IAddrExclusionControl, @ptrCast(self)), riid, ppEnumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAddrExclusionControl_UpdateAddrExclusionList(self: *const T, pEnumerator: ?*IUnknown) HRESULT {
                return @as(*const IAddrExclusionControl.VTable, @ptrCast(self.vtable)).UpdateAddrExclusionList(@as(*const IAddrExclusionControl, @ptrCast(self)), pEnumerator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeByte_Value = Guid.initString("db2f3aca-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeByte = &IID_IPipeByte_Value;
pub const IPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPipeByte,
                buf: [*:0]u8,
                cRequest: u32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPipeByte,
                buf: [*:0]u8,
                cRequest: u32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPipeByte,
                buf: [*:0]u8,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPipeByte,
                buf: [*:0]u8,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPipeByte_Pull(self: *const T, buf: [*:0]u8, cRequest: u32, pcReturned: ?*u32) HRESULT {
                return @as(*const IPipeByte.VTable, @ptrCast(self.vtable)).Pull(@as(*const IPipeByte, @ptrCast(self)), buf, cRequest, pcReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPipeByte_Push(self: *const T, buf: [*:0]u8, cSent: u32) HRESULT {
                return @as(*const IPipeByte.VTable, @ptrCast(self.vtable)).Push(@as(*const IPipeByte, @ptrCast(self)), buf, cSent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeByte_Value = Guid.initString("db2f3acb-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeByte = &IID_AsyncIPipeByte_Value;
pub const AsyncIPipeByte = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeByte,
                cRequest: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeByte,
                cRequest: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeByte,
                buf: [*:0]u8,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeByte,
                buf: [*:0]u8,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeByte,
                buf: [*:0]u8,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeByte,
                buf: [*:0]u8,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeByte,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeByte,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeByte_Begin_Pull(self: *const T, cRequest: u32) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Begin_Pull(@as(*const AsyncIPipeByte, @ptrCast(self)), cRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeByte_Finish_Pull(self: *const T, buf: [*:0]u8, pcReturned: ?*u32) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Finish_Pull(@as(*const AsyncIPipeByte, @ptrCast(self)), buf, pcReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeByte_Begin_Push(self: *const T, buf: [*:0]u8, cSent: u32) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Begin_Push(@as(*const AsyncIPipeByte, @ptrCast(self)), buf, cSent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeByte_Finish_Push(self: *const T) HRESULT {
                return @as(*const AsyncIPipeByte.VTable, @ptrCast(self.vtable)).Finish_Push(@as(*const AsyncIPipeByte, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeLong_Value = Guid.initString("db2f3acc-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeLong = &IID_IPipeLong_Value;
pub const IPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPipeLong,
                buf: [*]i32,
                cRequest: u32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPipeLong,
                buf: [*]i32,
                cRequest: u32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPipeLong,
                buf: [*]i32,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPipeLong,
                buf: [*]i32,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPipeLong_Pull(self: *const T, buf: [*]i32, cRequest: u32, pcReturned: ?*u32) HRESULT {
                return @as(*const IPipeLong.VTable, @ptrCast(self.vtable)).Pull(@as(*const IPipeLong, @ptrCast(self)), buf, cRequest, pcReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPipeLong_Push(self: *const T, buf: [*]i32, cSent: u32) HRESULT {
                return @as(*const IPipeLong.VTable, @ptrCast(self.vtable)).Push(@as(*const IPipeLong, @ptrCast(self)), buf, cSent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeLong_Value = Guid.initString("db2f3acd-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeLong = &IID_AsyncIPipeLong_Value;
pub const AsyncIPipeLong = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeLong,
                cRequest: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeLong,
                cRequest: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeLong,
                buf: [*]i32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeLong,
                buf: [*]i32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeLong,
                buf: [*]i32,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeLong,
                buf: [*]i32,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeLong,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeLong,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeLong_Begin_Pull(self: *const T, cRequest: u32) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Begin_Pull(@as(*const AsyncIPipeLong, @ptrCast(self)), cRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeLong_Finish_Pull(self: *const T, buf: [*]i32, pcReturned: ?*u32) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Finish_Pull(@as(*const AsyncIPipeLong, @ptrCast(self)), buf, pcReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeLong_Begin_Push(self: *const T, buf: [*]i32, cSent: u32) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Begin_Push(@as(*const AsyncIPipeLong, @ptrCast(self)), buf, cSent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeLong_Finish_Push(self: *const T) HRESULT {
                return @as(*const AsyncIPipeLong.VTable, @ptrCast(self.vtable)).Finish_Push(@as(*const AsyncIPipeLong, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPipeDouble_Value = Guid.initString("db2f3ace-2f86-11d1-8e04-00c04fb9989a");
pub const IID_IPipeDouble = &IID_IPipeDouble_Value;
pub const IPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPipeDouble,
                buf: [*]f64,
                cRequest: u32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPipeDouble,
                buf: [*]f64,
                cRequest: u32,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPipeDouble,
                buf: [*]f64,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPipeDouble,
                buf: [*]f64,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPipeDouble_Pull(self: *const T, buf: [*]f64, cRequest: u32, pcReturned: ?*u32) HRESULT {
                return @as(*const IPipeDouble.VTable, @ptrCast(self.vtable)).Pull(@as(*const IPipeDouble, @ptrCast(self)), buf, cRequest, pcReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPipeDouble_Push(self: *const T, buf: [*]f64, cSent: u32) HRESULT {
                return @as(*const IPipeDouble.VTable, @ptrCast(self.vtable)).Push(@as(*const IPipeDouble, @ptrCast(self)), buf, cSent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIPipeDouble_Value = Guid.initString("db2f3acf-2f86-11d1-8e04-00c04fb9989a");
pub const IID_AsyncIPipeDouble = &IID_AsyncIPipeDouble_Value;
pub const AsyncIPipeDouble = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeDouble,
                cRequest: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeDouble,
                cRequest: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Pull: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeDouble,
                buf: [*]f64,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeDouble,
                buf: [*]f64,
                pcReturned: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeDouble,
                buf: [*]f64,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeDouble,
                buf: [*]f64,
                cSent: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_Push: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIPipeDouble,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIPipeDouble,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeDouble_Begin_Pull(self: *const T, cRequest: u32) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Begin_Pull(@as(*const AsyncIPipeDouble, @ptrCast(self)), cRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeDouble_Finish_Pull(self: *const T, buf: [*]f64, pcReturned: ?*u32) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Finish_Pull(@as(*const AsyncIPipeDouble, @ptrCast(self)), buf, pcReturned);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeDouble_Begin_Push(self: *const T, buf: [*]f64, cSent: u32) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Begin_Push(@as(*const AsyncIPipeDouble, @ptrCast(self)), buf, cSent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIPipeDouble_Finish_Push(self: *const T) HRESULT {
                return @as(*const AsyncIPipeDouble.VTable, @ptrCast(self.vtable)).Finish_Push(@as(*const AsyncIPipeDouble, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APTTYPEQUALIFIER = enum(i32) {
    NONE = 0,
    IMPLICIT_MTA = 1,
    NA_ON_MTA = 2,
    NA_ON_STA = 3,
    NA_ON_IMPLICIT_MTA = 4,
    NA_ON_MAINSTA = 5,
    APPLICATION_STA = 6,
    RESERVED_1 = 7,
};
pub const APTTYPEQUALIFIER_NONE = APTTYPEQUALIFIER.NONE;
pub const APTTYPEQUALIFIER_IMPLICIT_MTA = APTTYPEQUALIFIER.IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MTA = APTTYPEQUALIFIER.NA_ON_MTA;
pub const APTTYPEQUALIFIER_NA_ON_STA = APTTYPEQUALIFIER.NA_ON_STA;
pub const APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = APTTYPEQUALIFIER.NA_ON_IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MAINSTA = APTTYPEQUALIFIER.NA_ON_MAINSTA;
pub const APTTYPEQUALIFIER_APPLICATION_STA = APTTYPEQUALIFIER.APPLICATION_STA;
pub const APTTYPEQUALIFIER_RESERVED_1 = APTTYPEQUALIFIER.RESERVED_1;

pub const APTTYPE = enum(i32) {
    CURRENT = -1,
    STA = 0,
    MTA = 1,
    NA = 2,
    MAINSTA = 3,
};
pub const APTTYPE_CURRENT = APTTYPE.CURRENT;
pub const APTTYPE_STA = APTTYPE.STA;
pub const APTTYPE_MTA = APTTYPE.MTA;
pub const APTTYPE_NA = APTTYPE.NA;
pub const APTTYPE_MAINSTA = APTTYPE.MAINSTA;

pub const THDTYPE = enum(i32) {
    BLOCKMESSAGES = 0,
    PROCESSMESSAGES = 1,
};
pub const THDTYPE_BLOCKMESSAGES = THDTYPE.BLOCKMESSAGES;
pub const THDTYPE_PROCESSMESSAGES = THDTYPE.PROCESSMESSAGES;

// TODO: this type is limited to platform 'windows5.0'
const IID_IComThreadingInfo_Value = Guid.initString("000001ce-0000-0000-c000-000000000046");
pub const IID_IComThreadingInfo = &IID_IComThreadingInfo_Value;
pub const IComThreadingInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentApartmentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComThreadingInfo,
                pAptType: ?*APTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComThreadingInfo,
                pAptType: ?*APTTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComThreadingInfo,
                pThreadType: ?*THDTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComThreadingInfo,
                pThreadType: ?*THDTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentLogicalThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComThreadingInfo,
                pguidLogicalThreadId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComThreadingInfo,
                pguidLogicalThreadId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentLogicalThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComThreadingInfo,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComThreadingInfo,
                rguid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComThreadingInfo_GetCurrentApartmentType(self: *const T, pAptType: ?*APTTYPE) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).GetCurrentApartmentType(@as(*const IComThreadingInfo, @ptrCast(self)), pAptType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComThreadingInfo_GetCurrentThreadType(self: *const T, pThreadType: ?*THDTYPE) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).GetCurrentThreadType(@as(*const IComThreadingInfo, @ptrCast(self)), pThreadType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComThreadingInfo_GetCurrentLogicalThreadId(self: *const T, pguidLogicalThreadId: ?*Guid) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).GetCurrentLogicalThreadId(@as(*const IComThreadingInfo, @ptrCast(self)), pguidLogicalThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComThreadingInfo_SetCurrentLogicalThreadId(self: *const T, rguid: ?*const Guid) HRESULT {
                return @as(*const IComThreadingInfo.VTable, @ptrCast(self.vtable)).SetCurrentLogicalThreadId(@as(*const IComThreadingInfo, @ptrCast(self)), rguid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessInitControl_Value = Guid.initString("72380d55-8d2b-43a3-8513-2b6ef31434e9");
pub const IID_IProcessInitControl = &IID_IProcessInitControl_Value;
pub const IProcessInitControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetInitializerTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessInitControl,
                dwSecondsRemaining: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessInitControl,
                dwSecondsRemaining: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessInitControl_ResetInitializerTimeout(self: *const T, dwSecondsRemaining: u32) HRESULT {
                return @as(*const IProcessInitControl.VTable, @ptrCast(self.vtable)).ResetInitializerTimeout(@as(*const IProcessInitControl, @ptrCast(self)), dwSecondsRemaining);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IFastRundown_Value = Guid.initString("00000040-0000-0000-c000-000000000046");
pub const IID_IFastRundown = &IID_IFastRundown_Value;
pub const IFastRundown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CO_MARSHALING_CONTEXT_ATTRIBUTES = enum(i32) {
    SOURCE_IS_APP_CONTAINER = 0,
    CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
    CONTEXT_ATTRIBUTE_RESERVED_18 = -2147483631,
};
pub const CO_MARSHALING_SOURCE_IS_APP_CONTAINER = CO_MARSHALING_CONTEXT_ATTRIBUTES.SOURCE_IS_APP_CONTAINER;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_1;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_2;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_3;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_4;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_5;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_6;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_7;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_8;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_9;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_10;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_11;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_12;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_13;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_14;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_15;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_16;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_17;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_18 = CO_MARSHALING_CONTEXT_ATTRIBUTES.CONTEXT_ATTRIBUTE_RESERVED_18;

pub const MachineGlobalObjectTableRegistrationToken__ = extern struct {
    unused: i32,
};

const IID_IMachineGlobalObjectTable_Value = Guid.initString("26d709ac-f70b-4421-a96f-d2878fafb00d");
pub const IID_IMachineGlobalObjectTable = &IID_IMachineGlobalObjectTable_Value;
pub const IMachineGlobalObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineGlobalObjectTable,
                clsid: ?*const Guid,
                identifier: ?[*:0]const u16,
                object: ?*IUnknown,
                token: ?*?*MachineGlobalObjectTableRegistrationToken__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineGlobalObjectTable,
                clsid: ?*const Guid,
                identifier: ?[*:0]const u16,
                object: ?*IUnknown,
                token: ?*?*MachineGlobalObjectTableRegistrationToken__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineGlobalObjectTable,
                clsid: ?*const Guid,
                identifier: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineGlobalObjectTable,
                clsid: ?*const Guid,
                identifier: ?[*:0]const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineGlobalObjectTable,
                token: ?*MachineGlobalObjectTableRegistrationToken__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineGlobalObjectTable,
                token: ?*MachineGlobalObjectTableRegistrationToken__,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineGlobalObjectTable_RegisterObject(self: *const T, clsid: ?*const Guid, identifier: ?[*:0]const u16, object: ?*IUnknown, token: ?*?*MachineGlobalObjectTableRegistrationToken__) HRESULT {
                return @as(*const IMachineGlobalObjectTable.VTable, @ptrCast(self.vtable)).RegisterObject(@as(*const IMachineGlobalObjectTable, @ptrCast(self)), clsid, identifier, object, token);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineGlobalObjectTable_GetObject(self: *const T, clsid: ?*const Guid, identifier: ?[*:0]const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IMachineGlobalObjectTable.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IMachineGlobalObjectTable, @ptrCast(self)), clsid, identifier, riid, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineGlobalObjectTable_RevokeObject(self: *const T, token: ?*MachineGlobalObjectTableRegistrationToken__) HRESULT {
                return @as(*const IMachineGlobalObjectTable.VTable, @ptrCast(self.vtable)).RevokeObject(@as(*const IMachineGlobalObjectTable, @ptrCast(self)), token);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMallocSpy_Value = Guid.initString("0000001d-0000-0000-c000-000000000046");
pub const IID_IMallocSpy = &IID_IMallocSpy_Value;
pub const IMallocSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                cbRequest: usize,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn (
                self: *const IMallocSpy,
                cbRequest: usize,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        PostAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pActual: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMallocSpy,
                pActual: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        PreFree: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        PostFree: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMallocSpy,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PreRealloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                cbRequest: usize,
                ppNewRequest: ?*?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                cbRequest: usize,
                ppNewRequest: ?*?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        PostRealloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pActual: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMallocSpy,
                pActual: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        PreGetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        PostGetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                cbActual: usize,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn (
                self: *const IMallocSpy,
                cbActual: usize,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        PreDidAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
        PostDidAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
                fActual: i32,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn (
                self: *const IMallocSpy,
                pRequest: ?*anyopaque,
                fSpyed: BOOL,
                fActual: i32,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        PreHeapMinimize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMallocSpy,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PostHeapMinimize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMallocSpy,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IMallocSpy,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PreAlloc(self: *const T, cbRequest: usize) usize {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreAlloc(@as(*const IMallocSpy, @ptrCast(self)), cbRequest);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PostAlloc(self: *const T, pActual: ?*anyopaque) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostAlloc(@as(*const IMallocSpy, @ptrCast(self)), pActual);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PreFree(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreFree(@as(*const IMallocSpy, @ptrCast(self)), pRequest, fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PostFree(self: *const T, fSpyed: BOOL) void {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostFree(@as(*const IMallocSpy, @ptrCast(self)), fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PreRealloc(self: *const T, pRequest: ?*anyopaque, cbRequest: usize, ppNewRequest: ?*?*anyopaque, fSpyed: BOOL) usize {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreRealloc(@as(*const IMallocSpy, @ptrCast(self)), pRequest, cbRequest, ppNewRequest, fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PostRealloc(self: *const T, pActual: ?*anyopaque, fSpyed: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostRealloc(@as(*const IMallocSpy, @ptrCast(self)), pActual, fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PreGetSize(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreGetSize(@as(*const IMallocSpy, @ptrCast(self)), pRequest, fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PostGetSize(self: *const T, cbActual: usize, fSpyed: BOOL) usize {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostGetSize(@as(*const IMallocSpy, @ptrCast(self)), cbActual, fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PreDidAlloc(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL) ?*anyopaque {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreDidAlloc(@as(*const IMallocSpy, @ptrCast(self)), pRequest, fSpyed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PostDidAlloc(self: *const T, pRequest: ?*anyopaque, fSpyed: BOOL, fActual: i32) i32 {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostDidAlloc(@as(*const IMallocSpy, @ptrCast(self)), pRequest, fSpyed, fActual);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PreHeapMinimize(self: *const T) void {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PreHeapMinimize(@as(*const IMallocSpy, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMallocSpy_PostHeapMinimize(self: *const T) void {
                return @as(*const IMallocSpy.VTable, @ptrCast(self.vtable)).PostHeapMinimize(@as(*const IMallocSpy, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BIND_OPTS = extern struct {
    cbStruct: u32,
    grfFlags: u32,
    grfMode: u32,
    dwTickCountDeadline: u32,
};

pub const BIND_OPTS2 = extern struct {
    __AnonymousBase_objidl_L9017_C36: BIND_OPTS,
    dwTrackFlags: u32,
    dwClassContext: u32,
    locale: u32,
    pServerInfo: ?*COSERVERINFO,
};

pub const BIND_OPTS3 = extern struct {
    __AnonymousBase_objidl_L9041_C36: BIND_OPTS2,
    hwnd: ?HWND,
};

pub const BIND_FLAGS = enum(i32) {
    MAYBOTHERUSER = 1,
    JUSTTESTEXISTENCE = 2,
};
pub const BIND_MAYBOTHERUSER = BIND_FLAGS.MAYBOTHERUSER;
pub const BIND_JUSTTESTEXISTENCE = BIND_FLAGS.JUSTTESTEXISTENCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IBindCtx_Value = Guid.initString("0000000e-0000-0000-c000-000000000046");
pub const IID_IBindCtx = &IID_IBindCtx_Value;
pub const IBindCtx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterObjectBound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeObjectBound: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseBoundObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBindOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                pbindopts: ?*BIND_OPTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                pbindopts: ?*BIND_OPTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                pbindopts: ?*BIND_OPTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                pbindopts: ?*BIND_OPTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningObjectTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                pprot: ?*?*IRunningObjectTable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                pprot: ?*?*IRunningObjectTable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterObjectParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                pszKey: ?PWSTR,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                pszKey: ?PWSTR,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                pszKey: ?PWSTR,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                pszKey: ?PWSTR,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumObjectParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                ppenum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                ppenum: ?*?*IEnumString,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevokeObjectParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindCtx,
                pszKey: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindCtx,
                pszKey: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_RegisterObjectBound(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RegisterObjectBound(@as(*const IBindCtx, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_RevokeObjectBound(self: *const T, punk: ?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RevokeObjectBound(@as(*const IBindCtx, @ptrCast(self)), punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_ReleaseBoundObjects(self: *const T) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).ReleaseBoundObjects(@as(*const IBindCtx, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_SetBindOptions(self: *const T, pbindopts: ?*BIND_OPTS) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).SetBindOptions(@as(*const IBindCtx, @ptrCast(self)), pbindopts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_GetBindOptions(self: *const T, pbindopts: ?*BIND_OPTS) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).GetBindOptions(@as(*const IBindCtx, @ptrCast(self)), pbindopts);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_GetRunningObjectTable(self: *const T, pprot: ?*?*IRunningObjectTable) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).GetRunningObjectTable(@as(*const IBindCtx, @ptrCast(self)), pprot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_RegisterObjectParam(self: *const T, pszKey: ?PWSTR, punk: ?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RegisterObjectParam(@as(*const IBindCtx, @ptrCast(self)), pszKey, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_GetObjectParam(self: *const T, pszKey: ?PWSTR, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).GetObjectParam(@as(*const IBindCtx, @ptrCast(self)), pszKey, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_EnumObjectParam(self: *const T, ppenum: ?*?*IEnumString) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).EnumObjectParam(@as(*const IBindCtx, @ptrCast(self)), ppenum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindCtx_RevokeObjectParam(self: *const T, pszKey: ?PWSTR) HRESULT {
                return @as(*const IBindCtx.VTable, @ptrCast(self.vtable)).RevokeObjectParam(@as(*const IBindCtx, @ptrCast(self)), pszKey);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMoniker_Value = Guid.initString("00000102-0000-0000-c000-000000000046");
pub const IID_IEnumMoniker = &IID_IEnumMoniker_Value;
pub const IEnumMoniker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMoniker,
                celt: u32,
                rgelt: [*]?*IMoniker,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMoniker,
                celt: u32,
                rgelt: [*]?*IMoniker,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMoniker,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMoniker,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumMoniker,
                ppenum: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumMoniker,
                ppenum: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMoniker_Next(self: *const T, celt: u32, rgelt: [*]?*IMoniker, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMoniker, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMoniker_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMoniker, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMoniker_Reset(self: *const T) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMoniker, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumMoniker_Clone(self: *const T, ppenum: ?*?*IEnumMoniker) HRESULT {
                return @as(*const IEnumMoniker.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMoniker, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunnableObject_Value = Guid.initString("00000126-0000-0000-c000-000000000046");
pub const IID_IRunnableObject = &IID_IRunnableObject_Value;
pub const IRunnableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRunningClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableObject,
                lpClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableObject,
                lpClsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableObject,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableObject,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableObject,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IRunnableObject,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        LockRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableObject,
                fLock: BOOL,
                fLastUnlockCloses: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableObject,
                fLock: BOOL,
                fLastUnlockCloses: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContainedObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunnableObject,
                fContained: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunnableObject,
                fContained: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableObject_GetRunningClass(self: *const T, lpClsid: ?*Guid) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).GetRunningClass(@as(*const IRunnableObject, @ptrCast(self)), lpClsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableObject_Run(self: *const T, pbc: ?*IBindCtx) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).Run(@as(*const IRunnableObject, @ptrCast(self)), pbc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableObject_IsRunning(self: *const T) BOOL {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IRunnableObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableObject_LockRunning(self: *const T, fLock: BOOL, fLastUnlockCloses: BOOL) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).LockRunning(@as(*const IRunnableObject, @ptrCast(self)), fLock, fLastUnlockCloses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunnableObject_SetContainedObject(self: *const T, fContained: BOOL) HRESULT {
                return @as(*const IRunnableObject.VTable, @ptrCast(self.vtable)).SetContainedObject(@as(*const IRunnableObject, @ptrCast(self)), fContained);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRunningObjectTable_Value = Guid.initString("00000010-0000-0000-c000-000000000046");
pub const IID_IRunningObjectTable = &IID_IRunningObjectTable_Value;
pub const IRunningObjectTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                grfFlags: u32,
                punkObject: ?*IUnknown,
                pmkObjectName: ?*IMoniker,
                pdwRegister: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                grfFlags: u32,
                punkObject: ?*IUnknown,
                pmkObjectName: ?*IMoniker,
                pdwRegister: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                dwRegister: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                dwRegister: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                pmkObjectName: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                pmkObjectName: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                pmkObjectName: ?*IMoniker,
                ppunkObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                pmkObjectName: ?*IMoniker,
                ppunkObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NoteChangeTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                dwRegister: u32,
                pfiletime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                dwRegister: u32,
                pfiletime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeOfLastChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                pmkObjectName: ?*IMoniker,
                pfiletime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                pmkObjectName: ?*IMoniker,
                pfiletime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRunningObjectTable,
                ppenumMoniker: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRunningObjectTable,
                ppenumMoniker: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_Register(self: *const T, grfFlags: u32, punkObject: ?*IUnknown, pmkObjectName: ?*IMoniker, pdwRegister: ?*u32) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).Register(@as(*const IRunningObjectTable, @ptrCast(self)), grfFlags, punkObject, pmkObjectName, pdwRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_Revoke(self: *const T, dwRegister: u32) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).Revoke(@as(*const IRunningObjectTable, @ptrCast(self)), dwRegister);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_IsRunning(self: *const T, pmkObjectName: ?*IMoniker) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IRunningObjectTable, @ptrCast(self)), pmkObjectName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_GetObject(self: *const T, pmkObjectName: ?*IMoniker, ppunkObject: ?*?*IUnknown) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).GetObject(@as(*const IRunningObjectTable, @ptrCast(self)), pmkObjectName, ppunkObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_NoteChangeTime(self: *const T, dwRegister: u32, pfiletime: ?*FILETIME) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).NoteChangeTime(@as(*const IRunningObjectTable, @ptrCast(self)), dwRegister, pfiletime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_GetTimeOfLastChange(self: *const T, pmkObjectName: ?*IMoniker, pfiletime: ?*FILETIME) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).GetTimeOfLastChange(@as(*const IRunningObjectTable, @ptrCast(self)), pmkObjectName, pfiletime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRunningObjectTable_EnumRunning(self: *const T, ppenumMoniker: ?*?*IEnumMoniker) HRESULT {
                return @as(*const IRunningObjectTable.VTable, @ptrCast(self.vtable)).EnumRunning(@as(*const IRunningObjectTable, @ptrCast(self)), ppenumMoniker);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersist_Value = Guid.initString("0000010c-0000-0000-c000-000000000046");
pub const IID_IPersist = &IID_IPersist_Value;
pub const IPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersist,
                pClassID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersist,
                pClassID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersist_GetClassID(self: *const T, pClassID: ?*Guid) HRESULT {
                return @as(*const IPersist.VTable, @ptrCast(self.vtable)).GetClassID(@as(*const IPersist, @ptrCast(self)), pClassID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStream_Value = Guid.initString("00000109-0000-0000-c000-000000000046");
pub const IID_IPersistStream = &IID_IPersistStream_Value;
pub const IPersistStream = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStream,
                pStm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStream,
                pStm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStream,
                pStm: ?*IStream,
                fClearDirty: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStream,
                pStm: ?*IStream,
                fClearDirty: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSizeMax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStream,
                pcbSize: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStream,
                pcbSize: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStream_IsDirty(self: *const T) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStream, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStream_Load(self: *const T, pStm: ?*IStream) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStream, @ptrCast(self)), pStm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStream_Save(self: *const T, pStm: ?*IStream, fClearDirty: BOOL) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStream, @ptrCast(self)), pStm, fClearDirty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStream_GetSizeMax(self: *const T, pcbSize: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IPersistStream.VTable, @ptrCast(self.vtable)).GetSizeMax(@as(*const IPersistStream, @ptrCast(self)), pcbSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const MKSYS = enum(i32) {
    NONE = 0,
    GENERICCOMPOSITE = 1,
    FILEMONIKER = 2,
    ANTIMONIKER = 3,
    ITEMMONIKER = 4,
    POINTERMONIKER = 5,
    CLASSMONIKER = 7,
    OBJREFMONIKER = 8,
    SESSIONMONIKER = 9,
    LUAMONIKER = 10,
};
pub const MKSYS_NONE = MKSYS.NONE;
pub const MKSYS_GENERICCOMPOSITE = MKSYS.GENERICCOMPOSITE;
pub const MKSYS_FILEMONIKER = MKSYS.FILEMONIKER;
pub const MKSYS_ANTIMONIKER = MKSYS.ANTIMONIKER;
pub const MKSYS_ITEMMONIKER = MKSYS.ITEMMONIKER;
pub const MKSYS_POINTERMONIKER = MKSYS.POINTERMONIKER;
pub const MKSYS_CLASSMONIKER = MKSYS.CLASSMONIKER;
pub const MKSYS_OBJREFMONIKER = MKSYS.OBJREFMONIKER;
pub const MKSYS_SESSIONMONIKER = MKSYS.SESSIONMONIKER;
pub const MKSYS_LUAMONIKER = MKSYS.LUAMONIKER;

pub const MKREDUCE = enum(i32) {
    ONE = 196608,
    TOUSER = 131072,
    THROUGHUSER = 65536,
    ALL = 0,
};
pub const MKRREDUCE_ONE = MKREDUCE.ONE;
pub const MKRREDUCE_TOUSER = MKREDUCE.TOUSER;
pub const MKRREDUCE_THROUGHUSER = MKREDUCE.THROUGHUSER;
pub const MKRREDUCE_ALL = MKREDUCE.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMoniker_Value = Guid.initString("0000000f-0000-0000-c000-000000000046");
pub const IID_IMoniker = &IID_IMoniker_Value;
pub const IMoniker = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        BindToObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                riidResult: ?*const Guid,
                ppvResult: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                riidResult: ?*const Guid,
                ppvResult: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reduce: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                dwReduceHowFar: u32,
                ppmkToLeft: ?*?*IMoniker,
                ppmkReduced: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                dwReduceHowFar: u32,
                ppmkToLeft: ?*?*IMoniker,
                ppmkReduced: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComposeWith: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pmkRight: ?*IMoniker,
                fOnlyIfNotGeneric: BOOL,
                ppmkComposite: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pmkRight: ?*IMoniker,
                fOnlyIfNotGeneric: BOOL,
                ppmkComposite: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enum: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                fForward: BOOL,
                ppenumMoniker: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                fForward: BOOL,
                ppenumMoniker: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pmkOtherMoniker: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pmkOtherMoniker: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Hash: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pdwHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pdwHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                pmkNewlyRunning: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                pmkNewlyRunning: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeOfLastChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                pFileTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                pFileTime: ?*FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Inverse: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                ppmk: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommonPrefixWith: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pmkOther: ?*IMoniker,
                ppmkPrefix: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pmkOther: ?*IMoniker,
                ppmkPrefix: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RelativePathTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pmkOther: ?*IMoniker,
                ppmkRelPath: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pmkOther: ?*IMoniker,
                ppmkRelPath: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                ppszDisplayName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                ppszDisplayName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                pszDisplayName: ?PWSTR,
                pchEaten: ?*u32,
                ppmkOut: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pbc: ?*IBindCtx,
                pmkToLeft: ?*IMoniker,
                pszDisplayName: ?PWSTR,
                pchEaten: ?*u32,
                ppmkOut: ?*?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSystemMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMoniker,
                pdwMksys: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMoniker,
                pdwMksys: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersistStream.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_BindToObject(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, riidResult: ?*const Guid, ppvResult: ?*?*anyopaque) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).BindToObject(@as(*const IMoniker, @ptrCast(self)), pbc, pmkToLeft, riidResult, ppvResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_BindToStorage(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, riid: ?*const Guid, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).BindToStorage(@as(*const IMoniker, @ptrCast(self)), pbc, pmkToLeft, riid, ppvObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_Reduce(self: *const T, pbc: ?*IBindCtx, dwReduceHowFar: u32, ppmkToLeft: ?*?*IMoniker, ppmkReduced: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Reduce(@as(*const IMoniker, @ptrCast(self)), pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_ComposeWith(self: *const T, pmkRight: ?*IMoniker, fOnlyIfNotGeneric: BOOL, ppmkComposite: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).ComposeWith(@as(*const IMoniker, @ptrCast(self)), pmkRight, fOnlyIfNotGeneric, ppmkComposite);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_Enum(self: *const T, fForward: BOOL, ppenumMoniker: ?*?*IEnumMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Enum(@as(*const IMoniker, @ptrCast(self)), fForward, ppenumMoniker);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_IsEqual(self: *const T, pmkOtherMoniker: ?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IMoniker, @ptrCast(self)), pmkOtherMoniker);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_Hash(self: *const T, pdwHash: ?*u32) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Hash(@as(*const IMoniker, @ptrCast(self)), pdwHash);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_IsRunning(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pmkNewlyRunning: ?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).IsRunning(@as(*const IMoniker, @ptrCast(self)), pbc, pmkToLeft, pmkNewlyRunning);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_GetTimeOfLastChange(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pFileTime: ?*FILETIME) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).GetTimeOfLastChange(@as(*const IMoniker, @ptrCast(self)), pbc, pmkToLeft, pFileTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_Inverse(self: *const T, ppmk: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).Inverse(@as(*const IMoniker, @ptrCast(self)), ppmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_CommonPrefixWith(self: *const T, pmkOther: ?*IMoniker, ppmkPrefix: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).CommonPrefixWith(@as(*const IMoniker, @ptrCast(self)), pmkOther, ppmkPrefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_RelativePathTo(self: *const T, pmkOther: ?*IMoniker, ppmkRelPath: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).RelativePathTo(@as(*const IMoniker, @ptrCast(self)), pmkOther, ppmkRelPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_GetDisplayName(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, ppszDisplayName: ?*?PWSTR) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IMoniker, @ptrCast(self)), pbc, pmkToLeft, ppszDisplayName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_ParseDisplayName(self: *const T, pbc: ?*IBindCtx, pmkToLeft: ?*IMoniker, pszDisplayName: ?PWSTR, pchEaten: ?*u32, ppmkOut: ?*?*IMoniker) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).ParseDisplayName(@as(*const IMoniker, @ptrCast(self)), pbc, pmkToLeft, pszDisplayName, pchEaten, ppmkOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMoniker_IsSystemMoniker(self: *const T, pdwMksys: ?*u32) HRESULT {
                return @as(*const IMoniker.VTable, @ptrCast(self.vtable)).IsSystemMoniker(@as(*const IMoniker, @ptrCast(self)), pdwMksys);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IROTData_Value = Guid.initString("f29f6bc0-5021-11ce-aa15-00006901293f");
pub const IID_IROTData = &IID_IROTData_Value;
pub const IROTData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetComparisonData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IROTData,
                pbData: [*:0]u8,
                cbMax: u32,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IROTData,
                pbData: [*:0]u8,
                cbMax: u32,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IROTData_GetComparisonData(self: *const T, pbData: [*:0]u8, cbMax: u32, pcbData: ?*u32) HRESULT {
                return @as(*const IROTData.VTable, @ptrCast(self.vtable)).GetComparisonData(@as(*const IROTData, @ptrCast(self)), pbData, cbMax, pcbData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistFile_Value = Guid.initString("0000010b-0000-0000-c000-000000000046");
pub const IID_IPersistFile = &IID_IPersistFile_Value;
pub const IPersistFile = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFile,
                pszFileName: ?[*:0]const u16,
                dwMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFile,
                pszFileName: ?[*:0]const u16,
                dwMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFile,
                pszFileName: ?[*:0]const u16,
                fRemember: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFile,
                pszFileName: ?[*:0]const u16,
                fRemember: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFile,
                pszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFile,
                pszFileName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistFile,
                ppszFileName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistFile,
                ppszFileName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFile_IsDirty(self: *const T) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistFile, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFile_Load(self: *const T, pszFileName: ?[*:0]const u16, dwMode: u32) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistFile, @ptrCast(self)), pszFileName, dwMode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFile_Save(self: *const T, pszFileName: ?[*:0]const u16, fRemember: BOOL) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistFile, @ptrCast(self)), pszFileName, fRemember);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFile_SaveCompleted(self: *const T, pszFileName: ?[*:0]const u16) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IPersistFile, @ptrCast(self)), pszFileName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistFile_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR) HRESULT {
                return @as(*const IPersistFile.VTable, @ptrCast(self.vtable)).GetCurFile(@as(*const IPersistFile, @ptrCast(self)), ppszFileName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DVTARGETDEVICE = extern struct {
    tdSize: u32,
    tdDriverNameOffset: u16,
    tdDeviceNameOffset: u16,
    tdPortNameOffset: u16,
    tdExtDevmodeOffset: u16,
    tdData: [1]u8,
};

pub const FORMATETC = extern struct {
    cfFormat: u16,
    ptd: ?*DVTARGETDEVICE,
    dwAspect: u32,
    lindex: i32,
    tymed: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFORMATETC_Value = Guid.initString("00000103-0000-0000-c000-000000000046");
pub const IID_IEnumFORMATETC = &IID_IEnumFORMATETC_Value;
pub const IEnumFORMATETC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFORMATETC,
                celt: u32,
                rgelt: [*]FORMATETC,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFORMATETC,
                celt: u32,
                rgelt: [*]FORMATETC,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFORMATETC,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFORMATETC,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumFORMATETC,
                ppenum: ?*?*IEnumFORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumFORMATETC,
                ppenum: ?*?*IEnumFORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFORMATETC_Next(self: *const T, celt: u32, rgelt: [*]FORMATETC, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFORMATETC, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFORMATETC_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFORMATETC, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFORMATETC_Reset(self: *const T) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFORMATETC, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumFORMATETC_Clone(self: *const T, ppenum: ?*?*IEnumFORMATETC) HRESULT {
                return @as(*const IEnumFORMATETC.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFORMATETC, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ADVF = enum(i32) {
    _NODATA = 1,
    _PRIMEFIRST = 2,
    _ONLYONCE = 4,
    _DATAONSTOP = 64,
    CACHE_NOHANDLER = 8,
    CACHE_FORCEBUILTIN = 16,
    CACHE_ONSAVE = 32,
};
pub const ADVF_NODATA = ADVF._NODATA;
pub const ADVF_PRIMEFIRST = ADVF._PRIMEFIRST;
pub const ADVF_ONLYONCE = ADVF._ONLYONCE;
pub const ADVF_DATAONSTOP = ADVF._DATAONSTOP;
pub const ADVFCACHE_NOHANDLER = ADVF.CACHE_NOHANDLER;
pub const ADVFCACHE_FORCEBUILTIN = ADVF.CACHE_FORCEBUILTIN;
pub const ADVFCACHE_ONSAVE = ADVF.CACHE_ONSAVE;

pub const STATDATA = extern struct {
    formatetc: FORMATETC,
    advf: u32,
    pAdvSink: ?*IAdviseSink,
    dwConnection: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATDATA_Value = Guid.initString("00000105-0000-0000-c000-000000000046");
pub const IID_IEnumSTATDATA = &IID_IEnumSTATDATA_Value;
pub const IEnumSTATDATA = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSTATDATA,
                celt: u32,
                rgelt: [*]STATDATA,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSTATDATA,
                celt: u32,
                rgelt: [*]STATDATA,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSTATDATA,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSTATDATA,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumSTATDATA,
                ppenum: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumSTATDATA,
                ppenum: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSTATDATA_Next(self: *const T, celt: u32, rgelt: [*]STATDATA, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATDATA, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSTATDATA_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATDATA, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSTATDATA_Reset(self: *const T) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATDATA, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumSTATDATA_Clone(self: *const T, ppenum: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IEnumSTATDATA.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATDATA, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const TYMED = enum(i32) {
    HGLOBAL = 1,
    FILE = 2,
    ISTREAM = 4,
    ISTORAGE = 8,
    GDI = 16,
    MFPICT = 32,
    ENHMF = 64,
    NULL = 0,
};
pub const TYMED_HGLOBAL = TYMED.HGLOBAL;
pub const TYMED_FILE = TYMED.FILE;
pub const TYMED_ISTREAM = TYMED.ISTREAM;
pub const TYMED_ISTORAGE = TYMED.ISTORAGE;
pub const TYMED_GDI = TYMED.GDI;
pub const TYMED_MFPICT = TYMED.MFPICT;
pub const TYMED_ENHMF = TYMED.ENHMF;
pub const TYMED_NULL = TYMED.NULL;

pub const RemSTGMEDIUM = extern struct {
    tymed: u32,
    dwHandleType: u32,
    pData: u32,
    pUnkForRelease: u32,
    cbData: u32,
    data: [1]u8,
};

pub const STGMEDIUM = extern struct {
    tymed: u32,
    Anonymous: extern union {
        hBitmap: ?HBITMAP,
        hMetaFilePict: ?*anyopaque,
        hEnhMetaFile: ?HENHMETAFILE,
        hGlobal: isize,
        lpszFileName: ?PWSTR,
        pstm: ?*IStream,
        pstg: ?*IStorage,
    },
    pUnkForRelease: ?*IUnknown,
};

pub const GDI_OBJECT = extern struct {
    ObjectType: u32,
    u: extern struct {
        hBitmap: ?*userHBITMAP,
        hPalette: ?*userHPALETTE,
        hGeneric: ?*userHGLOBAL,
    },
};

pub const userSTGMEDIUM = extern struct {
    pub const _STGMEDIUM_UNION = extern struct {
        tymed: u32,
        u: extern struct {
            hMetaFilePict: ?*userHMETAFILEPICT,
            hHEnhMetaFile: ?*userHENHMETAFILE,
            hGdiHandle: ?*GDI_OBJECT,
            hGlobal: ?*userHGLOBAL,
            lpszFileName: ?PWSTR,
            pstm: ?*BYTE_BLOB,
            pstg: ?*BYTE_BLOB,
        },
    };
    pUnkForRelease: ?*IUnknown,
};

pub const userFLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: userSTGMEDIUM,
};

pub const FLAG_STGMEDIUM = extern struct {
    ContextFlags: i32,
    fPassOwnership: i32,
    Stgmed: STGMEDIUM,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink_Value = Guid.initString("0000010f-0000-0000-c000-000000000046");
pub const IID_IAdviseSink = &IID_IAdviseSink_Value;
pub const IAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDataChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSink,
                pFormatetc: ?*FORMATETC,
                pStgmed: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSink,
                pFormatetc: ?*FORMATETC,
                pStgmed: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnViewChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSink,
                dwAspect: u32,
                lindex: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSink,
                dwAspect: u32,
                lindex: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnRename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSink,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSink,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSink_OnDataChange(self: *const T, pFormatetc: ?*FORMATETC, pStgmed: ?*STGMEDIUM) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnDataChange(@as(*const IAdviseSink, @ptrCast(self)), pFormatetc, pStgmed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSink_OnViewChange(self: *const T, dwAspect: u32, lindex: i32) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnViewChange(@as(*const IAdviseSink, @ptrCast(self)), dwAspect, lindex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSink_OnRename(self: *const T, pmk: ?*IMoniker) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnRename(@as(*const IAdviseSink, @ptrCast(self)), pmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSink_OnSave(self: *const T) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnSave(@as(*const IAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSink_OnClose(self: *const T) void {
                return @as(*const IAdviseSink.VTable, @ptrCast(self.vtable)).OnClose(@as(*const IAdviseSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink_Value = Guid.initString("00000150-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink = &IID_AsyncIAdviseSink_Value;
pub const AsyncIAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_OnDataChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
                pFormatetc: ?*FORMATETC,
                pStgmed: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
                pFormatetc: ?*FORMATETC,
                pStgmed: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Finish_OnDataChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Begin_OnViewChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
                dwAspect: u32,
                lindex: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
                dwAspect: u32,
                lindex: i32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Finish_OnViewChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Begin_OnRename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Finish_OnRename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Begin_OnSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Finish_OnSave: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Begin_OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Finish_OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Begin_OnDataChange(self: *const T, pFormatetc: ?*FORMATETC, pStgmed: ?*STGMEDIUM) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnDataChange(@as(*const AsyncIAdviseSink, @ptrCast(self)), pFormatetc, pStgmed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Finish_OnDataChange(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnDataChange(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Begin_OnViewChange(self: *const T, dwAspect: u32, lindex: i32) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnViewChange(@as(*const AsyncIAdviseSink, @ptrCast(self)), dwAspect, lindex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Finish_OnViewChange(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnViewChange(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Begin_OnRename(self: *const T, pmk: ?*IMoniker) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnRename(@as(*const AsyncIAdviseSink, @ptrCast(self)), pmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Finish_OnRename(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnRename(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Begin_OnSave(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnSave(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Finish_OnSave(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnSave(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Begin_OnClose(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Begin_OnClose(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink_Finish_OnClose(self: *const T) void {
                return @as(*const AsyncIAdviseSink.VTable, @ptrCast(self.vtable)).Finish_OnClose(@as(*const AsyncIAdviseSink, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAdviseSink2_Value = Guid.initString("00000125-0000-0000-c000-000000000046");
pub const IID_IAdviseSink2 = &IID_IAdviseSink2_Value;
pub const IAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: IAdviseSink.VTable,
        OnLinkSrcChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAdviseSink2,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IAdviseSink2,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAdviseSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAdviseSink2_OnLinkSrcChange(self: *const T, pmk: ?*IMoniker) void {
                return @as(*const IAdviseSink2.VTable, @ptrCast(self.vtable)).OnLinkSrcChange(@as(*const IAdviseSink2, @ptrCast(self)), pmk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIAdviseSink2_Value = Guid.initString("00000151-0000-0000-c000-000000000046");
pub const IID_AsyncIAdviseSink2 = &IID_AsyncIAdviseSink2_Value;
pub const AsyncIAdviseSink2 = extern struct {
    pub const VTable = extern struct {
        base: AsyncIAdviseSink.VTable,
        Begin_OnLinkSrcChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink2,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink2,
                pmk: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Finish_OnLinkSrcChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIAdviseSink2,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const AsyncIAdviseSink2,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace AsyncIAdviseSink.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink2_Begin_OnLinkSrcChange(self: *const T, pmk: ?*IMoniker) void {
                return @as(*const AsyncIAdviseSink2.VTable, @ptrCast(self.vtable)).Begin_OnLinkSrcChange(@as(*const AsyncIAdviseSink2, @ptrCast(self)), pmk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIAdviseSink2_Finish_OnLinkSrcChange(self: *const T) void {
                return @as(*const AsyncIAdviseSink2.VTable, @ptrCast(self.vtable)).Finish_OnLinkSrcChange(@as(*const AsyncIAdviseSink2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DATADIR = enum(i32) {
    GET = 1,
    SET = 2,
};
pub const DATADIR_GET = DATADIR.GET;
pub const DATADIR_SET = DATADIR.SET;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataObject_Value = Guid.initString("0000010e-0000-0000-c000-000000000046");
pub const IID_IDataObject = &IID_IDataObject_Value;
pub const IDataObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                pformatetcIn: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                pformatetcIn: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataHere: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryGetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCanonicalFormatEtc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                pformatectIn: ?*FORMATETC,
                pformatetcOut: ?*FORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                pformatectIn: ?*FORMATETC,
                pformatetcOut: ?*FORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
                fRelease: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
                pmedium: ?*STGMEDIUM,
                fRelease: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFormatEtc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                dwDirection: u32,
                ppenumFormatEtc: ?*?*IEnumFORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                dwDirection: u32,
                ppenumFormatEtc: ?*?*IEnumFORMATETC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
                advf: u32,
                pAdvSink: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                pformatetc: ?*FORMATETC,
                advf: u32,
                pAdvSink: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DUnadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataObject,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataObject,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_GetData(self: *const T, pformatetcIn: ?*FORMATETC, pmedium: ?*STGMEDIUM) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).GetData(@as(*const IDataObject, @ptrCast(self)), pformatetcIn, pmedium);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_GetDataHere(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).GetDataHere(@as(*const IDataObject, @ptrCast(self)), pformatetc, pmedium);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_QueryGetData(self: *const T, pformatetc: ?*FORMATETC) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).QueryGetData(@as(*const IDataObject, @ptrCast(self)), pformatetc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_GetCanonicalFormatEtc(self: *const T, pformatectIn: ?*FORMATETC, pformatetcOut: ?*FORMATETC) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).GetCanonicalFormatEtc(@as(*const IDataObject, @ptrCast(self)), pformatectIn, pformatetcOut);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_SetData(self: *const T, pformatetc: ?*FORMATETC, pmedium: ?*STGMEDIUM, fRelease: BOOL) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).SetData(@as(*const IDataObject, @ptrCast(self)), pformatetc, pmedium, fRelease);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_EnumFormatEtc(self: *const T, dwDirection: u32, ppenumFormatEtc: ?*?*IEnumFORMATETC) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).EnumFormatEtc(@as(*const IDataObject, @ptrCast(self)), dwDirection, ppenumFormatEtc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_DAdvise(self: *const T, pformatetc: ?*FORMATETC, advf: u32, pAdvSink: ?*IAdviseSink, pdwConnection: ?*u32) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).DAdvise(@as(*const IDataObject, @ptrCast(self)), pformatetc, advf, pAdvSink, pdwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_DUnadvise(self: *const T, dwConnection: u32) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).DUnadvise(@as(*const IDataObject, @ptrCast(self)), dwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataObject_EnumDAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IDataObject.VTable, @ptrCast(self.vtable)).EnumDAdvise(@as(*const IDataObject, @ptrCast(self)), ppenumAdvise);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDataAdviseHolder_Value = Guid.initString("00000110-0000-0000-c000-000000000046");
pub const IID_IDataAdviseHolder = &IID_IDataAdviseHolder_Value;
pub const IDataAdviseHolder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataAdviseHolder,
                pDataObject: ?*IDataObject,
                pFetc: ?*FORMATETC,
                advf: u32,
                pAdvise: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataAdviseHolder,
                pDataObject: ?*IDataObject,
                pFetc: ?*FORMATETC,
                advf: u32,
                pAdvise: ?*IAdviseSink,
                pdwConnection: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataAdviseHolder,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataAdviseHolder,
                dwConnection: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataAdviseHolder,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataAdviseHolder,
                ppenumAdvise: ?*?*IEnumSTATDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendOnDataChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataAdviseHolder,
                pDataObject: ?*IDataObject,
                dwReserved: u32,
                advf: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataAdviseHolder,
                pDataObject: ?*IDataObject,
                dwReserved: u32,
                advf: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataAdviseHolder_Advise(self: *const T, pDataObject: ?*IDataObject, pFetc: ?*FORMATETC, advf: u32, pAdvise: ?*IAdviseSink, pdwConnection: ?*u32) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).Advise(@as(*const IDataAdviseHolder, @ptrCast(self)), pDataObject, pFetc, advf, pAdvise, pdwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataAdviseHolder_Unadvise(self: *const T, dwConnection: u32) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IDataAdviseHolder, @ptrCast(self)), dwConnection);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataAdviseHolder_EnumAdvise(self: *const T, ppenumAdvise: ?*?*IEnumSTATDATA) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).EnumAdvise(@as(*const IDataAdviseHolder, @ptrCast(self)), ppenumAdvise);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataAdviseHolder_SendOnDataChange(self: *const T, pDataObject: ?*IDataObject, dwReserved: u32, advf: u32) HRESULT {
                return @as(*const IDataAdviseHolder.VTable, @ptrCast(self.vtable)).SendOnDataChange(@as(*const IDataAdviseHolder, @ptrCast(self)), pDataObject, dwReserved, advf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CALLTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
    ASYNC = 3,
    TOPLEVEL_CALLPENDING = 4,
    ASYNC_CALLPENDING = 5,
};
pub const CALLTYPE_TOPLEVEL = CALLTYPE.TOPLEVEL;
pub const CALLTYPE_NESTED = CALLTYPE.NESTED;
pub const CALLTYPE_ASYNC = CALLTYPE.ASYNC;
pub const CALLTYPE_TOPLEVEL_CALLPENDING = CALLTYPE.TOPLEVEL_CALLPENDING;
pub const CALLTYPE_ASYNC_CALLPENDING = CALLTYPE.ASYNC_CALLPENDING;

pub const SERVERCALL = enum(i32) {
    ISHANDLED = 0,
    REJECTED = 1,
    RETRYLATER = 2,
};
pub const SERVERCALL_ISHANDLED = SERVERCALL.ISHANDLED;
pub const SERVERCALL_REJECTED = SERVERCALL.REJECTED;
pub const SERVERCALL_RETRYLATER = SERVERCALL.RETRYLATER;

pub const PENDINGTYPE = enum(i32) {
    TOPLEVEL = 1,
    NESTED = 2,
};
pub const PENDINGTYPE_TOPLEVEL = PENDINGTYPE.TOPLEVEL;
pub const PENDINGTYPE_NESTED = PENDINGTYPE.NESTED;

pub const PENDINGMSG = enum(i32) {
    CANCELCALL = 0,
    WAITNOPROCESS = 1,
    WAITDEFPROCESS = 2,
};
pub const PENDINGMSG_CANCELCALL = PENDINGMSG.CANCELCALL;
pub const PENDINGMSG_WAITNOPROCESS = PENDINGMSG.WAITNOPROCESS;
pub const PENDINGMSG_WAITDEFPROCESS = PENDINGMSG.WAITDEFPROCESS;

pub const INTERFACEINFO = extern struct {
    pUnk: ?*IUnknown,
    iid: Guid,
    wMethod: u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IClassActivator_Value = Guid.initString("00000140-0000-0000-c000-000000000046");
pub const IID_IClassActivator = &IID_IClassActivator_Value;
pub const IClassActivator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IClassActivator,
                rclsid: ?*const Guid,
                dwClassContext: u32,
                locale: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IClassActivator,
                rclsid: ?*const Guid,
                dwClassContext: u32,
                locale: u32,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IClassActivator_GetClassObject(self: *const T, rclsid: ?*const Guid, dwClassContext: u32, locale: u32, riid: ?*const Guid, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const IClassActivator.VTable, @ptrCast(self.vtable)).GetClassObject(@as(*const IClassActivator, @ptrCast(self)), rclsid, dwClassContext, locale, riid, ppv);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IProgressNotify_Value = Guid.initString("a9d758a0-4617-11cf-95fc-00aa00680db4");
pub const IID_IProgressNotify = &IID_IProgressNotify_Value;
pub const IProgressNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProgressNotify,
                dwProgressCurrent: u32,
                dwProgressMaximum: u32,
                fAccurate: BOOL,
                fOwner: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProgressNotify,
                dwProgressCurrent: u32,
                dwProgressMaximum: u32,
                fAccurate: BOOL,
                fOwner: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProgressNotify_OnProgress(self: *const T, dwProgressCurrent: u32, dwProgressMaximum: u32, fAccurate: BOOL, fOwner: BOOL) HRESULT {
                return @as(*const IProgressNotify.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IProgressNotify, @ptrCast(self)), dwProgressCurrent, dwProgressMaximum, fAccurate, fOwner);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const StorageLayout = extern struct {
    LayoutType: u32,
    pwcsElementName: ?PWSTR,
    cOffset: LARGE_INTEGER,
    cBytes: LARGE_INTEGER,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBlockingLock_Value = Guid.initString("30f3d47a-6447-11d1-8e3c-00c04fb9386d");
pub const IID_IBlockingLock = &IID_IBlockingLock_Value;
pub const IBlockingLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBlockingLock,
                dwTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBlockingLock,
                dwTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBlockingLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBlockingLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBlockingLock_Lock(self: *const T, dwTimeout: u32) HRESULT {
                return @as(*const IBlockingLock.VTable, @ptrCast(self.vtable)).Lock(@as(*const IBlockingLock, @ptrCast(self)), dwTimeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBlockingLock_Unlock(self: *const T) HRESULT {
                return @as(*const IBlockingLock.VTable, @ptrCast(self.vtable)).Unlock(@as(*const IBlockingLock, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimeAndNoticeControl_Value = Guid.initString("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4");
pub const IID_ITimeAndNoticeControl = &IID_ITimeAndNoticeControl_Value;
pub const ITimeAndNoticeControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuppressChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITimeAndNoticeControl,
                res1: u32,
                res2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITimeAndNoticeControl,
                res1: u32,
                res2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITimeAndNoticeControl_SuppressChanges(self: *const T, res1: u32, res2: u32) HRESULT {
                return @as(*const ITimeAndNoticeControl.VTable, @ptrCast(self.vtable)).SuppressChanges(@as(*const ITimeAndNoticeControl, @ptrCast(self)), res1, res2);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IOplockStorage_Value = Guid.initString("8d19c834-8879-11d1-83e9-00c04fc2c6d4");
pub const IID_IOplockStorage = &IID_IOplockStorage_Value;
pub const IOplockStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStorageEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOplockStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: u32,
                stgfmt: u32,
                grfAttrs: u32,
                riid: ?*const Guid,
                ppstgOpen: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOplockStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: u32,
                stgfmt: u32,
                grfAttrs: u32,
                riid: ?*const Guid,
                ppstgOpen: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStorageEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IOplockStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: u32,
                stgfmt: u32,
                grfAttrs: u32,
                riid: ?*const Guid,
                ppstgOpen: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IOplockStorage,
                pwcsName: ?[*:0]const u16,
                grfMode: u32,
                stgfmt: u32,
                grfAttrs: u32,
                riid: ?*const Guid,
                ppstgOpen: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOplockStorage_CreateStorageEx(self: *const T, pwcsName: ?[*:0]const u16, grfMode: u32, stgfmt: u32, grfAttrs: u32, riid: ?*const Guid, ppstgOpen: ?*?*anyopaque) HRESULT {
                return @as(*const IOplockStorage.VTable, @ptrCast(self.vtable)).CreateStorageEx(@as(*const IOplockStorage, @ptrCast(self)), pwcsName, grfMode, stgfmt, grfAttrs, riid, ppstgOpen);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IOplockStorage_OpenStorageEx(self: *const T, pwcsName: ?[*:0]const u16, grfMode: u32, stgfmt: u32, grfAttrs: u32, riid: ?*const Guid, ppstgOpen: ?*?*anyopaque) HRESULT {
                return @as(*const IOplockStorage.VTable, @ptrCast(self.vtable)).OpenStorageEx(@as(*const IOplockStorage, @ptrCast(self)), pwcsName, grfMode, stgfmt, grfAttrs, riid, ppstgOpen);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlMon_Value = Guid.initString("00000026-0000-0000-c000-000000000046");
pub const IID_IUrlMon = &IID_IUrlMon_Value;
pub const IUrlMon = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AsyncGetClassBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUrlMon,
                rclsid: ?*const Guid,
                pszTYPE: ?[*:0]const u16,
                pszExt: ?[*:0]const u16,
                dwFileVersionMS: u32,
                dwFileVersionLS: u32,
                pszCodeBase: ?[*:0]const u16,
                pbc: ?*IBindCtx,
                dwClassContext: u32,
                riid: ?*const Guid,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUrlMon,
                rclsid: ?*const Guid,
                pszTYPE: ?[*:0]const u16,
                pszExt: ?[*:0]const u16,
                dwFileVersionMS: u32,
                dwFileVersionLS: u32,
                pszCodeBase: ?[*:0]const u16,
                pbc: ?*IBindCtx,
                dwClassContext: u32,
                riid: ?*const Guid,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUrlMon_AsyncGetClassBits(self: *const T, rclsid: ?*const Guid, pszTYPE: ?[*:0]const u16, pszExt: ?[*:0]const u16, dwFileVersionMS: u32, dwFileVersionLS: u32, pszCodeBase: ?[*:0]const u16, pbc: ?*IBindCtx, dwClassContext: u32, riid: ?*const Guid, flags: u32) HRESULT {
                return @as(*const IUrlMon.VTable, @ptrCast(self.vtable)).AsyncGetClassBits(@as(*const IUrlMon, @ptrCast(self)), rclsid, pszTYPE, pszExt, dwFileVersionMS, dwFileVersionLS, pszCodeBase, pbc, dwClassContext, riid, flags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IForegroundTransfer_Value = Guid.initString("00000145-0000-0000-c000-000000000046");
pub const IID_IForegroundTransfer = &IID_IForegroundTransfer_Value;
pub const IForegroundTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllowForegroundTransfer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IForegroundTransfer,
                lpvReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IForegroundTransfer,
                lpvReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IForegroundTransfer_AllowForegroundTransfer(self: *const T, lpvReserved: ?*anyopaque) HRESULT {
                return @as(*const IForegroundTransfer.VTable, @ptrCast(self.vtable)).AllowForegroundTransfer(@as(*const IForegroundTransfer, @ptrCast(self)), lpvReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ApplicationType = enum(i32) {
    ServerApplication = 0,
    LibraryApplication = 1,
};
pub const ServerApplication = ApplicationType.ServerApplication;
pub const LibraryApplication = ApplicationType.LibraryApplication;

pub const ShutdownType = enum(i32) {
    IdleShutdown = 0,
    ForcedShutdown = 1,
};
pub const IdleShutdown = ShutdownType.IdleShutdown;
pub const ForcedShutdown = ShutdownType.ForcedShutdown;

// TODO: this type is limited to platform 'windows5.0'
const IID_IProcessLock_Value = Guid.initString("000001d5-0000-0000-c000-000000000046");
pub const IID_IProcessLock = &IID_IProcessLock_Value;
pub const IProcessLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefOnProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessLock,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IProcessLock,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        ReleaseRefOnProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessLock,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const IProcessLock,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessLock_AddRefOnProcess(self: *const T) u32 {
                return @as(*const IProcessLock.VTable, @ptrCast(self.vtable)).AddRefOnProcess(@as(*const IProcessLock, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessLock_ReleaseRefOnProcess(self: *const T) u32 {
                return @as(*const IProcessLock.VTable, @ptrCast(self.vtable)).ReleaseRefOnProcess(@as(*const IProcessLock, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISurrogateService_Value = Guid.initString("000001d4-0000-0000-c000-000000000046");
pub const IID_ISurrogateService = &IID_ISurrogateService_Value;
pub const ISurrogateService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogateService,
                rguidProcessID: ?*const Guid,
                pProcessLock: ?*IProcessLock,
                pfApplicationAware: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogateService,
                rguidProcessID: ?*const Guid,
                pProcessLock: ?*IProcessLock,
                pfApplicationAware: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplicationLaunch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogateService,
                rguidApplID: ?*const Guid,
                appType: ApplicationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogateService,
                rguidApplID: ?*const Guid,
                appType: ApplicationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplicationFree: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogateService,
                rguidApplID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogateService,
                rguidApplID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CatalogRefresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogateService,
                ulReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogateService,
                ulReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessShutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISurrogateService,
                shutdownType: ShutdownType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISurrogateService,
                shutdownType: ShutdownType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogateService_Init(self: *const T, rguidProcessID: ?*const Guid, pProcessLock: ?*IProcessLock, pfApplicationAware: ?*BOOL) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).Init(@as(*const ISurrogateService, @ptrCast(self)), rguidProcessID, pProcessLock, pfApplicationAware);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogateService_ApplicationLaunch(self: *const T, rguidApplID: ?*const Guid, appType: ApplicationType) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).ApplicationLaunch(@as(*const ISurrogateService, @ptrCast(self)), rguidApplID, appType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogateService_ApplicationFree(self: *const T, rguidApplID: ?*const Guid) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).ApplicationFree(@as(*const ISurrogateService, @ptrCast(self)), rguidApplID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogateService_CatalogRefresh(self: *const T, ulReserved: u32) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).CatalogRefresh(@as(*const ISurrogateService, @ptrCast(self)), ulReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISurrogateService_ProcessShutdown(self: *const T, shutdownType: ShutdownType) HRESULT {
                return @as(*const ISurrogateService.VTable, @ptrCast(self.vtable)).ProcessShutdown(@as(*const ISurrogateService, @ptrCast(self)), shutdownType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IInitializeSpy_Value = Guid.initString("00000034-0000-0000-c000-000000000046");
pub const IID_IInitializeSpy = &IID_IInitializeSpy_Value;
pub const IInitializeSpy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreInitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeSpy,
                dwCoInit: u32,
                dwCurThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeSpy,
                dwCoInit: u32,
                dwCurThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostInitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeSpy,
                hrCoInit: HRESULT,
                dwCoInit: u32,
                dwNewThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeSpy,
                hrCoInit: HRESULT,
                dwCoInit: u32,
                dwNewThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreUninitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeSpy,
                dwCurThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeSpy,
                dwCurThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostUninitialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IInitializeSpy,
                dwNewThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IInitializeSpy,
                dwNewThreadAptRefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeSpy_PreInitialize(self: *const T, dwCoInit: u32, dwCurThreadAptRefs: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PreInitialize(@as(*const IInitializeSpy, @ptrCast(self)), dwCoInit, dwCurThreadAptRefs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeSpy_PostInitialize(self: *const T, hrCoInit: HRESULT, dwCoInit: u32, dwNewThreadAptRefs: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PostInitialize(@as(*const IInitializeSpy, @ptrCast(self)), hrCoInit, dwCoInit, dwNewThreadAptRefs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeSpy_PreUninitialize(self: *const T, dwCurThreadAptRefs: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PreUninitialize(@as(*const IInitializeSpy, @ptrCast(self)), dwCurThreadAptRefs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IInitializeSpy_PostUninitialize(self: *const T, dwNewThreadAptRefs: u32) HRESULT {
                return @as(*const IInitializeSpy.VTable, @ptrCast(self.vtable)).PostUninitialize(@as(*const IInitializeSpy, @ptrCast(self)), dwNewThreadAptRefs);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COINIT = enum(u32) {
    APARTMENTTHREADED = 2,
    MULTITHREADED = 0,
    DISABLE_OLE1DDE = 4,
    SPEED_OVER_MEMORY = 8,
    _,
    pub fn initFlags(o: struct {
        APARTMENTTHREADED: u1 = 0,
        MULTITHREADED: u1 = 0,
        DISABLE_OLE1DDE: u1 = 0,
        SPEED_OVER_MEMORY: u1 = 0,
    }) COINIT {
        return @as(COINIT, @enumFromInt((if (o.APARTMENTTHREADED == 1) @intFromEnum(COINIT.APARTMENTTHREADED) else 0) | (if (o.MULTITHREADED == 1) @intFromEnum(COINIT.MULTITHREADED) else 0) | (if (o.DISABLE_OLE1DDE == 1) @intFromEnum(COINIT.DISABLE_OLE1DDE) else 0) | (if (o.SPEED_OVER_MEMORY == 1) @intFromEnum(COINIT.SPEED_OVER_MEMORY) else 0)));
    }
};
pub const COINIT_APARTMENTTHREADED = COINIT.APARTMENTTHREADED;
pub const COINIT_MULTITHREADED = COINIT.MULTITHREADED;
pub const COINIT_DISABLE_OLE1DDE = COINIT.DISABLE_OLE1DDE;
pub const COINIT_SPEED_OVER_MEMORY = COINIT.SPEED_OVER_MEMORY;

pub const COMSD = enum(i32) {
    LAUNCHPERMISSIONS = 0,
    ACCESSPERMISSIONS = 1,
    LAUNCHRESTRICTIONS = 2,
    ACCESSRESTRICTIONS = 3,
};
pub const SD_LAUNCHPERMISSIONS = COMSD.LAUNCHPERMISSIONS;
pub const SD_ACCESSPERMISSIONS = COMSD.ACCESSPERMISSIONS;
pub const SD_LAUNCHRESTRICTIONS = COMSD.LAUNCHRESTRICTIONS;
pub const SD_ACCESSRESTRICTIONS = COMSD.ACCESSRESTRICTIONS;

const IID_IServiceProvider_Value = Guid.initString("6d5140c1-7436-11ce-8034-00aa006009fa");
pub const IID_IServiceProvider = &IID_IServiceProvider_Value;
pub const IServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IServiceProvider,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IServiceProvider,
                guidService: ?*const Guid,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IServiceProvider_QueryService(self: *const T, guidService: ?*const Guid, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IServiceProvider.VTable, @ptrCast(self.vtable)).QueryService(@as(*const IServiceProvider, @ptrCast(self)), guidService, riid, ppvObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const COWAIT_FLAGS = enum(i32) {
    DEFAULT = 0,
    WAITALL = 1,
    ALERTABLE = 2,
    INPUTAVAILABLE = 4,
    DISPATCH_CALLS = 8,
    DISPATCH_WINDOW_MESSAGES = 16,
};
pub const COWAIT_DEFAULT = COWAIT_FLAGS.DEFAULT;
pub const COWAIT_WAITALL = COWAIT_FLAGS.WAITALL;
pub const COWAIT_ALERTABLE = COWAIT_FLAGS.ALERTABLE;
pub const COWAIT_INPUTAVAILABLE = COWAIT_FLAGS.INPUTAVAILABLE;
pub const COWAIT_DISPATCH_CALLS = COWAIT_FLAGS.DISPATCH_CALLS;
pub const COWAIT_DISPATCH_WINDOW_MESSAGES = COWAIT_FLAGS.DISPATCH_WINDOW_MESSAGES;

pub const CWMO_FLAGS = enum(i32) {
    EFAULT = 0,
    ISPATCH_CALLS = 1,
    ISPATCH_WINDOW_MESSAGES = 2,
};
pub const CWMO_DEFAULT = CWMO_FLAGS.EFAULT;
pub const CWMO_DISPATCH_CALLS = CWMO_FLAGS.ISPATCH_CALLS;
pub const CWMO_DISPATCH_WINDOW_MESSAGES = CWMO_FLAGS.ISPATCH_WINDOW_MESSAGES;

pub const LPFNGETCLASSOBJECT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*const Guid,
        param1: ?*const Guid,
        param2: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        param0: ?*const Guid,
        param1: ?*const Guid,
        param2: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const LPFNCANUNLOADNOW = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) HRESULT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumGUID_Value = Guid.initString("0002e000-0000-0000-c000-000000000046");
pub const IID_IEnumGUID = &IID_IEnumGUID_Value;
pub const IEnumGUID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumGUID,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumGUID,
                celt: u32,
                rgelt: [*]Guid,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumGUID,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumGUID,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumGUID,
                ppenum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumGUID,
                ppenum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumGUID_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumGUID, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumGUID_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumGUID, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumGUID_Reset(self: *const T) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumGUID, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumGUID_Clone(self: *const T, ppenum: ?*?*IEnumGUID) HRESULT {
                return @as(*const IEnumGUID.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumGUID, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CATEGORYINFO = extern struct {
    catid: Guid,
    lcid: u32,
    szDescription: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumCATEGORYINFO_Value = Guid.initString("0002e011-0000-0000-c000-000000000046");
pub const IID_IEnumCATEGORYINFO = &IID_IEnumCATEGORYINFO_Value;
pub const IEnumCATEGORYINFO = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCATEGORYINFO,
                celt: u32,
                rgelt: [*]CATEGORYINFO,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCATEGORYINFO,
                celt: u32,
                rgelt: [*]CATEGORYINFO,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCATEGORYINFO,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCATEGORYINFO,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumCATEGORYINFO,
                ppenum: ?*?*IEnumCATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumCATEGORYINFO,
                ppenum: ?*?*IEnumCATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCATEGORYINFO_Next(self: *const T, celt: u32, rgelt: [*]CATEGORYINFO, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumCATEGORYINFO, @ptrCast(self)), celt, rgelt, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCATEGORYINFO_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumCATEGORYINFO, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCATEGORYINFO_Reset(self: *const T) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumCATEGORYINFO, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumCATEGORYINFO_Clone(self: *const T, ppenum: ?*?*IEnumCATEGORYINFO) HRESULT {
                return @as(*const IEnumCATEGORYINFO.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumCATEGORYINFO, @ptrCast(self)), ppenum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatRegister_Value = Guid.initString("0002e012-0000-0000-c000-000000000046");
pub const IID_ICatRegister = &IID_ICatRegister_Value;
pub const ICatRegister = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatRegister,
                cCategories: u32,
                rgCategoryInfo: [*]CATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatRegister,
                cCategories: u32,
                rgCategoryInfo: [*]CATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatRegister,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatRegister,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterClassImplCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterClassImplCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterClassReqCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterClassReqCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatRegister,
                rclsid: ?*const Guid,
                cCategories: u32,
                rgcatid: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatRegister_RegisterCategories(self: *const T, cCategories: u32, rgCategoryInfo: [*]CATEGORYINFO) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).RegisterCategories(@as(*const ICatRegister, @ptrCast(self)), cCategories, rgCategoryInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatRegister_UnRegisterCategories(self: *const T, cCategories: u32, rgcatid: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).UnRegisterCategories(@as(*const ICatRegister, @ptrCast(self)), cCategories, rgcatid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatRegister_RegisterClassImplCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).RegisterClassImplCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid, cCategories, rgcatid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatRegister_UnRegisterClassImplCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).UnRegisterClassImplCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid, cCategories, rgcatid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatRegister_RegisterClassReqCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).RegisterClassReqCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid, cCategories, rgcatid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatRegister_UnRegisterClassReqCategories(self: *const T, rclsid: ?*const Guid, cCategories: u32, rgcatid: [*]Guid) HRESULT {
                return @as(*const ICatRegister.VTable, @ptrCast(self.vtable)).UnRegisterClassReqCategories(@as(*const ICatRegister, @ptrCast(self)), rclsid, cCategories, rgcatid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICatInformation_Value = Guid.initString("0002e013-0000-0000-c000-000000000046");
pub const IID_ICatInformation = &IID_ICatInformation_Value;
pub const ICatInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatInformation,
                lcid: u32,
                ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatInformation,
                lcid: u32,
                ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategoryDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatInformation,
                rcatid: ?*Guid,
                lcid: u32,
                pszDesc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatInformation,
                rcatid: ?*Guid,
                lcid: u32,
                pszDesc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumClassesOfCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatInformation,
                cImplemented: u32,
                rgcatidImpl: [*]const Guid,
                cRequired: u32,
                rgcatidReq: [*]const Guid,
                ppenumClsid: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatInformation,
                cImplemented: u32,
                rgcatidImpl: [*]const Guid,
                cRequired: u32,
                rgcatidReq: [*]const Guid,
                ppenumClsid: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsClassOfCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatInformation,
                rclsid: ?*const Guid,
                cImplemented: u32,
                rgcatidImpl: [*]const Guid,
                cRequired: u32,
                rgcatidReq: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatInformation,
                rclsid: ?*const Guid,
                cImplemented: u32,
                rgcatidImpl: [*]const Guid,
                cRequired: u32,
                rgcatidReq: [*]const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumImplCategoriesOfClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatInformation,
                rclsid: ?*const Guid,
                ppenumCatid: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatInformation,
                rclsid: ?*const Guid,
                ppenumCatid: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumReqCategoriesOfClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICatInformation,
                rclsid: ?*const Guid,
                ppenumCatid: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICatInformation,
                rclsid: ?*const Guid,
                ppenumCatid: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatInformation_EnumCategories(self: *const T, lcid: u32, ppenumCategoryInfo: ?*?*IEnumCATEGORYINFO) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumCategories(@as(*const ICatInformation, @ptrCast(self)), lcid, ppenumCategoryInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatInformation_GetCategoryDesc(self: *const T, rcatid: ?*Guid, lcid: u32, pszDesc: ?*?PWSTR) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).GetCategoryDesc(@as(*const ICatInformation, @ptrCast(self)), rcatid, lcid, pszDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatInformation_EnumClassesOfCategories(self: *const T, cImplemented: u32, rgcatidImpl: [*]const Guid, cRequired: u32, rgcatidReq: [*]const Guid, ppenumClsid: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumClassesOfCategories(@as(*const ICatInformation, @ptrCast(self)), cImplemented, rgcatidImpl, cRequired, rgcatidReq, ppenumClsid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatInformation_IsClassOfCategories(self: *const T, rclsid: ?*const Guid, cImplemented: u32, rgcatidImpl: [*]const Guid, cRequired: u32, rgcatidReq: [*]const Guid) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).IsClassOfCategories(@as(*const ICatInformation, @ptrCast(self)), rclsid, cImplemented, rgcatidImpl, cRequired, rgcatidReq);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatInformation_EnumImplCategoriesOfClass(self: *const T, rclsid: ?*const Guid, ppenumCatid: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumImplCategoriesOfClass(@as(*const ICatInformation, @ptrCast(self)), rclsid, ppenumCatid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICatInformation_EnumReqCategoriesOfClass(self: *const T, rclsid: ?*const Guid, ppenumCatid: ?*?*IEnumGUID) HRESULT {
                return @as(*const ICatInformation.VTable, @ptrCast(self.vtable)).EnumReqCategoriesOfClass(@as(*const ICatInformation, @ptrCast(self)), rclsid, ppenumCatid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ComCallData = extern struct {
    dwDispid: u32,
    dwReserved: u32,
    pUserDefined: ?*anyopaque,
};

pub const PFNCONTEXTCALL = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pParam: ?*ComCallData,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        pParam: ?*ComCallData,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IContextCallback_Value = Guid.initString("000001da-0000-0000-c000-000000000046");
pub const IID_IContextCallback = &IID_IContextCallback_Value;
pub const IContextCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ContextCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IContextCallback,
                pfnCallback: ?PFNCONTEXTCALL,
                pParam: ?*ComCallData,
                riid: ?*const Guid,
                iMethod: i32,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IContextCallback,
                pfnCallback: ?PFNCONTEXTCALL,
                pParam: ?*ComCallData,
                riid: ?*const Guid,
                iMethod: i32,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IContextCallback_ContextCallback(self: *const T, pfnCallback: ?PFNCONTEXTCALL, pParam: ?*ComCallData, riid: ?*const Guid, iMethod: i32, pUnk: ?*IUnknown) HRESULT {
                return @as(*const IContextCallback.VTable, @ptrCast(self.vtable)).ContextCallback(@as(*const IContextCallback, @ptrCast(self)), pfnCallback, pParam, riid, iMethod, pUnk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBinding_Value = Guid.initString("79eac9c0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBinding = &IID_IBinding_Value;
pub const IBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBinding,
                nPriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBinding,
                nPriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBinding,
                pnPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBinding,
                pnPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBinding,
                pclsidProtocol: ?*Guid,
                pdwResult: ?*u32,
                pszResult: ?*?PWSTR,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBinding,
                pclsidProtocol: ?*Guid,
                pdwResult: ?*u32,
                pszResult: ?*?PWSTR,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBinding_Abort(self: *const T) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).Abort(@as(*const IBinding, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBinding_Suspend(self: *const T) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IBinding, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBinding_Resume(self: *const T) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).Resume(@as(*const IBinding, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBinding_SetPriority(self: *const T, nPriority: i32) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).SetPriority(@as(*const IBinding, @ptrCast(self)), nPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBinding_GetPriority(self: *const T, pnPriority: ?*i32) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IBinding, @ptrCast(self)), pnPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBinding_GetBindResult(self: *const T, pclsidProtocol: ?*Guid, pdwResult: ?*u32, pszResult: ?*?PWSTR, pdwReserved: ?*u32) HRESULT {
                return @as(*const IBinding.VTable, @ptrCast(self.vtable)).GetBindResult(@as(*const IBinding, @ptrCast(self)), pclsidProtocol, pdwResult, pszResult, pdwReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BINDINFOF = enum(i32) {
    STGMEDDATA = 1,
    DEXTRAINFO = 2,
};
pub const BINDINFOF_URLENCODESTGMEDDATA = BINDINFOF.STGMEDDATA;
pub const BINDINFOF_URLENCODEDEXTRAINFO = BINDINFOF.DEXTRAINFO;

pub const BINDINFO = extern struct {
    cbSize: u32,
    szExtraInfo: ?PWSTR,
    stgmedData: STGMEDIUM,
    grfBindInfoF: u32,
    dwBindVerb: u32,
    szCustomVerb: ?PWSTR,
    cbstgmedData: u32,
    dwOptions: u32,
    dwOptionsFlags: u32,
    dwCodePage: u32,
    securityAttributes: SECURITY_ATTRIBUTES,
    iid: Guid,
    pUnk: ?*IUnknown,
    dwReserved: u32,
};

const IID_IBindStatusCallback_Value = Guid.initString("79eac9c1-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IBindStatusCallback = &IID_IBindStatusCallback_Value;
pub const IBindStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartBinding: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                dwReserved: u32,
                pib: ?*IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                dwReserved: u32,
                pib: ?*IBinding,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                pnPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                pnPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLowResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                reserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                reserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                ulProgress: u32,
                ulProgressMax: u32,
                ulStatusCode: u32,
                szStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                ulProgress: u32,
                ulProgressMax: u32,
                ulStatusCode: u32,
                szStatusText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStopBinding: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                hresult: HRESULT,
                szError: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                hresult: HRESULT,
                szError: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDataAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                grfBSCF: u32,
                dwSize: u32,
                pformatetc: ?*FORMATETC,
                pstgmed: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                grfBSCF: u32,
                dwSize: u32,
                pformatetc: ?*FORMATETC,
                pstgmed: ?*STGMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnObjectAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallback,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallback,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_OnStartBinding(self: *const T, dwReserved: u32, pib: ?*IBinding) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnStartBinding(@as(*const IBindStatusCallback, @ptrCast(self)), dwReserved, pib);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_GetPriority(self: *const T, pnPriority: ?*i32) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IBindStatusCallback, @ptrCast(self)), pnPriority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_OnLowResource(self: *const T, reserved: u32) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnLowResource(@as(*const IBindStatusCallback, @ptrCast(self)), reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_OnProgress(self: *const T, ulProgress: u32, ulProgressMax: u32, ulStatusCode: u32, szStatusText: ?[*:0]const u16) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IBindStatusCallback, @ptrCast(self)), ulProgress, ulProgressMax, ulStatusCode, szStatusText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_OnStopBinding(self: *const T, hresult: HRESULT, szError: ?[*:0]const u16) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnStopBinding(@as(*const IBindStatusCallback, @ptrCast(self)), hresult, szError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_GetBindInfo(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).GetBindInfo(@as(*const IBindStatusCallback, @ptrCast(self)), grfBINDF, pbindinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_OnDataAvailable(self: *const T, grfBSCF: u32, dwSize: u32, pformatetc: ?*FORMATETC, pstgmed: ?*STGMEDIUM) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnDataAvailable(@as(*const IBindStatusCallback, @ptrCast(self)), grfBSCF, dwSize, pformatetc, pstgmed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallback_OnObjectAvailable(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IBindStatusCallback.VTable, @ptrCast(self.vtable)).OnObjectAvailable(@as(*const IBindStatusCallback, @ptrCast(self)), riid, punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindStatusCallbackEx_Value = Guid.initString("aaa74ef9-8ee7-4659-88d9-f8c504da73cc");
pub const IID_IBindStatusCallbackEx = &IID_IBindStatusCallbackEx_Value;
pub const IBindStatusCallbackEx = extern struct {
    pub const VTable = extern struct {
        base: IBindStatusCallback.VTable,
        GetBindInfoEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindStatusCallbackEx,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
                grfBINDF2: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindStatusCallbackEx,
                grfBINDF: ?*u32,
                pbindinfo: ?*BINDINFO,
                grfBINDF2: ?*u32,
                pdwReserved: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IBindStatusCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindStatusCallbackEx_GetBindInfoEx(self: *const T, grfBINDF: ?*u32, pbindinfo: ?*BINDINFO, grfBINDF2: ?*u32, pdwReserved: ?*u32) HRESULT {
                return @as(*const IBindStatusCallbackEx.VTable, @ptrCast(self.vtable)).GetBindInfoEx(@as(*const IBindStatusCallbackEx, @ptrCast(self)), grfBINDF, pbindinfo, grfBINDF2, pdwReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuthenticate_Value = Guid.initString("79eac9d0-baf9-11ce-8c82-00aa004ba90b");
pub const IID_IAuthenticate = &IID_IAuthenticate_Value;
pub const IAuthenticate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Authenticate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAuthenticate,
                phwnd: ?*?HWND,
                pszUsername: ?*?PWSTR,
                pszPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAuthenticate,
                phwnd: ?*?HWND,
                pszUsername: ?*?PWSTR,
                pszPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAuthenticate_Authenticate(self: *const T, phwnd: ?*?HWND, pszUsername: ?*?PWSTR, pszPassword: ?*?PWSTR) HRESULT {
                return @as(*const IAuthenticate.VTable, @ptrCast(self.vtable)).Authenticate(@as(*const IAuthenticate, @ptrCast(self)), phwnd, pszUsername, pszPassword);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const AUTHENTICATEINFO = extern struct {
    dwFlags: u32,
    dwReserved: u32,
};

const IID_IAuthenticateEx_Value = Guid.initString("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd");
pub const IID_IAuthenticateEx = &IID_IAuthenticateEx_Value;
pub const IAuthenticateEx = extern struct {
    pub const VTable = extern struct {
        base: IAuthenticate.VTable,
        AuthenticateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IAuthenticateEx,
                phwnd: ?*?HWND,
                pszUsername: ?*?PWSTR,
                pszPassword: ?*?PWSTR,
                pauthinfo: ?*AUTHENTICATEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IAuthenticateEx,
                phwnd: ?*?HWND,
                pszUsername: ?*?PWSTR,
                pszPassword: ?*?PWSTR,
                pauthinfo: ?*AUTHENTICATEINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IAuthenticate.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IAuthenticateEx_AuthenticateEx(self: *const T, phwnd: ?*?HWND, pszUsername: ?*?PWSTR, pszPassword: ?*?PWSTR, pauthinfo: ?*AUTHENTICATEINFO) HRESULT {
                return @as(*const IAuthenticateEx.VTable, @ptrCast(self.vtable)).AuthenticateEx(@as(*const IAuthenticateEx, @ptrCast(self)), phwnd, pszUsername, pszPassword, pauthinfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const Uri_PROPERTY = enum(i32) {
    ABSOLUTE_URI = 0,
    // STRING_START = 0, this enum value conflicts with ABSOLUTE_URI
    AUTHORITY = 1,
    DISPLAY_URI = 2,
    DOMAIN = 3,
    EXTENSION = 4,
    FRAGMENT = 5,
    HOST = 6,
    PASSWORD = 7,
    PATH = 8,
    PATH_AND_QUERY = 9,
    QUERY = 10,
    RAW_URI = 11,
    SCHEME_NAME = 12,
    USER_INFO = 13,
    USER_NAME = 14,
    // STRING_LAST = 14, this enum value conflicts with USER_NAME
    HOST_TYPE = 15,
    // DWORD_START = 15, this enum value conflicts with HOST_TYPE
    PORT = 16,
    SCHEME = 17,
    ZONE = 18,
    // DWORD_LAST = 18, this enum value conflicts with ZONE
};
pub const Uri_PROPERTY_ABSOLUTE_URI = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_STRING_START = Uri_PROPERTY.ABSOLUTE_URI;
pub const Uri_PROPERTY_AUTHORITY = Uri_PROPERTY.AUTHORITY;
pub const Uri_PROPERTY_DISPLAY_URI = Uri_PROPERTY.DISPLAY_URI;
pub const Uri_PROPERTY_DOMAIN = Uri_PROPERTY.DOMAIN;
pub const Uri_PROPERTY_EXTENSION = Uri_PROPERTY.EXTENSION;
pub const Uri_PROPERTY_FRAGMENT = Uri_PROPERTY.FRAGMENT;
pub const Uri_PROPERTY_HOST = Uri_PROPERTY.HOST;
pub const Uri_PROPERTY_PASSWORD = Uri_PROPERTY.PASSWORD;
pub const Uri_PROPERTY_PATH = Uri_PROPERTY.PATH;
pub const Uri_PROPERTY_PATH_AND_QUERY = Uri_PROPERTY.PATH_AND_QUERY;
pub const Uri_PROPERTY_QUERY = Uri_PROPERTY.QUERY;
pub const Uri_PROPERTY_RAW_URI = Uri_PROPERTY.RAW_URI;
pub const Uri_PROPERTY_SCHEME_NAME = Uri_PROPERTY.SCHEME_NAME;
pub const Uri_PROPERTY_USER_INFO = Uri_PROPERTY.USER_INFO;
pub const Uri_PROPERTY_USER_NAME = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_STRING_LAST = Uri_PROPERTY.USER_NAME;
pub const Uri_PROPERTY_HOST_TYPE = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_DWORD_START = Uri_PROPERTY.HOST_TYPE;
pub const Uri_PROPERTY_PORT = Uri_PROPERTY.PORT;
pub const Uri_PROPERTY_SCHEME = Uri_PROPERTY.SCHEME;
pub const Uri_PROPERTY_ZONE = Uri_PROPERTY.ZONE;
pub const Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY.ZONE;

const IID_IUri_Value = Guid.initString("a39ee748-6a27-4817-a6f2-13914bef5890");
pub const IID_IUri = &IID_IUri_Value;
pub const IUri = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyBSTR: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pbstrProperty: ?*?BSTR,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pbstrProperty: ?*?BSTR,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pcchProperty: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pcchProperty: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyDWORD: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pdwProperty: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pdwProperty: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pfHasProperty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                uriProp: Uri_PROPERTY,
                pfHasProperty: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAbsoluteUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrAbsoluteUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrAbsoluteUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAuthority: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrAuthority: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrAuthority: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrDisplayString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrDisplayString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrDomain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrDomain: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrExtension: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrExtension: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFragment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrFragment: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrFragment: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrHost: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrHost: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrPassword: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrPassword: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPathAndQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrPathAndQuery: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrPathAndQuery: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrQuery: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrQuery: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrRawUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrRawUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSchemeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrSchemeName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrSchemeName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrUserInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrUserInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pbstrUserName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHostType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pdwHostType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pdwHostType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pdwPort: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pdwPort: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScheme: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pdwScheme: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pdwScheme: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pdwZone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pdwZone: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUri,
                pUri: ?*IUri,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUri,
                pUri: ?*IUri,
                pfEqual: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPropertyBSTR(self: *const T, uriProp: Uri_PROPERTY, pbstrProperty: ?*?BSTR, dwFlags: u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPropertyBSTR(@as(*const IUri, @ptrCast(self)), uriProp, pbstrProperty, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPropertyLength(self: *const T, uriProp: Uri_PROPERTY, pcchProperty: ?*u32, dwFlags: u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPropertyLength(@as(*const IUri, @ptrCast(self)), uriProp, pcchProperty, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPropertyDWORD(self: *const T, uriProp: Uri_PROPERTY, pdwProperty: ?*u32, dwFlags: u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPropertyDWORD(@as(*const IUri, @ptrCast(self)), uriProp, pdwProperty, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_HasProperty(self: *const T, uriProp: Uri_PROPERTY, pfHasProperty: ?*BOOL) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).HasProperty(@as(*const IUri, @ptrCast(self)), uriProp, pfHasProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetAbsoluteUri(self: *const T, pbstrAbsoluteUri: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetAbsoluteUri(@as(*const IUri, @ptrCast(self)), pbstrAbsoluteUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetAuthority(self: *const T, pbstrAuthority: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetAuthority(@as(*const IUri, @ptrCast(self)), pbstrAuthority);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetDisplayUri(self: *const T, pbstrDisplayString: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetDisplayUri(@as(*const IUri, @ptrCast(self)), pbstrDisplayString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetDomain(self: *const T, pbstrDomain: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetDomain(@as(*const IUri, @ptrCast(self)), pbstrDomain);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetExtension(self: *const T, pbstrExtension: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetExtension(@as(*const IUri, @ptrCast(self)), pbstrExtension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetFragment(self: *const T, pbstrFragment: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetFragment(@as(*const IUri, @ptrCast(self)), pbstrFragment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetHost(self: *const T, pbstrHost: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetHost(@as(*const IUri, @ptrCast(self)), pbstrHost);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPassword(self: *const T, pbstrPassword: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPassword(@as(*const IUri, @ptrCast(self)), pbstrPassword);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPath(self: *const T, pbstrPath: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IUri, @ptrCast(self)), pbstrPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPathAndQuery(self: *const T, pbstrPathAndQuery: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPathAndQuery(@as(*const IUri, @ptrCast(self)), pbstrPathAndQuery);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetQuery(self: *const T, pbstrQuery: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetQuery(@as(*const IUri, @ptrCast(self)), pbstrQuery);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetRawUri(self: *const T, pbstrRawUri: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetRawUri(@as(*const IUri, @ptrCast(self)), pbstrRawUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetSchemeName(self: *const T, pbstrSchemeName: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetSchemeName(@as(*const IUri, @ptrCast(self)), pbstrSchemeName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetUserInfo(self: *const T, pbstrUserInfo: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetUserInfo(@as(*const IUri, @ptrCast(self)), pbstrUserInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetUserName(self: *const T, pbstrUserName: ?*?BSTR) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetUserName(@as(*const IUri, @ptrCast(self)), pbstrUserName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetHostType(self: *const T, pdwHostType: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetHostType(@as(*const IUri, @ptrCast(self)), pdwHostType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetPort(self: *const T, pdwPort: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetPort(@as(*const IUri, @ptrCast(self)), pdwPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetScheme(self: *const T, pdwScheme: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetScheme(@as(*const IUri, @ptrCast(self)), pdwScheme);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetZone(self: *const T, pdwZone: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetZone(@as(*const IUri, @ptrCast(self)), pdwZone);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_GetProperties(self: *const T, pdwFlags: ?*u32) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IUri, @ptrCast(self)), pdwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUri_IsEqual(self: *const T, pUri: ?*IUri, pfEqual: ?*BOOL) HRESULT {
                return @as(*const IUri.VTable, @ptrCast(self.vtable)).IsEqual(@as(*const IUri, @ptrCast(self)), pUri, pfEqual);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IUriBuilder_Value = Guid.initString("4221b2e1-8955-46c0-bd5b-de9897565de7");
pub const IID_IUriBuilder = &IID_IUriBuilder_Value;
pub const IUriBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateUriSimple: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                dwAllowEncodingPropertyMask: u32,
                dwReserved: usize,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                dwAllowEncodingPropertyMask: u32,
                dwReserved: usize,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                dwCreateFlags: u32,
                dwAllowEncodingPropertyMask: u32,
                dwReserved: usize,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                dwCreateFlags: u32,
                dwAllowEncodingPropertyMask: u32,
                dwReserved: usize,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateUriWithFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                dwCreateFlags: u32,
                dwUriBuilderFlags: u32,
                dwAllowEncodingPropertyMask: u32,
                dwReserved: usize,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                dwCreateFlags: u32,
                dwUriBuilderFlags: u32,
                dwAllowEncodingPropertyMask: u32,
                dwReserved: usize,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                ppIUri: ?*?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIUri: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pIUri: ?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pIUri: ?*IUri,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFragment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchFragment: ?*u32,
                ppwzFragment: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchFragment: ?*u32,
                ppwzFragment: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchHost: ?*u32,
                ppwzHost: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchHost: ?*u32,
                ppwzHost: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchPassword: ?*u32,
                ppwzPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchPassword: ?*u32,
                ppwzPassword: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchPath: ?*u32,
                ppwzPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchPath: ?*u32,
                ppwzPath: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pfHasPort: ?*BOOL,
                pdwPort: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pfHasPort: ?*BOOL,
                pdwPort: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchQuery: ?*u32,
                ppwzQuery: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchQuery: ?*u32,
                ppwzQuery: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSchemeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchSchemeName: ?*u32,
                ppwzSchemeName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchSchemeName: ?*u32,
                ppwzSchemeName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pcchUserName: ?*u32,
                ppwzUserName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pcchUserName: ?*u32,
                ppwzUserName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFragment: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                fHasPort: BOOL,
                dwNewValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                fHasPort: BOOL,
                dwNewValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSchemeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUserName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pwzNewValue: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                dwPropertyMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                dwPropertyMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasBeenModified: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IUriBuilder,
                pfModified: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IUriBuilder,
                pfModified: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_CreateUriSimple(self: *const T, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).CreateUriSimple(@as(*const IUriBuilder, @ptrCast(self)), dwAllowEncodingPropertyMask, dwReserved, ppIUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_CreateUri(self: *const T, dwCreateFlags: u32, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).CreateUri(@as(*const IUriBuilder, @ptrCast(self)), dwCreateFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_CreateUriWithFlags(self: *const T, dwCreateFlags: u32, dwUriBuilderFlags: u32, dwAllowEncodingPropertyMask: u32, dwReserved: usize, ppIUri: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).CreateUriWithFlags(@as(*const IUriBuilder, @ptrCast(self)), dwCreateFlags, dwUriBuilderFlags, dwAllowEncodingPropertyMask, dwReserved, ppIUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetIUri(self: *const T, ppIUri: ?*?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetIUri(@as(*const IUriBuilder, @ptrCast(self)), ppIUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetIUri(self: *const T, pIUri: ?*IUri) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetIUri(@as(*const IUriBuilder, @ptrCast(self)), pIUri);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetFragment(self: *const T, pcchFragment: ?*u32, ppwzFragment: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetFragment(@as(*const IUriBuilder, @ptrCast(self)), pcchFragment, ppwzFragment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetHost(self: *const T, pcchHost: ?*u32, ppwzHost: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetHost(@as(*const IUriBuilder, @ptrCast(self)), pcchHost, ppwzHost);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetPassword(self: *const T, pcchPassword: ?*u32, ppwzPassword: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetPassword(@as(*const IUriBuilder, @ptrCast(self)), pcchPassword, ppwzPassword);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetPath(self: *const T, pcchPath: ?*u32, ppwzPath: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetPath(@as(*const IUriBuilder, @ptrCast(self)), pcchPath, ppwzPath);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetPort(self: *const T, pfHasPort: ?*BOOL, pdwPort: ?*u32) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetPort(@as(*const IUriBuilder, @ptrCast(self)), pfHasPort, pdwPort);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetQuery(self: *const T, pcchQuery: ?*u32, ppwzQuery: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetQuery(@as(*const IUriBuilder, @ptrCast(self)), pcchQuery, ppwzQuery);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetSchemeName(self: *const T, pcchSchemeName: ?*u32, ppwzSchemeName: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetSchemeName(@as(*const IUriBuilder, @ptrCast(self)), pcchSchemeName, ppwzSchemeName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_GetUserName(self: *const T, pcchUserName: ?*u32, ppwzUserName: ?*?PWSTR) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).GetUserName(@as(*const IUriBuilder, @ptrCast(self)), pcchUserName, ppwzUserName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetFragment(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetFragment(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetHost(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetHost(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetPassword(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetPassword(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetPath(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetPath(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetPort(self: *const T, fHasPort: BOOL, dwNewValue: u32) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetPort(@as(*const IUriBuilder, @ptrCast(self)), fHasPort, dwNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetQuery(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetQuery(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetSchemeName(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetSchemeName(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_SetUserName(self: *const T, pwzNewValue: ?[*:0]const u16) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).SetUserName(@as(*const IUriBuilder, @ptrCast(self)), pwzNewValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_RemoveProperties(self: *const T, dwPropertyMask: u32) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).RemoveProperties(@as(*const IUriBuilder, @ptrCast(self)), dwPropertyMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IUriBuilder_HasBeenModified(self: *const T, pfModified: ?*BOOL) HRESULT {
                return @as(*const IUriBuilder.VTable, @ptrCast(self.vtable)).HasBeenModified(@as(*const IUriBuilder, @ptrCast(self)), pfModified);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindHost_Value = Guid.initString("fc4801a1-2ba9-11cf-a229-00aa003d7352");
pub const IID_IBindHost = &IID_IBindHost_Value;
pub const IBindHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindHost,
                szName: ?PWSTR,
                pBC: ?*IBindCtx,
                ppmk: ?*?*IMoniker,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindHost,
                szName: ?PWSTR,
                pBC: ?*IBindCtx,
                ppmk: ?*?*IMoniker,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MonikerBindToStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindHost,
                pMk: ?*IMoniker,
                pBC: ?*IBindCtx,
                pBSC: ?*IBindStatusCallback,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindHost,
                pMk: ?*IMoniker,
                pBC: ?*IBindCtx,
                pBSC: ?*IBindStatusCallback,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MonikerBindToObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindHost,
                pMk: ?*IMoniker,
                pBC: ?*IBindCtx,
                pBSC: ?*IBindStatusCallback,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindHost,
                pMk: ?*IMoniker,
                pBC: ?*IBindCtx,
                pBSC: ?*IBindStatusCallback,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindHost_CreateMoniker(self: *const T, szName: ?PWSTR, pBC: ?*IBindCtx, ppmk: ?*?*IMoniker, dwReserved: u32) HRESULT {
                return @as(*const IBindHost.VTable, @ptrCast(self.vtable)).CreateMoniker(@as(*const IBindHost, @ptrCast(self)), szName, pBC, ppmk, dwReserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindHost_MonikerBindToStorage(self: *const T, pMk: ?*IMoniker, pBC: ?*IBindCtx, pBSC: ?*IBindStatusCallback, riid: ?*const Guid, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const IBindHost.VTable, @ptrCast(self.vtable)).MonikerBindToStorage(@as(*const IBindHost, @ptrCast(self)), pMk, pBC, pBSC, riid, ppvObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindHost_MonikerBindToObject(self: *const T, pMk: ?*IMoniker, pBC: ?*IBindCtx, pBSC: ?*IBindStatusCallback, riid: ?*const Guid, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const IBindHost.VTable, @ptrCast(self.vtable)).MonikerBindToObject(@as(*const IBindHost, @ptrCast(self)), pMk, pBC, pBSC, riid, ppvObj);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SAFEARRAYBOUND = extern struct {
    cElements: u32,
    lLbound: i32,
};

pub const SAFEARRAY = extern struct {
    cDims: u16,
    fFeatures: u16,
    cbElements: u32,
    cLocks: u32,
    pvData: ?*anyopaque,
    rgsabound: [1]SAFEARRAYBOUND,
};

pub const VARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: u16,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                llVal: i64,
                lVal: i32,
                bVal: u8,
                iVal: i16,
                fltVal: f32,
                dblVal: f64,
                boolVal: i16,
                __OBSOLETE__VARIANT_BOOL: i16,
                scode: i32,
                cyVal: CY,
                date: f64,
                bstrVal: ?BSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                parray: ?*SAFEARRAY,
                pbVal: ?*u8,
                piVal: ?*i16,
                plVal: ?*i32,
                pllVal: ?*i64,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*i16,
                __OBSOLETE__VARIANT_PBOOL: ?*i16,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*VARIANT,
                byref: ?*anyopaque,
                cVal: CHAR,
                uiVal: u16,
                ulVal: u32,
                ullVal: u64,
                intVal: i32,
                uintVal: u32,
                pdecVal: ?*DECIMAL,
                pcVal: ?PSTR,
                puiVal: ?*u16,
                pulVal: ?*u32,
                pullVal: ?*u64,
                pintVal: ?*i32,
                puintVal: ?*u32,
                Anonymous: extern struct {
                    pvRecord: ?*anyopaque,
                    pRecInfo: ?*IRecordInfo,
                },
            },
        },
        decVal: DECIMAL,
    },
};

pub const TYPEKIND = enum(i32) {
    ENUM = 0,
    RECORD = 1,
    MODULE = 2,
    INTERFACE = 3,
    DISPATCH = 4,
    COCLASS = 5,
    ALIAS = 6,
    UNION = 7,
    MAX = 8,
};
pub const TKIND_ENUM = TYPEKIND.ENUM;
pub const TKIND_RECORD = TYPEKIND.RECORD;
pub const TKIND_MODULE = TYPEKIND.MODULE;
pub const TKIND_INTERFACE = TYPEKIND.INTERFACE;
pub const TKIND_DISPATCH = TYPEKIND.DISPATCH;
pub const TKIND_COCLASS = TYPEKIND.COCLASS;
pub const TKIND_ALIAS = TYPEKIND.ALIAS;
pub const TKIND_UNION = TYPEKIND.UNION;
pub const TKIND_MAX = TYPEKIND.MAX;

pub const TYPEDESC = extern struct {
    Anonymous: extern union {
        lptdesc: ?*TYPEDESC,
        lpadesc: ?*ARRAYDESC,
        hreftype: u32,
    },
    vt: u16,
};

pub const IDLDESC = extern struct {
    dwReserved: usize,
    wIDLFlags: u16,
};

pub const ELEMDESC = extern struct {
    tdesc: TYPEDESC,
    Anonymous: extern union {
        idldesc: IDLDESC,
        paramdesc: PARAMDESC,
    },
};

pub const TYPEATTR = extern struct {
    guid: Guid,
    lcid: u32,
    dwReserved: u32,
    memidConstructor: i32,
    memidDestructor: i32,
    lpstrSchema: ?PWSTR,
    cbSizeInstance: u32,
    typekind: TYPEKIND,
    cFuncs: u16,
    cVars: u16,
    cImplTypes: u16,
    cbSizeVft: u16,
    cbAlignment: u16,
    wTypeFlags: u16,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    tdescAlias: TYPEDESC,
    idldescType: IDLDESC,
};

pub const DISPPARAMS = extern struct {
    rgvarg: ?*VARIANT,
    rgdispidNamedArgs: ?*i32,
    cArgs: u32,
    cNamedArgs: u32,
};

pub const EXCEPINFO = extern struct {
    wCode: u16,
    wReserved: u16,
    bstrSource: ?BSTR,
    bstrDescription: ?BSTR,
    bstrHelpFile: ?BSTR,
    dwHelpContext: u32,
    pvReserved: ?*anyopaque,
    pfnDeferredFillIn: ?LPEXCEPFINO_DEFERRED_FILLIN,
    scode: i32,
};

pub const CALLCONV = enum(i32) {
    FASTCALL = 0,
    CDECL = 1,
    MSCPASCAL = 2,
    // PASCAL = 2, this enum value conflicts with MSCPASCAL
    MACPASCAL = 3,
    STDCALL = 4,
    FPFASTCALL = 5,
    SYSCALL = 6,
    MPWCDECL = 7,
    MPWPASCAL = 8,
    MAX = 9,
};
pub const CC_FASTCALL = CALLCONV.FASTCALL;
pub const CC_CDECL = CALLCONV.CDECL;
pub const CC_MSCPASCAL = CALLCONV.MSCPASCAL;
pub const CC_PASCAL = CALLCONV.MSCPASCAL;
pub const CC_MACPASCAL = CALLCONV.MACPASCAL;
pub const CC_STDCALL = CALLCONV.STDCALL;
pub const CC_FPFASTCALL = CALLCONV.FPFASTCALL;
pub const CC_SYSCALL = CALLCONV.SYSCALL;
pub const CC_MPWCDECL = CALLCONV.MPWCDECL;
pub const CC_MPWPASCAL = CALLCONV.MPWPASCAL;
pub const CC_MAX = CALLCONV.MAX;

pub const FUNCKIND = enum(i32) {
    VIRTUAL = 0,
    PUREVIRTUAL = 1,
    NONVIRTUAL = 2,
    STATIC = 3,
    DISPATCH = 4,
};
pub const FUNC_VIRTUAL = FUNCKIND.VIRTUAL;
pub const FUNC_PUREVIRTUAL = FUNCKIND.PUREVIRTUAL;
pub const FUNC_NONVIRTUAL = FUNCKIND.NONVIRTUAL;
pub const FUNC_STATIC = FUNCKIND.STATIC;
pub const FUNC_DISPATCH = FUNCKIND.DISPATCH;

pub const INVOKEKIND = enum(i32) {
    FUNC = 1,
    PROPERTYGET = 2,
    PROPERTYPUT = 4,
    PROPERTYPUTREF = 8,
};
pub const INVOKE_FUNC = INVOKEKIND.FUNC;
pub const INVOKE_PROPERTYGET = INVOKEKIND.PROPERTYGET;
pub const INVOKE_PROPERTYPUT = INVOKEKIND.PROPERTYPUT;
pub const INVOKE_PROPERTYPUTREF = INVOKEKIND.PROPERTYPUTREF;

pub const FUNCDESC = extern struct {
    memid: i32,
    lprgscode: ?*i32,
    lprgelemdescParam: ?*ELEMDESC,
    funckind: FUNCKIND,
    invkind: INVOKEKIND,
    @"callconv": CALLCONV,
    cParams: i16,
    cParamsOpt: i16,
    oVft: i16,
    cScodes: i16,
    elemdescFunc: ELEMDESC,
    wFuncFlags: u16,
};

pub const VARKIND = enum(i32) {
    PERINSTANCE = 0,
    STATIC = 1,
    CONST = 2,
    DISPATCH = 3,
};
pub const VAR_PERINSTANCE = VARKIND.PERINSTANCE;
pub const VAR_STATIC = VARKIND.STATIC;
pub const VAR_CONST = VARKIND.CONST;
pub const VAR_DISPATCH = VARKIND.DISPATCH;

pub const VARDESC = extern struct {
    memid: i32,
    lpstrSchema: ?PWSTR,
    Anonymous: extern union {
        oInst: u32,
        lpvarValue: ?*VARIANT,
    },
    elemdescVar: ELEMDESC,
    wVarFlags: u16,
    varkind: VARKIND,
};

pub const CUSTDATAITEM = extern struct {
    guid: Guid,
    varValue: VARIANT,
};

pub const CUSTDATA = extern struct {
    cCustData: u32,
    prgCustData: ?*CUSTDATAITEM,
};

const IID_IDispatch_Value = Guid.initString("00020400-0000-0000-c000-000000000046");
pub const IID_IDispatch = &IID_IDispatch_Value;
pub const IDispatch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatch,
                pctinfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatch,
                pctinfo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatch,
                iTInfo: u32,
                lcid: u32,
                ppTInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatch,
                iTInfo: u32,
                lcid: u32,
                ppTInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDsOfNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatch,
                riid: ?*const Guid,
                rgszNames: [*]?PWSTR,
                cNames: u32,
                lcid: u32,
                rgDispId: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatch,
                riid: ?*const Guid,
                rgszNames: [*]?PWSTR,
                cNames: u32,
                lcid: u32,
                rgDispId: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDispatch,
                dispIdMember: i32,
                riid: ?*const Guid,
                lcid: u32,
                wFlags: u16,
                pDispParams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pExcepInfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDispatch,
                dispIdMember: i32,
                riid: ?*const Guid,
                lcid: u32,
                wFlags: u16,
                pDispParams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pExcepInfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatch_GetTypeInfoCount(self: *const T, pctinfo: ?*u32) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).GetTypeInfoCount(@as(*const IDispatch, @ptrCast(self)), pctinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatch_GetTypeInfo(self: *const T, iTInfo: u32, lcid: u32, ppTInfo: ?*?*ITypeInfo) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const IDispatch, @ptrCast(self)), iTInfo, lcid, ppTInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatch_GetIDsOfNames(self: *const T, riid: ?*const Guid, rgszNames: [*]?PWSTR, cNames: u32, lcid: u32, rgDispId: [*]i32) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).GetIDsOfNames(@as(*const IDispatch, @ptrCast(self)), riid, rgszNames, cNames, lcid, rgDispId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDispatch_Invoke(self: *const T, dispIdMember: i32, riid: ?*const Guid, lcid: u32, wFlags: u16, pDispParams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pExcepInfo: ?*EXCEPINFO, puArgErr: ?*u32) HRESULT {
                return @as(*const IDispatch.VTable, @ptrCast(self.vtable)).Invoke(@as(*const IDispatch, @ptrCast(self)), dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DESCKIND = enum(i32) {
    NONE = 0,
    FUNCDESC = 1,
    VARDESC = 2,
    TYPECOMP = 3,
    IMPLICITAPPOBJ = 4,
    MAX = 5,
};
pub const DESCKIND_NONE = DESCKIND.NONE;
pub const DESCKIND_FUNCDESC = DESCKIND.FUNCDESC;
pub const DESCKIND_VARDESC = DESCKIND.VARDESC;
pub const DESCKIND_TYPECOMP = DESCKIND.TYPECOMP;
pub const DESCKIND_IMPLICITAPPOBJ = DESCKIND.IMPLICITAPPOBJ;
pub const DESCKIND_MAX = DESCKIND.MAX;

pub const BINDPTR = extern union {
    lpfuncdesc: ?*FUNCDESC,
    lpvardesc: ?*VARDESC,
    lptcomp: ?*ITypeComp,
};

const IID_ITypeComp_Value = Guid.initString("00020403-0000-0000-c000-000000000046");
pub const IID_ITypeComp = &IID_ITypeComp_Value;
pub const ITypeComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeComp,
                szName: ?PWSTR,
                lHashVal: u32,
                wFlags: u16,
                ppTInfo: ?*?*ITypeInfo,
                pDescKind: ?*DESCKIND,
                pBindPtr: ?*BINDPTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeComp,
                szName: ?PWSTR,
                lHashVal: u32,
                wFlags: u16,
                ppTInfo: ?*?*ITypeInfo,
                pDescKind: ?*DESCKIND,
                pBindPtr: ?*BINDPTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeComp,
                szName: ?PWSTR,
                lHashVal: u32,
                ppTInfo: ?*?*ITypeInfo,
                ppTComp: ?*?*ITypeComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeComp,
                szName: ?PWSTR,
                lHashVal: u32,
                ppTInfo: ?*?*ITypeInfo,
                ppTComp: ?*?*ITypeComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeComp_Bind(self: *const T, szName: ?PWSTR, lHashVal: u32, wFlags: u16, ppTInfo: ?*?*ITypeInfo, pDescKind: ?*DESCKIND, pBindPtr: ?*BINDPTR) HRESULT {
                return @as(*const ITypeComp.VTable, @ptrCast(self.vtable)).Bind(@as(*const ITypeComp, @ptrCast(self)), szName, lHashVal, wFlags, ppTInfo, pDescKind, pBindPtr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeComp_BindType(self: *const T, szName: ?PWSTR, lHashVal: u32, ppTInfo: ?*?*ITypeInfo, ppTComp: ?*?*ITypeComp) HRESULT {
                return @as(*const ITypeComp.VTable, @ptrCast(self.vtable)).BindType(@as(*const ITypeComp, @ptrCast(self)), szName, lHashVal, ppTInfo, ppTComp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo_Value = Guid.initString("00020401-0000-0000-c000-000000000046");
pub const IID_ITypeInfo = &IID_ITypeInfo_Value;
pub const ITypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                ppTypeAttr: ?*?*TYPEATTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                ppTypeAttr: ?*?*TYPEATTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeComp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                ppTComp: ?*?*ITypeComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                ppTComp: ?*?*ITypeComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFuncDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                index: u32,
                ppFuncDesc: ?*?*FUNCDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                index: u32,
                ppFuncDesc: ?*?*FUNCDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVarDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                index: u32,
                ppVarDesc: ?*?*VARDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                index: u32,
                ppVarDesc: ?*?*VARDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                memid: i32,
                rgBstrNames: [*]?BSTR,
                cMaxNames: u32,
                pcNames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                memid: i32,
                rgBstrNames: [*]?BSTR,
                cMaxNames: u32,
                pcNames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRefTypeOfImplType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                index: u32,
                pRefType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                index: u32,
                pRefType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplTypeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                index: u32,
                pImplTypeFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                index: u32,
                pImplTypeFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDsOfNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                rgszNames: [*]?PWSTR,
                cNames: u32,
                pMemId: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                rgszNames: [*]?PWSTR,
                cNames: u32,
                pMemId: [*]i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Invoke: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                pvInstance: ?*anyopaque,
                memid: i32,
                wFlags: u16,
                pDispParams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pExcepInfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                pvInstance: ?*anyopaque,
                memid: i32,
                wFlags: u16,
                pDispParams: ?*DISPPARAMS,
                pVarResult: ?*VARIANT,
                pExcepInfo: ?*EXCEPINFO,
                puArgErr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                memid: i32,
                pBstrName: ?*?BSTR,
                pBstrDocString: ?*?BSTR,
                pdwHelpContext: ?*u32,
                pBstrHelpFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                memid: i32,
                pBstrName: ?*?BSTR,
                pBstrDocString: ?*?BSTR,
                pdwHelpContext: ?*u32,
                pBstrHelpFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDllEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                memid: i32,
                invKind: INVOKEKIND,
                pBstrDllName: ?*?BSTR,
                pBstrName: ?*?BSTR,
                pwOrdinal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                memid: i32,
                invKind: INVOKEKIND,
                pBstrDllName: ?*?BSTR,
                pBstrName: ?*?BSTR,
                pwOrdinal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRefTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                hRefType: u32,
                ppTInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                hRefType: u32,
                ppTInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddressOfMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                memid: i32,
                invKind: INVOKEKIND,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                memid: i32,
                invKind: INVOKEKIND,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                pUnkOuter: ?*IUnknown,
                riid: ?*const Guid,
                ppvObj: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMops: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                memid: i32,
                pBstrMops: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                memid: i32,
                pBstrMops: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainingTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                ppTLib: ?*?*ITypeLib,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo,
                ppTLib: ?*?*ITypeLib,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseTypeAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                pTypeAttr: ?*TYPEATTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITypeInfo,
                pTypeAttr: ?*TYPEATTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ReleaseFuncDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                pFuncDesc: ?*FUNCDESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITypeInfo,
                pFuncDesc: ?*FUNCDESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        ReleaseVarDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo,
                pVarDesc: ?*VARDESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITypeInfo,
                pVarDesc: ?*VARDESC,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetTypeAttr(self: *const T, ppTypeAttr: ?*?*TYPEATTR) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetTypeAttr(@as(*const ITypeInfo, @ptrCast(self)), ppTypeAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetTypeComp(self: *const T, ppTComp: ?*?*ITypeComp) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetTypeComp(@as(*const ITypeInfo, @ptrCast(self)), ppTComp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetFuncDesc(self: *const T, index: u32, ppFuncDesc: ?*?*FUNCDESC) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetFuncDesc(@as(*const ITypeInfo, @ptrCast(self)), index, ppFuncDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetVarDesc(self: *const T, index: u32, ppVarDesc: ?*?*VARDESC) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetVarDesc(@as(*const ITypeInfo, @ptrCast(self)), index, ppVarDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetNames(self: *const T, memid: i32, rgBstrNames: [*]?BSTR, cMaxNames: u32, pcNames: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetNames(@as(*const ITypeInfo, @ptrCast(self)), memid, rgBstrNames, cMaxNames, pcNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetRefTypeOfImplType(self: *const T, index: u32, pRefType: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetRefTypeOfImplType(@as(*const ITypeInfo, @ptrCast(self)), index, pRefType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetImplTypeFlags(self: *const T, index: u32, pImplTypeFlags: ?*i32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetImplTypeFlags(@as(*const ITypeInfo, @ptrCast(self)), index, pImplTypeFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetIDsOfNames(self: *const T, rgszNames: [*]?PWSTR, cNames: u32, pMemId: [*]i32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetIDsOfNames(@as(*const ITypeInfo, @ptrCast(self)), rgszNames, cNames, pMemId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_Invoke(self: *const T, pvInstance: ?*anyopaque, memid: i32, wFlags: u16, pDispParams: ?*DISPPARAMS, pVarResult: ?*VARIANT, pExcepInfo: ?*EXCEPINFO, puArgErr: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).Invoke(@as(*const ITypeInfo, @ptrCast(self)), pvInstance, memid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetDocumentation(self: *const T, memid: i32, pBstrName: ?*?BSTR, pBstrDocString: ?*?BSTR, pdwHelpContext: ?*u32, pBstrHelpFile: ?*?BSTR) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetDocumentation(@as(*const ITypeInfo, @ptrCast(self)), memid, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetDllEntry(self: *const T, memid: i32, invKind: INVOKEKIND, pBstrDllName: ?*?BSTR, pBstrName: ?*?BSTR, pwOrdinal: ?*u16) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetDllEntry(@as(*const ITypeInfo, @ptrCast(self)), memid, invKind, pBstrDllName, pBstrName, pwOrdinal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetRefTypeInfo(self: *const T, hRefType: u32, ppTInfo: ?*?*ITypeInfo) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetRefTypeInfo(@as(*const ITypeInfo, @ptrCast(self)), hRefType, ppTInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_AddressOfMember(self: *const T, memid: i32, invKind: INVOKEKIND, ppv: ?*?*anyopaque) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).AddressOfMember(@as(*const ITypeInfo, @ptrCast(self)), memid, invKind, ppv);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_CreateInstance(self: *const T, pUnkOuter: ?*IUnknown, riid: ?*const Guid, ppvObj: ?*?*anyopaque) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).CreateInstance(@as(*const ITypeInfo, @ptrCast(self)), pUnkOuter, riid, ppvObj);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetMops(self: *const T, memid: i32, pBstrMops: ?*?BSTR) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetMops(@as(*const ITypeInfo, @ptrCast(self)), memid, pBstrMops);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_GetContainingTypeLib(self: *const T, ppTLib: ?*?*ITypeLib, pIndex: ?*u32) HRESULT {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).GetContainingTypeLib(@as(*const ITypeInfo, @ptrCast(self)), ppTLib, pIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_ReleaseTypeAttr(self: *const T, pTypeAttr: ?*TYPEATTR) void {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).ReleaseTypeAttr(@as(*const ITypeInfo, @ptrCast(self)), pTypeAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_ReleaseFuncDesc(self: *const T, pFuncDesc: ?*FUNCDESC) void {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).ReleaseFuncDesc(@as(*const ITypeInfo, @ptrCast(self)), pFuncDesc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo_ReleaseVarDesc(self: *const T, pVarDesc: ?*VARDESC) void {
                return @as(*const ITypeInfo.VTable, @ptrCast(self.vtable)).ReleaseVarDesc(@as(*const ITypeInfo, @ptrCast(self)), pVarDesc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeInfo2_Value = Guid.initString("00020412-0000-0000-c000-000000000046");
pub const IID_ITypeInfo2 = &IID_ITypeInfo2_Value;
pub const ITypeInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeInfo.VTable,
        GetTypeKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                pTypeKind: ?*TYPEKIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                pTypeKind: ?*TYPEKIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                pTypeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                pTypeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFuncIndexOfMemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                memid: i32,
                invKind: INVOKEKIND,
                pFuncIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                memid: i32,
                invKind: INVOKEKIND,
                pFuncIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVarIndexOfMemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                memid: i32,
                pVarIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                memid: i32,
                pVarIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFuncCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParamCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                indexFunc: u32,
                indexParam: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                indexFunc: u32,
                indexParam: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVarCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplTypeCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                index: u32,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentation2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                memid: i32,
                lcid: u32,
                pbstrHelpString: ?*?BSTR,
                pdwHelpStringContext: ?*u32,
                pbstrHelpStringDll: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                memid: i32,
                lcid: u32,
                pbstrHelpString: ?*?BSTR,
                pdwHelpStringContext: ?*u32,
                pbstrHelpStringDll: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllFuncCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                index: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                index: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllParamCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                indexFunc: u32,
                indexParam: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                indexFunc: u32,
                indexParam: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllVarCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                index: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                index: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllImplTypeCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeInfo2,
                index: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeInfo2,
                index: u32,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITypeInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetTypeKind(self: *const T, pTypeKind: ?*TYPEKIND) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetTypeKind(@as(*const ITypeInfo2, @ptrCast(self)), pTypeKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetTypeFlags(self: *const T, pTypeFlags: ?*u32) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetTypeFlags(@as(*const ITypeInfo2, @ptrCast(self)), pTypeFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetFuncIndexOfMemId(self: *const T, memid: i32, invKind: INVOKEKIND, pFuncIndex: ?*u32) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetFuncIndexOfMemId(@as(*const ITypeInfo2, @ptrCast(self)), memid, invKind, pFuncIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetVarIndexOfMemId(self: *const T, memid: i32, pVarIndex: ?*u32) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetVarIndexOfMemId(@as(*const ITypeInfo2, @ptrCast(self)), memid, pVarIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetCustData(@as(*const ITypeInfo2, @ptrCast(self)), guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetFuncCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetFuncCustData(@as(*const ITypeInfo2, @ptrCast(self)), index, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetParamCustData(self: *const T, indexFunc: u32, indexParam: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetParamCustData(@as(*const ITypeInfo2, @ptrCast(self)), indexFunc, indexParam, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetVarCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetVarCustData(@as(*const ITypeInfo2, @ptrCast(self)), index, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetImplTypeCustData(self: *const T, index: u32, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetImplTypeCustData(@as(*const ITypeInfo2, @ptrCast(self)), index, guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetDocumentation2(self: *const T, memid: i32, lcid: u32, pbstrHelpString: ?*?BSTR, pdwHelpStringContext: ?*u32, pbstrHelpStringDll: ?*?BSTR) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetDocumentation2(@as(*const ITypeInfo2, @ptrCast(self)), memid, lcid, pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetAllCustData(self: *const T, pCustData: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllCustData(@as(*const ITypeInfo2, @ptrCast(self)), pCustData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetAllFuncCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllFuncCustData(@as(*const ITypeInfo2, @ptrCast(self)), index, pCustData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetAllParamCustData(self: *const T, indexFunc: u32, indexParam: u32, pCustData: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllParamCustData(@as(*const ITypeInfo2, @ptrCast(self)), indexFunc, indexParam, pCustData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetAllVarCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllVarCustData(@as(*const ITypeInfo2, @ptrCast(self)), index, pCustData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeInfo2_GetAllImplTypeCustData(self: *const T, index: u32, pCustData: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeInfo2.VTable, @ptrCast(self.vtable)).GetAllImplTypeCustData(@as(*const ITypeInfo2, @ptrCast(self)), index, pCustData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYSKIND = enum(i32) {
    WIN16 = 0,
    WIN32 = 1,
    MAC = 2,
    WIN64 = 3,
};
pub const SYS_WIN16 = SYSKIND.WIN16;
pub const SYS_WIN32 = SYSKIND.WIN32;
pub const SYS_MAC = SYSKIND.MAC;
pub const SYS_WIN64 = SYSKIND.WIN64;

pub const TLIBATTR = extern struct {
    guid: Guid,
    lcid: u32,
    syskind: SYSKIND,
    wMajorVerNum: u16,
    wMinorVerNum: u16,
    wLibFlags: u16,
};

const IID_ITypeLib_Value = Guid.initString("00020402-0000-0000-c000-000000000046");
pub const IID_ITypeLib = &IID_ITypeLib_Value;
pub const ITypeLib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTypeInfoCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn (
                self: *const ITypeLib,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                index: u32,
                ppTInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                index: u32,
                ppTInfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeInfoType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                index: u32,
                pTKind: ?*TYPEKIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                index: u32,
                pTKind: ?*TYPEKIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeInfoOfGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                guid: ?*const Guid,
                ppTinfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                guid: ?*const Guid,
                ppTinfo: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLibAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                ppTLibAttr: ?*?*TLIBATTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                ppTLibAttr: ?*?*TLIBATTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeComp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                ppTComp: ?*?*ITypeComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                ppTComp: ?*?*ITypeComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                index: i32,
                pBstrName: ?*?BSTR,
                pBstrDocString: ?*?BSTR,
                pdwHelpContext: ?*u32,
                pBstrHelpFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                index: i32,
                pBstrName: ?*?BSTR,
                pBstrDocString: ?*?BSTR,
                pdwHelpContext: ?*u32,
                pBstrHelpFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                szNameBuf: ?PWSTR,
                lHashVal: u32,
                pfName: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                szNameBuf: ?PWSTR,
                lHashVal: u32,
                pfName: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                szNameBuf: ?PWSTR,
                lHashVal: u32,
                ppTInfo: [*]?*ITypeInfo,
                rgMemId: [*]i32,
                pcFound: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib,
                szNameBuf: ?PWSTR,
                lHashVal: u32,
                ppTInfo: [*]?*ITypeInfo,
                rgMemId: [*]i32,
                pcFound: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseTLibAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib,
                pTLibAttr: ?*TLIBATTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const ITypeLib,
                pTLibAttr: ?*TLIBATTR,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetTypeInfoCount(self: *const T) u32 {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfoCount(@as(*const ITypeLib, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetTypeInfo(self: *const T, index: u32, ppTInfo: ?*?*ITypeInfo) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const ITypeLib, @ptrCast(self)), index, ppTInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetTypeInfoType(self: *const T, index: u32, pTKind: ?*TYPEKIND) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfoType(@as(*const ITypeLib, @ptrCast(self)), index, pTKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetTypeInfoOfGuid(self: *const T, guid: ?*const Guid, ppTinfo: ?*?*ITypeInfo) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeInfoOfGuid(@as(*const ITypeLib, @ptrCast(self)), guid, ppTinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetLibAttr(self: *const T, ppTLibAttr: ?*?*TLIBATTR) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetLibAttr(@as(*const ITypeLib, @ptrCast(self)), ppTLibAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetTypeComp(self: *const T, ppTComp: ?*?*ITypeComp) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetTypeComp(@as(*const ITypeLib, @ptrCast(self)), ppTComp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_GetDocumentation(self: *const T, index: i32, pBstrName: ?*?BSTR, pBstrDocString: ?*?BSTR, pdwHelpContext: ?*u32, pBstrHelpFile: ?*?BSTR) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).GetDocumentation(@as(*const ITypeLib, @ptrCast(self)), index, pBstrName, pBstrDocString, pdwHelpContext, pBstrHelpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_IsName(self: *const T, szNameBuf: ?PWSTR, lHashVal: u32, pfName: ?*BOOL) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).IsName(@as(*const ITypeLib, @ptrCast(self)), szNameBuf, lHashVal, pfName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_FindName(self: *const T, szNameBuf: ?PWSTR, lHashVal: u32, ppTInfo: [*]?*ITypeInfo, rgMemId: [*]i32, pcFound: ?*u16) HRESULT {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).FindName(@as(*const ITypeLib, @ptrCast(self)), szNameBuf, lHashVal, ppTInfo, rgMemId, pcFound);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib_ReleaseTLibAttr(self: *const T, pTLibAttr: ?*TLIBATTR) void {
                return @as(*const ITypeLib.VTable, @ptrCast(self.vtable)).ReleaseTLibAttr(@as(*const ITypeLib, @ptrCast(self)), pTLibAttr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLib2_Value = Guid.initString("00020411-0000-0000-c000-000000000046");
pub const IID_ITypeLib2 = &IID_ITypeLib2_Value;
pub const ITypeLib2 = extern struct {
    pub const VTable = extern struct {
        base: ITypeLib.VTable,
        GetCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib2,
                guid: ?*const Guid,
                pVarVal: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLibStatistics: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib2,
                pcUniqueNames: ?*u32,
                pcchUniqueNames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib2,
                pcUniqueNames: ?*u32,
                pcchUniqueNames: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentation2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib2,
                index: i32,
                lcid: u32,
                pbstrHelpString: ?*?BSTR,
                pdwHelpStringContext: ?*u32,
                pbstrHelpStringDll: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib2,
                index: i32,
                lcid: u32,
                pbstrHelpString: ?*?BSTR,
                pdwHelpStringContext: ?*u32,
                pbstrHelpStringDll: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllCustData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLib2,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLib2,
                pCustData: ?*CUSTDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace ITypeLib.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib2_GetCustData(self: *const T, guid: ?*const Guid, pVarVal: ?*VARIANT) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetCustData(@as(*const ITypeLib2, @ptrCast(self)), guid, pVarVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib2_GetLibStatistics(self: *const T, pcUniqueNames: ?*u32, pcchUniqueNames: ?*u32) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetLibStatistics(@as(*const ITypeLib2, @ptrCast(self)), pcUniqueNames, pcchUniqueNames);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib2_GetDocumentation2(self: *const T, index: i32, lcid: u32, pbstrHelpString: ?*?BSTR, pdwHelpStringContext: ?*u32, pbstrHelpStringDll: ?*?BSTR) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetDocumentation2(@as(*const ITypeLib2, @ptrCast(self)), index, lcid, pbstrHelpString, pdwHelpStringContext, pbstrHelpStringDll);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLib2_GetAllCustData(self: *const T, pCustData: ?*CUSTDATA) HRESULT {
                return @as(*const ITypeLib2.VTable, @ptrCast(self.vtable)).GetAllCustData(@as(*const ITypeLib2, @ptrCast(self)), pCustData);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorInfo_Value = Guid.initString("1cf2b120-547d-101b-8e65-08002b2bd119");
pub const IID_IErrorInfo = &IID_IErrorInfo_Value;
pub const IErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGUID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorInfo,
                pGUID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorInfo,
                pGUID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorInfo,
                pBstrSource: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorInfo,
                pBstrSource: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorInfo,
                pBstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorInfo,
                pBstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorInfo,
                pBstrHelpFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorInfo,
                pBstrHelpFile: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelpContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorInfo,
                pdwHelpContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorInfo,
                pdwHelpContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorInfo_GetGUID(self: *const T, pGUID: ?*Guid) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetGUID(@as(*const IErrorInfo, @ptrCast(self)), pGUID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorInfo_GetSource(self: *const T, pBstrSource: ?*?BSTR) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetSource(@as(*const IErrorInfo, @ptrCast(self)), pBstrSource);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorInfo_GetDescription(self: *const T, pBstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IErrorInfo, @ptrCast(self)), pBstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorInfo_GetHelpFile(self: *const T, pBstrHelpFile: ?*?BSTR) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetHelpFile(@as(*const IErrorInfo, @ptrCast(self)), pBstrHelpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorInfo_GetHelpContext(self: *const T, pdwHelpContext: ?*u32) HRESULT {
                return @as(*const IErrorInfo.VTable, @ptrCast(self.vtable)).GetHelpContext(@as(*const IErrorInfo, @ptrCast(self)), pdwHelpContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISupportErrorInfo_Value = Guid.initString("df0b3d60-548f-101b-8e65-08002b2bd119");
pub const IID_ISupportErrorInfo = &IID_ISupportErrorInfo_Value;
pub const ISupportErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InterfaceSupportsErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISupportErrorInfo,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISupportErrorInfo,
                riid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISupportErrorInfo_InterfaceSupportsErrorInfo(self: *const T, riid: ?*const Guid) HRESULT {
                return @as(*const ISupportErrorInfo.VTable, @ptrCast(self.vtable)).InterfaceSupportsErrorInfo(@as(*const ISupportErrorInfo, @ptrCast(self)), riid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLog_Value = Guid.initString("3127ca40-446e-11ce-8135-00aa004bb851");
pub const IID_IErrorLog = &IID_IErrorLog_Value;
pub const IErrorLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IErrorLog,
                pszPropName: ?[*:0]const u16,
                pExcepInfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IErrorLog,
                pszPropName: ?[*:0]const u16,
                pExcepInfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IErrorLog_AddError(self: *const T, pszPropName: ?[*:0]const u16, pExcepInfo: ?*EXCEPINFO) HRESULT {
                return @as(*const IErrorLog.VTable, @ptrCast(self.vtable)).AddError(@as(*const IErrorLog, @ptrCast(self)), pszPropName, pExcepInfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistrationReader_Value = Guid.initString("ed6a8a2a-b160-4e77-8f73-aa7435cd5c27");
pub const IID_ITypeLibRegistrationReader = &IID_ITypeLibRegistrationReader_Value;
pub const ITypeLibRegistrationReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumTypeLibRegistrations: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistrationReader,
                ppEnumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistrationReader,
                ppEnumUnknown: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistrationReader_EnumTypeLibRegistrations(self: *const T, ppEnumUnknown: ?*?*IEnumUnknown) HRESULT {
                return @as(*const ITypeLibRegistrationReader.VTable, @ptrCast(self.vtable)).EnumTypeLibRegistrations(@as(*const ITypeLibRegistrationReader, @ptrCast(self)), ppEnumUnknown);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeLibRegistration_Value = Guid.initString("76a3e735-02df-4a12-98eb-043ad3600af3");
pub const IID_ITypeLibRegistration = &IID_ITypeLibRegistration_Value;
pub const ITypeLibRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLcid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pLcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pLcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWin32Path: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pWin32Path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pWin32Path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWin64Path: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pWin64Path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pWin64Path: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pDisplayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pDisplayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHelpDir: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITypeLibRegistration,
                pHelpDir: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITypeLibRegistration,
                pHelpDir: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetGuid(self: *const T, pGuid: ?*Guid) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetGuid(@as(*const ITypeLibRegistration, @ptrCast(self)), pGuid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetVersion(self: *const T, pVersion: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const ITypeLibRegistration, @ptrCast(self)), pVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetLcid(self: *const T, pLcid: ?*u32) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetLcid(@as(*const ITypeLibRegistration, @ptrCast(self)), pLcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetWin32Path(self: *const T, pWin32Path: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetWin32Path(@as(*const ITypeLibRegistration, @ptrCast(self)), pWin32Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetWin64Path(self: *const T, pWin64Path: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetWin64Path(@as(*const ITypeLibRegistration, @ptrCast(self)), pWin64Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetDisplayName(self: *const T, pDisplayName: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const ITypeLibRegistration, @ptrCast(self)), pDisplayName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetFlags(self: *const T, pFlags: ?*u32) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const ITypeLibRegistration, @ptrCast(self)), pFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITypeLibRegistration_GetHelpDir(self: *const T, pHelpDir: ?*?BSTR) HRESULT {
                return @as(*const ITypeLibRegistration.VTable, @ptrCast(self.vtable)).GetHelpDir(@as(*const ITypeLibRegistration, @ptrCast(self)), pHelpDir);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const CONNECTDATA = extern struct {
    pUnk: ?*IUnknown,
    dwCookie: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnections_Value = Guid.initString("b196b287-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnections = &IID_IEnumConnections_Value;
pub const IEnumConnections = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnections,
                cConnections: u32,
                rgcd: [*]CONNECTDATA,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnections,
                cConnections: u32,
                rgcd: [*]CONNECTDATA,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnections,
                cConnections: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnections,
                cConnections: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnections,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnections,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnections,
                ppEnum: ?*?*IEnumConnections,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnections,
                ppEnum: ?*?*IEnumConnections,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnections_Next(self: *const T, cConnections: u32, rgcd: [*]CONNECTDATA, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumConnections, @ptrCast(self)), cConnections, rgcd, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnections_Skip(self: *const T, cConnections: u32) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumConnections, @ptrCast(self)), cConnections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnections_Reset(self: *const T) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumConnections, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnections_Clone(self: *const T, ppEnum: ?*?*IEnumConnections) HRESULT {
                return @as(*const IEnumConnections.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumConnections, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPoint_Value = Guid.initString("b196b286-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPoint = &IID_IConnectionPoint_Value;
pub const IConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectionInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPoint,
                pIID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPoint,
                pIID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConnectionPointContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPoint,
                ppCPC: ?*?*IConnectionPointContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPoint,
                ppCPC: ?*?*IConnectionPointContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPoint,
                pUnkSink: ?*IUnknown,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPoint,
                pUnkSink: ?*IUnknown,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPoint,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPoint,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumConnections: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPoint,
                ppEnum: ?*?*IEnumConnections,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPoint,
                ppEnum: ?*?*IEnumConnections,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPoint_GetConnectionInterface(self: *const T, pIID: ?*Guid) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).GetConnectionInterface(@as(*const IConnectionPoint, @ptrCast(self)), pIID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPoint_GetConnectionPointContainer(self: *const T, ppCPC: ?*?*IConnectionPointContainer) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).GetConnectionPointContainer(@as(*const IConnectionPoint, @ptrCast(self)), ppCPC);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPoint_Advise(self: *const T, pUnkSink: ?*IUnknown, pdwCookie: ?*u32) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).Advise(@as(*const IConnectionPoint, @ptrCast(self)), pUnkSink, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPoint_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IConnectionPoint, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPoint_EnumConnections(self: *const T, ppEnum: ?*?*IEnumConnections) HRESULT {
                return @as(*const IConnectionPoint.VTable, @ptrCast(self.vtable)).EnumConnections(@as(*const IConnectionPoint, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumConnectionPoints_Value = Guid.initString("b196b285-bab4-101a-b69c-00aa00341d07");
pub const IID_IEnumConnectionPoints = &IID_IEnumConnectionPoints_Value;
pub const IEnumConnectionPoints = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnectionPoints,
                cConnections: u32,
                ppCP: [*]?*IConnectionPoint,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnectionPoints,
                cConnections: u32,
                ppCP: [*]?*IConnectionPoint,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnectionPoints,
                cConnections: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnectionPoints,
                cConnections: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnectionPoints,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnectionPoints,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumConnectionPoints,
                ppEnum: ?*?*IEnumConnectionPoints,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumConnectionPoints,
                ppEnum: ?*?*IEnumConnectionPoints,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnectionPoints_Next(self: *const T, cConnections: u32, ppCP: [*]?*IConnectionPoint, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumConnectionPoints, @ptrCast(self)), cConnections, ppCP, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnectionPoints_Skip(self: *const T, cConnections: u32) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumConnectionPoints, @ptrCast(self)), cConnections);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnectionPoints_Reset(self: *const T) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumConnectionPoints, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumConnectionPoints_Clone(self: *const T, ppEnum: ?*?*IEnumConnectionPoints) HRESULT {
                return @as(*const IEnumConnectionPoints.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumConnectionPoints, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConnectionPointContainer_Value = Guid.initString("b196b284-bab4-101a-b69c-00aa00341d07");
pub const IID_IConnectionPointContainer = &IID_IConnectionPointContainer_Value;
pub const IConnectionPointContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumConnectionPoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPointContainer,
                ppEnum: ?*?*IEnumConnectionPoints,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPointContainer,
                ppEnum: ?*?*IEnumConnectionPoints,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindConnectionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IConnectionPointContainer,
                riid: ?*const Guid,
                ppCP: ?*?*IConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IConnectionPointContainer,
                riid: ?*const Guid,
                ppCP: ?*?*IConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPointContainer_EnumConnectionPoints(self: *const T, ppEnum: ?*?*IEnumConnectionPoints) HRESULT {
                return @as(*const IConnectionPointContainer.VTable, @ptrCast(self.vtable)).EnumConnectionPoints(@as(*const IConnectionPointContainer, @ptrCast(self)), ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IConnectionPointContainer_FindConnectionPoint(self: *const T, riid: ?*const Guid, ppCP: ?*?*IConnectionPoint) HRESULT {
                return @as(*const IConnectionPointContainer.VTable, @ptrCast(self.vtable)).FindConnectionPoint(@as(*const IConnectionPointContainer, @ptrCast(self)), riid, ppCP);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistMemory_Value = Guid.initString("bd1ae5e0-a6ae-11ce-bd37-504200c10000");
pub const IID_IPersistMemory = &IID_IPersistMemory_Value;
pub const IPersistMemory = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistMemory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistMemory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistMemory,
                pMem: [*]u8,
                cbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistMemory,
                pMem: [*]u8,
                cbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistMemory,
                pMem: [*]u8,
                fClearDirty: BOOL,
                cbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistMemory,
                pMem: [*]u8,
                fClearDirty: BOOL,
                cbSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSizeMax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistMemory,
                pCbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistMemory,
                pCbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistMemory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistMemory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistMemory_IsDirty(self: *const T) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistMemory, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistMemory_Load(self: *const T, pMem: [*]u8, cbSize: u32) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistMemory, @ptrCast(self)), pMem, cbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistMemory_Save(self: *const T, pMem: [*]u8, fClearDirty: BOOL, cbSize: u32) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistMemory, @ptrCast(self)), pMem, fClearDirty, cbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistMemory_GetSizeMax(self: *const T, pCbSize: ?*u32) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).GetSizeMax(@as(*const IPersistMemory, @ptrCast(self)), pCbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistMemory_InitNew(self: *const T) HRESULT {
                return @as(*const IPersistMemory.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistMemory, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStreamInit_Value = Guid.initString("7fd52380-4e07-101b-ae2d-08002b2ec713");
pub const IID_IPersistStreamInit = &IID_IPersistStreamInit_Value;
pub const IPersistStreamInit = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStreamInit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStreamInit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStreamInit,
                pStm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStreamInit,
                pStm: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStreamInit,
                pStm: ?*IStream,
                fClearDirty: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStreamInit,
                pStm: ?*IStream,
                fClearDirty: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSizeMax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStreamInit,
                pCbSize: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStreamInit,
                pCbSize: ?*ULARGE_INTEGER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPersistStreamInit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPersistStreamInit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IPersist.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStreamInit_IsDirty(self: *const T) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStreamInit, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStreamInit_Load(self: *const T, pStm: ?*IStream) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStreamInit, @ptrCast(self)), pStm);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStreamInit_Save(self: *const T, pStm: ?*IStream, fClearDirty: BOOL) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStreamInit, @ptrCast(self)), pStm, fClearDirty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStreamInit_GetSizeMax(self: *const T, pCbSize: ?*ULARGE_INTEGER) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).GetSizeMax(@as(*const IPersistStreamInit, @ptrCast(self)), pCbSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPersistStreamInit_InitNew(self: *const T) HRESULT {
                return @as(*const IPersistStreamInit.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistStreamInit, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

//--------------------------------------------------------------------------------
// Section: Functions (110)
//--------------------------------------------------------------------------------
pub extern "ole32" fn CoBuildVersion() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoInitialize(
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterMallocSpy(
    pMallocSpy: ?*IMallocSpy,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevokeMallocSpy() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoRegisterInitializeSpy(
    pSpy: ?*IInitializeSpy,
    puliCookie: ?*ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevokeInitializeSpy(
    uliCookie: ULARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetSystemSecurityPermissions(
    comSDType: COMSD,
    ppSD: ?*?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoLoadLibrary(
    lpszLibName: ?PWSTR,
    bAutoFree: BOOL,
) callconv(@import("std").os.windows.WINAPI) ?HINSTANCE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFreeLibrary(
    hInst: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFreeAllLibraries() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoAllowSetForegroundWindow(
    pUnk: ?*IUnknown,
    lpvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn DcomChannelSetHResult(
    pvReserved: ?*anyopaque,
    pulReserved: ?*u32,
    appsHR: HRESULT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoIsOle1Class(
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CLSIDFromProgIDEx(
    lpszProgID: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFileTimeToDosDateTime(
    lpFileTime: ?*FILETIME,
    lpDosDate: ?*u16,
    lpDosTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoDosDateTimeToFileTime(
    nDosDate: u16,
    nDosTime: u16,
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFileTimeNow(
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoRegisterChannelHook(
    ExtensionUuid: ?*const Guid,
    pChannelHook: ?*IChannelHook,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTreatAsClass(
    clsidOld: ?*const Guid,
    clsidNew: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateDataAdviseHolder(
    ppDAHolder: ?*?*IDataAdviseHolder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateDataCache(
    pUnkOuter: ?*IUnknown,
    rclsid: ?*const Guid,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoInstall(
    pbc: ?*IBindCtx,
    dwFlags: u32,
    pClassSpec: ?*uCLSSPEC,
    pQuery: ?*QUERYCONTEXT,
    pszCodeBase: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn BindMoniker(
    pmk: ?*IMoniker,
    grfOpt: u32,
    iidResult: ?*const Guid,
    ppvResult: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetObject(
    pszName: ?[*:0]const u16,
    pBindOptions: ?*BIND_OPTS,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MkParseDisplayName(
    pbc: ?*IBindCtx,
    szUserName: ?[*:0]const u16,
    pchEaten: ?*u32,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerRelativePathTo(
    pmkSrc: ?*IMoniker,
    pmkDest: ?*IMoniker,
    ppmkRelPath: ?*?*IMoniker,
    dwReserved: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn MonikerCommonPrefixWith(
    pmkThis: ?*IMoniker,
    pmkOther: ?*IMoniker,
    ppmkCommon: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateBindCtx(
    reserved: u32,
    ppbc: ?*?*IBindCtx,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateGenericComposite(
    pmkFirst: ?*IMoniker,
    pmkRest: ?*IMoniker,
    ppmkComposite: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetClassFile(
    szFilename: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateClassMoniker(
    rclsid: ?*const Guid,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateFileMoniker(
    lpszPathName: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateItemMoniker(
    lpszDelim: ?[*:0]const u16,
    lpszItem: ?[*:0]const u16,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateAntiMoniker(
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreatePointerMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateObjrefMoniker(
    punk: ?*IUnknown,
    ppmk: ?*?*IMoniker,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetRunningObjectTable(
    reserved: u32,
    pprot: ?*?*IRunningObjectTable,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CreateStdProgressIndicator(
    hwndParent: ?HWND,
    pszTitle: ?[*:0]const u16,
    pIbscCaller: ?*IBindStatusCallback,
    ppIbsc: ?*?*IBindStatusCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetMalloc(
    dwMemContext: u32,
    ppMalloc: ?*?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoUninitialize() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCurrentProcess() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoInitializeEx(
    pvReserved: ?*anyopaque,
    dwCoInit: COINIT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCallerTID(
    lpdwTID: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCurrentLogicalThreadId(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetContextToken(
    pToken: ?*usize,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ole32" fn CoGetApartmentType(
    pAptType: ?*APTTYPE,
    pAptQualifier: ?*APTTYPEQUALIFIER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoIncrementMTAUsage(
    pCookie: ?*CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoDecrementMTAUsage(
    Cookie: CO_MTA_USAGE_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ole32" fn CoAllowUnmarshalerCLSID(
    clsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetObjectContext(
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetClassObject(
    rclsid: ?*const Guid,
    dwClsContext: CLSCTX,
    pvReserved: ?*anyopaque,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterClassObject(
    rclsid: ?*const Guid,
    pUnk: ?*IUnknown,
    dwClsContext: CLSCTX,
    flags: u32,
    lpdwRegister: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevokeClassObject(
    dwRegister: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoResumeClassObjects() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSuspendClassObjects() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoAddRefServerProcess() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoReleaseServerProcess() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetPSClsid(
    riid: ?*const Guid,
    pClsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterPSClsid(
    riid: ?*const Guid,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRegisterSurrogate(
    pSurrogate: ?*ISurrogate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoDisconnectObject(
    pUnk: ?*IUnknown,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoLockObjectExternal(
    pUnk: ?*IUnknown,
    fLock: BOOL,
    fLastUnlockReleases: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoIsHandlerConnected(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateFreeThreadedMarshaler(
    punkOuter: ?*IUnknown,
    ppunkMarshal: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoFreeUnusedLibraries() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoFreeUnusedLibrariesEx(
    dwUnloadDelay: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ole32" fn CoDisconnectContext(
    dwTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoInitializeSecurity(
    pSecDesc: ?*SECURITY_DESCRIPTOR,
    cAuthSvc: i32,
    asAuthSvc: ?[*]SOLE_AUTHENTICATION_SERVICE,
    pReserved1: ?*anyopaque,
    dwAuthnLevel: RPC_C_AUTHN_LEVEL,
    dwImpLevel: RPC_C_IMP_LEVEL,
    pAuthList: ?*anyopaque,
    dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
    pReserved3: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCallContext(
    riid: ?*const Guid,
    ppInterface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoQueryProxyBlanket(
    pProxy: ?*IUnknown,
    pwAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?PWSTR,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pAuthInfo: ?*?*anyopaque,
    pCapabilites: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSetProxyBlanket(
    pProxy: ?*IUnknown,
    dwAuthnSvc: u32,
    dwAuthzSvc: u32,
    pServerPrincName: ?PWSTR,
    dwAuthnLevel: RPC_C_AUTHN_LEVEL,
    dwImpLevel: RPC_C_IMP_LEVEL,
    pAuthInfo: ?*anyopaque,
    dwCapabilities: EOLE_AUTHENTICATION_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCopyProxy(
    pProxy: ?*IUnknown,
    ppCopy: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoQueryClientBlanket(
    pAuthnSvc: ?*u32,
    pAuthzSvc: ?*u32,
    pServerPrincName: ?*?PWSTR,
    pAuthnLevel: ?*u32,
    pImpLevel: ?*u32,
    pPrivs: ?*?*anyopaque,
    pCapabilities: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoImpersonateClient() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoRevertToSelf() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoQueryAuthenticationServices(
    pcAuthSvc: ?*u32,
    asAuthSvc: ?*?*SOLE_AUTHENTICATION_SERVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSwitchCallContext(
    pNewObject: ?*IUnknown,
    ppOldObject: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateInstance(
    rclsid: ?*const Guid,
    pUnkOuter: ?*IUnknown,
    dwClsContext: CLSCTX,
    riid: *const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateInstanceEx(
    Clsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    pServerInfo: ?*COSERVERINFO,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "ole32" fn CoCreateInstanceFromApp(
    Clsid: ?*const Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    reserved: ?*anyopaque,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoRegisterActivationFilter(
    pActivationFilter: ?*IActivationFilter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetCancelObject(
    dwThreadId: u32,
    iid: ?*const Guid,
    ppUnk: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoSetCancelObject(
    pUnk: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCancelCall(
    dwThreadId: u32,
    ulTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTestCancel() callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoEnableCallCancellation(
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoDisableCallCancellation(
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StringFromCLSID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CLSIDFromString(
    lpsz: ?[*:0]const u16,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StringFromIID(
    rclsid: ?*const Guid,
    lplpsz: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn IIDFromString(
    lpsz: ?[*:0]const u16,
    lpiid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ProgIDFromCLSID(
    clsid: ?*const Guid,
    lplpszProgID: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CLSIDFromProgID(
    lpszProgID: ?[*:0]const u16,
    lpclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StringFromGUID2(
    rguid: ?*const Guid,
    lpsz: [*:0]u16,
    cchMax: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoCreateGuid(
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoWaitForMultipleHandles(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: [*]?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoWaitForMultipleObjects(
    dwFlags: u32,
    dwTimeout: u32,
    cHandles: u32,
    pHandles: [*]const ?HANDLE,
    lpdwindex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetTreatAsClass(
    clsidOld: ?*const Guid,
    pClsidNew: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ole32" fn CoInvalidateRemoteMachineBindings(
    pszMachineName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTaskMemAlloc(
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTaskMemRealloc(
    pv: ?*anyopaque,
    cb: usize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoTaskMemFree(
    pv: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ole32" fn CoRegisterDeviceCatalog(
    deviceInstanceId: ?[*:0]const u16,
    cookie: ?*CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn CoRevokeDeviceCatalog(
    cookie: CO_DEVICE_CATALOG_COOKIE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUri(
    pwzURI: ?[*:0]const u16,
    dwFlags: URI_CREATE_FLAGS,
    dwReserved: usize,
    ppURI: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUriWithFragment(
    pwzURI: ?[*:0]const u16,
    pwzFragment: ?[*:0]const u16,
    dwFlags: u32,
    dwReserved: usize,
    ppURI: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateUriFromMultiByteString(
    pszANSIInputUri: ?[*:0]const u8,
    dwEncodingFlags: u32,
    dwCodePage: u32,
    dwCreateFlags: u32,
    dwReserved: usize,
    ppUri: ?*?*IUri,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "urlmon" fn CreateIUriBuilder(
    pIUri: ?*IUri,
    dwFlags: u32,
    dwReserved: usize,
    ppIUriBuilder: ?*?*IUriBuilder,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn SetErrorInfo(
    dwReserved: u32,
    perrinfo: ?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "oleaut32" fn GetErrorInfo(
    dwReserved: u32,
    pperrinfo: ?*?*IErrorInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {},
    .wide => struct {},
    .unspecified => if (@import("builtin").is_test) struct {} else struct {},
};
//--------------------------------------------------------------------------------
// Section: Imports (27)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ARRAYDESC = @import("../system/ole.zig").ARRAYDESC;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const DECIMAL = @import("../foundation.zig").DECIMAL;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HBITMAP = @import("../graphics/gdi.zig").HBITMAP;
const HENHMETAFILE = @import("../graphics/gdi.zig").HENHMETAFILE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IRecordInfo = @import("../system/ole.zig").IRecordInfo;
const IStorage = @import("../system/com/structured_storage.zig").IStorage;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PARAMDESC = @import("../system/ole.zig").PARAMDESC;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const SECURITY_DESCRIPTOR = @import("../security.zig").SECURITY_DESCRIPTOR;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;
const userHBITMAP = @import("../system/system_services.zig").userHBITMAP;
const userHENHMETAFILE = @import("../system/system_services.zig").userHENHMETAFILE;
const userHGLOBAL = @import("../system/system_services.zig").userHGLOBAL;
const userHMETAFILEPICT = @import("../system/system_services.zig").userHMETAFILEPICT;
const userHPALETTE = @import("../system/system_services.zig").userHPALETTE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPFNGETCLASSOBJECT")) {
        _ = LPFNGETCLASSOBJECT;
    }
    if (@hasDecl(@This(), "LPFNCANUNLOADNOW")) {
        _ = LPFNCANUNLOADNOW;
    }
    if (@hasDecl(@This(), "PFNCONTEXTCALL")) {
        _ = PFNCONTEXTCALL;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (7)
//--------------------------------------------------------------------------------
pub const call_obj = @import("com/call_obj.zig");
pub const channel_credentials = @import("com/channel_credentials.zig");
pub const events = @import("com/events.zig");
pub const marshal = @import("com/marshal.zig");
pub const structured_storage = @import("com/structured_storage.zig");
pub const ui = @import("com/ui.zig");
pub const urlmon = @import("com/urlmon.zig");
