//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1302)
//--------------------------------------------------------------------------------
pub const WOW64_CONTEXT_i386 = @as(u32, 65536);
pub const WOW64_CONTEXT_i486 = @as(u32, 65536);
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE = @as(u32, 134217728);
pub const WOW64_CONTEXT_SERVICE_ACTIVE = @as(u32, 268435456);
pub const WOW64_CONTEXT_EXCEPTION_REQUEST = @as(u32, 1073741824);
pub const WOW64_CONTEXT_EXCEPTION_REPORTING = @as(u32, 2147483648);
pub const WOW64_SIZE_OF_80387_REGISTERS = @as(u32, 80);
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION = @as(u32, 512);
pub const ERROR_DBG_CANCELLED = @as(u32, 3221226695);
pub const ERROR_DBG_TIMEOUT = @as(u32, 3221226932);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_DOT_COMMANDS = @as(u32, 1);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_EXTENSION_COMMANDS = @as(u32, 2);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_SYMBOLS = @as(u32, 4);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_DOT_COMMAND = @as(u32, 1);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_EXTENSION_COMMAND = @as(u32, 2);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_SYMBOL = @as(u32, 4);
pub const DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER = @as(u32, 0);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT = @as(u32, 1);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_THREAD = @as(u32, 2);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_RECORD = @as(u32, 3);
pub const DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS = @as(u32, 4);
pub const DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS = @as(u32, 5);
pub const DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS = @as(u32, 6);
pub const DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM = @as(u32, 7);
pub const DEBUG_REQUEST_TARGET_CAN_DETACH = @as(u32, 8);
pub const DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE = @as(u32, 9);
pub const DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET = @as(u32, 10);
pub const DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM = @as(u32, 11);
pub const DEBUG_REQUEST_EXT_TYPED_DATA_ANSI = @as(u32, 12);
pub const DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE = @as(u32, 13);
pub const DEBUG_REQUEST_GET_TEXT_COMPLETIONS_WIDE = @as(u32, 14);
pub const DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO = @as(u32, 15);
pub const DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO = @as(u32, 16);
pub const DEBUG_REQUEST_REMOVE_CACHED_SYMBOL_INFO = @as(u32, 17);
pub const DEBUG_REQUEST_GET_TEXT_COMPLETIONS_ANSI = @as(u32, 18);
pub const DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE = @as(u32, 19);
pub const DEBUG_REQUEST_GET_OFFSET_UNWIND_INFORMATION = @as(u32, 20);
pub const DEBUG_REQUEST_GET_DUMP_HEADER = @as(u32, 21);
pub const DEBUG_REQUEST_SET_DUMP_HEADER = @as(u32, 22);
pub const DEBUG_REQUEST_MIDORI = @as(u32, 23);
pub const DEBUG_REQUEST_PROCESS_DESCRIPTORS = @as(u32, 24);
pub const DEBUG_REQUEST_MISC_INFORMATION = @as(u32, 25);
pub const DEBUG_REQUEST_OPEN_PROCESS_TOKEN = @as(u32, 26);
pub const DEBUG_REQUEST_OPEN_THREAD_TOKEN = @as(u32, 27);
pub const DEBUG_REQUEST_DUPLICATE_TOKEN = @as(u32, 28);
pub const DEBUG_REQUEST_QUERY_INFO_TOKEN = @as(u32, 29);
pub const DEBUG_REQUEST_CLOSE_TOKEN = @as(u32, 30);
pub const DEBUG_REQUEST_WOW_PROCESS = @as(u32, 31);
pub const DEBUG_REQUEST_WOW_MODULE = @as(u32, 32);
pub const DEBUG_LIVE_USER_NON_INVASIVE = @as(u32, 33);
pub const DEBUG_REQUEST_RESUME_THREAD = @as(u32, 34);
pub const DEBUG_REQUEST_INLINE_QUERY = @as(u32, 35);
pub const DEBUG_REQUEST_TL_INSTRUMENTATION_AWARE = @as(u32, 36);
pub const DEBUG_REQUEST_GET_INSTRUMENTATION_VERSION = @as(u32, 37);
pub const DEBUG_REQUEST_GET_MODULE_ARCHITECTURE = @as(u32, 38);
pub const DEBUG_SRCFILE_SYMBOL_TOKEN = @as(u32, 0);
pub const DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE = @as(u32, 1);
pub const DEBUG_SRCFILE_SYMBOL_CHECKSUMINFO = @as(u32, 2);
pub const DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE = @as(u32, 0);
pub const DEBUG_SYMINFO_IMAGEHLP_MODULEW64 = @as(u32, 1);
pub const DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE = @as(u32, 2);
pub const DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS = @as(u32, 3);
pub const DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION = @as(u32, 0);
pub const DEBUG_SYSOBJINFO_THREAD_NAME_WIDE = @as(u32, 1);
pub const DEBUG_SYSOBJINFO_CURRENT_PROCESS_COOKIE = @as(u32, 2);
pub const DEBUG_TBINFO_EXIT_STATUS = @as(u32, 1);
pub const DEBUG_TBINFO_PRIORITY_CLASS = @as(u32, 2);
pub const DEBUG_TBINFO_PRIORITY = @as(u32, 4);
pub const DEBUG_TBINFO_TIMES = @as(u32, 8);
pub const DEBUG_TBINFO_START_OFFSET = @as(u32, 16);
pub const DEBUG_TBINFO_AFFINITY = @as(u32, 32);
pub const DEBUG_TBINFO_ALL = @as(u32, 63);
pub const DEBUG_BREAKPOINT_CODE = @as(u32, 0);
pub const DEBUG_BREAKPOINT_DATA = @as(u32, 1);
pub const DEBUG_BREAKPOINT_TIME = @as(u32, 2);
pub const DEBUG_BREAKPOINT_INLINE = @as(u32, 3);
pub const DEBUG_BREAKPOINT_GO_ONLY = @as(u32, 1);
pub const DEBUG_BREAKPOINT_DEFERRED = @as(u32, 2);
pub const DEBUG_BREAKPOINT_ENABLED = @as(u32, 4);
pub const DEBUG_BREAKPOINT_ADDER_ONLY = @as(u32, 8);
pub const DEBUG_BREAKPOINT_ONE_SHOT = @as(u32, 16);
pub const DEBUG_BREAK_READ = @as(u32, 1);
pub const DEBUG_BREAK_WRITE = @as(u32, 2);
pub const DEBUG_BREAK_EXECUTE = @as(u32, 4);
pub const DEBUG_BREAK_IO = @as(u32, 8);
pub const DEBUG_ATTACH_KERNEL_CONNECTION = @as(u32, 0);
pub const DEBUG_ATTACH_LOCAL_KERNEL = @as(u32, 1);
pub const DEBUG_ATTACH_EXDI_DRIVER = @as(u32, 2);
pub const DEBUG_ATTACH_INSTALL_DRIVER = @as(u32, 4);
pub const DEBUG_GET_PROC_DEFAULT = @as(u32, 0);
pub const DEBUG_GET_PROC_FULL_MATCH = @as(u32, 1);
pub const DEBUG_GET_PROC_ONLY_MATCH = @as(u32, 2);
pub const DEBUG_GET_PROC_SERVICE_NAME = @as(u32, 4);
pub const DEBUG_PROC_DESC_DEFAULT = @as(u32, 0);
pub const DEBUG_PROC_DESC_NO_PATHS = @as(u32, 1);
pub const DEBUG_PROC_DESC_NO_SERVICES = @as(u32, 2);
pub const DEBUG_PROC_DESC_NO_MTS_PACKAGES = @as(u32, 4);
pub const DEBUG_PROC_DESC_NO_COMMAND_LINE = @as(u32, 8);
pub const DEBUG_PROC_DESC_NO_SESSION_ID = @as(u32, 16);
pub const DEBUG_PROC_DESC_NO_USER_NAME = @as(u32, 32);
pub const DEBUG_PROC_DESC_WITH_PACKAGEFAMILY = @as(u32, 64);
pub const DEBUG_ATTACH_DEFAULT = @as(u32, 0);
pub const DEBUG_ATTACH_NONINVASIVE = @as(u32, 1);
pub const DEBUG_ATTACH_EXISTING = @as(u32, 2);
pub const DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND = @as(u32, 4);
pub const DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK = @as(u32, 8);
pub const DEBUG_ATTACH_INVASIVE_RESUME_PROCESS = @as(u32, 16);
pub const DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL = @as(u32, 32);
pub const DEBUG_ECREATE_PROCESS_DEFAULT = @as(u32, 0);
pub const DEBUG_ECREATE_PROCESS_INHERIT_HANDLES = @as(u32, 1);
pub const DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS = @as(u32, 2);
pub const DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE = @as(u32, 4);
pub const DEBUG_PROCESS_DETACH_ON_EXIT = @as(u32, 1);
pub const DEBUG_PROCESS_ONLY_THIS_PROCESS = @as(u32, 2);
pub const DEBUG_CONNECT_SESSION_DEFAULT = @as(u32, 0);
pub const DEBUG_CONNECT_SESSION_NO_VERSION = @as(u32, 1);
pub const DEBUG_CONNECT_SESSION_NO_ANNOUNCE = @as(u32, 2);
pub const DEBUG_SERVERS_DEBUGGER = @as(u32, 1);
pub const DEBUG_SERVERS_PROCESS = @as(u32, 2);
pub const DEBUG_SERVERS_ALL = @as(u32, 3);
pub const DEBUG_END_PASSIVE = @as(u32, 0);
pub const DEBUG_END_ACTIVE_TERMINATE = @as(u32, 1);
pub const DEBUG_END_ACTIVE_DETACH = @as(u32, 2);
pub const DEBUG_END_REENTRANT = @as(u32, 3);
pub const DEBUG_END_DISCONNECT = @as(u32, 4);
pub const DEBUG_OUTPUT_NORMAL = @as(u32, 1);
pub const DEBUG_OUTPUT_ERROR = @as(u32, 2);
pub const DEBUG_OUTPUT_WARNING = @as(u32, 4);
pub const DEBUG_OUTPUT_VERBOSE = @as(u32, 8);
pub const DEBUG_OUTPUT_PROMPT = @as(u32, 16);
pub const DEBUG_OUTPUT_PROMPT_REGISTERS = @as(u32, 32);
pub const DEBUG_OUTPUT_EXTENSION_WARNING = @as(u32, 64);
pub const DEBUG_OUTPUT_DEBUGGEE = @as(u32, 128);
pub const DEBUG_OUTPUT_DEBUGGEE_PROMPT = @as(u32, 256);
pub const DEBUG_OUTPUT_SYMBOLS = @as(u32, 512);
pub const DEBUG_OUTPUT_STATUS = @as(u32, 1024);
pub const DEBUG_OUTPUT_XML = @as(u32, 2048);
pub const DEBUG_IOUTPUT_KD_PROTOCOL = @as(u32, 2147483648);
pub const DEBUG_IOUTPUT_REMOTING = @as(u32, 1073741824);
pub const DEBUG_IOUTPUT_BREAKPOINT = @as(u32, 536870912);
pub const DEBUG_IOUTPUT_EVENT = @as(u32, 268435456);
pub const DEBUG_IOUTPUT_ADDR_TRANSLATE = @as(u32, 134217728);
pub const DEBUG_OUTPUT_IDENTITY_DEFAULT = @as(u32, 0);
pub const DEBUG_CLIENT_UNKNOWN = @as(u32, 0);
pub const DEBUG_CLIENT_VSINT = @as(u32, 1);
pub const DEBUG_CLIENT_NTSD = @as(u32, 2);
pub const DEBUG_CLIENT_NTKD = @as(u32, 3);
pub const DEBUG_CLIENT_CDB = @as(u32, 4);
pub const DEBUG_CLIENT_KD = @as(u32, 5);
pub const DEBUG_CLIENT_WINDBG = @as(u32, 6);
pub const DEBUG_CLIENT_WINIDE = @as(u32, 7);
pub const DEBUG_FORMAT_DEFAULT = @as(u32, 0);
pub const DEBUG_FORMAT_CAB_SECONDARY_ALL_IMAGES = @as(u32, 268435456);
pub const DEBUG_FORMAT_WRITE_CAB = @as(u32, 536870912);
pub const DEBUG_FORMAT_CAB_SECONDARY_FILES = @as(u32, 1073741824);
pub const DEBUG_FORMAT_NO_OVERWRITE = @as(u32, 2147483648);
pub const DEBUG_FORMAT_USER_SMALL_FULL_MEMORY = @as(u32, 1);
pub const DEBUG_FORMAT_USER_SMALL_HANDLE_DATA = @as(u32, 2);
pub const DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES = @as(u32, 4);
pub const DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY = @as(u32, 8);
pub const DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS = @as(u32, 16);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY = @as(u32, 32);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_PATHS = @as(u32, 64);
pub const DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA = @as(u32, 128);
pub const DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY = @as(u32, 256);
pub const DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA = @as(u32, 512);
pub const DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO = @as(u32, 1024);
pub const DEBUG_FORMAT_USER_SMALL_THREAD_INFO = @as(u32, 2048);
pub const DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS = @as(u32, 4096);
pub const DEBUG_FORMAT_USER_SMALL_NO_AUXILIARY_STATE = @as(u32, 8192);
pub const DEBUG_FORMAT_USER_SMALL_FULL_AUXILIARY_STATE = @as(u32, 16384);
pub const DEBUG_FORMAT_USER_SMALL_MODULE_HEADERS = @as(u32, 32768);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_TRIAGE = @as(u32, 65536);
pub const DEBUG_FORMAT_USER_SMALL_ADD_AVX_XSTATE_CONTEXT = @as(u32, 131072);
pub const DEBUG_FORMAT_USER_SMALL_IPT_TRACE = @as(u32, 262144);
pub const DEBUG_FORMAT_USER_SMALL_IGNORE_INACCESSIBLE_MEM = @as(u32, 134217728);
pub const DEBUG_FORMAT_USER_SMALL_SCAN_PARTIAL_PAGES = @as(u32, 268435456);
pub const DEBUG_DUMP_FILE_BASE = @as(u32, 4294967295);
pub const DEBUG_DUMP_FILE_PAGE_FILE_DUMP = @as(u32, 0);
pub const DEBUG_DUMP_FILE_LOAD_FAILED_INDEX = @as(u32, 4294967295);
pub const DEBUG_DUMP_FILE_ORIGINAL_CAB_INDEX = @as(u32, 4294967294);
pub const DEBUG_STATUS_NO_CHANGE = @as(u32, 0);
pub const DEBUG_STATUS_GO = @as(u32, 1);
pub const DEBUG_STATUS_GO_HANDLED = @as(u32, 2);
pub const DEBUG_STATUS_GO_NOT_HANDLED = @as(u32, 3);
pub const DEBUG_STATUS_STEP_OVER = @as(u32, 4);
pub const DEBUG_STATUS_STEP_INTO = @as(u32, 5);
pub const DEBUG_STATUS_BREAK = @as(u32, 6);
pub const DEBUG_STATUS_NO_DEBUGGEE = @as(u32, 7);
pub const DEBUG_STATUS_STEP_BRANCH = @as(u32, 8);
pub const DEBUG_STATUS_IGNORE_EVENT = @as(u32, 9);
pub const DEBUG_STATUS_RESTART_REQUESTED = @as(u32, 10);
pub const DEBUG_STATUS_REVERSE_GO = @as(u32, 11);
pub const DEBUG_STATUS_REVERSE_STEP_BRANCH = @as(u32, 12);
pub const DEBUG_STATUS_REVERSE_STEP_OVER = @as(u32, 13);
pub const DEBUG_STATUS_REVERSE_STEP_INTO = @as(u32, 14);
pub const DEBUG_STATUS_OUT_OF_SYNC = @as(u32, 15);
pub const DEBUG_STATUS_WAIT_INPUT = @as(u32, 16);
pub const DEBUG_STATUS_TIMEOUT = @as(u32, 17);
pub const DEBUG_STATUS_MASK = @as(u32, 31);
pub const DEBUG_STATUS_INSIDE_WAIT = @as(u64, 4294967296);
pub const DEBUG_STATUS_WAIT_TIMEOUT = @as(u64, 8589934592);
pub const DEBUG_OUTCTL_THIS_CLIENT = @as(u32, 0);
pub const DEBUG_OUTCTL_ALL_CLIENTS = @as(u32, 1);
pub const DEBUG_OUTCTL_ALL_OTHER_CLIENTS = @as(u32, 2);
pub const DEBUG_OUTCTL_IGNORE = @as(u32, 3);
pub const DEBUG_OUTCTL_LOG_ONLY = @as(u32, 4);
pub const DEBUG_OUTCTL_SEND_MASK = @as(u32, 7);
pub const DEBUG_OUTCTL_NOT_LOGGED = @as(u32, 8);
pub const DEBUG_OUTCTL_OVERRIDE_MASK = @as(u32, 16);
pub const DEBUG_OUTCTL_DML = @as(u32, 32);
pub const DEBUG_OUTCTL_AMBIENT_DML = @as(u32, 4294967294);
pub const DEBUG_OUTCTL_AMBIENT_TEXT = @as(u32, 4294967295);
pub const DEBUG_OUTCTL_AMBIENT = @as(u32, 4294967295);
pub const DEBUG_INTERRUPT_ACTIVE = @as(u32, 0);
pub const DEBUG_INTERRUPT_PASSIVE = @as(u32, 1);
pub const DEBUG_INTERRUPT_EXIT = @as(u32, 2);
pub const DEBUG_CURRENT_DEFAULT = @as(u32, 15);
pub const DEBUG_CURRENT_SYMBOL = @as(u32, 1);
pub const DEBUG_CURRENT_DISASM = @as(u32, 2);
pub const DEBUG_CURRENT_REGISTERS = @as(u32, 4);
pub const DEBUG_CURRENT_SOURCE_LINE = @as(u32, 8);
pub const DEBUG_DISASM_EFFECTIVE_ADDRESS = @as(u32, 1);
pub const DEBUG_DISASM_MATCHING_SYMBOLS = @as(u32, 2);
pub const DEBUG_DISASM_SOURCE_LINE_NUMBER = @as(u32, 4);
pub const DEBUG_DISASM_SOURCE_FILE_NAME = @as(u32, 8);
pub const DEBUG_LEVEL_SOURCE = @as(u32, 0);
pub const DEBUG_LEVEL_ASSEMBLY = @as(u32, 1);
pub const DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION = @as(u32, 1);
pub const DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS = @as(u32, 2);
pub const DEBUG_ENGOPT_ALLOW_NETWORK_PATHS = @as(u32, 4);
pub const DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 8);
pub const DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS = @as(u32, 16);
pub const DEBUG_ENGOPT_INITIAL_BREAK = @as(u32, 32);
pub const DEBUG_ENGOPT_INITIAL_MODULE_BREAK = @as(u32, 64);
pub const DEBUG_ENGOPT_FINAL_BREAK = @as(u32, 128);
pub const DEBUG_ENGOPT_NO_EXECUTE_REPEAT = @as(u32, 256);
pub const DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION = @as(u32, 512);
pub const DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS = @as(u32, 1024);
pub const DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS = @as(u32, 2048);
pub const DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS = @as(u32, 4096);
pub const DEBUG_ENGOPT_KD_QUIET_MODE = @as(u32, 8192);
pub const DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT = @as(u32, 16384);
pub const DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD = @as(u32, 32768);
pub const DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS = @as(u32, 65536);
pub const DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING = @as(u32, 131072);
pub const DEBUG_ENGOPT_PREFER_DML = @as(u32, 262144);
pub const DEBUG_ENGOPT_DISABLESQM = @as(u32, 524288);
pub const DEBUG_ENGOPT_DISABLE_STEPLINES_OPTIONS = @as(u32, 2097152);
pub const DEBUG_ENGOPT_DEBUGGING_SENSITIVE_DATA = @as(u32, 4194304);
pub const DEBUG_ENGOPT_PREFER_TRACE_FILES = @as(u32, 8388608);
pub const DEBUG_ENGOPT_ALL = @as(u32, 15728639);
pub const DEBUG_ANY_ID = @as(u32, 4294967295);
pub const DBG_FRAME_DEFAULT = @as(u32, 0);
pub const DBG_FRAME_IGNORE_INLINE = @as(u32, 4294967295);
pub const STACK_FRAME_TYPE_INIT = @as(u32, 0);
pub const STACK_FRAME_TYPE_STACK = @as(u32, 1);
pub const STACK_FRAME_TYPE_INLINE = @as(u32, 2);
pub const STACK_FRAME_TYPE_RA = @as(u32, 128);
pub const STACK_FRAME_TYPE_IGNORE = @as(u32, 255);
pub const DEBUG_STACK_ARGUMENTS = @as(u32, 1);
pub const DEBUG_STACK_FUNCTION_INFO = @as(u32, 2);
pub const DEBUG_STACK_SOURCE_LINE = @as(u32, 4);
pub const DEBUG_STACK_FRAME_ADDRESSES = @as(u32, 8);
pub const DEBUG_STACK_COLUMN_NAMES = @as(u32, 16);
pub const DEBUG_STACK_NONVOLATILE_REGISTERS = @as(u32, 32);
pub const DEBUG_STACK_FRAME_NUMBERS = @as(u32, 64);
pub const DEBUG_STACK_PARAMETERS = @as(u32, 128);
pub const DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY = @as(u32, 256);
pub const DEBUG_STACK_FRAME_MEMORY_USAGE = @as(u32, 512);
pub const DEBUG_STACK_PARAMETERS_NEWLINE = @as(u32, 1024);
pub const DEBUG_STACK_DML = @as(u32, 2048);
pub const DEBUG_STACK_FRAME_OFFSETS = @as(u32, 4096);
pub const DEBUG_STACK_PROVIDER = @as(u32, 8192);
pub const DEBUG_STACK_FRAME_ARCH = @as(u32, 16384);
pub const DEBUG_CLASS_UNINITIALIZED = @as(u32, 0);
pub const DEBUG_CLASS_KERNEL = @as(u32, 1);
pub const DEBUG_CLASS_USER_WINDOWS = @as(u32, 2);
pub const DEBUG_CLASS_IMAGE_FILE = @as(u32, 3);
pub const DEBUG_DUMP_SMALL = @as(u32, 1024);
pub const DEBUG_DUMP_DEFAULT = @as(u32, 1025);
pub const DEBUG_DUMP_FULL = @as(u32, 1026);
pub const DEBUG_DUMP_IMAGE_FILE = @as(u32, 1027);
pub const DEBUG_DUMP_TRACE_LOG = @as(u32, 1028);
pub const DEBUG_DUMP_WINDOWS_CE = @as(u32, 1029);
pub const DEBUG_DUMP_ACTIVE = @as(u32, 1030);
pub const DEBUG_KERNEL_CONNECTION = @as(u32, 0);
pub const DEBUG_KERNEL_LOCAL = @as(u32, 1);
pub const DEBUG_KERNEL_EXDI_DRIVER = @as(u32, 2);
pub const DEBUG_KERNEL_IDNA = @as(u32, 3);
pub const DEBUG_KERNEL_INSTALL_DRIVER = @as(u32, 4);
pub const DEBUG_KERNEL_REPT = @as(u32, 5);
pub const DEBUG_KERNEL_SMALL_DUMP = @as(u32, 1024);
pub const DEBUG_KERNEL_DUMP = @as(u32, 1025);
pub const DEBUG_KERNEL_ACTIVE_DUMP = @as(u32, 1030);
pub const DEBUG_KERNEL_FULL_DUMP = @as(u32, 1026);
pub const DEBUG_KERNEL_TRACE_LOG = @as(u32, 1028);
pub const DEBUG_USER_WINDOWS_PROCESS = @as(u32, 0);
pub const DEBUG_USER_WINDOWS_PROCESS_SERVER = @as(u32, 1);
pub const DEBUG_USER_WINDOWS_IDNA = @as(u32, 2);
pub const DEBUG_USER_WINDOWS_REPT = @as(u32, 3);
pub const DEBUG_USER_WINDOWS_SMALL_DUMP = @as(u32, 1024);
pub const DEBUG_USER_WINDOWS_DUMP = @as(u32, 1025);
pub const DEBUG_USER_WINDOWS_DUMP_WINDOWS_CE = @as(u32, 1029);
pub const DEBUG_EXTENSION_AT_ENGINE = @as(u32, 0);
pub const DEBUG_EXECUTE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXECUTE_ECHO = @as(u32, 1);
pub const DEBUG_EXECUTE_NOT_LOGGED = @as(u32, 2);
pub const DEBUG_EXECUTE_NO_REPEAT = @as(u32, 4);
pub const DEBUG_EXECUTE_USER_TYPED = @as(u32, 8);
pub const DEBUG_EXECUTE_USER_CLICKED = @as(u32, 16);
pub const DEBUG_EXECUTE_EXTENSION = @as(u32, 32);
pub const DEBUG_EXECUTE_INTERNAL = @as(u32, 64);
pub const DEBUG_EXECUTE_SCRIPT = @as(u32, 128);
pub const DEBUG_EXECUTE_TOOLBAR = @as(u32, 256);
pub const DEBUG_EXECUTE_MENU = @as(u32, 512);
pub const DEBUG_EXECUTE_HOTKEY = @as(u32, 1024);
pub const DEBUG_EXECUTE_EVENT = @as(u32, 2048);
pub const DEBUG_FILTER_CREATE_THREAD = @as(u32, 0);
pub const DEBUG_FILTER_EXIT_THREAD = @as(u32, 1);
pub const DEBUG_FILTER_CREATE_PROCESS = @as(u32, 2);
pub const DEBUG_FILTER_EXIT_PROCESS = @as(u32, 3);
pub const DEBUG_FILTER_LOAD_MODULE = @as(u32, 4);
pub const DEBUG_FILTER_UNLOAD_MODULE = @as(u32, 5);
pub const DEBUG_FILTER_SYSTEM_ERROR = @as(u32, 6);
pub const DEBUG_FILTER_INITIAL_BREAKPOINT = @as(u32, 7);
pub const DEBUG_FILTER_INITIAL_MODULE_LOAD = @as(u32, 8);
pub const DEBUG_FILTER_DEBUGGEE_OUTPUT = @as(u32, 9);
pub const DEBUG_FILTER_BREAK = @as(u32, 0);
pub const DEBUG_FILTER_SECOND_CHANCE_BREAK = @as(u32, 1);
pub const DEBUG_FILTER_OUTPUT = @as(u32, 2);
pub const DEBUG_FILTER_IGNORE = @as(u32, 3);
pub const DEBUG_FILTER_REMOVE = @as(u32, 4);
pub const DEBUG_FILTER_GO_HANDLED = @as(u32, 0);
pub const DEBUG_FILTER_GO_NOT_HANDLED = @as(u32, 1);
pub const DEBUG_WAIT_DEFAULT = @as(u32, 0);
pub const DEBUG_VALUE_INVALID = @as(u32, 0);
pub const DEBUG_VALUE_INT8 = @as(u32, 1);
pub const DEBUG_VALUE_INT16 = @as(u32, 2);
pub const DEBUG_VALUE_INT32 = @as(u32, 3);
pub const DEBUG_VALUE_INT64 = @as(u32, 4);
pub const DEBUG_VALUE_FLOAT32 = @as(u32, 5);
pub const DEBUG_VALUE_FLOAT64 = @as(u32, 6);
pub const DEBUG_VALUE_FLOAT80 = @as(u32, 7);
pub const DEBUG_VALUE_FLOAT82 = @as(u32, 8);
pub const DEBUG_VALUE_FLOAT128 = @as(u32, 9);
pub const DEBUG_VALUE_VECTOR64 = @as(u32, 10);
pub const DEBUG_VALUE_VECTOR128 = @as(u32, 11);
pub const DEBUG_VALUE_TYPES = @as(u32, 12);
pub const DEBUG_OUT_TEXT_REPL_DEFAULT = @as(u32, 0);
pub const DEBUG_ASMOPT_DEFAULT = @as(u32, 0);
pub const DEBUG_ASMOPT_VERBOSE = @as(u32, 1);
pub const DEBUG_ASMOPT_NO_CODE_BYTES = @as(u32, 2);
pub const DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH = @as(u32, 4);
pub const DEBUG_ASMOPT_SOURCE_LINE_NUMBER = @as(u32, 8);
pub const DEBUG_EXPR_MASM = @as(u32, 0);
pub const DEBUG_EXPR_CPLUSPLUS = @as(u32, 1);
pub const DEBUG_EINDEX_NAME = @as(u32, 0);
pub const DEBUG_EINDEX_FROM_START = @as(u32, 0);
pub const DEBUG_EINDEX_FROM_END = @as(u32, 1);
pub const DEBUG_EINDEX_FROM_CURRENT = @as(u32, 2);
pub const DEBUG_LOG_DEFAULT = @as(u32, 0);
pub const DEBUG_LOG_APPEND = @as(u32, 1);
pub const DEBUG_LOG_UNICODE = @as(u32, 2);
pub const DEBUG_LOG_DML = @as(u32, 4);
pub const DEBUG_SYSVERSTR_SERVICE_PACK = @as(u32, 0);
pub const DEBUG_SYSVERSTR_BUILD = @as(u32, 1);
pub const DEBUG_MANAGED_DISABLED = @as(u32, 0);
pub const DEBUG_MANAGED_ALLOWED = @as(u32, 1);
pub const DEBUG_MANAGED_DLL_LOADED = @as(u32, 2);
pub const DEBUG_MANSTR_NONE = @as(u32, 0);
pub const DEBUG_MANSTR_LOADED_SUPPORT_DLL = @as(u32, 1);
pub const DEBUG_MANSTR_LOAD_STATUS = @as(u32, 2);
pub const DEBUG_MANRESET_DEFAULT = @as(u32, 0);
pub const DEBUG_MANRESET_LOAD_DLL = @as(u32, 1);
pub const DEBUG_EXEC_FLAGS_NONBLOCK = @as(u32, 1);
pub const DEBUG_DATA_SPACE_VIRTUAL = @as(u32, 0);
pub const DEBUG_DATA_SPACE_PHYSICAL = @as(u32, 1);
pub const DEBUG_DATA_SPACE_CONTROL = @as(u32, 2);
pub const DEBUG_DATA_SPACE_IO = @as(u32, 3);
pub const DEBUG_DATA_SPACE_MSR = @as(u32, 4);
pub const DEBUG_DATA_SPACE_BUS_DATA = @as(u32, 5);
pub const DEBUG_DATA_SPACE_DEBUGGER_DATA = @as(u32, 6);
pub const DEBUG_DATA_SPACE_COUNT = @as(u32, 7);
pub const DEBUG_DATA_KernBase = @as(u32, 24);
pub const DEBUG_DATA_BreakpointWithStatusAddr = @as(u32, 32);
pub const DEBUG_DATA_SavedContextAddr = @as(u32, 40);
pub const DEBUG_DATA_KiCallUserModeAddr = @as(u32, 56);
pub const DEBUG_DATA_KeUserCallbackDispatcherAddr = @as(u32, 64);
pub const DEBUG_DATA_PsLoadedModuleListAddr = @as(u32, 72);
pub const DEBUG_DATA_PsActiveProcessHeadAddr = @as(u32, 80);
pub const DEBUG_DATA_PspCidTableAddr = @as(u32, 88);
pub const DEBUG_DATA_ExpSystemResourcesListAddr = @as(u32, 96);
pub const DEBUG_DATA_ExpPagedPoolDescriptorAddr = @as(u32, 104);
pub const DEBUG_DATA_ExpNumberOfPagedPoolsAddr = @as(u32, 112);
pub const DEBUG_DATA_KeTimeIncrementAddr = @as(u32, 120);
pub const DEBUG_DATA_KeBugCheckCallbackListHeadAddr = @as(u32, 128);
pub const DEBUG_DATA_KiBugcheckDataAddr = @as(u32, 136);
pub const DEBUG_DATA_IopErrorLogListHeadAddr = @as(u32, 144);
pub const DEBUG_DATA_ObpRootDirectoryObjectAddr = @as(u32, 152);
pub const DEBUG_DATA_ObpTypeObjectTypeAddr = @as(u32, 160);
pub const DEBUG_DATA_MmSystemCacheStartAddr = @as(u32, 168);
pub const DEBUG_DATA_MmSystemCacheEndAddr = @as(u32, 176);
pub const DEBUG_DATA_MmSystemCacheWsAddr = @as(u32, 184);
pub const DEBUG_DATA_MmPfnDatabaseAddr = @as(u32, 192);
pub const DEBUG_DATA_MmSystemPtesStartAddr = @as(u32, 200);
pub const DEBUG_DATA_MmSystemPtesEndAddr = @as(u32, 208);
pub const DEBUG_DATA_MmSubsectionBaseAddr = @as(u32, 216);
pub const DEBUG_DATA_MmNumberOfPagingFilesAddr = @as(u32, 224);
pub const DEBUG_DATA_MmLowestPhysicalPageAddr = @as(u32, 232);
pub const DEBUG_DATA_MmHighestPhysicalPageAddr = @as(u32, 240);
pub const DEBUG_DATA_MmNumberOfPhysicalPagesAddr = @as(u32, 248);
pub const DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr = @as(u32, 256);
pub const DEBUG_DATA_MmNonPagedSystemStartAddr = @as(u32, 264);
pub const DEBUG_DATA_MmNonPagedPoolStartAddr = @as(u32, 272);
pub const DEBUG_DATA_MmNonPagedPoolEndAddr = @as(u32, 280);
pub const DEBUG_DATA_MmPagedPoolStartAddr = @as(u32, 288);
pub const DEBUG_DATA_MmPagedPoolEndAddr = @as(u32, 296);
pub const DEBUG_DATA_MmPagedPoolInformationAddr = @as(u32, 304);
pub const DEBUG_DATA_MmPageSize = @as(u32, 312);
pub const DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr = @as(u32, 320);
pub const DEBUG_DATA_MmTotalCommitLimitAddr = @as(u32, 328);
pub const DEBUG_DATA_MmTotalCommittedPagesAddr = @as(u32, 336);
pub const DEBUG_DATA_MmSharedCommitAddr = @as(u32, 344);
pub const DEBUG_DATA_MmDriverCommitAddr = @as(u32, 352);
pub const DEBUG_DATA_MmProcessCommitAddr = @as(u32, 360);
pub const DEBUG_DATA_MmPagedPoolCommitAddr = @as(u32, 368);
pub const DEBUG_DATA_MmExtendedCommitAddr = @as(u32, 376);
pub const DEBUG_DATA_MmZeroedPageListHeadAddr = @as(u32, 384);
pub const DEBUG_DATA_MmFreePageListHeadAddr = @as(u32, 392);
pub const DEBUG_DATA_MmStandbyPageListHeadAddr = @as(u32, 400);
pub const DEBUG_DATA_MmModifiedPageListHeadAddr = @as(u32, 408);
pub const DEBUG_DATA_MmModifiedNoWritePageListHeadAddr = @as(u32, 416);
pub const DEBUG_DATA_MmAvailablePagesAddr = @as(u32, 424);
pub const DEBUG_DATA_MmResidentAvailablePagesAddr = @as(u32, 432);
pub const DEBUG_DATA_PoolTrackTableAddr = @as(u32, 440);
pub const DEBUG_DATA_NonPagedPoolDescriptorAddr = @as(u32, 448);
pub const DEBUG_DATA_MmHighestUserAddressAddr = @as(u32, 456);
pub const DEBUG_DATA_MmSystemRangeStartAddr = @as(u32, 464);
pub const DEBUG_DATA_MmUserProbeAddressAddr = @as(u32, 472);
pub const DEBUG_DATA_KdPrintCircularBufferAddr = @as(u32, 480);
pub const DEBUG_DATA_KdPrintCircularBufferEndAddr = @as(u32, 488);
pub const DEBUG_DATA_KdPrintWritePointerAddr = @as(u32, 496);
pub const DEBUG_DATA_KdPrintRolloverCountAddr = @as(u32, 504);
pub const DEBUG_DATA_MmLoadedUserImageListAddr = @as(u32, 512);
pub const DEBUG_DATA_NtBuildLabAddr = @as(u32, 520);
pub const DEBUG_DATA_KiNormalSystemCall = @as(u32, 528);
pub const DEBUG_DATA_KiProcessorBlockAddr = @as(u32, 536);
pub const DEBUG_DATA_MmUnloadedDriversAddr = @as(u32, 544);
pub const DEBUG_DATA_MmLastUnloadedDriverAddr = @as(u32, 552);
pub const DEBUG_DATA_MmTriageActionTakenAddr = @as(u32, 560);
pub const DEBUG_DATA_MmSpecialPoolTagAddr = @as(u32, 568);
pub const DEBUG_DATA_KernelVerifierAddr = @as(u32, 576);
pub const DEBUG_DATA_MmVerifierDataAddr = @as(u32, 584);
pub const DEBUG_DATA_MmAllocatedNonPagedPoolAddr = @as(u32, 592);
pub const DEBUG_DATA_MmPeakCommitmentAddr = @as(u32, 600);
pub const DEBUG_DATA_MmTotalCommitLimitMaximumAddr = @as(u32, 608);
pub const DEBUG_DATA_CmNtCSDVersionAddr = @as(u32, 616);
pub const DEBUG_DATA_MmPhysicalMemoryBlockAddr = @as(u32, 624);
pub const DEBUG_DATA_MmSessionBase = @as(u32, 632);
pub const DEBUG_DATA_MmSessionSize = @as(u32, 640);
pub const DEBUG_DATA_MmSystemParentTablePage = @as(u32, 648);
pub const DEBUG_DATA_MmVirtualTranslationBase = @as(u32, 656);
pub const DEBUG_DATA_OffsetKThreadNextProcessor = @as(u32, 664);
pub const DEBUG_DATA_OffsetKThreadTeb = @as(u32, 666);
pub const DEBUG_DATA_OffsetKThreadKernelStack = @as(u32, 668);
pub const DEBUG_DATA_OffsetKThreadInitialStack = @as(u32, 670);
pub const DEBUG_DATA_OffsetKThreadApcProcess = @as(u32, 672);
pub const DEBUG_DATA_OffsetKThreadState = @as(u32, 674);
pub const DEBUG_DATA_OffsetKThreadBStore = @as(u32, 676);
pub const DEBUG_DATA_OffsetKThreadBStoreLimit = @as(u32, 678);
pub const DEBUG_DATA_SizeEProcess = @as(u32, 680);
pub const DEBUG_DATA_OffsetEprocessPeb = @as(u32, 682);
pub const DEBUG_DATA_OffsetEprocessParentCID = @as(u32, 684);
pub const DEBUG_DATA_OffsetEprocessDirectoryTableBase = @as(u32, 686);
pub const DEBUG_DATA_SizePrcb = @as(u32, 688);
pub const DEBUG_DATA_OffsetPrcbDpcRoutine = @as(u32, 690);
pub const DEBUG_DATA_OffsetPrcbCurrentThread = @as(u32, 692);
pub const DEBUG_DATA_OffsetPrcbMhz = @as(u32, 694);
pub const DEBUG_DATA_OffsetPrcbCpuType = @as(u32, 696);
pub const DEBUG_DATA_OffsetPrcbVendorString = @as(u32, 698);
pub const DEBUG_DATA_OffsetPrcbProcessorState = @as(u32, 700);
pub const DEBUG_DATA_OffsetPrcbNumber = @as(u32, 702);
pub const DEBUG_DATA_SizeEThread = @as(u32, 704);
pub const DEBUG_DATA_KdPrintCircularBufferPtrAddr = @as(u32, 712);
pub const DEBUG_DATA_KdPrintBufferSizeAddr = @as(u32, 720);
pub const DEBUG_DATA_MmBadPagesDetected = @as(u32, 800);
pub const DEBUG_DATA_EtwpDebuggerData = @as(u32, 816);
pub const DEBUG_DATA_PteBase = @as(u32, 864);
pub const DEBUG_DATA_PaeEnabled = @as(u32, 100000);
pub const DEBUG_DATA_SharedUserData = @as(u32, 100008);
pub const DEBUG_DATA_ProductType = @as(u32, 100016);
pub const DEBUG_DATA_SuiteMask = @as(u32, 100024);
pub const DEBUG_DATA_DumpWriterStatus = @as(u32, 100032);
pub const DEBUG_DATA_DumpFormatVersion = @as(u32, 100040);
pub const DEBUG_DATA_DumpWriterVersion = @as(u32, 100048);
pub const DEBUG_DATA_DumpPowerState = @as(u32, 100056);
pub const DEBUG_DATA_DumpMmStorage = @as(u32, 100064);
pub const DEBUG_DATA_DumpAttributes = @as(u32, 100072);
pub const DEBUG_DATA_KPCR_OFFSET = @as(u32, 0);
pub const DEBUG_DATA_KPRCB_OFFSET = @as(u32, 1);
pub const DEBUG_DATA_KTHREAD_OFFSET = @as(u32, 2);
pub const DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET = @as(u32, 3);
pub const DEBUG_DATA_PROCESSOR_IDENTIFICATION = @as(u32, 4);
pub const DEBUG_DATA_PROCESSOR_SPEED = @as(u32, 5);
pub const DEBUG_HANDLE_DATA_TYPE_BASIC = @as(u32, 0);
pub const DEBUG_HANDLE_DATA_TYPE_TYPE_NAME = @as(u32, 1);
pub const DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME = @as(u32, 2);
pub const DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT = @as(u32, 3);
pub const DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE = @as(u32, 4);
pub const DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE = @as(u32, 5);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_THREAD_1 = @as(u32, 6);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_1 = @as(u32, 7);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_2 = @as(u32, 8);
pub const DEBUG_HANDLE_DATA_TYPE_PER_HANDLE_OPERATIONS = @as(u32, 9);
pub const DEBUG_HANDLE_DATA_TYPE_ALL_HANDLE_OPERATIONS = @as(u32, 10);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_1 = @as(u32, 11);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_2 = @as(u32, 12);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_EVENT_1 = @as(u32, 13);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_SECTION_1 = @as(u32, 14);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_SEMAPHORE_1 = @as(u32, 15);
pub const DEBUG_OFFSINFO_VIRTUAL_SOURCE = @as(u32, 1);
pub const DEBUG_VSOURCE_INVALID = @as(u32, 0);
pub const DEBUG_VSOURCE_DEBUGGEE = @as(u32, 1);
pub const DEBUG_VSOURCE_MAPPED_IMAGE = @as(u32, 2);
pub const DEBUG_VSOURCE_DUMP_WITHOUT_MEMINFO = @as(u32, 3);
pub const DEBUG_VSEARCH_DEFAULT = @as(u32, 0);
pub const DEBUG_VSEARCH_WRITABLE_ONLY = @as(u32, 1);
pub const DEBUG_PHYSICAL_DEFAULT = @as(u32, 0);
pub const DEBUG_PHYSICAL_CACHED = @as(u32, 1);
pub const DEBUG_PHYSICAL_UNCACHED = @as(u32, 2);
pub const DEBUG_PHYSICAL_WRITE_COMBINED = @as(u32, 3);
pub const DEBUG_EVENT_BREAKPOINT = @as(u32, 1);
pub const DEBUG_EVENT_EXCEPTION = @as(u32, 2);
pub const DEBUG_EVENT_CREATE_THREAD = @as(u32, 4);
pub const DEBUG_EVENT_EXIT_THREAD = @as(u32, 8);
pub const DEBUG_EVENT_CREATE_PROCESS = @as(u32, 16);
pub const DEBUG_EVENT_EXIT_PROCESS = @as(u32, 32);
pub const DEBUG_EVENT_LOAD_MODULE = @as(u32, 64);
pub const DEBUG_EVENT_UNLOAD_MODULE = @as(u32, 128);
pub const DEBUG_EVENT_SYSTEM_ERROR = @as(u32, 256);
pub const DEBUG_EVENT_SESSION_STATUS = @as(u32, 512);
pub const DEBUG_EVENT_CHANGE_DEBUGGEE_STATE = @as(u32, 1024);
pub const DEBUG_EVENT_CHANGE_ENGINE_STATE = @as(u32, 2048);
pub const DEBUG_EVENT_CHANGE_SYMBOL_STATE = @as(u32, 4096);
pub const DEBUG_EVENT_SERVICE_EXCEPTION = @as(u32, 8192);
pub const DEBUG_SESSION_ACTIVE = @as(u32, 0);
pub const DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE = @as(u32, 1);
pub const DEBUG_SESSION_END_SESSION_ACTIVE_DETACH = @as(u32, 2);
pub const DEBUG_SESSION_END_SESSION_PASSIVE = @as(u32, 3);
pub const DEBUG_SESSION_END = @as(u32, 4);
pub const DEBUG_SESSION_REBOOT = @as(u32, 5);
pub const DEBUG_SESSION_HIBERNATE = @as(u32, 6);
pub const DEBUG_SESSION_FAILURE = @as(u32, 7);
pub const DEBUG_CDS_ALL = @as(u32, 4294967295);
pub const DEBUG_CDS_REGISTERS = @as(u32, 1);
pub const DEBUG_CDS_DATA = @as(u32, 2);
pub const DEBUG_CDS_REFRESH = @as(u32, 4);
pub const DEBUG_CDS_REFRESH_EVALUATE = @as(u32, 1);
pub const DEBUG_CDS_REFRESH_EXECUTE = @as(u32, 2);
pub const DEBUG_CDS_REFRESH_EXECUTECOMMANDFILE = @as(u32, 3);
pub const DEBUG_CDS_REFRESH_ADDBREAKPOINT = @as(u32, 4);
pub const DEBUG_CDS_REFRESH_REMOVEBREAKPOINT = @as(u32, 5);
pub const DEBUG_CDS_REFRESH_WRITEVIRTUAL = @as(u32, 6);
pub const DEBUG_CDS_REFRESH_WRITEVIRTUALUNCACHED = @as(u32, 7);
pub const DEBUG_CDS_REFRESH_WRITEPHYSICAL = @as(u32, 8);
pub const DEBUG_CDS_REFRESH_WRITEPHYSICAL2 = @as(u32, 9);
pub const DEBUG_CDS_REFRESH_SETVALUE = @as(u32, 10);
pub const DEBUG_CDS_REFRESH_SETVALUE2 = @as(u32, 11);
pub const DEBUG_CDS_REFRESH_SETSCOPE = @as(u32, 12);
pub const DEBUG_CDS_REFRESH_SETSCOPEFRAMEBYINDEX = @as(u32, 13);
pub const DEBUG_CDS_REFRESH_SETSCOPEFROMJITDEBUGINFO = @as(u32, 14);
pub const DEBUG_CDS_REFRESH_SETSCOPEFROMSTOREDEVENT = @as(u32, 15);
pub const DEBUG_CDS_REFRESH_INLINESTEP = @as(u32, 16);
pub const DEBUG_CDS_REFRESH_INLINESTEP_PSEUDO = @as(u32, 17);
pub const DEBUG_CES_ALL = @as(u32, 4294967295);
pub const DEBUG_CES_CURRENT_THREAD = @as(u32, 1);
pub const DEBUG_CES_EFFECTIVE_PROCESSOR = @as(u32, 2);
pub const DEBUG_CES_BREAKPOINTS = @as(u32, 4);
pub const DEBUG_CES_CODE_LEVEL = @as(u32, 8);
pub const DEBUG_CES_EXECUTION_STATUS = @as(u32, 16);
pub const DEBUG_CES_ENGINE_OPTIONS = @as(u32, 32);
pub const DEBUG_CES_LOG_FILE = @as(u32, 64);
pub const DEBUG_CES_RADIX = @as(u32, 128);
pub const DEBUG_CES_EVENT_FILTERS = @as(u32, 256);
pub const DEBUG_CES_PROCESS_OPTIONS = @as(u32, 512);
pub const DEBUG_CES_EXTENSIONS = @as(u32, 1024);
pub const DEBUG_CES_SYSTEMS = @as(u32, 2048);
pub const DEBUG_CES_ASSEMBLY_OPTIONS = @as(u32, 4096);
pub const DEBUG_CES_EXPRESSION_SYNTAX = @as(u32, 8192);
pub const DEBUG_CES_TEXT_REPLACEMENTS = @as(u32, 16384);
pub const DEBUG_CSS_ALL = @as(u32, 4294967295);
pub const DEBUG_CSS_LOADS = @as(u32, 1);
pub const DEBUG_CSS_UNLOADS = @as(u32, 2);
pub const DEBUG_CSS_SCOPE = @as(u32, 4);
pub const DEBUG_CSS_PATHS = @as(u32, 8);
pub const DEBUG_CSS_SYMBOL_OPTIONS = @as(u32, 16);
pub const DEBUG_CSS_TYPE_OPTIONS = @as(u32, 32);
pub const DEBUG_CSS_COLLAPSE_CHILDREN = @as(u32, 64);
pub const DEBUG_OUTCBI_EXPLICIT_FLUSH = @as(u32, 1);
pub const DEBUG_OUTCBI_TEXT = @as(u32, 2);
pub const DEBUG_OUTCBI_DML = @as(u32, 4);
pub const DEBUG_OUTCBI_ANY_FORMAT = @as(u32, 6);
pub const DEBUG_OUTCB_TEXT = @as(u32, 0);
pub const DEBUG_OUTCB_DML = @as(u32, 1);
pub const DEBUG_OUTCB_EXPLICIT_FLUSH = @as(u32, 2);
pub const DEBUG_OUTCBF_COMBINED_EXPLICIT_FLUSH = @as(u32, 1);
pub const DEBUG_OUTCBF_DML_HAS_TAGS = @as(u32, 2);
pub const DEBUG_OUTCBF_DML_HAS_SPECIAL_CHARACTERS = @as(u32, 4);
pub const DEBUG_REGISTERS_DEFAULT = @as(u32, 0);
pub const DEBUG_REGISTERS_INT32 = @as(u32, 1);
pub const DEBUG_REGISTERS_INT64 = @as(u32, 2);
pub const DEBUG_REGISTERS_FLOAT = @as(u32, 4);
pub const DEBUG_REGISTERS_ALL = @as(u32, 7);
pub const DEBUG_REGISTER_SUB_REGISTER = @as(u32, 1);
pub const DEBUG_REGSRC_DEBUGGEE = @as(u32, 0);
pub const DEBUG_REGSRC_EXPLICIT = @as(u32, 1);
pub const DEBUG_REGSRC_FRAME = @as(u32, 2);
pub const DEBUG_OUTPUT_SYMBOLS_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTPUT_SYMBOLS_NO_NAMES = @as(u32, 1);
pub const DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS = @as(u32, 2);
pub const DEBUG_OUTPUT_SYMBOLS_NO_VALUES = @as(u32, 4);
pub const DEBUG_OUTPUT_SYMBOLS_NO_TYPES = @as(u32, 16);
pub const DEBUG_SYMBOL_EXPANSION_LEVEL_MASK = @as(u32, 15);
pub const DEBUG_SYMBOL_EXPANDED = @as(u32, 16);
pub const DEBUG_SYMBOL_READ_ONLY = @as(u32, 32);
pub const DEBUG_SYMBOL_IS_ARRAY = @as(u32, 64);
pub const DEBUG_SYMBOL_IS_FLOAT = @as(u32, 128);
pub const DEBUG_SYMBOL_IS_ARGUMENT = @as(u32, 256);
pub const DEBUG_SYMBOL_IS_LOCAL = @as(u32, 512);
pub const DEBUG_SYMENT_IS_CODE = @as(u32, 1);
pub const DEBUG_SYMENT_IS_DATA = @as(u32, 2);
pub const DEBUG_SYMENT_IS_PARAMETER = @as(u32, 4);
pub const DEBUG_SYMENT_IS_LOCAL = @as(u32, 8);
pub const DEBUG_SYMENT_IS_MANAGED = @as(u32, 16);
pub const DEBUG_SYMENT_IS_SYNTHETIC = @as(u32, 32);
pub const DEBUG_MODULE_LOADED = @as(u32, 0);
pub const DEBUG_MODULE_UNLOADED = @as(u32, 1);
pub const DEBUG_MODULE_USER_MODE = @as(u32, 2);
pub const DEBUG_MODULE_EXE_MODULE = @as(u32, 4);
pub const DEBUG_MODULE_EXPLICIT = @as(u32, 8);
pub const DEBUG_MODULE_SECONDARY = @as(u32, 16);
pub const DEBUG_MODULE_SYNTHETIC = @as(u32, 32);
pub const DEBUG_MODULE_SYM_BAD_CHECKSUM = @as(u32, 65536);
pub const DEBUG_SYMTYPE_NONE = @as(u32, 0);
pub const DEBUG_SYMTYPE_COFF = @as(u32, 1);
pub const DEBUG_SYMTYPE_CODEVIEW = @as(u32, 2);
pub const DEBUG_SYMTYPE_PDB = @as(u32, 3);
pub const DEBUG_SYMTYPE_EXPORT = @as(u32, 4);
pub const DEBUG_SYMTYPE_DEFERRED = @as(u32, 5);
pub const DEBUG_SYMTYPE_SYM = @as(u32, 6);
pub const DEBUG_SYMTYPE_DIA = @as(u32, 7);
pub const DEBUG_SCOPE_GROUP_ARGUMENTS = @as(u32, 1);
pub const DEBUG_SCOPE_GROUP_LOCALS = @as(u32, 2);
pub const DEBUG_SCOPE_GROUP_ALL = @as(u32, 3);
pub const DEBUG_SCOPE_GROUP_BY_DATAMODEL = @as(u32, 4);
pub const DEBUG_OUTTYPE_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTTYPE_NO_INDENT = @as(u32, 1);
pub const DEBUG_OUTTYPE_NO_OFFSET = @as(u32, 2);
pub const DEBUG_OUTTYPE_VERBOSE = @as(u32, 4);
pub const DEBUG_OUTTYPE_COMPACT_OUTPUT = @as(u32, 8);
pub const DEBUG_OUTTYPE_ADDRESS_OF_FIELD = @as(u32, 65536);
pub const DEBUG_OUTTYPE_ADDRESS_AT_END = @as(u32, 131072);
pub const DEBUG_OUTTYPE_BLOCK_RECURSE = @as(u32, 2097152);
pub const DEBUG_FIND_SOURCE_DEFAULT = @as(u32, 0);
pub const DEBUG_FIND_SOURCE_FULL_PATH = @as(u32, 1);
pub const DEBUG_FIND_SOURCE_BEST_MATCH = @as(u32, 2);
pub const DEBUG_FIND_SOURCE_NO_SRCSRV = @as(u32, 4);
pub const DEBUG_FIND_SOURCE_TOKEN_LOOKUP = @as(u32, 8);
pub const DEBUG_FIND_SOURCE_WITH_CHECKSUM = @as(u32, 16);
pub const DEBUG_FIND_SOURCE_WITH_CHECKSUM_STRICT = @as(u32, 32);
pub const MODULE_ORDERS_MASK = @as(u32, 4026531840);
pub const MODULE_ORDERS_LOADTIME = @as(u32, 268435456);
pub const MODULE_ORDERS_MODULENAME = @as(u32, 536870912);
pub const DEBUG_MODNAME_IMAGE = @as(u32, 0);
pub const DEBUG_MODNAME_MODULE = @as(u32, 1);
pub const DEBUG_MODNAME_LOADED_IMAGE = @as(u32, 2);
pub const DEBUG_MODNAME_SYMBOL_FILE = @as(u32, 3);
pub const DEBUG_MODNAME_MAPPED_IMAGE = @as(u32, 4);
pub const DEBUG_TYPEOPTS_UNICODE_DISPLAY = @as(u32, 1);
pub const DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY = @as(u32, 2);
pub const DEBUG_TYPEOPTS_FORCERADIX_OUTPUT = @as(u32, 4);
pub const DEBUG_TYPEOPTS_MATCH_MAXSIZE = @as(u32, 8);
pub const DEBUG_GETMOD_DEFAULT = @as(u32, 0);
pub const DEBUG_GETMOD_NO_LOADED_MODULES = @as(u32, 1);
pub const DEBUG_GETMOD_NO_UNLOADED_MODULES = @as(u32, 2);
pub const DEBUG_ADDSYNTHMOD_DEFAULT = @as(u32, 0);
pub const DEBUG_ADDSYNTHMOD_ZEROBASE = @as(u32, 1);
pub const DEBUG_ADDSYNTHSYM_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTSYM_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTSYM_FORCE_OFFSET = @as(u32, 1);
pub const DEBUG_OUTSYM_SOURCE_LINE = @as(u32, 2);
pub const DEBUG_OUTSYM_ALLOW_DISPLACEMENT = @as(u32, 4);
pub const DEBUG_GETFNENT_DEFAULT = @as(u32, 0);
pub const DEBUG_GETFNENT_RAW_ENTRY_ONLY = @as(u32, 1);
pub const DEBUG_SOURCE_IS_STATEMENT = @as(u32, 1);
pub const DEBUG_GSEL_DEFAULT = @as(u32, 0);
pub const DEBUG_GSEL_NO_SYMBOL_LOADS = @as(u32, 1);
pub const DEBUG_GSEL_ALLOW_LOWER = @as(u32, 2);
pub const DEBUG_GSEL_ALLOW_HIGHER = @as(u32, 4);
pub const DEBUG_GSEL_NEAREST_ONLY = @as(u32, 8);
pub const DEBUG_GSEL_INLINE_CALLSITE = @as(u32, 16);
pub const DEBUG_FRAME_DEFAULT = @as(u32, 0);
pub const DEBUG_FRAME_IGNORE_INLINE = @as(u32, 1);
pub const DEBUG_COMMAND_EXCEPTION_ID = @as(u32, 3688893886);
pub const DEBUG_CMDEX_INVALID = @as(u32, 0);
pub const DEBUG_CMDEX_ADD_EVENT_STRING = @as(u32, 1);
pub const DEBUG_CMDEX_RESET_EVENT_STRINGS = @as(u32, 2);
pub const DEBUG_EXTINIT_HAS_COMMAND_HELP = @as(u32, 1);
pub const DEBUG_NOTIFY_SESSION_ACTIVE = @as(u32, 0);
pub const DEBUG_NOTIFY_SESSION_INACTIVE = @as(u32, 1);
pub const DEBUG_NOTIFY_SESSION_ACCESSIBLE = @as(u32, 2);
pub const DEBUG_NOTIFY_SESSION_INACCESSIBLE = @as(u32, 3);
pub const DEBUG_KNOWN_STRUCT_GET_NAMES = @as(u32, 1);
pub const DEBUG_KNOWN_STRUCT_GET_SINGLE_LINE_OUTPUT = @as(u32, 2);
pub const DEBUG_KNOWN_STRUCT_SUPPRESS_TYPE_NAME = @as(u32, 3);
pub const DEBUG_EXT_QVALUE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXT_PVALUE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXT_PVTYPE_IS_VALUE = @as(u32, 0);
pub const DEBUG_EXT_PVTYPE_IS_POINTER = @as(u32, 1);
pub const CROSS_PLATFORM_MAXIMUM_PROCESSORS = @as(u32, 2048);
pub const EXT_API_VERSION_NUMBER = @as(u32, 5);
pub const EXT_API_VERSION_NUMBER32 = @as(u32, 5);
pub const EXT_API_VERSION_NUMBER64 = @as(u32, 6);
pub const IG_KD_CONTEXT = @as(u32, 1);
pub const IG_READ_CONTROL_SPACE = @as(u32, 2);
pub const IG_WRITE_CONTROL_SPACE = @as(u32, 3);
pub const IG_READ_IO_SPACE = @as(u32, 4);
pub const IG_WRITE_IO_SPACE = @as(u32, 5);
pub const IG_READ_PHYSICAL = @as(u32, 6);
pub const IG_WRITE_PHYSICAL = @as(u32, 7);
pub const IG_READ_IO_SPACE_EX = @as(u32, 8);
pub const IG_WRITE_IO_SPACE_EX = @as(u32, 9);
pub const IG_KSTACK_HELP = @as(u32, 10);
pub const IG_SET_THREAD = @as(u32, 11);
pub const IG_READ_MSR = @as(u32, 12);
pub const IG_WRITE_MSR = @as(u32, 13);
pub const IG_GET_DEBUGGER_DATA = @as(u32, 14);
pub const IG_GET_KERNEL_VERSION = @as(u32, 15);
pub const IG_RELOAD_SYMBOLS = @as(u32, 16);
pub const IG_GET_SET_SYMPATH = @as(u32, 17);
pub const IG_GET_EXCEPTION_RECORD = @as(u32, 18);
pub const IG_IS_PTR64 = @as(u32, 19);
pub const IG_GET_BUS_DATA = @as(u32, 20);
pub const IG_SET_BUS_DATA = @as(u32, 21);
pub const IG_DUMP_SYMBOL_INFO = @as(u32, 22);
pub const IG_LOWMEM_CHECK = @as(u32, 23);
pub const IG_SEARCH_MEMORY = @as(u32, 24);
pub const IG_GET_CURRENT_THREAD = @as(u32, 25);
pub const IG_GET_CURRENT_PROCESS = @as(u32, 26);
pub const IG_GET_TYPE_SIZE = @as(u32, 27);
pub const IG_GET_CURRENT_PROCESS_HANDLE = @as(u32, 28);
pub const IG_GET_INPUT_LINE = @as(u32, 29);
pub const IG_GET_EXPRESSION_EX = @as(u32, 30);
pub const IG_TRANSLATE_VIRTUAL_TO_PHYSICAL = @as(u32, 31);
pub const IG_GET_CACHE_SIZE = @as(u32, 32);
pub const IG_READ_PHYSICAL_WITH_FLAGS = @as(u32, 33);
pub const IG_WRITE_PHYSICAL_WITH_FLAGS = @as(u32, 34);
pub const IG_POINTER_SEARCH_PHYSICAL = @as(u32, 35);
pub const IG_OBSOLETE_PLACEHOLDER_36 = @as(u32, 36);
pub const IG_GET_THREAD_OS_INFO = @as(u32, 37);
pub const IG_GET_CLR_DATA_INTERFACE = @as(u32, 38);
pub const IG_MATCH_PATTERN_A = @as(u32, 39);
pub const IG_FIND_FILE = @as(u32, 40);
pub const IG_TYPED_DATA_OBSOLETE = @as(u32, 41);
pub const IG_QUERY_TARGET_INTERFACE = @as(u32, 42);
pub const IG_TYPED_DATA = @as(u32, 43);
pub const IG_DISASSEMBLE_BUFFER = @as(u32, 44);
pub const IG_GET_ANY_MODULE_IN_RANGE = @as(u32, 45);
pub const IG_VIRTUAL_TO_PHYSICAL = @as(u32, 46);
pub const IG_PHYSICAL_TO_VIRTUAL = @as(u32, 47);
pub const IG_GET_CONTEXT_EX = @as(u32, 48);
pub const IG_GET_TEB_ADDRESS = @as(u32, 128);
pub const IG_GET_PEB_ADDRESS = @as(u32, 129);
pub const PHYS_FLAG_DEFAULT = @as(u32, 0);
pub const PHYS_FLAG_CACHED = @as(u32, 1);
pub const PHYS_FLAG_UNCACHED = @as(u32, 2);
pub const PHYS_FLAG_WRITE_COMBINED = @as(u32, 3);
pub const PTR_SEARCH_PHYS_ALL_HITS = @as(u32, 1);
pub const PTR_SEARCH_PHYS_PTE = @as(u32, 2);
pub const PTR_SEARCH_PHYS_RANGE_CHECK_ONLY = @as(u32, 4);
pub const PTR_SEARCH_PHYS_SIZE_SHIFT = @as(u32, 3);
pub const PTR_SEARCH_NO_SYMBOL_CHECK = @as(u32, 2147483648);
pub const EXT_FIND_FILE_ALLOW_GIVEN_PATH = @as(u32, 1);
pub const DEBUG_TYPED_DATA_IS_IN_MEMORY = @as(u32, 1);
pub const DEBUG_TYPED_DATA_PHYSICAL_DEFAULT = @as(u32, 2);
pub const DEBUG_TYPED_DATA_PHYSICAL_CACHED = @as(u32, 4);
pub const DEBUG_TYPED_DATA_PHYSICAL_UNCACHED = @as(u32, 6);
pub const DEBUG_TYPED_DATA_PHYSICAL_WRITE_COMBINED = @as(u32, 8);
pub const DEBUG_TYPED_DATA_PHYSICAL_MEMORY = @as(u32, 14);
pub const EXT_TDF_PHYSICAL_DEFAULT = @as(u32, 2);
pub const EXT_TDF_PHYSICAL_CACHED = @as(u32, 4);
pub const EXT_TDF_PHYSICAL_UNCACHED = @as(u32, 6);
pub const EXT_TDF_PHYSICAL_WRITE_COMBINED = @as(u32, 8);
pub const EXT_TDF_PHYSICAL_MEMORY = @as(u32, 14);
pub const WDBGEXTS_ADDRESS_DEFAULT = @as(u32, 0);
pub const WDBGEXTS_ADDRESS_SEG16 = @as(u32, 1);
pub const WDBGEXTS_ADDRESS_SEG32 = @as(u32, 2);
pub const WDBGEXTS_ADDRESS_RESERVED0 = @as(u32, 2147483648);
pub const DBGKD_VERS_FLAG_MP = @as(u32, 1);
pub const DBGKD_VERS_FLAG_DATA = @as(u32, 2);
pub const DBGKD_VERS_FLAG_PTR64 = @as(u32, 4);
pub const DBGKD_VERS_FLAG_NOMM = @as(u32, 8);
pub const DBGKD_VERS_FLAG_HSS = @as(u32, 16);
pub const DBGKD_VERS_FLAG_PARTITIONS = @as(u32, 32);
pub const DBGKD_VERS_FLAG_HAL_IN_NTOS = @as(u32, 64);
pub const KD_SECONDARY_VERSION_DEFAULT = @as(u32, 0);
pub const KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_1 = @as(u32, 0);
pub const KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_2 = @as(u32, 1);
pub const KD_SECONDARY_VERSION_AMD64_CONTEXT = @as(u32, 2);
pub const CURRENT_KD_SECONDARY_VERSION = @as(u32, 2);
pub const DBG_DUMP_NO_INDENT = @as(u32, 1);
pub const DBG_DUMP_NO_OFFSET = @as(u32, 2);
pub const DBG_DUMP_VERBOSE = @as(u32, 4);
pub const DBG_DUMP_CALL_FOR_EACH = @as(u32, 8);
pub const DBG_DUMP_LIST = @as(u32, 32);
pub const DBG_DUMP_NO_PRINT = @as(u32, 64);
pub const DBG_DUMP_GET_SIZE_ONLY = @as(u32, 128);
pub const DBG_DUMP_COMPACT_OUT = @as(u32, 8192);
pub const DBG_DUMP_ARRAY = @as(u32, 32768);
pub const DBG_DUMP_ADDRESS_OF_FIELD = @as(u32, 65536);
pub const DBG_DUMP_ADDRESS_AT_END = @as(u32, 131072);
pub const DBG_DUMP_COPY_TYPE_DATA = @as(u32, 262144);
pub const DBG_DUMP_READ_PHYSICAL = @as(u32, 524288);
pub const DBG_DUMP_FUNCTION_FORMAT = @as(u32, 1048576);
pub const DBG_DUMP_BLOCK_RECURSE = @as(u32, 2097152);
pub const DBG_DUMP_MATCH_SIZE = @as(u32, 4194304);
pub const DBG_RETURN_TYPE = @as(u32, 0);
pub const DBG_RETURN_SUBTYPES = @as(u32, 0);
pub const DBG_RETURN_TYPE_VALUES = @as(u32, 0);
pub const DBG_DUMP_FIELD_CALL_BEFORE_PRINT = @as(u32, 1);
pub const DBG_DUMP_FIELD_NO_CALLBACK_REQ = @as(u32, 2);
pub const DBG_DUMP_FIELD_RECUR_ON_THIS = @as(u32, 4);
pub const DBG_DUMP_FIELD_FULL_NAME = @as(u32, 8);
pub const DBG_DUMP_FIELD_ARRAY = @as(u32, 16);
pub const DBG_DUMP_FIELD_COPY_FIELD_DATA = @as(u32, 32);
pub const DBG_DUMP_FIELD_RETURN_ADDRESS = @as(u32, 4096);
pub const DBG_DUMP_FIELD_SIZE_IN_BITS = @as(u32, 8192);
pub const DBG_DUMP_FIELD_NO_PRINT = @as(u32, 16384);
pub const DBG_DUMP_FIELD_DEFAULT_STRING = @as(u32, 65536);
pub const DBG_DUMP_FIELD_WCHAR_STRING = @as(u32, 131072);
pub const DBG_DUMP_FIELD_MULTI_STRING = @as(u32, 262144);
pub const DBG_DUMP_FIELD_GUID_STRING = @as(u32, 524288);
pub const DBG_DUMP_FIELD_UTF32_STRING = @as(u32, 1048576);
pub const MEMORY_READ_ERROR = @as(u32, 1);
pub const SYMBOL_TYPE_INDEX_NOT_FOUND = @as(u32, 2);
pub const SYMBOL_TYPE_INFO_NOT_FOUND = @as(u32, 3);
pub const FIELDS_DID_NOT_MATCH = @as(u32, 4);
pub const NULL_SYM_DUMP_PARAM = @as(u32, 5);
pub const NULL_FIELD_NAME = @as(u32, 6);
pub const INCORRECT_VERSION_INFO = @as(u32, 7);
pub const EXIT_ON_CONTROLC = @as(u32, 8);
pub const CANNOT_ALLOCATE_MEMORY = @as(u32, 9);
pub const INSUFFICIENT_SPACE_TO_COPY = @as(u32, 10);
pub const ADDRESS_TYPE_INDEX_NOT_FOUND = @as(u32, 11);
pub const UNAVAILABLE_ERROR = @as(u32, 12);
pub const CATID_ActiveScript = Guid.initString("f0b7a1a1-9847-11cf-8f20-00805f2cd064");
pub const CATID_ActiveScriptParse = Guid.initString("f0b7a1a2-9847-11cf-8f20-00805f2cd064");
pub const CATID_ActiveScriptEncode = Guid.initString("f0b7a1a3-9847-11cf-8f20-00805f2cd064");
pub const OID_VBSSIP = Guid.initString("1629f04e-2799-4db5-8fe5-ace10f17ebab");
pub const OID_JSSIP = Guid.initString("06c9e010-38ce-11d4-a2a3-00104bd35090");
pub const OID_WSFSIP = Guid.initString("1a610570-38ce-11d4-a2a3-00104bd35090");
pub const SCRIPTITEM_ISVISIBLE = @as(u32, 2);
pub const SCRIPTITEM_ISSOURCE = @as(u32, 4);
pub const SCRIPTITEM_GLOBALMEMBERS = @as(u32, 8);
pub const SCRIPTITEM_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTITEM_CODEONLY = @as(u32, 512);
pub const SCRIPTITEM_NOCODE = @as(u32, 1024);
pub const SCRIPTTYPELIB_ISCONTROL = @as(u32, 16);
pub const SCRIPTTYPELIB_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTTEXT_DELAYEXECUTION = @as(u32, 1);
pub const SCRIPTTEXT_ISVISIBLE = @as(u32, 2);
pub const SCRIPTTEXT_ISEXPRESSION = @as(u32, 32);
pub const SCRIPTTEXT_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTTEXT_HOSTMANAGESSOURCE = @as(u32, 128);
pub const SCRIPTTEXT_ISXDOMAIN = @as(u32, 256);
pub const SCRIPTTEXT_ISNONUSERCODE = @as(u32, 512);
pub const SCRIPTPROC_ISEXPRESSION = @as(u32, 32);
pub const SCRIPTPROC_HOSTMANAGESSOURCE = @as(u32, 128);
pub const SCRIPTPROC_IMPLICIT_THIS = @as(u32, 256);
pub const SCRIPTPROC_IMPLICIT_PARENTS = @as(u32, 512);
pub const SCRIPTPROC_ISXDOMAIN = @as(u32, 1024);
pub const SCRIPTINFO_IUNKNOWN = @as(u32, 1);
pub const SCRIPTINFO_ITYPEINFO = @as(u32, 2);
pub const SCRIPTINTERRUPT_DEBUG = @as(u32, 1);
pub const SCRIPTINTERRUPT_RAISEEXCEPTION = @as(u32, 2);
pub const SCRIPTSTAT_STATEMENT_COUNT = @as(u32, 1);
pub const SCRIPTSTAT_INSTRUCTION_COUNT = @as(u32, 2);
pub const SCRIPTSTAT_INTSTRUCTION_TIME = @as(u32, 3);
pub const SCRIPTSTAT_TOTAL_TIME = @as(u32, 4);
pub const SCRIPT_ENCODE_SECTION = @as(u32, 1);
pub const SCRIPT_ENCODE_DEFAULT_LANGUAGE = @as(u32, 1);
pub const SCRIPT_ENCODE_NO_ASP_LANGUAGE = @as(u32, 2);
pub const SCRIPTPROP_NAME = @as(u32, 0);
pub const SCRIPTPROP_MAJORVERSION = @as(u32, 1);
pub const SCRIPTPROP_MINORVERSION = @as(u32, 2);
pub const SCRIPTPROP_BUILDNUMBER = @as(u32, 3);
pub const SCRIPTPROP_DELAYEDEVENTSINKING = @as(u32, 4096);
pub const SCRIPTPROP_CATCHEXCEPTION = @as(u32, 4097);
pub const SCRIPTPROP_CONVERSIONLCID = @as(u32, 4098);
pub const SCRIPTPROP_HOSTSTACKREQUIRED = @as(u32, 4099);
pub const SCRIPTPROP_SCRIPTSAREFULLYTRUSTED = @as(u32, 4100);
pub const SCRIPTPROP_DEBUGGER = @as(u32, 4352);
pub const SCRIPTPROP_JITDEBUG = @as(u32, 4353);
pub const SCRIPTPROP_GCCONTROLSOFTCLOSE = @as(u32, 8192);
pub const SCRIPTPROP_INTEGERMODE = @as(u32, 12288);
pub const SCRIPTPROP_STRINGCOMPAREINSTANCE = @as(u32, 12289);
pub const SCRIPTPROP_INVOKEVERSIONING = @as(u32, 16384);
pub const SCRIPTPROP_HACK_FIBERSUPPORT = @as(u32, 1879048192);
pub const SCRIPTPROP_HACK_TRIDENTEVENTSINK = @as(u32, 1879048193);
pub const SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION = @as(u32, 1879048194);
pub const SCRIPTPROP_HOSTKEEPALIVE = @as(u32, 1879048196);
pub const SCRIPT_E_RECORDED = @as(i32, -2040119292);
pub const SCRIPT_E_REPORTED = @as(i32, -2147352319);
pub const SCRIPT_E_PROPAGATE = @as(i32, -2147352318);
pub const MINIDUMP_VERSION = @as(u32, 42899);
pub const MINIDUMP_MISC1_PROCESSOR_POWER_INFO = @as(u32, 4);
pub const MINIDUMP_MISC3_PROCESS_INTEGRITY = @as(u32, 16);
pub const MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS = @as(u32, 32);
pub const MINIDUMP_MISC3_TIMEZONE = @as(u32, 64);
pub const MINIDUMP_MISC3_PROTECTED_PROCESS = @as(u32, 128);
pub const MINIDUMP_MISC4_BUILDSTRING = @as(u32, 256);
pub const MINIDUMP_MISC5_PROCESS_COOKIE = @as(u32, 512);
pub const MINIDUMP_SYSMEMINFO1_FILECACHE_TRANSITIONREPURPOSECOUNT_FLAGS = @as(u32, 1);
pub const MINIDUMP_SYSMEMINFO1_BASICPERF = @as(u32, 2);
pub const MINIDUMP_SYSMEMINFO1_PERF_CCTOTALDIRTYPAGES_CCDIRTYPAGETHRESHOLD = @as(u32, 4);
pub const MINIDUMP_SYSMEMINFO1_PERF_RESIDENTAVAILABLEPAGES_SHAREDCOMMITPAGES = @as(u32, 8);
pub const MINIDUMP_PROCESS_VM_COUNTERS = @as(u32, 1);
pub const MINIDUMP_PROCESS_VM_COUNTERS_VIRTUALSIZE = @as(u32, 2);
pub const MINIDUMP_PROCESS_VM_COUNTERS_EX = @as(u32, 4);
pub const MINIDUMP_PROCESS_VM_COUNTERS_EX2 = @as(u32, 8);
pub const MINIDUMP_PROCESS_VM_COUNTERS_JOB = @as(u32, 16);
pub const MAX_SYM_NAME = @as(u32, 2000);
pub const BIND_NO_BOUND_IMPORTS = @as(u32, 1);
pub const BIND_NO_UPDATE = @as(u32, 2);
pub const BIND_ALL_IMAGES = @as(u32, 4);
pub const BIND_CACHE_IMPORT_DLLS = @as(u32, 8);
pub const BIND_REPORT_64BIT_VA = @as(u32, 16);
pub const CHECKSUM_SUCCESS = @as(u32, 0);
pub const CHECKSUM_OPEN_FAILURE = @as(u32, 1);
pub const CHECKSUM_MAP_FAILURE = @as(u32, 2);
pub const CHECKSUM_MAPVIEW_FAILURE = @as(u32, 3);
pub const CHECKSUM_UNICODE_FAILURE = @as(u32, 4);
pub const SPLITSYM_REMOVE_PRIVATE = @as(u32, 1);
pub const SPLITSYM_EXTRACT_ALL = @as(u32, 2);
pub const SPLITSYM_SYMBOLPATH_IS_SRC = @as(u32, 4);
pub const CERT_PE_IMAGE_DIGEST_DEBUG_INFO = @as(u32, 1);
pub const CERT_PE_IMAGE_DIGEST_RESOURCES = @as(u32, 2);
pub const CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO = @as(u32, 4);
pub const CERT_PE_IMAGE_DIGEST_NON_PE_INFO = @as(u32, 8);
pub const CERT_SECTION_TYPE_ANY = @as(u32, 255);
pub const ERROR_IMAGE_NOT_STRIPPED = @as(u32, 34816);
pub const ERROR_NO_DBG_POINTER = @as(u32, 34817);
pub const ERROR_NO_PDB_POINTER = @as(u32, 34818);
pub const UNDNAME_COMPLETE = @as(u32, 0);
pub const UNDNAME_NO_LEADING_UNDERSCORES = @as(u32, 1);
pub const UNDNAME_NO_MS_KEYWORDS = @as(u32, 2);
pub const UNDNAME_NO_FUNCTION_RETURNS = @as(u32, 4);
pub const UNDNAME_NO_ALLOCATION_MODEL = @as(u32, 8);
pub const UNDNAME_NO_ALLOCATION_LANGUAGE = @as(u32, 16);
pub const UNDNAME_NO_MS_THISTYPE = @as(u32, 32);
pub const UNDNAME_NO_CV_THISTYPE = @as(u32, 64);
pub const UNDNAME_NO_THISTYPE = @as(u32, 96);
pub const UNDNAME_NO_ACCESS_SPECIFIERS = @as(u32, 128);
pub const UNDNAME_NO_THROW_SIGNATURES = @as(u32, 256);
pub const UNDNAME_NO_MEMBER_TYPE = @as(u32, 512);
pub const UNDNAME_NO_RETURN_UDT_MODEL = @as(u32, 1024);
pub const UNDNAME_32_BIT_DECODE = @as(u32, 2048);
pub const UNDNAME_NAME_ONLY = @as(u32, 4096);
pub const UNDNAME_NO_ARGUMENTS = @as(u32, 8192);
pub const UNDNAME_NO_SPECIAL_SYMS = @as(u32, 16384);
pub const DBHHEADER_PDBGUID = @as(u32, 3);
pub const INLINE_FRAME_CONTEXT_INIT = @as(u32, 0);
pub const INLINE_FRAME_CONTEXT_IGNORE = @as(u32, 4294967295);
pub const SYM_STKWALK_DEFAULT = @as(u32, 0);
pub const SYM_STKWALK_FORCE_FRAMEPTR = @as(u32, 1);
pub const SYM_STKWALK_ZEROEXTEND_PTRS = @as(u32, 2);
pub const API_VERSION_NUMBER = @as(u32, 12);
pub const SYMFLAG_NULL = @as(u32, 524288);
pub const SYMFLAG_FUNC_NO_RETURN = @as(u32, 1048576);
pub const SYMFLAG_SYNTHETIC_ZEROBASE = @as(u32, 2097152);
pub const SYMFLAG_PUBLIC_CODE = @as(u32, 4194304);
pub const SYMFLAG_REGREL_ALIASINDIR = @as(u32, 8388608);
pub const SYMFLAG_FIXUP_ARM64X = @as(u32, 16777216);
pub const SYMFLAG_GLOBAL = @as(u32, 33554432);
pub const SYMFLAG_RESET = @as(u32, 2147483648);
pub const IMAGEHLP_MODULE_REGION_DLLBASE = @as(u32, 1);
pub const IMAGEHLP_MODULE_REGION_DLLRANGE = @as(u32, 2);
pub const IMAGEHLP_MODULE_REGION_ADDITIONAL = @as(u32, 4);
pub const IMAGEHLP_MODULE_REGION_JIT = @as(u32, 8);
pub const IMAGEHLP_MODULE_REGION_ALL = @as(u32, 255);
pub const CBA_DEFERRED_SYMBOL_LOAD_START = @as(u32, 1);
pub const CBA_DEFERRED_SYMBOL_LOAD_COMPLETE = @as(u32, 2);
pub const CBA_DEFERRED_SYMBOL_LOAD_FAILURE = @as(u32, 3);
pub const CBA_SYMBOLS_UNLOADED = @as(u32, 4);
pub const CBA_DUPLICATE_SYMBOL = @as(u32, 5);
pub const CBA_READ_MEMORY = @as(u32, 6);
pub const CBA_DEFERRED_SYMBOL_LOAD_CANCEL = @as(u32, 7);
pub const CBA_SET_OPTIONS = @as(u32, 8);
pub const CBA_EVENT = @as(u32, 16);
pub const CBA_DEFERRED_SYMBOL_LOAD_PARTIAL = @as(u32, 32);
pub const CBA_DEBUG_INFO = @as(u32, 268435456);
pub const CBA_SRCSRV_INFO = @as(u32, 536870912);
pub const CBA_SRCSRV_EVENT = @as(u32, 1073741824);
pub const CBA_UPDATE_STATUS_BAR = @as(u32, 1342177280);
pub const CBA_ENGINE_PRESENT = @as(u32, 1610612736);
pub const CBA_CHECK_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 1879048192);
pub const CBA_CHECK_ARM_MACHINE_THUMB_TYPE_OVERRIDE = @as(u32, 2147483648);
pub const CBA_XML_LOG = @as(u32, 2415919104);
pub const CBA_MAP_JIT_SYMBOL = @as(u32, 2684354560);
pub const EVENT_SRCSPEW_START = @as(u32, 100);
pub const EVENT_SRCSPEW = @as(u32, 100);
pub const EVENT_SRCSPEW_END = @as(u32, 199);
pub const DSLFLAG_MISMATCHED_PDB = @as(u32, 1);
pub const DSLFLAG_MISMATCHED_DBG = @as(u32, 2);
pub const FLAG_ENGINE_PRESENT = @as(u32, 4);
pub const FLAG_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 8);
pub const FLAG_OVERRIDE_ARM_MACHINE_TYPE = @as(u32, 16);
pub const SYMOPT_CASE_INSENSITIVE = @as(u32, 1);
pub const SYMOPT_UNDNAME = @as(u32, 2);
pub const SYMOPT_DEFERRED_LOADS = @as(u32, 4);
pub const SYMOPT_NO_CPP = @as(u32, 8);
pub const SYMOPT_LOAD_LINES = @as(u32, 16);
pub const SYMOPT_OMAP_FIND_NEAREST = @as(u32, 32);
pub const SYMOPT_LOAD_ANYTHING = @as(u32, 64);
pub const SYMOPT_IGNORE_CVREC = @as(u32, 128);
pub const SYMOPT_NO_UNQUALIFIED_LOADS = @as(u32, 256);
pub const SYMOPT_FAIL_CRITICAL_ERRORS = @as(u32, 512);
pub const SYMOPT_EXACT_SYMBOLS = @as(u32, 1024);
pub const SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = @as(u32, 2048);
pub const SYMOPT_IGNORE_NT_SYMPATH = @as(u32, 4096);
pub const SYMOPT_INCLUDE_32BIT_MODULES = @as(u32, 8192);
pub const SYMOPT_PUBLICS_ONLY = @as(u32, 16384);
pub const SYMOPT_NO_PUBLICS = @as(u32, 32768);
pub const SYMOPT_AUTO_PUBLICS = @as(u32, 65536);
pub const SYMOPT_NO_IMAGE_SEARCH = @as(u32, 131072);
pub const SYMOPT_SECURE = @as(u32, 262144);
pub const SYMOPT_NO_PROMPTS = @as(u32, 524288);
pub const SYMOPT_OVERWRITE = @as(u32, 1048576);
pub const SYMOPT_IGNORE_IMAGEDIR = @as(u32, 2097152);
pub const SYMOPT_FLAT_DIRECTORY = @as(u32, 4194304);
pub const SYMOPT_FAVOR_COMPRESSED = @as(u32, 8388608);
pub const SYMOPT_ALLOW_ZERO_ADDRESS = @as(u32, 16777216);
pub const SYMOPT_DISABLE_SYMSRV_AUTODETECT = @as(u32, 33554432);
pub const SYMOPT_READONLY_CACHE = @as(u32, 67108864);
pub const SYMOPT_SYMPATH_LAST = @as(u32, 134217728);
pub const SYMOPT_DISABLE_FAST_SYMBOLS = @as(u32, 268435456);
pub const SYMOPT_DISABLE_SYMSRV_TIMEOUT = @as(u32, 536870912);
pub const SYMOPT_DISABLE_SRVSTAR_ON_STARTUP = @as(u32, 1073741824);
pub const SYMOPT_DEBUG = @as(u32, 2147483648);
pub const SYM_INLINE_COMP_ERROR = @as(u32, 0);
pub const SYM_INLINE_COMP_IDENTICAL = @as(u32, 1);
pub const SYM_INLINE_COMP_STEPIN = @as(u32, 2);
pub const SYM_INLINE_COMP_STEPOUT = @as(u32, 3);
pub const SYM_INLINE_COMP_STEPOVER = @as(u32, 4);
pub const SYM_INLINE_COMP_DIFFERENT = @as(u32, 5);
pub const ESLFLAG_FULLPATH = @as(u32, 1);
pub const ESLFLAG_NEAREST = @as(u32, 2);
pub const ESLFLAG_PREV = @as(u32, 4);
pub const ESLFLAG_NEXT = @as(u32, 8);
pub const ESLFLAG_INLINE_SITE = @as(u32, 16);
pub const SYMENUM_OPTIONS_DEFAULT = @as(u32, 1);
pub const SYMENUM_OPTIONS_INLINE = @as(u32, 2);
pub const SYMSEARCH_MASKOBJS = @as(u32, 1);
pub const SYMSEARCH_RECURSE = @as(u32, 2);
pub const SYMSEARCH_GLOBALSONLY = @as(u32, 4);
pub const SYMSEARCH_ALLITEMS = @as(u32, 8);
pub const EXT_OUTPUT_VER = @as(u32, 1);
pub const SYMSRV_VERSION = @as(u32, 2);
pub const SSRVOPT_CALLBACK = @as(u32, 1);
pub const SSRVOPT_OLDGUIDPTR = @as(u32, 16);
pub const SSRVOPT_UNATTENDED = @as(u32, 32);
pub const SSRVOPT_NOCOPY = @as(u32, 64);
pub const SSRVOPT_GETPATH = @as(u32, 64);
pub const SSRVOPT_PARENTWIN = @as(u32, 128);
pub const SSRVOPT_PARAMTYPE = @as(u32, 256);
pub const SSRVOPT_SECURE = @as(u32, 512);
pub const SSRVOPT_TRACE = @as(u32, 1024);
pub const SSRVOPT_SETCONTEXT = @as(u32, 2048);
pub const SSRVOPT_PROXY = @as(u32, 4096);
pub const SSRVOPT_DOWNSTREAM_STORE = @as(u32, 8192);
pub const SSRVOPT_OVERWRITE = @as(u32, 16384);
pub const SSRVOPT_RESETTOU = @as(u32, 32768);
pub const SSRVOPT_CALLBACKW = @as(u32, 65536);
pub const SSRVOPT_FLAT_DEFAULT_STORE = @as(u32, 131072);
pub const SSRVOPT_PROXYW = @as(u32, 262144);
pub const SSRVOPT_MESSAGE = @as(u32, 524288);
pub const SSRVOPT_SERVICE = @as(u32, 1048576);
pub const SSRVOPT_FAVOR_COMPRESSED = @as(u32, 2097152);
pub const SSRVOPT_STRING = @as(u32, 4194304);
pub const SSRVOPT_WINHTTP = @as(u32, 8388608);
pub const SSRVOPT_WININET = @as(u32, 16777216);
pub const SSRVOPT_DONT_UNCOMPRESS = @as(u32, 33554432);
pub const SSRVOPT_DISABLE_PING_HOST = @as(u32, 67108864);
pub const SSRVOPT_DISABLE_TIMEOUT = @as(u32, 134217728);
pub const SSRVOPT_ENABLE_COMM_MSG = @as(u32, 268435456);
pub const SSRVOPT_URI_FILTER = @as(u32, 536870912);
pub const SSRVOPT_URI_TIERS = @as(u32, 1073741824);
pub const SSRVOPT_RETRY_APP_HANG = @as(u32, 2147483648);
pub const SSRVOPT_MAX = @as(u32, 2147483648);
pub const NUM_SSRVOPTS = @as(u32, 32);
pub const SSRVURI_HTTP_NORMAL = @as(u32, 1);
pub const SSRVURI_HTTP_COMPRESSED = @as(u32, 2);
pub const SSRVURI_HTTP_FILEPTR = @as(u32, 4);
pub const SSRVURI_UNC_NORMAL = @as(u32, 16);
pub const SSRVURI_UNC_COMPRESSED = @as(u32, 32);
pub const SSRVURI_UNC_FILEPTR = @as(u32, 64);
pub const SSRVURI_HTTP_MASK = @as(u32, 15);
pub const SSRVURI_UNC_MASK = @as(u32, 240);
pub const SSRVURI_ALL = @as(u32, 255);
pub const SSRVURI_NORMAL = @as(u32, 1);
pub const SSRVURI_COMPRESSED = @as(u32, 2);
pub const SSRVURI_FILEPTR = @as(u32, 4);
pub const SSRVACTION_TRACE = @as(u32, 1);
pub const SSRVACTION_QUERYCANCEL = @as(u32, 2);
pub const SSRVACTION_EVENT = @as(u32, 3);
pub const SSRVACTION_EVENTW = @as(u32, 4);
pub const SSRVACTION_SIZE = @as(u32, 5);
pub const SSRVACTION_HTTPSTATUS = @as(u32, 6);
pub const SSRVACTION_XMLOUTPUT = @as(u32, 7);
pub const SSRVACTION_CHECKSUMSTATUS = @as(u32, 8);
pub const SYMSTOREOPT_ALT_INDEX = @as(u32, 16);
pub const SYMSTOREOPT_UNICODE = @as(u32, 32);
pub const SYMF_OMAP_GENERATED = @as(u32, 1);
pub const SYMF_OMAP_MODIFIED = @as(u32, 2);
pub const SYMF_REGISTER = @as(u32, 8);
pub const SYMF_REGREL = @as(u32, 16);
pub const SYMF_FRAMEREL = @as(u32, 32);
pub const SYMF_PARAMETER = @as(u32, 64);
pub const SYMF_LOCAL = @as(u32, 128);
pub const SYMF_CONSTANT = @as(u32, 256);
pub const SYMF_EXPORT = @as(u32, 512);
pub const SYMF_FORWARDER = @as(u32, 1024);
pub const SYMF_FUNCTION = @as(u32, 2048);
pub const SYMF_VIRTUAL = @as(u32, 4096);
pub const SYMF_THUNK = @as(u32, 8192);
pub const SYMF_TLSREL = @as(u32, 16384);
pub const IMAGEHLP_SYMBOL_INFO_VALUEPRESENT = @as(u32, 1);
pub const IMAGEHLP_SYMBOL_INFO_REGISTER = @as(u32, 8);
pub const IMAGEHLP_SYMBOL_INFO_REGRELATIVE = @as(u32, 16);
pub const IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE = @as(u32, 32);
pub const IMAGEHLP_SYMBOL_INFO_PARAMETER = @as(u32, 64);
pub const IMAGEHLP_SYMBOL_INFO_LOCAL = @as(u32, 128);
pub const IMAGEHLP_SYMBOL_INFO_CONSTANT = @as(u32, 256);
pub const IMAGEHLP_SYMBOL_FUNCTION = @as(u32, 2048);
pub const IMAGEHLP_SYMBOL_VIRTUAL = @as(u32, 4096);
pub const IMAGEHLP_SYMBOL_THUNK = @as(u32, 8192);
pub const IMAGEHLP_SYMBOL_INFO_TLSRELATIVE = @as(u32, 16384);
pub const IMAGEHLP_RMAP_MAPPED_FLAT = @as(u32, 1);
pub const IMAGEHLP_RMAP_BIG_ENDIAN = @as(u32, 2);
pub const IMAGEHLP_RMAP_IGNORE_MISCOMPARE = @as(u32, 4);
pub const IMAGEHLP_RMAP_FIXUP_ARM64X = @as(u32, 268435456);
pub const IMAGEHLP_RMAP_LOAD_RW_DATA_SECTIONS = @as(u32, 536870912);
pub const IMAGEHLP_RMAP_OMIT_SHARED_RW_DATA_SECTIONS = @as(u32, 1073741824);
pub const IMAGEHLP_RMAP_FIXUP_IMAGEBASE = @as(u32, 2147483648);
pub const WCT_MAX_NODE_COUNT = @as(u32, 16);
pub const WCT_OBJNAME_LENGTH = @as(u32, 128);
pub const WCT_NETWORK_IO_FLAG = @as(u32, 8);
pub const APPBREAKFLAG_DEBUGGER_BLOCK = @as(u32, 1);
pub const APPBREAKFLAG_DEBUGGER_HALT = @as(u32, 2);
pub const APPBREAKFLAG_STEP = @as(u32, 65536);
pub const APPBREAKFLAG_NESTED = @as(u32, 131072);
pub const APPBREAKFLAG_STEPTYPE_SOURCE = @as(u32, 0);
pub const APPBREAKFLAG_STEPTYPE_BYTECODE = @as(u32, 1048576);
pub const APPBREAKFLAG_STEPTYPE_MACHINE = @as(u32, 2097152);
pub const APPBREAKFLAG_STEPTYPE_MASK = @as(u32, 15728640);
pub const APPBREAKFLAG_IN_BREAKPOINT = @as(u32, 2147483648);
pub const SOURCETEXT_ATTR_KEYWORD = @as(u32, 1);
pub const SOURCETEXT_ATTR_COMMENT = @as(u32, 2);
pub const SOURCETEXT_ATTR_NONSOURCE = @as(u32, 4);
pub const SOURCETEXT_ATTR_OPERATOR = @as(u32, 8);
pub const SOURCETEXT_ATTR_NUMBER = @as(u32, 16);
pub const SOURCETEXT_ATTR_STRING = @as(u32, 32);
pub const SOURCETEXT_ATTR_FUNCTION_START = @as(u32, 64);
pub const TEXT_DOC_ATTR_READONLY = @as(u32, 1);
pub const TEXT_DOC_ATTR_TYPE_PRIMARY = @as(u32, 2);
pub const TEXT_DOC_ATTR_TYPE_WORKER = @as(u32, 4);
pub const TEXT_DOC_ATTR_TYPE_SCRIPT = @as(u32, 8);
pub const DEBUG_TEXT_ISEXPRESSION = @as(u32, 1);
pub const DEBUG_TEXT_RETURNVALUE = @as(u32, 2);
pub const DEBUG_TEXT_NOSIDEEFFECTS = @as(u32, 4);
pub const DEBUG_TEXT_ALLOWBREAKPOINTS = @as(u32, 8);
pub const DEBUG_TEXT_ALLOWERRORREPORT = @as(u32, 16);
pub const DEBUG_TEXT_EVALUATETOCODECONTEXT = @as(u32, 32);
pub const DEBUG_TEXT_ISNONUSERCODE = @as(u32, 64);
pub const THREAD_STATE_RUNNING = @as(u32, 1);
pub const THREAD_STATE_SUSPENDED = @as(u32, 2);
pub const THREAD_BLOCKED = @as(u32, 4);
pub const THREAD_OUT_OF_CONTEXT = @as(u32, 8);
pub const CATID_ActiveScriptAuthor = Guid.initString("0aee2a92-bcbb-11d0-8c72-00c04fc2b085");
pub const FACILITY_JsDEBUG = @as(u32, 3527);
pub const E_JsDEBUG_MISMATCHED_RUNTIME = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -1916338175));
pub const E_JsDEBUG_UNKNOWN_THREAD = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -1916338174));
pub const E_JsDEBUG_OUTSIDE_OF_VM = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -1916338172));
pub const E_JsDEBUG_INVALID_MEMORY_ADDRESS = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -1916338171));
pub const E_JsDEBUG_SOURCE_LOCATION_NOT_FOUND = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -1916338170));
pub const E_JsDEBUG_RUNTIME_NOT_IN_DEBUG_MODE = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -1916338169));
pub const DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32 = @as(u32, 700);
pub const DMP_CONTEXT_RECORD_SIZE_32 = @as(u32, 1200);
pub const DMP_RESERVED_0_SIZE_32 = @as(u32, 1760);
pub const DMP_RESERVED_2_SIZE_32 = @as(u32, 16);
pub const DMP_RESERVED_3_SIZE_32 = @as(u32, 56);
pub const DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64 = @as(u32, 700);
pub const DMP_CONTEXT_RECORD_SIZE_64 = @as(u32, 3000);
pub const DMP_RESERVED_0_SIZE_64 = @as(u32, 4008);
pub const DMP_HEADER_COMMENT_SIZE = @as(u32, 128);
pub const DUMP_SUMMARY_VALID_KERNEL_VA = @as(u32, 1);
pub const DUMP_SUMMARY_VALID_CURRENT_USER_VA = @as(u32, 2);
pub const INTERFACESAFE_FOR_UNTRUSTED_CALLER = @as(u32, 1);
pub const INTERFACESAFE_FOR_UNTRUSTED_DATA = @as(u32, 2);
pub const INTERFACE_USES_DISPEX = @as(u32, 4);
pub const INTERFACE_USES_SECURITY_MANAGER = @as(u32, 8);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10 = @as(u32, 10);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_11 = @as(u32, 11);
pub const WHEA_MAX_MC_BANKS = @as(u32, 32);
pub const WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST = @as(u32, 1);
pub const WHEA_ERROR_SOURCE_FLAG_GLOBAL = @as(u32, 2);
pub const WHEA_ERROR_SOURCE_FLAG_GHES_ASSIST = @as(u32, 4);
pub const WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE = @as(u32, 2147483648);
pub const WHEA_ERROR_SOURCE_INVALID_RELATED_SOURCE = @as(u32, 65535);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE = @as(u32, 0);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC = @as(u32, 1);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI = @as(u32, 2);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA = @as(u32, 3);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC = @as(u32, 4);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE = @as(u32, 5);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT = @as(u32, 6);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT = @as(u32, 7);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE = @as(u32, 8);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC = @as(u32, 9);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC_V2 = @as(u32, 10);
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA = @as(u32, 0);
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA = @as(u32, 1);
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA = @as(u32, 2);
pub const WHEA_NOTIFICATION_TYPE_POLLED = @as(u32, 0);
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT = @as(u32, 1);
pub const WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT = @as(u32, 2);
pub const WHEA_NOTIFICATION_TYPE_SCI = @as(u32, 3);
pub const WHEA_NOTIFICATION_TYPE_NMI = @as(u32, 4);
pub const WHEA_NOTIFICATION_TYPE_CMCI = @as(u32, 5);
pub const WHEA_NOTIFICATION_TYPE_MCE = @as(u32, 6);
pub const WHEA_NOTIFICATION_TYPE_GPIO_SIGNAL = @as(u32, 7);
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEA = @as(u32, 8);
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEI = @as(u32, 9);
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT_GSIV = @as(u32, 10);
pub const WHEA_NOTIFICATION_TYPE_SDEI = @as(u32, 11);
pub const WHEA_DEVICE_DRIVER_CONFIG_V1 = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_CONFIG_V2 = @as(u32, 2);
pub const WHEA_DEVICE_DRIVER_CONFIG_MIN = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_CONFIG_MAX = @as(u32, 2);
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_V1 = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_MIN = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_MAX = @as(u32, 1);
pub const WHEA_DISABLE_OFFLINE = @as(u32, 0);
pub const WHEA_MEM_PERSISTOFFLINE = @as(u32, 1);
pub const WHEA_MEM_PFA_DISABLE = @as(u32, 2);
pub const WHEA_MEM_PFA_PAGECOUNT = @as(u32, 3);
pub const WHEA_MEM_PFA_THRESHOLD = @as(u32, 4);
pub const WHEA_MEM_PFA_TIMEOUT = @as(u32, 5);
pub const WHEA_DISABLE_DUMMY_WRITE = @as(u32, 6);
pub const WHEA_RESTORE_CMCI_ENABLED = @as(u32, 7);
pub const WHEA_RESTORE_CMCI_ATTEMPTS = @as(u32, 8);
pub const WHEA_RESTORE_CMCI_ERR_LIMIT = @as(u32, 9);
pub const WHEA_CMCI_THRESHOLD_COUNT = @as(u32, 10);
pub const WHEA_CMCI_THRESHOLD_TIME = @as(u32, 11);
pub const WHEA_CMCI_THRESHOLD_POLL_COUNT = @as(u32, 12);
pub const WHEA_PENDING_PAGE_LIST_SZ = @as(u32, 13);
pub const WHEA_BAD_PAGE_LIST_MAX_SIZE = @as(u32, 14);
pub const WHEA_BAD_PAGE_LIST_LOCATION = @as(u32, 15);
pub const WHEA_NOTIFY_ALL_OFFLINES = @as(u32, 16);
pub const IPMI_OS_SEL_RECORD_VERSION_1 = @as(u32, 1);
pub const IPMI_OS_SEL_RECORD_VERSION = @as(u32, 1);
pub const IPMI_IOCTL_INDEX = @as(u32, 1024);
pub const IOCTL_IPMI_INTERNAL_RECORD_SEL_EVENT = @as(u32, 2232320);
pub const IPMI_OS_SEL_RECORD_MASK = @as(u32, 65535);
pub const DBGKD_SIMULATION_NONE = @as(i32, 0);
pub const DBGKD_SIMULATION_EXDI = @as(i32, 1);
pub const ACTIVPROF_E_PROFILER_PRESENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const ACTIVPROF_E_PROFILER_ABSENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const ACTIVPROF_E_UNABLE_TO_APPLY_ACTION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const PROFILER_HEAP_OBJECT_NAME_ID_UNAVAILABLE = @as(u32, 4294967295);
pub const sevMax = @as(i32, 4);
pub const fasaPreferInternalHandler = @as(u32, 1);
pub const fasaSupportInternalHandler = @as(u32, 2);
pub const fasaCaseSensitive = @as(u32, 4);
pub const SCRIPT_CMPL_NOLIST = @as(u32, 0);
pub const SCRIPT_CMPL_MEMBERLIST = @as(u32, 1);
pub const SCRIPT_CMPL_ENUMLIST = @as(u32, 2);
pub const SCRIPT_CMPL_PARAMTIP = @as(u32, 4);
pub const SCRIPT_CMPL_GLOBALLIST = @as(u32, 8);
pub const SCRIPT_CMPL_ENUM_TRIGGER = @as(u32, 1);
pub const SCRIPT_CMPL_MEMBER_TRIGGER = @as(u32, 2);
pub const SCRIPT_CMPL_PARAM_TRIGGER = @as(u32, 3);
pub const SCRIPT_CMPL_COMMIT = @as(u32, 4);
pub const GETATTRTYPE_NORMAL = @as(u32, 0);
pub const GETATTRTYPE_DEPSCAN = @as(u32, 1);
pub const GETATTRFLAG_THIS = @as(u32, 256);
pub const GETATTRFLAG_HUMANTEXT = @as(u32, 32768);
pub const SOURCETEXT_ATTR_HUMANTEXT = @as(u32, 32768);
pub const SOURCETEXT_ATTR_IDENTIFIER = @as(u32, 256);
pub const SOURCETEXT_ATTR_MEMBERLOOKUP = @as(u32, 512);
pub const SOURCETEXT_ATTR_THIS = @as(u32, 1024);

//--------------------------------------------------------------------------------
// Section: Types (842)
//--------------------------------------------------------------------------------
pub const SYM_LOAD_FLAGS = enum(u32) {
    NONE = 0,
    VIRTUAL = 1,
    ALT_INDEX = 2,
    NO_SYMBOLS = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        VIRTUAL: u1 = 0,
        ALT_INDEX: u1 = 0,
        NO_SYMBOLS: u1 = 0,
    }) SYM_LOAD_FLAGS {
        return @as(SYM_LOAD_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(SYM_LOAD_FLAGS.NONE) else 0) | (if (o.VIRTUAL == 1) @intFromEnum(SYM_LOAD_FLAGS.VIRTUAL) else 0) | (if (o.ALT_INDEX == 1) @intFromEnum(SYM_LOAD_FLAGS.ALT_INDEX) else 0) | (if (o.NO_SYMBOLS == 1) @intFromEnum(SYM_LOAD_FLAGS.NO_SYMBOLS) else 0)));
    }
};
pub const SLMFLAG_NONE = SYM_LOAD_FLAGS.NONE;
pub const SLMFLAG_VIRTUAL = SYM_LOAD_FLAGS.VIRTUAL;
pub const SLMFLAG_ALT_INDEX = SYM_LOAD_FLAGS.ALT_INDEX;
pub const SLMFLAG_NO_SYMBOLS = SYM_LOAD_FLAGS.NO_SYMBOLS;

pub const IMAGE_SECTION_CHARACTERISTICS = enum(u32) {
    TYPE_NO_PAD = 8,
    CNT_CODE = 32,
    CNT_INITIALIZED_DATA = 64,
    CNT_UNINITIALIZED_DATA = 128,
    LNK_OTHER = 256,
    LNK_INFO = 512,
    LNK_REMOVE = 2048,
    LNK_COMDAT = 4096,
    NO_DEFER_SPEC_EXC = 16384,
    GPREL = 32768,
    // MEM_FARDATA = 32768, this enum value conflicts with GPREL
    MEM_PURGEABLE = 131072,
    // MEM_16BIT = 131072, this enum value conflicts with MEM_PURGEABLE
    MEM_LOCKED = 262144,
    MEM_PRELOAD = 524288,
    ALIGN_1BYTES = 1048576,
    ALIGN_2BYTES = 2097152,
    ALIGN_4BYTES = 3145728,
    ALIGN_8BYTES = 4194304,
    ALIGN_16BYTES = 5242880,
    ALIGN_32BYTES = 6291456,
    ALIGN_64BYTES = 7340032,
    ALIGN_128BYTES = 8388608,
    ALIGN_256BYTES = 9437184,
    ALIGN_512BYTES = 10485760,
    ALIGN_1024BYTES = 11534336,
    ALIGN_2048BYTES = 12582912,
    ALIGN_4096BYTES = 13631488,
    ALIGN_8192BYTES = 14680064,
    ALIGN_MASK = 15728640,
    LNK_NRELOC_OVFL = 16777216,
    MEM_DISCARDABLE = 33554432,
    MEM_NOT_CACHED = 67108864,
    MEM_NOT_PAGED = 134217728,
    MEM_SHARED = 268435456,
    MEM_EXECUTE = 536870912,
    MEM_READ = 1073741824,
    MEM_WRITE = 2147483648,
    SCALE_INDEX = 1,
    _,
    pub fn initFlags(o: struct {
        TYPE_NO_PAD: u1 = 0,
        CNT_CODE: u1 = 0,
        CNT_INITIALIZED_DATA: u1 = 0,
        CNT_UNINITIALIZED_DATA: u1 = 0,
        LNK_OTHER: u1 = 0,
        LNK_INFO: u1 = 0,
        LNK_REMOVE: u1 = 0,
        LNK_COMDAT: u1 = 0,
        NO_DEFER_SPEC_EXC: u1 = 0,
        GPREL: u1 = 0,
        MEM_PURGEABLE: u1 = 0,
        MEM_LOCKED: u1 = 0,
        MEM_PRELOAD: u1 = 0,
        ALIGN_1BYTES: u1 = 0,
        ALIGN_2BYTES: u1 = 0,
        ALIGN_4BYTES: u1 = 0,
        ALIGN_8BYTES: u1 = 0,
        ALIGN_16BYTES: u1 = 0,
        ALIGN_32BYTES: u1 = 0,
        ALIGN_64BYTES: u1 = 0,
        ALIGN_128BYTES: u1 = 0,
        ALIGN_256BYTES: u1 = 0,
        ALIGN_512BYTES: u1 = 0,
        ALIGN_1024BYTES: u1 = 0,
        ALIGN_2048BYTES: u1 = 0,
        ALIGN_4096BYTES: u1 = 0,
        ALIGN_8192BYTES: u1 = 0,
        ALIGN_MASK: u1 = 0,
        LNK_NRELOC_OVFL: u1 = 0,
        MEM_DISCARDABLE: u1 = 0,
        MEM_NOT_CACHED: u1 = 0,
        MEM_NOT_PAGED: u1 = 0,
        MEM_SHARED: u1 = 0,
        MEM_EXECUTE: u1 = 0,
        MEM_READ: u1 = 0,
        MEM_WRITE: u1 = 0,
        SCALE_INDEX: u1 = 0,
    }) IMAGE_SECTION_CHARACTERISTICS {
        return @as(IMAGE_SECTION_CHARACTERISTICS, @enumFromInt((if (o.TYPE_NO_PAD == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.TYPE_NO_PAD) else 0) | (if (o.CNT_CODE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.CNT_CODE) else 0) | (if (o.CNT_INITIALIZED_DATA == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA) else 0) | (if (o.CNT_UNINITIALIZED_DATA == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA) else 0) | (if (o.LNK_OTHER == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_OTHER) else 0) | (if (o.LNK_INFO == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_INFO) else 0) | (if (o.LNK_REMOVE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_REMOVE) else 0) | (if (o.LNK_COMDAT == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_COMDAT) else 0) | (if (o.NO_DEFER_SPEC_EXC == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.NO_DEFER_SPEC_EXC) else 0) | (if (o.GPREL == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.GPREL) else 0) | (if (o.MEM_PURGEABLE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE) else 0) | (if (o.MEM_LOCKED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_LOCKED) else 0) | (if (o.MEM_PRELOAD == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_PRELOAD) else 0) | (if (o.ALIGN_1BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_1BYTES) else 0) | (if (o.ALIGN_2BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_2BYTES) else 0) | (if (o.ALIGN_4BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_4BYTES) else 0) | (if (o.ALIGN_8BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_8BYTES) else 0) | (if (o.ALIGN_16BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_16BYTES) else 0) | (if (o.ALIGN_32BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_32BYTES) else 0) | (if (o.ALIGN_64BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_64BYTES) else 0) | (if (o.ALIGN_128BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_128BYTES) else 0) | (if (o.ALIGN_256BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_256BYTES) else 0) | (if (o.ALIGN_512BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_512BYTES) else 0) | (if (o.ALIGN_1024BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_1024BYTES) else 0) | (if (o.ALIGN_2048BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_2048BYTES) else 0) | (if (o.ALIGN_4096BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_4096BYTES) else 0) | (if (o.ALIGN_8192BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_8192BYTES) else 0) | (if (o.ALIGN_MASK == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_MASK) else 0) | (if (o.LNK_NRELOC_OVFL == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_NRELOC_OVFL) else 0) | (if (o.MEM_DISCARDABLE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_DISCARDABLE) else 0) | (if (o.MEM_NOT_CACHED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_CACHED) else 0) | (if (o.MEM_NOT_PAGED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_PAGED) else 0) | (if (o.MEM_SHARED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_SHARED) else 0) | (if (o.MEM_EXECUTE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_EXECUTE) else 0) | (if (o.MEM_READ == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_READ) else 0) | (if (o.MEM_WRITE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_WRITE) else 0) | (if (o.SCALE_INDEX == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.SCALE_INDEX) else 0)));
    }
};
pub const IMAGE_SCN_TYPE_NO_PAD = IMAGE_SECTION_CHARACTERISTICS.TYPE_NO_PAD;
pub const IMAGE_SCN_CNT_CODE = IMAGE_SECTION_CHARACTERISTICS.CNT_CODE;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA = IMAGE_SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA = IMAGE_SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA;
pub const IMAGE_SCN_LNK_OTHER = IMAGE_SECTION_CHARACTERISTICS.LNK_OTHER;
pub const IMAGE_SCN_LNK_INFO = IMAGE_SECTION_CHARACTERISTICS.LNK_INFO;
pub const IMAGE_SCN_LNK_REMOVE = IMAGE_SECTION_CHARACTERISTICS.LNK_REMOVE;
pub const IMAGE_SCN_LNK_COMDAT = IMAGE_SECTION_CHARACTERISTICS.LNK_COMDAT;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC = IMAGE_SECTION_CHARACTERISTICS.NO_DEFER_SPEC_EXC;
pub const IMAGE_SCN_GPREL = IMAGE_SECTION_CHARACTERISTICS.GPREL;
pub const IMAGE_SCN_MEM_FARDATA = IMAGE_SECTION_CHARACTERISTICS.GPREL;
pub const IMAGE_SCN_MEM_PURGEABLE = IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE;
pub const IMAGE_SCN_MEM_16BIT = IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE;
pub const IMAGE_SCN_MEM_LOCKED = IMAGE_SECTION_CHARACTERISTICS.MEM_LOCKED;
pub const IMAGE_SCN_MEM_PRELOAD = IMAGE_SECTION_CHARACTERISTICS.MEM_PRELOAD;
pub const IMAGE_SCN_ALIGN_1BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_1BYTES;
pub const IMAGE_SCN_ALIGN_2BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_2BYTES;
pub const IMAGE_SCN_ALIGN_4BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_4BYTES;
pub const IMAGE_SCN_ALIGN_8BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_8BYTES;
pub const IMAGE_SCN_ALIGN_16BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_16BYTES;
pub const IMAGE_SCN_ALIGN_32BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_32BYTES;
pub const IMAGE_SCN_ALIGN_64BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_64BYTES;
pub const IMAGE_SCN_ALIGN_128BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_128BYTES;
pub const IMAGE_SCN_ALIGN_256BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_256BYTES;
pub const IMAGE_SCN_ALIGN_512BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_512BYTES;
pub const IMAGE_SCN_ALIGN_1024BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_1024BYTES;
pub const IMAGE_SCN_ALIGN_2048BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_2048BYTES;
pub const IMAGE_SCN_ALIGN_4096BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_4096BYTES;
pub const IMAGE_SCN_ALIGN_8192BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_8192BYTES;
pub const IMAGE_SCN_ALIGN_MASK = IMAGE_SECTION_CHARACTERISTICS.ALIGN_MASK;
pub const IMAGE_SCN_LNK_NRELOC_OVFL = IMAGE_SECTION_CHARACTERISTICS.LNK_NRELOC_OVFL;
pub const IMAGE_SCN_MEM_DISCARDABLE = IMAGE_SECTION_CHARACTERISTICS.MEM_DISCARDABLE;
pub const IMAGE_SCN_MEM_NOT_CACHED = IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_CACHED;
pub const IMAGE_SCN_MEM_NOT_PAGED = IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_PAGED;
pub const IMAGE_SCN_MEM_SHARED = IMAGE_SECTION_CHARACTERISTICS.MEM_SHARED;
pub const IMAGE_SCN_MEM_EXECUTE = IMAGE_SECTION_CHARACTERISTICS.MEM_EXECUTE;
pub const IMAGE_SCN_MEM_READ = IMAGE_SECTION_CHARACTERISTICS.MEM_READ;
pub const IMAGE_SCN_MEM_WRITE = IMAGE_SECTION_CHARACTERISTICS.MEM_WRITE;
pub const IMAGE_SCN_SCALE_INDEX = IMAGE_SECTION_CHARACTERISTICS.SCALE_INDEX;

pub const IMAGE_FILE_MACHINE = enum(u16) {
    AXP64 = 644,
    I386 = 332,
    IA64 = 512,
    AMD64 = 34404,
    UNKNOWN = 0,
    TARGET_HOST = 1,
    R3000 = 354,
    R4000 = 358,
    R10000 = 360,
    WCEMIPSV2 = 361,
    ALPHA = 388,
    SH3 = 418,
    SH3DSP = 419,
    SH3E = 420,
    SH4 = 422,
    SH5 = 424,
    ARM = 448,
    THUMB = 450,
    ARMNT = 452,
    AM33 = 467,
    POWERPC = 496,
    POWERPCFP = 497,
    MIPS16 = 614,
    // ALPHA64 = 644, this enum value conflicts with AXP64
    MIPSFPU = 870,
    MIPSFPU16 = 1126,
    TRICORE = 1312,
    CEF = 3311,
    EBC = 3772,
    M32R = 36929,
    ARM64 = 43620,
    CEE = 49390,
};
pub const IMAGE_FILE_MACHINE_AXP64 = IMAGE_FILE_MACHINE.AXP64;
pub const IMAGE_FILE_MACHINE_I386 = IMAGE_FILE_MACHINE.I386;
pub const IMAGE_FILE_MACHINE_IA64 = IMAGE_FILE_MACHINE.IA64;
pub const IMAGE_FILE_MACHINE_AMD64 = IMAGE_FILE_MACHINE.AMD64;
pub const IMAGE_FILE_MACHINE_UNKNOWN = IMAGE_FILE_MACHINE.UNKNOWN;
pub const IMAGE_FILE_MACHINE_TARGET_HOST = IMAGE_FILE_MACHINE.TARGET_HOST;
pub const IMAGE_FILE_MACHINE_R3000 = IMAGE_FILE_MACHINE.R3000;
pub const IMAGE_FILE_MACHINE_R4000 = IMAGE_FILE_MACHINE.R4000;
pub const IMAGE_FILE_MACHINE_R10000 = IMAGE_FILE_MACHINE.R10000;
pub const IMAGE_FILE_MACHINE_WCEMIPSV2 = IMAGE_FILE_MACHINE.WCEMIPSV2;
pub const IMAGE_FILE_MACHINE_ALPHA = IMAGE_FILE_MACHINE.ALPHA;
pub const IMAGE_FILE_MACHINE_SH3 = IMAGE_FILE_MACHINE.SH3;
pub const IMAGE_FILE_MACHINE_SH3DSP = IMAGE_FILE_MACHINE.SH3DSP;
pub const IMAGE_FILE_MACHINE_SH3E = IMAGE_FILE_MACHINE.SH3E;
pub const IMAGE_FILE_MACHINE_SH4 = IMAGE_FILE_MACHINE.SH4;
pub const IMAGE_FILE_MACHINE_SH5 = IMAGE_FILE_MACHINE.SH5;
pub const IMAGE_FILE_MACHINE_ARM = IMAGE_FILE_MACHINE.ARM;
pub const IMAGE_FILE_MACHINE_THUMB = IMAGE_FILE_MACHINE.THUMB;
pub const IMAGE_FILE_MACHINE_ARMNT = IMAGE_FILE_MACHINE.ARMNT;
pub const IMAGE_FILE_MACHINE_AM33 = IMAGE_FILE_MACHINE.AM33;
pub const IMAGE_FILE_MACHINE_POWERPC = IMAGE_FILE_MACHINE.POWERPC;
pub const IMAGE_FILE_MACHINE_POWERPCFP = IMAGE_FILE_MACHINE.POWERPCFP;
pub const IMAGE_FILE_MACHINE_MIPS16 = IMAGE_FILE_MACHINE.MIPS16;
pub const IMAGE_FILE_MACHINE_ALPHA64 = IMAGE_FILE_MACHINE.AXP64;
pub const IMAGE_FILE_MACHINE_MIPSFPU = IMAGE_FILE_MACHINE.MIPSFPU;
pub const IMAGE_FILE_MACHINE_MIPSFPU16 = IMAGE_FILE_MACHINE.MIPSFPU16;
pub const IMAGE_FILE_MACHINE_TRICORE = IMAGE_FILE_MACHINE.TRICORE;
pub const IMAGE_FILE_MACHINE_CEF = IMAGE_FILE_MACHINE.CEF;
pub const IMAGE_FILE_MACHINE_EBC = IMAGE_FILE_MACHINE.EBC;
pub const IMAGE_FILE_MACHINE_M32R = IMAGE_FILE_MACHINE.M32R;
pub const IMAGE_FILE_MACHINE_ARM64 = IMAGE_FILE_MACHINE.ARM64;
pub const IMAGE_FILE_MACHINE_CEE = IMAGE_FILE_MACHINE.CEE;

pub const IMAGE_SUBSYSTEM = enum(u16) {
    UNKNOWN = 0,
    NATIVE = 1,
    WINDOWS_GUI = 2,
    WINDOWS_CUI = 3,
    OS2_CUI = 5,
    POSIX_CUI = 7,
    NATIVE_WINDOWS = 8,
    WINDOWS_CE_GUI = 9,
    EFI_APPLICATION = 10,
    EFI_BOOT_SERVICE_DRIVER = 11,
    EFI_RUNTIME_DRIVER = 12,
    EFI_ROM = 13,
    XBOX = 14,
    WINDOWS_BOOT_APPLICATION = 16,
    XBOX_CODE_CATALOG = 17,
};
pub const IMAGE_SUBSYSTEM_UNKNOWN = IMAGE_SUBSYSTEM.UNKNOWN;
pub const IMAGE_SUBSYSTEM_NATIVE = IMAGE_SUBSYSTEM.NATIVE;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI = IMAGE_SUBSYSTEM.WINDOWS_GUI;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI = IMAGE_SUBSYSTEM.WINDOWS_CUI;
pub const IMAGE_SUBSYSTEM_OS2_CUI = IMAGE_SUBSYSTEM.OS2_CUI;
pub const IMAGE_SUBSYSTEM_POSIX_CUI = IMAGE_SUBSYSTEM.POSIX_CUI;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS = IMAGE_SUBSYSTEM.NATIVE_WINDOWS;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = IMAGE_SUBSYSTEM.WINDOWS_CE_GUI;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION = IMAGE_SUBSYSTEM.EFI_APPLICATION;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = IMAGE_SUBSYSTEM.EFI_BOOT_SERVICE_DRIVER;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = IMAGE_SUBSYSTEM.EFI_RUNTIME_DRIVER;
pub const IMAGE_SUBSYSTEM_EFI_ROM = IMAGE_SUBSYSTEM.EFI_ROM;
pub const IMAGE_SUBSYSTEM_XBOX = IMAGE_SUBSYSTEM.XBOX;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = IMAGE_SUBSYSTEM.WINDOWS_BOOT_APPLICATION;
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG = IMAGE_SUBSYSTEM.XBOX_CODE_CATALOG;

pub const IMAGE_DLL_CHARACTERISTICS = enum(u16) {
    HIGH_ENTROPY_VA = 32,
    DYNAMIC_BASE = 64,
    FORCE_INTEGRITY = 128,
    NX_COMPAT = 256,
    NO_ISOLATION = 512,
    NO_SEH = 1024,
    NO_BIND = 2048,
    APPCONTAINER = 4096,
    WDM_DRIVER = 8192,
    GUARD_CF = 16384,
    TERMINAL_SERVER_AWARE = 32768,
    EX_CET_COMPAT = 1,
    EX_CET_COMPAT_STRICT_MODE = 2,
    EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE = 4,
    EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC = 8,
    EX_CET_RESERVED_1 = 16,
    // EX_CET_RESERVED_2 = 32, this enum value conflicts with HIGH_ENTROPY_VA
    _,
    pub fn initFlags(o: struct {
        HIGH_ENTROPY_VA: u1 = 0,
        DYNAMIC_BASE: u1 = 0,
        FORCE_INTEGRITY: u1 = 0,
        NX_COMPAT: u1 = 0,
        NO_ISOLATION: u1 = 0,
        NO_SEH: u1 = 0,
        NO_BIND: u1 = 0,
        APPCONTAINER: u1 = 0,
        WDM_DRIVER: u1 = 0,
        GUARD_CF: u1 = 0,
        TERMINAL_SERVER_AWARE: u1 = 0,
        EX_CET_COMPAT: u1 = 0,
        EX_CET_COMPAT_STRICT_MODE: u1 = 0,
        EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE: u1 = 0,
        EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC: u1 = 0,
        EX_CET_RESERVED_1: u1 = 0,
    }) IMAGE_DLL_CHARACTERISTICS {
        return @as(IMAGE_DLL_CHARACTERISTICS, @enumFromInt((if (o.HIGH_ENTROPY_VA == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA) else 0) | (if (o.DYNAMIC_BASE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.DYNAMIC_BASE) else 0) | (if (o.FORCE_INTEGRITY == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.FORCE_INTEGRITY) else 0) | (if (o.NX_COMPAT == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NX_COMPAT) else 0) | (if (o.NO_ISOLATION == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NO_ISOLATION) else 0) | (if (o.NO_SEH == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NO_SEH) else 0) | (if (o.NO_BIND == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NO_BIND) else 0) | (if (o.APPCONTAINER == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.APPCONTAINER) else 0) | (if (o.WDM_DRIVER == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.WDM_DRIVER) else 0) | (if (o.GUARD_CF == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.GUARD_CF) else 0) | (if (o.TERMINAL_SERVER_AWARE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.TERMINAL_SERVER_AWARE) else 0) | (if (o.EX_CET_COMPAT == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT) else 0) | (if (o.EX_CET_COMPAT_STRICT_MODE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT_STRICT_MODE) else 0) | (if (o.EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE) else 0) | (if (o.EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC) else 0) | (if (o.EX_CET_RESERVED_1 == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_RESERVED_1) else 0)));
    }
};
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = IMAGE_DLL_CHARACTERISTICS.DYNAMIC_BASE;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = IMAGE_DLL_CHARACTERISTICS.FORCE_INTEGRITY;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT = IMAGE_DLL_CHARACTERISTICS.NX_COMPAT;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = IMAGE_DLL_CHARACTERISTICS.NO_ISOLATION;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH = IMAGE_DLL_CHARACTERISTICS.NO_SEH;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND = IMAGE_DLL_CHARACTERISTICS.NO_BIND;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER = IMAGE_DLL_CHARACTERISTICS.APPCONTAINER;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = IMAGE_DLL_CHARACTERISTICS.WDM_DRIVER;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF = IMAGE_DLL_CHARACTERISTICS.GUARD_CF;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = IMAGE_DLL_CHARACTERISTICS.TERMINAL_SERVER_AWARE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT = IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT_STRICT_MODE = IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT_STRICT_MODE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE = IMAGE_DLL_CHARACTERISTICS.EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC = IMAGE_DLL_CHARACTERISTICS.EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_1 = IMAGE_DLL_CHARACTERISTICS.EX_CET_RESERVED_1;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_2 = IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA;

pub const IMAGE_OPTIONAL_HEADER_MAGIC = enum(u16) {
    NT_OPTIONAL_HDR_MAGIC = 523,
    NT_OPTIONAL_HDR32_MAGIC = 267,
    // NT_OPTIONAL_HDR64_MAGIC = 523, this enum value conflicts with NT_OPTIONAL_HDR_MAGIC
    ROM_OPTIONAL_HDR_MAGIC = 263,
};
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR_MAGIC;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR32_MAGIC;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR_MAGIC;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.ROM_OPTIONAL_HDR_MAGIC;

pub const BUGCHECK_ERROR = enum(u32) {
    HARDWARE_PROFILE_UNDOCKED_STRING = 1073807361,
    HARDWARE_PROFILE_DOCKED_STRING = 1073807362,
    HARDWARE_PROFILE_UNKNOWN_STRING = 1073807363,
    WINDOWS_NT_BANNER = 1073741950,
    WINDOWS_NT_CSD_STRING = 1073741959,
    WINDOWS_NT_INFO_STRING = 1073741960,
    WINDOWS_NT_MP_STRING = 1073741961,
    THREAD_TERMINATE_HELD_MUTEX = 1073741962,
    WINDOWS_NT_INFO_STRING_PLURAL = 1073741981,
    WINDOWS_NT_RC_STRING = 1073741982,
    APC_INDEX_MISMATCH = 1,
    DEVICE_QUEUE_NOT_BUSY = 2,
    INVALID_AFFINITY_SET = 3,
    INVALID_DATA_ACCESS_TRAP = 4,
    INVALID_PROCESS_ATTACH_ATTEMPT = 5,
    INVALID_PROCESS_DETACH_ATTEMPT = 6,
    INVALID_SOFTWARE_INTERRUPT = 7,
    IRQL_NOT_DISPATCH_LEVEL = 8,
    IRQL_NOT_GREATER_OR_EQUAL = 9,
    IRQL_NOT_LESS_OR_EQUAL = 10,
    NO_EXCEPTION_HANDLING_SUPPORT = 11,
    MAXIMUM_WAIT_OBJECTS_EXCEEDED = 12,
    MUTEX_LEVEL_NUMBER_VIOLATION = 13,
    NO_USER_MODE_CONTEXT = 14,
    SPIN_LOCK_ALREADY_OWNED = 15,
    SPIN_LOCK_NOT_OWNED = 16,
    THREAD_NOT_MUTEX_OWNER = 17,
    TRAP_CAUSE_UNKNOWN = 18,
    EMPTY_THREAD_REAPER_LIST = 19,
    CREATE_DELETE_LOCK_NOT_LOCKED = 20,
    LAST_CHANCE_CALLED_FROM_KMODE = 21,
    CID_HANDLE_CREATION = 22,
    CID_HANDLE_DELETION = 23,
    REFERENCE_BY_POINTER = 24,
    BAD_POOL_HEADER = 25,
    MEMORY_MANAGEMENT = 26,
    PFN_SHARE_COUNT = 27,
    PFN_REFERENCE_COUNT = 28,
    NO_SPIN_LOCK_AVAILABLE = 29,
    KMODE_EXCEPTION_NOT_HANDLED = 30,
    SHARED_RESOURCE_CONV_ERROR = 31,
    KERNEL_APC_PENDING_DURING_EXIT = 32,
    QUOTA_UNDERFLOW = 33,
    FILE_SYSTEM = 34,
    FAT_FILE_SYSTEM = 35,
    NTFS_FILE_SYSTEM = 36,
    NPFS_FILE_SYSTEM = 37,
    CDFS_FILE_SYSTEM = 38,
    RDR_FILE_SYSTEM = 39,
    CORRUPT_ACCESS_TOKEN = 40,
    SECURITY_SYSTEM = 41,
    INCONSISTENT_IRP = 42,
    PANIC_STACK_SWITCH = 43,
    PORT_DRIVER_INTERNAL = 44,
    SCSI_DISK_DRIVER_INTERNAL = 45,
    DATA_BUS_ERROR = 46,
    INSTRUCTION_BUS_ERROR = 47,
    SET_OF_INVALID_CONTEXT = 48,
    PHASE0_INITIALIZATION_FAILED = 49,
    PHASE1_INITIALIZATION_FAILED = 50,
    UNEXPECTED_INITIALIZATION_CALL = 51,
    CACHE_MANAGER = 52,
    NO_MORE_IRP_STACK_LOCATIONS = 53,
    DEVICE_REFERENCE_COUNT_NOT_ZERO = 54,
    FLOPPY_INTERNAL_ERROR = 55,
    SERIAL_DRIVER_INTERNAL = 56,
    SYSTEM_EXIT_OWNED_MUTEX = 57,
    SYSTEM_UNWIND_PREVIOUS_USER = 58,
    SYSTEM_SERVICE_EXCEPTION = 59,
    INTERRUPT_UNWIND_ATTEMPTED = 60,
    INTERRUPT_EXCEPTION_NOT_HANDLED = 61,
    MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED = 62,
    NO_MORE_SYSTEM_PTES = 63,
    TARGET_MDL_TOO_SMALL = 64,
    MUST_SUCCEED_POOL_EMPTY = 65,
    ATDISK_DRIVER_INTERNAL = 66,
    NO_SUCH_PARTITION = 67,
    MULTIPLE_IRP_COMPLETE_REQUESTS = 68,
    INSUFFICIENT_SYSTEM_MAP_REGS = 69,
    DEREF_UNKNOWN_LOGON_SESSION = 70,
    REF_UNKNOWN_LOGON_SESSION = 71,
    CANCEL_STATE_IN_COMPLETED_IRP = 72,
    PAGE_FAULT_WITH_INTERRUPTS_OFF = 73,
    IRQL_GT_ZERO_AT_SYSTEM_SERVICE = 74,
    STREAMS_INTERNAL_ERROR = 75,
    FATAL_UNHANDLED_HARD_ERROR = 76,
    NO_PAGES_AVAILABLE = 77,
    PFN_LIST_CORRUPT = 78,
    NDIS_INTERNAL_ERROR = 79,
    PAGE_FAULT_IN_NONPAGED_AREA = 80,
    PAGE_FAULT_IN_NONPAGED_AREA_M = 268435536,
    REGISTRY_ERROR = 81,
    MAILSLOT_FILE_SYSTEM = 82,
    NO_BOOT_DEVICE = 83,
    LM_SERVER_INTERNAL_ERROR = 84,
    DATA_COHERENCY_EXCEPTION = 85,
    INSTRUCTION_COHERENCY_EXCEPTION = 86,
    XNS_INTERNAL_ERROR = 87,
    VOLMGRX_INTERNAL_ERROR = 88,
    PINBALL_FILE_SYSTEM = 89,
    CRITICAL_SERVICE_FAILED = 90,
    SET_ENV_VAR_FAILED = 91,
    HAL_INITIALIZATION_FAILED = 92,
    UNSUPPORTED_PROCESSOR = 93,
    OBJECT_INITIALIZATION_FAILED = 94,
    SECURITY_INITIALIZATION_FAILED = 95,
    PROCESS_INITIALIZATION_FAILED = 96,
    HAL1_INITIALIZATION_FAILED = 97,
    OBJECT1_INITIALIZATION_FAILED = 98,
    SECURITY1_INITIALIZATION_FAILED = 99,
    SYMBOLIC_INITIALIZATION_FAILED = 100,
    MEMORY1_INITIALIZATION_FAILED = 101,
    CACHE_INITIALIZATION_FAILED = 102,
    CONFIG_INITIALIZATION_FAILED = 103,
    FILE_INITIALIZATION_FAILED = 104,
    IO1_INITIALIZATION_FAILED = 105,
    LPC_INITIALIZATION_FAILED = 106,
    PROCESS1_INITIALIZATION_FAILED = 107,
    REFMON_INITIALIZATION_FAILED = 108,
    SESSION1_INITIALIZATION_FAILED = 109,
    BOOTPROC_INITIALIZATION_FAILED = 110,
    VSL_INITIALIZATION_FAILED = 111,
    SOFT_RESTART_FATAL_ERROR = 112,
    ASSIGN_DRIVE_LETTERS_FAILED = 114,
    CONFIG_LIST_FAILED = 115,
    BAD_SYSTEM_CONFIG_INFO = 116,
    CANNOT_WRITE_CONFIGURATION = 117,
    PROCESS_HAS_LOCKED_PAGES = 118,
    KERNEL_STACK_INPAGE_ERROR = 119,
    PHASE0_EXCEPTION = 120,
    MISMATCHED_HAL = 121,
    KERNEL_DATA_INPAGE_ERROR = 122,
    INACCESSIBLE_BOOT_DEVICE = 123,
    BUGCODE_NDIS_DRIVER = 124,
    INSTALL_MORE_MEMORY = 125,
    SYSTEM_THREAD_EXCEPTION_NOT_HANDLED = 126,
    SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M = 268435582,
    UNEXPECTED_KERNEL_MODE_TRAP = 127,
    UNEXPECTED_KERNEL_MODE_TRAP_M = 268435583,
    NMI_HARDWARE_FAILURE = 128,
    SPIN_LOCK_INIT_FAILURE = 129,
    DFS_FILE_SYSTEM = 130,
    OFS_FILE_SYSTEM = 131,
    RECOM_DRIVER = 132,
    SETUP_FAILURE = 133,
    AUDIT_FAILURE = 134,
    MBR_CHECKSUM_MISMATCH = 139,
    KERNEL_MODE_EXCEPTION_NOT_HANDLED = 142,
    KERNEL_MODE_EXCEPTION_NOT_HANDLED_M = 268435598,
    PP0_INITIALIZATION_FAILED = 143,
    PP1_INITIALIZATION_FAILED = 144,
    WIN32K_INIT_OR_RIT_FAILURE = 145,
    UP_DRIVER_ON_MP_SYSTEM = 146,
    INVALID_KERNEL_HANDLE = 147,
    KERNEL_STACK_LOCKED_AT_EXIT = 148,
    PNP_INTERNAL_ERROR = 149,
    INVALID_WORK_QUEUE_ITEM = 150,
    BOUND_IMAGE_UNSUPPORTED = 151,
    END_OF_NT_EVALUATION_PERIOD = 152,
    INVALID_REGION_OR_SEGMENT = 153,
    SYSTEM_LICENSE_VIOLATION = 154,
    UDFS_FILE_SYSTEM = 155,
    MACHINE_CHECK_EXCEPTION = 156,
    USER_MODE_HEALTH_MONITOR = 158,
    DRIVER_POWER_STATE_FAILURE = 159,
    INTERNAL_POWER_ERROR = 160,
    PCI_BUS_DRIVER_INTERNAL = 161,
    MEMORY_IMAGE_CORRUPT = 162,
    ACPI_DRIVER_INTERNAL = 163,
    CNSS_FILE_SYSTEM_FILTER = 164,
    ACPI_BIOS_ERROR = 165,
    FP_EMULATION_ERROR = 166,
    BAD_EXHANDLE = 167,
    BOOTING_IN_SAFEMODE_MINIMAL = 168,
    BOOTING_IN_SAFEMODE_NETWORK = 169,
    BOOTING_IN_SAFEMODE_DSREPAIR = 170,
    SESSION_HAS_VALID_POOL_ON_EXIT = 171,
    HAL_MEMORY_ALLOCATION = 172,
    VIDEO_DRIVER_DEBUG_REPORT_REQUEST = 1073741997,
    BGI_DETECTED_VIOLATION = 177,
    VIDEO_DRIVER_INIT_FAILURE = 180,
    BOOTLOG_LOADED = 181,
    BOOTLOG_NOT_LOADED = 182,
    BOOTLOG_ENABLED = 183,
    ATTEMPTED_SWITCH_FROM_DPC = 184,
    CHIPSET_DETECTED_ERROR = 185,
    SESSION_HAS_VALID_VIEWS_ON_EXIT = 186,
    NETWORK_BOOT_INITIALIZATION_FAILED = 187,
    NETWORK_BOOT_DUPLICATE_ADDRESS = 188,
    INVALID_HIBERNATED_STATE = 189,
    ATTEMPTED_WRITE_TO_READONLY_MEMORY = 190,
    MUTEX_ALREADY_OWNED = 191,
    PCI_CONFIG_SPACE_ACCESS_FAILURE = 192,
    SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION = 193,
    BAD_POOL_CALLER = 194,
    SYSTEM_IMAGE_BAD_SIGNATURE = 195,
    DRIVER_VERIFIER_DETECTED_VIOLATION = 196,
    DRIVER_CORRUPTED_EXPOOL = 197,
    DRIVER_CAUGHT_MODIFYING_FREED_POOL = 198,
    TIMER_OR_DPC_INVALID = 199,
    IRQL_UNEXPECTED_VALUE = 200,
    DRIVER_VERIFIER_IOMANAGER_VIOLATION = 201,
    PNP_DETECTED_FATAL_ERROR = 202,
    DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS = 203,
    PAGE_FAULT_IN_FREED_SPECIAL_POOL = 204,
    PAGE_FAULT_BEYOND_END_OF_ALLOCATION = 205,
    DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS = 206,
    TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE = 207,
    DRIVER_CORRUPTED_MMPOOL = 208,
    DRIVER_IRQL_NOT_LESS_OR_EQUAL = 209,
    BUGCODE_ID_DRIVER = 210,
    DRIVER_PORTION_MUST_BE_NONPAGED = 211,
    SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD = 212,
    DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL = 213,
    DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION = 214,
    DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M = 268435670,
    DRIVER_UNMAPPING_INVALID_VIEW = 215,
    DRIVER_USED_EXCESSIVE_PTES = 216,
    LOCKED_PAGES_TRACKER_CORRUPTION = 217,
    SYSTEM_PTE_MISUSE = 218,
    DRIVER_CORRUPTED_SYSPTES = 219,
    DRIVER_INVALID_STACK_ACCESS = 220,
    POOL_CORRUPTION_IN_FILE_AREA = 222,
    IMPERSONATING_WORKER_THREAD = 223,
    ACPI_BIOS_FATAL_ERROR = 224,
    WORKER_THREAD_RETURNED_AT_BAD_IRQL = 225,
    MANUALLY_INITIATED_CRASH = 226,
    RESOURCE_NOT_OWNED = 227,
    WORKER_INVALID = 228,
    POWER_FAILURE_SIMULATE = 229,
    DRIVER_VERIFIER_DMA_VIOLATION = 230,
    INVALID_FLOATING_POINT_STATE = 231,
    INVALID_CANCEL_OF_FILE_OPEN = 232,
    ACTIVE_EX_WORKER_THREAD_TERMINATION = 233,
    SAVER_UNSPECIFIED = 61440,
    SAVER_BLANKSCREEN = 61442,
    SAVER_INPUT = 61443,
    SAVER_WATCHDOG = 61444,
    SAVER_STARTNOTVISIBLE = 61445,
    SAVER_NAVIGATIONMODEL = 61446,
    SAVER_OUTOFMEMORY = 61447,
    SAVER_GRAPHICS = 61448,
    SAVER_NAVSERVERTIMEOUT = 61449,
    SAVER_CHROMEPROCESSCRASH = 61450,
    SAVER_NOTIFICATIONDISMISSAL = 61451,
    SAVER_SPEECHDISMISSAL = 61452,
    SAVER_CALLDISMISSAL = 61453,
    SAVER_APPBARDISMISSAL = 61454,
    SAVER_RILADAPTATIONCRASH = 61455,
    SAVER_APPLISTUNREACHABLE = 61456,
    SAVER_REPORTNOTIFICATIONFAILURE = 61457,
    SAVER_UNEXPECTEDSHUTDOWN = 61458,
    SAVER_RPCFAILURE = 61459,
    SAVER_AUXILIARYFULLDUMP = 61460,
    SAVER_ACCOUNTPROVSVCINITFAILURE = 61461,
    SAVER_MTBFCOMMANDTIMEOUT = 789,
    SAVER_MTBFCOMMANDHANG = 61697,
    SAVER_MTBFPASSBUGCHECK = 61698,
    SAVER_MTBFIOERROR = 61699,
    SAVER_RENDERTHREADHANG = 61952,
    SAVER_RENDERMOBILEUIOOM = 61953,
    SAVER_DEVICEUPDATEUNSPECIFIED = 62208,
    SAVER_AUDIODRIVERHANG = 62464,
    SAVER_BATTERYPULLOUT = 62720,
    SAVER_MEDIACORETESTHANG = 62976,
    SAVER_RESOURCEMANAGEMENT = 63232,
    SAVER_CAPTURESERVICE = 63488,
    SAVER_WAITFORSHELLREADY = 63744,
    SAVER_NONRESPONSIVEPROCESS = 404,
    SAVER_SICKAPPLICATION = 34918,
    THREAD_STUCK_IN_DEVICE_DRIVER = 234,
    THREAD_STUCK_IN_DEVICE_DRIVER_M = 268435690,
    DIRTY_MAPPED_PAGES_CONGESTION = 235,
    SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT = 236,
    UNMOUNTABLE_BOOT_VOLUME = 237,
    CRITICAL_PROCESS_DIED = 239,
    STORAGE_MINIPORT_ERROR = 240,
    SCSI_VERIFIER_DETECTED_VIOLATION = 241,
    HARDWARE_INTERRUPT_STORM = 242,
    DISORDERLY_SHUTDOWN = 243,
    CRITICAL_OBJECT_TERMINATION = 244,
    FLTMGR_FILE_SYSTEM = 245,
    PCI_VERIFIER_DETECTED_VIOLATION = 246,
    DRIVER_OVERRAN_STACK_BUFFER = 247,
    RAMDISK_BOOT_INITIALIZATION_FAILED = 248,
    DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN = 249,
    HTTP_DRIVER_CORRUPTED = 250,
    RECURSIVE_MACHINE_CHECK = 251,
    ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY = 252,
    DIRTY_NOWRITE_PAGES_CONGESTION = 253,
    BUGCODE_USB_DRIVER = 254,
    BC_BLUETOOTH_VERIFIER_FAULT = 3070,
    BC_BTHMINI_VERIFIER_FAULT = 3071,
    RESERVE_QUEUE_OVERFLOW = 255,
    LOADER_BLOCK_MISMATCH = 256,
    CLOCK_WATCHDOG_TIMEOUT = 257,
    DPC_WATCHDOG_TIMEOUT = 258,
    MUP_FILE_SYSTEM = 259,
    AGP_INVALID_ACCESS = 260,
    AGP_GART_CORRUPTION = 261,
    AGP_ILLEGALLY_REPROGRAMMED = 262,
    KERNEL_EXPAND_STACK_ACTIVE = 263,
    THIRD_PARTY_FILE_SYSTEM_FAILURE = 264,
    CRITICAL_STRUCTURE_CORRUPTION = 265,
    APP_TAGGING_INITIALIZATION_FAILED = 266,
    DFSC_FILE_SYSTEM = 267,
    FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION = 268,
    WDF_VIOLATION = 269,
    VIDEO_MEMORY_MANAGEMENT_INTERNAL = 270,
    DRIVER_INVALID_CRUNTIME_PARAMETER = 272,
    RECURSIVE_NMI = 273,
    MSRPC_STATE_VIOLATION = 274,
    VIDEO_DXGKRNL_FATAL_ERROR = 275,
    VIDEO_SHADOW_DRIVER_FATAL_ERROR = 276,
    AGP_INTERNAL = 277,
    VIDEO_TDR_FAILURE = 278,
    VIDEO_TDR_TIMEOUT_DETECTED = 279,
    NTHV_GUEST_ERROR = 280,
    VIDEO_SCHEDULER_INTERNAL_ERROR = 281,
    EM_INITIALIZATION_ERROR = 282,
    DRIVER_RETURNED_HOLDING_CANCEL_LOCK = 283,
    ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE = 284,
    EVENT_TRACING_FATAL_ERROR = 285,
    TOO_MANY_RECURSIVE_FAULTS = 286,
    INVALID_DRIVER_HANDLE = 287,
    BITLOCKER_FATAL_ERROR = 288,
    DRIVER_VIOLATION = 289,
    WHEA_INTERNAL_ERROR = 290,
    CRYPTO_SELF_TEST_FAILURE = 291,
    WHEA_UNCORRECTABLE_ERROR = 292,
    NMR_INVALID_STATE = 293,
    NETIO_INVALID_POOL_CALLER = 294,
    PAGE_NOT_ZERO = 295,
    WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY = 296,
    WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY = 297,
    MUI_NO_VALID_SYSTEM_LANGUAGE = 298,
    FAULTY_HARDWARE_CORRUPTED_PAGE = 299,
    EXFAT_FILE_SYSTEM = 300,
    VOLSNAP_OVERLAPPED_TABLE_ACCESS = 301,
    INVALID_MDL_RANGE = 302,
    VHD_BOOT_INITIALIZATION_FAILED = 303,
    DYNAMIC_ADD_PROCESSOR_MISMATCH = 304,
    INVALID_EXTENDED_PROCESSOR_STATE = 305,
    RESOURCE_OWNER_POINTER_INVALID = 306,
    DPC_WATCHDOG_VIOLATION = 307,
    DRIVE_EXTENDER = 308,
    REGISTRY_FILTER_DRIVER_EXCEPTION = 309,
    VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE = 310,
    WIN32K_HANDLE_MANAGER = 311,
    GPIO_CONTROLLER_DRIVER_ERROR = 312,
    KERNEL_SECURITY_CHECK_FAILURE = 313,
    KERNEL_MODE_HEAP_CORRUPTION = 314,
    PASSIVE_INTERRUPT_ERROR = 315,
    INVALID_IO_BOOST_STATE = 316,
    CRITICAL_INITIALIZATION_FAILURE = 317,
    ERRATA_WORKAROUND_UNSUCCESSFUL = 318,
    REGISTRY_CALLBACK_DRIVER_EXCEPTION = 319,
    STORAGE_DEVICE_ABNORMALITY_DETECTED = 320,
    VIDEO_ENGINE_TIMEOUT_DETECTED = 321,
    VIDEO_TDR_APPLICATION_BLOCKED = 322,
    PROCESSOR_DRIVER_INTERNAL = 323,
    BUGCODE_USB3_DRIVER = 324,
    SECURE_BOOT_VIOLATION = 325,
    NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED = 326,
    ABNORMAL_RESET_DETECTED = 327,
    IO_OBJECT_INVALID = 328,
    REFS_FILE_SYSTEM = 329,
    KERNEL_WMI_INTERNAL = 330,
    SOC_SUBSYSTEM_FAILURE = 331,
    FATAL_ABNORMAL_RESET_ERROR = 332,
    EXCEPTION_SCOPE_INVALID = 333,
    SOC_CRITICAL_DEVICE_REMOVED = 334,
    PDC_WATCHDOG_TIMEOUT = 335,
    TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK = 336,
    UNSUPPORTED_INSTRUCTION_MODE = 337,
    INVALID_PUSH_LOCK_FLAGS = 338,
    KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION = 339,
    UNEXPECTED_STORE_EXCEPTION = 340,
    OS_DATA_TAMPERING = 341,
    WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP = 342,
    KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION = 343,
    ILLEGAL_IOMMU_PAGE_FAULT = 344,
    HAL_ILLEGAL_IOMMU_PAGE_FAULT = 345,
    SDBUS_INTERNAL_ERROR = 346,
    WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE = 347,
    PDC_WATCHDOG_TIMEOUT_LIVEDUMP = 348,
    SOC_SUBSYSTEM_FAILURE_LIVEDUMP = 349,
    BUGCODE_NDIS_DRIVER_LIVE_DUMP = 350,
    CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP = 351,
    WIN32K_ATOMIC_CHECK_FAILURE = 352,
    LIVE_SYSTEM_DUMP = 353,
    KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE = 354,
    WORKER_THREAD_TEST_CONDITION = 355,
    WIN32K_CRITICAL_FAILURE = 356,
    CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP = 357,
    CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP = 358,
    CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP = 359,
    CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP = 360,
    CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP = 361,
    CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP = 362,
    CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP = 363,
    INVALID_RUNDOWN_PROTECTION_FLAGS = 364,
    INVALID_SLOT_ALLOCATOR_FLAGS = 365,
    ERESOURCE_INVALID_RELEASE = 366,
    CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP = 367,
    CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG = 368,
    CRYPTO_LIBRARY_INTERNAL_ERROR = 369,
    COREMSGCALL_INTERNAL_ERROR = 371,
    COREMSG_INTERNAL_ERROR = 372,
    PREVIOUS_FATAL_ABNORMAL_RESET_ERROR = 373,
    ELAM_DRIVER_DETECTED_FATAL_ERROR = 376,
    CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP = 377,
    PROFILER_CONFIGURATION_ILLEGAL = 379,
    PDC_LOCK_WATCHDOG_LIVEDUMP = 380,
    PDC_UNEXPECTED_REVOCATION_LIVEDUMP = 381,
    MICROCODE_REVISION_MISMATCH = 382,
    HYPERGUARD_INITIALIZATION_FAILURE = 383,
    WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT = 384,
    WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT = 385,
    WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT = 386,
    WVR_LIVEDUMP_APP_IO_TIMEOUT = 387,
    WVR_LIVEDUMP_MANUALLY_INITIATED = 388,
    WVR_LIVEDUMP_STATE_FAILURE = 389,
    WVR_LIVEDUMP_CRITICAL_ERROR = 390,
    VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD = 391,
    CLUSTER_CSVFS_LIVEDUMP = 392,
    BAD_OBJECT_HEADER = 393,
    SILO_CORRUPT = 394,
    SECURE_KERNEL_ERROR = 395,
    HYPERGUARD_VIOLATION = 396,
    SECURE_FAULT_UNHANDLED = 397,
    KERNEL_PARTITION_REFERENCE_VIOLATION = 398,
    SYNTHETIC_EXCEPTION_UNHANDLED = 399,
    WIN32K_CRITICAL_FAILURE_LIVEDUMP = 400,
    PF_DETECTED_CORRUPTION = 401,
    KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL = 402,
    VIDEO_DXGKRNL_LIVEDUMP = 403,
    KERNEL_STORAGE_SLOT_IN_USE = 409,
    SMB_SERVER_LIVEDUMP = 405,
    LOADER_ROLLBACK_DETECTED = 406,
    WIN32K_SECURITY_FAILURE = 407,
    UFX_LIVEDUMP = 408,
    WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO = 410,
    TTM_FATAL_ERROR = 411,
    WIN32K_POWER_WATCHDOG_TIMEOUT = 412,
    CLUSTER_SVHDX_LIVEDUMP = 413,
    BUGCODE_NETADAPTER_DRIVER = 414,
    PDC_PRIVILEGE_CHECK_LIVEDUMP = 415,
    TTM_WATCHDOG_TIMEOUT = 416,
    WIN32K_CALLOUT_WATCHDOG_LIVEDUMP = 417,
    WIN32K_CALLOUT_WATCHDOG_BUGCHECK = 418,
    CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP = 419,
    DRIPS_SW_HW_DIVERGENCE_LIVEDUMP = 420,
    USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP = 421,
    BLUETOOTH_ERROR_RECOVERY_LIVEDUMP = 422,
    SMB_REDIRECTOR_LIVEDUMP = 423,
    VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP = 424,
    DIRECTED_FX_TRANSITION_LIVEDUMP = 425,
    EXCEPTION_ON_INVALID_STACK = 426,
    UNWIND_ON_INVALID_STACK = 427,
    VIDEO_MINIPORT_FAILED_LIVEDUMP = 432,
    VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP = 440,
    DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP = 452,
    IO_THREADPOOL_DEADLOCK_LIVEDUMP = 453,
    FAST_ERESOURCE_PRECONDITION_VIOLATION = 454,
    STORE_DATA_STRUCTURE_CORRUPTION = 455,
    MANUALLY_INITIATED_POWER_BUTTON_HOLD = 456,
    USER_MODE_HEALTH_MONITOR_LIVEDUMP = 457,
    SYNTHETIC_WATCHDOG_TIMEOUT = 458,
    INVALID_SILO_DETACH = 459,
    EXRESOURCE_TIMEOUT_LIVEDUMP = 460,
    INVALID_CALLBACK_STACK_ADDRESS = 461,
    INVALID_KERNEL_STACK_ADDRESS = 462,
    HARDWARE_WATCHDOG_TIMEOUT = 463,
    ACPI_FIRMWARE_WATCHDOG_TIMEOUT = 464,
    TELEMETRY_ASSERTS_LIVEDUMP = 465,
    WORKER_THREAD_INVALID_STATE = 466,
    WFP_INVALID_OPERATION = 467,
    UCMUCSI_LIVEDUMP = 468,
    DRIVER_PNP_WATCHDOG = 469,
    WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS = 470,
    EFS_FATAL_ERROR = 471,
    UCMUCSI_FAILURE = 472,
    HAL_IOMMU_INTERNAL_ERROR = 473,
    HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR = 474,
    IPI_WATCHDOG_TIMEOUT = 475,
    DMA_COMMON_BUFFER_VECTOR_ERROR = 476,
    BUGCODE_MBBADAPTER_DRIVER = 477,
    BUGCODE_WIFIADAPTER_DRIVER = 478,
    PROCESSOR_START_TIMEOUT = 479,
    INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION = 480,
    DEVICE_DIAGNOSTIC_LOG_LIVEDUMP = 481,
    AZURE_DEVICE_FW_DUMP = 482,
    BREAKAWAY_CABLE_TRANSITION = 483,
    VIDEO_DXGKRNL_SYSMM_FATAL_ERROR = 484,
    DRIVER_VERIFIER_TRACKING_LIVE_DUMP = 485,
    CRASHDUMP_WATCHDOG_TIMEOUT = 486,
    REGISTRY_LIVE_DUMP = 487,
    INVALID_THREAD_AFFINITY_STATE = 488,
    ILLEGAL_ATS_INITIALIZATION = 489,
    SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION = 490,
    DAM_WATCHDOG_TIMEOUT = 491,
    XBOX_VMCTRL_CS_TIMEOUT = 854,
    XBOX_CORRUPTED_IMAGE = 855,
    XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW = 856,
    XBOX_CORRUPTED_IMAGE_BASE = 857,
    XBOX_XDS_WATCHDOG_TIMEOUT = 858,
    XBOX_SHUTDOWN_WATCHDOG_TIMEOUT = 859,
    XBOX_360_SYSTEM_CRASH = 864,
    XBOX_360_SYSTEM_CRASH_RESERVED = 1056,
    XBOX_SECURITY_FAILUE = 1057,
    KERNEL_CFG_INIT_FAILURE = 1058,
    MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP = 4552,
    HYPERVISOR_ERROR = 131073,
    WINLOGON_FATAL_ERROR = 3221226010,
    MANUALLY_INITIATED_CRASH1 = 3735936685,
    BUGCHECK_CONTEXT_MODIFIER = 2147483648,
};
pub const HARDWARE_PROFILE_UNDOCKED_STRING = BUGCHECK_ERROR.HARDWARE_PROFILE_UNDOCKED_STRING;
pub const HARDWARE_PROFILE_DOCKED_STRING = BUGCHECK_ERROR.HARDWARE_PROFILE_DOCKED_STRING;
pub const HARDWARE_PROFILE_UNKNOWN_STRING = BUGCHECK_ERROR.HARDWARE_PROFILE_UNKNOWN_STRING;
pub const WINDOWS_NT_BANNER = BUGCHECK_ERROR.WINDOWS_NT_BANNER;
pub const WINDOWS_NT_CSD_STRING = BUGCHECK_ERROR.WINDOWS_NT_CSD_STRING;
pub const WINDOWS_NT_INFO_STRING = BUGCHECK_ERROR.WINDOWS_NT_INFO_STRING;
pub const WINDOWS_NT_MP_STRING = BUGCHECK_ERROR.WINDOWS_NT_MP_STRING;
pub const THREAD_TERMINATE_HELD_MUTEX = BUGCHECK_ERROR.THREAD_TERMINATE_HELD_MUTEX;
pub const WINDOWS_NT_INFO_STRING_PLURAL = BUGCHECK_ERROR.WINDOWS_NT_INFO_STRING_PLURAL;
pub const WINDOWS_NT_RC_STRING = BUGCHECK_ERROR.WINDOWS_NT_RC_STRING;
pub const APC_INDEX_MISMATCH = BUGCHECK_ERROR.APC_INDEX_MISMATCH;
pub const DEVICE_QUEUE_NOT_BUSY = BUGCHECK_ERROR.DEVICE_QUEUE_NOT_BUSY;
pub const INVALID_AFFINITY_SET = BUGCHECK_ERROR.INVALID_AFFINITY_SET;
pub const INVALID_DATA_ACCESS_TRAP = BUGCHECK_ERROR.INVALID_DATA_ACCESS_TRAP;
pub const INVALID_PROCESS_ATTACH_ATTEMPT = BUGCHECK_ERROR.INVALID_PROCESS_ATTACH_ATTEMPT;
pub const INVALID_PROCESS_DETACH_ATTEMPT = BUGCHECK_ERROR.INVALID_PROCESS_DETACH_ATTEMPT;
pub const INVALID_SOFTWARE_INTERRUPT = BUGCHECK_ERROR.INVALID_SOFTWARE_INTERRUPT;
pub const IRQL_NOT_DISPATCH_LEVEL = BUGCHECK_ERROR.IRQL_NOT_DISPATCH_LEVEL;
pub const IRQL_NOT_GREATER_OR_EQUAL = BUGCHECK_ERROR.IRQL_NOT_GREATER_OR_EQUAL;
pub const IRQL_NOT_LESS_OR_EQUAL = BUGCHECK_ERROR.IRQL_NOT_LESS_OR_EQUAL;
pub const NO_EXCEPTION_HANDLING_SUPPORT = BUGCHECK_ERROR.NO_EXCEPTION_HANDLING_SUPPORT;
pub const MAXIMUM_WAIT_OBJECTS_EXCEEDED = BUGCHECK_ERROR.MAXIMUM_WAIT_OBJECTS_EXCEEDED;
pub const MUTEX_LEVEL_NUMBER_VIOLATION = BUGCHECK_ERROR.MUTEX_LEVEL_NUMBER_VIOLATION;
pub const NO_USER_MODE_CONTEXT = BUGCHECK_ERROR.NO_USER_MODE_CONTEXT;
pub const SPIN_LOCK_ALREADY_OWNED = BUGCHECK_ERROR.SPIN_LOCK_ALREADY_OWNED;
pub const SPIN_LOCK_NOT_OWNED = BUGCHECK_ERROR.SPIN_LOCK_NOT_OWNED;
pub const THREAD_NOT_MUTEX_OWNER = BUGCHECK_ERROR.THREAD_NOT_MUTEX_OWNER;
pub const TRAP_CAUSE_UNKNOWN = BUGCHECK_ERROR.TRAP_CAUSE_UNKNOWN;
pub const EMPTY_THREAD_REAPER_LIST = BUGCHECK_ERROR.EMPTY_THREAD_REAPER_LIST;
pub const CREATE_DELETE_LOCK_NOT_LOCKED = BUGCHECK_ERROR.CREATE_DELETE_LOCK_NOT_LOCKED;
pub const LAST_CHANCE_CALLED_FROM_KMODE = BUGCHECK_ERROR.LAST_CHANCE_CALLED_FROM_KMODE;
pub const CID_HANDLE_CREATION = BUGCHECK_ERROR.CID_HANDLE_CREATION;
pub const CID_HANDLE_DELETION = BUGCHECK_ERROR.CID_HANDLE_DELETION;
pub const REFERENCE_BY_POINTER = BUGCHECK_ERROR.REFERENCE_BY_POINTER;
pub const BAD_POOL_HEADER = BUGCHECK_ERROR.BAD_POOL_HEADER;
pub const MEMORY_MANAGEMENT = BUGCHECK_ERROR.MEMORY_MANAGEMENT;
pub const PFN_SHARE_COUNT = BUGCHECK_ERROR.PFN_SHARE_COUNT;
pub const PFN_REFERENCE_COUNT = BUGCHECK_ERROR.PFN_REFERENCE_COUNT;
pub const NO_SPIN_LOCK_AVAILABLE = BUGCHECK_ERROR.NO_SPIN_LOCK_AVAILABLE;
pub const KMODE_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.KMODE_EXCEPTION_NOT_HANDLED;
pub const SHARED_RESOURCE_CONV_ERROR = BUGCHECK_ERROR.SHARED_RESOURCE_CONV_ERROR;
pub const KERNEL_APC_PENDING_DURING_EXIT = BUGCHECK_ERROR.KERNEL_APC_PENDING_DURING_EXIT;
pub const QUOTA_UNDERFLOW = BUGCHECK_ERROR.QUOTA_UNDERFLOW;
pub const FILE_SYSTEM = BUGCHECK_ERROR.FILE_SYSTEM;
pub const FAT_FILE_SYSTEM = BUGCHECK_ERROR.FAT_FILE_SYSTEM;
pub const NTFS_FILE_SYSTEM = BUGCHECK_ERROR.NTFS_FILE_SYSTEM;
pub const NPFS_FILE_SYSTEM = BUGCHECK_ERROR.NPFS_FILE_SYSTEM;
pub const CDFS_FILE_SYSTEM = BUGCHECK_ERROR.CDFS_FILE_SYSTEM;
pub const RDR_FILE_SYSTEM = BUGCHECK_ERROR.RDR_FILE_SYSTEM;
pub const CORRUPT_ACCESS_TOKEN = BUGCHECK_ERROR.CORRUPT_ACCESS_TOKEN;
pub const SECURITY_SYSTEM = BUGCHECK_ERROR.SECURITY_SYSTEM;
pub const INCONSISTENT_IRP = BUGCHECK_ERROR.INCONSISTENT_IRP;
pub const PANIC_STACK_SWITCH = BUGCHECK_ERROR.PANIC_STACK_SWITCH;
pub const PORT_DRIVER_INTERNAL = BUGCHECK_ERROR.PORT_DRIVER_INTERNAL;
pub const SCSI_DISK_DRIVER_INTERNAL = BUGCHECK_ERROR.SCSI_DISK_DRIVER_INTERNAL;
pub const DATA_BUS_ERROR = BUGCHECK_ERROR.DATA_BUS_ERROR;
pub const INSTRUCTION_BUS_ERROR = BUGCHECK_ERROR.INSTRUCTION_BUS_ERROR;
pub const SET_OF_INVALID_CONTEXT = BUGCHECK_ERROR.SET_OF_INVALID_CONTEXT;
pub const PHASE0_INITIALIZATION_FAILED = BUGCHECK_ERROR.PHASE0_INITIALIZATION_FAILED;
pub const PHASE1_INITIALIZATION_FAILED = BUGCHECK_ERROR.PHASE1_INITIALIZATION_FAILED;
pub const UNEXPECTED_INITIALIZATION_CALL = BUGCHECK_ERROR.UNEXPECTED_INITIALIZATION_CALL;
pub const CACHE_MANAGER = BUGCHECK_ERROR.CACHE_MANAGER;
pub const NO_MORE_IRP_STACK_LOCATIONS = BUGCHECK_ERROR.NO_MORE_IRP_STACK_LOCATIONS;
pub const DEVICE_REFERENCE_COUNT_NOT_ZERO = BUGCHECK_ERROR.DEVICE_REFERENCE_COUNT_NOT_ZERO;
pub const FLOPPY_INTERNAL_ERROR = BUGCHECK_ERROR.FLOPPY_INTERNAL_ERROR;
pub const SERIAL_DRIVER_INTERNAL = BUGCHECK_ERROR.SERIAL_DRIVER_INTERNAL;
pub const SYSTEM_EXIT_OWNED_MUTEX = BUGCHECK_ERROR.SYSTEM_EXIT_OWNED_MUTEX;
pub const SYSTEM_UNWIND_PREVIOUS_USER = BUGCHECK_ERROR.SYSTEM_UNWIND_PREVIOUS_USER;
pub const SYSTEM_SERVICE_EXCEPTION = BUGCHECK_ERROR.SYSTEM_SERVICE_EXCEPTION;
pub const INTERRUPT_UNWIND_ATTEMPTED = BUGCHECK_ERROR.INTERRUPT_UNWIND_ATTEMPTED;
pub const INTERRUPT_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.INTERRUPT_EXCEPTION_NOT_HANDLED;
pub const MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED = BUGCHECK_ERROR.MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED;
pub const NO_MORE_SYSTEM_PTES = BUGCHECK_ERROR.NO_MORE_SYSTEM_PTES;
pub const TARGET_MDL_TOO_SMALL = BUGCHECK_ERROR.TARGET_MDL_TOO_SMALL;
pub const MUST_SUCCEED_POOL_EMPTY = BUGCHECK_ERROR.MUST_SUCCEED_POOL_EMPTY;
pub const ATDISK_DRIVER_INTERNAL = BUGCHECK_ERROR.ATDISK_DRIVER_INTERNAL;
pub const NO_SUCH_PARTITION = BUGCHECK_ERROR.NO_SUCH_PARTITION;
pub const MULTIPLE_IRP_COMPLETE_REQUESTS = BUGCHECK_ERROR.MULTIPLE_IRP_COMPLETE_REQUESTS;
pub const INSUFFICIENT_SYSTEM_MAP_REGS = BUGCHECK_ERROR.INSUFFICIENT_SYSTEM_MAP_REGS;
pub const DEREF_UNKNOWN_LOGON_SESSION = BUGCHECK_ERROR.DEREF_UNKNOWN_LOGON_SESSION;
pub const REF_UNKNOWN_LOGON_SESSION = BUGCHECK_ERROR.REF_UNKNOWN_LOGON_SESSION;
pub const CANCEL_STATE_IN_COMPLETED_IRP = BUGCHECK_ERROR.CANCEL_STATE_IN_COMPLETED_IRP;
pub const PAGE_FAULT_WITH_INTERRUPTS_OFF = BUGCHECK_ERROR.PAGE_FAULT_WITH_INTERRUPTS_OFF;
pub const IRQL_GT_ZERO_AT_SYSTEM_SERVICE = BUGCHECK_ERROR.IRQL_GT_ZERO_AT_SYSTEM_SERVICE;
pub const STREAMS_INTERNAL_ERROR = BUGCHECK_ERROR.STREAMS_INTERNAL_ERROR;
pub const FATAL_UNHANDLED_HARD_ERROR = BUGCHECK_ERROR.FATAL_UNHANDLED_HARD_ERROR;
pub const NO_PAGES_AVAILABLE = BUGCHECK_ERROR.NO_PAGES_AVAILABLE;
pub const PFN_LIST_CORRUPT = BUGCHECK_ERROR.PFN_LIST_CORRUPT;
pub const NDIS_INTERNAL_ERROR = BUGCHECK_ERROR.NDIS_INTERNAL_ERROR;
pub const PAGE_FAULT_IN_NONPAGED_AREA = BUGCHECK_ERROR.PAGE_FAULT_IN_NONPAGED_AREA;
pub const PAGE_FAULT_IN_NONPAGED_AREA_M = BUGCHECK_ERROR.PAGE_FAULT_IN_NONPAGED_AREA_M;
pub const REGISTRY_ERROR = BUGCHECK_ERROR.REGISTRY_ERROR;
pub const MAILSLOT_FILE_SYSTEM = BUGCHECK_ERROR.MAILSLOT_FILE_SYSTEM;
pub const NO_BOOT_DEVICE = BUGCHECK_ERROR.NO_BOOT_DEVICE;
pub const LM_SERVER_INTERNAL_ERROR = BUGCHECK_ERROR.LM_SERVER_INTERNAL_ERROR;
pub const DATA_COHERENCY_EXCEPTION = BUGCHECK_ERROR.DATA_COHERENCY_EXCEPTION;
pub const INSTRUCTION_COHERENCY_EXCEPTION = BUGCHECK_ERROR.INSTRUCTION_COHERENCY_EXCEPTION;
pub const XNS_INTERNAL_ERROR = BUGCHECK_ERROR.XNS_INTERNAL_ERROR;
pub const VOLMGRX_INTERNAL_ERROR = BUGCHECK_ERROR.VOLMGRX_INTERNAL_ERROR;
pub const PINBALL_FILE_SYSTEM = BUGCHECK_ERROR.PINBALL_FILE_SYSTEM;
pub const CRITICAL_SERVICE_FAILED = BUGCHECK_ERROR.CRITICAL_SERVICE_FAILED;
pub const SET_ENV_VAR_FAILED = BUGCHECK_ERROR.SET_ENV_VAR_FAILED;
pub const HAL_INITIALIZATION_FAILED = BUGCHECK_ERROR.HAL_INITIALIZATION_FAILED;
pub const UNSUPPORTED_PROCESSOR = BUGCHECK_ERROR.UNSUPPORTED_PROCESSOR;
pub const OBJECT_INITIALIZATION_FAILED = BUGCHECK_ERROR.OBJECT_INITIALIZATION_FAILED;
pub const SECURITY_INITIALIZATION_FAILED = BUGCHECK_ERROR.SECURITY_INITIALIZATION_FAILED;
pub const PROCESS_INITIALIZATION_FAILED = BUGCHECK_ERROR.PROCESS_INITIALIZATION_FAILED;
pub const HAL1_INITIALIZATION_FAILED = BUGCHECK_ERROR.HAL1_INITIALIZATION_FAILED;
pub const OBJECT1_INITIALIZATION_FAILED = BUGCHECK_ERROR.OBJECT1_INITIALIZATION_FAILED;
pub const SECURITY1_INITIALIZATION_FAILED = BUGCHECK_ERROR.SECURITY1_INITIALIZATION_FAILED;
pub const SYMBOLIC_INITIALIZATION_FAILED = BUGCHECK_ERROR.SYMBOLIC_INITIALIZATION_FAILED;
pub const MEMORY1_INITIALIZATION_FAILED = BUGCHECK_ERROR.MEMORY1_INITIALIZATION_FAILED;
pub const CACHE_INITIALIZATION_FAILED = BUGCHECK_ERROR.CACHE_INITIALIZATION_FAILED;
pub const CONFIG_INITIALIZATION_FAILED = BUGCHECK_ERROR.CONFIG_INITIALIZATION_FAILED;
pub const FILE_INITIALIZATION_FAILED = BUGCHECK_ERROR.FILE_INITIALIZATION_FAILED;
pub const IO1_INITIALIZATION_FAILED = BUGCHECK_ERROR.IO1_INITIALIZATION_FAILED;
pub const LPC_INITIALIZATION_FAILED = BUGCHECK_ERROR.LPC_INITIALIZATION_FAILED;
pub const PROCESS1_INITIALIZATION_FAILED = BUGCHECK_ERROR.PROCESS1_INITIALIZATION_FAILED;
pub const REFMON_INITIALIZATION_FAILED = BUGCHECK_ERROR.REFMON_INITIALIZATION_FAILED;
pub const SESSION1_INITIALIZATION_FAILED = BUGCHECK_ERROR.SESSION1_INITIALIZATION_FAILED;
pub const BOOTPROC_INITIALIZATION_FAILED = BUGCHECK_ERROR.BOOTPROC_INITIALIZATION_FAILED;
pub const VSL_INITIALIZATION_FAILED = BUGCHECK_ERROR.VSL_INITIALIZATION_FAILED;
pub const SOFT_RESTART_FATAL_ERROR = BUGCHECK_ERROR.SOFT_RESTART_FATAL_ERROR;
pub const ASSIGN_DRIVE_LETTERS_FAILED = BUGCHECK_ERROR.ASSIGN_DRIVE_LETTERS_FAILED;
pub const CONFIG_LIST_FAILED = BUGCHECK_ERROR.CONFIG_LIST_FAILED;
pub const BAD_SYSTEM_CONFIG_INFO = BUGCHECK_ERROR.BAD_SYSTEM_CONFIG_INFO;
pub const CANNOT_WRITE_CONFIGURATION = BUGCHECK_ERROR.CANNOT_WRITE_CONFIGURATION;
pub const PROCESS_HAS_LOCKED_PAGES = BUGCHECK_ERROR.PROCESS_HAS_LOCKED_PAGES;
pub const KERNEL_STACK_INPAGE_ERROR = BUGCHECK_ERROR.KERNEL_STACK_INPAGE_ERROR;
pub const PHASE0_EXCEPTION = BUGCHECK_ERROR.PHASE0_EXCEPTION;
pub const MISMATCHED_HAL = BUGCHECK_ERROR.MISMATCHED_HAL;
pub const KERNEL_DATA_INPAGE_ERROR = BUGCHECK_ERROR.KERNEL_DATA_INPAGE_ERROR;
pub const INACCESSIBLE_BOOT_DEVICE = BUGCHECK_ERROR.INACCESSIBLE_BOOT_DEVICE;
pub const BUGCODE_NDIS_DRIVER = BUGCHECK_ERROR.BUGCODE_NDIS_DRIVER;
pub const INSTALL_MORE_MEMORY = BUGCHECK_ERROR.INSTALL_MORE_MEMORY;
pub const SYSTEM_THREAD_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.SYSTEM_THREAD_EXCEPTION_NOT_HANDLED;
pub const SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M = BUGCHECK_ERROR.SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M;
pub const UNEXPECTED_KERNEL_MODE_TRAP = BUGCHECK_ERROR.UNEXPECTED_KERNEL_MODE_TRAP;
pub const UNEXPECTED_KERNEL_MODE_TRAP_M = BUGCHECK_ERROR.UNEXPECTED_KERNEL_MODE_TRAP_M;
pub const NMI_HARDWARE_FAILURE = BUGCHECK_ERROR.NMI_HARDWARE_FAILURE;
pub const SPIN_LOCK_INIT_FAILURE = BUGCHECK_ERROR.SPIN_LOCK_INIT_FAILURE;
pub const DFS_FILE_SYSTEM = BUGCHECK_ERROR.DFS_FILE_SYSTEM;
pub const OFS_FILE_SYSTEM = BUGCHECK_ERROR.OFS_FILE_SYSTEM;
pub const RECOM_DRIVER = BUGCHECK_ERROR.RECOM_DRIVER;
pub const SETUP_FAILURE = BUGCHECK_ERROR.SETUP_FAILURE;
pub const AUDIT_FAILURE = BUGCHECK_ERROR.AUDIT_FAILURE;
pub const MBR_CHECKSUM_MISMATCH = BUGCHECK_ERROR.MBR_CHECKSUM_MISMATCH;
pub const KERNEL_MODE_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.KERNEL_MODE_EXCEPTION_NOT_HANDLED;
pub const KERNEL_MODE_EXCEPTION_NOT_HANDLED_M = BUGCHECK_ERROR.KERNEL_MODE_EXCEPTION_NOT_HANDLED_M;
pub const PP0_INITIALIZATION_FAILED = BUGCHECK_ERROR.PP0_INITIALIZATION_FAILED;
pub const PP1_INITIALIZATION_FAILED = BUGCHECK_ERROR.PP1_INITIALIZATION_FAILED;
pub const WIN32K_INIT_OR_RIT_FAILURE = BUGCHECK_ERROR.WIN32K_INIT_OR_RIT_FAILURE;
pub const UP_DRIVER_ON_MP_SYSTEM = BUGCHECK_ERROR.UP_DRIVER_ON_MP_SYSTEM;
pub const INVALID_KERNEL_HANDLE = BUGCHECK_ERROR.INVALID_KERNEL_HANDLE;
pub const KERNEL_STACK_LOCKED_AT_EXIT = BUGCHECK_ERROR.KERNEL_STACK_LOCKED_AT_EXIT;
pub const PNP_INTERNAL_ERROR = BUGCHECK_ERROR.PNP_INTERNAL_ERROR;
pub const INVALID_WORK_QUEUE_ITEM = BUGCHECK_ERROR.INVALID_WORK_QUEUE_ITEM;
pub const BOUND_IMAGE_UNSUPPORTED = BUGCHECK_ERROR.BOUND_IMAGE_UNSUPPORTED;
pub const END_OF_NT_EVALUATION_PERIOD = BUGCHECK_ERROR.END_OF_NT_EVALUATION_PERIOD;
pub const INVALID_REGION_OR_SEGMENT = BUGCHECK_ERROR.INVALID_REGION_OR_SEGMENT;
pub const SYSTEM_LICENSE_VIOLATION = BUGCHECK_ERROR.SYSTEM_LICENSE_VIOLATION;
pub const UDFS_FILE_SYSTEM = BUGCHECK_ERROR.UDFS_FILE_SYSTEM;
pub const MACHINE_CHECK_EXCEPTION = BUGCHECK_ERROR.MACHINE_CHECK_EXCEPTION;
pub const USER_MODE_HEALTH_MONITOR = BUGCHECK_ERROR.USER_MODE_HEALTH_MONITOR;
pub const DRIVER_POWER_STATE_FAILURE = BUGCHECK_ERROR.DRIVER_POWER_STATE_FAILURE;
pub const INTERNAL_POWER_ERROR = BUGCHECK_ERROR.INTERNAL_POWER_ERROR;
pub const PCI_BUS_DRIVER_INTERNAL = BUGCHECK_ERROR.PCI_BUS_DRIVER_INTERNAL;
pub const MEMORY_IMAGE_CORRUPT = BUGCHECK_ERROR.MEMORY_IMAGE_CORRUPT;
pub const ACPI_DRIVER_INTERNAL = BUGCHECK_ERROR.ACPI_DRIVER_INTERNAL;
pub const CNSS_FILE_SYSTEM_FILTER = BUGCHECK_ERROR.CNSS_FILE_SYSTEM_FILTER;
pub const ACPI_BIOS_ERROR = BUGCHECK_ERROR.ACPI_BIOS_ERROR;
pub const FP_EMULATION_ERROR = BUGCHECK_ERROR.FP_EMULATION_ERROR;
pub const BAD_EXHANDLE = BUGCHECK_ERROR.BAD_EXHANDLE;
pub const BOOTING_IN_SAFEMODE_MINIMAL = BUGCHECK_ERROR.BOOTING_IN_SAFEMODE_MINIMAL;
pub const BOOTING_IN_SAFEMODE_NETWORK = BUGCHECK_ERROR.BOOTING_IN_SAFEMODE_NETWORK;
pub const BOOTING_IN_SAFEMODE_DSREPAIR = BUGCHECK_ERROR.BOOTING_IN_SAFEMODE_DSREPAIR;
pub const SESSION_HAS_VALID_POOL_ON_EXIT = BUGCHECK_ERROR.SESSION_HAS_VALID_POOL_ON_EXIT;
pub const HAL_MEMORY_ALLOCATION = BUGCHECK_ERROR.HAL_MEMORY_ALLOCATION;
pub const VIDEO_DRIVER_DEBUG_REPORT_REQUEST = BUGCHECK_ERROR.VIDEO_DRIVER_DEBUG_REPORT_REQUEST;
pub const BGI_DETECTED_VIOLATION = BUGCHECK_ERROR.BGI_DETECTED_VIOLATION;
pub const VIDEO_DRIVER_INIT_FAILURE = BUGCHECK_ERROR.VIDEO_DRIVER_INIT_FAILURE;
pub const BOOTLOG_LOADED = BUGCHECK_ERROR.BOOTLOG_LOADED;
pub const BOOTLOG_NOT_LOADED = BUGCHECK_ERROR.BOOTLOG_NOT_LOADED;
pub const BOOTLOG_ENABLED = BUGCHECK_ERROR.BOOTLOG_ENABLED;
pub const ATTEMPTED_SWITCH_FROM_DPC = BUGCHECK_ERROR.ATTEMPTED_SWITCH_FROM_DPC;
pub const CHIPSET_DETECTED_ERROR = BUGCHECK_ERROR.CHIPSET_DETECTED_ERROR;
pub const SESSION_HAS_VALID_VIEWS_ON_EXIT = BUGCHECK_ERROR.SESSION_HAS_VALID_VIEWS_ON_EXIT;
pub const NETWORK_BOOT_INITIALIZATION_FAILED = BUGCHECK_ERROR.NETWORK_BOOT_INITIALIZATION_FAILED;
pub const NETWORK_BOOT_DUPLICATE_ADDRESS = BUGCHECK_ERROR.NETWORK_BOOT_DUPLICATE_ADDRESS;
pub const INVALID_HIBERNATED_STATE = BUGCHECK_ERROR.INVALID_HIBERNATED_STATE;
pub const ATTEMPTED_WRITE_TO_READONLY_MEMORY = BUGCHECK_ERROR.ATTEMPTED_WRITE_TO_READONLY_MEMORY;
pub const MUTEX_ALREADY_OWNED = BUGCHECK_ERROR.MUTEX_ALREADY_OWNED;
pub const PCI_CONFIG_SPACE_ACCESS_FAILURE = BUGCHECK_ERROR.PCI_CONFIG_SPACE_ACCESS_FAILURE;
pub const SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION = BUGCHECK_ERROR.SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION;
pub const BAD_POOL_CALLER = BUGCHECK_ERROR.BAD_POOL_CALLER;
pub const SYSTEM_IMAGE_BAD_SIGNATURE = BUGCHECK_ERROR.SYSTEM_IMAGE_BAD_SIGNATURE;
pub const DRIVER_VERIFIER_DETECTED_VIOLATION = BUGCHECK_ERROR.DRIVER_VERIFIER_DETECTED_VIOLATION;
pub const DRIVER_CORRUPTED_EXPOOL = BUGCHECK_ERROR.DRIVER_CORRUPTED_EXPOOL;
pub const DRIVER_CAUGHT_MODIFYING_FREED_POOL = BUGCHECK_ERROR.DRIVER_CAUGHT_MODIFYING_FREED_POOL;
pub const TIMER_OR_DPC_INVALID = BUGCHECK_ERROR.TIMER_OR_DPC_INVALID;
pub const IRQL_UNEXPECTED_VALUE = BUGCHECK_ERROR.IRQL_UNEXPECTED_VALUE;
pub const DRIVER_VERIFIER_IOMANAGER_VIOLATION = BUGCHECK_ERROR.DRIVER_VERIFIER_IOMANAGER_VIOLATION;
pub const PNP_DETECTED_FATAL_ERROR = BUGCHECK_ERROR.PNP_DETECTED_FATAL_ERROR;
pub const DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS = BUGCHECK_ERROR.DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS;
pub const PAGE_FAULT_IN_FREED_SPECIAL_POOL = BUGCHECK_ERROR.PAGE_FAULT_IN_FREED_SPECIAL_POOL;
pub const PAGE_FAULT_BEYOND_END_OF_ALLOCATION = BUGCHECK_ERROR.PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
pub const DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS = BUGCHECK_ERROR.DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS;
pub const TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE = BUGCHECK_ERROR.TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE;
pub const DRIVER_CORRUPTED_MMPOOL = BUGCHECK_ERROR.DRIVER_CORRUPTED_MMPOOL;
pub const DRIVER_IRQL_NOT_LESS_OR_EQUAL = BUGCHECK_ERROR.DRIVER_IRQL_NOT_LESS_OR_EQUAL;
pub const BUGCODE_ID_DRIVER = BUGCHECK_ERROR.BUGCODE_ID_DRIVER;
pub const DRIVER_PORTION_MUST_BE_NONPAGED = BUGCHECK_ERROR.DRIVER_PORTION_MUST_BE_NONPAGED;
pub const SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD = BUGCHECK_ERROR.SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD;
pub const DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL = BUGCHECK_ERROR.DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL;
pub const DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION = BUGCHECK_ERROR.DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
pub const DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M = BUGCHECK_ERROR.DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M;
pub const DRIVER_UNMAPPING_INVALID_VIEW = BUGCHECK_ERROR.DRIVER_UNMAPPING_INVALID_VIEW;
pub const DRIVER_USED_EXCESSIVE_PTES = BUGCHECK_ERROR.DRIVER_USED_EXCESSIVE_PTES;
pub const LOCKED_PAGES_TRACKER_CORRUPTION = BUGCHECK_ERROR.LOCKED_PAGES_TRACKER_CORRUPTION;
pub const SYSTEM_PTE_MISUSE = BUGCHECK_ERROR.SYSTEM_PTE_MISUSE;
pub const DRIVER_CORRUPTED_SYSPTES = BUGCHECK_ERROR.DRIVER_CORRUPTED_SYSPTES;
pub const DRIVER_INVALID_STACK_ACCESS = BUGCHECK_ERROR.DRIVER_INVALID_STACK_ACCESS;
pub const POOL_CORRUPTION_IN_FILE_AREA = BUGCHECK_ERROR.POOL_CORRUPTION_IN_FILE_AREA;
pub const IMPERSONATING_WORKER_THREAD = BUGCHECK_ERROR.IMPERSONATING_WORKER_THREAD;
pub const ACPI_BIOS_FATAL_ERROR = BUGCHECK_ERROR.ACPI_BIOS_FATAL_ERROR;
pub const WORKER_THREAD_RETURNED_AT_BAD_IRQL = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_AT_BAD_IRQL;
pub const MANUALLY_INITIATED_CRASH = BUGCHECK_ERROR.MANUALLY_INITIATED_CRASH;
pub const RESOURCE_NOT_OWNED = BUGCHECK_ERROR.RESOURCE_NOT_OWNED;
pub const WORKER_INVALID = BUGCHECK_ERROR.WORKER_INVALID;
pub const POWER_FAILURE_SIMULATE = BUGCHECK_ERROR.POWER_FAILURE_SIMULATE;
pub const DRIVER_VERIFIER_DMA_VIOLATION = BUGCHECK_ERROR.DRIVER_VERIFIER_DMA_VIOLATION;
pub const INVALID_FLOATING_POINT_STATE = BUGCHECK_ERROR.INVALID_FLOATING_POINT_STATE;
pub const INVALID_CANCEL_OF_FILE_OPEN = BUGCHECK_ERROR.INVALID_CANCEL_OF_FILE_OPEN;
pub const ACTIVE_EX_WORKER_THREAD_TERMINATION = BUGCHECK_ERROR.ACTIVE_EX_WORKER_THREAD_TERMINATION;
pub const SAVER_UNSPECIFIED = BUGCHECK_ERROR.SAVER_UNSPECIFIED;
pub const SAVER_BLANKSCREEN = BUGCHECK_ERROR.SAVER_BLANKSCREEN;
pub const SAVER_INPUT = BUGCHECK_ERROR.SAVER_INPUT;
pub const SAVER_WATCHDOG = BUGCHECK_ERROR.SAVER_WATCHDOG;
pub const SAVER_STARTNOTVISIBLE = BUGCHECK_ERROR.SAVER_STARTNOTVISIBLE;
pub const SAVER_NAVIGATIONMODEL = BUGCHECK_ERROR.SAVER_NAVIGATIONMODEL;
pub const SAVER_OUTOFMEMORY = BUGCHECK_ERROR.SAVER_OUTOFMEMORY;
pub const SAVER_GRAPHICS = BUGCHECK_ERROR.SAVER_GRAPHICS;
pub const SAVER_NAVSERVERTIMEOUT = BUGCHECK_ERROR.SAVER_NAVSERVERTIMEOUT;
pub const SAVER_CHROMEPROCESSCRASH = BUGCHECK_ERROR.SAVER_CHROMEPROCESSCRASH;
pub const SAVER_NOTIFICATIONDISMISSAL = BUGCHECK_ERROR.SAVER_NOTIFICATIONDISMISSAL;
pub const SAVER_SPEECHDISMISSAL = BUGCHECK_ERROR.SAVER_SPEECHDISMISSAL;
pub const SAVER_CALLDISMISSAL = BUGCHECK_ERROR.SAVER_CALLDISMISSAL;
pub const SAVER_APPBARDISMISSAL = BUGCHECK_ERROR.SAVER_APPBARDISMISSAL;
pub const SAVER_RILADAPTATIONCRASH = BUGCHECK_ERROR.SAVER_RILADAPTATIONCRASH;
pub const SAVER_APPLISTUNREACHABLE = BUGCHECK_ERROR.SAVER_APPLISTUNREACHABLE;
pub const SAVER_REPORTNOTIFICATIONFAILURE = BUGCHECK_ERROR.SAVER_REPORTNOTIFICATIONFAILURE;
pub const SAVER_UNEXPECTEDSHUTDOWN = BUGCHECK_ERROR.SAVER_UNEXPECTEDSHUTDOWN;
pub const SAVER_RPCFAILURE = BUGCHECK_ERROR.SAVER_RPCFAILURE;
pub const SAVER_AUXILIARYFULLDUMP = BUGCHECK_ERROR.SAVER_AUXILIARYFULLDUMP;
pub const SAVER_ACCOUNTPROVSVCINITFAILURE = BUGCHECK_ERROR.SAVER_ACCOUNTPROVSVCINITFAILURE;
pub const SAVER_MTBFCOMMANDTIMEOUT = BUGCHECK_ERROR.SAVER_MTBFCOMMANDTIMEOUT;
pub const SAVER_MTBFCOMMANDHANG = BUGCHECK_ERROR.SAVER_MTBFCOMMANDHANG;
pub const SAVER_MTBFPASSBUGCHECK = BUGCHECK_ERROR.SAVER_MTBFPASSBUGCHECK;
pub const SAVER_MTBFIOERROR = BUGCHECK_ERROR.SAVER_MTBFIOERROR;
pub const SAVER_RENDERTHREADHANG = BUGCHECK_ERROR.SAVER_RENDERTHREADHANG;
pub const SAVER_RENDERMOBILEUIOOM = BUGCHECK_ERROR.SAVER_RENDERMOBILEUIOOM;
pub const SAVER_DEVICEUPDATEUNSPECIFIED = BUGCHECK_ERROR.SAVER_DEVICEUPDATEUNSPECIFIED;
pub const SAVER_AUDIODRIVERHANG = BUGCHECK_ERROR.SAVER_AUDIODRIVERHANG;
pub const SAVER_BATTERYPULLOUT = BUGCHECK_ERROR.SAVER_BATTERYPULLOUT;
pub const SAVER_MEDIACORETESTHANG = BUGCHECK_ERROR.SAVER_MEDIACORETESTHANG;
pub const SAVER_RESOURCEMANAGEMENT = BUGCHECK_ERROR.SAVER_RESOURCEMANAGEMENT;
pub const SAVER_CAPTURESERVICE = BUGCHECK_ERROR.SAVER_CAPTURESERVICE;
pub const SAVER_WAITFORSHELLREADY = BUGCHECK_ERROR.SAVER_WAITFORSHELLREADY;
pub const SAVER_NONRESPONSIVEPROCESS = BUGCHECK_ERROR.SAVER_NONRESPONSIVEPROCESS;
pub const SAVER_SICKAPPLICATION = BUGCHECK_ERROR.SAVER_SICKAPPLICATION;
pub const THREAD_STUCK_IN_DEVICE_DRIVER = BUGCHECK_ERROR.THREAD_STUCK_IN_DEVICE_DRIVER;
pub const THREAD_STUCK_IN_DEVICE_DRIVER_M = BUGCHECK_ERROR.THREAD_STUCK_IN_DEVICE_DRIVER_M;
pub const DIRTY_MAPPED_PAGES_CONGESTION = BUGCHECK_ERROR.DIRTY_MAPPED_PAGES_CONGESTION;
pub const SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT = BUGCHECK_ERROR.SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT;
pub const UNMOUNTABLE_BOOT_VOLUME = BUGCHECK_ERROR.UNMOUNTABLE_BOOT_VOLUME;
pub const CRITICAL_PROCESS_DIED = BUGCHECK_ERROR.CRITICAL_PROCESS_DIED;
pub const STORAGE_MINIPORT_ERROR = BUGCHECK_ERROR.STORAGE_MINIPORT_ERROR;
pub const SCSI_VERIFIER_DETECTED_VIOLATION = BUGCHECK_ERROR.SCSI_VERIFIER_DETECTED_VIOLATION;
pub const HARDWARE_INTERRUPT_STORM = BUGCHECK_ERROR.HARDWARE_INTERRUPT_STORM;
pub const DISORDERLY_SHUTDOWN = BUGCHECK_ERROR.DISORDERLY_SHUTDOWN;
pub const CRITICAL_OBJECT_TERMINATION = BUGCHECK_ERROR.CRITICAL_OBJECT_TERMINATION;
pub const FLTMGR_FILE_SYSTEM = BUGCHECK_ERROR.FLTMGR_FILE_SYSTEM;
pub const PCI_VERIFIER_DETECTED_VIOLATION = BUGCHECK_ERROR.PCI_VERIFIER_DETECTED_VIOLATION;
pub const DRIVER_OVERRAN_STACK_BUFFER = BUGCHECK_ERROR.DRIVER_OVERRAN_STACK_BUFFER;
pub const RAMDISK_BOOT_INITIALIZATION_FAILED = BUGCHECK_ERROR.RAMDISK_BOOT_INITIALIZATION_FAILED;
pub const DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN = BUGCHECK_ERROR.DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN;
pub const HTTP_DRIVER_CORRUPTED = BUGCHECK_ERROR.HTTP_DRIVER_CORRUPTED;
pub const RECURSIVE_MACHINE_CHECK = BUGCHECK_ERROR.RECURSIVE_MACHINE_CHECK;
pub const ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY = BUGCHECK_ERROR.ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY;
pub const DIRTY_NOWRITE_PAGES_CONGESTION = BUGCHECK_ERROR.DIRTY_NOWRITE_PAGES_CONGESTION;
pub const BUGCODE_USB_DRIVER = BUGCHECK_ERROR.BUGCODE_USB_DRIVER;
pub const BC_BLUETOOTH_VERIFIER_FAULT = BUGCHECK_ERROR.BC_BLUETOOTH_VERIFIER_FAULT;
pub const BC_BTHMINI_VERIFIER_FAULT = BUGCHECK_ERROR.BC_BTHMINI_VERIFIER_FAULT;
pub const RESERVE_QUEUE_OVERFLOW = BUGCHECK_ERROR.RESERVE_QUEUE_OVERFLOW;
pub const LOADER_BLOCK_MISMATCH = BUGCHECK_ERROR.LOADER_BLOCK_MISMATCH;
pub const CLOCK_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.CLOCK_WATCHDOG_TIMEOUT;
pub const DPC_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.DPC_WATCHDOG_TIMEOUT;
pub const MUP_FILE_SYSTEM = BUGCHECK_ERROR.MUP_FILE_SYSTEM;
pub const AGP_INVALID_ACCESS = BUGCHECK_ERROR.AGP_INVALID_ACCESS;
pub const AGP_GART_CORRUPTION = BUGCHECK_ERROR.AGP_GART_CORRUPTION;
pub const AGP_ILLEGALLY_REPROGRAMMED = BUGCHECK_ERROR.AGP_ILLEGALLY_REPROGRAMMED;
pub const KERNEL_EXPAND_STACK_ACTIVE = BUGCHECK_ERROR.KERNEL_EXPAND_STACK_ACTIVE;
pub const THIRD_PARTY_FILE_SYSTEM_FAILURE = BUGCHECK_ERROR.THIRD_PARTY_FILE_SYSTEM_FAILURE;
pub const CRITICAL_STRUCTURE_CORRUPTION = BUGCHECK_ERROR.CRITICAL_STRUCTURE_CORRUPTION;
pub const APP_TAGGING_INITIALIZATION_FAILED = BUGCHECK_ERROR.APP_TAGGING_INITIALIZATION_FAILED;
pub const DFSC_FILE_SYSTEM = BUGCHECK_ERROR.DFSC_FILE_SYSTEM;
pub const FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION = BUGCHECK_ERROR.FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION;
pub const WDF_VIOLATION = BUGCHECK_ERROR.WDF_VIOLATION;
pub const VIDEO_MEMORY_MANAGEMENT_INTERNAL = BUGCHECK_ERROR.VIDEO_MEMORY_MANAGEMENT_INTERNAL;
pub const DRIVER_INVALID_CRUNTIME_PARAMETER = BUGCHECK_ERROR.DRIVER_INVALID_CRUNTIME_PARAMETER;
pub const RECURSIVE_NMI = BUGCHECK_ERROR.RECURSIVE_NMI;
pub const MSRPC_STATE_VIOLATION = BUGCHECK_ERROR.MSRPC_STATE_VIOLATION;
pub const VIDEO_DXGKRNL_FATAL_ERROR = BUGCHECK_ERROR.VIDEO_DXGKRNL_FATAL_ERROR;
pub const VIDEO_SHADOW_DRIVER_FATAL_ERROR = BUGCHECK_ERROR.VIDEO_SHADOW_DRIVER_FATAL_ERROR;
pub const AGP_INTERNAL = BUGCHECK_ERROR.AGP_INTERNAL;
pub const VIDEO_TDR_FAILURE = BUGCHECK_ERROR.VIDEO_TDR_FAILURE;
pub const VIDEO_TDR_TIMEOUT_DETECTED = BUGCHECK_ERROR.VIDEO_TDR_TIMEOUT_DETECTED;
pub const NTHV_GUEST_ERROR = BUGCHECK_ERROR.NTHV_GUEST_ERROR;
pub const VIDEO_SCHEDULER_INTERNAL_ERROR = BUGCHECK_ERROR.VIDEO_SCHEDULER_INTERNAL_ERROR;
pub const EM_INITIALIZATION_ERROR = BUGCHECK_ERROR.EM_INITIALIZATION_ERROR;
pub const DRIVER_RETURNED_HOLDING_CANCEL_LOCK = BUGCHECK_ERROR.DRIVER_RETURNED_HOLDING_CANCEL_LOCK;
pub const ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE = BUGCHECK_ERROR.ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE;
pub const EVENT_TRACING_FATAL_ERROR = BUGCHECK_ERROR.EVENT_TRACING_FATAL_ERROR;
pub const TOO_MANY_RECURSIVE_FAULTS = BUGCHECK_ERROR.TOO_MANY_RECURSIVE_FAULTS;
pub const INVALID_DRIVER_HANDLE = BUGCHECK_ERROR.INVALID_DRIVER_HANDLE;
pub const BITLOCKER_FATAL_ERROR = BUGCHECK_ERROR.BITLOCKER_FATAL_ERROR;
pub const DRIVER_VIOLATION = BUGCHECK_ERROR.DRIVER_VIOLATION;
pub const WHEA_INTERNAL_ERROR = BUGCHECK_ERROR.WHEA_INTERNAL_ERROR;
pub const CRYPTO_SELF_TEST_FAILURE = BUGCHECK_ERROR.CRYPTO_SELF_TEST_FAILURE;
pub const WHEA_UNCORRECTABLE_ERROR = BUGCHECK_ERROR.WHEA_UNCORRECTABLE_ERROR;
pub const NMR_INVALID_STATE = BUGCHECK_ERROR.NMR_INVALID_STATE;
pub const NETIO_INVALID_POOL_CALLER = BUGCHECK_ERROR.NETIO_INVALID_POOL_CALLER;
pub const PAGE_NOT_ZERO = BUGCHECK_ERROR.PAGE_NOT_ZERO;
pub const WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY;
pub const WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY;
pub const MUI_NO_VALID_SYSTEM_LANGUAGE = BUGCHECK_ERROR.MUI_NO_VALID_SYSTEM_LANGUAGE;
pub const FAULTY_HARDWARE_CORRUPTED_PAGE = BUGCHECK_ERROR.FAULTY_HARDWARE_CORRUPTED_PAGE;
pub const EXFAT_FILE_SYSTEM = BUGCHECK_ERROR.EXFAT_FILE_SYSTEM;
pub const VOLSNAP_OVERLAPPED_TABLE_ACCESS = BUGCHECK_ERROR.VOLSNAP_OVERLAPPED_TABLE_ACCESS;
pub const INVALID_MDL_RANGE = BUGCHECK_ERROR.INVALID_MDL_RANGE;
pub const VHD_BOOT_INITIALIZATION_FAILED = BUGCHECK_ERROR.VHD_BOOT_INITIALIZATION_FAILED;
pub const DYNAMIC_ADD_PROCESSOR_MISMATCH = BUGCHECK_ERROR.DYNAMIC_ADD_PROCESSOR_MISMATCH;
pub const INVALID_EXTENDED_PROCESSOR_STATE = BUGCHECK_ERROR.INVALID_EXTENDED_PROCESSOR_STATE;
pub const RESOURCE_OWNER_POINTER_INVALID = BUGCHECK_ERROR.RESOURCE_OWNER_POINTER_INVALID;
pub const DPC_WATCHDOG_VIOLATION = BUGCHECK_ERROR.DPC_WATCHDOG_VIOLATION;
pub const DRIVE_EXTENDER = BUGCHECK_ERROR.DRIVE_EXTENDER;
pub const REGISTRY_FILTER_DRIVER_EXCEPTION = BUGCHECK_ERROR.REGISTRY_FILTER_DRIVER_EXCEPTION;
pub const VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE = BUGCHECK_ERROR.VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE;
pub const WIN32K_HANDLE_MANAGER = BUGCHECK_ERROR.WIN32K_HANDLE_MANAGER;
pub const GPIO_CONTROLLER_DRIVER_ERROR = BUGCHECK_ERROR.GPIO_CONTROLLER_DRIVER_ERROR;
pub const KERNEL_SECURITY_CHECK_FAILURE = BUGCHECK_ERROR.KERNEL_SECURITY_CHECK_FAILURE;
pub const KERNEL_MODE_HEAP_CORRUPTION = BUGCHECK_ERROR.KERNEL_MODE_HEAP_CORRUPTION;
pub const PASSIVE_INTERRUPT_ERROR = BUGCHECK_ERROR.PASSIVE_INTERRUPT_ERROR;
pub const INVALID_IO_BOOST_STATE = BUGCHECK_ERROR.INVALID_IO_BOOST_STATE;
pub const CRITICAL_INITIALIZATION_FAILURE = BUGCHECK_ERROR.CRITICAL_INITIALIZATION_FAILURE;
pub const ERRATA_WORKAROUND_UNSUCCESSFUL = BUGCHECK_ERROR.ERRATA_WORKAROUND_UNSUCCESSFUL;
pub const REGISTRY_CALLBACK_DRIVER_EXCEPTION = BUGCHECK_ERROR.REGISTRY_CALLBACK_DRIVER_EXCEPTION;
pub const STORAGE_DEVICE_ABNORMALITY_DETECTED = BUGCHECK_ERROR.STORAGE_DEVICE_ABNORMALITY_DETECTED;
pub const VIDEO_ENGINE_TIMEOUT_DETECTED = BUGCHECK_ERROR.VIDEO_ENGINE_TIMEOUT_DETECTED;
pub const VIDEO_TDR_APPLICATION_BLOCKED = BUGCHECK_ERROR.VIDEO_TDR_APPLICATION_BLOCKED;
pub const PROCESSOR_DRIVER_INTERNAL = BUGCHECK_ERROR.PROCESSOR_DRIVER_INTERNAL;
pub const BUGCODE_USB3_DRIVER = BUGCHECK_ERROR.BUGCODE_USB3_DRIVER;
pub const SECURE_BOOT_VIOLATION = BUGCHECK_ERROR.SECURE_BOOT_VIOLATION;
pub const NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED = BUGCHECK_ERROR.NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED;
pub const ABNORMAL_RESET_DETECTED = BUGCHECK_ERROR.ABNORMAL_RESET_DETECTED;
pub const IO_OBJECT_INVALID = BUGCHECK_ERROR.IO_OBJECT_INVALID;
pub const REFS_FILE_SYSTEM = BUGCHECK_ERROR.REFS_FILE_SYSTEM;
pub const KERNEL_WMI_INTERNAL = BUGCHECK_ERROR.KERNEL_WMI_INTERNAL;
pub const SOC_SUBSYSTEM_FAILURE = BUGCHECK_ERROR.SOC_SUBSYSTEM_FAILURE;
pub const FATAL_ABNORMAL_RESET_ERROR = BUGCHECK_ERROR.FATAL_ABNORMAL_RESET_ERROR;
pub const EXCEPTION_SCOPE_INVALID = BUGCHECK_ERROR.EXCEPTION_SCOPE_INVALID;
pub const SOC_CRITICAL_DEVICE_REMOVED = BUGCHECK_ERROR.SOC_CRITICAL_DEVICE_REMOVED;
pub const PDC_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.PDC_WATCHDOG_TIMEOUT;
pub const TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK = BUGCHECK_ERROR.TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK;
pub const UNSUPPORTED_INSTRUCTION_MODE = BUGCHECK_ERROR.UNSUPPORTED_INSTRUCTION_MODE;
pub const INVALID_PUSH_LOCK_FLAGS = BUGCHECK_ERROR.INVALID_PUSH_LOCK_FLAGS;
pub const KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION = BUGCHECK_ERROR.KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION;
pub const UNEXPECTED_STORE_EXCEPTION = BUGCHECK_ERROR.UNEXPECTED_STORE_EXCEPTION;
pub const OS_DATA_TAMPERING = BUGCHECK_ERROR.OS_DATA_TAMPERING;
pub const WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP = BUGCHECK_ERROR.WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP;
pub const KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION = BUGCHECK_ERROR.KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION;
pub const ILLEGAL_IOMMU_PAGE_FAULT = BUGCHECK_ERROR.ILLEGAL_IOMMU_PAGE_FAULT;
pub const HAL_ILLEGAL_IOMMU_PAGE_FAULT = BUGCHECK_ERROR.HAL_ILLEGAL_IOMMU_PAGE_FAULT;
pub const SDBUS_INTERNAL_ERROR = BUGCHECK_ERROR.SDBUS_INTERNAL_ERROR;
pub const WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE;
pub const PDC_WATCHDOG_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.PDC_WATCHDOG_TIMEOUT_LIVEDUMP;
pub const SOC_SUBSYSTEM_FAILURE_LIVEDUMP = BUGCHECK_ERROR.SOC_SUBSYSTEM_FAILURE_LIVEDUMP;
pub const BUGCODE_NDIS_DRIVER_LIVE_DUMP = BUGCHECK_ERROR.BUGCODE_NDIS_DRIVER_LIVE_DUMP;
pub const CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP;
pub const WIN32K_ATOMIC_CHECK_FAILURE = BUGCHECK_ERROR.WIN32K_ATOMIC_CHECK_FAILURE;
pub const LIVE_SYSTEM_DUMP = BUGCHECK_ERROR.LIVE_SYSTEM_DUMP;
pub const KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE = BUGCHECK_ERROR.KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE;
pub const WORKER_THREAD_TEST_CONDITION = BUGCHECK_ERROR.WORKER_THREAD_TEST_CONDITION;
pub const WIN32K_CRITICAL_FAILURE = BUGCHECK_ERROR.WIN32K_CRITICAL_FAILURE;
pub const CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP;
pub const CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP;
pub const CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP;
pub const CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP;
pub const INVALID_RUNDOWN_PROTECTION_FLAGS = BUGCHECK_ERROR.INVALID_RUNDOWN_PROTECTION_FLAGS;
pub const INVALID_SLOT_ALLOCATOR_FLAGS = BUGCHECK_ERROR.INVALID_SLOT_ALLOCATOR_FLAGS;
pub const ERESOURCE_INVALID_RELEASE = BUGCHECK_ERROR.ERESOURCE_INVALID_RELEASE;
pub const CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG = BUGCHECK_ERROR.CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG;
pub const CRYPTO_LIBRARY_INTERNAL_ERROR = BUGCHECK_ERROR.CRYPTO_LIBRARY_INTERNAL_ERROR;
pub const COREMSGCALL_INTERNAL_ERROR = BUGCHECK_ERROR.COREMSGCALL_INTERNAL_ERROR;
pub const COREMSG_INTERNAL_ERROR = BUGCHECK_ERROR.COREMSG_INTERNAL_ERROR;
pub const PREVIOUS_FATAL_ABNORMAL_RESET_ERROR = BUGCHECK_ERROR.PREVIOUS_FATAL_ABNORMAL_RESET_ERROR;
pub const ELAM_DRIVER_DETECTED_FATAL_ERROR = BUGCHECK_ERROR.ELAM_DRIVER_DETECTED_FATAL_ERROR;
pub const CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP;
pub const PROFILER_CONFIGURATION_ILLEGAL = BUGCHECK_ERROR.PROFILER_CONFIGURATION_ILLEGAL;
pub const PDC_LOCK_WATCHDOG_LIVEDUMP = BUGCHECK_ERROR.PDC_LOCK_WATCHDOG_LIVEDUMP;
pub const PDC_UNEXPECTED_REVOCATION_LIVEDUMP = BUGCHECK_ERROR.PDC_UNEXPECTED_REVOCATION_LIVEDUMP;
pub const MICROCODE_REVISION_MISMATCH = BUGCHECK_ERROR.MICROCODE_REVISION_MISMATCH;
pub const HYPERGUARD_INITIALIZATION_FAILURE = BUGCHECK_ERROR.HYPERGUARD_INITIALIZATION_FAILURE;
pub const WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT;
pub const WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT;
pub const WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT;
pub const WVR_LIVEDUMP_APP_IO_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_APP_IO_TIMEOUT;
pub const WVR_LIVEDUMP_MANUALLY_INITIATED = BUGCHECK_ERROR.WVR_LIVEDUMP_MANUALLY_INITIATED;
pub const WVR_LIVEDUMP_STATE_FAILURE = BUGCHECK_ERROR.WVR_LIVEDUMP_STATE_FAILURE;
pub const WVR_LIVEDUMP_CRITICAL_ERROR = BUGCHECK_ERROR.WVR_LIVEDUMP_CRITICAL_ERROR;
pub const VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD = BUGCHECK_ERROR.VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD;
pub const CLUSTER_CSVFS_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSVFS_LIVEDUMP;
pub const BAD_OBJECT_HEADER = BUGCHECK_ERROR.BAD_OBJECT_HEADER;
pub const SILO_CORRUPT = BUGCHECK_ERROR.SILO_CORRUPT;
pub const SECURE_KERNEL_ERROR = BUGCHECK_ERROR.SECURE_KERNEL_ERROR;
pub const HYPERGUARD_VIOLATION = BUGCHECK_ERROR.HYPERGUARD_VIOLATION;
pub const SECURE_FAULT_UNHANDLED = BUGCHECK_ERROR.SECURE_FAULT_UNHANDLED;
pub const KERNEL_PARTITION_REFERENCE_VIOLATION = BUGCHECK_ERROR.KERNEL_PARTITION_REFERENCE_VIOLATION;
pub const SYNTHETIC_EXCEPTION_UNHANDLED = BUGCHECK_ERROR.SYNTHETIC_EXCEPTION_UNHANDLED;
pub const WIN32K_CRITICAL_FAILURE_LIVEDUMP = BUGCHECK_ERROR.WIN32K_CRITICAL_FAILURE_LIVEDUMP;
pub const PF_DETECTED_CORRUPTION = BUGCHECK_ERROR.PF_DETECTED_CORRUPTION;
pub const KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL = BUGCHECK_ERROR.KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL;
pub const VIDEO_DXGKRNL_LIVEDUMP = BUGCHECK_ERROR.VIDEO_DXGKRNL_LIVEDUMP;
pub const KERNEL_STORAGE_SLOT_IN_USE = BUGCHECK_ERROR.KERNEL_STORAGE_SLOT_IN_USE;
pub const SMB_SERVER_LIVEDUMP = BUGCHECK_ERROR.SMB_SERVER_LIVEDUMP;
pub const LOADER_ROLLBACK_DETECTED = BUGCHECK_ERROR.LOADER_ROLLBACK_DETECTED;
pub const WIN32K_SECURITY_FAILURE = BUGCHECK_ERROR.WIN32K_SECURITY_FAILURE;
pub const UFX_LIVEDUMP = BUGCHECK_ERROR.UFX_LIVEDUMP;
pub const WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO;
pub const TTM_FATAL_ERROR = BUGCHECK_ERROR.TTM_FATAL_ERROR;
pub const WIN32K_POWER_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.WIN32K_POWER_WATCHDOG_TIMEOUT;
pub const CLUSTER_SVHDX_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_SVHDX_LIVEDUMP;
pub const BUGCODE_NETADAPTER_DRIVER = BUGCHECK_ERROR.BUGCODE_NETADAPTER_DRIVER;
pub const PDC_PRIVILEGE_CHECK_LIVEDUMP = BUGCHECK_ERROR.PDC_PRIVILEGE_CHECK_LIVEDUMP;
pub const TTM_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.TTM_WATCHDOG_TIMEOUT;
pub const WIN32K_CALLOUT_WATCHDOG_LIVEDUMP = BUGCHECK_ERROR.WIN32K_CALLOUT_WATCHDOG_LIVEDUMP;
pub const WIN32K_CALLOUT_WATCHDOG_BUGCHECK = BUGCHECK_ERROR.WIN32K_CALLOUT_WATCHDOG_BUGCHECK;
pub const CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP;
pub const DRIPS_SW_HW_DIVERGENCE_LIVEDUMP = BUGCHECK_ERROR.DRIPS_SW_HW_DIVERGENCE_LIVEDUMP;
pub const USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP = BUGCHECK_ERROR.USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP;
pub const BLUETOOTH_ERROR_RECOVERY_LIVEDUMP = BUGCHECK_ERROR.BLUETOOTH_ERROR_RECOVERY_LIVEDUMP;
pub const SMB_REDIRECTOR_LIVEDUMP = BUGCHECK_ERROR.SMB_REDIRECTOR_LIVEDUMP;
pub const VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP = BUGCHECK_ERROR.VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP;
pub const DIRECTED_FX_TRANSITION_LIVEDUMP = BUGCHECK_ERROR.DIRECTED_FX_TRANSITION_LIVEDUMP;
pub const EXCEPTION_ON_INVALID_STACK = BUGCHECK_ERROR.EXCEPTION_ON_INVALID_STACK;
pub const UNWIND_ON_INVALID_STACK = BUGCHECK_ERROR.UNWIND_ON_INVALID_STACK;
pub const VIDEO_MINIPORT_FAILED_LIVEDUMP = BUGCHECK_ERROR.VIDEO_MINIPORT_FAILED_LIVEDUMP;
pub const VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP = BUGCHECK_ERROR.VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP;
pub const DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP = BUGCHECK_ERROR.DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP;
pub const IO_THREADPOOL_DEADLOCK_LIVEDUMP = BUGCHECK_ERROR.IO_THREADPOOL_DEADLOCK_LIVEDUMP;
pub const FAST_ERESOURCE_PRECONDITION_VIOLATION = BUGCHECK_ERROR.FAST_ERESOURCE_PRECONDITION_VIOLATION;
pub const STORE_DATA_STRUCTURE_CORRUPTION = BUGCHECK_ERROR.STORE_DATA_STRUCTURE_CORRUPTION;
pub const MANUALLY_INITIATED_POWER_BUTTON_HOLD = BUGCHECK_ERROR.MANUALLY_INITIATED_POWER_BUTTON_HOLD;
pub const USER_MODE_HEALTH_MONITOR_LIVEDUMP = BUGCHECK_ERROR.USER_MODE_HEALTH_MONITOR_LIVEDUMP;
pub const SYNTHETIC_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.SYNTHETIC_WATCHDOG_TIMEOUT;
pub const INVALID_SILO_DETACH = BUGCHECK_ERROR.INVALID_SILO_DETACH;
pub const EXRESOURCE_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.EXRESOURCE_TIMEOUT_LIVEDUMP;
pub const INVALID_CALLBACK_STACK_ADDRESS = BUGCHECK_ERROR.INVALID_CALLBACK_STACK_ADDRESS;
pub const INVALID_KERNEL_STACK_ADDRESS = BUGCHECK_ERROR.INVALID_KERNEL_STACK_ADDRESS;
pub const HARDWARE_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.HARDWARE_WATCHDOG_TIMEOUT;
pub const ACPI_FIRMWARE_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.ACPI_FIRMWARE_WATCHDOG_TIMEOUT;
pub const TELEMETRY_ASSERTS_LIVEDUMP = BUGCHECK_ERROR.TELEMETRY_ASSERTS_LIVEDUMP;
pub const WORKER_THREAD_INVALID_STATE = BUGCHECK_ERROR.WORKER_THREAD_INVALID_STATE;
pub const WFP_INVALID_OPERATION = BUGCHECK_ERROR.WFP_INVALID_OPERATION;
pub const UCMUCSI_LIVEDUMP = BUGCHECK_ERROR.UCMUCSI_LIVEDUMP;
pub const DRIVER_PNP_WATCHDOG = BUGCHECK_ERROR.DRIVER_PNP_WATCHDOG;
pub const WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS;
pub const EFS_FATAL_ERROR = BUGCHECK_ERROR.EFS_FATAL_ERROR;
pub const UCMUCSI_FAILURE = BUGCHECK_ERROR.UCMUCSI_FAILURE;
pub const HAL_IOMMU_INTERNAL_ERROR = BUGCHECK_ERROR.HAL_IOMMU_INTERNAL_ERROR;
pub const HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR = BUGCHECK_ERROR.HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR;
pub const IPI_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.IPI_WATCHDOG_TIMEOUT;
pub const DMA_COMMON_BUFFER_VECTOR_ERROR = BUGCHECK_ERROR.DMA_COMMON_BUFFER_VECTOR_ERROR;
pub const BUGCODE_MBBADAPTER_DRIVER = BUGCHECK_ERROR.BUGCODE_MBBADAPTER_DRIVER;
pub const BUGCODE_WIFIADAPTER_DRIVER = BUGCHECK_ERROR.BUGCODE_WIFIADAPTER_DRIVER;
pub const PROCESSOR_START_TIMEOUT = BUGCHECK_ERROR.PROCESSOR_START_TIMEOUT;
pub const INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION = BUGCHECK_ERROR.INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION;
pub const DEVICE_DIAGNOSTIC_LOG_LIVEDUMP = BUGCHECK_ERROR.DEVICE_DIAGNOSTIC_LOG_LIVEDUMP;
pub const AZURE_DEVICE_FW_DUMP = BUGCHECK_ERROR.AZURE_DEVICE_FW_DUMP;
pub const BREAKAWAY_CABLE_TRANSITION = BUGCHECK_ERROR.BREAKAWAY_CABLE_TRANSITION;
pub const VIDEO_DXGKRNL_SYSMM_FATAL_ERROR = BUGCHECK_ERROR.VIDEO_DXGKRNL_SYSMM_FATAL_ERROR;
pub const DRIVER_VERIFIER_TRACKING_LIVE_DUMP = BUGCHECK_ERROR.DRIVER_VERIFIER_TRACKING_LIVE_DUMP;
pub const CRASHDUMP_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.CRASHDUMP_WATCHDOG_TIMEOUT;
pub const REGISTRY_LIVE_DUMP = BUGCHECK_ERROR.REGISTRY_LIVE_DUMP;
pub const INVALID_THREAD_AFFINITY_STATE = BUGCHECK_ERROR.INVALID_THREAD_AFFINITY_STATE;
pub const ILLEGAL_ATS_INITIALIZATION = BUGCHECK_ERROR.ILLEGAL_ATS_INITIALIZATION;
pub const SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION = BUGCHECK_ERROR.SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION;
pub const DAM_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.DAM_WATCHDOG_TIMEOUT;
pub const XBOX_VMCTRL_CS_TIMEOUT = BUGCHECK_ERROR.XBOX_VMCTRL_CS_TIMEOUT;
pub const XBOX_CORRUPTED_IMAGE = BUGCHECK_ERROR.XBOX_CORRUPTED_IMAGE;
pub const XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW = BUGCHECK_ERROR.XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW;
pub const XBOX_CORRUPTED_IMAGE_BASE = BUGCHECK_ERROR.XBOX_CORRUPTED_IMAGE_BASE;
pub const XBOX_XDS_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.XBOX_XDS_WATCHDOG_TIMEOUT;
pub const XBOX_SHUTDOWN_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.XBOX_SHUTDOWN_WATCHDOG_TIMEOUT;
pub const XBOX_360_SYSTEM_CRASH = BUGCHECK_ERROR.XBOX_360_SYSTEM_CRASH;
pub const XBOX_360_SYSTEM_CRASH_RESERVED = BUGCHECK_ERROR.XBOX_360_SYSTEM_CRASH_RESERVED;
pub const XBOX_SECURITY_FAILUE = BUGCHECK_ERROR.XBOX_SECURITY_FAILUE;
pub const KERNEL_CFG_INIT_FAILURE = BUGCHECK_ERROR.KERNEL_CFG_INIT_FAILURE;
pub const MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP = BUGCHECK_ERROR.MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP;
pub const HYPERVISOR_ERROR = BUGCHECK_ERROR.HYPERVISOR_ERROR;
pub const WINLOGON_FATAL_ERROR = BUGCHECK_ERROR.WINLOGON_FATAL_ERROR;
pub const MANUALLY_INITIATED_CRASH1 = BUGCHECK_ERROR.MANUALLY_INITIATED_CRASH1;
pub const BUGCHECK_CONTEXT_MODIFIER = BUGCHECK_ERROR.BUGCHECK_CONTEXT_MODIFIER;

pub const FACILITY_CODE = enum(u32) {
    NULL = 0,
    RPC = 1,
    DISPATCH = 2,
    STORAGE = 3,
    ITF = 4,
    WIN32 = 7,
    WINDOWS = 8,
    SSPI = 9,
    // SECURITY = 9, this enum value conflicts with SSPI
    CONTROL = 10,
    CERT = 11,
    INTERNET = 12,
    MEDIASERVER = 13,
    MSMQ = 14,
    SETUPAPI = 15,
    SCARD = 16,
    COMPLUS = 17,
    AAF = 18,
    URT = 19,
    ACS = 20,
    DPLAY = 21,
    UMI = 22,
    SXS = 23,
    WINDOWS_CE = 24,
    HTTP = 25,
    USERMODE_COMMONLOG = 26,
    WER = 27,
    USERMODE_FILTER_MANAGER = 31,
    BACKGROUNDCOPY = 32,
    CONFIGURATION = 33,
    // WIA = 33, this enum value conflicts with CONFIGURATION
    STATE_MANAGEMENT = 34,
    METADIRECTORY = 35,
    WINDOWSUPDATE = 36,
    DIRECTORYSERVICE = 37,
    GRAPHICS = 38,
    SHELL = 39,
    // NAP = 39, this enum value conflicts with SHELL
    TPM_SERVICES = 40,
    TPM_SOFTWARE = 41,
    UI = 42,
    XAML = 43,
    ACTION_QUEUE = 44,
    PLA = 48,
    // WINDOWS_SETUP = 48, this enum value conflicts with PLA
    FVE = 49,
    FWP = 50,
    WINRM = 51,
    NDIS = 52,
    USERMODE_HYPERVISOR = 53,
    CMI = 54,
    USERMODE_VIRTUALIZATION = 55,
    USERMODE_VOLMGR = 56,
    BCD = 57,
    USERMODE_VHD = 58,
    USERMODE_HNS = 59,
    SDIAG = 60,
    WEBSERVICES = 61,
    // WINPE = 61, this enum value conflicts with WEBSERVICES
    WPN = 62,
    WINDOWS_STORE = 63,
    INPUT = 64,
    QUIC = 65,
    EAP = 66,
    IORING = 70,
    WINDOWS_DEFENDER = 80,
    OPC = 81,
    XPS = 82,
    MBN = 84,
    // POWERSHELL = 84, this enum value conflicts with MBN
    RAS = 83,
    P2P_INT = 98,
    P2P = 99,
    DAF = 100,
    BLUETOOTH_ATT = 101,
    AUDIO = 102,
    STATEREPOSITORY = 103,
    VISUALCPP = 109,
    SCRIPT = 112,
    PARSE = 113,
    BLB = 120,
    BLB_CLI = 121,
    WSBAPP = 122,
    BLBUI = 128,
    USN = 129,
    USERMODE_VOLSNAP = 130,
    TIERING = 131,
    WSB_ONLINE = 133,
    ONLINE_ID = 134,
    DEVICE_UPDATE_AGENT = 135,
    DRVSERVICING = 136,
    DLS = 153,
    DELIVERY_OPTIMIZATION = 208,
    USERMODE_SPACES = 231,
    USER_MODE_SECURITY_CORE = 232,
    USERMODE_LICENSING = 234,
    SOS = 160,
    OCP_UPDATE_AGENT = 173,
    DEBUGGERS = 176,
    SPP = 256,
    // RESTORE = 256, this enum value conflicts with SPP
    // DMSERVER = 256, this enum value conflicts with SPP
    DEPLOYMENT_SERVICES_SERVER = 257,
    DEPLOYMENT_SERVICES_IMAGING = 258,
    DEPLOYMENT_SERVICES_MANAGEMENT = 259,
    DEPLOYMENT_SERVICES_UTIL = 260,
    DEPLOYMENT_SERVICES_BINLSVC = 261,
    DEPLOYMENT_SERVICES_PXE = 263,
    DEPLOYMENT_SERVICES_TFTP = 264,
    DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 272,
    DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = 278,
    DEPLOYMENT_SERVICES_MULTICAST_SERVER = 289,
    DEPLOYMENT_SERVICES_MULTICAST_CLIENT = 290,
    DEPLOYMENT_SERVICES_CONTENT_PROVIDER = 293,
    HSP_SERVICES = 296,
    HSP_SOFTWARE = 297,
    LINGUISTIC_SERVICES = 305,
    AUDIOSTREAMING = 1094,
    TTD = 1490,
    ACCELERATOR = 1536,
    WMAAECMA = 1996,
    DIRECTMUSIC = 2168,
    DIRECT3D10 = 2169,
    DXGI = 2170,
    DXGI_DDI = 2171,
    DIRECT3D11 = 2172,
    DIRECT3D11_DEBUG = 2173,
    DIRECT3D12 = 2174,
    DIRECT3D12_DEBUG = 2175,
    DXCORE = 2176,
    PRESENTATION = 2177,
    LEAP = 2184,
    AUDCLNT = 2185,
    WINCODEC_DWRITE_DWM = 2200,
    WINML = 2192,
    DIRECT2D = 2201,
    DEFRAG = 2304,
    USERMODE_SDBUS = 2305,
    JSCRIPT = 2306,
    PIDGENX = 2561,
    EAS = 85,
    WEB = 885,
    WEB_SOCKET = 886,
    MOBILE = 1793,
    SQLITE = 1967,
    SERVICE_FABRIC = 1968,
    UTC = 1989,
    WEP = 2049,
    SYNCENGINE = 2050,
    XBOX = 2339,
    GAME = 2340,
    PIX = 2748,
    NT_BIT = 268435456,
};
pub const FACILITY_NULL = FACILITY_CODE.NULL;
pub const FACILITY_RPC = FACILITY_CODE.RPC;
pub const FACILITY_DISPATCH = FACILITY_CODE.DISPATCH;
pub const FACILITY_STORAGE = FACILITY_CODE.STORAGE;
pub const FACILITY_ITF = FACILITY_CODE.ITF;
pub const FACILITY_WIN32 = FACILITY_CODE.WIN32;
pub const FACILITY_WINDOWS = FACILITY_CODE.WINDOWS;
pub const FACILITY_SSPI = FACILITY_CODE.SSPI;
pub const FACILITY_SECURITY = FACILITY_CODE.SSPI;
pub const FACILITY_CONTROL = FACILITY_CODE.CONTROL;
pub const FACILITY_CERT = FACILITY_CODE.CERT;
pub const FACILITY_INTERNET = FACILITY_CODE.INTERNET;
pub const FACILITY_MEDIASERVER = FACILITY_CODE.MEDIASERVER;
pub const FACILITY_MSMQ = FACILITY_CODE.MSMQ;
pub const FACILITY_SETUPAPI = FACILITY_CODE.SETUPAPI;
pub const FACILITY_SCARD = FACILITY_CODE.SCARD;
pub const FACILITY_COMPLUS = FACILITY_CODE.COMPLUS;
pub const FACILITY_AAF = FACILITY_CODE.AAF;
pub const FACILITY_URT = FACILITY_CODE.URT;
pub const FACILITY_ACS = FACILITY_CODE.ACS;
pub const FACILITY_DPLAY = FACILITY_CODE.DPLAY;
pub const FACILITY_UMI = FACILITY_CODE.UMI;
pub const FACILITY_SXS = FACILITY_CODE.SXS;
pub const FACILITY_WINDOWS_CE = FACILITY_CODE.WINDOWS_CE;
pub const FACILITY_HTTP = FACILITY_CODE.HTTP;
pub const FACILITY_USERMODE_COMMONLOG = FACILITY_CODE.USERMODE_COMMONLOG;
pub const FACILITY_WER = FACILITY_CODE.WER;
pub const FACILITY_USERMODE_FILTER_MANAGER = FACILITY_CODE.USERMODE_FILTER_MANAGER;
pub const FACILITY_BACKGROUNDCOPY = FACILITY_CODE.BACKGROUNDCOPY;
pub const FACILITY_CONFIGURATION = FACILITY_CODE.CONFIGURATION;
pub const FACILITY_WIA = FACILITY_CODE.CONFIGURATION;
pub const FACILITY_STATE_MANAGEMENT = FACILITY_CODE.STATE_MANAGEMENT;
pub const FACILITY_METADIRECTORY = FACILITY_CODE.METADIRECTORY;
pub const FACILITY_WINDOWSUPDATE = FACILITY_CODE.WINDOWSUPDATE;
pub const FACILITY_DIRECTORYSERVICE = FACILITY_CODE.DIRECTORYSERVICE;
pub const FACILITY_GRAPHICS = FACILITY_CODE.GRAPHICS;
pub const FACILITY_SHELL = FACILITY_CODE.SHELL;
pub const FACILITY_NAP = FACILITY_CODE.SHELL;
pub const FACILITY_TPM_SERVICES = FACILITY_CODE.TPM_SERVICES;
pub const FACILITY_TPM_SOFTWARE = FACILITY_CODE.TPM_SOFTWARE;
pub const FACILITY_UI = FACILITY_CODE.UI;
pub const FACILITY_XAML = FACILITY_CODE.XAML;
pub const FACILITY_ACTION_QUEUE = FACILITY_CODE.ACTION_QUEUE;
pub const FACILITY_PLA = FACILITY_CODE.PLA;
pub const FACILITY_WINDOWS_SETUP = FACILITY_CODE.PLA;
pub const FACILITY_FVE = FACILITY_CODE.FVE;
pub const FACILITY_FWP = FACILITY_CODE.FWP;
pub const FACILITY_WINRM = FACILITY_CODE.WINRM;
pub const FACILITY_NDIS = FACILITY_CODE.NDIS;
pub const FACILITY_USERMODE_HYPERVISOR = FACILITY_CODE.USERMODE_HYPERVISOR;
pub const FACILITY_CMI = FACILITY_CODE.CMI;
pub const FACILITY_USERMODE_VIRTUALIZATION = FACILITY_CODE.USERMODE_VIRTUALIZATION;
pub const FACILITY_USERMODE_VOLMGR = FACILITY_CODE.USERMODE_VOLMGR;
pub const FACILITY_BCD = FACILITY_CODE.BCD;
pub const FACILITY_USERMODE_VHD = FACILITY_CODE.USERMODE_VHD;
pub const FACILITY_USERMODE_HNS = FACILITY_CODE.USERMODE_HNS;
pub const FACILITY_SDIAG = FACILITY_CODE.SDIAG;
pub const FACILITY_WEBSERVICES = FACILITY_CODE.WEBSERVICES;
pub const FACILITY_WINPE = FACILITY_CODE.WEBSERVICES;
pub const FACILITY_WPN = FACILITY_CODE.WPN;
pub const FACILITY_WINDOWS_STORE = FACILITY_CODE.WINDOWS_STORE;
pub const FACILITY_INPUT = FACILITY_CODE.INPUT;
pub const FACILITY_QUIC = FACILITY_CODE.QUIC;
pub const FACILITY_EAP = FACILITY_CODE.EAP;
pub const FACILITY_IORING = FACILITY_CODE.IORING;
pub const FACILITY_WINDOWS_DEFENDER = FACILITY_CODE.WINDOWS_DEFENDER;
pub const FACILITY_OPC = FACILITY_CODE.OPC;
pub const FACILITY_XPS = FACILITY_CODE.XPS;
pub const FACILITY_MBN = FACILITY_CODE.MBN;
pub const FACILITY_POWERSHELL = FACILITY_CODE.MBN;
pub const FACILITY_RAS = FACILITY_CODE.RAS;
pub const FACILITY_P2P_INT = FACILITY_CODE.P2P_INT;
pub const FACILITY_P2P = FACILITY_CODE.P2P;
pub const FACILITY_DAF = FACILITY_CODE.DAF;
pub const FACILITY_BLUETOOTH_ATT = FACILITY_CODE.BLUETOOTH_ATT;
pub const FACILITY_AUDIO = FACILITY_CODE.AUDIO;
pub const FACILITY_STATEREPOSITORY = FACILITY_CODE.STATEREPOSITORY;
pub const FACILITY_VISUALCPP = FACILITY_CODE.VISUALCPP;
pub const FACILITY_SCRIPT = FACILITY_CODE.SCRIPT;
pub const FACILITY_PARSE = FACILITY_CODE.PARSE;
pub const FACILITY_BLB = FACILITY_CODE.BLB;
pub const FACILITY_BLB_CLI = FACILITY_CODE.BLB_CLI;
pub const FACILITY_WSBAPP = FACILITY_CODE.WSBAPP;
pub const FACILITY_BLBUI = FACILITY_CODE.BLBUI;
pub const FACILITY_USN = FACILITY_CODE.USN;
pub const FACILITY_USERMODE_VOLSNAP = FACILITY_CODE.USERMODE_VOLSNAP;
pub const FACILITY_TIERING = FACILITY_CODE.TIERING;
pub const FACILITY_WSB_ONLINE = FACILITY_CODE.WSB_ONLINE;
pub const FACILITY_ONLINE_ID = FACILITY_CODE.ONLINE_ID;
pub const FACILITY_DEVICE_UPDATE_AGENT = FACILITY_CODE.DEVICE_UPDATE_AGENT;
pub const FACILITY_DRVSERVICING = FACILITY_CODE.DRVSERVICING;
pub const FACILITY_DLS = FACILITY_CODE.DLS;
pub const FACILITY_DELIVERY_OPTIMIZATION = FACILITY_CODE.DELIVERY_OPTIMIZATION;
pub const FACILITY_USERMODE_SPACES = FACILITY_CODE.USERMODE_SPACES;
pub const FACILITY_USER_MODE_SECURITY_CORE = FACILITY_CODE.USER_MODE_SECURITY_CORE;
pub const FACILITY_USERMODE_LICENSING = FACILITY_CODE.USERMODE_LICENSING;
pub const FACILITY_SOS = FACILITY_CODE.SOS;
pub const FACILITY_OCP_UPDATE_AGENT = FACILITY_CODE.OCP_UPDATE_AGENT;
pub const FACILITY_DEBUGGERS = FACILITY_CODE.DEBUGGERS;
pub const FACILITY_SPP = FACILITY_CODE.SPP;
pub const FACILITY_RESTORE = FACILITY_CODE.SPP;
pub const FACILITY_DMSERVER = FACILITY_CODE.SPP;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER = FACILITY_CODE.DEPLOYMENT_SERVICES_SERVER;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING = FACILITY_CODE.DEPLOYMENT_SERVICES_IMAGING;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT = FACILITY_CODE.DEPLOYMENT_SERVICES_MANAGEMENT;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL = FACILITY_CODE.DEPLOYMENT_SERVICES_UTIL;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC = FACILITY_CODE.DEPLOYMENT_SERVICES_BINLSVC;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE = FACILITY_CODE.DEPLOYMENT_SERVICES_PXE;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP = FACILITY_CODE.DEPLOYMENT_SERVICES_TFTP;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = FACILITY_CODE.DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = FACILITY_CODE.DEPLOYMENT_SERVICES_DRIVER_PROVISIONING;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER = FACILITY_CODE.DEPLOYMENT_SERVICES_MULTICAST_SERVER;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT = FACILITY_CODE.DEPLOYMENT_SERVICES_MULTICAST_CLIENT;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER = FACILITY_CODE.DEPLOYMENT_SERVICES_CONTENT_PROVIDER;
pub const FACILITY_HSP_SERVICES = FACILITY_CODE.HSP_SERVICES;
pub const FACILITY_HSP_SOFTWARE = FACILITY_CODE.HSP_SOFTWARE;
pub const FACILITY_LINGUISTIC_SERVICES = FACILITY_CODE.LINGUISTIC_SERVICES;
pub const FACILITY_AUDIOSTREAMING = FACILITY_CODE.AUDIOSTREAMING;
pub const FACILITY_TTD = FACILITY_CODE.TTD;
pub const FACILITY_ACCELERATOR = FACILITY_CODE.ACCELERATOR;
pub const FACILITY_WMAAECMA = FACILITY_CODE.WMAAECMA;
pub const FACILITY_DIRECTMUSIC = FACILITY_CODE.DIRECTMUSIC;
pub const FACILITY_DIRECT3D10 = FACILITY_CODE.DIRECT3D10;
pub const FACILITY_DXGI = FACILITY_CODE.DXGI;
pub const FACILITY_DXGI_DDI = FACILITY_CODE.DXGI_DDI;
pub const FACILITY_DIRECT3D11 = FACILITY_CODE.DIRECT3D11;
pub const FACILITY_DIRECT3D11_DEBUG = FACILITY_CODE.DIRECT3D11_DEBUG;
pub const FACILITY_DIRECT3D12 = FACILITY_CODE.DIRECT3D12;
pub const FACILITY_DIRECT3D12_DEBUG = FACILITY_CODE.DIRECT3D12_DEBUG;
pub const FACILITY_DXCORE = FACILITY_CODE.DXCORE;
pub const FACILITY_PRESENTATION = FACILITY_CODE.PRESENTATION;
pub const FACILITY_LEAP = FACILITY_CODE.LEAP;
pub const FACILITY_AUDCLNT = FACILITY_CODE.AUDCLNT;
pub const FACILITY_WINCODEC_DWRITE_DWM = FACILITY_CODE.WINCODEC_DWRITE_DWM;
pub const FACILITY_WINML = FACILITY_CODE.WINML;
pub const FACILITY_DIRECT2D = FACILITY_CODE.DIRECT2D;
pub const FACILITY_DEFRAG = FACILITY_CODE.DEFRAG;
pub const FACILITY_USERMODE_SDBUS = FACILITY_CODE.USERMODE_SDBUS;
pub const FACILITY_JSCRIPT = FACILITY_CODE.JSCRIPT;
pub const FACILITY_PIDGENX = FACILITY_CODE.PIDGENX;
pub const FACILITY_EAS = FACILITY_CODE.EAS;
pub const FACILITY_WEB = FACILITY_CODE.WEB;
pub const FACILITY_WEB_SOCKET = FACILITY_CODE.WEB_SOCKET;
pub const FACILITY_MOBILE = FACILITY_CODE.MOBILE;
pub const FACILITY_SQLITE = FACILITY_CODE.SQLITE;
pub const FACILITY_SERVICE_FABRIC = FACILITY_CODE.SERVICE_FABRIC;
pub const FACILITY_UTC = FACILITY_CODE.UTC;
pub const FACILITY_WEP = FACILITY_CODE.WEP;
pub const FACILITY_SYNCENGINE = FACILITY_CODE.SYNCENGINE;
pub const FACILITY_XBOX = FACILITY_CODE.XBOX;
pub const FACILITY_GAME = FACILITY_CODE.GAME;
pub const FACILITY_PIX = FACILITY_CODE.PIX;
pub const FACILITY_NT_BIT = FACILITY_CODE.NT_BIT;

pub const THREAD_ERROR_MODE = enum(u32) {
    ALL_ERRORS = 0,
    FAILCRITICALERRORS = 1,
    NOGPFAULTERRORBOX = 2,
    NOOPENFILEERRORBOX = 32768,
    NOALIGNMENTFAULTEXCEPT = 4,
    _,
    pub fn initFlags(o: struct {
        ALL_ERRORS: u1 = 0,
        FAILCRITICALERRORS: u1 = 0,
        NOGPFAULTERRORBOX: u1 = 0,
        NOOPENFILEERRORBOX: u1 = 0,
        NOALIGNMENTFAULTEXCEPT: u1 = 0,
    }) THREAD_ERROR_MODE {
        return @as(THREAD_ERROR_MODE, @enumFromInt((if (o.ALL_ERRORS == 1) @intFromEnum(THREAD_ERROR_MODE.ALL_ERRORS) else 0) | (if (o.FAILCRITICALERRORS == 1) @intFromEnum(THREAD_ERROR_MODE.FAILCRITICALERRORS) else 0) | (if (o.NOGPFAULTERRORBOX == 1) @intFromEnum(THREAD_ERROR_MODE.NOGPFAULTERRORBOX) else 0) | (if (o.NOOPENFILEERRORBOX == 1) @intFromEnum(THREAD_ERROR_MODE.NOOPENFILEERRORBOX) else 0) | (if (o.NOALIGNMENTFAULTEXCEPT == 1) @intFromEnum(THREAD_ERROR_MODE.NOALIGNMENTFAULTEXCEPT) else 0)));
    }
};
pub const SEM_ALL_ERRORS = THREAD_ERROR_MODE.ALL_ERRORS;
pub const SEM_FAILCRITICALERRORS = THREAD_ERROR_MODE.FAILCRITICALERRORS;
pub const SEM_NOGPFAULTERRORBOX = THREAD_ERROR_MODE.NOGPFAULTERRORBOX;
pub const SEM_NOOPENFILEERRORBOX = THREAD_ERROR_MODE.NOOPENFILEERRORBOX;
pub const SEM_NOALIGNMENTFAULTEXCEPT = THREAD_ERROR_MODE.NOALIGNMENTFAULTEXCEPT;

pub const FORMAT_MESSAGE_OPTIONS = enum(u32) {
    ALLOCATE_BUFFER = 256,
    ARGUMENT_ARRAY = 8192,
    FROM_HMODULE = 2048,
    FROM_STRING = 1024,
    FROM_SYSTEM = 4096,
    IGNORE_INSERTS = 512,
    _,
    pub fn initFlags(o: struct {
        ALLOCATE_BUFFER: u1 = 0,
        ARGUMENT_ARRAY: u1 = 0,
        FROM_HMODULE: u1 = 0,
        FROM_STRING: u1 = 0,
        FROM_SYSTEM: u1 = 0,
        IGNORE_INSERTS: u1 = 0,
    }) FORMAT_MESSAGE_OPTIONS {
        return @as(FORMAT_MESSAGE_OPTIONS, @enumFromInt((if (o.ALLOCATE_BUFFER == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.ALLOCATE_BUFFER) else 0) | (if (o.ARGUMENT_ARRAY == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.ARGUMENT_ARRAY) else 0) | (if (o.FROM_HMODULE == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.FROM_HMODULE) else 0) | (if (o.FROM_STRING == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.FROM_STRING) else 0) | (if (o.FROM_SYSTEM == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.FROM_SYSTEM) else 0) | (if (o.IGNORE_INSERTS == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.IGNORE_INSERTS) else 0)));
    }
};
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER = FORMAT_MESSAGE_OPTIONS.ALLOCATE_BUFFER;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY = FORMAT_MESSAGE_OPTIONS.ARGUMENT_ARRAY;
pub const FORMAT_MESSAGE_FROM_HMODULE = FORMAT_MESSAGE_OPTIONS.FROM_HMODULE;
pub const FORMAT_MESSAGE_FROM_STRING = FORMAT_MESSAGE_OPTIONS.FROM_STRING;
pub const FORMAT_MESSAGE_FROM_SYSTEM = FORMAT_MESSAGE_OPTIONS.FROM_SYSTEM;
pub const FORMAT_MESSAGE_IGNORE_INSERTS = FORMAT_MESSAGE_OPTIONS.IGNORE_INSERTS;

pub const RTL_VIRTUAL_UNWIND_HANDLER_TYPE = enum(u32) {
    NHANDLER = 0,
    EHANDLER = 1,
    UHANDLER = 2,
    CHAININFO = 4,
};
pub const UNW_FLAG_NHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.NHANDLER;
pub const UNW_FLAG_EHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.EHANDLER;
pub const UNW_FLAG_UHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.UHANDLER;
pub const UNW_FLAG_CHAININFO = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.CHAININFO;

pub const OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS = enum(u32) {
    G = 1,
};
pub const WCT_ASYNC_OPEN_FLAG = OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS.G;

pub const SYM_SRV_STORE_FILE_FLAGS = enum(u32) {
    COMPRESS = 1,
    OVERWRITE = 2,
    PASS_IF_EXISTS = 64,
    POINTER = 8,
    RETURNINDEX = 4,
};
pub const SYMSTOREOPT_COMPRESS = SYM_SRV_STORE_FILE_FLAGS.COMPRESS;
pub const SYMSTOREOPT_OVERWRITE = SYM_SRV_STORE_FILE_FLAGS.OVERWRITE;
pub const SYMSTOREOPT_PASS_IF_EXISTS = SYM_SRV_STORE_FILE_FLAGS.PASS_IF_EXISTS;
pub const SYMSTOREOPT_POINTER = SYM_SRV_STORE_FILE_FLAGS.POINTER;
pub const SYMSTOREOPT_RETURNINDEX = SYM_SRV_STORE_FILE_FLAGS.RETURNINDEX;

pub const PROCESSOR_ARCHITECTURE = enum(u16) {
    AMD64 = 9,
    IA64 = 6,
    INTEL = 0,
    ARM = 5,
    UNKNOWN = 65535,
};
pub const PROCESSOR_ARCHITECTURE_AMD64 = PROCESSOR_ARCHITECTURE.AMD64;
pub const PROCESSOR_ARCHITECTURE_IA64 = PROCESSOR_ARCHITECTURE.IA64;
pub const PROCESSOR_ARCHITECTURE_INTEL = PROCESSOR_ARCHITECTURE.INTEL;
pub const PROCESSOR_ARCHITECTURE_ARM = PROCESSOR_ARCHITECTURE.ARM;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN = PROCESSOR_ARCHITECTURE.UNKNOWN;

pub const IMAGE_DIRECTORY_ENTRY = enum(u32) {
    ARCHITECTURE = 7,
    BASERELOC = 5,
    BOUND_IMPORT = 11,
    COM_DESCRIPTOR = 14,
    DEBUG = 6,
    DELAY_IMPORT = 13,
    EXCEPTION = 3,
    EXPORT = 0,
    GLOBALPTR = 8,
    IAT = 12,
    IMPORT = 1,
    LOAD_CONFIG = 10,
    RESOURCE = 2,
    SECURITY = 4,
    TLS = 9,
};
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = IMAGE_DIRECTORY_ENTRY.ARCHITECTURE;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC = IMAGE_DIRECTORY_ENTRY.BASERELOC;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = IMAGE_DIRECTORY_ENTRY.BOUND_IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = IMAGE_DIRECTORY_ENTRY.COM_DESCRIPTOR;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG = IMAGE_DIRECTORY_ENTRY.DEBUG;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = IMAGE_DIRECTORY_ENTRY.DELAY_IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION = IMAGE_DIRECTORY_ENTRY.EXCEPTION;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT = IMAGE_DIRECTORY_ENTRY.EXPORT;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR = IMAGE_DIRECTORY_ENTRY.GLOBALPTR;
pub const IMAGE_DIRECTORY_ENTRY_IAT = IMAGE_DIRECTORY_ENTRY.IAT;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT = IMAGE_DIRECTORY_ENTRY.IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = IMAGE_DIRECTORY_ENTRY.LOAD_CONFIG;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE = IMAGE_DIRECTORY_ENTRY.RESOURCE;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY = IMAGE_DIRECTORY_ENTRY.SECURITY;
pub const IMAGE_DIRECTORY_ENTRY_TLS = IMAGE_DIRECTORY_ENTRY.TLS;

pub const WAIT_CHAIN_THREAD_OPTIONS = enum(u32) {
    COM_FLAG = 2,
    CS_FLAG = 4,
    FLAG = 1,
};
pub const WCT_OUT_OF_PROC_COM_FLAG = WAIT_CHAIN_THREAD_OPTIONS.COM_FLAG;
pub const WCT_OUT_OF_PROC_CS_FLAG = WAIT_CHAIN_THREAD_OPTIONS.CS_FLAG;
pub const WCT_OUT_OF_PROC_FLAG = WAIT_CHAIN_THREAD_OPTIONS.FLAG;

pub const SYM_FIND_ID_OPTION = enum(u32) {
    DWORD = 2,
    DWORDPTR = 4,
    GUIDPTR = 8,
};
pub const SSRVOPT_DWORD = SYM_FIND_ID_OPTION.DWORD;
pub const SSRVOPT_DWORDPTR = SYM_FIND_ID_OPTION.DWORDPTR;
pub const SSRVOPT_GUIDPTR = SYM_FIND_ID_OPTION.GUIDPTR;

pub const IMAGE_FILE_CHARACTERISTICS = enum(u16) {
    RELOCS_STRIPPED = 1,
    EXECUTABLE_IMAGE = 2,
    LINE_NUMS_STRIPPED = 4,
    LOCAL_SYMS_STRIPPED = 8,
    AGGRESIVE_WS_TRIM = 16,
    LARGE_ADDRESS_AWARE = 32,
    BYTES_REVERSED_LO = 128,
    @"32BIT_MACHINE" = 256,
    DEBUG_STRIPPED = 512,
    REMOVABLE_RUN_FROM_SWAP = 1024,
    NET_RUN_FROM_SWAP = 2048,
    SYSTEM = 4096,
    DLL = 8192,
    UP_SYSTEM_ONLY = 16384,
    BYTES_REVERSED_HI = 32768,
    _,
    pub fn initFlags(o: struct {
        RELOCS_STRIPPED: u1 = 0,
        EXECUTABLE_IMAGE: u1 = 0,
        LINE_NUMS_STRIPPED: u1 = 0,
        LOCAL_SYMS_STRIPPED: u1 = 0,
        AGGRESIVE_WS_TRIM: u1 = 0,
        LARGE_ADDRESS_AWARE: u1 = 0,
        BYTES_REVERSED_LO: u1 = 0,
        @"32BIT_MACHINE": u1 = 0,
        DEBUG_STRIPPED: u1 = 0,
        REMOVABLE_RUN_FROM_SWAP: u1 = 0,
        NET_RUN_FROM_SWAP: u1 = 0,
        SYSTEM: u1 = 0,
        DLL: u1 = 0,
        UP_SYSTEM_ONLY: u1 = 0,
        BYTES_REVERSED_HI: u1 = 0,
    }) IMAGE_FILE_CHARACTERISTICS {
        return @as(IMAGE_FILE_CHARACTERISTICS, @enumFromInt((if (o.RELOCS_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.RELOCS_STRIPPED) else 0) | (if (o.EXECUTABLE_IMAGE == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.EXECUTABLE_IMAGE) else 0) | (if (o.LINE_NUMS_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.LINE_NUMS_STRIPPED) else 0) | (if (o.LOCAL_SYMS_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.LOCAL_SYMS_STRIPPED) else 0) | (if (o.AGGRESIVE_WS_TRIM == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.AGGRESIVE_WS_TRIM) else 0) | (if (o.LARGE_ADDRESS_AWARE == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.LARGE_ADDRESS_AWARE) else 0) | (if (o.BYTES_REVERSED_LO == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_LO) else 0) | (if (o.@"32BIT_MACHINE" == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.@"32BIT_MACHINE") else 0) | (if (o.DEBUG_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.DEBUG_STRIPPED) else 0) | (if (o.REMOVABLE_RUN_FROM_SWAP == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.REMOVABLE_RUN_FROM_SWAP) else 0) | (if (o.NET_RUN_FROM_SWAP == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.NET_RUN_FROM_SWAP) else 0) | (if (o.SYSTEM == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.SYSTEM) else 0) | (if (o.DLL == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.DLL) else 0) | (if (o.UP_SYSTEM_ONLY == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.UP_SYSTEM_ONLY) else 0) | (if (o.BYTES_REVERSED_HI == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_HI) else 0)));
    }
};
pub const IMAGE_FILE_RELOCS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.RELOCS_STRIPPED;
pub const IMAGE_FILE_EXECUTABLE_IMAGE = IMAGE_FILE_CHARACTERISTICS.EXECUTABLE_IMAGE;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.LINE_NUMS_STRIPPED;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.LOCAL_SYMS_STRIPPED;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM = IMAGE_FILE_CHARACTERISTICS.AGGRESIVE_WS_TRIM;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE = IMAGE_FILE_CHARACTERISTICS.LARGE_ADDRESS_AWARE;
pub const IMAGE_FILE_BYTES_REVERSED_LO = IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_LO;
pub const IMAGE_FILE_32BIT_MACHINE = IMAGE_FILE_CHARACTERISTICS.@"32BIT_MACHINE";
pub const IMAGE_FILE_DEBUG_STRIPPED = IMAGE_FILE_CHARACTERISTICS.DEBUG_STRIPPED;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = IMAGE_FILE_CHARACTERISTICS.REMOVABLE_RUN_FROM_SWAP;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP = IMAGE_FILE_CHARACTERISTICS.NET_RUN_FROM_SWAP;
pub const IMAGE_FILE_SYSTEM = IMAGE_FILE_CHARACTERISTICS.SYSTEM;
pub const IMAGE_FILE_DLL = IMAGE_FILE_CHARACTERISTICS.DLL;
pub const IMAGE_FILE_UP_SYSTEM_ONLY = IMAGE_FILE_CHARACTERISTICS.UP_SYSTEM_ONLY;
pub const IMAGE_FILE_BYTES_REVERSED_HI = IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_HI;

pub const IMAGE_FILE_CHARACTERISTICS2 = enum(u32) {
    RELOCS_STRIPPED2 = 1,
    EXECUTABLE_IMAGE2 = 2,
    LINE_NUMS_STRIPPED2 = 4,
    LOCAL_SYMS_STRIPPED2 = 8,
    AGGRESIVE_WS_TRIM2 = 16,
    LARGE_ADDRESS_AWARE2 = 32,
    BYTES_REVERSED_LO2 = 128,
    @"32BIT_MACHINE2" = 256,
    DEBUG_STRIPPED2 = 512,
    REMOVABLE_RUN_FROM_SWAP2 = 1024,
    NET_RUN_FROM_SWAP2 = 2048,
    SYSTEM_2 = 4096,
    DLL_2 = 8192,
    UP_SYSTEM_ONLY_2 = 16384,
    BYTES_REVERSED_HI_2 = 32768,
    _,
    pub fn initFlags(o: struct {
        RELOCS_STRIPPED2: u1 = 0,
        EXECUTABLE_IMAGE2: u1 = 0,
        LINE_NUMS_STRIPPED2: u1 = 0,
        LOCAL_SYMS_STRIPPED2: u1 = 0,
        AGGRESIVE_WS_TRIM2: u1 = 0,
        LARGE_ADDRESS_AWARE2: u1 = 0,
        BYTES_REVERSED_LO2: u1 = 0,
        @"32BIT_MACHINE2": u1 = 0,
        DEBUG_STRIPPED2: u1 = 0,
        REMOVABLE_RUN_FROM_SWAP2: u1 = 0,
        NET_RUN_FROM_SWAP2: u1 = 0,
        SYSTEM_2: u1 = 0,
        DLL_2: u1 = 0,
        UP_SYSTEM_ONLY_2: u1 = 0,
        BYTES_REVERSED_HI_2: u1 = 0,
    }) IMAGE_FILE_CHARACTERISTICS2 {
        return @as(IMAGE_FILE_CHARACTERISTICS2, @enumFromInt((if (o.RELOCS_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.RELOCS_STRIPPED2) else 0) | (if (o.EXECUTABLE_IMAGE2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.EXECUTABLE_IMAGE2) else 0) | (if (o.LINE_NUMS_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.LINE_NUMS_STRIPPED2) else 0) | (if (o.LOCAL_SYMS_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.LOCAL_SYMS_STRIPPED2) else 0) | (if (o.AGGRESIVE_WS_TRIM2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.AGGRESIVE_WS_TRIM2) else 0) | (if (o.LARGE_ADDRESS_AWARE2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.LARGE_ADDRESS_AWARE2) else 0) | (if (o.BYTES_REVERSED_LO2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_LO2) else 0) | (if (o.@"32BIT_MACHINE2" == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.@"32BIT_MACHINE2") else 0) | (if (o.DEBUG_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.DEBUG_STRIPPED2) else 0) | (if (o.REMOVABLE_RUN_FROM_SWAP2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.REMOVABLE_RUN_FROM_SWAP2) else 0) | (if (o.NET_RUN_FROM_SWAP2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.NET_RUN_FROM_SWAP2) else 0) | (if (o.SYSTEM_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.SYSTEM_2) else 0) | (if (o.DLL_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.DLL_2) else 0) | (if (o.UP_SYSTEM_ONLY_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.UP_SYSTEM_ONLY_2) else 0) | (if (o.BYTES_REVERSED_HI_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_HI_2) else 0)));
    }
};
pub const IMAGE_FILE_RELOCS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.RELOCS_STRIPPED2;
pub const IMAGE_FILE_EXECUTABLE_IMAGE2 = IMAGE_FILE_CHARACTERISTICS2.EXECUTABLE_IMAGE2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.LINE_NUMS_STRIPPED2;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.LOCAL_SYMS_STRIPPED2;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM2 = IMAGE_FILE_CHARACTERISTICS2.AGGRESIVE_WS_TRIM2;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE2 = IMAGE_FILE_CHARACTERISTICS2.LARGE_ADDRESS_AWARE2;
pub const IMAGE_FILE_BYTES_REVERSED_LO2 = IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_LO2;
pub const IMAGE_FILE_32BIT_MACHINE2 = IMAGE_FILE_CHARACTERISTICS2.@"32BIT_MACHINE2";
pub const IMAGE_FILE_DEBUG_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.DEBUG_STRIPPED2;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP2 = IMAGE_FILE_CHARACTERISTICS2.REMOVABLE_RUN_FROM_SWAP2;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP2 = IMAGE_FILE_CHARACTERISTICS2.NET_RUN_FROM_SWAP2;
pub const IMAGE_FILE_SYSTEM_2 = IMAGE_FILE_CHARACTERISTICS2.SYSTEM_2;
pub const IMAGE_FILE_DLL_2 = IMAGE_FILE_CHARACTERISTICS2.DLL_2;
pub const IMAGE_FILE_UP_SYSTEM_ONLY_2 = IMAGE_FILE_CHARACTERISTICS2.UP_SYSTEM_ONLY_2;
pub const IMAGE_FILE_BYTES_REVERSED_HI_2 = IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_HI_2;

pub const SYMBOL_INFO_FLAGS = enum(u32) {
    CLR_TOKEN = 262144,
    CONSTANT = 256,
    EXPORT = 512,
    FORWARDER = 1024,
    FRAMEREL = 32,
    FUNCTION = 2048,
    ILREL = 65536,
    LOCAL = 128,
    METADATA = 131072,
    PARAMETER = 64,
    REGISTER = 8,
    REGREL = 16,
    SLOT = 32768,
    THUNK = 8192,
    TLSREL = 16384,
    VALUEPRESENT = 1,
    VIRTUAL = 4096,
    _,
    pub fn initFlags(o: struct {
        CLR_TOKEN: u1 = 0,
        CONSTANT: u1 = 0,
        EXPORT: u1 = 0,
        FORWARDER: u1 = 0,
        FRAMEREL: u1 = 0,
        FUNCTION: u1 = 0,
        ILREL: u1 = 0,
        LOCAL: u1 = 0,
        METADATA: u1 = 0,
        PARAMETER: u1 = 0,
        REGISTER: u1 = 0,
        REGREL: u1 = 0,
        SLOT: u1 = 0,
        THUNK: u1 = 0,
        TLSREL: u1 = 0,
        VALUEPRESENT: u1 = 0,
        VIRTUAL: u1 = 0,
    }) SYMBOL_INFO_FLAGS {
        return @as(SYMBOL_INFO_FLAGS, @enumFromInt((if (o.CLR_TOKEN == 1) @intFromEnum(SYMBOL_INFO_FLAGS.CLR_TOKEN) else 0) | (if (o.CONSTANT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.CONSTANT) else 0) | (if (o.EXPORT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.EXPORT) else 0) | (if (o.FORWARDER == 1) @intFromEnum(SYMBOL_INFO_FLAGS.FORWARDER) else 0) | (if (o.FRAMEREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.FRAMEREL) else 0) | (if (o.FUNCTION == 1) @intFromEnum(SYMBOL_INFO_FLAGS.FUNCTION) else 0) | (if (o.ILREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.ILREL) else 0) | (if (o.LOCAL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.LOCAL) else 0) | (if (o.METADATA == 1) @intFromEnum(SYMBOL_INFO_FLAGS.METADATA) else 0) | (if (o.PARAMETER == 1) @intFromEnum(SYMBOL_INFO_FLAGS.PARAMETER) else 0) | (if (o.REGISTER == 1) @intFromEnum(SYMBOL_INFO_FLAGS.REGISTER) else 0) | (if (o.REGREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.REGREL) else 0) | (if (o.SLOT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.SLOT) else 0) | (if (o.THUNK == 1) @intFromEnum(SYMBOL_INFO_FLAGS.THUNK) else 0) | (if (o.TLSREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.TLSREL) else 0) | (if (o.VALUEPRESENT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.VALUEPRESENT) else 0) | (if (o.VIRTUAL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.VIRTUAL) else 0)));
    }
};
pub const SYMFLAG_CLR_TOKEN = SYMBOL_INFO_FLAGS.CLR_TOKEN;
pub const SYMFLAG_CONSTANT = SYMBOL_INFO_FLAGS.CONSTANT;
pub const SYMFLAG_EXPORT = SYMBOL_INFO_FLAGS.EXPORT;
pub const SYMFLAG_FORWARDER = SYMBOL_INFO_FLAGS.FORWARDER;
pub const SYMFLAG_FRAMEREL = SYMBOL_INFO_FLAGS.FRAMEREL;
pub const SYMFLAG_FUNCTION = SYMBOL_INFO_FLAGS.FUNCTION;
pub const SYMFLAG_ILREL = SYMBOL_INFO_FLAGS.ILREL;
pub const SYMFLAG_LOCAL = SYMBOL_INFO_FLAGS.LOCAL;
pub const SYMFLAG_METADATA = SYMBOL_INFO_FLAGS.METADATA;
pub const SYMFLAG_PARAMETER = SYMBOL_INFO_FLAGS.PARAMETER;
pub const SYMFLAG_REGISTER = SYMBOL_INFO_FLAGS.REGISTER;
pub const SYMFLAG_REGREL = SYMBOL_INFO_FLAGS.REGREL;
pub const SYMFLAG_SLOT = SYMBOL_INFO_FLAGS.SLOT;
pub const SYMFLAG_THUNK = SYMBOL_INFO_FLAGS.THUNK;
pub const SYMFLAG_TLSREL = SYMBOL_INFO_FLAGS.TLSREL;
pub const SYMFLAG_VALUEPRESENT = SYMBOL_INFO_FLAGS.VALUEPRESENT;
pub const SYMFLAG_VIRTUAL = SYMBOL_INFO_FLAGS.VIRTUAL;

pub const IMAGEHLP_CBA_EVENT_SEVERITY = enum(u32) {
    Info = 0,
    Problem = 1,
    Attn = 2,
    Fatal = 3,
};
// TODO: enum 'IMAGEHLP_CBA_EVENT_SEVERITY' has known issues with its value aliases

pub const IMAGEHLP_GET_TYPE_INFO_FLAGS = enum(u32) {
    CHILDREN = 2,
    UNCACHED = 1,
};
pub const IMAGEHLP_GET_TYPE_INFO_CHILDREN = IMAGEHLP_GET_TYPE_INFO_FLAGS.CHILDREN;
pub const IMAGEHLP_GET_TYPE_INFO_UNCACHED = IMAGEHLP_GET_TYPE_INFO_FLAGS.UNCACHED;

pub const RIP_INFO_TYPE = enum(u32) {
    ERROR = 1,
    MINORERROR = 2,
    WARNING = 3,
};
pub const SLE_ERROR = RIP_INFO_TYPE.ERROR;
pub const SLE_MINORERROR = RIP_INFO_TYPE.MINORERROR;
pub const SLE_WARNING = RIP_INFO_TYPE.WARNING;

pub const VER_PLATFORM = enum(u32) {
    s = 0,
    _WINDOWS = 1,
    _NT = 2,
};
pub const VER_PLATFORM_WIN32s = VER_PLATFORM.s;
pub const VER_PLATFORM_WIN32_WINDOWS = VER_PLATFORM._WINDOWS;
pub const VER_PLATFORM_WIN32_NT = VER_PLATFORM._NT;

pub const IMAGE_DEBUG_TYPE = enum(u32) {
    UNKNOWN = 0,
    COFF = 1,
    CODEVIEW = 2,
    FPO = 3,
    MISC = 4,
    EXCEPTION = 5,
    FIXUP = 6,
    BORLAND = 9,
};
pub const IMAGE_DEBUG_TYPE_UNKNOWN = IMAGE_DEBUG_TYPE.UNKNOWN;
pub const IMAGE_DEBUG_TYPE_COFF = IMAGE_DEBUG_TYPE.COFF;
pub const IMAGE_DEBUG_TYPE_CODEVIEW = IMAGE_DEBUG_TYPE.CODEVIEW;
pub const IMAGE_DEBUG_TYPE_FPO = IMAGE_DEBUG_TYPE.FPO;
pub const IMAGE_DEBUG_TYPE_MISC = IMAGE_DEBUG_TYPE.MISC;
pub const IMAGE_DEBUG_TYPE_EXCEPTION = IMAGE_DEBUG_TYPE.EXCEPTION;
pub const IMAGE_DEBUG_TYPE_FIXUP = IMAGE_DEBUG_TYPE.FIXUP;
pub const IMAGE_DEBUG_TYPE_BORLAND = IMAGE_DEBUG_TYPE.BORLAND;

pub const MINIDUMP_THREAD_INFO_DUMP_FLAGS = enum(u32) {
    ERROR_THREAD = 1,
    EXITED_THREAD = 4,
    INVALID_CONTEXT = 16,
    INVALID_INFO = 8,
    INVALID_TEB = 32,
    WRITING_THREAD = 2,
};
pub const MINIDUMP_THREAD_INFO_ERROR_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.ERROR_THREAD;
pub const MINIDUMP_THREAD_INFO_EXITED_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.EXITED_THREAD;
pub const MINIDUMP_THREAD_INFO_INVALID_CONTEXT = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_CONTEXT;
pub const MINIDUMP_THREAD_INFO_INVALID_INFO = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_INFO;
pub const MINIDUMP_THREAD_INFO_INVALID_TEB = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_TEB;
pub const MINIDUMP_THREAD_INFO_WRITING_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.WRITING_THREAD;

pub const DEBUG_EVENT_CODE = enum(u32) {
    CREATE_PROCESS_DEBUG_EVENT = 3,
    CREATE_THREAD_DEBUG_EVENT = 2,
    EXCEPTION_DEBUG_EVENT = 1,
    EXIT_PROCESS_DEBUG_EVENT = 5,
    EXIT_THREAD_DEBUG_EVENT = 4,
    LOAD_DLL_DEBUG_EVENT = 6,
    OUTPUT_DEBUG_STRING_EVENT = 8,
    RIP_EVENT = 9,
    UNLOAD_DLL_DEBUG_EVENT = 7,
};
pub const CREATE_PROCESS_DEBUG_EVENT = DEBUG_EVENT_CODE.CREATE_PROCESS_DEBUG_EVENT;
pub const CREATE_THREAD_DEBUG_EVENT = DEBUG_EVENT_CODE.CREATE_THREAD_DEBUG_EVENT;
pub const EXCEPTION_DEBUG_EVENT = DEBUG_EVENT_CODE.EXCEPTION_DEBUG_EVENT;
pub const EXIT_PROCESS_DEBUG_EVENT = DEBUG_EVENT_CODE.EXIT_PROCESS_DEBUG_EVENT;
pub const EXIT_THREAD_DEBUG_EVENT = DEBUG_EVENT_CODE.EXIT_THREAD_DEBUG_EVENT;
pub const LOAD_DLL_DEBUG_EVENT = DEBUG_EVENT_CODE.LOAD_DLL_DEBUG_EVENT;
pub const OUTPUT_DEBUG_STRING_EVENT = DEBUG_EVENT_CODE.OUTPUT_DEBUG_STRING_EVENT;
pub const RIP_EVENT = DEBUG_EVENT_CODE.RIP_EVENT;
pub const UNLOAD_DLL_DEBUG_EVENT = DEBUG_EVENT_CODE.UNLOAD_DLL_DEBUG_EVENT;

pub const MINIDUMP_MISC_INFO_FLAGS = enum(u32) {
    ID = 1,
    TIMES = 2,
    _,
    pub fn initFlags(o: struct {
        ID: u1 = 0,
        TIMES: u1 = 0,
    }) MINIDUMP_MISC_INFO_FLAGS {
        return @as(MINIDUMP_MISC_INFO_FLAGS, @enumFromInt((if (o.ID == 1) @intFromEnum(MINIDUMP_MISC_INFO_FLAGS.ID) else 0) | (if (o.TIMES == 1) @intFromEnum(MINIDUMP_MISC_INFO_FLAGS.TIMES) else 0)));
    }
};
pub const MINIDUMP_MISC1_PROCESS_ID = MINIDUMP_MISC_INFO_FLAGS.ID;
pub const MINIDUMP_MISC1_PROCESS_TIMES = MINIDUMP_MISC_INFO_FLAGS.TIMES;

pub const MODLOAD_DATA_TYPE = enum(u32) {
    DEBUGDIRS = 1,
    CVMISC = 2,
};
pub const DBHHEADER_DEBUGDIRS = MODLOAD_DATA_TYPE.DEBUGDIRS;
pub const DBHHEADER_CVMISC = MODLOAD_DATA_TYPE.CVMISC;

pub const EXCEPTION_DEBUG_INFO = extern struct {
    ExceptionRecord: EXCEPTION_RECORD,
    dwFirstChance: u32,
};

pub const CREATE_THREAD_DEBUG_INFO = extern struct {
    hThread: ?HANDLE,
    lpThreadLocalBase: ?*anyopaque,
    lpStartAddress: ?LPTHREAD_START_ROUTINE,
};

pub const CREATE_PROCESS_DEBUG_INFO = extern struct {
    hFile: ?HANDLE,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    lpBaseOfImage: ?*anyopaque,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpThreadLocalBase: ?*anyopaque,
    lpStartAddress: ?LPTHREAD_START_ROUTINE,
    lpImageName: ?*anyopaque,
    fUnicode: u16,
};

pub const EXIT_THREAD_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const EXIT_PROCESS_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const LOAD_DLL_DEBUG_INFO = extern struct {
    hFile: ?HANDLE,
    lpBaseOfDll: ?*anyopaque,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpImageName: ?*anyopaque,
    fUnicode: u16,
};

pub const UNLOAD_DLL_DEBUG_INFO = extern struct {
    lpBaseOfDll: ?*anyopaque,
};

pub const OUTPUT_DEBUG_STRING_INFO = extern struct {
    lpDebugStringData: ?PSTR,
    fUnicode: u16,
    nDebugStringLength: u16,
};

pub const RIP_INFO = extern struct {
    dwError: u32,
    dwType: RIP_INFO_TYPE,
};

pub const DEBUG_EVENT = extern struct {
    dwDebugEventCode: DEBUG_EVENT_CODE,
    dwProcessId: u32,
    dwThreadId: u32,
    u: extern union {
        Exception: EXCEPTION_DEBUG_INFO,
        CreateThread: CREATE_THREAD_DEBUG_INFO,
        CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
        ExitThread: EXIT_THREAD_DEBUG_INFO,
        ExitProcess: EXIT_PROCESS_DEBUG_INFO,
        LoadDll: LOAD_DLL_DEBUG_INFO,
        UnloadDll: UNLOAD_DLL_DEBUG_INFO,
        DebugString: OUTPUT_DEBUG_STRING_INFO,
        RipInfo: RIP_INFO,
    },
};

pub const DEBUG_OFFSET_REGION = extern struct {
    Base: u64,
    Size: u64,
};

const IID_IDebugAdvanced_Value = Guid.initString("f2df5f53-071f-47bd-9de6-5734c3fed689");
pub const IID_IDebugAdvanced = &IID_IDebugAdvanced_Value;
pub const IDebugAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced, @ptrCast(self)), Context, ContextSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_READ_USER_MINIDUMP_STREAM = extern struct {
    StreamType: u32,
    Flags: u32,
    Offset: u64,
    Buffer: ?*anyopaque,
    BufferSize: u32,
    BufferUsed: u32,
};

pub const DEBUG_GET_TEXT_COMPLETIONS_IN = extern struct {
    Flags: u32,
    MatchCountLimit: u32,
    Reserved: [3]u64,
};

pub const DEBUG_GET_TEXT_COMPLETIONS_OUT = extern struct {
    Flags: u32,
    ReplaceIndex: u32,
    MatchCount: u32,
    Reserved1: u32,
    Reserved2: [2]u64,
};

pub const DEBUG_CACHED_SYMBOL_INFO = extern struct {
    ModBase: u64,
    Arg1: u64,
    Arg2: u64,
    Id: u32,
    Arg3: u32,
};

pub const PROCESS_NAME_ENTRY = extern struct {
    ProcessId: u32,
    NameOffset: u32,
    NameSize: u32,
    NextEntry: u32,
};

pub const DEBUG_THREAD_BASIC_INFORMATION = extern struct {
    Valid: u32,
    ExitStatus: u32,
    PriorityClass: u32,
    Priority: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartOffset: u64,
    Affinity: u64,
};

const IID_IDebugAdvanced2_Value = Guid.initString("716d14c9-119b-4ba5-af1f-0890e672416a");
pub const IID_IDebugAdvanced2 = &IID_IDebugAdvanced2_Value;
pub const IDebugAdvanced2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemObjectInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced2, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced2, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_Request(self: *const T, Request: u32, InBuffer: ?*anyopaque, InBufferSize: u32, OutBuffer: ?*anyopaque, OutBufferSize: u32, OutSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).Request(@as(*const IDebugAdvanced2, @ptrCast(self)), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetSourceFileInformation(@as(*const IDebugAdvanced2, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u8, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).FindSourceFileAndToken(@as(*const IDebugAdvanced2, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetSymbolInformation(@as(*const IDebugAdvanced2, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced2_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetSystemObjectInformation(@as(*const IDebugAdvanced2, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAdvanced3_Value = Guid.initString("cba4abb4-84c4-444d-87ca-a04e13286739");
pub const IID_IDebugAdvanced3 = &IID_IDebugAdvanced3_Value;
pub const IDebugAdvanced3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemObjectInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndTokenWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced3, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced3, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_Request(self: *const T, Request: u32, InBuffer: ?*anyopaque, InBufferSize: u32, OutBuffer: ?*anyopaque, OutBufferSize: u32, OutSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).Request(@as(*const IDebugAdvanced3, @ptrCast(self)), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSourceFileInformation(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u8, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).FindSourceFileAndToken(@as(*const IDebugAdvanced3, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSymbolInformation(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSystemObjectInformation(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_GetSourceFileInformationWide(self: *const T, Which: u32, SourceFile: ?PWSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSourceFileInformationWide(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_FindSourceFileAndTokenWide(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u16, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).FindSourceFileAndTokenWide(@as(*const IDebugAdvanced3, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced3_GetSymbolInformationWide(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSymbolInformationWide(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SYMBOL_INFO_EX = extern struct {
    SizeOfStruct: u32,
    TypeOfInfo: u32,
    Offset: u64,
    Line: u32,
    Displacement: u32,
    Reserved: [4]u32,
};

const IID_IDebugAdvanced4_Value = Guid.initString("d1069067-2a65-4bf0-ae97-76184b67856b");
pub const IID_IDebugAdvanced4 = &IID_IDebugAdvanced4_Value;
pub const IDebugAdvanced4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemObjectInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndTokenWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformationWideEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
                pInfoEx: ?*SYMBOL_INFO_EX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
                pInfoEx: ?*SYMBOL_INFO_EX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced4, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced4, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_Request(self: *const T, Request: u32, InBuffer: ?*anyopaque, InBufferSize: u32, OutBuffer: ?*anyopaque, OutBufferSize: u32, OutSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).Request(@as(*const IDebugAdvanced4, @ptrCast(self)), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSourceFileInformation(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u8, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).FindSourceFileAndToken(@as(*const IDebugAdvanced4, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSymbolInformation(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSystemObjectInformation(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetSourceFileInformationWide(self: *const T, Which: u32, SourceFile: ?PWSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSourceFileInformationWide(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_FindSourceFileAndTokenWide(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u16, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).FindSourceFileAndTokenWide(@as(*const IDebugAdvanced4, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetSymbolInformationWide(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSymbolInformationWide(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAdvanced4_GetSymbolInformationWideEx(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32, pInfoEx: ?*SYMBOL_INFO_EX) HRESULT {
                return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSymbolInformationWideEx(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize, pInfoEx);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_BREAKPOINT_PARAMETERS = extern struct {
    Offset: u64,
    Id: u32,
    BreakType: u32,
    ProcType: u32,
    Flags: u32,
    DataSize: u32,
    DataAccessType: u32,
    PassCount: u32,
    CurrentPassCount: u32,
    MatchThread: u32,
    CommandSize: u32,
    OffsetExpressionSize: u32,
};

const IID_IDebugBreakpoint_Value = Guid.initString("5bd9d474-5975-423a-b88b-65a8e7110e65");
pub const IID_IDebugBreakpoint = &IID_IDebugBreakpoint_Value;
pub const IDebugBreakpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Expression: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Expression: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDebugBreakpoint, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugBreakpoint, @ptrCast(self)), BreakType, ProcType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetAdder(self: *const T, Adder: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetAdder(@as(*const IDebugBreakpoint, @ptrCast(self)), Adder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetFlags(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_AddFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).AddFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_RemoveFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).RemoveFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugBreakpoint, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const IDebugBreakpoint, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetDataParameters(@as(*const IDebugBreakpoint, @ptrCast(self)), Size, AccessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetDataParameters(self: *const T, Size: u32, AccessType: u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetDataParameters(@as(*const IDebugBreakpoint, @ptrCast(self)), Size, AccessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetPassCount(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetPassCount(@as(*const IDebugBreakpoint, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetPassCount(self: *const T, Count: u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetPassCount(@as(*const IDebugBreakpoint, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetCurrentPassCount(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetCurrentPassCount(@as(*const IDebugBreakpoint, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetMatchThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetMatchThreadId(@as(*const IDebugBreakpoint, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetMatchThreadId(self: *const T, Thread: u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetMatchThreadId(@as(*const IDebugBreakpoint, @ptrCast(self)), Thread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDebugBreakpoint, @ptrCast(self)), Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetCommand(self: *const T, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetCommand(@as(*const IDebugBreakpoint, @ptrCast(self)), Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetOffsetExpression(@as(*const IDebugBreakpoint, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_SetOffsetExpression(self: *const T, Expression: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetOffsetExpression(@as(*const IDebugBreakpoint, @ptrCast(self)), Expression);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IDebugBreakpoint, @ptrCast(self)), Params);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugBreakpoint2_Value = Guid.initString("1b278d20-79f2-426e-a3f9-c1ddf375d48e");
pub const IID_IDebugBreakpoint2 = &IID_IDebugBreakpoint2_Value;
pub const IDebugBreakpoint2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDebugBreakpoint2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugBreakpoint2, @ptrCast(self)), BreakType, ProcType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetAdder(self: *const T, Adder: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetAdder(@as(*const IDebugBreakpoint2, @ptrCast(self)), Adder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetFlags(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_AddFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).AddFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_RemoveFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).RemoveFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugBreakpoint2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const IDebugBreakpoint2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetDataParameters(@as(*const IDebugBreakpoint2, @ptrCast(self)), Size, AccessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetDataParameters(self: *const T, Size: u32, AccessType: u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetDataParameters(@as(*const IDebugBreakpoint2, @ptrCast(self)), Size, AccessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetPassCount(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetPassCount(@as(*const IDebugBreakpoint2, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetPassCount(self: *const T, Count: u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetPassCount(@as(*const IDebugBreakpoint2, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetCurrentPassCount(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetCurrentPassCount(@as(*const IDebugBreakpoint2, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetMatchThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetMatchThreadId(@as(*const IDebugBreakpoint2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetMatchThreadId(self: *const T, Thread: u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetMatchThreadId(@as(*const IDebugBreakpoint2, @ptrCast(self)), Thread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetCommand(self: *const T, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetCommand(@as(*const IDebugBreakpoint2, @ptrCast(self)), Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetOffsetExpression(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetOffsetExpression(self: *const T, Expression: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetOffsetExpression(@as(*const IDebugBreakpoint2, @ptrCast(self)), Expression);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IDebugBreakpoint2, @ptrCast(self)), Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetCommandWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetCommandWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetCommandWide(self: *const T, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetCommandWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_GetOffsetExpressionWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExpressionSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetOffsetExpressionWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint2_SetOffsetExpressionWide(self: *const T, Expression: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetOffsetExpressionWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Expression);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugBreakpoint3_Value = Guid.initString("38f5c249-b448-43bb-9835-579d4ec02249");
pub const IID_IDebugBreakpoint3 = &IID_IDebugBreakpoint3_Value;
pub const IDebugBreakpoint3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugBreakpoint3,
                Guid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugBreakpoint3,
                Guid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDebugBreakpoint3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugBreakpoint3, @ptrCast(self)), BreakType, ProcType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetAdder(self: *const T, Adder: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetAdder(@as(*const IDebugBreakpoint3, @ptrCast(self)), Adder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetFlags(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_AddFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).AddFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_RemoveFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).RemoveFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetFlags(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugBreakpoint3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const IDebugBreakpoint3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetDataParameters(@as(*const IDebugBreakpoint3, @ptrCast(self)), Size, AccessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetDataParameters(self: *const T, Size: u32, AccessType: u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetDataParameters(@as(*const IDebugBreakpoint3, @ptrCast(self)), Size, AccessType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetPassCount(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetPassCount(@as(*const IDebugBreakpoint3, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetPassCount(self: *const T, Count: u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetPassCount(@as(*const IDebugBreakpoint3, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetCurrentPassCount(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetCurrentPassCount(@as(*const IDebugBreakpoint3, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetMatchThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetMatchThreadId(@as(*const IDebugBreakpoint3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetMatchThreadId(self: *const T, Thread: u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetMatchThreadId(@as(*const IDebugBreakpoint3, @ptrCast(self)), Thread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetCommand(self: *const T, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetCommand(@as(*const IDebugBreakpoint3, @ptrCast(self)), Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetOffsetExpression(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetOffsetExpression(self: *const T, Expression: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetOffsetExpression(@as(*const IDebugBreakpoint3, @ptrCast(self)), Expression);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IDebugBreakpoint3, @ptrCast(self)), Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetCommandWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetCommandWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetCommandWide(self: *const T, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetCommandWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetOffsetExpressionWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExpressionSize: ?*u32) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetOffsetExpressionWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_SetOffsetExpressionWide(self: *const T, Expression: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetOffsetExpressionWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Expression);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugBreakpoint3_GetGuid(self: *const T, _param_Guid: ?*Guid) HRESULT {
                return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetGuid(@as(*const IDebugBreakpoint3, @ptrCast(self)), _param_Guid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_CREATE_PROCESS_OPTIONS = extern struct {
    CreateFlags: u32,
    EngCreateFlags: u32,
    VerifierFlags: u32,
    Reserved: u32,
};

pub const DEBUG_CLIENT_CONTEXT = extern struct {
    cbSize: u32,
    eClient: u32,
};

const IID_IDebugClient_Value = Guid.initString("27fe5639-8407-4f47-8364-ee118fb08ac8");
pub const IID_IDebugClient = &IID_IDebugClient_Value;
pub const IDebugClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient2_Value = Guid.initString("edbed635-372e-4dab-bbfe-ed0d2f63be81");
pub const IID_IDebugClient2 = &IID_IDebugClient2_Value;
pub const IDebugClient2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient2, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient2, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient2, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient2, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient2, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient2, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient2, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient2, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient2, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient2, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient2, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient2, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient2, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient2, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient2, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient2, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient2, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient2, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient2, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient2, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient2, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient2, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient2, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient2, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient2, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient2, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient2, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient2, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient2_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient3_Value = Guid.initString("dd492d7f-71b8-4ad6-a8dc-1c887479ff91");
pub const IID_IDebugClient3 = &IID_IDebugClient3_Value;
pub const IDebugClient3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient3, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient3, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient3, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient3, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient3, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient3, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient3, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient3, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient3, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient3, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient3, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient3, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient3, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient3, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient3, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient3, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient3, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient3, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient3, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient3, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient3, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient3, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient3, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient3, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient3, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient3, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient3, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient3, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient3_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient4_Value = Guid.initString("ca83c3de-5089-4cf8-93c8-d892387f2a5e");
pub const IID_IDebugClient4 = &IID_IDebugClient4_Value;
pub const IDebugClient4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient4, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient4, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient4, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient4, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient4, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient4, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient4, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient4, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient4, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient4, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient4, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient4, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient4, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient4, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient4, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient4, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient4, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient4, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient4, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient4, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient4, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient4, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient4, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient4, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient4, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient4, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient4, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient4, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient4, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient4, @ptrCast(self)), FileName, FileHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient4, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient4, @ptrCast(self)), FileName, FileHandle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetNumberDumpFiles(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient4, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient4_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient4, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient5_Value = Guid.initString("e3acb9d7-7ec2-4f0c-a0da-e81e0cbbe628");
pub const IID_IDebugClient5 = &IID_IDebugClient5_Value;
pub const IDebugClient5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient5,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient5,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient5, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient5, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient5, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient5, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient5, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient5, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient5, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient5, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient5, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient5, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient5, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient5, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient5, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient5, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient5, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient5, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient5, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient5, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient5, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient5, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient5, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient5, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient5, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient5, @ptrCast(self)), FileName, FileHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient5, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient5, @ptrCast(self)), FileName, FileHandle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetNumberDumpFiles(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient5, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient5, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient5, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient5, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient5, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient5, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_StartServerWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient5, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient5, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_PopOutputLinePrefix(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetNumberInputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient5, @ptrCast(self)), EventFlags, Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetQuitLockString(self: *const T, String: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient5, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient5_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient5, @ptrCast(self)), String);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient6_Value = Guid.initString("fd28b4c5-c498-4686-a28e-62cad2154eb3");
pub const IID_IDebugClient6 = &IID_IDebugClient6_Value;
pub const IDebugClient6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventContextCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient6, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient6, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient6, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient6, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient6, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient6, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient6, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient6, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient6, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient6, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient6, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient6, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient6, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient6, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient6, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient6, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient6, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient6, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient6, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient6, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient6, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient6, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient6, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient6, @ptrCast(self)), FileName, FileHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient6, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient6, @ptrCast(self)), FileName, FileHandle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetNumberDumpFiles(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient6, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient6, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient6, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient6, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient6, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient6, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_StartServerWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient6, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient6, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_PopOutputLinePrefix(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetNumberInputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient6, @ptrCast(self)), EventFlags, Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetQuitLockString(self: *const T, String: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient6, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient6, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient6_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) HRESULT {
                return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetEventContextCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient7_Value = Guid.initString("13586be3-542e-481e-b1f2-8497ba74f9a9");
pub const IID_IDebugClient7 = &IID_IDebugClient7_Value;
pub const IDebugClient7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventContextCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient7,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient7,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient7, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient7, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient7, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient7, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient7, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient7, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient7, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient7, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient7, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient7, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient7, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient7, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient7, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient7, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient7, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient7, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient7, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient7, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient7, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient7, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient7, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient7, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient7, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient7, @ptrCast(self)), FileName, FileHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient7, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient7, @ptrCast(self)), FileName, FileHandle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetNumberDumpFiles(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient7, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient7, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient7, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient7, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient7, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient7, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_StartServerWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient7, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient7, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_PopOutputLinePrefix(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetNumberInputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient7, @ptrCast(self)), EventFlags, Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetQuitLockString(self: *const T, String: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient7, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient7, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetEventContextCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient7_SetClientContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetClientContext(@as(*const IDebugClient7, @ptrCast(self)), Context, ContextSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient8_Value = Guid.initString("cec43add-6375-469e-83d5-414e4033c19a");
pub const IID_IDebugClient8 = &IID_IDebugClient8_Value;
pub const IDebugClient8 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                DumpFile: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Prefix: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                DumpFile: ?[*:0]const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                InfoFile: ?[*:0]const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Options: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Prefix: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u8,
                Environment: ?[*:0]const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]const u16,
                Environment: ?[*:0]const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                String: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                String: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventContextCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                AlternateArch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugClient8,
                FileName: ?[*:0]const u16,
                FileHandle: u64,
                AlternateArch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient8, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient8, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient8, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_DisconnectProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient8, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient8, @ptrCast(self)), Server, Ids, Count, ActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient8, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient8, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient8, @ptrCast(self)), Server, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetProcessOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AddProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_RemoveProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetProcessOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient8, @ptrCast(self)), DumpFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient8, @ptrCast(self)), DumpFile, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient8, @ptrCast(self)), Flags, HistoryLimit);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_StartServer(self: *const T, Options: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_TerminateProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_DetachProcesses(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_EndSession(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient8, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetExitCode(self: *const T, Code: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient8, @ptrCast(self)), Code);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_DispatchCallbacks(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_ExitDispatch(self: *const T, Client: ?*IDebugClient) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient8, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateClient(self: *const T, Client: ?*?*IDebugClient) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient8, @ptrCast(self)), Client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOutputMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOutputMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Client, Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOutputWidth(self: *const T, Columns: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient8, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOutputWidth(self: *const T, Columns: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient8, @ptrCast(self)), Columns);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_FlushCallbacks(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient8, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient8, @ptrCast(self)), InfoFile, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_EndProcessServer(self: *const T, Server: u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient8, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_WaitForProcessServerEnd(self: *const T, Timeout: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient8, @ptrCast(self)), Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_IsKernelDebuggerEnabled(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_TerminateCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_DetachCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AbandonCurrentProcess(self: *const T) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient8, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient8, @ptrCast(self)), Server, ExeName, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient8, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetNumberDumpFiles(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient8, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient8, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient8, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient8, @ptrCast(self)), Flags, ConnectOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*anyopaque) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient8, @ptrCast(self)), Flags, Options, Reserved);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient8, @ptrCast(self)), RemoteOptions, Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_StartServerWide(self: *const T, Options: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient8, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Machine, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient8, @ptrCast(self)), Prefix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Flags, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient8, @ptrCast(self)), NewPrefix, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_PopOutputLinePrefix(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetNumberInputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient8, @ptrCast(self)), EventFlags, Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetQuitLockString(self: *const T, String: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient8, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient8, @ptrCast(self)), String);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetEventContextCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_SetClientContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetClientContext(@as(*const IDebugClient8, @ptrCast(self)), Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugClient8_OpenDumpFileWide2(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, AlternateArch: u32) HRESULT {
                return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OpenDumpFileWide2(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle, AlternateArch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient_Value = Guid.initString("a02b66c4-aea3-4234-a9f7-fe4c383d4e29");
pub const IID_IDebugPlmClient = &IID_IDebugPlmClient_Value;
pub const IDebugPlmClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) HRESULT {
                return @as(*const IDebugPlmClient.VTable, @ptrCast(self.vtable)).LaunchPlmPackageForDebugWide(@as(*const IDebugPlmClient, @ptrCast(self)), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient2_Value = Guid.initString("597c980d-e7bd-4309-962c-9d9b69a7372c");
pub const IID_IDebugPlmClient2 = &IID_IDebugPlmClient2_Value;
pub const IDebugPlmClient2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchPlmBgTaskForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                BackgroundTaskId: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                BackgroundTaskId: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient2_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) HRESULT {
                return @as(*const IDebugPlmClient2.VTable, @ptrCast(self.vtable)).LaunchPlmPackageForDebugWide(@as(*const IDebugPlmClient2, @ptrCast(self)), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient2_LaunchPlmBgTaskForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, BackgroundTaskId: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) HRESULT {
                return @as(*const IDebugPlmClient2.VTable, @ptrCast(self.vtable)).LaunchPlmBgTaskForDebugWide(@as(*const IDebugPlmClient2, @ptrCast(self)), Server, Timeout, PackageFullName, BackgroundTaskId, ProcessId, ThreadId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient3_Value = Guid.initString("d4a5dbd1-ca02-4d90-856a-2a92bfd0f20f");
pub const IID_IDebugPlmClient3 = &IID_IDebugPlmClient3_Value;
pub const IDebugPlmClient3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchPlmBgTaskForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                BackgroundTaskId: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]const u16,
                BackgroundTaskId: ?[*:0]const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPlmPackageList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnablePlmPackageDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisablePlmPackageDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspendPlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumePlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminatePlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchAndDebugPlmAppWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
                AppName: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateAndDebugPlmBgTaskWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
                BackgroundTaskId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]const u16,
                BackgroundTaskId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).LaunchPlmPackageForDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_LaunchPlmBgTaskForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, BackgroundTaskId: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).LaunchPlmBgTaskForDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, Timeout, PackageFullName, BackgroundTaskId, ProcessId, ThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_QueryPlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16, Stream: ?*IDebugOutputStream) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).QueryPlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName, Stream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_QueryPlmPackageList(self: *const T, Server: u64, Stream: ?*IDebugOutputStream) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).QueryPlmPackageList(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, Stream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_EnablePlmPackageDebugWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).EnablePlmPackageDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_DisablePlmPackageDebugWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).DisablePlmPackageDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_SuspendPlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).SuspendPlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_ResumePlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).ResumePlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_TerminatePlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).TerminatePlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_LaunchAndDebugPlmAppWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).LaunchAndDebugPlmAppWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName, AppName, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPlmClient3_ActivateAndDebugPlmBgTaskWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16, BackgroundTaskId: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).ActivateAndDebugPlmBgTaskWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName, BackgroundTaskId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputStream_Value = Guid.initString("7782d8f2-2b85-4059-ab88-28ceddca1c80");
pub const IID_IDebugOutputStream = &IID_IDebugOutputStream_Value;
pub const IDebugOutputStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugOutputStream,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugOutputStream,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugOutputStream_Write(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugOutputStream.VTable, @ptrCast(self.vtable)).Write(@as(*const IDebugOutputStream, @ptrCast(self)), psz);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_STACK_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [6]u64,
    Virtual: BOOL,
    FrameNumber: u32,
};

pub const DEBUG_STACK_FRAME_EX = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [6]u64,
    Virtual: BOOL,
    FrameNumber: u32,
    InlineFrameContext: u32,
    Reserved1: u32,
};

pub const INLINE_FRAME_CONTEXT = extern union {
    ContextValue: u32,
    Anonymous: extern struct {
        FrameId: u8,
        FrameType: u8,
        FrameSignature: u16,
    },
};

pub const STACK_SRC_INFO = extern struct {
    ImagePath: ?[*:0]const u16,
    ModuleName: ?[*:0]const u16,
    Function: ?[*:0]const u16,
    Displacement: u32,
    Row: u32,
    Column: u32,
};

pub const STACK_SYM_FRAME_INFO = extern struct {
    StackFrameEx: DEBUG_STACK_FRAME_EX,
    SrcInfo: STACK_SRC_INFO,
};

pub const DEBUG_SPECIFIC_FILTER_PARAMETERS = extern struct {
    ExecutionOption: u32,
    ContinueOption: u32,
    TextSize: u32,
    CommandSize: u32,
    ArgumentSize: u32,
};

pub const DEBUG_EXCEPTION_FILTER_PARAMETERS = extern struct {
    ExecutionOption: u32,
    ContinueOption: u32,
    TextSize: u32,
    CommandSize: u32,
    SecondCommandSize: u32,
    ExceptionCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_BREAKPOINT = extern struct {
    Id: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXCEPTION = extern struct {
    ExceptionRecord: EXCEPTION_RECORD64,
    FirstChance: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXIT_THREAD = extern struct {
    ExitCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXIT_PROCESS = extern struct {
    ExitCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_LOAD_MODULE = extern struct {
    Base: u64,
};

pub const DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE = extern struct {
    Base: u64,
};

pub const DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR = extern struct {
    Error: u32,
    Level: u32,
};

pub const DEBUG_LAST_EVENT_INFO_SERVICE_EXCEPTION = extern struct {
    Kind: u32,
    DataSize: u32,
    Address: u64,
};

pub const DEBUG_VALUE = extern struct {
    Anonymous: extern union {
        I8: u8,
        I16: u16,
        I32: u32,
        Anonymous: extern struct {
            I64: u64,
            Nat: BOOL,
        },
        F32: f32,
        F64: f64,
        F80Bytes: [10]u8,
        F82Bytes: [11]u8,
        F128Bytes: [16]u8,
        VI8: [16]u8,
        VI16: [8]u16,
        VI32: [4]u32,
        VI64: [2]u64,
        VF32: [4]f32,
        VF64: [2]f64,
        I64Parts32: extern struct {
            LowPart: u32,
            HighPart: u32,
        },
        F128Parts64: extern struct {
            LowPart: u64,
            HighPart: i64,
        },
        RawBytes: [24]u8,
    },
    TailOfRawBytes: u32,
    Type: u32,
};

const IID_IDebugControl_Value = Guid.initString("5182e668-105e-416e-ad92-24ef800424ba");
pub const IID_IDebugControl = &IID_IDebugControl_Value;
pub const IDebugControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl2_Value = Guid.initString("d4366723-44df-4bed-8c7e-4c05424f4588");
pub const IID_IDebugControl2 = &IID_IDebugControl2_Value;
pub const IDebugControl2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl2, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl2, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl2, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl2, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl2, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl2, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl2, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl2, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl2, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl2, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl2, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl2, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl2, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl2, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl2, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl2, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl2, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl2, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl2, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl2, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl2, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl2, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl2, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl2, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl2, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl2, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl2, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl2, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl2, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl2, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl2, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl2, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl2, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl2, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl2, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl2, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl2, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl2, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl2, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl2, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl2, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl2, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl2, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl2, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl2, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl2, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl2, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl2, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl2, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl2, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl2, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl2, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl2, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl2, @ptrCast(self)), TimeDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl2, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl2, @ptrCast(self)), FormatFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl2, @ptrCast(self)), NumRepl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl2, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl2, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_RemoveTextReplacements(self: *const T) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl2_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Flags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl3_Value = Guid.initString("7df74a86-b03f-407f-90ab-a20dadcead08");
pub const IID_IDebugControl3 = &IID_IDebugControl3_Value;
pub const IDebugControl3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl3,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl3,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl3, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl3, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl3, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl3, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl3, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl3, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl3, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl3, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl3, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl3, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl3, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl3, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl3, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl3, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl3, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl3, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl3, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl3, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl3, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl3, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl3, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl3, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl3, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl3, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl3, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl3, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl3, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl3, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl3, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl3, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl3, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl3, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl3, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl3, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl3, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl3, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl3, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl3, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl3, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl3, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl3, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl3, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl3, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl3, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl3, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl3, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl3, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl3, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl3, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl3, @ptrCast(self)), TimeDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl3, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl3, @ptrCast(self)), FormatFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl3, @ptrCast(self)), NumRepl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl3, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl3, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_RemoveTextReplacements(self: *const T) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetAssemblyOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_AddAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_RemoveAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExpressionSyntax(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetExpressionSyntax(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl3, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl3, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl3, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetNumberEvents(self: *const T, Events: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl3, @ptrCast(self)), Events);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl3, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_GetCurrentEventIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl3, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl3_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl3, @ptrCast(self)), Relation, Value, NextIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl4_Value = Guid.initString("94e60ce9-9b41-4b19-9fc0-6d9eb35272b3");
pub const IID_IDebugControl4 = &IID_IDebugControl4_Value;
pub const IDebugControl4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl4, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl4, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl4, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl4, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl4, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl4, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl4, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl4, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl4, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl4, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl4, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl4, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl4, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl4, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl4, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl4, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl4, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl4, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl4, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl4, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl4, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl4, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl4, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl4, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl4, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl4, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl4, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl4, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl4, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl4, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl4, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl4, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl4, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl4, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl4, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl4, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl4, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl4, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl4, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl4, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl4, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl4, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl4, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl4, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl4, @ptrCast(self)), TimeDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl4, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl4, @ptrCast(self)), FormatFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl4, @ptrCast(self)), NumRepl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl4, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl4, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_RemoveTextReplacements(self: *const T) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetAssemblyOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AddAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_RemoveAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExpressionSyntax(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl4, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExpressionSyntax(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl4, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl4, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl4, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetNumberEvents(self: *const T, Events: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl4, @ptrCast(self)), Events);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl4, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetCurrentEventIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl4, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl4, @ptrCast(self)), Relation, Value, NextIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl4, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl4, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl4, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl4, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl4, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl4, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl4, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl4, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl4, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl4, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl4, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl4, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl4, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl4, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl4, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl4, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl4, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl4, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl4, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl4, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl4, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl4, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl4, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl4, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl4, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl4, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl4, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl4, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl4_ResetManagedStatus(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl4, @ptrCast(self)), Flags);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl5_Value = Guid.initString("b2ffe162-2412-429f-8d1d-5bf6dd824696");
pub const IID_IDebugControl5 = &IID_IDebugControl5_Value;
pub const IDebugControl5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl5,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl5,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl5, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl5, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl5, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl5, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl5, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl5, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl5, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl5, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl5, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl5, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl5, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl5, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl5, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl5, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl5, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl5, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl5, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl5, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl5, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl5, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl5, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl5, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl5, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl5, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl5, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl5, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl5, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl5, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl5, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl5, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl5, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl5, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl5, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl5, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl5, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl5, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl5, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl5, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl5, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl5, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl5, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl5, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl5, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl5, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl5, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl5, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl5, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl5, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl5, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl5, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl5, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl5, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl5, @ptrCast(self)), TimeDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl5, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl5, @ptrCast(self)), FormatFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl5, @ptrCast(self)), NumRepl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl5, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl5, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_RemoveTextReplacements(self: *const T) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetAssemblyOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AddAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_RemoveAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExpressionSyntax(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl5, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExpressionSyntax(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl5, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl5, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl5, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl5, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetNumberEvents(self: *const T, Events: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl5, @ptrCast(self)), Events);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl5, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetCurrentEventIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl5, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl5, @ptrCast(self)), Relation, Value, NextIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl5, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl5, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl5, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl5, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl5, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl5, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl5, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl5, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl5, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl5, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl5, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl5, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl5, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl5, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl5, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl5, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl5, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl5, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl5, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl5, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl5, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl5, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl5, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl5, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl5, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl5, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl5, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl5, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl5, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_ResetManagedStatus(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl5, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetContextStackTraceEx(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetContextStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputContextStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl5_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) HRESULT {
                return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointByGuid(@as(*const IDebugControl5, @ptrCast(self)), _param_Guid, Bp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl6_Value = Guid.initString("bc0d583f-126d-43a1-9cc4-a860ab1d537b");
pub const IID_IDebugControl6 = &IID_IDebugControl6_Value;
pub const IDebugControl6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatusEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSynchronizationStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl6,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl6,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl6, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl6, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl6, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl6, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl6, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl6, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl6, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl6, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl6, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl6, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl6, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl6, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl6, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl6, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl6, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl6, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl6, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl6, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl6, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl6, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl6, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl6, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl6, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl6, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl6, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl6, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl6, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl6, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl6, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl6, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl6, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl6, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl6, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl6, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl6, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl6, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl6, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl6, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl6, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl6, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl6, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl6, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl6, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl6, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl6, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl6, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl6, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl6, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl6, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl6, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl6, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl6, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl6, @ptrCast(self)), TimeDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl6, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl6, @ptrCast(self)), FormatFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl6, @ptrCast(self)), NumRepl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl6, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl6, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_RemoveTextReplacements(self: *const T) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl6, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetAssemblyOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AddAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_RemoveAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExpressionSyntax(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl6, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExpressionSyntax(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl6, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl6, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl6, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl6, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetNumberEvents(self: *const T, Events: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl6, @ptrCast(self)), Events);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl6, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetCurrentEventIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl6, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl6, @ptrCast(self)), Relation, Value, NextIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl6, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl6, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl6, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl6, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl6, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl6, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl6, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl6, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl6, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl6, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl6, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl6, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl6, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl6, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl6, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl6, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl6, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl6, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl6, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl6, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl6, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl6, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl6, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl6, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl6, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl6, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl6, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl6, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl6, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_ResetManagedStatus(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl6, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetContextStackTraceEx(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetContextStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputContextStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointByGuid(@as(*const IDebugControl6, @ptrCast(self)), _param_Guid, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetExecutionStatusEx(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExecutionStatusEx(@as(*const IDebugControl6, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl6_GetSynchronizationStatus(self: *const T, SendsAttempted: ?*u32, SecondsSinceLastResponse: ?*u32) HRESULT {
                return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSynchronizationStatus(@as(*const IDebugControl6, @ptrCast(self)), SendsAttempted, SecondsSinceLastResponse);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl7_Value = Guid.initString("b86fb3b1-80d4-475b-aea3-cf06539cf63a");
pub const IID_IDebugControl7 = &IID_IDebugControl7_Value;
pub const IDebugControl7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Expression: ?[*:0]const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]const u8,
                Arguments: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u8,
                DstText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Expression: ?[*:0]const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Path: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]const u16,
                Arguments: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                SrcText: ?[*:0]const u16,
                DstText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                File: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatusEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSynchronizationStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugControl7,
                Flags: u32,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugControl7,
                Flags: u32,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetInterrupt(self: *const T) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetInterrupt(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl7, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetInterruptTimeout(self: *const T, Seconds: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl7, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetInterruptTimeout(self: *const T, Seconds: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl7, @ptrCast(self)), Seconds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl7, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_CloseLogFile(self: *const T) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLogMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl7, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetLogMask(self: *const T, Mask: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl7, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl7, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputVersionInformation(self: *const T, OutputControl: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl7, @ptrCast(self)), OutputControl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNotifyEventHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl7, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetNotifyEventHandle(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl7, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl7, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl7, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl7, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl7, @ptrCast(self)), Offset, Delta, NearOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl7, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetReturnOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl7, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl7, @ptrCast(self)), Class, Qualifier);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetActualProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExecutingProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberProcessors(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl7, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl7, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetPageSize(self: *const T, Size: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl7, @ptrCast(self)), Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_IsPointer64Bit(self: *const T) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl7, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Types);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl7, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEffectiveProcessorType(self: *const T, Type: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetEffectiveProcessorType(self: *const T, Type: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExecutionStatus(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl7, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExecutionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl7, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetCodeLevel(self: *const T, Level: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl7, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetCodeLevel(self: *const T, Level: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl7, @ptrCast(self)), Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEngineOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AddEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_RemoveEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetEngineOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl7, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl7, @ptrCast(self)), OutputLevel, BreakLevel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl7, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl7, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetRadix(self: *const T, Radix: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl7, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetRadix(self: *const T, Radix: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl7, @ptrCast(self)), Radix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl7, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl7, @ptrCast(self)), In, OutType, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl7, @ptrCast(self)), Count, In, OutTypes, Out);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberBreakpoints(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl7, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl7, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl7, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl7, @ptrCast(self)), Count, Ids, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl7, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl7, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl7, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_RemoveExtension(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl7, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl7, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl7, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl7, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl7, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl7, @ptrCast(self)), Api);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl7, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl7, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Count, Codes, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl7, @ptrCast(self)), Flags, Timeout);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl7, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl7, @ptrCast(self)), TimeDate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl7, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl7, @ptrCast(self)), FormatFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl7, @ptrCast(self)), NumRepl);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl7, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl7, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_RemoveTextReplacements(self: *const T) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl7, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetAssemblyOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AddAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_RemoveAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetAssemblyOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExpressionSyntax(self: *const T, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl7, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExpressionSyntax(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl7, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl7, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl7, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl7, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetNumberEvents(self: *const T, Events: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl7, @ptrCast(self)), Events);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl7, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetCurrentEventIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl7, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl7, @ptrCast(self)), Relation, Value, NextIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl7, @ptrCast(self)), File, Append);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, InputSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format, Args);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl7, @ptrCast(self)), Offset, Instr, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl7, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl7, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl7, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl7, @ptrCast(self)), Slot, Macro);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl7, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Command, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, CommandFile, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl7, @ptrCast(self)), Index, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl7, @ptrCast(self)), Id, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl7, @ptrCast(self)), Type, DesiredId, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl7, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl7, @ptrCast(self)), Path, Flags, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl7, @ptrCast(self)), Path, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl7, @ptrCast(self)), Handle, Function, Arguments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl7, @ptrCast(self)), Handle, FuncName, Function);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl7, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl7, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl7, @ptrCast(self)), SrcText, DstText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl7, @ptrCast(self)), AbbrevName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl7, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl7, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl7, @ptrCast(self)), File, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl7, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl7, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl7, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl7, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl7, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl7, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl7, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_ResetManagedStatus(self: *const T, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl7, @ptrCast(self)), Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetContextStackTraceEx(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetContextStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputContextStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointByGuid(@as(*const IDebugControl7, @ptrCast(self)), _param_Guid, Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetExecutionStatusEx(self: *const T, Status: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExecutionStatusEx(@as(*const IDebugControl7, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetSynchronizationStatus(self: *const T, SendsAttempted: ?*u32, SecondsSinceLastResponse: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSynchronizationStatus(@as(*const IDebugControl7, @ptrCast(self)), SendsAttempted, SecondsSinceLastResponse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugControl7_GetDebuggeeType2(self: *const T, Flags: u32, Class: ?*u32, Qualifier: ?*u32) HRESULT {
                return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDebuggeeType2(@as(*const IDebugControl7, @ptrCast(self)), Flags, Class, Qualifier);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ALPHA = extern struct {
    Type: u32,
    Revision: u32,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_AMD64 = extern struct {
    Family: u32,
    Model: u32,
    Stepping: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_IA64 = extern struct {
    Model: u32,
    Revision: u32,
    Family: u32,
    ArchRev: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_X86 = extern struct {
    Family: u32,
    Model: u32,
    Stepping: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ARM = extern struct {
    Model: u32,
    Revision: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ARM64 = extern struct {
    Model: u32,
    Revision: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ALL = extern union {
    Alpha: DEBUG_PROCESSOR_IDENTIFICATION_ALPHA,
    Amd64: DEBUG_PROCESSOR_IDENTIFICATION_AMD64,
    Ia64: DEBUG_PROCESSOR_IDENTIFICATION_IA64,
    X86: DEBUG_PROCESSOR_IDENTIFICATION_X86,
    Arm: DEBUG_PROCESSOR_IDENTIFICATION_ARM,
    Arm64: DEBUG_PROCESSOR_IDENTIFICATION_ARM64,
};

const IID_IDebugDataSpaces_Value = Guid.initString("88f7dfab-3ea7-4c3a-aefb-c4e8106173aa");
pub const IID_IDebugDataSpaces = &IID_IDebugDataSpaces_Value;
pub const IDebugDataSpaces = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WriteMsr(self: *const T, Msr: u32, Value: u64) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_CheckLowMemory(self: *const T) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_HANDLE_DATA_BASIC = extern struct {
    TypeNameSize: u32,
    ObjectNameSize: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
};

const IID_IDebugDataSpaces2_Value = Guid.initString("7a5e852f-96e9-468f-ac1b-0b3addc4a049");
pub const IID_IDebugDataSpaces2 = &IID_IDebugDataSpaces2_Value;
pub const IDebugDataSpaces2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualToPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualTranslationPhysicalOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadHandleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces2, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces2, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces2, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces2, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces2, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WriteMsr(self: *const T, Msr: u32, Value: u64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces2, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces2, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces2, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_CheckLowMemory(self: *const T) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces2, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces2, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).VirtualToPhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Virtual, Physical);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).GetVirtualTranslationPhysicalOffsets(@as(*const IDebugDataSpaces2, @ptrCast(self)), Virtual, Offsets, OffsetsSize, Levels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadHandleData(@as(*const IDebugDataSpaces2, @ptrCast(self)), Handle, DataType, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).FillVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).FillPhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces2_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) HRESULT {
                return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).QueryVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Info);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDataSpaces3_Value = Guid.initString("23f79d6c-8aaf-4f7c-a607-9995f5407e63");
pub const IID_IDebugDataSpaces3 = &IID_IDebugDataSpaces3_Value;
pub const IDebugDataSpaces3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualToPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualTranslationPhysicalOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadHandleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadImageNtHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces3, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces3, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces3, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces3, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces3, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WriteMsr(self: *const T, Msr: u32, Value: u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces3, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces3, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces3, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_CheckLowMemory(self: *const T) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces3, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces3, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).VirtualToPhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Virtual, Physical);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).GetVirtualTranslationPhysicalOffsets(@as(*const IDebugDataSpaces3, @ptrCast(self)), Virtual, Offsets, OffsetsSize, Levels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadHandleData(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle, DataType, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).FillVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).FillPhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).QueryVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Info);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadImageNtHeaders(self: *const T, ImageBase: u64, Headers: ?*IMAGE_NT_HEADERS64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadImageNtHeaders(@as(*const IDebugDataSpaces3, @ptrCast(self)), ImageBase, Headers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_ReadTagged(self: *const T, Tag: ?*Guid, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, TotalSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Tag, Offset, Buffer, BufferSize, TotalSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_StartEnumTagged(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).StartEnumTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_GetNextTagged(self: *const T, Handle: u64, Tag: ?*Guid, Size: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).GetNextTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle, Tag, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces3_EndEnumTagged(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).EndEnumTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDataSpaces4_Value = Guid.initString("d98ada1f-29e9-4ef5-a6c0-e53349883212");
pub const IID_IDebugDataSpaces4 = &IID_IDebugDataSpaces4_Value;
pub const IDebugDataSpaces4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualToPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualTranslationPhysicalOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadHandleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadImageNtHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Space: u32,
                Which: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Space: u32,
                Which: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextDifferentlyValidOffsetVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                NextOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                NextOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValidRegionVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Base: u64,
                Size: u32,
                ValidBase: ?*u64,
                ValidSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Base: u64,
                Size: u32,
                ValidBase: ?*u64,
                ValidSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 4?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 4?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMultiByteStringVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMultiByteStringVirtualWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadUnicodeStringVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadUnicodeStringVirtualWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Count, Offset, Ptrs);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces4, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces4, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces4, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces4, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces4, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WriteMsr(self: *const T, Msr: u32, Value: u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces4, @ptrCast(self)), Msr, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces4, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces4, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_CheckLowMemory(self: *const T) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces4, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces4, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).VirtualToPhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Virtual, Physical);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetVirtualTranslationPhysicalOffsets(@as(*const IDebugDataSpaces4, @ptrCast(self)), Virtual, Offsets, OffsetsSize, Levels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadHandleData(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle, DataType, Buffer, BufferSize, DataSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).FillVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).FillPhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).QueryVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Info);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadImageNtHeaders(self: *const T, ImageBase: u64, Headers: ?*IMAGE_NT_HEADERS64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadImageNtHeaders(@as(*const IDebugDataSpaces4, @ptrCast(self)), ImageBase, Headers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadTagged(self: *const T, Tag: ?*Guid, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, TotalSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Tag, Offset, Buffer, BufferSize, TotalSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_StartEnumTagged(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).StartEnumTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_GetNextTagged(self: *const T, Handle: u64, Tag: ?*Guid, Size: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetNextTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle, Tag, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_EndEnumTagged(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).EndEnumTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_GetOffsetInformation(self: *const T, Space: u32, Which: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetOffsetInformation(@as(*const IDebugDataSpaces4, @ptrCast(self)), Space, Which, Offset, Buffer, BufferSize, InfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_GetNextDifferentlyValidOffsetVirtual(self: *const T, Offset: u64, NextOffset: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetNextDifferentlyValidOffsetVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, NextOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_GetValidRegionVirtual(self: *const T, Base: u64, Size: u32, ValidBase: ?*u64, ValidSize: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetValidRegionVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Base, Size, ValidBase, ValidSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_SearchVirtual2(self: *const T, Offset: u64, Length: u64, Flags: u32, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).SearchVirtual2(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Length, Flags, Pattern, PatternSize, PatternGranularity, MatchOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadMultiByteStringVirtual(self: *const T, Offset: u64, MaxBytes: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringBytes: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadMultiByteStringVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, Buffer, BufferSize, StringBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadMultiByteStringVirtualWide(self: *const T, Offset: u64, MaxBytes: u32, CodePage: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringBytes: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadMultiByteStringVirtualWide(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadUnicodeStringVirtual(self: *const T, Offset: u64, MaxBytes: u32, CodePage: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringBytes: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadUnicodeStringVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadUnicodeStringVirtualWide(self: *const T, Offset: u64, MaxBytes: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringBytes: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadUnicodeStringVirtualWide(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, Buffer, BufferSize, StringBytes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_ReadPhysical2(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadPhysical2(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDataSpaces4_WritePhysical2(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WritePhysical2(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BytesWritten);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugEventCallbacks_Value = Guid.initString("337be28b-5036-4d72-b6bf-c45fbb9f2eaa");
pub const IID_IDebugEventCallbacks = &IID_IDebugEventCallbacks_Value;
pub const IDebugEventCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Breakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exception: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u8,
                ImageName: ?[*:0]const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u8,
                ImageName: ?[*:0]const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) noreturn,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) noreturn,
        },
        LoadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u8,
                ImageName: ?[*:0]const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u8,
                ImageName: ?[*:0]const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                ImageBaseName: ?[*:0]const u8,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                ImageBaseName: ?[*:0]const u8,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDebuggeeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeEngineState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeSymbolState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_GetInterestMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugEventCallbacks, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).Breakpoint(@as(*const IDebugEventCallbacks, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).Exception(@as(*const IDebugEventCallbacks, @ptrCast(self)), Exception, FirstChance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).CreateThread(@as(*const IDebugEventCallbacks, @ptrCast(self)), Handle, DataOffset, StartOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_ExitThread(self: *const T, ExitCode: u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ExitThread(@as(*const IDebugEventCallbacks, @ptrCast(self)), ExitCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u8, ImageName: ?[*:0]const u8, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugEventCallbacks, @ptrCast(self)), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_ExitProcess(self: *const T, ExitCode: u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const IDebugEventCallbacks, @ptrCast(self)), ExitCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u8, ImageName: ?[*:0]const u8, CheckSum: u32, TimeDateStamp: u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).LoadModule(@as(*const IDebugEventCallbacks, @ptrCast(self)), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_UnloadModule(self: *const T, ImageBaseName: ?[*:0]const u8, BaseOffset: u64) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).UnloadModule(@as(*const IDebugEventCallbacks, @ptrCast(self)), ImageBaseName, BaseOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_SystemError(self: *const T, Error: u32, Level: u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).SystemError(@as(*const IDebugEventCallbacks, @ptrCast(self)), Error, Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_SessionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).SessionStatus(@as(*const IDebugEventCallbacks, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ChangeDebuggeeState(@as(*const IDebugEventCallbacks, @ptrCast(self)), Flags, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_ChangeEngineState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ChangeEngineState(@as(*const IDebugEventCallbacks, @ptrCast(self)), Flags, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacks_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ChangeSymbolState(@as(*const IDebugEventCallbacks, @ptrCast(self)), Flags, Argument);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugEventCallbacksWide_Value = Guid.initString("0690e046-9c23-45ac-a04f-987ac29ad0d3");
pub const IID_IDebugEventCallbacksWide = &IID_IDebugEventCallbacksWide_Value;
pub const IDebugEventCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Breakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exception: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) noreturn,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) noreturn,
        },
        LoadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                ImageBaseName: ?[*:0]const u16,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                ImageBaseName: ?[*:0]const u16,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDebuggeeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeEngineState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeSymbolState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_GetInterestMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint2) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).Breakpoint(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Bp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).Exception(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Exception, FirstChance);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).CreateThread(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Handle, DataOffset, StartOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_ExitThread(self: *const T, ExitCode: u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ExitThread(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ExitCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_ExitProcess(self: *const T, ExitCode: u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ExitCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).LoadModule(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_UnloadModule(self: *const T, ImageBaseName: ?[*:0]const u16, BaseOffset: u64) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).UnloadModule(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ImageBaseName, BaseOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_SystemError(self: *const T, Error: u32, Level: u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).SystemError(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Error, Level);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_SessionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).SessionStatus(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ChangeDebuggeeState(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Flags, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_ChangeEngineState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ChangeEngineState(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Flags, Argument);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventCallbacksWide_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ChangeSymbolState(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Flags, Argument);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_EVENT_CONTEXT = extern struct {
    Size: u32,
    ProcessEngineId: u32,
    ThreadEngineId: u32,
    FrameEngineId: u32,
};

const IID_IDebugEventContextCallbacks_Value = Guid.initString("61a4905b-23f9-4247-b3c5-53d087529ab7");
pub const IID_IDebugEventContextCallbacks = &IID_IDebugEventContextCallbacks_Value;
pub const IDebugEventContextCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Breakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Bp: ?*IDebugBreakpoint2,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Bp: ?*IDebugBreakpoint2,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exception: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 12?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 12?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) noreturn,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) noreturn,
        },
        LoadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                // TODO: what to do with BytesParamIndex 8?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]const u16,
                ImageName: ?[*:0]const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                // TODO: what to do with BytesParamIndex 8?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                ImageBaseName: ?[*:0]const u16,
                BaseOffset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                ImageBaseName: ?[*:0]const u16,
                BaseOffset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Error: u32,
                Level: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Error: u32,
                Level: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDebuggeeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeEngineState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeSymbolState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_GetInterestMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint2, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).Breakpoint(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Bp, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).Exception(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Exception, FirstChance, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).CreateThread(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Handle, DataOffset, StartOffset, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_ExitThread(self: *const T, ExitCode: u32, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ExitThread(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ExitCode, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_ExitProcess(self: *const T, ExitCode: u32, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ExitCode, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).LoadModule(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_UnloadModule(self: *const T, ImageBaseName: ?[*:0]const u16, BaseOffset: u64, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).UnloadModule(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ImageBaseName, BaseOffset, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_SystemError(self: *const T, Error: u32, Level: u32, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).SystemError(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Error, Level, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_SessionStatus(self: *const T, Status: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).SessionStatus(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Status);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ChangeDebuggeeState(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Flags, Argument, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_ChangeEngineState(self: *const T, Flags: u32, Argument: u64, Context: ?*anyopaque, ContextSize: u32) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ChangeEngineState(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Flags, Argument, Context, ContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugEventContextCallbacks_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) HRESULT {
                return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ChangeSymbolState(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Flags, Argument);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugInputCallbacks_Value = Guid.initString("9f50e42c-f136-499e-9a97-73036c94ed2d");
pub const IID_IDebugInputCallbacks = &IID_IDebugInputCallbacks_Value;
pub const IDebugInputCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugInputCallbacks,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugInputCallbacks,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugInputCallbacks_StartInput(self: *const T, BufferSize: u32) HRESULT {
                return @as(*const IDebugInputCallbacks.VTable, @ptrCast(self.vtable)).StartInput(@as(*const IDebugInputCallbacks, @ptrCast(self)), BufferSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugInputCallbacks_EndInput(self: *const T) HRESULT {
                return @as(*const IDebugInputCallbacks.VTable, @ptrCast(self.vtable)).EndInput(@as(*const IDebugInputCallbacks, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacks_Value = Guid.initString("4bf58045-d654-4c40-b0af-683090f356dc");
pub const IID_IDebugOutputCallbacks = &IID_IDebugOutputCallbacks_Value;
pub const IDebugOutputCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugOutputCallbacks,
                Mask: u32,
                Text: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugOutputCallbacks,
                Mask: u32,
                Text: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugOutputCallbacks_Output(self: *const T, Mask: u32, Text: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugOutputCallbacks.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugOutputCallbacks, @ptrCast(self)), Mask, Text);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacksWide_Value = Guid.initString("4c7fd663-c394-4e26-8ef1-34ad5ed3764c");
pub const IID_IDebugOutputCallbacksWide = &IID_IDebugOutputCallbacksWide_Value;
pub const IDebugOutputCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugOutputCallbacksWide,
                Mask: u32,
                Text: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugOutputCallbacksWide,
                Mask: u32,
                Text: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugOutputCallbacksWide_Output(self: *const T, Mask: u32, Text: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugOutputCallbacksWide.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugOutputCallbacksWide, @ptrCast(self)), Mask, Text);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacks2_Value = Guid.initString("67721fe9-56d2-4a44-a325-2b65513ce6eb");
pub const IID_IDebugOutputCallbacks2 = &IID_IDebugOutputCallbacks2_Value;
pub const IDebugOutputCallbacks2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugOutputCallbacks2,
                Mask: u32,
                Text: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugOutputCallbacks2,
                Mask: u32,
                Text: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugOutputCallbacks2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugOutputCallbacks2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugOutputCallbacks2,
                Which: u32,
                Flags: u32,
                Arg: u64,
                Text: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugOutputCallbacks2,
                Which: u32,
                Flags: u32,
                Arg: u64,
                Text: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugOutputCallbacks2_Output(self: *const T, Mask: u32, Text: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugOutputCallbacks2.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugOutputCallbacks2, @ptrCast(self)), Mask, Text);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugOutputCallbacks2_GetInterestMask(self: *const T, Mask: ?*u32) HRESULT {
                return @as(*const IDebugOutputCallbacks2.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugOutputCallbacks2, @ptrCast(self)), Mask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugOutputCallbacks2_Output2(self: *const T, Which: u32, Flags: u32, Arg: u64, Text: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugOutputCallbacks2.VTable, @ptrCast(self.vtable)).Output2(@as(*const IDebugOutputCallbacks2, @ptrCast(self)), Which, Flags, Arg, Text);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_REGISTER_DESCRIPTION = extern struct {
    Type: u32,
    Flags: u32,
    SubregMaster: u32,
    SubregLength: u32,
    SubregMask: u64,
    SubregShift: u32,
    Reserved0: u32,
};

const IID_IDebugRegisters_Value = Guid.initString("ce289126-9e84-45a7-937e-67bb18691493");
pub const IID_IDebugRegisters = &IID_IDebugRegisters_Value;
pub const IDebugRegisters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstructionOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetNumberRegisters(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetNumberRegisters(@as(*const IDebugRegisters, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDebugRegisters, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, Desc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetIndexByName(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetIndexByName(@as(*const IDebugRegisters, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugRegisters, @ptrCast(self)), Register, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_SetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IDebugRegisters, @ptrCast(self)), Register, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetValues(@as(*const IDebugRegisters, @ptrCast(self)), Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_SetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).SetValues(@as(*const IDebugRegisters, @ptrCast(self)), Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_OutputRegisters(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).OutputRegisters(@as(*const IDebugRegisters, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetInstructionOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetInstructionOffset(@as(*const IDebugRegisters, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetStackOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetStackOffset(@as(*const IDebugRegisters, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters_GetFrameOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetFrameOffset(@as(*const IDebugRegisters, @ptrCast(self)), Offset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugRegisters2_Value = Guid.initString("1656afa9-19c6-4e3a-97e7-5dc9160cf9c4");
pub const IID_IDebugRegisters2 = &IID_IDebugRegisters2_Value;
pub const IDebugRegisters2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstructionOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPseudoRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoIndexByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoIndexByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Name: ?[*:0]const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPseudoValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValues2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValues2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputRegisters2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Source: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Source: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstructionOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetNumberRegisters(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetNumberRegisters(@as(*const IDebugRegisters2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, Desc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetIndexByName(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetIndexByName(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugRegisters2, @ptrCast(self)), Register, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_SetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IDebugRegisters2, @ptrCast(self)), Register, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetValues(@as(*const IDebugRegisters2, @ptrCast(self)), Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_SetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetValues(@as(*const IDebugRegisters2, @ptrCast(self)), Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_OutputRegisters(self: *const T, OutputControl: u32, Flags: u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).OutputRegisters(@as(*const IDebugRegisters2, @ptrCast(self)), OutputControl, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetInstructionOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetInstructionOffset(@as(*const IDebugRegisters2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetStackOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetStackOffset(@as(*const IDebugRegisters2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetFrameOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetFrameOffset(@as(*const IDebugRegisters2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetDescriptionWide(self: *const T, Register: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetDescriptionWide(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, Desc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetIndexByNameWide(self: *const T, Name: ?[*:0]const u16, Index: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetIndexByNameWide(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetNumberPseudoRegisters(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetNumberPseudoRegisters(@as(*const IDebugRegisters2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetPseudoDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, TypeModule: ?*u64, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoDescription(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetPseudoDescriptionWide(self: *const T, Register: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, TypeModule: ?*u64, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoDescriptionWide(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetPseudoIndexByName(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoIndexByName(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetPseudoIndexByNameWide(self: *const T, Name: ?[*:0]const u16, Index: ?*u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoIndexByNameWide(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetPseudoValues(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoValues(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_SetPseudoValues(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetPseudoValues(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetValues2(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetValues2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_SetValues2(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetValues2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_OutputRegisters2(self: *const T, OutputControl: u32, Source: u32, Flags: u32) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).OutputRegisters2(@as(*const IDebugRegisters2, @ptrCast(self)), OutputControl, Source, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetInstructionOffset2(self: *const T, Source: u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetInstructionOffset2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetStackOffset2(self: *const T, Source: u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetStackOffset2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugRegisters2_GetFrameOffset2(self: *const T, Source: u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetFrameOffset2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Offset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_SYMBOL_PARAMETERS = extern struct {
    Module: u64,
    TypeId: u32,
    ParentSymbol: u32,
    SubElements: u32,
    Flags: u32,
    Reserved: u64,
};

const IID_IDebugSymbolGroup_Value = Guid.initString("f2528316-0f1a-4431-aeed-11d096e1e2ab");
pub const IID_IDebugSymbolGroup = &IID_IDebugSymbolGroup_Value;
pub const IDebugSymbolGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Value: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Value: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputAsType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Type: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup,
                Index: u32,
                Type: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_GetNumberSymbols(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).GetNumberSymbols(@as(*const IDebugSymbolGroup, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_AddSymbol(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).AddSymbol(@as(*const IDebugSymbolGroup, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_RemoveSymbolByName(self: *const T, Name: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).RemoveSymbolByName(@as(*const IDebugSymbolGroup, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_RemoveSymbolByIndex(self: *const T, Index: u32) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).RemoveSymbolByIndex(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_GetSymbolName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).GetSymbolName(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_GetSymbolParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SYMBOL_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).GetSymbolParameters(@as(*const IDebugSymbolGroup, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_ExpandSymbol(self: *const T, Index: u32, Expand: BOOL) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).ExpandSymbol(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Expand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_OutputSymbols(self: *const T, OutputControl: u32, Flags: u32, Start: u32, Count: u32) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).OutputSymbols(@as(*const IDebugSymbolGroup, @ptrCast(self)), OutputControl, Flags, Start, Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_WriteSymbol(self: *const T, Index: u32, Value: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).WriteSymbol(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup_OutputAsType(self: *const T, Index: u32, Type: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).OutputAsType(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Type);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_SYMBOL_ENTRY = extern struct {
    ModuleBase: u64,
    Offset: u64,
    Id: u64,
    Arg64: u64,
    Size: u32,
    Flags: u32,
    TypeId: u32,
    NameSize: u32,
    Token: u32,
    Tag: u32,
    Arg32: u32,
    Reserved: u32,
};

const IID_IDebugSymbolGroup2_Value = Guid.initString("6a7ccc5f-fb5e-4dcc-b41c-6c20307bccc7");
pub const IID_IDebugSymbolGroup2 = &IID_IDebugSymbolGroup2_Value;
pub const IDebugSymbolGroup2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputAsType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputAsTypeWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolRegister: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Register: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Register: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolValueText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolValueTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Entry: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Entry: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetNumberSymbols(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetNumberSymbols(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_AddSymbol(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).AddSymbol(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_RemoveSymbolByName(self: *const T, Name: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).RemoveSymbolByName(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_RemoveSymbolByIndex(self: *const T, Index: u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).RemoveSymbolByIndex(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolName(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SYMBOL_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolParameters(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Start, Count, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_ExpandSymbol(self: *const T, Index: u32, Expand: BOOL) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).ExpandSymbol(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Expand);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_OutputSymbols(self: *const T, OutputControl: u32, Flags: u32, Start: u32, Count: u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).OutputSymbols(@as(*const IDebugSymbolGroup2, @ptrCast(self)), OutputControl, Flags, Start, Count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_WriteSymbol(self: *const T, Index: u32, Value: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).WriteSymbol(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_OutputAsType(self: *const T, Index: u32, Type: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).OutputAsType(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_AddSymbolWide(self: *const T, Name: ?[*:0]const u16, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).AddSymbolWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_RemoveSymbolByNameWide(self: *const T, Name: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).RemoveSymbolByNameWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolNameWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolNameWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_WriteSymbolWide(self: *const T, Index: u32, Value: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).WriteSymbolWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_OutputAsTypeWide(self: *const T, Index: u32, Type: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).OutputAsTypeWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Type);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolTypeName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolTypeName(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolTypeNameWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolTypeNameWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolSize(self: *const T, Index: u32, Size: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolSize(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolOffset(self: *const T, Index: u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolOffset(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolRegister(self: *const T, Index: u32, Register: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolRegister(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Register);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolValueText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolValueText(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolValueTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolValueTextWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbolGroup2_GetSymbolEntryInformation(self: *const T, Index: u32, Entry: ?*DEBUG_SYMBOL_ENTRY) HRESULT {
                return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Entry);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_MODULE_PARAMETERS = extern struct {
    Base: u64,
    Size: u32,
    TimeDateStamp: u32,
    Checksum: u32,
    Flags: u32,
    SymbolType: u32,
    ImageNameSize: u32,
    ModuleNameSize: u32,
    LoadedImageNameSize: u32,
    SymbolFileNameSize: u32,
    MappedImageNameSize: u32,
    Reserved: [2]u64,
};

const IID_IDebugSymbols_Value = Guid.initString("8c31e98c-983a-48a5-9016-6fe5d667a950");
pub const IID_IDebugSymbols = &IID_IDebugSymbols_Value;
pub const IDebugSymbols = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSymbolOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_AddSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_RemoveSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_SetSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols, @ptrCast(self)), Loaded, Unloaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols, @ptrCast(self)), Count, Bases, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols, @ptrCast(self)), Module, TypeId, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols, @ptrCast(self)), Offset, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_ResetScope(self: *const T) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_EndSymbolMatch(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_Reload(self: *const T, Module: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_SetImagePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_SetSourcePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols2_Value = Guid.initString("3a707211-afdd-4495-ad4f-56fecdf8163f");
pub const IID_IDebugSymbols2 = &IID_IDebugSymbols2_Value;
pub const IDebugSymbols2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSymbolOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_AddSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_RemoveSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_SetSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols2, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols2, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols2, @ptrCast(self)), Loaded, Unloaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols2, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols2, @ptrCast(self)), Count, Bases, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols2, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols2, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols2, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols2, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols2, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols2, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols2, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_ResetScope(self: *const T) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols2, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols2, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols2, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols2, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_EndSymbolMatch(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols2, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_Reload(self: *const T, Module: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols2, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols2, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols2, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols2, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols2, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_SetImagePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols2, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols2, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols2, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_SetSourcePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols2, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols2, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols2, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols2, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols2, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_GetTypeOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_AddTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_RemoveTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols2_SetTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_MODULE_AND_ID = extern struct {
    ModuleBase: u64,
    Id: u64,
};

pub const DEBUG_SYMBOL_SOURCE_ENTRY = extern struct {
    ModuleBase: u64,
    Offset: u64,
    FileNameId: u64,
    EngineInternal: u64,
    Size: u32,
    Flags: u32,
    FileNameSize: u32,
    StartLine: u32,
    EndLine: u32,
    StartColumn: u32,
    EndColumn: u32,
    Reserved: u32,
};

const IID_IDebugSymbols3_Value = Guid.initString("f02fbecc-50ac-4f36-9ad9-c975e8f32ff8");
pub const IID_IDebugSymbols3 = &IID_IDebugSymbols3_Value;
pub const IDebugSymbols3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReloadWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsetsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                File: ?[*:0]const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                File: ?[*:0]const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsManagedModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u8,
                ModuleName: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u8,
                ModuleName: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u16,
                ModuleName: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u16,
                ModuleName: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromJitDebugInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromStoredEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEntryByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryByToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryBySymbolEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryBySourceEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols3,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols3,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AddSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_RemoveSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols3, @ptrCast(self)), Loaded, Unloaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols3, @ptrCast(self)), Count, Bases, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols3, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols3, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols3, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_ResetScope(self: *const T) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols3, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols3, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols3, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols3, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_EndSymbolMatch(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_Reload(self: *const T, Module: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols3, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetImagePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetSourcePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols3, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols3, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols3, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetTypeOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AddTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_RemoveTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNameByOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNearNameByOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetLineByOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByLineWide(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]const u16, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolModuleWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]const u16, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeIdWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u16, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]const u16, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolTypeIdWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup2(@as(*const IDebugSymbols3, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).CreateSymbolGroup2(@as(*const IDebugSymbols3, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).StartSymbolMatchWide(@as(*const IDebugSymbols3, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNextSymbolMatchWide(@as(*const IDebugSymbols3, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_ReloadWide(self: *const T, Module: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ReloadWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolPathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetSymbolPathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSymbolPathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSymbolPathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetImagePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetImagePathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetImagePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AppendImagePathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendImagePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePathElementWide(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetSourcePathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSourcePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AppendSourcePathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSourcePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).FindSourceFileWide(@as(*const IDebugSymbols3, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsetsWide(@as(*const IDebugSymbols3, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u16, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleVersionInformationWide(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleNameStringWide(@as(*const IDebugSymbols3, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetConstantNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_IsManagedModule(self: *const T, Index: u32, Base: u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).IsManagedModule(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByModuleName2(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2Wide(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByOffset2(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u8, ModuleName: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticModule(@as(*const IDebugSymbols3, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u16, ModuleName: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticModuleWide(@as(*const IDebugSymbols3, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_RemoveSyntheticModule(self: *const T, Base: u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveSyntheticModule(@as(*const IDebugSymbols3, @ptrCast(self)), Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndex(@as(*const IDebugSymbols3, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetScopeFrameByIndex(self: *const T, Index: u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndex(@as(*const IDebugSymbols3, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScopeFromJitDebugInfo(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, InfoOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_SetScopeFromStoredEvent(self: *const T) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScopeFromStoredEvent(@as(*const IDebugSymbols3, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).OutputSymbolByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, Flags, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BufferNeeded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFunctionEntryByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BufferNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u8, FieldTypeId: ?*u32, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u16, FieldTypeId: ?*u32, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticSymbol(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Size, Name, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticSymbolWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Size, Name, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveSyntheticSymbol(@as(*const IDebugSymbols3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Flags, Ids, Displacements, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByName(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryByToken(@as(*const IDebugSymbols3, @ptrCast(self)), ModuleBase, Token, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Info);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryString(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryStringWide(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryOffsetRegions(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Flags, Regions, RegionsCount, RegionsAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryBySymbolEntry(@as(*const IDebugSymbols3, @ptrCast(self)), FromId, Flags, ToId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntriesByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLine(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLineWide(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryString(@as(*const IDebugSymbols3, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryStringWide(@as(*const IDebugSymbols3, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryOffsetRegions(@as(*const IDebugSymbols3, @ptrCast(self)), Entry, Flags, Regions, RegionsCount, RegionsAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols3_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) HRESULT {
                return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryBySourceEntry(@as(*const IDebugSymbols3, @ptrCast(self)), FromEntry, Flags, ToEntry);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols4_Value = Guid.initString("e391bbd8-9d8c-4418-840b-c006592a1752");
pub const IID_IDebugSymbols4 = &IID_IDebugSymbols4_Value;
pub const IDebugSymbols4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReloadWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsetsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                File: ?[*:0]const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                File: ?[*:0]const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsManagedModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u8,
                ModuleName: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u8,
                ModuleName: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u16,
                ModuleName: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u16,
                ModuleName: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromJitDebugInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromStoredEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEntryByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryByToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryBySymbolEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryBySourceEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AddSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_RemoveSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols4, @ptrCast(self)), Loaded, Unloaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols4, @ptrCast(self)), Count, Bases, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols4, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_ResetScope(self: *const T) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols4, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols4, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols4, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols4, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_EndSymbolMatch(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_Reload(self: *const T, Module: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols4, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetImagePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetSourcePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols4, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols4, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols4, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetTypeOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AddTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_RemoveTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNearNameByOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByLineWide(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]const u16, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolModuleWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]const u16, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeIdWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u16, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]const u16, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolTypeIdWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup2(@as(*const IDebugSymbols4, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).CreateSymbolGroup2(@as(*const IDebugSymbols4, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).StartSymbolMatchWide(@as(*const IDebugSymbols4, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNextSymbolMatchWide(@as(*const IDebugSymbols4, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_ReloadWide(self: *const T, Module: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ReloadWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolPathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetSymbolPathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSymbolPathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSymbolPathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetImagePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetImagePathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetImagePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AppendImagePathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendImagePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePathElementWide(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetSourcePathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSourcePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AppendSourcePathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSourcePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).FindSourceFileWide(@as(*const IDebugSymbols4, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsetsWide(@as(*const IDebugSymbols4, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u16, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleVersionInformationWide(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleNameStringWide(@as(*const IDebugSymbols4, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetConstantNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_IsManagedModule(self: *const T, Index: u32, Base: u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).IsManagedModule(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByModuleName2(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2Wide(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByOffset2(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u8, ModuleName: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticModule(@as(*const IDebugSymbols4, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u16, ModuleName: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticModuleWide(@as(*const IDebugSymbols4, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_RemoveSyntheticModule(self: *const T, Base: u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveSyntheticModule(@as(*const IDebugSymbols4, @ptrCast(self)), Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndex(@as(*const IDebugSymbols4, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetScopeFrameByIndex(self: *const T, Index: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndex(@as(*const IDebugSymbols4, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeFromJitDebugInfo(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, InfoOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetScopeFromStoredEvent(self: *const T) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeFromStoredEvent(@as(*const IDebugSymbols4, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputSymbolByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Flags, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BufferNeeded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFunctionEntryByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BufferNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u8, FieldTypeId: ?*u32, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u16, FieldTypeId: ?*u32, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticSymbol(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Size, Name, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticSymbolWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Size, Name, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveSyntheticSymbol(@as(*const IDebugSymbols4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Flags, Ids, Displacements, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByName(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryByToken(@as(*const IDebugSymbols4, @ptrCast(self)), ModuleBase, Token, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Info);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryString(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryStringWide(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryOffsetRegions(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Flags, Regions, RegionsCount, RegionsAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryBySymbolEntry(@as(*const IDebugSymbols4, @ptrCast(self)), FromId, Flags, ToId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntriesByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLine(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLineWide(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryString(@as(*const IDebugSymbols4, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryStringWide(@as(*const IDebugSymbols4, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryOffsetRegions(@as(*const IDebugSymbols4, @ptrCast(self)), Entry, Flags, Regions, RegionsCount, RegionsAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryBySourceEntry(@as(*const IDebugSymbols4, @ptrCast(self)), FromEntry, Flags, ToEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetScopeEx(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScopeEx(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_SetScopeEx(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeEx(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNameByInlineContext(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByInlineContext(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetNameByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByInlineContextWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetLineByInlineContext(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByInlineContext(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_GetLineByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByInlineContextWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols4_OutputSymbolByInlineContext(self: *const T, OutputControl: u32, Flags: u32, Offset: u64, InlineContext: u32) HRESULT {
                return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputSymbolByInlineContext(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Flags, Offset, InlineContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols5_Value = Guid.initString("c65fa83e-1e69-475e-8e0e-b5d79e9cc17e");
pub const IID_IDebugSymbols5 = &IID_IDebugSymbols5_Value;
pub const IDebugSymbols5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                File: ?[*:0]const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReloadWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Path: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Addition: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsetsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                File: ?[*:0]const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                File: ?[*:0]const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsManagedModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Name: ?[*:0]const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u8,
                ModuleName: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u8,
                ModuleName: ?[*:0]const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u16,
                ModuleName: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]const u16,
                ModuleName: ?[*:0]const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromJitDebugInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromStoredEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEntryByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryByToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryBySymbolEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryBySourceEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndexEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndexEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AddSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_RemoveSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetSymbolOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols5, @ptrCast(self)), Loaded, Unloaded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols5, @ptrCast(self)), Count, Bases, Start, Params);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols5, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_ResetScope(self: *const T) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols5, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols5, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols5, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_EndSymbolMatch(self: *const T, Handle: u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols5, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_Reload(self: *const T, Module: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols5, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetImagePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetSourcePath(self: *const T, Path: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols5, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols5, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols5, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetTypeOptions(self: *const T, Options: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AddTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_RemoveTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetTypeOptions(self: *const T, Options: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNearNameByOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByLineWide(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]const u16, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolModuleWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]const u16, TypeId: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeIdWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, Name, TypeId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u16, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Field, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]const u16, TypeId: ?*u32, Module: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolTypeIdWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, TypeId, Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup2(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Update, Symbols);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).CreateSymbolGroup2(@as(*const IDebugSymbols5, @ptrCast(self)), Group);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]const u16, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).StartSymbolMatchWide(@as(*const IDebugSymbols5, @ptrCast(self)), Pattern, Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNextSymbolMatchWide(@as(*const IDebugSymbols5, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_ReloadWide(self: *const T, Module: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ReloadWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolPathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetSymbolPathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSymbolPathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSymbolPathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetImagePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetImagePathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetImagePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AppendImagePathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendImagePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePathElementWide(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetSourcePathWide(self: *const T, Path: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSourcePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AppendSourcePathWide(self: *const T, Addition: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSourcePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).FindSourceFileWide(@as(*const IDebugSymbols5, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsetsWide(@as(*const IDebugSymbols5, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u16, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleVersionInformationWide(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleNameStringWide(@as(*const IDebugSymbols5, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetConstantNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_IsManagedModule(self: *const T, Index: u32, Base: u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).IsManagedModule(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByModuleName2(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2Wide(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByOffset2(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, StartIndex, Flags, Index, Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u8, ModuleName: ?[*:0]const u8, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticModule(@as(*const IDebugSymbols5, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u16, ModuleName: ?[*:0]const u16, Flags: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticModuleWide(@as(*const IDebugSymbols5, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_RemoveSyntheticModule(self: *const T, Base: u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveSyntheticModule(@as(*const IDebugSymbols5, @ptrCast(self)), Base);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndex(@as(*const IDebugSymbols5, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetScopeFrameByIndex(self: *const T, Index: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndex(@as(*const IDebugSymbols5, @ptrCast(self)), Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFromJitDebugInfo(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, InfoOffset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetScopeFromStoredEvent(self: *const T) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFromStoredEvent(@as(*const IDebugSymbols5, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputSymbolByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Flags, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BufferNeeded: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFunctionEntryByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BufferNeeded);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u8, FieldTypeId: ?*u32, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u16, FieldTypeId: ?*u32, Offset: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticSymbol(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Size, Name, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticSymbolWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Size, Name, Flags, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveSyntheticSymbol(@as(*const IDebugSymbols5, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Flags, Ids, Displacements, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByName(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryByToken(@as(*const IDebugSymbols5, @ptrCast(self)), ModuleBase, Token, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Info);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryString(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryStringWide(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryOffsetRegions(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Flags, Regions, RegionsCount, RegionsAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryBySymbolEntry(@as(*const IDebugSymbols5, @ptrCast(self)), FromId, Flags, ToId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntriesByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLine(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLineWide(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryString(@as(*const IDebugSymbols5, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryStringWide(@as(*const IDebugSymbols5, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryOffsetRegions(@as(*const IDebugSymbols5, @ptrCast(self)), Entry, Flags, Regions, RegionsCount, RegionsAvail);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryBySourceEntry(@as(*const IDebugSymbols5, @ptrCast(self)), FromEntry, Flags, ToEntry);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetScopeEx(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScopeEx(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetScopeEx(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeEx(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNameByInlineContext(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByInlineContext(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetNameByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByInlineContextWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetLineByInlineContext(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByInlineContext(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetLineByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByInlineContextWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_OutputSymbolByInlineContext(self: *const T, OutputControl: u32, Flags: u32, Offset: u64, InlineContext: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputSymbolByInlineContext(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Flags, Offset, InlineContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_GetCurrentScopeFrameIndexEx(self: *const T, Flags: u32, Index: ?*u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndexEx(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Index);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSymbols5_SetScopeFrameByIndexEx(self: *const T, Flags: u32, Index: u32) HRESULT {
                return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndexEx(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Index);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects_Value = Guid.initString("6b86fe2c-2c4f-4f0c-9da2-174311acc327");
pub const IID_IDebugSystemObjects = &IID_IDebugSystemObjects_Value;
pub const IDebugSystemObjects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetEventThread(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetEventProcess(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_SetCurrentThreadId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentProcessId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_SetCurrentProcessId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetNumberThreads(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects, @ptrCast(self)), Total, LargestProcess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects, @ptrCast(self)), Processor, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetNumberProcesses(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects, @ptrCast(self)), Buffer, BufferSize, ExeSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects2_Value = Guid.initString("0ae9f5ff-1852-4679-b055-494bee6407ee");
pub const IID_IDebugSystemObjects2 = &IID_IDebugSystemObjects2_Value;
pub const IDebugSystemObjects2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetEventThread(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetEventProcess(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_SetCurrentThreadId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_SetCurrentProcessId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetNumberThreads(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects2, @ptrCast(self)), Total, LargestProcess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects2, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects2, @ptrCast(self)), Processor, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetNumberProcesses(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects2, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects2, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects2, @ptrCast(self)), Buffer, BufferSize, ExeSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessUpTime(@as(*const IDebugSystemObjects2, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetImplicitThreadDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_SetImplicitThreadDataOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetImplicitThreadDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetImplicitProcessDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects2_SetImplicitProcessDataOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetImplicitProcessDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects3_Value = Guid.initString("e9676e2f-e286-4ea3-b0f9-dfe5d9fc330e");
pub const IID_IDebugSystemObjects3 = &IID_IDebugSystemObjects3_Value;
pub const IDebugSystemObjects3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSystems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreadsAndProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemByServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetEventThread(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetEventProcess(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_SetCurrentThreadId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_SetCurrentProcessId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetNumberThreads(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects3, @ptrCast(self)), Total, LargestProcess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects3, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects3, @ptrCast(self)), Processor, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetNumberProcesses(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects3, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects3, @ptrCast(self)), Buffer, BufferSize, ExeSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessUpTime(@as(*const IDebugSystemObjects3, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetImplicitThreadDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_SetImplicitThreadDataOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetImplicitThreadDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetImplicitProcessDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_SetImplicitProcessDataOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetImplicitProcessDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetEventSystem(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetEventSystem(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentSystemId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_SetCurrentSystemId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetCurrentSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetNumberSystems(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetNumberSystems(@as(*const IDebugSystemObjects3, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetSystemIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: [*]u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetSystemIdsByIndex(@as(*const IDebugSystemObjects3, @ptrCast(self)), Start, Count, Ids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetTotalNumberThreadsAndProcesses(self: *const T, TotalThreads: ?*u32, TotalProcesses: ?*u32, LargestProcessThreads: ?*u32, LargestSystemThreads: ?*u32, LargestSystemProcesses: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetTotalNumberThreadsAndProcesses(@as(*const IDebugSystemObjects3, @ptrCast(self)), TotalThreads, TotalProcesses, LargestProcessThreads, LargestSystemThreads, LargestSystemProcesses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentSystemServer(self: *const T, Server: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentSystemServer(@as(*const IDebugSystemObjects3, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetSystemByServer(self: *const T, Server: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetSystemByServer(@as(*const IDebugSystemObjects3, @ptrCast(self)), Server, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects3_GetCurrentSystemServerName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentSystemServerName(@as(*const IDebugSystemObjects3, @ptrCast(self)), Buffer, BufferSize, NameSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects4_Value = Guid.initString("489468e6-7d0f-4af5-87ab-25207454d553");
pub const IID_IDebugSystemObjects4 = &IID_IDebugSystemObjects4_Value;
pub const IDebugSystemObjects4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSystems: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreadsAndProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemByServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServerNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetEventThread(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetEventProcess(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentThreadId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_SetCurrentThreadId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_SetCurrentProcessId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetNumberThreads(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects4, @ptrCast(self)), Total, LargestProcess);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects4, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects4, @ptrCast(self)), Processor, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetNumberProcesses(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects4, @ptrCast(self)), Start, Count, Ids, SysIds);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, ExeSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessUpTime(@as(*const IDebugSystemObjects4, @ptrCast(self)), UpTime);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetImplicitThreadDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_SetImplicitThreadDataOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetImplicitThreadDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetImplicitProcessDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_SetImplicitProcessDataOffset(self: *const T, Offset: u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetImplicitProcessDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetEventSystem(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetEventSystem(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentSystemId(self: *const T, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_SetCurrentSystemId(self: *const T, Id: u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetCurrentSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetNumberSystems(self: *const T, Number: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetNumberSystems(@as(*const IDebugSystemObjects4, @ptrCast(self)), Number);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetSystemIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: [*]u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetSystemIdsByIndex(@as(*const IDebugSystemObjects4, @ptrCast(self)), Start, Count, Ids);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetTotalNumberThreadsAndProcesses(self: *const T, TotalThreads: ?*u32, TotalProcesses: ?*u32, LargestProcessThreads: ?*u32, LargestSystemThreads: ?*u32, LargestSystemProcesses: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetTotalNumberThreadsAndProcesses(@as(*const IDebugSystemObjects4, @ptrCast(self)), TotalThreads, TotalProcesses, LargestProcessThreads, LargestSystemThreads, LargestSystemProcesses);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentSystemServer(self: *const T, Server: ?*u64) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemServer(@as(*const IDebugSystemObjects4, @ptrCast(self)), Server);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetSystemByServer(self: *const T, Server: u64, Id: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetSystemByServer(@as(*const IDebugSystemObjects4, @ptrCast(self)), Server, Id);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentSystemServerName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemServerName(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, NameSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentProcessExecutableNameWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExeSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableNameWide(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, ExeSize);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSystemObjects4_GetCurrentSystemServerNameWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) HRESULT {
                return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemServerNameWide(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, NameSize);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PDEBUG_EXTENSION_INITIALIZE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Version: ?*u32,
        Flags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Version: ?*u32,
        Flags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_EXTENSION_UNINITIALIZE = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const PDEBUG_EXTENSION_CANUNLOAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_EXTENSION_UNLOAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) void,
};

pub const PDEBUG_EXTENSION_NOTIFY = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Notify: u32,
        Argument: u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        Notify: u32,
        Argument: u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PDEBUG_EXTENSION_CALL = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Client: ?*IDebugClient,
        Args: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Client: ?*IDebugClient,
        Args: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_EXTENSION_KNOWN_STRUCT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Flags: u32,
        Offset: u64,
        TypeName: ?PSTR,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Flags: u32,
        Offset: u64,
        TypeName: ?PSTR,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_EXTENSION_KNOWN_STRUCT_EX = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Client: ?*IDebugClient,
        Flags: u32,
        Offset: u64,
        TypeName: ?[*:0]const u8,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Client: ?*IDebugClient,
        Flags: u32,
        Offset: u64,
        TypeName: ?[*:0]const u8,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_EXTENSION_QUERY_VALUE_NAMES = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Client: ?*IDebugClient,
        Flags: u32,
        Buffer: [*:0]u16,
        BufferChars: u32,
        BufferNeeded: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Client: ?*IDebugClient,
        Flags: u32,
        Buffer: [*:0]u16,
        BufferChars: u32,
        BufferNeeded: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_EXTENSION_PROVIDE_VALUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Client: ?*IDebugClient,
        Flags: u32,
        Name: ?[*:0]const u16,
        Value: ?*u64,
        TypeModBase: ?*u64,
        TypeId: ?*u32,
        TypeFlags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        Client: ?*IDebugClient,
        Flags: u32,
        Name: ?[*:0]const u16,
        Value: ?*u64,
        TypeModBase: ?*u64,
        TypeId: ?*u32,
        TypeFlags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        StreamType: u32,
        MiniDumpStreamBuffer: [*]u8,
        BufferSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        StreamType: u32,
        MiniDumpStreamBuffer: [*]u8,
        BufferSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        SystemThreadId: u32,
        NativeFrames: [*]DEBUG_STACK_FRAME_EX,
        CountNativeFrames: u32,
        StackSymFrames: ?*?*STACK_SYM_FRAME_INFO,
        StackSymFramesFilled: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        SystemThreadId: u32,
        NativeFrames: [*]DEBUG_STACK_FRAME_EX,
        CountNativeFrames: u32,
        StackSymFrames: ?*?*STACK_SYM_FRAME_INFO,
        StackSymFramesFilled: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        StackSymFrames: ?*STACK_SYM_FRAME_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        StackSymFrames: ?*STACK_SYM_FRAME_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const DebugBaseEventCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IDebugEventCallbacks.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugEventCallbacks.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DebugBaseEventCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IDebugEventCallbacksWide.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugEventCallbacksWide.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const Location = extern struct {
    HostDefined: u64,
    Offset: u64,
};

pub const ModelObjectKind = enum(i32) {
    PropertyAccessor = 0,
    Context = 1,
    TargetObject = 2,
    TargetObjectReference = 3,
    Synthetic = 4,
    NoValue = 5,
    Error = 6,
    Intrinsic = 7,
    Method = 8,
    KeyReference = 9,
};
pub const ObjectPropertyAccessor = ModelObjectKind.PropertyAccessor;
pub const ObjectContext = ModelObjectKind.Context;
pub const ObjectTargetObject = ModelObjectKind.TargetObject;
pub const ObjectTargetObjectReference = ModelObjectKind.TargetObjectReference;
pub const ObjectSynthetic = ModelObjectKind.Synthetic;
pub const ObjectNoValue = ModelObjectKind.NoValue;
pub const ObjectError = ModelObjectKind.Error;
pub const ObjectIntrinsic = ModelObjectKind.Intrinsic;
pub const ObjectMethod = ModelObjectKind.Method;
pub const ObjectKeyReference = ModelObjectKind.KeyReference;

pub const SymbolKind = enum(i32) {
    l = 0,
    Module = 1,
    Type = 2,
    Field = 3,
    Constant = 4,
    Data = 5,
    BaseClass = 6,
    Public = 7,
    Function = 8,
};
pub const Symbol = SymbolKind.l;
pub const SymbolModule = SymbolKind.Module;
pub const SymbolType = SymbolKind.Type;
pub const SymbolField = SymbolKind.Field;
pub const SymbolConstant = SymbolKind.Constant;
pub const SymbolData = SymbolKind.Data;
pub const SymbolBaseClass = SymbolKind.BaseClass;
pub const SymbolPublic = SymbolKind.Public;
pub const SymbolFunction = SymbolKind.Function;

pub const TypeKind = enum(i32) {
    UDT = 0,
    Pointer = 1,
    MemberPointer = 2,
    Array = 3,
    Function = 4,
    Typedef = 5,
    Enum = 6,
    Intrinsic = 7,
    ExtendedArray = 8,
};
pub const TypeUDT = TypeKind.UDT;
pub const TypePointer = TypeKind.Pointer;
pub const TypeMemberPointer = TypeKind.MemberPointer;
pub const TypeArray = TypeKind.Array;
pub const TypeFunction = TypeKind.Function;
pub const TypeTypedef = TypeKind.Typedef;
pub const TypeEnum = TypeKind.Enum;
pub const TypeIntrinsic = TypeKind.Intrinsic;
pub const TypeExtendedArray = TypeKind.ExtendedArray;

pub const IntrinsicKind = enum(i32) {
    Void = 0,
    Bool = 1,
    Char = 2,
    WChar = 3,
    Int = 4,
    UInt = 5,
    Long = 6,
    ULong = 7,
    Float = 8,
    HRESULT = 9,
    Char16 = 10,
    Char32 = 11,
};
pub const IntrinsicVoid = IntrinsicKind.Void;
pub const IntrinsicBool = IntrinsicKind.Bool;
pub const IntrinsicChar = IntrinsicKind.Char;
pub const IntrinsicWChar = IntrinsicKind.WChar;
pub const IntrinsicInt = IntrinsicKind.Int;
pub const IntrinsicUInt = IntrinsicKind.UInt;
pub const IntrinsicLong = IntrinsicKind.Long;
pub const IntrinsicULong = IntrinsicKind.ULong;
pub const IntrinsicFloat = IntrinsicKind.Float;
pub const IntrinsicHRESULT = IntrinsicKind.HRESULT;
pub const IntrinsicChar16 = IntrinsicKind.Char16;
pub const IntrinsicChar32 = IntrinsicKind.Char32;

pub const PointerKind = enum(i32) {
    Standard = 0,
    Reference = 1,
    RValueReference = 2,
    CXHat = 3,
    ManagedReference = 4,
};
pub const PointerStandard = PointerKind.Standard;
pub const PointerReference = PointerKind.Reference;
pub const PointerRValueReference = PointerKind.RValueReference;
pub const PointerCXHat = PointerKind.CXHat;
pub const PointerManagedReference = PointerKind.ManagedReference;

pub const CallingConventionKind = enum(i32) {
    Unknown = 0,
    CDecl = 1,
    FastCall = 2,
    StdCall = 3,
    SysCall = 4,
    ThisCall = 5,
};
pub const CallingConventionUnknown = CallingConventionKind.Unknown;
pub const CallingConventionCDecl = CallingConventionKind.CDecl;
pub const CallingConventionFastCall = CallingConventionKind.FastCall;
pub const CallingConventionStdCall = CallingConventionKind.StdCall;
pub const CallingConventionSysCall = CallingConventionKind.SysCall;
pub const CallingConventionThisCall = CallingConventionKind.ThisCall;

pub const LocationKind = enum(i32) {
    Member = 0,
    Static = 1,
    Constant = 2,
    None = 3,
};
pub const LocationMember = LocationKind.Member;
pub const LocationStatic = LocationKind.Static;
pub const LocationConstant = LocationKind.Constant;
pub const LocationNone = LocationKind.None;

pub const PreferredFormat = enum(i32) {
    None = 0,
    SingleCharacter = 1,
    QuotedString = 2,
    String = 3,
    QuotedUnicodeString = 4,
    UnicodeString = 5,
    QuotedUTF8String = 6,
    UTF8String = 7,
    BSTRString = 8,
    QuotedHString = 9,
    HString = 10,
    Raw = 11,
    EnumNameOnly = 12,
    EscapedStringWithQuote = 13,
    UTF32String = 14,
    QuotedUTF32String = 15,
};
pub const FormatNone = PreferredFormat.None;
pub const FormatSingleCharacter = PreferredFormat.SingleCharacter;
pub const FormatQuotedString = PreferredFormat.QuotedString;
pub const FormatString = PreferredFormat.String;
pub const FormatQuotedUnicodeString = PreferredFormat.QuotedUnicodeString;
pub const FormatUnicodeString = PreferredFormat.UnicodeString;
pub const FormatQuotedUTF8String = PreferredFormat.QuotedUTF8String;
pub const FormatUTF8String = PreferredFormat.UTF8String;
pub const FormatBSTRString = PreferredFormat.BSTRString;
pub const FormatQuotedHString = PreferredFormat.QuotedHString;
pub const FormatHString = PreferredFormat.HString;
pub const FormatRaw = PreferredFormat.Raw;
pub const FormatEnumNameOnly = PreferredFormat.EnumNameOnly;
pub const FormatEscapedStringWithQuote = PreferredFormat.EscapedStringWithQuote;
pub const FormatUTF32String = PreferredFormat.UTF32String;
pub const FormatQuotedUTF32String = PreferredFormat.QuotedUTF32String;

const IID_IHostDataModelAccess_Value = Guid.initString("f2bce54e-4835-4f8a-836e-7981e29904d1");
pub const IID_IHostDataModelAccess = &IID_IHostDataModelAccess_Value;
pub const IHostDataModelAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IHostDataModelAccess,
                manager: ?*?*IDataModelManager,
                host: ?*?*IDebugHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IHostDataModelAccess,
                manager: ?*?*IDataModelManager,
                host: ?*?*IDebugHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IHostDataModelAccess_GetDataModel(self: *const T, manager: ?*?*IDataModelManager, host: ?*?*IDebugHost) HRESULT {
                return @as(*const IHostDataModelAccess.VTable, @ptrCast(self.vtable)).GetDataModel(@as(*const IHostDataModelAccess, @ptrCast(self)), manager, host);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IKeyStore_Value = Guid.initString("0fc7557d-401d-4fca-9365-da1e9850697c");
pub const IID_IKeyStore = &IID_IKeyStore_Value;
pub const IKeyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyStore,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyStore_GetKey(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IKeyStore, @ptrCast(self)), key, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyStore_SetKey(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject, metadata: ?*IKeyStore) HRESULT {
                return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IKeyStore, @ptrCast(self)), key, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyStore_GetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).GetKeyValue(@as(*const IKeyStore, @ptrCast(self)), key, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyStore_SetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject) HRESULT {
                return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).SetKeyValue(@as(*const IKeyStore, @ptrCast(self)), key, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyStore_ClearKeys(self: *const T) HRESULT {
                return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).ClearKeys(@as(*const IKeyStore, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const RawSearchFlags = enum(i32) {
    ne = 0,
    Bases = 1,
};
pub const RawSearchNone = RawSearchFlags.ne;
pub const RawSearchNoBases = RawSearchFlags.Bases;

const IID_IModelObject_Value = Guid.initString("e28c7893-3f4b-4b96-baca-293cdc55f45d");
pub const IID_IModelObject = &IID_IModelObject_Value;
pub const IModelObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                kind: ?*ModelObjectKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                kind: ?*ModelObjectKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicValueAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                vt: u16,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                vt: u16,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeyValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateRawValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Dereference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TryCastToRuntimeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                runtimeTypedObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                runtimeTypedObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTargetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                location: ?*Location,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                location: ?*Location,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfParentModels: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                numModels: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                numModels: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                i: u64,
                model: ?*?*IModelObject,
                contextObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                i: u64,
                model: ?*?*IModelObject,
                contextObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddParentModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                model: ?*IModelObject,
                contextObject: ?*IModelObject,
                override: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                model: ?*IModelObject,
                contextObject: ?*IModelObject,
                override: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveParentModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                model: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                model: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                objectReference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                objectReference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                key: ?[*:0]const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeyReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearConcepts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateRawReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContextForDataModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextForDataModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                other: ?*IModelObject,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                other: ?*IModelObject,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqualTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelObject,
                other: ?*IModelObject,
                equal: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelObject,
                other: ?*IModelObject,
                equal: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetContext(self: *const T, context: ?*?*IDebugHostContext) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IModelObject, @ptrCast(self)), context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetKind(self: *const T, kind: ?*ModelObjectKind) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKind(@as(*const IModelObject, @ptrCast(self)), kind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetIntrinsicValue(self: *const T, intrinsicData: ?*VARIANT) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetIntrinsicValue(@as(*const IModelObject, @ptrCast(self)), intrinsicData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetIntrinsicValueAs(self: *const T, vt: u16, intrinsicData: ?*VARIANT) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetIntrinsicValueAs(@as(*const IModelObject, @ptrCast(self)), vt, intrinsicData);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKeyValue(@as(*const IModelObject, @ptrCast(self)), key, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_SetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetKeyValue(@as(*const IModelObject, @ptrCast(self)), key, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_EnumerateKeyValues(self: *const T, enumerator: ?*?*IKeyEnumerator) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateKeyValues(@as(*const IModelObject, @ptrCast(self)), enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetRawValue(self: *const T, kind: SymbolKind, name: ?[*:0]const u16, searchFlags: u32, object: ?*?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetRawValue(@as(*const IModelObject, @ptrCast(self)), kind, name, searchFlags, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_EnumerateRawValues(self: *const T, kind: SymbolKind, searchFlags: u32, enumerator: ?*?*IRawEnumerator) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateRawValues(@as(*const IModelObject, @ptrCast(self)), kind, searchFlags, enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_Dereference(self: *const T, object: ?*?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).Dereference(@as(*const IModelObject, @ptrCast(self)), object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_TryCastToRuntimeType(self: *const T, runtimeTypedObject: ?*?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).TryCastToRuntimeType(@as(*const IModelObject, @ptrCast(self)), runtimeTypedObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetConcept(self: *const T, conceptId: ?*const Guid, conceptInterface: ?*?*IUnknown, conceptMetadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetConcept(@as(*const IModelObject, @ptrCast(self)), conceptId, conceptInterface, conceptMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetLocation(self: *const T, location: ?*Location) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IModelObject, @ptrCast(self)), location);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetTypeInfo(self: *const T, type_: ?*?*IDebugHostType) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const IModelObject, @ptrCast(self)), type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetTargetInfo(self: *const T, location: ?*Location, type_: ?*?*IDebugHostType) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetTargetInfo(@as(*const IModelObject, @ptrCast(self)), location, type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetNumberOfParentModels(self: *const T, numModels: ?*u64) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetNumberOfParentModels(@as(*const IModelObject, @ptrCast(self)), numModels);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetParentModel(self: *const T, i: u64, model: ?*?*IModelObject, contextObject: ?*?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetParentModel(@as(*const IModelObject, @ptrCast(self)), i, model, contextObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_AddParentModel(self: *const T, model: ?*IModelObject, contextObject: ?*IModelObject, override: u8) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).AddParentModel(@as(*const IModelObject, @ptrCast(self)), model, contextObject, override);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_RemoveParentModel(self: *const T, model: ?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).RemoveParentModel(@as(*const IModelObject, @ptrCast(self)), model);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetKey(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IModelObject, @ptrCast(self)), key, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetKeyReference(self: *const T, key: ?[*:0]const u16, objectReference: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKeyReference(@as(*const IModelObject, @ptrCast(self)), key, objectReference, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_SetKey(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject, metadata: ?*IKeyStore) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IModelObject, @ptrCast(self)), key, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_ClearKeys(self: *const T) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).ClearKeys(@as(*const IModelObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_EnumerateKeys(self: *const T, enumerator: ?*?*IKeyEnumerator) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateKeys(@as(*const IModelObject, @ptrCast(self)), enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_EnumerateKeyReferences(self: *const T, enumerator: ?*?*IKeyEnumerator) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateKeyReferences(@as(*const IModelObject, @ptrCast(self)), enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_SetConcept(self: *const T, conceptId: ?*const Guid, conceptInterface: ?*IUnknown, conceptMetadata: ?*IKeyStore) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetConcept(@as(*const IModelObject, @ptrCast(self)), conceptId, conceptInterface, conceptMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_ClearConcepts(self: *const T) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).ClearConcepts(@as(*const IModelObject, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetRawReference(self: *const T, kind: SymbolKind, name: ?[*:0]const u16, searchFlags: u32, object: ?*?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetRawReference(@as(*const IModelObject, @ptrCast(self)), kind, name, searchFlags, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_EnumerateRawReferences(self: *const T, kind: SymbolKind, searchFlags: u32, enumerator: ?*?*IRawEnumerator) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateRawReferences(@as(*const IModelObject, @ptrCast(self)), kind, searchFlags, enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_SetContextForDataModel(self: *const T, dataModelObject: ?*IModelObject, context: ?*IUnknown) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetContextForDataModel(@as(*const IModelObject, @ptrCast(self)), dataModelObject, context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_GetContextForDataModel(self: *const T, dataModelObject: ?*IModelObject, context: ?*?*IUnknown) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetContextForDataModel(@as(*const IModelObject, @ptrCast(self)), dataModelObject, context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_Compare(self: *const T, other: ?*IModelObject, ppResult: ?*?*IModelObject) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).Compare(@as(*const IModelObject, @ptrCast(self)), other, ppResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelObject_IsEqualTo(self: *const T, other: ?*IModelObject, equal: ?*bool) HRESULT {
                return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).IsEqualTo(@as(*const IModelObject, @ptrCast(self)), other, equal);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelManager_Value = Guid.initString("73fe19f4-a110-4500-8ed9-3c28896f508c");
pub const IID_IDataModelManager = &IID_IDataModelManager_Value;
pub const IDataModelManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNoValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateErrorObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                hrError: HRESULT,
                pwszMessage: ?[*:0]const u16,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                hrError: HRESULT,
                pwszMessage: ?[*:0]const u16,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedObjectReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSyntheticObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDataModelObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                dataModel: ?*IDataModelConcept,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                dataModel: ?*IDataModelConcept,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateIntrinsicObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                objectKind: ModelObjectKind,
                intrinsicData: ?*VARIANT,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                objectKind: ModelObjectKind,
                intrinsicData: ?*VARIANT,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedIntrinsicObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModelForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModelForType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                type: ?*IDebugHostType,
                dataModel: ?*?*IModelObject,
                typeSignature: ?*?*IDebugHostTypeSignature,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                type: ?*IDebugHostType,
                dataModel: ?*?*IModelObject,
                typeSignature: ?*?*IDebugHostTypeSignature,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterModelForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterModelForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterExtensionForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterExtensionForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMetadataStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                parentStore: ?*IKeyStore,
                metadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                parentStore: ?*IKeyStore,
                metadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                rootNamespace: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                rootNamespace: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterNamedModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                modelName: ?[*:0]const u16,
                modeObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                modelName: ?[*:0]const u16,
                modeObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterNamedModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                modelName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                modelName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcquireNamedModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager,
                modelName: ?[*:0]const u16,
                modelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager,
                modelName: ?[*:0]const u16,
                modelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_Close(self: *const T) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).Close(@as(*const IDataModelManager, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateNoValue(self: *const T, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateNoValue(@as(*const IDataModelManager, @ptrCast(self)), object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateErrorObject(self: *const T, hrError: HRESULT, pwszMessage: ?[*:0]const u16, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateErrorObject(@as(*const IDataModelManager, @ptrCast(self)), hrError, pwszMessage, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateTypedObject(self: *const T, context: ?*IDebugHostContext, objectLocation: Location, objectType: ?*IDebugHostType, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateTypedObject(@as(*const IDataModelManager, @ptrCast(self)), context, objectLocation, objectType, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateTypedObjectReference(self: *const T, context: ?*IDebugHostContext, objectLocation: Location, objectType: ?*IDebugHostType, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateTypedObjectReference(@as(*const IDataModelManager, @ptrCast(self)), context, objectLocation, objectType, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateSyntheticObject(self: *const T, context: ?*IDebugHostContext, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateSyntheticObject(@as(*const IDataModelManager, @ptrCast(self)), context, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateDataModelObject(self: *const T, dataModel: ?*IDataModelConcept, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateDataModelObject(@as(*const IDataModelManager, @ptrCast(self)), dataModel, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateIntrinsicObject(self: *const T, objectKind: ModelObjectKind, intrinsicData: ?*VARIANT, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateIntrinsicObject(@as(*const IDataModelManager, @ptrCast(self)), objectKind, intrinsicData, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateTypedIntrinsicObject(self: *const T, intrinsicData: ?*VARIANT, type_: ?*IDebugHostType, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateTypedIntrinsicObject(@as(*const IDataModelManager, @ptrCast(self)), intrinsicData, type_, object);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_GetModelForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).GetModelForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), typeSignature, dataModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_GetModelForType(self: *const T, type_: ?*IDebugHostType, dataModel: ?*?*IModelObject, typeSignature: ?*?*IDebugHostTypeSignature, wildcardMatches: ?*?*IDebugHostSymbolEnumerator) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).GetModelForType(@as(*const IDataModelManager, @ptrCast(self)), type_, dataModel, typeSignature, wildcardMatches);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_RegisterModelForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).RegisterModelForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), typeSignature, dataModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_UnregisterModelForTypeSignature(self: *const T, dataModel: ?*IModelObject, typeSignature: ?*IDebugHostTypeSignature) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).UnregisterModelForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), dataModel, typeSignature);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_RegisterExtensionForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).RegisterExtensionForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), typeSignature, dataModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_UnregisterExtensionForTypeSignature(self: *const T, dataModel: ?*IModelObject, typeSignature: ?*IDebugHostTypeSignature) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).UnregisterExtensionForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), dataModel, typeSignature);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_CreateMetadataStore(self: *const T, parentStore: ?*IKeyStore, metadataStore: ?*?*IKeyStore) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateMetadataStore(@as(*const IDataModelManager, @ptrCast(self)), parentStore, metadataStore);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_GetRootNamespace(self: *const T, rootNamespace: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).GetRootNamespace(@as(*const IDataModelManager, @ptrCast(self)), rootNamespace);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_RegisterNamedModel(self: *const T, modelName: ?[*:0]const u16, modeObject: ?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).RegisterNamedModel(@as(*const IDataModelManager, @ptrCast(self)), modelName, modeObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_UnregisterNamedModel(self: *const T, modelName: ?[*:0]const u16) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).UnregisterNamedModel(@as(*const IDataModelManager, @ptrCast(self)), modelName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager_AcquireNamedModel(self: *const T, modelName: ?[*:0]const u16, modelObject: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).AcquireNamedModel(@as(*const IDataModelManager, @ptrCast(self)), modelName, modelObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelKeyReference_Value = Guid.initString("5253dcf8-5aff-4c62-b302-56a289e00998");
pub const IID_IModelKeyReference = &IID_IModelKeyReference_Value;
pub const IModelKeyReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                keyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                keyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                originalObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                originalObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                containingObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                containingObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_GetKeyName(self: *const T, keyName: ?*?BSTR) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetKeyName(@as(*const IModelKeyReference, @ptrCast(self)), keyName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_GetOriginalObject(self: *const T, originalObject: ?*?*IModelObject) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetOriginalObject(@as(*const IModelKeyReference, @ptrCast(self)), originalObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_GetContextObject(self: *const T, containingObject: ?*?*IModelObject) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetContextObject(@as(*const IModelKeyReference, @ptrCast(self)), containingObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_GetKey(self: *const T, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IModelKeyReference, @ptrCast(self)), object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_GetKeyValue(self: *const T, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetKeyValue(@as(*const IModelKeyReference, @ptrCast(self)), object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_SetKey(self: *const T, object: ?*IModelObject, metadata: ?*IKeyStore) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IModelKeyReference, @ptrCast(self)), object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference_SetKeyValue(self: *const T, object: ?*IModelObject) HRESULT {
                return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).SetKeyValue(@as(*const IModelKeyReference, @ptrCast(self)), object);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelPropertyAccessor_Value = Guid.initString("5a0c63d9-0526-42b8-960c-9516a3254c85");
pub const IID_IModelPropertyAccessor = &IID_IModelPropertyAccessor_Value;
pub const IModelPropertyAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelPropertyAccessor,
                key: ?[*:0]const u16,
                contextObject: ?*IModelObject,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelPropertyAccessor,
                key: ?[*:0]const u16,
                contextObject: ?*IModelObject,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelPropertyAccessor,
                key: ?[*:0]const u16,
                contextObject: ?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelPropertyAccessor,
                key: ?[*:0]const u16,
                contextObject: ?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelPropertyAccessor_GetValue(self: *const T, key: ?[*:0]const u16, contextObject: ?*IModelObject, value: ?*?*IModelObject) HRESULT {
                return @as(*const IModelPropertyAccessor.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IModelPropertyAccessor, @ptrCast(self)), key, contextObject, value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelPropertyAccessor_SetValue(self: *const T, key: ?[*:0]const u16, contextObject: ?*IModelObject, value: ?*IModelObject) HRESULT {
                return @as(*const IModelPropertyAccessor.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IModelPropertyAccessor, @ptrCast(self)), key, contextObject, value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelMethod_Value = Guid.initString("80600c1f-b90b-4896-82ad-1c00207909e8");
pub const IID_IModelMethod = &IID_IModelMethod_Value;
pub const IModelMethod = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Call: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelMethod,
                pContextObject: ?*IModelObject,
                argCount: u64,
                ppArguments: [*]?*IModelObject,
                ppResult: ?*?*IModelObject,
                ppMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelMethod,
                pContextObject: ?*IModelObject,
                argCount: u64,
                ppArguments: [*]?*IModelObject,
                ppResult: ?*?*IModelObject,
                ppMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelMethod_Call(self: *const T, pContextObject: ?*IModelObject, argCount: u64, ppArguments: [*]?*IModelObject, ppResult: ?*?*IModelObject, ppMetadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelMethod.VTable, @ptrCast(self.vtable)).Call(@as(*const IModelMethod, @ptrCast(self)), pContextObject, argCount, ppArguments, ppResult, ppMetadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IKeyEnumerator_Value = Guid.initString("345fa92e-5e00-4319-9cae-971f7601cdcf");
pub const IID_IKeyEnumerator = &IID_IKeyEnumerator_Value;
pub const IKeyEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IKeyEnumerator,
                key: ?*?BSTR,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IKeyEnumerator,
                key: ?*?BSTR,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IKeyEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IKeyEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IKeyEnumerator_GetNext(self: *const T, key: ?*?BSTR, value: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IKeyEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IKeyEnumerator, @ptrCast(self)), key, value, metadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawEnumerator_Value = Guid.initString("e13613f9-3a3c-40b5-8f48-1e5ebfb9b21b");
pub const IID_IRawEnumerator = &IID_IRawEnumerator_Value;
pub const IRawEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRawEnumerator,
                name: ?*?BSTR,
                kind: ?*SymbolKind,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRawEnumerator,
                name: ?*?BSTR,
                kind: ?*SymbolKind,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRawEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IRawEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRawEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRawEnumerator_GetNext(self: *const T, name: ?*?BSTR, kind: ?*SymbolKind, value: ?*?*IModelObject) HRESULT {
                return @as(*const IRawEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IRawEnumerator, @ptrCast(self)), name, kind, value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelConcept_Value = Guid.initString("fcb98d1d-1114-4fbf-b24c-effcb5def0d3");
pub const IID_IDataModelConcept = &IID_IDataModelConcept_Value;
pub const IDataModelConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelConcept,
                modelObject: ?*IModelObject,
                matchingTypeSignature: ?*IDebugHostTypeSignature,
                wildcardMatches: ?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelConcept,
                modelObject: ?*IModelObject,
                matchingTypeSignature: ?*IDebugHostTypeSignature,
                wildcardMatches: ?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelConcept,
                modelName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelConcept,
                modelName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelConcept_InitializeObject(self: *const T, modelObject: ?*IModelObject, matchingTypeSignature: ?*IDebugHostTypeSignature, wildcardMatches: ?*IDebugHostSymbolEnumerator) HRESULT {
                return @as(*const IDataModelConcept.VTable, @ptrCast(self.vtable)).InitializeObject(@as(*const IDataModelConcept, @ptrCast(self)), modelObject, matchingTypeSignature, wildcardMatches);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelConcept_GetName(self: *const T, modelName: ?*?BSTR) HRESULT {
                return @as(*const IDataModelConcept.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelConcept, @ptrCast(self)), modelName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IStringDisplayableConcept_Value = Guid.initString("d28e8d70-6c00-4205-940d-501016601ea3");
pub const IID_IStringDisplayableConcept = &IID_IStringDisplayableConcept_Value;
pub const IStringDisplayableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ToDisplayString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IStringDisplayableConcept,
                contextObject: ?*IModelObject,
                metadata: ?*IKeyStore,
                displayString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IStringDisplayableConcept,
                contextObject: ?*IModelObject,
                metadata: ?*IKeyStore,
                displayString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IStringDisplayableConcept_ToDisplayString(self: *const T, contextObject: ?*IModelObject, metadata: ?*IKeyStore, displayString: ?*?BSTR) HRESULT {
                return @as(*const IStringDisplayableConcept.VTable, @ptrCast(self.vtable)).ToDisplayString(@as(*const IStringDisplayableConcept, @ptrCast(self)), contextObject, metadata, displayString);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ICodeAddressConcept_Value = Guid.initString("c7371568-5c78-4a00-a4ab-6ef8823184cb");
pub const IID_ICodeAddressConcept = &IID_ICodeAddressConcept_Value;
pub const ICodeAddressConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContainingSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ICodeAddressConcept,
                pContextObject: ?*IModelObject,
                ppSymbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ICodeAddressConcept,
                pContextObject: ?*IModelObject,
                ppSymbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ICodeAddressConcept_GetContainingSymbol(self: *const T, pContextObject: ?*IModelObject, ppSymbol: ?*?*IDebugHostSymbol) HRESULT {
                return @as(*const ICodeAddressConcept.VTable, @ptrCast(self.vtable)).GetContainingSymbol(@as(*const ICodeAddressConcept, @ptrCast(self)), pContextObject, ppSymbol);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelIterator_Value = Guid.initString("e4622136-927d-4490-874f-581f3e4e3688");
pub const IID_IModelIterator = &IID_IModelIterator_Value;
pub const IModelIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelIterator,
                object: ?*?*IModelObject,
                dimensions: u64,
                indexers: ?[*]?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelIterator,
                object: ?*?*IModelObject,
                dimensions: u64,
                indexers: ?[*]?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelIterator_Reset(self: *const T) HRESULT {
                return @as(*const IModelIterator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IModelIterator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelIterator_GetNext(self: *const T, object: ?*?*IModelObject, dimensions: u64, indexers: ?[*]?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IModelIterator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IModelIterator, @ptrCast(self)), object, dimensions, indexers, metadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IIterableConcept_Value = Guid.initString("f5d49d0c-0b02-4301-9c9b-b3a6037628f3");
pub const IID_IIterableConcept = &IID_IIterableConcept_Value;
pub const IIterableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultIndexDimensionality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIterator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                iterator: ?*?*IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                iterator: ?*?*IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIterableConcept_GetDefaultIndexDimensionality(self: *const T, contextObject: ?*IModelObject, dimensionality: ?*u64) HRESULT {
                return @as(*const IIterableConcept.VTable, @ptrCast(self.vtable)).GetDefaultIndexDimensionality(@as(*const IIterableConcept, @ptrCast(self)), contextObject, dimensionality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIterableConcept_GetIterator(self: *const T, contextObject: ?*IModelObject, iterator: ?*?*IModelIterator) HRESULT {
                return @as(*const IIterableConcept.VTable, @ptrCast(self.vtable)).GetIterator(@as(*const IIterableConcept, @ptrCast(self)), contextObject, iterator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IIndexableConcept_Value = Guid.initString("d1fad99f-3f53-4457-850c-8051df2d3fb5");
pub const IID_IIndexableConcept = &IID_IIndexableConcept_Value;
pub const IIndexableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDimensionality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIndexableConcept_GetDimensionality(self: *const T, contextObject: ?*IModelObject, dimensionality: ?*u64) HRESULT {
                return @as(*const IIndexableConcept.VTable, @ptrCast(self.vtable)).GetDimensionality(@as(*const IIndexableConcept, @ptrCast(self)), contextObject, dimensionality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIndexableConcept_GetAt(self: *const T, contextObject: ?*IModelObject, indexerCount: u64, indexers: [*]?*IModelObject, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IIndexableConcept.VTable, @ptrCast(self.vtable)).GetAt(@as(*const IIndexableConcept, @ptrCast(self)), contextObject, indexerCount, indexers, object, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IIndexableConcept_SetAt(self: *const T, contextObject: ?*IModelObject, indexerCount: u64, indexers: [*]?*IModelObject, value: ?*IModelObject) HRESULT {
                return @as(*const IIndexableConcept.VTable, @ptrCast(self.vtable)).SetAt(@as(*const IIndexableConcept, @ptrCast(self)), contextObject, indexerCount, indexers, value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPreferredRuntimeTypeConcept_Value = Guid.initString("9d6c1d7b-a76f-4618-8068-5f76bd9a4e8a");
pub const IID_IPreferredRuntimeTypeConcept = &IID_IPreferredRuntimeTypeConcept_Value;
pub const IPreferredRuntimeTypeConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CastToPreferredRuntimeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPreferredRuntimeTypeConcept,
                contextObject: ?*IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPreferredRuntimeTypeConcept,
                contextObject: ?*IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPreferredRuntimeTypeConcept_CastToPreferredRuntimeType(self: *const T, contextObject: ?*IModelObject, object: ?*?*IModelObject) HRESULT {
                return @as(*const IPreferredRuntimeTypeConcept.VTable, @ptrCast(self.vtable)).CastToPreferredRuntimeType(@as(*const IPreferredRuntimeTypeConcept, @ptrCast(self)), contextObject, object);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHost_Value = Guid.initString("b8c74943-6b2c-4eeb-b5c5-35d378a6d99d");
pub const IID_IDebugHost = &IID_IDebugHost_Value;
pub const IDebugHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHostDefinedInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHost,
                hostUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHost,
                hostUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHost,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHost,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHost,
                defaultMetadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHost,
                defaultMetadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHost_GetHostDefinedInterface(self: *const T, hostUnk: ?*?*IUnknown) HRESULT {
                return @as(*const IDebugHost.VTable, @ptrCast(self.vtable)).GetHostDefinedInterface(@as(*const IDebugHost, @ptrCast(self)), hostUnk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHost_GetCurrentContext(self: *const T, context: ?*?*IDebugHostContext) HRESULT {
                return @as(*const IDebugHost.VTable, @ptrCast(self.vtable)).GetCurrentContext(@as(*const IDebugHost, @ptrCast(self)), context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHost_GetDefaultMetadata(self: *const T, defaultMetadataStore: ?*?*IKeyStore) HRESULT {
                return @as(*const IDebugHost.VTable, @ptrCast(self.vtable)).GetDefaultMetadata(@as(*const IDebugHost, @ptrCast(self)), defaultMetadataStore);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostContext_Value = Guid.initString("a68c70d8-5ec0-46e5-b775-3134a48ea2e3");
pub const IID_IDebugHostContext = &IID_IDebugHostContext_Value;
pub const IDebugHostContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEqualTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostContext,
                pContext: ?*IDebugHostContext,
                pIsEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostContext,
                pContext: ?*IDebugHostContext,
                pIsEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostContext_IsEqualTo(self: *const T, pContext: ?*IDebugHostContext, pIsEqual: ?*bool) HRESULT {
                return @as(*const IDebugHostContext.VTable, @ptrCast(self.vtable)).IsEqualTo(@as(*const IDebugHostContext, @ptrCast(self)), pContext, pIsEqual);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ErrorClass = enum(i32) {
    Warning = 0,
    Error = 1,
};
pub const ErrorClassWarning = ErrorClass.Warning;
pub const ErrorClassError = ErrorClass.Error;

const IID_IDebugHostErrorSink_Value = Guid.initString("c8ff0f0b-fce9-467e-8bb3-5d69ef109c00");
pub const IID_IDebugHostErrorSink = &IID_IDebugHostErrorSink_Value;
pub const IDebugHostErrorSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostErrorSink,
                errClass: ErrorClass,
                hrError: HRESULT,
                message: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostErrorSink,
                errClass: ErrorClass,
                hrError: HRESULT,
                message: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostErrorSink_ReportError(self: *const T, errClass: ErrorClass, hrError: HRESULT, message: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugHostErrorSink.VTable, @ptrCast(self.vtable)).ReportError(@as(*const IDebugHostErrorSink, @ptrCast(self)), errClass, hrError, message);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbol_Value = Guid.initString("0f819103-87de-4e96-8277-e05cd441fb22");
pub const IID_IDebugHostSymbol = &IID_IDebugHostSymbol_Value;
pub const IDebugHostSymbol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                kind: SymbolKind,
                name: ?[*:0]const u16,
                ppEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                kind: SymbolKind,
                name: ?[*:0]const u16,
                ppEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                kind: ?*SymbolKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                kind: ?*SymbolKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                symbolName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                symbolName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainingModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                containingModule: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                containingModule: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareAgainst: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol,
                pComparisonSymbol: ?*IDebugHostSymbol,
                comparisonFlags: u32,
                pMatches: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol,
                pComparisonSymbol: ?*IDebugHostSymbol,
                comparisonFlags: u32,
                pMatches: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_GetContext(self: *const T, context: ?*?*IDebugHostContext) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IDebugHostSymbol, @ptrCast(self)), context);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_EnumerateChildren(self: *const T, kind: SymbolKind, name: ?[*:0]const u16, ppEnum: ?*?*IDebugHostSymbolEnumerator) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).EnumerateChildren(@as(*const IDebugHostSymbol, @ptrCast(self)), kind, name, ppEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_GetSymbolKind(self: *const T, kind: ?*SymbolKind) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetSymbolKind(@as(*const IDebugHostSymbol, @ptrCast(self)), kind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_GetName(self: *const T, symbolName: ?*?BSTR) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDebugHostSymbol, @ptrCast(self)), symbolName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_GetType(self: *const T, type_: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugHostSymbol, @ptrCast(self)), type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_GetContainingModule(self: *const T, containingModule: ?*?*IDebugHostModule) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetContainingModule(@as(*const IDebugHostSymbol, @ptrCast(self)), containingModule);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol_CompareAgainst(self: *const T, pComparisonSymbol: ?*IDebugHostSymbol, comparisonFlags: u32, pMatches: ?*bool) HRESULT {
                return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).CompareAgainst(@as(*const IDebugHostSymbol, @ptrCast(self)), pComparisonSymbol, comparisonFlags, pMatches);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbolEnumerator_Value = Guid.initString("28d96c86-10a3-4976-b14e-eaef4790aa1f");
pub const IID_IDebugHostSymbolEnumerator = &IID_IDebugHostSymbolEnumerator_Value;
pub const IDebugHostSymbolEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbolEnumerator,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbolEnumerator,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbolEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IDebugHostSymbolEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDebugHostSymbolEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbolEnumerator_GetNext(self: *const T, symbol: ?*?*IDebugHostSymbol) HRESULT {
                return @as(*const IDebugHostSymbolEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDebugHostSymbolEnumerator, @ptrCast(self)), symbol);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostModule_Value = Guid.initString("c9ba3e18-d070-4378-bbd0-34613b346e1e");
pub const IID_IDebugHostModule = &IID_IDebugHostModule_Value;
pub const IDebugHostModule = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetImageName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule,
                allowPath: u8,
                imageName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule,
                allowPath: u8,
                imageName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule,
                moduleBaseLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule,
                moduleBaseLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule,
                fileVersion: ?*u64,
                productVersion: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule,
                fileVersion: ?*u64,
                productVersion: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTypeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule,
                typeName: ?[*:0]const u16,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule,
                typeName: ?[*:0]const u16,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSymbolByRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSymbolByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule,
                symbolName: ?[*:0]const u16,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule,
                symbolName: ?[*:0]const u16,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule_GetImageName(self: *const T, allowPath: u8, imageName: ?*?BSTR) HRESULT {
                return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).GetImageName(@as(*const IDebugHostModule, @ptrCast(self)), allowPath, imageName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule_GetBaseLocation(self: *const T, moduleBaseLocation: ?*Location) HRESULT {
                return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).GetBaseLocation(@as(*const IDebugHostModule, @ptrCast(self)), moduleBaseLocation);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule_GetVersion(self: *const T, fileVersion: ?*u64, productVersion: ?*u64) HRESULT {
                return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IDebugHostModule, @ptrCast(self)), fileVersion, productVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule_FindTypeByName(self: *const T, typeName: ?[*:0]const u16, type_: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).FindTypeByName(@as(*const IDebugHostModule, @ptrCast(self)), typeName, type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule_FindSymbolByRVA(self: *const T, rva: u64, symbol: ?*?*IDebugHostSymbol) HRESULT {
                return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).FindSymbolByRVA(@as(*const IDebugHostModule, @ptrCast(self)), rva, symbol);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule_FindSymbolByName(self: *const T, symbolName: ?[*:0]const u16, symbol: ?*?*IDebugHostSymbol) HRESULT {
                return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).FindSymbolByName(@as(*const IDebugHostModule, @ptrCast(self)), symbolName, symbol);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ArrayDimension = extern struct {
    LowerBound: i64,
    Length: u64,
    Stride: u64,
};

const IID_IDebugHostType_Value = Guid.initString("3aadc353-2b14-4abb-9893-5e03458e07ee");
pub const IID_IDebugHostType = &IID_IDebugHostType_Value;
pub const IDebugHostType = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetTypeKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                kind: ?*TypeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                kind: ?*TypeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                size: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                size: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                baseType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                baseType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                intrinsicKind: ?*IntrinsicKind,
                carrierType: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                intrinsicKind: ?*IntrinsicKind,
                carrierType: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBitField: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                lsbOfField: ?*u32,
                lengthOfField: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                lsbOfField: ?*u32,
                lengthOfField: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPointerKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                pointerKind: ?*PointerKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                pointerKind: ?*PointerKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                memberType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                memberType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePointerTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                kind: PointerKind,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                kind: PointerKind,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArrayDimensionality: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                arrayDimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                arrayDimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArrayDimensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateArrayOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionCallingConvention: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                conventionKind: ?*CallingConventionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                conventionKind: ?*CallingConventionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionReturnType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                returnType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                returnType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionParameterTypeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                count: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                count: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionParameterTypeAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                i: u64,
                parameterType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                i: u64,
                parameterType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsGeneric: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                isGeneric: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                isGeneric: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenericArgumentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                argCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                argCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenericArgumentAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType,
                i: u64,
                argument: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType,
                i: u64,
                argument: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetTypeKind(self: *const T, kind: ?*TypeKind) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetTypeKind(@as(*const IDebugHostType, @ptrCast(self)), kind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetSize(self: *const T, size: ?*u64) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IDebugHostType, @ptrCast(self)), size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetBaseType(self: *const T, baseType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetBaseType(@as(*const IDebugHostType, @ptrCast(self)), baseType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetHashCode(self: *const T, hashCode: ?*u32) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetHashCode(@as(*const IDebugHostType, @ptrCast(self)), hashCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetIntrinsicType(self: *const T, intrinsicKind: ?*IntrinsicKind, carrierType: ?*u16) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetIntrinsicType(@as(*const IDebugHostType, @ptrCast(self)), intrinsicKind, carrierType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetBitField(self: *const T, lsbOfField: ?*u32, lengthOfField: ?*u32) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetBitField(@as(*const IDebugHostType, @ptrCast(self)), lsbOfField, lengthOfField);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetPointerKind(self: *const T, pointerKind: ?*PointerKind) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetPointerKind(@as(*const IDebugHostType, @ptrCast(self)), pointerKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetMemberType(self: *const T, memberType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetMemberType(@as(*const IDebugHostType, @ptrCast(self)), memberType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_CreatePointerTo(self: *const T, kind: PointerKind, newType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).CreatePointerTo(@as(*const IDebugHostType, @ptrCast(self)), kind, newType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetArrayDimensionality(self: *const T, arrayDimensionality: ?*u64) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetArrayDimensionality(@as(*const IDebugHostType, @ptrCast(self)), arrayDimensionality);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetArrayDimensions(self: *const T, dimensions: u64, pDimensions: [*]ArrayDimension) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetArrayDimensions(@as(*const IDebugHostType, @ptrCast(self)), dimensions, pDimensions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_CreateArrayOf(self: *const T, dimensions: u64, pDimensions: [*]ArrayDimension, newType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).CreateArrayOf(@as(*const IDebugHostType, @ptrCast(self)), dimensions, pDimensions, newType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetFunctionCallingConvention(self: *const T, conventionKind: ?*CallingConventionKind) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionCallingConvention(@as(*const IDebugHostType, @ptrCast(self)), conventionKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetFunctionReturnType(self: *const T, returnType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionReturnType(@as(*const IDebugHostType, @ptrCast(self)), returnType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetFunctionParameterTypeCount(self: *const T, count: ?*u64) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionParameterTypeCount(@as(*const IDebugHostType, @ptrCast(self)), count);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetFunctionParameterTypeAt(self: *const T, i: u64, parameterType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionParameterTypeAt(@as(*const IDebugHostType, @ptrCast(self)), i, parameterType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_IsGeneric(self: *const T, isGeneric: ?*bool) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).IsGeneric(@as(*const IDebugHostType, @ptrCast(self)), isGeneric);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetGenericArgumentCount(self: *const T, argCount: ?*u64) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetGenericArgumentCount(@as(*const IDebugHostType, @ptrCast(self)), argCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType_GetGenericArgumentAt(self: *const T, i: u64, argument: ?*?*IDebugHostSymbol) HRESULT {
                return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetGenericArgumentAt(@as(*const IDebugHostType, @ptrCast(self)), i, argument);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostConstant_Value = Guid.initString("62787edc-fa76-4690-bd71-5e8c3e2937ec");
pub const IID_IDebugHostConstant = &IID_IDebugHostConstant_Value;
pub const IDebugHostConstant = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostConstant,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostConstant,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostConstant_GetValue(self: *const T, value: ?*VARIANT) HRESULT {
                return @as(*const IDebugHostConstant.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugHostConstant, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostField_Value = Guid.initString("e06f6495-16bc-4cc9-b11d-2a6b23fa72f3");
pub const IID_IDebugHostField = &IID_IDebugHostField_Value;
pub const IDebugHostField = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostField,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostField,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostField,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostField,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostField,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostField,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostField,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostField,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostField_GetLocationKind(self: *const T, locationKind: ?*LocationKind) HRESULT {
                return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetLocationKind(@as(*const IDebugHostField, @ptrCast(self)), locationKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostField_GetOffset(self: *const T, offset: ?*u64) HRESULT {
                return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugHostField, @ptrCast(self)), offset);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostField_GetLocation(self: *const T, location: ?*Location) HRESULT {
                return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IDebugHostField, @ptrCast(self)), location);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostField_GetValue(self: *const T, value: ?*VARIANT) HRESULT {
                return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugHostField, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostData_Value = Guid.initString("a3d64993-826c-44fa-897d-926f2fe7ad0b");
pub const IID_IDebugHostData = &IID_IDebugHostData_Value;
pub const IDebugHostData = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostData,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostData,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostData,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostData,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostData,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostData,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostData_GetLocationKind(self: *const T, locationKind: ?*LocationKind) HRESULT {
                return @as(*const IDebugHostData.VTable, @ptrCast(self.vtable)).GetLocationKind(@as(*const IDebugHostData, @ptrCast(self)), locationKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostData_GetLocation(self: *const T, location: ?*Location) HRESULT {
                return @as(*const IDebugHostData.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IDebugHostData, @ptrCast(self)), location);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostData_GetValue(self: *const T, value: ?*VARIANT) HRESULT {
                return @as(*const IDebugHostData.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugHostData, @ptrCast(self)), value);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostPublic_Value = Guid.initString("6c597ac9-fb4d-4f6d-9f39-22488539f8f4");
pub const IID_IDebugHostPublic = &IID_IDebugHostPublic_Value;
pub const IDebugHostPublic = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostPublic,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostPublic,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostPublic,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostPublic,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostPublic_GetLocationKind(self: *const T, locationKind: ?*LocationKind) HRESULT {
                return @as(*const IDebugHostPublic.VTable, @ptrCast(self.vtable)).GetLocationKind(@as(*const IDebugHostPublic, @ptrCast(self)), locationKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostPublic_GetLocation(self: *const T, location: ?*Location) HRESULT {
                return @as(*const IDebugHostPublic.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IDebugHostPublic, @ptrCast(self)), location);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostBaseClass_Value = Guid.initString("b94d57d2-390b-40f7-b5b4-b6db897d974b");
pub const IID_IDebugHostBaseClass = &IID_IDebugHostBaseClass_Value;
pub const IDebugHostBaseClass = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostBaseClass,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostBaseClass,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostBaseClass_GetOffset(self: *const T, offset: ?*u64) HRESULT {
                return @as(*const IDebugHostBaseClass.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugHostBaseClass, @ptrCast(self)), offset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbols_Value = Guid.initString("854fd751-c2e1-4eb2-b525-6619cb97a588");
pub const IID_IDebugHostSymbols = &IID_IDebugHostSymbols_Value;
pub const IDebugHostSymbols = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateModuleSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                pwszModuleName: ?[*:0]const u16,
                pwszMinVersion: ?[*:0]const u16,
                pwszMaxVersion: ?[*:0]const u16,
                ppModuleSignature: ?*?*IDebugHostModuleSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                pwszModuleName: ?[*:0]const u16,
                pwszMinVersion: ?[*:0]const u16,
                pwszMaxVersion: ?[*:0]const u16,
                ppModuleSignature: ?*?*IDebugHostModuleSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]const u16,
                module: ?*IDebugHostModule,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]const u16,
                module: ?*IDebugHostModule,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypeSignatureForModuleRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]const u16,
                moduleName: ?[*:0]const u16,
                minVersion: ?[*:0]const u16,
                maxVersion: ?[*:0]const u16,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]const u16,
                moduleName: ?[*:0]const u16,
                minVersion: ?[*:0]const u16,
                maxVersion: ?[*:0]const u16,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindModuleByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleName: ?[*:0]const u16,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleName: ?[*:0]const u16,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindModuleByLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleLocation: Location,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleLocation: Location,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMostDerivedObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbols,
                pContext: ?*IDebugHostContext,
                location: Location,
                objectType: ?*IDebugHostType,
                derivedLocation: ?*Location,
                derivedType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbols,
                pContext: ?*IDebugHostContext,
                location: Location,
                objectType: ?*IDebugHostType,
                derivedLocation: ?*Location,
                derivedType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_CreateModuleSignature(self: *const T, pwszModuleName: ?[*:0]const u16, pwszMinVersion: ?[*:0]const u16, pwszMaxVersion: ?[*:0]const u16, ppModuleSignature: ?*?*IDebugHostModuleSignature) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).CreateModuleSignature(@as(*const IDebugHostSymbols, @ptrCast(self)), pwszModuleName, pwszMinVersion, pwszMaxVersion, ppModuleSignature);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_CreateTypeSignature(self: *const T, signatureSpecification: ?[*:0]const u16, module: ?*IDebugHostModule, typeSignature: ?*?*IDebugHostTypeSignature) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).CreateTypeSignature(@as(*const IDebugHostSymbols, @ptrCast(self)), signatureSpecification, module, typeSignature);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_CreateTypeSignatureForModuleRange(self: *const T, signatureSpecification: ?[*:0]const u16, moduleName: ?[*:0]const u16, minVersion: ?[*:0]const u16, maxVersion: ?[*:0]const u16, typeSignature: ?*?*IDebugHostTypeSignature) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).CreateTypeSignatureForModuleRange(@as(*const IDebugHostSymbols, @ptrCast(self)), signatureSpecification, moduleName, minVersion, maxVersion, typeSignature);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_EnumerateModules(self: *const T, context: ?*IDebugHostContext, moduleEnum: ?*?*IDebugHostSymbolEnumerator) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).EnumerateModules(@as(*const IDebugHostSymbols, @ptrCast(self)), context, moduleEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_FindModuleByName(self: *const T, context: ?*IDebugHostContext, moduleName: ?[*:0]const u16, module: ?*?*IDebugHostModule) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).FindModuleByName(@as(*const IDebugHostSymbols, @ptrCast(self)), context, moduleName, module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_FindModuleByLocation(self: *const T, context: ?*IDebugHostContext, moduleLocation: Location, module: ?*?*IDebugHostModule) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).FindModuleByLocation(@as(*const IDebugHostSymbols, @ptrCast(self)), context, moduleLocation, module);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbols_GetMostDerivedObject(self: *const T, pContext: ?*IDebugHostContext, location: Location, objectType: ?*IDebugHostType, derivedLocation: ?*Location, derivedType: ?*?*IDebugHostType) HRESULT {
                return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).GetMostDerivedObject(@as(*const IDebugHostSymbols, @ptrCast(self)), pContext, location, objectType, derivedLocation, derivedType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostMemory_Value = Guid.initString("212149c9-9183-4a3e-b00e-4fd1dc95339b");
pub const IID_IDebugHostMemory = &IID_IDebugHostMemory_Value;
pub const IDebugHostMemory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesRead: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesRead: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesWritten: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesWritten: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayStringForLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                verbose: u8,
                locationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                verbose: u8,
                locationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostMemory_ReadBytes(self: *const T, context: ?*IDebugHostContext, location: Location, buffer: ?*anyopaque, bufferSize: u64, bytesRead: ?*u64) HRESULT {
                return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).ReadBytes(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, buffer, bufferSize, bytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostMemory_WriteBytes(self: *const T, context: ?*IDebugHostContext, location: Location, buffer: ?*anyopaque, bufferSize: u64, bytesWritten: ?*u64) HRESULT {
                return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).WriteBytes(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, buffer, bufferSize, bytesWritten);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostMemory_ReadPointers(self: *const T, context: ?*IDebugHostContext, location: Location, count: u64, pointers: [*]u64) HRESULT {
                return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).ReadPointers(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, count, pointers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostMemory_WritePointers(self: *const T, context: ?*IDebugHostContext, location: Location, count: u64, pointers: [*]u64) HRESULT {
                return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).WritePointers(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, count, pointers);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostMemory_GetDisplayStringForLocation(self: *const T, context: ?*IDebugHostContext, location: Location, verbose: u8, locationName: ?*?BSTR) HRESULT {
                return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).GetDisplayStringForLocation(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, verbose, locationName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostEvaluator_Value = Guid.initString("0fef9a21-577e-4997-ac7b-1c4883241d99");
pub const IID_IDebugHostEvaluator = &IID_IDebugHostEvaluator_Value;
pub const IDebugHostEvaluator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateExtendedExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostEvaluator_EvaluateExpression(self: *const T, context: ?*IDebugHostContext, expression: ?[*:0]const u16, bindingContext: ?*IModelObject, result: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IDebugHostEvaluator.VTable, @ptrCast(self.vtable)).EvaluateExpression(@as(*const IDebugHostEvaluator, @ptrCast(self)), context, expression, bindingContext, result, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostEvaluator_EvaluateExtendedExpression(self: *const T, context: ?*IDebugHostContext, expression: ?[*:0]const u16, bindingContext: ?*IModelObject, result: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IDebugHostEvaluator.VTable, @ptrCast(self.vtable)).EvaluateExtendedExpression(@as(*const IDebugHostEvaluator, @ptrCast(self)), context, expression, bindingContext, result, metadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SignatureComparison = enum(i32) {
    Unrelated = 0,
    Ambiguous = 1,
    LessSpecific = 2,
    MoreSpecific = 3,
    Identical = 4,
};
pub const Unrelated = SignatureComparison.Unrelated;
pub const Ambiguous = SignatureComparison.Ambiguous;
pub const LessSpecific = SignatureComparison.LessSpecific;
pub const MoreSpecific = SignatureComparison.MoreSpecific;
pub const Identical = SignatureComparison.Identical;

const IID_IDebugHostModuleSignature_Value = Guid.initString("31e53a5a-01ee-4bbb-b899-4b46ae7d595c");
pub const IID_IDebugHostModuleSignature = &IID_IDebugHostModuleSignature_Value;
pub const IDebugHostModuleSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModuleSignature,
                pModule: ?*IDebugHostModule,
                isMatch: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModuleSignature,
                pModule: ?*IDebugHostModule,
                isMatch: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModuleSignature_IsMatch(self: *const T, pModule: ?*IDebugHostModule, isMatch: ?*bool) HRESULT {
                return @as(*const IDebugHostModuleSignature.VTable, @ptrCast(self.vtable)).IsMatch(@as(*const IDebugHostModuleSignature, @ptrCast(self)), pModule, isMatch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostTypeSignature_Value = Guid.initString("3aadc353-2b14-4abb-9893-5e03458e07ee");
pub const IID_IDebugHostTypeSignature = &IID_IDebugHostTypeSignature_Value;
pub const IDebugHostTypeSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHashCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostTypeSignature,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostTypeSignature,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostTypeSignature,
                type: ?*IDebugHostType,
                isMatch: ?*bool,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostTypeSignature,
                type: ?*IDebugHostType,
                isMatch: ?*bool,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareAgainst: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostTypeSignature,
                typeSignature: ?*IDebugHostTypeSignature,
                result: ?*SignatureComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostTypeSignature,
                typeSignature: ?*IDebugHostTypeSignature,
                result: ?*SignatureComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostTypeSignature_GetHashCode(self: *const T, hashCode: ?*u32) HRESULT {
                return @as(*const IDebugHostTypeSignature.VTable, @ptrCast(self.vtable)).GetHashCode(@as(*const IDebugHostTypeSignature, @ptrCast(self)), hashCode);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostTypeSignature_IsMatch(self: *const T, type_: ?*IDebugHostType, isMatch: ?*bool, wildcardMatches: ?*?*IDebugHostSymbolEnumerator) HRESULT {
                return @as(*const IDebugHostTypeSignature.VTable, @ptrCast(self.vtable)).IsMatch(@as(*const IDebugHostTypeSignature, @ptrCast(self)), type_, isMatch, wildcardMatches);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostTypeSignature_CompareAgainst(self: *const T, typeSignature: ?*IDebugHostTypeSignature, result: ?*SignatureComparison) HRESULT {
                return @as(*const IDebugHostTypeSignature.VTable, @ptrCast(self.vtable)).CompareAgainst(@as(*const IDebugHostTypeSignature, @ptrCast(self)), typeSignature, result);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SymbolSearchOptions = enum(i32) {
    None = 0,
    Completion = 1,
    CaseInsensitive = 2,
};
pub const SymbolSearchNone = SymbolSearchOptions.None;
pub const SymbolSearchCompletion = SymbolSearchOptions.Completion;
pub const SymbolSearchCaseInsensitive = SymbolSearchOptions.CaseInsensitive;

pub const LanguageKind = enum(i32) {
    Unknown = 0,
    C = 1,
    CPP = 2,
    Assembly = 3,
};
pub const LanguageUnknown = LanguageKind.Unknown;
pub const LanguageC = LanguageKind.C;
pub const LanguageCPP = LanguageKind.CPP;
pub const LanguageAssembly = LanguageKind.Assembly;

const IID_IDebugHostSymbol2_Value = Guid.initString("21515b67-6720-4257-8a68-077dc944471c");
pub const IID_IDebugHostSymbol2 = &IID_IDebugHostSymbol2_Value;
pub const IDebugHostSymbol2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostSymbol2,
                pKind: ?*LanguageKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostSymbol2,
                pKind: ?*LanguageKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostSymbol.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostSymbol2_GetLanguage(self: *const T, pKind: ?*LanguageKind) HRESULT {
                return @as(*const IDebugHostSymbol2.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IDebugHostSymbol2, @ptrCast(self)), pKind);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const VarArgsKind = enum(i32) {
    None = 0,
    CStyle = 1,
};
pub const VarArgsNone = VarArgsKind.None;
pub const VarArgsCStyle = VarArgsKind.CStyle;

const IID_IDebugHostType2_Value = Guid.initString("b28632b9-8506-4676-87ce-8f7e05e59876");
pub const IID_IDebugHostType2 = &IID_IDebugHostType2_Value;
pub const IDebugHostType2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostType.VTable,
        IsTypedef: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType2,
                isTypedef: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType2,
                isTypedef: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypedefBaseType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType2,
                baseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType2,
                baseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypedefFinalBaseType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType2,
                finalBaseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType2,
                finalBaseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionVarArgsKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType2,
                varArgsKind: ?*VarArgsKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType2,
                varArgsKind: ?*VarArgsKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionInstancePointerType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostType2,
                instancePointerType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostType2,
                instancePointerType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostType.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType2_IsTypedef(self: *const T, isTypedef: ?*bool) HRESULT {
                return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).IsTypedef(@as(*const IDebugHostType2, @ptrCast(self)), isTypedef);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType2_GetTypedefBaseType(self: *const T, baseType: ?*?*IDebugHostType2) HRESULT {
                return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetTypedefBaseType(@as(*const IDebugHostType2, @ptrCast(self)), baseType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType2_GetTypedefFinalBaseType(self: *const T, finalBaseType: ?*?*IDebugHostType2) HRESULT {
                return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetTypedefFinalBaseType(@as(*const IDebugHostType2, @ptrCast(self)), finalBaseType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType2_GetFunctionVarArgsKind(self: *const T, varArgsKind: ?*VarArgsKind) HRESULT {
                return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetFunctionVarArgsKind(@as(*const IDebugHostType2, @ptrCast(self)), varArgsKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostType2_GetFunctionInstancePointerType(self: *const T, instancePointerType: ?*?*IDebugHostType2) HRESULT {
                return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetFunctionInstancePointerType(@as(*const IDebugHostType2, @ptrCast(self)), instancePointerType);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostStatus_Value = Guid.initString("4f3e1ce2-86b2-4c7a-9c65-d0a9d0eecf44");
pub const IID_IDebugHostStatus = &IID_IDebugHostStatus_Value;
pub const IDebugHostStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PollUserInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostStatus,
                interruptRequested: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostStatus,
                interruptRequested: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostStatus_PollUserInterrupt(self: *const T, interruptRequested: ?*bool) HRESULT {
                return @as(*const IDebugHostStatus.VTable, @ptrCast(self.vtable)).PollUserInterrupt(@as(*const IDebugHostStatus, @ptrCast(self)), interruptRequested);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptClient_Value = Guid.initString("3b362b0e-89f0-46c6-a663-dfdc95194aef");
pub const IID_IDataModelScriptClient = &IID_IDataModelScriptClient_Value;
pub const IDataModelScriptClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptClient,
                errClass: ErrorClass,
                hrFail: HRESULT,
                message: ?[*:0]const u16,
                line: u32,
                position: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptClient,
                errClass: ErrorClass,
                hrFail: HRESULT,
                message: ?[*:0]const u16,
                line: u32,
                position: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptClient_ReportError(self: *const T, errClass: ErrorClass, hrFail: HRESULT, message: ?[*:0]const u16, line: u32, position: u32) HRESULT {
                return @as(*const IDataModelScriptClient.VTable, @ptrCast(self.vtable)).ReportError(@as(*const IDataModelScriptClient, @ptrCast(self)), errClass, hrFail, message, line, position);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptTemplate_Value = Guid.initString("1303dec4-fa3b-4f1b-9224-b953d16babb5");
pub const IID_IDataModelScriptTemplate = &IID_IDataModelScriptTemplate_Value;
pub const IDataModelScriptTemplate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptTemplate,
                templateName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptTemplate,
                templateName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptTemplate,
                templateDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptTemplate,
                templateDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptTemplate,
                contentStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptTemplate,
                contentStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptTemplate_GetName(self: *const T, templateName: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptTemplate.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScriptTemplate, @ptrCast(self)), templateName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptTemplate_GetDescription(self: *const T, templateDescription: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptTemplate.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDataModelScriptTemplate, @ptrCast(self)), templateDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptTemplate_GetContent(self: *const T, contentStream: ?*?*IStream) HRESULT {
                return @as(*const IDataModelScriptTemplate.VTable, @ptrCast(self.vtable)).GetContent(@as(*const IDataModelScriptTemplate, @ptrCast(self)), contentStream);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScript_Value = Guid.initString("7b4d30fc-b14a-49f8-8d87-d9a1480c97f7");
pub const IID_IDataModelScript = &IID_IDataModelScript_Value;
pub const IDataModelScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
                scriptName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
                scriptName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
                scriptName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
                scriptName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Populate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
                contentStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
                contentStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInvocable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
                isInvocable: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
                isInvocable: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeMain: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_GetName(self: *const T, scriptName: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScript, @ptrCast(self)), scriptName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_Rename(self: *const T, scriptName: ?[*:0]const u16) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Rename(@as(*const IDataModelScript, @ptrCast(self)), scriptName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_Populate(self: *const T, contentStream: ?*IStream) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Populate(@as(*const IDataModelScript, @ptrCast(self)), contentStream);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_Execute(self: *const T, client: ?*IDataModelScriptClient) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDataModelScript, @ptrCast(self)), client);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_Unlink(self: *const T) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Unlink(@as(*const IDataModelScript, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_IsInvocable(self: *const T, isInvocable: ?*bool) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).IsInvocable(@as(*const IDataModelScript, @ptrCast(self)), isInvocable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScript_InvokeMain(self: *const T, client: ?*IDataModelScriptClient) HRESULT {
                return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).InvokeMain(@as(*const IDataModelScript, @ptrCast(self)), client);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptTemplateEnumerator_Value = Guid.initString("69ce6ae2-2268-4e6f-b062-20ce62bfe677");
pub const IID_IDataModelScriptTemplateEnumerator = &IID_IDataModelScriptTemplateEnumerator_Value;
pub const IDataModelScriptTemplateEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptTemplateEnumerator,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptTemplateEnumerator,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptTemplateEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IDataModelScriptTemplateEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptTemplateEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptTemplateEnumerator_GetNext(self: *const T, templateContent: ?*?*IDataModelScriptTemplate) HRESULT {
                return @as(*const IDataModelScriptTemplateEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptTemplateEnumerator, @ptrCast(self)), templateContent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptProvider_Value = Guid.initString("513461e0-4fca-48ce-8658-32f3e2056f3b");
pub const IID_IDataModelScriptProvider = &IID_IDataModelScriptProvider_Value;
pub const IDataModelScriptProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProvider,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProvider,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProvider,
                extension: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProvider,
                extension: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProvider,
                script: ?*?*IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProvider,
                script: ?*?*IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultTemplateContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProvider,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProvider,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTemplates: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProvider,
                enumerator: ?*?*IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProvider,
                enumerator: ?*?*IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProvider_GetName(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScriptProvider, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProvider_GetExtension(self: *const T, extension: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).GetExtension(@as(*const IDataModelScriptProvider, @ptrCast(self)), extension);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProvider_CreateScript(self: *const T, script: ?*?*IDataModelScript) HRESULT {
                return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).CreateScript(@as(*const IDataModelScriptProvider, @ptrCast(self)), script);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProvider_GetDefaultTemplateContent(self: *const T, templateContent: ?*?*IDataModelScriptTemplate) HRESULT {
                return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).GetDefaultTemplateContent(@as(*const IDataModelScriptProvider, @ptrCast(self)), templateContent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProvider_EnumerateTemplates(self: *const T, enumerator: ?*?*IDataModelScriptTemplateEnumerator) HRESULT {
                return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).EnumerateTemplates(@as(*const IDataModelScriptProvider, @ptrCast(self)), enumerator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptProviderEnumerator_Value = Guid.initString("95ba00e2-704a-4fe2-a8f1-a7e7d8fb0941");
pub const IID_IDataModelScriptProviderEnumerator = &IID_IDataModelScriptProviderEnumerator_Value;
pub const IDataModelScriptProviderEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptProviderEnumerator,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptProviderEnumerator,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProviderEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IDataModelScriptProviderEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptProviderEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptProviderEnumerator_GetNext(self: *const T, provider: ?*?*IDataModelScriptProvider) HRESULT {
                return @as(*const IDataModelScriptProviderEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptProviderEnumerator, @ptrCast(self)), provider);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptManager_Value = Guid.initString("6fd11e33-e5ad-410b-8011-68c6bc4bf80d");
pub const IID_IDataModelScriptManager = &IID_IDataModelScriptManager_Value;
pub const IDataModelScriptManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultNameBinder: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptManager,
                ppNameBinder: ?*?*IDataModelNameBinder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptManager,
                ppNameBinder: ?*?*IDataModelNameBinder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterScriptProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterScriptProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProviderForScriptType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptManager,
                scriptType: ?[*:0]const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptManager,
                scriptType: ?[*:0]const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProviderForScriptExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptManager,
                scriptExtension: ?[*:0]const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptManager,
                scriptExtension: ?[*:0]const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateScriptProviders: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptManager,
                enumerator: ?*?*IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptManager,
                enumerator: ?*?*IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptManager_GetDefaultNameBinder(self: *const T, ppNameBinder: ?*?*IDataModelNameBinder) HRESULT {
                return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).GetDefaultNameBinder(@as(*const IDataModelScriptManager, @ptrCast(self)), ppNameBinder);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptManager_RegisterScriptProvider(self: *const T, provider: ?*IDataModelScriptProvider) HRESULT {
                return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).RegisterScriptProvider(@as(*const IDataModelScriptManager, @ptrCast(self)), provider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptManager_UnregisterScriptProvider(self: *const T, provider: ?*IDataModelScriptProvider) HRESULT {
                return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).UnregisterScriptProvider(@as(*const IDataModelScriptManager, @ptrCast(self)), provider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptManager_FindProviderForScriptType(self: *const T, scriptType: ?[*:0]const u16, provider: ?*?*IDataModelScriptProvider) HRESULT {
                return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).FindProviderForScriptType(@as(*const IDataModelScriptManager, @ptrCast(self)), scriptType, provider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptManager_FindProviderForScriptExtension(self: *const T, scriptExtension: ?[*:0]const u16, provider: ?*?*IDataModelScriptProvider) HRESULT {
                return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).FindProviderForScriptExtension(@as(*const IDataModelScriptManager, @ptrCast(self)), scriptExtension, provider);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptManager_EnumerateScriptProviders(self: *const T, enumerator: ?*?*IDataModelScriptProviderEnumerator) HRESULT {
                return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).EnumerateScriptProviders(@as(*const IDataModelScriptManager, @ptrCast(self)), enumerator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicKeyProviderConcept_Value = Guid.initString("e7983fa1-80a7-498c-988f-518ddc5d4025");
pub const IID_IDynamicKeyProviderConcept = &IID_IDynamicKeyProviderConcept_Value;
pub const IDynamicKeyProviderConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]const u16,
                keyValue: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
                hasKey: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]const u16,
                keyValue: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
                hasKey: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]const u16,
                keyValue: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]const u16,
                keyValue: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                ppEnumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                ppEnumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicKeyProviderConcept_GetKey(self: *const T, contextObject: ?*IModelObject, key: ?[*:0]const u16, keyValue: ?*?*IModelObject, metadata: ?*?*IKeyStore, hasKey: ?*bool) HRESULT {
                return @as(*const IDynamicKeyProviderConcept.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IDynamicKeyProviderConcept, @ptrCast(self)), contextObject, key, keyValue, metadata, hasKey);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicKeyProviderConcept_SetKey(self: *const T, contextObject: ?*IModelObject, key: ?[*:0]const u16, keyValue: ?*IModelObject, metadata: ?*IKeyStore) HRESULT {
                return @as(*const IDynamicKeyProviderConcept.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IDynamicKeyProviderConcept, @ptrCast(self)), contextObject, key, keyValue, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicKeyProviderConcept_EnumerateKeys(self: *const T, contextObject: ?*IModelObject, ppEnumerator: ?*?*IKeyEnumerator) HRESULT {
                return @as(*const IDynamicKeyProviderConcept.VTable, @ptrCast(self.vtable)).EnumerateKeys(@as(*const IDynamicKeyProviderConcept, @ptrCast(self)), contextObject, ppEnumerator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicConceptProviderConcept_Value = Guid.initString("95a7f7dd-602e-483f-9d06-a15c0ee13174");
pub const IID_IDynamicConceptProviderConcept = &IID_IDynamicConceptProviderConcept_Value;
pub const IDynamicConceptProviderConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
                hasConcept: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
                hasConcept: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyParentChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyDestruct: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDynamicConceptProviderConcept,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDynamicConceptProviderConcept,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicConceptProviderConcept_GetConcept(self: *const T, contextObject: ?*IModelObject, conceptId: ?*const Guid, conceptInterface: ?*?*IUnknown, conceptMetadata: ?*?*IKeyStore, hasConcept: ?*bool) HRESULT {
                return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).GetConcept(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), contextObject, conceptId, conceptInterface, conceptMetadata, hasConcept);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicConceptProviderConcept_SetConcept(self: *const T, contextObject: ?*IModelObject, conceptId: ?*const Guid, conceptInterface: ?*IUnknown, conceptMetadata: ?*IKeyStore) HRESULT {
                return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).SetConcept(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), contextObject, conceptId, conceptInterface, conceptMetadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicConceptProviderConcept_NotifyParent(self: *const T, parentModel: ?*IModelObject) HRESULT {
                return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).NotifyParent(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), parentModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicConceptProviderConcept_NotifyParentChange(self: *const T, parentModel: ?*IModelObject) HRESULT {
                return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).NotifyParentChange(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), parentModel);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDynamicConceptProviderConcept_NotifyDestruct(self: *const T) HRESULT {
                return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).NotifyDestruct(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ScriptChangeKind = enum(i32) {
    e = 0,
};
pub const ScriptRename = ScriptChangeKind.e;

const IID_IDataModelScriptHostContext_Value = Guid.initString("014d366a-1f23-4981-9219-b2db8b402054");
pub const IID_IDataModelScriptHostContext = &IID_IDataModelScriptHostContext_Value;
pub const IDataModelScriptHostContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyScriptChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptHostContext,
                script: ?*IDataModelScript,
                changeKind: ScriptChangeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptHostContext,
                script: ?*IDataModelScript,
                changeKind: ScriptChangeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamespaceObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptHostContext,
                namespaceObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptHostContext,
                namespaceObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptHostContext_NotifyScriptChange(self: *const T, script: ?*IDataModelScript, changeKind: ScriptChangeKind) HRESULT {
                return @as(*const IDataModelScriptHostContext.VTable, @ptrCast(self.vtable)).NotifyScriptChange(@as(*const IDataModelScriptHostContext, @ptrCast(self)), script, changeKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptHostContext_GetNamespaceObject(self: *const T, namespaceObject: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelScriptHostContext.VTable, @ptrCast(self.vtable)).GetNamespaceObject(@as(*const IDataModelScriptHostContext, @ptrCast(self)), namespaceObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostScriptHost_Value = Guid.initString("b70334a4-b92c-4570-93a1-d3eb686649a0");
pub const IID_IDebugHostScriptHost = &IID_IDebugHostScriptHost_Value;
pub const IDebugHostScriptHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostScriptHost,
                script: ?*IDataModelScript,
                scriptContext: ?*?*IDataModelScriptHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostScriptHost,
                script: ?*IDataModelScript,
                scriptContext: ?*?*IDataModelScriptHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostScriptHost_CreateContext(self: *const T, script: ?*IDataModelScript, scriptContext: ?*?*IDataModelScriptHostContext) HRESULT {
                return @as(*const IDebugHostScriptHost.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const IDebugHostScriptHost, @ptrCast(self)), script, scriptContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelNameBinder_Value = Guid.initString("af352b7b-8292-4c01-b360-2dc3696c65e7");
pub const IID_IDataModelNameBinder = &IID_IDataModelNameBinder_Value;
pub const IDataModelNameBinder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]const u16,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]const u16,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]const u16,
                reference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]const u16,
                reference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelNameBinder_BindValue(self: *const T, contextObject: ?*IModelObject, name: ?[*:0]const u16, value: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).BindValue(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, name, value, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelNameBinder_BindReference(self: *const T, contextObject: ?*IModelObject, name: ?[*:0]const u16, reference: ?*?*IModelObject, metadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).BindReference(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, name, reference, metadata);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelNameBinder_EnumerateValues(self: *const T, contextObject: ?*IModelObject, enumerator: ?*?*IKeyEnumerator) HRESULT {
                return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).EnumerateValues(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, enumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelNameBinder_EnumerateReferences(self: *const T, contextObject: ?*IModelObject, enumerator: ?*?*IKeyEnumerator) HRESULT {
                return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).EnumerateReferences(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, enumerator);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelKeyReference2_Value = Guid.initString("80e2f7c5-7159-4e92-887e-7e0347e88406");
pub const IID_IModelKeyReference2 = &IID_IModelKeyReference2_Value;
pub const IModelKeyReference2 = extern struct {
    pub const VTable = extern struct {
        base: IModelKeyReference.VTable,
        OverrideContextObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IModelKeyReference2,
                newContextObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IModelKeyReference2,
                newContextObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IModelKeyReference.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IModelKeyReference2_OverrideContextObject(self: *const T, newContextObject: ?*IModelObject) HRESULT {
                return @as(*const IModelKeyReference2.VTable, @ptrCast(self.vtable)).OverrideContextObject(@as(*const IModelKeyReference2, @ptrCast(self)), newContextObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostEvaluator2_Value = Guid.initString("a117a435-1fb4-4092-a2ab-a929576c1e87");
pub const IID_IDebugHostEvaluator2 = &IID_IDebugHostEvaluator2_Value;
pub const IDebugHostEvaluator2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostEvaluator.VTable,
        AssignTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostEvaluator2,
                assignmentReference: ?*IModelObject,
                assignmentValue: ?*IModelObject,
                assignmentResult: ?*?*IModelObject,
                assignmentMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostEvaluator2,
                assignmentReference: ?*IModelObject,
                assignmentValue: ?*IModelObject,
                assignmentResult: ?*?*IModelObject,
                assignmentMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostEvaluator.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostEvaluator2_AssignTo(self: *const T, assignmentReference: ?*IModelObject, assignmentValue: ?*IModelObject, assignmentResult: ?*?*IModelObject, assignmentMetadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IDebugHostEvaluator2.VTable, @ptrCast(self.vtable)).AssignTo(@as(*const IDebugHostEvaluator2, @ptrCast(self)), assignmentReference, assignmentValue, assignmentResult, assignmentMetadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelManager2_Value = Guid.initString("f412c5ea-2284-4622-a660-a697160d3312");
pub const IID_IDataModelManager2 = &IID_IDataModelManager2_Value;
pub const IDataModelManager2 = extern struct {
    pub const VTable = extern struct {
        base: IDataModelManager.VTable,
        AcquireSubNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager2,
                modelName: ?[*:0]const u16,
                subNamespaceModelName: ?[*:0]const u16,
                accessName: ?[*:0]const u16,
                metadata: ?*IKeyStore,
                namespaceModelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager2,
                modelName: ?[*:0]const u16,
                subNamespaceModelName: ?[*:0]const u16,
                accessName: ?[*:0]const u16,
                metadata: ?*IKeyStore,
                namespaceModelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedIntrinsicObjectEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelManager2,
                context: ?*IDebugHostContext,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelManager2,
                context: ?*IDebugHostContext,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDataModelManager.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager2_AcquireSubNamespace(self: *const T, modelName: ?[*:0]const u16, subNamespaceModelName: ?[*:0]const u16, accessName: ?[*:0]const u16, metadata: ?*IKeyStore, namespaceModelObject: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager2.VTable, @ptrCast(self.vtable)).AcquireSubNamespace(@as(*const IDataModelManager2, @ptrCast(self)), modelName, subNamespaceModelName, accessName, metadata, namespaceModelObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelManager2_CreateTypedIntrinsicObjectEx(self: *const T, context: ?*IDebugHostContext, intrinsicData: ?*VARIANT, type_: ?*IDebugHostType, object: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelManager2.VTable, @ptrCast(self.vtable)).CreateTypedIntrinsicObjectEx(@as(*const IDataModelManager2, @ptrCast(self)), context, intrinsicData, type_, object);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostMemory2_Value = Guid.initString("eea033de-38f6-416b-a251-1d3771001270");
pub const IID_IDebugHostMemory2 = &IID_IDebugHostMemory2_Value;
pub const IDebugHostMemory2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostMemory.VTable,
        LinearizeLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostMemory2,
                context: ?*IDebugHostContext,
                location: Location,
                pLinearizedLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostMemory2,
                context: ?*IDebugHostContext,
                location: Location,
                pLinearizedLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostMemory.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostMemory2_LinearizeLocation(self: *const T, context: ?*IDebugHostContext, location: Location, pLinearizedLocation: ?*Location) HRESULT {
                return @as(*const IDebugHostMemory2.VTable, @ptrCast(self.vtable)).LinearizeLocation(@as(*const IDebugHostMemory2, @ptrCast(self)), context, location, pLinearizedLocation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostExtensibility_Value = Guid.initString("3c2b24e1-11d0-4f86-8ae5-4df166f73253");
pub const IID_IDebugHostExtensibility = &IID_IDebugHostExtensibility_Value;
pub const IDebugHostExtensibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateFunctionAlias: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]const u16,
                functionObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]const u16,
                functionObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyFunctionAlias: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostExtensibility_CreateFunctionAlias(self: *const T, aliasName: ?[*:0]const u16, functionObject: ?*IModelObject) HRESULT {
                return @as(*const IDebugHostExtensibility.VTable, @ptrCast(self.vtable)).CreateFunctionAlias(@as(*const IDebugHostExtensibility, @ptrCast(self)), aliasName, functionObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostExtensibility_DestroyFunctionAlias(self: *const T, aliasName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugHostExtensibility.VTable, @ptrCast(self.vtable)).DestroyFunctionAlias(@as(*const IDebugHostExtensibility, @ptrCast(self)), aliasName);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const ScriptDebugState = enum(i32) {
    NoDebugger = 0,
    NotExecuting = 1,
    Executing = 2,
    Break = 3,
};
pub const ScriptDebugNoDebugger = ScriptDebugState.NoDebugger;
pub const ScriptDebugNotExecuting = ScriptDebugState.NotExecuting;
pub const ScriptDebugExecuting = ScriptDebugState.Executing;
pub const ScriptDebugBreak = ScriptDebugState.Break;

pub const ScriptDebugEventFilter = enum(i32) {
    Entry = 0,
    Exception = 1,
    UnhandledException = 2,
    Abort = 3,
};
pub const ScriptDebugEventFilterEntry = ScriptDebugEventFilter.Entry;
pub const ScriptDebugEventFilterException = ScriptDebugEventFilter.Exception;
pub const ScriptDebugEventFilterUnhandledException = ScriptDebugEventFilter.UnhandledException;
pub const ScriptDebugEventFilterAbort = ScriptDebugEventFilter.Abort;

pub const ScriptDebugEvent = enum(i32) {
    Breakpoint = 0,
    Step = 1,
    Exception = 2,
    AsyncBreak = 3,
};
pub const ScriptDebugBreakpoint = ScriptDebugEvent.Breakpoint;
pub const ScriptDebugStep = ScriptDebugEvent.Step;
pub const ScriptDebugException = ScriptDebugEvent.Exception;
pub const ScriptDebugAsyncBreak = ScriptDebugEvent.AsyncBreak;

pub const ScriptExecutionKind = enum(i32) {
    Normal = 0,
    StepIn = 1,
    StepOut = 2,
    StepOver = 3,
};
pub const ScriptExecutionNormal = ScriptExecutionKind.Normal;
pub const ScriptExecutionStepIn = ScriptExecutionKind.StepIn;
pub const ScriptExecutionStepOut = ScriptExecutionKind.StepOut;
pub const ScriptExecutionStepOver = ScriptExecutionKind.StepOver;

pub const ScriptDebugPosition = extern struct {
    Line: u32,
    Column: u32,
};

pub const ScriptDebugEventInformation = extern struct {
    DebugEvent: ScriptDebugEvent,
    EventPosition: ScriptDebugPosition,
    EventSpanEnd: ScriptDebugPosition,
    u: extern union {
        ExceptionInformation: extern struct {
            IsUncaught: bool,
        },
        BreakpointInformation: extern struct {
            BreakpointId: u64,
        },
    },
};

const IID_IDataModelScriptDebugClient_Value = Guid.initString("53159b6d-d4c4-471b-a863-5b110ca800ca");
pub const IID_IDataModelScriptDebugClient = &IID_IDataModelScriptDebugClient_Value;
pub const IDataModelScriptDebugClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyDebugEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugClient,
                pEventInfo: ?*ScriptDebugEventInformation,
                pScript: ?*IDataModelScript,
                pEventDataObject: ?*IModelObject,
                resumeEventKind: ?*ScriptExecutionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugClient,
                pEventInfo: ?*ScriptDebugEventInformation,
                pScript: ?*IDataModelScript,
                pEventDataObject: ?*IModelObject,
                resumeEventKind: ?*ScriptExecutionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugClient_NotifyDebugEvent(self: *const T, pEventInfo: ?*ScriptDebugEventInformation, pScript: ?*IDataModelScript, pEventDataObject: ?*IModelObject, resumeEventKind: ?*ScriptExecutionKind) HRESULT {
                return @as(*const IDataModelScriptDebugClient.VTable, @ptrCast(self.vtable)).NotifyDebugEvent(@as(*const IDataModelScriptDebugClient, @ptrCast(self)), pEventInfo, pScript, pEventDataObject, resumeEventKind);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugVariableSetEnumerator_Value = Guid.initString("0f9feed7-d045-4ac3-98a8-a98942cf6a35");
pub const IID_IDataModelScriptDebugVariableSetEnumerator = &IID_IDataModelScriptDebugVariableSetEnumerator_Value;
pub const IDataModelScriptDebugVariableSetEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugVariableSetEnumerator,
                variableName: ?*?BSTR,
                variableValue: ?*?*IModelObject,
                variableMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugVariableSetEnumerator,
                variableName: ?*?BSTR,
                variableValue: ?*?*IModelObject,
                variableMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugVariableSetEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IDataModelScriptDebugVariableSetEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptDebugVariableSetEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugVariableSetEnumerator_GetNext(self: *const T, variableName: ?*?BSTR, variableValue: ?*?*IModelObject, variableMetadata: ?*?*IKeyStore) HRESULT {
                return @as(*const IDataModelScriptDebugVariableSetEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptDebugVariableSetEnumerator, @ptrCast(self)), variableName, variableValue, variableMetadata);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugStackFrame_Value = Guid.initString("dec6ed5e-6360-4941-ab4c-a26409de4f82");
pub const IID_IDataModelScriptDebugStackFrame = &IID_IDataModelScriptDebugStackFrame_Value;
pub const IDataModelScriptDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTransitionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                isTransitionPoint: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                isTransitionPoint: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                transitionScript: ?*?*IDataModelScript,
                isTransitionContiguous: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                transitionScript: ?*?*IDataModelScript,
                isTransitionContiguous: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                pwszExpression: ?[*:0]const u16,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                pwszExpression: ?[*:0]const u16,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateLocals: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_GetName(self: *const T, name: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), name);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_GetPosition(self: *const T, position: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), position, positionSpanEnd, lineText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_IsTransitionPoint(self: *const T, isTransitionPoint: ?*bool) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).IsTransitionPoint(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), isTransitionPoint);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_GetTransition(self: *const T, transitionScript: ?*?*IDataModelScript, isTransitionContiguous: ?*bool) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).GetTransition(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), transitionScript, isTransitionContiguous);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_Evaluate(self: *const T, pwszExpression: ?[*:0]const u16, ppResult: ?*?*IModelObject) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), pwszExpression, ppResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_EnumerateLocals(self: *const T, variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).EnumerateLocals(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), variablesEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStackFrame_EnumerateArguments(self: *const T, variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator) HRESULT {
                return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).EnumerateArguments(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), variablesEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugStack_Value = Guid.initString("051364dd-e449-443e-9762-fe578f4a5473");
pub const IID_IDataModelScriptDebugStack = &IID_IDataModelScriptDebugStack_Value;
pub const IDataModelScriptDebugStack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn (
                self: *const IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetStackFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugStack,
                frameNumber: u64,
                stackFrame: ?*?*IDataModelScriptDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugStack,
                frameNumber: u64,
                stackFrame: ?*?*IDataModelScriptDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStack_GetFrameCount(self: *const T) u64 {
                return @as(*const IDataModelScriptDebugStack.VTable, @ptrCast(self.vtable)).GetFrameCount(@as(*const IDataModelScriptDebugStack, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugStack_GetStackFrame(self: *const T, frameNumber: u64, stackFrame: ?*?*IDataModelScriptDebugStackFrame) HRESULT {
                return @as(*const IDataModelScriptDebugStack.VTable, @ptrCast(self.vtable)).GetStackFrame(@as(*const IDataModelScriptDebugStack, @ptrCast(self)), frameNumber, stackFrame);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugBreakpoint_Value = Guid.initString("6bb27b35-02e6-47cb-90a0-5371244032de");
pub const IID_IDataModelScriptDebugBreakpoint = &IID_IDataModelScriptDebugBreakpoint_Value;
pub const IDataModelScriptDebugBreakpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Disable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpoint,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpoint,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpoint_GetId(self: *const T) u64 {
                return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpoint_IsEnabled(self: *const T) bool {
                return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpoint_Enable(self: *const T) void {
                return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).Enable(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpoint_Disable(self: *const T) void {
                return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).Disable(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpoint_Remove(self: *const T) void {
                return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).Remove(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpoint_GetPosition(self: *const T, position: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)), position, positionSpanEnd, lineText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugBreakpointEnumerator_Value = Guid.initString("39484a75-b4f3-4799-86da-691afa57b299");
pub const IID_IDataModelScriptDebugBreakpointEnumerator = &IID_IDataModelScriptDebugBreakpointEnumerator_Value;
pub const IDataModelScriptDebugBreakpointEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebugBreakpointEnumerator,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebugBreakpointEnumerator,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpointEnumerator_Reset(self: *const T) HRESULT {
                return @as(*const IDataModelScriptDebugBreakpointEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptDebugBreakpointEnumerator, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebugBreakpointEnumerator_GetNext(self: *const T, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) HRESULT {
                return @as(*const IDataModelScriptDebugBreakpointEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptDebugBreakpointEnumerator, @ptrCast(self)), breakpoint);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebug_Value = Guid.initString("de8e0945-9750-4471-ab76-a8f79d6ec350");
pub const IID_IDataModelScriptDebug = &IID_IDataModelScriptDebug_Value;
pub const IDataModelScriptDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDebugState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
            ) callconv(@import("std").os.windows.WINAPI) ScriptDebugState,
            else => *const fn (
                self: *const IDataModelScriptDebug,
            ) callconv(@import("std").os.windows.WINAPI) ScriptDebugState,
        },
        GetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                currentPosition: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                currentPosition: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStack: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                stack: ?*?*IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                stack: ?*?*IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                linePosition: u32,
                columnPosition: u32,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                linePosition: u32,
                columnPosition: u32,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                breakpointId: u64,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                breakpointId: u64,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_GetDebugState(self: *const T) ScriptDebugState {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetDebugState(@as(*const IDataModelScriptDebug, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_GetCurrentPosition(self: *const T, currentPosition: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetCurrentPosition(@as(*const IDataModelScriptDebug, @ptrCast(self)), currentPosition, positionSpanEnd, lineText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_GetStack(self: *const T, stack: ?*?*IDataModelScriptDebugStack) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetStack(@as(*const IDataModelScriptDebug, @ptrCast(self)), stack);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_SetBreakpoint(self: *const T, linePosition: u32, columnPosition: u32, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).SetBreakpoint(@as(*const IDataModelScriptDebug, @ptrCast(self)), linePosition, columnPosition, breakpoint);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_FindBreakpointById(self: *const T, breakpointId: u64, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).FindBreakpointById(@as(*const IDataModelScriptDebug, @ptrCast(self)), breakpointId, breakpoint);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_EnumerateBreakpoints(self: *const T, breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).EnumerateBreakpoints(@as(*const IDataModelScriptDebug, @ptrCast(self)), breakpointEnum);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_GetEventFilter(self: *const T, eventFilter: ScriptDebugEventFilter, isBreakEnabled: ?*bool) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetEventFilter(@as(*const IDataModelScriptDebug, @ptrCast(self)), eventFilter, isBreakEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_SetEventFilter(self: *const T, eventFilter: ScriptDebugEventFilter, isBreakEnabled: u8) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).SetEventFilter(@as(*const IDataModelScriptDebug, @ptrCast(self)), eventFilter, isBreakEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_StartDebugging(self: *const T, debugClient: ?*IDataModelScriptDebugClient) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).StartDebugging(@as(*const IDataModelScriptDebug, @ptrCast(self)), debugClient);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug_StopDebugging(self: *const T, debugClient: ?*IDataModelScriptDebugClient) HRESULT {
                return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).StopDebugging(@as(*const IDataModelScriptDebug, @ptrCast(self)), debugClient);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebug2_Value = Guid.initString("cbb10ed3-839e-426c-9243-e23535c1ae1a");
pub const IID_IDataModelScriptDebug2 = &IID_IDataModelScriptDebug2_Value;
pub const IDataModelScriptDebug2 = extern struct {
    pub const VTable = extern struct {
        base: IDataModelScriptDebug.VTable,
        SetBreakpointAtFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDataModelScriptDebug2,
                functionName: ?[*:0]const u16,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDataModelScriptDebug2,
                functionName: ?[*:0]const u16,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDataModelScriptDebug.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDataModelScriptDebug2_SetBreakpointAtFunction(self: *const T, functionName: ?[*:0]const u16, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) HRESULT {
                return @as(*const IDataModelScriptDebug2.VTable, @ptrCast(self.vtable)).SetBreakpointAtFunction(@as(*const IDataModelScriptDebug2, @ptrCast(self)), functionName, breakpoint);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostModule2_Value = Guid.initString("b51887e8-bcd0-4e8f-a8c7-434398b78c37");
pub const IID_IDebugHostModule2 = &IID_IDebugHostModule2_Value;
pub const IDebugHostModule2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostModule.VTable,
        FindContainingSymbolByRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHostModule2,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHostModule2,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugHostModule.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHostModule2_FindContainingSymbolByRVA(self: *const T, rva: u64, symbol: ?*?*IDebugHostSymbol, offset: ?*u64) HRESULT {
                return @as(*const IDebugHostModule2.VTable, @ptrCast(self.vtable)).FindContainingSymbolByRVA(@as(*const IDebugHostModule2, @ptrCast(self)), rva, symbol, offset);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IComparableConcept_Value = Guid.initString("a7830646-9f0c-4a31-ba19-503f33e6c8a3");
pub const IID_IComparableConcept = &IID_IComparableConcept_Value;
pub const IComparableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IComparableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                comparisonResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IComparableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                comparisonResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IComparableConcept_CompareObjects(self: *const T, contextObject: ?*IModelObject, otherObject: ?*IModelObject, comparisonResult: ?*i32) HRESULT {
                return @as(*const IComparableConcept.VTable, @ptrCast(self.vtable)).CompareObjects(@as(*const IComparableConcept, @ptrCast(self)), contextObject, otherObject, comparisonResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEquatableConcept_Value = Guid.initString("c52d5d3d-609d-4d5d-8a82-46b0acdec4f4");
pub const IID_IEquatableConcept = &IID_IEquatableConcept_Value;
pub const IEquatableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreObjectsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEquatableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                isEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEquatableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                isEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEquatableConcept_AreObjectsEqual(self: *const T, contextObject: ?*IModelObject, otherObject: ?*IModelObject, isEqual: ?*bool) HRESULT {
                return @as(*const IEquatableConcept.VTable, @ptrCast(self.vtable)).AreObjectsEqual(@as(*const IEquatableConcept, @ptrCast(self)), contextObject, otherObject, isEqual);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PWINDBG_OUTPUT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpFormat: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        lpFormat: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_GET_EXPRESSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpExpression: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) usize,
    else => *const fn (
        lpExpression: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) usize,
};

pub const PWINDBG_GET_EXPRESSION32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpExpression: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        lpExpression: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_GET_EXPRESSION64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpExpression: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) u64,
    else => *const fn (
        lpExpression: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) u64,
};

pub const PWINDBG_GET_SYMBOL = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: ?*anyopaque,
        pchBuffer: ?[*]u8,
        pDisplacement: ?*usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        offset: ?*anyopaque,
        pchBuffer: ?[*]u8,
        pDisplacement: ?*usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_GET_SYMBOL32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: u32,
        pchBuffer: ?[*]u8,
        pDisplacement: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        offset: u32,
        pchBuffer: ?[*]u8,
        pDisplacement: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_GET_SYMBOL64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: u64,
        pchBuffer: ?[*]u8,
        pDisplacement: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        offset: u64,
        pchBuffer: ?[*]u8,
        pDisplacement: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_DISASM = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpOffset: ?*usize,
        lpBuffer: ?[*:0]const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        lpOffset: ?*usize,
        lpBuffer: ?[*:0]const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_DISASM32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpOffset: ?*u32,
        lpBuffer: ?[*:0]const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        lpOffset: ?*u32,
        lpBuffer: ?[*:0]const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_DISASM64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpOffset: ?*u64,
        lpBuffer: ?[*:0]const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        lpOffset: ?*u64,
        lpBuffer: ?[*:0]const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_CHECK_CONTROL_C = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: usize,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        offset: usize,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: u32,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        offset: u32,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: u64,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        offset: u64,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: usize,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        offset: usize,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: u32,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        offset: u32,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        offset: u64,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        offset: u64,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_GET_THREAD_CONTEXT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_SET_THREAD_CONTEXT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_IOCTL_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        IoctlType: u16,
        lpvData: ?*anyopaque,
        cbSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        IoctlType: u16,
        lpvData: ?*anyopaque,
        cbSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_OLDKD_READ_PHYSICAL_MEMORY = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        address: u64,
        buffer: ?*anyopaque,
        count: u32,
        bytesread: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        address: u64,
        buffer: ?*anyopaque,
        count: u32,
        bytesread: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        address: u64,
        buffer: ?*anyopaque,
        length: u32,
        byteswritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        address: u64,
        buffer: ?*anyopaque,
        length: u32,
        byteswritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const EXTSTACKTRACE = extern struct {
    FramePointer: u32,
    ProgramCounter: u32,
    ReturnAddress: u32,
    Args: [4]u32,
};

pub const EXTSTACKTRACE32 = extern struct {
    FramePointer: u32,
    ProgramCounter: u32,
    ReturnAddress: u32,
    Args: [4]u32,
};

pub const EXTSTACKTRACE64 = extern struct {
    FramePointer: u64,
    ProgramCounter: u64,
    ReturnAddress: u64,
    Args: [4]u64,
};

pub const PWINDBG_STACKTRACE_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_STACKTRACE_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE32,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE32,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PWINDBG_STACKTRACE_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FramePointer: u64,
        StackPointer: u64,
        ProgramCounter: u64,
        StackFrames: ?*EXTSTACKTRACE64,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        FramePointer: u64,
        StackPointer: u64,
        ProgramCounter: u64,
        StackFrames: ?*EXTSTACKTRACE64,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const WINDBG_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL,
    lpDisasmRoutine: ?PWINDBG_DISASM,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE,
};

pub const WINDBG_EXTENSION_APIS32 = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION32,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL32,
    lpDisasmRoutine: ?PWINDBG_DISASM32,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE32,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE32,
};

pub const WINDBG_EXTENSION_APIS64 = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION64,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL64,
    lpDisasmRoutine: ?PWINDBG_DISASM64,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE64,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE64,
};

pub const WINDBG_OLD_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL,
    lpDisasmRoutine: ?PWINDBG_DISASM,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
};

pub const WINDBG_OLDKD_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION32,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL32,
    lpDisasmRoutine: ?PWINDBG_DISASM32,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadVirtualMemRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE32,
    lpWriteVirtualMemRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32,
    lpReadPhysicalMemRoutine: ?PWINDBG_OLDKD_READ_PHYSICAL_MEMORY,
    lpWritePhysicalMemRoutine: ?PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY,
};

pub const PWINDBG_OLD_EXTENSION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_EXTENSION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_EXTENSION_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_EXTENSION_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u64,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u64,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_OLDKD_EXTENSION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_OLDKD_EXTENSION_APIS,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_OLDKD_EXTENSION_APIS,
        lpArgumentString: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_EXTENSION_DLL_INIT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_EXTENSION_DLL_INIT32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS32,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS32,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_EXTENSION_DLL_INIT64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS64,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS64,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PWINDBG_CHECK_VERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) u32,
};

pub const EXT_API_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    Revision: u16,
    Reserved: u16,
};

pub const PWINDBG_EXTENSION_API_VERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) ?*EXT_API_VERSION,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) ?*EXT_API_VERSION,
};

pub const PROCESSORINFO = extern struct {
    Processor: u16,
    NumberProcessors: u16,
};

pub const READCONTROLSPACE = extern struct {
    Processor: u16,
    Address: u32,
    BufLen: u32,
    Buf: [1]u8,
};

pub const READCONTROLSPACE32 = extern struct {
    Processor: u16,
    Address: u32,
    BufLen: u32,
    Buf: [1]u8,
};

pub const READCONTROLSPACE64 = extern struct {
    Processor: u16,
    Address: u64,
    BufLen: u32,
    Buf: [1]u8,
};

pub const IOSPACE = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
};

pub const IOSPACE32 = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
};

pub const IOSPACE64 = extern struct {
    Address: u64,
    Length: u32,
    Data: u32,
};

pub const IOSPACE_EX = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const IOSPACE_EX32 = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const IOSPACE_EX64 = extern struct {
    Address: u64,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const _GETSETBUSDATA = extern struct {
    BusDataType: u32,
    BusNumber: u32,
    SlotNumber: u32,
    Buffer: ?*anyopaque,
    Offset: u32,
    Length: u32,
};

pub const SEARCHMEMORY = extern struct {
    SearchAddress: u64,
    SearchLength: u64,
    FoundAddress: u64,
    PatternLength: u32,
    Pattern: ?*anyopaque,
};

pub const PHYSICAL = extern struct {
    Address: u64,
    BufLen: u32,
    Buf: [1]u8,
};

pub const PHYSICAL_WITH_FLAGS = extern struct {
    Address: u64,
    BufLen: u32,
    Flags: u32,
    Buf: [1]u8,
};

pub const READ_WRITE_MSR = extern struct {
    Msr: u32,
    Value: i64,
};

pub const GET_SET_SYMPATH = extern struct {
    Args: ?[*:0]const u8,
    Result: ?PSTR,
    Length: i32,
};

pub const GET_TEB_ADDRESS = extern struct {
    Address: u64,
};

pub const GET_PEB_ADDRESS = extern struct {
    CurrentThread: u64,
    Address: u64,
};

pub const GET_CURRENT_THREAD_ADDRESS = extern struct {
    Processor: u32,
    Address: u64,
};

pub const GET_CURRENT_PROCESS_ADDRESS = extern struct {
    Processor: u32,
    CurrentThread: u64,
    Address: u64,
};

pub const GET_INPUT_LINE = extern struct {
    Prompt: ?[*:0]const u8,
    Buffer: ?PSTR,
    BufferSize: u32,
    InputSize: u32,
};

pub const GET_EXPRESSION_EX = extern struct {
    Expression: ?[*:0]const u8,
    Remainder: ?[*:0]const u8,
    Value: u64,
};

pub const TRANSLATE_VIRTUAL_TO_PHYSICAL = extern struct {
    Virtual: u64,
    Physical: u64,
};

pub const VIRTUAL_TO_PHYSICAL = extern struct {
    Status: u32,
    Size: u32,
    PdeAddress: u64,
    Virtual: u64,
    Physical: u64,
};

pub const PHYSICAL_TO_VIRTUAL = extern struct {
    Status: u32,
    Size: u32,
    PdeAddress: u64,
};

pub const GET_CONTEXT_EX = extern struct {
    Status: u32,
    ContextSize: u32,
    pContext: ?*anyopaque,
};

pub const POINTER_SEARCH_PHYSICAL = extern struct {
    Offset: u64,
    Length: u64,
    PointerMin: u64,
    PointerMax: u64,
    Flags: u32,
    MatchOffsets: ?*u64,
    MatchOffsetsSize: u32,
    MatchOffsetsCount: u32,
};

pub const WDBGEXTS_THREAD_OS_INFO = extern struct {
    ThreadId: u32,
    ExitStatus: u32,
    PriorityClass: u32,
    Priority: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartOffset: u64,
    Affinity: u64,
};

pub const WDBGEXTS_CLR_DATA_INTERFACE = extern struct {
    Iid: ?*const Guid,
    Iface: ?*anyopaque,
};

pub const EXT_MATCH_PATTERN_A = extern struct {
    Str: ?[*:0]const u8,
    Pattern: ?[*:0]const u8,
    CaseSensitive: u32,
};

pub const EXT_FIND_FILE = extern struct {
    FileName: ?[*:0]const u16,
    IndexedSize: u64,
    ImageTimeDateStamp: u32,
    ImageCheckSum: u32,
    ExtraInfo: ?*anyopaque,
    ExtraInfoSize: u32,
    Flags: u32,
    FileMapping: ?*anyopaque,
    FileMappingSize: u64,
    FileHandle: ?HANDLE,
    FoundFileName: ?PWSTR,
    FoundFileNameChars: u32,
};

pub const DEBUG_TYPED_DATA = extern struct {
    ModBase: u64,
    Offset: u64,
    EngineHandle: u64,
    Data: u64,
    Size: u32,
    Flags: u32,
    TypeId: u32,
    BaseTypeId: u32,
    Tag: u32,
    Register: u32,
    Internal: [9]u64,
};

pub const EXT_TDOP = enum(i32) {
    COPY = 0,
    RELEASE = 1,
    SET_FROM_EXPR = 2,
    SET_FROM_U64_EXPR = 3,
    GET_FIELD = 4,
    EVALUATE = 5,
    GET_TYPE_NAME = 6,
    OUTPUT_TYPE_NAME = 7,
    OUTPUT_SIMPLE_VALUE = 8,
    OUTPUT_FULL_VALUE = 9,
    HAS_FIELD = 10,
    GET_FIELD_OFFSET = 11,
    GET_ARRAY_ELEMENT = 12,
    GET_DEREFERENCE = 13,
    GET_TYPE_SIZE = 14,
    OUTPUT_TYPE_DEFINITION = 15,
    GET_POINTER_TO = 16,
    SET_FROM_TYPE_ID_AND_U64 = 17,
    SET_PTR_FROM_TYPE_ID_AND_U64 = 18,
    COUNT = 19,
};
pub const EXT_TDOP_COPY = EXT_TDOP.COPY;
pub const EXT_TDOP_RELEASE = EXT_TDOP.RELEASE;
pub const EXT_TDOP_SET_FROM_EXPR = EXT_TDOP.SET_FROM_EXPR;
pub const EXT_TDOP_SET_FROM_U64_EXPR = EXT_TDOP.SET_FROM_U64_EXPR;
pub const EXT_TDOP_GET_FIELD = EXT_TDOP.GET_FIELD;
pub const EXT_TDOP_EVALUATE = EXT_TDOP.EVALUATE;
pub const EXT_TDOP_GET_TYPE_NAME = EXT_TDOP.GET_TYPE_NAME;
pub const EXT_TDOP_OUTPUT_TYPE_NAME = EXT_TDOP.OUTPUT_TYPE_NAME;
pub const EXT_TDOP_OUTPUT_SIMPLE_VALUE = EXT_TDOP.OUTPUT_SIMPLE_VALUE;
pub const EXT_TDOP_OUTPUT_FULL_VALUE = EXT_TDOP.OUTPUT_FULL_VALUE;
pub const EXT_TDOP_HAS_FIELD = EXT_TDOP.HAS_FIELD;
pub const EXT_TDOP_GET_FIELD_OFFSET = EXT_TDOP.GET_FIELD_OFFSET;
pub const EXT_TDOP_GET_ARRAY_ELEMENT = EXT_TDOP.GET_ARRAY_ELEMENT;
pub const EXT_TDOP_GET_DEREFERENCE = EXT_TDOP.GET_DEREFERENCE;
pub const EXT_TDOP_GET_TYPE_SIZE = EXT_TDOP.GET_TYPE_SIZE;
pub const EXT_TDOP_OUTPUT_TYPE_DEFINITION = EXT_TDOP.OUTPUT_TYPE_DEFINITION;
pub const EXT_TDOP_GET_POINTER_TO = EXT_TDOP.GET_POINTER_TO;
pub const EXT_TDOP_SET_FROM_TYPE_ID_AND_U64 = EXT_TDOP.SET_FROM_TYPE_ID_AND_U64;
pub const EXT_TDOP_SET_PTR_FROM_TYPE_ID_AND_U64 = EXT_TDOP.SET_PTR_FROM_TYPE_ID_AND_U64;
pub const EXT_TDOP_COUNT = EXT_TDOP.COUNT;

pub const EXT_TYPED_DATA = extern struct {
    Operation: EXT_TDOP,
    Flags: u32,
    InData: DEBUG_TYPED_DATA,
    OutData: DEBUG_TYPED_DATA,
    InStrIndex: u32,
    In32: u32,
    Out32: u32,
    In64: u64,
    Out64: u64,
    StrBufferIndex: u32,
    StrBufferChars: u32,
    StrCharsNeeded: u32,
    DataBufferIndex: u32,
    DataBufferBytes: u32,
    DataBytesNeeded: u32,
    Status: HRESULT,
    Reserved: [8]u64,
};

pub const WDBGEXTS_QUERY_INTERFACE = extern struct {
    Iid: ?*const Guid,
    Iface: ?*anyopaque,
};

pub const WDBGEXTS_DISASSEMBLE_BUFFER = extern struct {
    InOffset: u64,
    OutOffset: u64,
    AddrFlags: u32,
    FormatFlags: u32,
    DataBufferBytes: u32,
    DisasmBufferChars: u32,
    DataBuffer: ?*anyopaque,
    DisasmBuffer: ?PWSTR,
    Reserved0: [3]u64,
};

pub const WDBGEXTS_MODULE_IN_RANGE = extern struct {
    Start: u64,
    End: u64,
    FoundModBase: u64,
    FoundModSize: u32,
};

pub const DBGKD_MAJOR_TYPES = enum(i32) {
    NT = 0,
    XBOX = 1,
    BIG = 2,
    EXDI = 3,
    NTBD = 4,
    EFI = 5,
    TNT = 6,
    SINGULARITY = 7,
    HYPERVISOR = 8,
    MIDORI = 9,
    CE = 10,
    COUNT = 11,
};
pub const DBGKD_MAJOR_NT = DBGKD_MAJOR_TYPES.NT;
pub const DBGKD_MAJOR_XBOX = DBGKD_MAJOR_TYPES.XBOX;
pub const DBGKD_MAJOR_BIG = DBGKD_MAJOR_TYPES.BIG;
pub const DBGKD_MAJOR_EXDI = DBGKD_MAJOR_TYPES.EXDI;
pub const DBGKD_MAJOR_NTBD = DBGKD_MAJOR_TYPES.NTBD;
pub const DBGKD_MAJOR_EFI = DBGKD_MAJOR_TYPES.EFI;
pub const DBGKD_MAJOR_TNT = DBGKD_MAJOR_TYPES.TNT;
pub const DBGKD_MAJOR_SINGULARITY = DBGKD_MAJOR_TYPES.SINGULARITY;
pub const DBGKD_MAJOR_HYPERVISOR = DBGKD_MAJOR_TYPES.HYPERVISOR;
pub const DBGKD_MAJOR_MIDORI = DBGKD_MAJOR_TYPES.MIDORI;
pub const DBGKD_MAJOR_CE = DBGKD_MAJOR_TYPES.CE;
pub const DBGKD_MAJOR_COUNT = DBGKD_MAJOR_TYPES.COUNT;

pub const DBGKD_GET_VERSION32 = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    ProtocolVersion: u16,
    Flags: u16,
    KernBase: u32,
    PsLoadedModuleList: u32,
    MachineType: u16,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    KiCallUserMode: u32,
    KeUserCallbackDispatcher: u32,
    BreakpointWithStatus: u32,
    DebuggerDataList: u32,
};

pub const DBGKD_DEBUG_DATA_HEADER32 = extern struct {
    List: LIST_ENTRY32,
    OwnerTag: u32,
    Size: u32,
};

pub const KDDEBUGGER_DATA32 = extern struct {
    Header: DBGKD_DEBUG_DATA_HEADER32,
    KernBase: u32,
    BreakpointWithStatus: u32,
    SavedContext: u32,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    _bitfield: u16,
    KiCallUserMode: u32,
    KeUserCallbackDispatcher: u32,
    PsLoadedModuleList: u32,
    PsActiveProcessHead: u32,
    PspCidTable: u32,
    ExpSystemResourcesList: u32,
    ExpPagedPoolDescriptor: u32,
    ExpNumberOfPagedPools: u32,
    KeTimeIncrement: u32,
    KeBugCheckCallbackListHead: u32,
    KiBugcheckData: u32,
    IopErrorLogListHead: u32,
    ObpRootDirectoryObject: u32,
    ObpTypeObjectType: u32,
    MmSystemCacheStart: u32,
    MmSystemCacheEnd: u32,
    MmSystemCacheWs: u32,
    MmPfnDatabase: u32,
    MmSystemPtesStart: u32,
    MmSystemPtesEnd: u32,
    MmSubsectionBase: u32,
    MmNumberOfPagingFiles: u32,
    MmLowestPhysicalPage: u32,
    MmHighestPhysicalPage: u32,
    MmNumberOfPhysicalPages: u32,
    MmMaximumNonPagedPoolInBytes: u32,
    MmNonPagedSystemStart: u32,
    MmNonPagedPoolStart: u32,
    MmNonPagedPoolEnd: u32,
    MmPagedPoolStart: u32,
    MmPagedPoolEnd: u32,
    MmPagedPoolInformation: u32,
    MmPageSize: u32,
    MmSizeOfPagedPoolInBytes: u32,
    MmTotalCommitLimit: u32,
    MmTotalCommittedPages: u32,
    MmSharedCommit: u32,
    MmDriverCommit: u32,
    MmProcessCommit: u32,
    MmPagedPoolCommit: u32,
    MmExtendedCommit: u32,
    MmZeroedPageListHead: u32,
    MmFreePageListHead: u32,
    MmStandbyPageListHead: u32,
    MmModifiedPageListHead: u32,
    MmModifiedNoWritePageListHead: u32,
    MmAvailablePages: u32,
    MmResidentAvailablePages: u32,
    PoolTrackTable: u32,
    NonPagedPoolDescriptor: u32,
    MmHighestUserAddress: u32,
    MmSystemRangeStart: u32,
    MmUserProbeAddress: u32,
    KdPrintCircularBuffer: u32,
    KdPrintCircularBufferEnd: u32,
    KdPrintWritePointer: u32,
    KdPrintRolloverCount: u32,
    MmLoadedUserImageList: u32,
};

pub const DBGKD_GET_VERSION64 = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    ProtocolVersion: u8,
    KdSecondaryVersion: u8,
    Flags: u16,
    MachineType: u16,
    MaxPacketType: u8,
    MaxStateChange: u8,
    MaxManipulate: u8,
    Simulation: u8,
    Unused: [1]u16,
    KernBase: u64,
    PsLoadedModuleList: u64,
    DebuggerDataList: u64,
};

pub const DBGKD_DEBUG_DATA_HEADER64 = extern struct {
    List: LIST_ENTRY64,
    OwnerTag: u32,
    Size: u32,
};

pub const KDDEBUGGER_DATA64 = extern struct {
    Header: DBGKD_DEBUG_DATA_HEADER64,
    KernBase: u64,
    BreakpointWithStatus: u64,
    SavedContext: u64,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    _bitfield: u16,
    KiCallUserMode: u64,
    KeUserCallbackDispatcher: u64,
    PsLoadedModuleList: u64,
    PsActiveProcessHead: u64,
    PspCidTable: u64,
    ExpSystemResourcesList: u64,
    ExpPagedPoolDescriptor: u64,
    ExpNumberOfPagedPools: u64,
    KeTimeIncrement: u64,
    KeBugCheckCallbackListHead: u64,
    KiBugcheckData: u64,
    IopErrorLogListHead: u64,
    ObpRootDirectoryObject: u64,
    ObpTypeObjectType: u64,
    MmSystemCacheStart: u64,
    MmSystemCacheEnd: u64,
    MmSystemCacheWs: u64,
    MmPfnDatabase: u64,
    MmSystemPtesStart: u64,
    MmSystemPtesEnd: u64,
    MmSubsectionBase: u64,
    MmNumberOfPagingFiles: u64,
    MmLowestPhysicalPage: u64,
    MmHighestPhysicalPage: u64,
    MmNumberOfPhysicalPages: u64,
    MmMaximumNonPagedPoolInBytes: u64,
    MmNonPagedSystemStart: u64,
    MmNonPagedPoolStart: u64,
    MmNonPagedPoolEnd: u64,
    MmPagedPoolStart: u64,
    MmPagedPoolEnd: u64,
    MmPagedPoolInformation: u64,
    MmPageSize: u64,
    MmSizeOfPagedPoolInBytes: u64,
    MmTotalCommitLimit: u64,
    MmTotalCommittedPages: u64,
    MmSharedCommit: u64,
    MmDriverCommit: u64,
    MmProcessCommit: u64,
    MmPagedPoolCommit: u64,
    MmExtendedCommit: u64,
    MmZeroedPageListHead: u64,
    MmFreePageListHead: u64,
    MmStandbyPageListHead: u64,
    MmModifiedPageListHead: u64,
    MmModifiedNoWritePageListHead: u64,
    MmAvailablePages: u64,
    MmResidentAvailablePages: u64,
    PoolTrackTable: u64,
    NonPagedPoolDescriptor: u64,
    MmHighestUserAddress: u64,
    MmSystemRangeStart: u64,
    MmUserProbeAddress: u64,
    KdPrintCircularBuffer: u64,
    KdPrintCircularBufferEnd: u64,
    KdPrintWritePointer: u64,
    KdPrintRolloverCount: u64,
    MmLoadedUserImageList: u64,
    NtBuildLab: u64,
    KiNormalSystemCall: u64,
    KiProcessorBlock: u64,
    MmUnloadedDrivers: u64,
    MmLastUnloadedDriver: u64,
    MmTriageActionTaken: u64,
    MmSpecialPoolTag: u64,
    KernelVerifier: u64,
    MmVerifierData: u64,
    MmAllocatedNonPagedPool: u64,
    MmPeakCommitment: u64,
    MmTotalCommitLimitMaximum: u64,
    CmNtCSDVersion: u64,
    MmPhysicalMemoryBlock: u64,
    MmSessionBase: u64,
    MmSessionSize: u64,
    MmSystemParentTablePage: u64,
    MmVirtualTranslationBase: u64,
    OffsetKThreadNextProcessor: u16,
    OffsetKThreadTeb: u16,
    OffsetKThreadKernelStack: u16,
    OffsetKThreadInitialStack: u16,
    OffsetKThreadApcProcess: u16,
    OffsetKThreadState: u16,
    OffsetKThreadBStore: u16,
    OffsetKThreadBStoreLimit: u16,
    SizeEProcess: u16,
    OffsetEprocessPeb: u16,
    OffsetEprocessParentCID: u16,
    OffsetEprocessDirectoryTableBase: u16,
    SizePrcb: u16,
    OffsetPrcbDpcRoutine: u16,
    OffsetPrcbCurrentThread: u16,
    OffsetPrcbMhz: u16,
    OffsetPrcbCpuType: u16,
    OffsetPrcbVendorString: u16,
    OffsetPrcbProcStateContext: u16,
    OffsetPrcbNumber: u16,
    SizeEThread: u16,
    L1tfHighPhysicalBitIndex: u8,
    L1tfSwizzleBitIndex: u8,
    Padding0: u32,
    KdPrintCircularBufferPtr: u64,
    KdPrintBufferSize: u64,
    KeLoaderBlock: u64,
    SizePcr: u16,
    OffsetPcrSelfPcr: u16,
    OffsetPcrCurrentPrcb: u16,
    OffsetPcrContainedPrcb: u16,
    OffsetPcrInitialBStore: u16,
    OffsetPcrBStoreLimit: u16,
    OffsetPcrInitialStack: u16,
    OffsetPcrStackLimit: u16,
    OffsetPrcbPcrPage: u16,
    OffsetPrcbProcStateSpecialReg: u16,
    GdtR0Code: u16,
    GdtR0Data: u16,
    GdtR0Pcr: u16,
    GdtR3Code: u16,
    GdtR3Data: u16,
    GdtR3Teb: u16,
    GdtLdt: u16,
    GdtTss: u16,
    Gdt64R3CmCode: u16,
    Gdt64R3CmTeb: u16,
    IopNumTriageDumpDataBlocks: u64,
    IopTriageDumpDataBlocks: u64,
    VfCrashDataBlock: u64,
    MmBadPagesDetected: u64,
    MmZeroedPageSingleBitErrorsDetected: u64,
    EtwpDebuggerData: u64,
    OffsetPrcbContext: u16,
    OffsetPrcbMaxBreakpoints: u16,
    OffsetPrcbMaxWatchpoints: u16,
    OffsetKThreadStackLimit: u32,
    OffsetKThreadStackBase: u32,
    OffsetKThreadQueueListEntry: u32,
    OffsetEThreadIrpList: u32,
    OffsetPrcbIdleThread: u16,
    OffsetPrcbNormalDpcState: u16,
    OffsetPrcbDpcStack: u16,
    OffsetPrcbIsrStack: u16,
    SizeKDPC_STACK_FRAME: u16,
    OffsetKPriQueueThreadListHead: u16,
    OffsetKThreadWaitReason: u16,
    Padding1: u16,
    PteBase: u64,
    RetpolineStubFunctionTable: u64,
    RetpolineStubFunctionTableSize: u32,
    RetpolineStubOffset: u32,
    RetpolineStubSize: u32,
    OffsetEProcessMmHotPatchContext: u16,
};

pub const PSYM_DUMP_FIELD_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pField: ?*FIELD_INFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn (
        pField: ?*FIELD_INFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
};

pub const FIELD_INFO = extern struct {
    pub const _BitField = extern struct {
        Position: u16,
        Size: u16,
    };
    fName: ?*u8,
    printName: ?*u8,
    size: u32,
    fOptions: u32,
    address: u64,
    Anonymous: extern union {
        fieldCallBack: ?*anyopaque,
        pBuffer: ?*anyopaque,
    },
    TypeId: u32,
    FieldOffset: u32,
    BufferSize: u32,
    BitField: _BitField,
    _bitfield: u32,
};

pub const SYM_DUMP_PARAM = extern struct {
    size: u32,
    sName: ?*u8,
    Options: u32,
    addr: u64,
    listLink: ?*FIELD_INFO,
    Anonymous: extern union {
        Context: ?*anyopaque,
        pBuffer: ?*anyopaque,
    },
    CallbackRoutine: ?PSYM_DUMP_FIELD_CALLBACK,
    nFields: u32,
    Fields: ?*FIELD_INFO,
    ModBase: u64,
    TypeId: u32,
    TypeSize: u32,
    BufferSize: u32,
    _bitfield: u32,
};

pub const M128A = extern struct {
    Low: u64,
    High: i64,
};

pub const XSAVE_AREA_HEADER = extern struct {
    Mask: u64,
    CompactionMask: u64,
    Reserved2: [6]u64,
};

pub const XSAVE_AREA = extern struct {
    LegacyState: XSAVE_FORMAT,
    Header: XSAVE_AREA_HEADER,
};

pub const ARM64_NT_NEON128 = extern union {
    Anonymous: extern struct {
        Low: u64,
        High: i64,
    },
    D: [2]f64,
    S: [4]f32,
    H: [8]u16,
    B: [16]u8,
};

pub const LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: u8,
            Flags1: u8,
            Flags2: u8,
            BaseHi: u8,
        },
        Bits: extern struct {
            _bitfield: u32,
        },
    },
};

pub const WOW64_FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Cr0NpxState: u32,
};

pub const WOW64_CONTEXT = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: WOW64_FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
    ExtendedRegisters: [512]u8,
};

pub const WOW64_LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: u8,
            Flags1: u8,
            Flags2: u8,
            BaseHi: u8,
        },
        Bits: extern struct {
            _bitfield: u32,
        },
    },
};

pub const WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: u32,
    Descriptor: WOW64_LDT_ENTRY,
};

pub const EXCEPTION_RECORD = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ExceptionAddress: ?*anyopaque,
    NumberParameters: u32,
    ExceptionInformation: [15]usize,
};

pub const EXCEPTION_RECORD32 = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: u32,
    ExceptionAddress: u32,
    NumberParameters: u32,
    ExceptionInformation: [15]u32,
};

pub const EXCEPTION_RECORD64 = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: u64,
    ExceptionAddress: u64,
    NumberParameters: u32,
    __unusedAlignment: u32,
    ExceptionInformation: [15]u64,
};

pub const EXCEPTION_POINTERS = extern struct {
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ContextRecord: ?*CONTEXT,
};

pub const XSTATE_FEATURE = extern struct {
    Offset: u32,
    Size: u32,
};

pub const XSTATE_CONFIGURATION = extern struct {
    EnabledFeatures: u64,
    EnabledVolatileFeatures: u64,
    Size: u32,
    Anonymous: extern union {
        ControlFlags: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
    Features: [64]XSTATE_FEATURE,
    EnabledSupervisorFeatures: u64,
    AlignedFeatures: u64,
    AllFeatureSize: u32,
    AllFeatures: [64]u32,
    EnabledUserVisibleSupervisorFeatures: u64,
    ExtendedFeatureDisableFeatures: u64,
    AllNonLargeFeatureSize: u32,
    Spare: u32,
};

pub const IMAGE_FILE_HEADER = extern struct {
    Machine: IMAGE_FILE_MACHINE,
    NumberOfSections: u16,
    TimeDateStamp: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
    SizeOfOptionalHeader: u16,
    Characteristics: IMAGE_FILE_CHARACTERISTICS,
};

pub const IMAGE_DATA_DIRECTORY = extern struct {
    VirtualAddress: u32,
    Size: u32,
};

pub const IMAGE_OPTIONAL_HEADER32 = extern struct {
    Magic: IMAGE_OPTIONAL_HEADER_MAGIC,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    ImageBase: u32,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: IMAGE_SUBSYSTEM,
    DllCharacteristics: IMAGE_DLL_CHARACTERISTICS,
    SizeOfStackReserve: u32,
    SizeOfStackCommit: u32,
    SizeOfHeapReserve: u32,
    SizeOfHeapCommit: u32,
    /// Deprecated
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};

pub const IMAGE_ROM_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    BaseOfBss: u32,
    GprMask: u32,
    CprMask: [4]u32,
    GpValue: u32,
};

pub const IMAGE_OPTIONAL_HEADER64 = extern struct {
    Magic: IMAGE_OPTIONAL_HEADER_MAGIC align(4),
    MajorLinkerVersion: u8 align(4),
    MinorLinkerVersion: u8 align(4),
    SizeOfCode: u32 align(4),
    SizeOfInitializedData: u32 align(4),
    SizeOfUninitializedData: u32 align(4),
    AddressOfEntryPoint: u32 align(4),
    BaseOfCode: u32 align(4),
    ImageBase: u64 align(4),
    SectionAlignment: u32 align(4),
    FileAlignment: u32 align(4),
    MajorOperatingSystemVersion: u16 align(4),
    MinorOperatingSystemVersion: u16 align(4),
    MajorImageVersion: u16 align(4),
    MinorImageVersion: u16 align(4),
    MajorSubsystemVersion: u16 align(4),
    MinorSubsystemVersion: u16 align(4),
    Win32VersionValue: u32 align(4),
    SizeOfImage: u32 align(4),
    SizeOfHeaders: u32 align(4),
    CheckSum: u32 align(4),
    Subsystem: IMAGE_SUBSYSTEM align(4),
    DllCharacteristics: IMAGE_DLL_CHARACTERISTICS align(4),
    SizeOfStackReserve: u64 align(4),
    SizeOfStackCommit: u64 align(4),
    SizeOfHeapReserve: u64 align(4),
    SizeOfHeapCommit: u64 align(4),
    /// Deprecated
    LoaderFlags: u32 align(4),
    NumberOfRvaAndSizes: u32 align(4),
    DataDirectory: [16]IMAGE_DATA_DIRECTORY align(4),
};

pub const IMAGE_NT_HEADERS64 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER64,
};

pub const IMAGE_NT_HEADERS32 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER32,
};

pub const IMAGE_ROM_HEADERS = extern struct {
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
};

pub const IMAGE_SECTION_HEADER = extern struct {
    Name: [8]u8,
    Misc: extern union {
        PhysicalAddress: u32,
        VirtualSize: u32,
    },
    VirtualAddress: u32,
    SizeOfRawData: u32,
    PointerToRawData: u32,
    PointerToRelocations: u32,
    PointerToLinenumbers: u32,
    NumberOfRelocations: u16,
    NumberOfLinenumbers: u16,
    Characteristics: IMAGE_SECTION_CHARACTERISTICS,
};

pub const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = extern struct {
    Flags: u16,
    Catalog: u16,
    CatalogOffset: u32,
    Reserved: u32,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY32 = extern struct {
    Size: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    GlobalFlagsClear: u32,
    GlobalFlagsSet: u32,
    CriticalSectionDefaultTimeout: u32,
    DeCommitFreeBlockThreshold: u32,
    DeCommitTotalFreeThreshold: u32,
    LockPrefixTable: u32,
    MaximumAllocationSize: u32,
    VirtualMemoryThreshold: u32,
    ProcessHeapFlags: u32,
    ProcessAffinityMask: u32,
    CSDVersion: u16,
    DependentLoadFlags: u16,
    EditList: u32,
    SecurityCookie: u32,
    SEHandlerTable: u32,
    SEHandlerCount: u32,
    GuardCFCheckFunctionPointer: u32,
    GuardCFDispatchFunctionPointer: u32,
    GuardCFFunctionTable: u32,
    GuardCFFunctionCount: u32,
    GuardFlags: u32,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: u32,
    GuardAddressTakenIatEntryCount: u32,
    GuardLongJumpTargetTable: u32,
    GuardLongJumpTargetCount: u32,
    DynamicValueRelocTable: u32,
    CHPEMetadataPointer: u32,
    GuardRFFailureRoutine: u32,
    GuardRFFailureRoutineFunctionPointer: u32,
    DynamicValueRelocTableOffset: u32,
    DynamicValueRelocTableSection: u16,
    Reserved2: u16,
    GuardRFVerifyStackPointerFunctionPointer: u32,
    HotPatchTableOffset: u32,
    Reserved3: u32,
    EnclaveConfigurationPointer: u32,
    VolatileMetadataPointer: u32,
    GuardEHContinuationTable: u32,
    GuardEHContinuationCount: u32,
    GuardXFGCheckFunctionPointer: u32,
    GuardXFGDispatchFunctionPointer: u32,
    GuardXFGTableDispatchFunctionPointer: u32,
    CastGuardOsDeterminedFailureMode: u32,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY64 = extern struct {
    Size: u32 align(4),
    TimeDateStamp: u32 align(4),
    MajorVersion: u16 align(4),
    MinorVersion: u16 align(4),
    GlobalFlagsClear: u32 align(4),
    GlobalFlagsSet: u32 align(4),
    CriticalSectionDefaultTimeout: u32 align(4),
    DeCommitFreeBlockThreshold: u64 align(4),
    DeCommitTotalFreeThreshold: u64 align(4),
    LockPrefixTable: u64 align(4),
    MaximumAllocationSize: u64 align(4),
    VirtualMemoryThreshold: u64 align(4),
    ProcessAffinityMask: u64 align(4),
    ProcessHeapFlags: u32 align(4),
    CSDVersion: u16 align(4),
    DependentLoadFlags: u16 align(4),
    EditList: u64 align(4),
    SecurityCookie: u64 align(4),
    SEHandlerTable: u64 align(4),
    SEHandlerCount: u64 align(4),
    GuardCFCheckFunctionPointer: u64 align(4),
    GuardCFDispatchFunctionPointer: u64 align(4),
    GuardCFFunctionTable: u64 align(4),
    GuardCFFunctionCount: u64 align(4),
    GuardFlags: u32 align(4),
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY align(4),
    GuardAddressTakenIatEntryTable: u64 align(4),
    GuardAddressTakenIatEntryCount: u64 align(4),
    GuardLongJumpTargetTable: u64 align(4),
    GuardLongJumpTargetCount: u64 align(4),
    DynamicValueRelocTable: u64 align(4),
    CHPEMetadataPointer: u64 align(4),
    GuardRFFailureRoutine: u64 align(4),
    GuardRFFailureRoutineFunctionPointer: u64 align(4),
    DynamicValueRelocTableOffset: u32 align(4),
    DynamicValueRelocTableSection: u16 align(4),
    Reserved2: u16 align(4),
    GuardRFVerifyStackPointerFunctionPointer: u64 align(4),
    HotPatchTableOffset: u32 align(4),
    Reserved3: u32 align(4),
    EnclaveConfigurationPointer: u64 align(4),
    VolatileMetadataPointer: u64 align(4),
    GuardEHContinuationTable: u64 align(4),
    GuardEHContinuationCount: u64 align(4),
    GuardXFGCheckFunctionPointer: u64 align(4),
    GuardXFGDispatchFunctionPointer: u64 align(4),
    GuardXFGTableDispatchFunctionPointer: u64 align(4),
    CastGuardOsDeterminedFailureMode: u64 align(4),
};

pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: extern union {
        UnwindData: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
};

pub const IMAGE_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    Anonymous: extern union {
        UnwindInfoAddress: u32,
        UnwindData: u32,
    },
};

pub const IMAGE_DEBUG_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Type: IMAGE_DEBUG_TYPE,
    SizeOfData: u32,
    AddressOfRawData: u32,
    PointerToRawData: u32,
};

pub const IMAGE_COFF_SYMBOLS_HEADER = extern struct {
    NumberOfSymbols: u32,
    LvaToFirstSymbol: u32,
    NumberOfLinenumbers: u32,
    LvaToFirstLinenumber: u32,
    RvaToFirstByteOfCode: u32,
    RvaToLastByteOfCode: u32,
    RvaToFirstByteOfData: u32,
    RvaToLastByteOfData: u32,
};

pub const FPO_DATA = extern struct {
    ulOffStart: u32,
    cbProcSize: u32,
    cdwLocals: u32,
    cdwParams: u16,
    _bitfield: u16,
};

pub const IMAGE_FUNCTION_ENTRY = extern struct {
    StartingAddress: u32,
    EndingAddress: u32,
    EndOfPrologue: u32,
};

pub const IMAGE_FUNCTION_ENTRY64 = extern struct {
    StartingAddress: u64 align(4),
    EndingAddress: u64 align(4),
    Anonymous: extern union {
        EndOfPrologue: u64 align(4),
        UnwindInfoAddress: u64 align(4),
    } align(4),
};

pub const IMAGE_COR20_HEADER = extern struct {
    cb: u32,
    MajorRuntimeVersion: u16,
    MinorRuntimeVersion: u16,
    MetaData: IMAGE_DATA_DIRECTORY,
    Flags: u32,
    Anonymous: extern union {
        EntryPointToken: u32,
        EntryPointRVA: u32,
    },
    Resources: IMAGE_DATA_DIRECTORY,
    StrongNameSignature: IMAGE_DATA_DIRECTORY,
    CodeManagerTable: IMAGE_DATA_DIRECTORY,
    VTableFixups: IMAGE_DATA_DIRECTORY,
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
};

pub const PVECTORED_EXCEPTION_HANDLER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const LPTOP_LEVEL_EXCEPTION_FILTER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn (
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
};

pub const WCT_OBJECT_TYPE = enum(i32) {
    CriticalSectionType = 1,
    SendMessageType = 2,
    MutexType = 3,
    AlpcType = 4,
    ComType = 5,
    ThreadWaitType = 6,
    ProcessWaitType = 7,
    ThreadType = 8,
    ComActivationType = 9,
    UnknownType = 10,
    SocketIoType = 11,
    SmbIoType = 12,
    MaxType = 13,
};
pub const WctCriticalSectionType = WCT_OBJECT_TYPE.CriticalSectionType;
pub const WctSendMessageType = WCT_OBJECT_TYPE.SendMessageType;
pub const WctMutexType = WCT_OBJECT_TYPE.MutexType;
pub const WctAlpcType = WCT_OBJECT_TYPE.AlpcType;
pub const WctComType = WCT_OBJECT_TYPE.ComType;
pub const WctThreadWaitType = WCT_OBJECT_TYPE.ThreadWaitType;
pub const WctProcessWaitType = WCT_OBJECT_TYPE.ProcessWaitType;
pub const WctThreadType = WCT_OBJECT_TYPE.ThreadType;
pub const WctComActivationType = WCT_OBJECT_TYPE.ComActivationType;
pub const WctUnknownType = WCT_OBJECT_TYPE.UnknownType;
pub const WctSocketIoType = WCT_OBJECT_TYPE.SocketIoType;
pub const WctSmbIoType = WCT_OBJECT_TYPE.SmbIoType;
pub const WctMaxType = WCT_OBJECT_TYPE.MaxType;

pub const WCT_OBJECT_STATUS = enum(i32) {
    NoAccess = 1,
    Running = 2,
    Blocked = 3,
    PidOnly = 4,
    PidOnlyRpcss = 5,
    Owned = 6,
    NotOwned = 7,
    Abandoned = 8,
    Unknown = 9,
    Error = 10,
    Max = 11,
};
pub const WctStatusNoAccess = WCT_OBJECT_STATUS.NoAccess;
pub const WctStatusRunning = WCT_OBJECT_STATUS.Running;
pub const WctStatusBlocked = WCT_OBJECT_STATUS.Blocked;
pub const WctStatusPidOnly = WCT_OBJECT_STATUS.PidOnly;
pub const WctStatusPidOnlyRpcss = WCT_OBJECT_STATUS.PidOnlyRpcss;
pub const WctStatusOwned = WCT_OBJECT_STATUS.Owned;
pub const WctStatusNotOwned = WCT_OBJECT_STATUS.NotOwned;
pub const WctStatusAbandoned = WCT_OBJECT_STATUS.Abandoned;
pub const WctStatusUnknown = WCT_OBJECT_STATUS.Unknown;
pub const WctStatusError = WCT_OBJECT_STATUS.Error;
pub const WctStatusMax = WCT_OBJECT_STATUS.Max;

pub const WAITCHAIN_NODE_INFO = extern struct {
    ObjectType: WCT_OBJECT_TYPE,
    ObjectStatus: WCT_OBJECT_STATUS,
    Anonymous: extern union {
        LockObject: extern struct {
            ObjectName: [128]u16,
            Timeout: LARGE_INTEGER,
            Alertable: BOOL,
        },
        ThreadObject: extern struct {
            ProcessId: u32,
            ThreadId: u32,
            WaitTime: u32,
            ContextSwitches: u32,
        },
    },
};

pub const PWAITCHAINCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        WctHandle: ?*anyopaque,
        Context: usize,
        CallbackStatus: u32,
        NodeCount: ?*u32,
        NodeInfoArray: ?*WAITCHAIN_NODE_INFO,
        IsCycle: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        WctHandle: ?*anyopaque,
        Context: usize,
        CallbackStatus: u32,
        NodeCount: ?*u32,
        NodeInfoArray: ?*WAITCHAIN_NODE_INFO,
        IsCycle: ?*i32,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const PCOGETCALLSTATE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: i32,
        param1: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        param0: i32,
        param1: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const PCOGETACTIVATIONSTATE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: Guid,
        param1: u32,
        param2: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn (
        param0: Guid,
        param1: u32,
        param2: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
};

pub const MINIDUMP_LOCATION_DESCRIPTOR = extern struct {
    DataSize: u32,
    Rva: u32,
};

pub const MINIDUMP_LOCATION_DESCRIPTOR64 = extern struct {
    DataSize: u64 align(4),
    Rva: u64 align(4),
};

pub const MINIDUMP_MEMORY_DESCRIPTOR = extern struct {
    StartOfMemoryRange: u64 align(4),
    Memory: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};

pub const MINIDUMP_MEMORY_DESCRIPTOR64 = extern struct {
    StartOfMemoryRange: u64 align(4),
    DataSize: u64 align(4),
};

pub const MINIDUMP_HEADER = extern struct {
    Signature: u32 align(4),
    Version: u32 align(4),
    NumberOfStreams: u32 align(4),
    StreamDirectoryRva: u32 align(4),
    CheckSum: u32 align(4),
    Anonymous: extern union {
        Reserved: u32,
        TimeDateStamp: u32,
    } align(4),
    Flags: u64 align(4),
};

pub const MINIDUMP_DIRECTORY = extern struct {
    StreamType: u32,
    Location: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_STRING = extern struct {
    Length: u32,
    Buffer: [1]u16,
};

pub const MINIDUMP_STREAM_TYPE = enum(i32) {
    UnusedStream = 0,
    ReservedStream0 = 1,
    ReservedStream1 = 2,
    ThreadListStream = 3,
    ModuleListStream = 4,
    MemoryListStream = 5,
    ExceptionStream = 6,
    SystemInfoStream = 7,
    ThreadExListStream = 8,
    Memory64ListStream = 9,
    CommentStreamA = 10,
    CommentStreamW = 11,
    HandleDataStream = 12,
    FunctionTableStream = 13,
    UnloadedModuleListStream = 14,
    MiscInfoStream = 15,
    MemoryInfoListStream = 16,
    ThreadInfoListStream = 17,
    HandleOperationListStream = 18,
    TokenStream = 19,
    JavaScriptDataStream = 20,
    SystemMemoryInfoStream = 21,
    ProcessVmCountersStream = 22,
    IptTraceStream = 23,
    ThreadNamesStream = 24,
    ceStreamNull = 32768,
    ceStreamSystemInfo = 32769,
    ceStreamException = 32770,
    ceStreamModuleList = 32771,
    ceStreamProcessList = 32772,
    ceStreamThreadList = 32773,
    ceStreamThreadContextList = 32774,
    ceStreamThreadCallStackList = 32775,
    ceStreamMemoryVirtualList = 32776,
    ceStreamMemoryPhysicalList = 32777,
    ceStreamBucketParameters = 32778,
    ceStreamProcessModuleMap = 32779,
    ceStreamDiagnosisList = 32780,
    LastReservedStream = 65535,
};
pub const UnusedStream = MINIDUMP_STREAM_TYPE.UnusedStream;
pub const ReservedStream0 = MINIDUMP_STREAM_TYPE.ReservedStream0;
pub const ReservedStream1 = MINIDUMP_STREAM_TYPE.ReservedStream1;
pub const ThreadListStream = MINIDUMP_STREAM_TYPE.ThreadListStream;
pub const ModuleListStream = MINIDUMP_STREAM_TYPE.ModuleListStream;
pub const MemoryListStream = MINIDUMP_STREAM_TYPE.MemoryListStream;
pub const ExceptionStream = MINIDUMP_STREAM_TYPE.ExceptionStream;
pub const SystemInfoStream = MINIDUMP_STREAM_TYPE.SystemInfoStream;
pub const ThreadExListStream = MINIDUMP_STREAM_TYPE.ThreadExListStream;
pub const Memory64ListStream = MINIDUMP_STREAM_TYPE.Memory64ListStream;
pub const CommentStreamA = MINIDUMP_STREAM_TYPE.CommentStreamA;
pub const CommentStreamW = MINIDUMP_STREAM_TYPE.CommentStreamW;
pub const HandleDataStream = MINIDUMP_STREAM_TYPE.HandleDataStream;
pub const FunctionTableStream = MINIDUMP_STREAM_TYPE.FunctionTableStream;
pub const UnloadedModuleListStream = MINIDUMP_STREAM_TYPE.UnloadedModuleListStream;
pub const MiscInfoStream = MINIDUMP_STREAM_TYPE.MiscInfoStream;
pub const MemoryInfoListStream = MINIDUMP_STREAM_TYPE.MemoryInfoListStream;
pub const ThreadInfoListStream = MINIDUMP_STREAM_TYPE.ThreadInfoListStream;
pub const HandleOperationListStream = MINIDUMP_STREAM_TYPE.HandleOperationListStream;
pub const TokenStream = MINIDUMP_STREAM_TYPE.TokenStream;
pub const JavaScriptDataStream = MINIDUMP_STREAM_TYPE.JavaScriptDataStream;
pub const SystemMemoryInfoStream = MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream;
pub const ProcessVmCountersStream = MINIDUMP_STREAM_TYPE.ProcessVmCountersStream;
pub const IptTraceStream = MINIDUMP_STREAM_TYPE.IptTraceStream;
pub const ThreadNamesStream = MINIDUMP_STREAM_TYPE.ThreadNamesStream;
pub const ceStreamNull = MINIDUMP_STREAM_TYPE.ceStreamNull;
pub const ceStreamSystemInfo = MINIDUMP_STREAM_TYPE.ceStreamSystemInfo;
pub const ceStreamException = MINIDUMP_STREAM_TYPE.ceStreamException;
pub const ceStreamModuleList = MINIDUMP_STREAM_TYPE.ceStreamModuleList;
pub const ceStreamProcessList = MINIDUMP_STREAM_TYPE.ceStreamProcessList;
pub const ceStreamThreadList = MINIDUMP_STREAM_TYPE.ceStreamThreadList;
pub const ceStreamThreadContextList = MINIDUMP_STREAM_TYPE.ceStreamThreadContextList;
pub const ceStreamThreadCallStackList = MINIDUMP_STREAM_TYPE.ceStreamThreadCallStackList;
pub const ceStreamMemoryVirtualList = MINIDUMP_STREAM_TYPE.ceStreamMemoryVirtualList;
pub const ceStreamMemoryPhysicalList = MINIDUMP_STREAM_TYPE.ceStreamMemoryPhysicalList;
pub const ceStreamBucketParameters = MINIDUMP_STREAM_TYPE.ceStreamBucketParameters;
pub const ceStreamProcessModuleMap = MINIDUMP_STREAM_TYPE.ceStreamProcessModuleMap;
pub const ceStreamDiagnosisList = MINIDUMP_STREAM_TYPE.ceStreamDiagnosisList;
pub const LastReservedStream = MINIDUMP_STREAM_TYPE.LastReservedStream;

pub const CPU_INFORMATION = extern union {
    X86CpuInfo: extern struct {
        VendorId: [3]u32,
        VersionInformation: u32,
        FeatureInformation: u32,
        AMDExtendedCpuFeatures: u32,
    },
    OtherCpuInfo: extern struct {
        ProcessorFeatures: [2]u64 align(4),
    },
};

pub const MINIDUMP_SYSTEM_INFO = extern struct {
    ProcessorArchitecture: PROCESSOR_ARCHITECTURE,
    ProcessorLevel: u16,
    ProcessorRevision: u16,
    Anonymous1: extern union {
        Reserved0: u16,
        Anonymous: extern struct {
            NumberOfProcessors: u8,
            ProductType: u8,
        },
    },
    MajorVersion: u32,
    MinorVersion: u32,
    BuildNumber: u32,
    PlatformId: VER_PLATFORM,
    CSDVersionRva: u32,
    Anonymous2: extern union {
        Reserved1: u32,
        Anonymous: extern struct {
            SuiteMask: u16,
            Reserved2: u16,
        },
    },
    Cpu: CPU_INFORMATION,
};

pub const MINIDUMP_THREAD = extern struct {
    ThreadId: u32 align(4),
    SuspendCount: u32 align(4),
    PriorityClass: u32 align(4),
    Priority: u32 align(4),
    Teb: u64 align(4),
    Stack: MINIDUMP_MEMORY_DESCRIPTOR align(4),
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};

pub const MINIDUMP_THREAD_LIST = extern struct {
    NumberOfThreads: u32,
    Threads: [1]MINIDUMP_THREAD,
};

pub const MINIDUMP_THREAD_EX = extern struct {
    ThreadId: u32 align(4),
    SuspendCount: u32 align(4),
    PriorityClass: u32 align(4),
    Priority: u32 align(4),
    Teb: u64 align(4),
    Stack: MINIDUMP_MEMORY_DESCRIPTOR align(4),
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR align(4),
    BackingStore: MINIDUMP_MEMORY_DESCRIPTOR align(4),
};

pub const MINIDUMP_THREAD_EX_LIST = extern struct {
    NumberOfThreads: u32,
    Threads: [1]MINIDUMP_THREAD_EX,
};

pub const MINIDUMP_EXCEPTION = extern struct {
    ExceptionCode: u32 align(4),
    ExceptionFlags: u32 align(4),
    ExceptionRecord: u64 align(4),
    ExceptionAddress: u64 align(4),
    NumberParameters: u32 align(4),
    __unusedAlignment: u32 align(4),
    ExceptionInformation: [15]u64 align(4),
};

pub const MINIDUMP_EXCEPTION_STREAM = extern struct {
    ThreadId: u32,
    __alignment: u32,
    ExceptionRecord: MINIDUMP_EXCEPTION,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_MODULE = extern struct {
    BaseOfImage: u64 align(4),
    SizeOfImage: u32 align(4),
    CheckSum: u32 align(4),
    TimeDateStamp: u32 align(4),
    ModuleNameRva: u32 align(4),
    VersionInfo: VS_FIXEDFILEINFO align(4),
    CvRecord: MINIDUMP_LOCATION_DESCRIPTOR align(4),
    MiscRecord: MINIDUMP_LOCATION_DESCRIPTOR align(4),
    Reserved0: u64 align(4),
    Reserved1: u64 align(4),
};

pub const MINIDUMP_MODULE_LIST = extern struct {
    NumberOfModules: u32,
    Modules: [1]MINIDUMP_MODULE,
};

pub const MINIDUMP_MEMORY_LIST = extern struct {
    NumberOfMemoryRanges: u32,
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR,
};

pub const MINIDUMP_MEMORY64_LIST = extern struct {
    NumberOfMemoryRanges: u64 align(4),
    BaseRva: u64 align(4),
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR64 align(4),
};

pub const MINIDUMP_EXCEPTION_INFORMATION = extern struct {
    ThreadId: u32 align(4),
    ExceptionPointers: ?*EXCEPTION_POINTERS align(4),
    ClientPointers: BOOL align(4),
};

pub const MINIDUMP_EXCEPTION_INFORMATION64 = extern struct {
    ThreadId: u32 align(4),
    ExceptionRecord: u64 align(4),
    ContextRecord: u64 align(4),
    ClientPointers: BOOL align(4),
};

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE = enum(i32) {
    HandleObjectInformationNone = 0,
    ThreadInformation1 = 1,
    MutantInformation1 = 2,
    MutantInformation2 = 3,
    ProcessInformation1 = 4,
    ProcessInformation2 = 5,
    EventInformation1 = 6,
    SectionInformation1 = 7,
    SemaphoreInformation1 = 8,
    HandleObjectInformationTypeMax = 9,
};
pub const MiniHandleObjectInformationNone = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.HandleObjectInformationNone;
pub const MiniThreadInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ThreadInformation1;
pub const MiniMutantInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MutantInformation1;
pub const MiniMutantInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MutantInformation2;
pub const MiniProcessInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ProcessInformation1;
pub const MiniProcessInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ProcessInformation2;
pub const MiniEventInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.EventInformation1;
pub const MiniSectionInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.SectionInformation1;
pub const MiniSemaphoreInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.SemaphoreInformation1;
pub const MiniHandleObjectInformationTypeMax = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.HandleObjectInformationTypeMax;

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION = extern struct {
    NextInfoRva: u32,
    InfoType: u32,
    SizeOfInfo: u32,
};

pub const MINIDUMP_HANDLE_DESCRIPTOR = extern struct {
    Handle: u64 align(4),
    TypeNameRva: u32 align(4),
    ObjectNameRva: u32 align(4),
    Attributes: u32 align(4),
    GrantedAccess: u32 align(4),
    HandleCount: u32 align(4),
    PointerCount: u32 align(4),
};

pub const MINIDUMP_HANDLE_DESCRIPTOR_2 = extern struct {
    Handle: u64 align(4),
    TypeNameRva: u32 align(4),
    ObjectNameRva: u32 align(4),
    Attributes: u32 align(4),
    GrantedAccess: u32 align(4),
    HandleCount: u32 align(4),
    PointerCount: u32 align(4),
    ObjectInfoRva: u32 align(4),
    Reserved0: u32 align(4),
};

pub const MINIDUMP_HANDLE_DATA_STREAM = extern struct {
    SizeOfHeader: u32,
    SizeOfDescriptor: u32,
    NumberOfDescriptors: u32,
    Reserved: u32,
};

pub const MINIDUMP_HANDLE_OPERATION_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
    Reserved: u32,
};

pub const MINIDUMP_FUNCTION_TABLE_DESCRIPTOR = extern struct {
    MinimumAddress: u64 align(4),
    MaximumAddress: u64 align(4),
    BaseAddress: u64 align(4),
    EntryCount: u32 align(4),
    SizeOfAlignPad: u32 align(4),
};

pub const MINIDUMP_FUNCTION_TABLE_STREAM = extern struct {
    SizeOfHeader: u32,
    SizeOfDescriptor: u32,
    SizeOfNativeDescriptor: u32,
    SizeOfFunctionEntry: u32,
    NumberOfDescriptors: u32,
    SizeOfAlignPad: u32,
};

pub const MINIDUMP_UNLOADED_MODULE = extern struct {
    BaseOfImage: u64 align(4),
    SizeOfImage: u32 align(4),
    CheckSum: u32 align(4),
    TimeDateStamp: u32 align(4),
    ModuleNameRva: u32 align(4),
};

pub const MINIDUMP_UNLOADED_MODULE_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
};

pub const XSTATE_CONFIG_FEATURE_MSC_INFO = extern struct {
    SizeOfInfo: u32 align(4),
    ContextSize: u32 align(4),
    EnabledFeatures: u64 align(4),
    Features: [64]XSTATE_FEATURE align(4),
};

pub const MINIDUMP_MISC_INFO = extern struct {
    SizeOfInfo: u32,
    Flags1: MINIDUMP_MISC_INFO_FLAGS,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
};

pub const MINIDUMP_MISC_INFO_2 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
};

pub const MINIDUMP_MISC_INFO_3 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
};

pub const MINIDUMP_MISC_INFO_4 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
    BuildString: [260]u16,
    DbgBldStr: [40]u16,
};

pub const MINIDUMP_MISC_INFO_5 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
    BuildString: [260]u16,
    DbgBldStr: [40]u16,
    XStateData: XSTATE_CONFIG_FEATURE_MSC_INFO,
    ProcessCookie: u32,
};

pub const MINIDUMP_MEMORY_INFO = extern struct {
    BaseAddress: u64 align(4),
    AllocationBase: u64 align(4),
    AllocationProtect: u32 align(4),
    __alignment1: u32 align(4),
    RegionSize: u64 align(4),
    State: VIRTUAL_ALLOCATION_TYPE align(4),
    Protect: u32 align(4),
    Type: u32 align(4),
    __alignment2: u32 align(4),
};

pub const MINIDUMP_MEMORY_INFO_LIST = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfEntry: u32 align(4),
    NumberOfEntries: u64 align(4),
};

pub const MINIDUMP_THREAD_NAME = extern struct {
    ThreadId: u32 align(4),
    RvaOfThreadName: u64 align(4),
};

pub const MINIDUMP_THREAD_NAME_LIST = extern struct {
    NumberOfThreadNames: u32,
    ThreadNames: [1]MINIDUMP_THREAD_NAME,
};

pub const MINIDUMP_THREAD_INFO = extern struct {
    ThreadId: u32 align(4),
    DumpFlags: MINIDUMP_THREAD_INFO_DUMP_FLAGS align(4),
    DumpError: u32 align(4),
    ExitStatus: u32 align(4),
    CreateTime: u64 align(4),
    ExitTime: u64 align(4),
    KernelTime: u64 align(4),
    UserTime: u64 align(4),
    StartAddress: u64 align(4),
    Affinity: u64 align(4),
};

pub const MINIDUMP_THREAD_INFO_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
};

pub const MINIDUMP_TOKEN_INFO_HEADER = extern struct {
    TokenSize: u32 align(4),
    TokenId: u32 align(4),
    TokenHandle: u64 align(4),
};

pub const MINIDUMP_TOKEN_INFO_LIST = extern struct {
    TokenListSize: u32,
    TokenListEntries: u32,
    ListHeaderSize: u32,
    ElementHeaderSize: u32,
};

pub const MINIDUMP_SYSTEM_BASIC_INFORMATION = extern struct {
    TimerResolution: u32 align(4),
    PageSize: u32 align(4),
    NumberOfPhysicalPages: u32 align(4),
    LowestPhysicalPageNumber: u32 align(4),
    HighestPhysicalPageNumber: u32 align(4),
    AllocationGranularity: u32 align(4),
    MinimumUserModeAddress: u64 align(4),
    MaximumUserModeAddress: u64 align(4),
    ActiveProcessorsAffinityMask: u64 align(4),
    NumberOfProcessors: u32 align(4),
};

pub const MINIDUMP_SYSTEM_FILECACHE_INFORMATION = extern struct {
    CurrentSize: u64 align(4),
    PeakSize: u64 align(4),
    PageFaultCount: u32 align(4),
    MinimumWorkingSet: u64 align(4),
    MaximumWorkingSet: u64 align(4),
    CurrentSizeIncludingTransitionInPages: u64 align(4),
    PeakSizeIncludingTransitionInPages: u64 align(4),
    TransitionRePurposeCount: u32 align(4),
    Flags: u32 align(4),
};

pub const MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION = extern struct {
    AvailablePages: u64 align(4),
    CommittedPages: u64 align(4),
    CommitLimit: u64 align(4),
    PeakCommitment: u64 align(4),
};

pub const MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    IdleProcessTime: u64 align(4),
    IoReadTransferCount: u64 align(4),
    IoWriteTransferCount: u64 align(4),
    IoOtherTransferCount: u64 align(4),
    IoReadOperationCount: u32 align(4),
    IoWriteOperationCount: u32 align(4),
    IoOtherOperationCount: u32 align(4),
    AvailablePages: u32 align(4),
    CommittedPages: u32 align(4),
    CommitLimit: u32 align(4),
    PeakCommitment: u32 align(4),
    PageFaultCount: u32 align(4),
    CopyOnWriteCount: u32 align(4),
    TransitionCount: u32 align(4),
    CacheTransitionCount: u32 align(4),
    DemandZeroCount: u32 align(4),
    PageReadCount: u32 align(4),
    PageReadIoCount: u32 align(4),
    CacheReadCount: u32 align(4),
    CacheIoCount: u32 align(4),
    DirtyPagesWriteCount: u32 align(4),
    DirtyWriteIoCount: u32 align(4),
    MappedPagesWriteCount: u32 align(4),
    MappedWriteIoCount: u32 align(4),
    PagedPoolPages: u32 align(4),
    NonPagedPoolPages: u32 align(4),
    PagedPoolAllocs: u32 align(4),
    PagedPoolFrees: u32 align(4),
    NonPagedPoolAllocs: u32 align(4),
    NonPagedPoolFrees: u32 align(4),
    FreeSystemPtes: u32 align(4),
    ResidentSystemCodePage: u32 align(4),
    TotalSystemDriverPages: u32 align(4),
    TotalSystemCodePages: u32 align(4),
    NonPagedPoolLookasideHits: u32 align(4),
    PagedPoolLookasideHits: u32 align(4),
    AvailablePagedPoolPages: u32 align(4),
    ResidentSystemCachePage: u32 align(4),
    ResidentPagedPoolPage: u32 align(4),
    ResidentSystemDriverPage: u32 align(4),
    CcFastReadNoWait: u32 align(4),
    CcFastReadWait: u32 align(4),
    CcFastReadResourceMiss: u32 align(4),
    CcFastReadNotPossible: u32 align(4),
    CcFastMdlReadNoWait: u32 align(4),
    CcFastMdlReadWait: u32 align(4),
    CcFastMdlReadResourceMiss: u32 align(4),
    CcFastMdlReadNotPossible: u32 align(4),
    CcMapDataNoWait: u32 align(4),
    CcMapDataWait: u32 align(4),
    CcMapDataNoWaitMiss: u32 align(4),
    CcMapDataWaitMiss: u32 align(4),
    CcPinMappedDataCount: u32 align(4),
    CcPinReadNoWait: u32 align(4),
    CcPinReadWait: u32 align(4),
    CcPinReadNoWaitMiss: u32 align(4),
    CcPinReadWaitMiss: u32 align(4),
    CcCopyReadNoWait: u32 align(4),
    CcCopyReadWait: u32 align(4),
    CcCopyReadNoWaitMiss: u32 align(4),
    CcCopyReadWaitMiss: u32 align(4),
    CcMdlReadNoWait: u32 align(4),
    CcMdlReadWait: u32 align(4),
    CcMdlReadNoWaitMiss: u32 align(4),
    CcMdlReadWaitMiss: u32 align(4),
    CcReadAheadIos: u32 align(4),
    CcLazyWriteIos: u32 align(4),
    CcLazyWritePages: u32 align(4),
    CcDataFlushes: u32 align(4),
    CcDataPages: u32 align(4),
    ContextSwitches: u32 align(4),
    FirstLevelTbFills: u32 align(4),
    SecondLevelTbFills: u32 align(4),
    SystemCalls: u32 align(4),
    CcTotalDirtyPages: u64 align(4),
    CcDirtyPageThreshold: u64 align(4),
    ResidentAvailablePages: i64 align(4),
    SharedCommittedPages: u64 align(4),
};

pub const MINIDUMP_SYSTEM_MEMORY_INFO_1 = extern struct {
    Revision: u16,
    Flags: u16,
    BasicInfo: MINIDUMP_SYSTEM_BASIC_INFORMATION,
    FileCacheInfo: MINIDUMP_SYSTEM_FILECACHE_INFORMATION,
    BasicPerfInfo: MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION,
    PerfInfo: MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION,
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_1 = extern struct {
    Revision: u16 align(4),
    PageFaultCount: u32 align(4),
    PeakWorkingSetSize: u64 align(4),
    WorkingSetSize: u64 align(4),
    QuotaPeakPagedPoolUsage: u64 align(4),
    QuotaPagedPoolUsage: u64 align(4),
    QuotaPeakNonPagedPoolUsage: u64 align(4),
    QuotaNonPagedPoolUsage: u64 align(4),
    PagefileUsage: u64 align(4),
    PeakPagefileUsage: u64 align(4),
    PrivateUsage: u64 align(4),
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_2 = extern struct {
    Revision: u16 align(4),
    Flags: u16 align(4),
    PageFaultCount: u32 align(4),
    PeakWorkingSetSize: u64 align(4),
    WorkingSetSize: u64 align(4),
    QuotaPeakPagedPoolUsage: u64 align(4),
    QuotaPagedPoolUsage: u64 align(4),
    QuotaPeakNonPagedPoolUsage: u64 align(4),
    QuotaNonPagedPoolUsage: u64 align(4),
    PagefileUsage: u64 align(4),
    PeakPagefileUsage: u64 align(4),
    PeakVirtualSize: u64 align(4),
    VirtualSize: u64 align(4),
    PrivateUsage: u64 align(4),
    PrivateWorkingSetSize: u64 align(4),
    SharedCommitUsage: u64 align(4),
    JobSharedCommitUsage: u64 align(4),
    JobPrivateCommitUsage: u64 align(4),
    JobPeakPrivateCommitUsage: u64 align(4),
    JobPrivateCommitLimit: u64 align(4),
    JobTotalCommitLimit: u64 align(4),
};

pub const MINIDUMP_USER_RECORD = extern struct {
    Type: u32,
    Memory: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_USER_STREAM = extern struct {
    Type: u32 align(4),
    BufferSize: u32 align(4),
    Buffer: ?*anyopaque align(4),
};

pub const MINIDUMP_USER_STREAM_INFORMATION = extern struct {
    UserStreamCount: u32 align(4),
    UserStreamArray: ?*MINIDUMP_USER_STREAM align(4),
};

pub const MINIDUMP_CALLBACK_TYPE = enum(i32) {
    ModuleCallback = 0,
    ThreadCallback = 1,
    ThreadExCallback = 2,
    IncludeThreadCallback = 3,
    IncludeModuleCallback = 4,
    MemoryCallback = 5,
    CancelCallback = 6,
    WriteKernelMinidumpCallback = 7,
    KernelMinidumpStatusCallback = 8,
    RemoveMemoryCallback = 9,
    IncludeVmRegionCallback = 10,
    IoStartCallback = 11,
    IoWriteAllCallback = 12,
    IoFinishCallback = 13,
    ReadMemoryFailureCallback = 14,
    SecondaryFlagsCallback = 15,
    IsProcessSnapshotCallback = 16,
    VmStartCallback = 17,
    VmQueryCallback = 18,
    VmPreReadCallback = 19,
    VmPostReadCallback = 20,
};
pub const ModuleCallback = MINIDUMP_CALLBACK_TYPE.ModuleCallback;
pub const ThreadCallback = MINIDUMP_CALLBACK_TYPE.ThreadCallback;
pub const ThreadExCallback = MINIDUMP_CALLBACK_TYPE.ThreadExCallback;
pub const IncludeThreadCallback = MINIDUMP_CALLBACK_TYPE.IncludeThreadCallback;
pub const IncludeModuleCallback = MINIDUMP_CALLBACK_TYPE.IncludeModuleCallback;
pub const MemoryCallback = MINIDUMP_CALLBACK_TYPE.MemoryCallback;
pub const CancelCallback = MINIDUMP_CALLBACK_TYPE.CancelCallback;
pub const WriteKernelMinidumpCallback = MINIDUMP_CALLBACK_TYPE.WriteKernelMinidumpCallback;
pub const KernelMinidumpStatusCallback = MINIDUMP_CALLBACK_TYPE.KernelMinidumpStatusCallback;
pub const RemoveMemoryCallback = MINIDUMP_CALLBACK_TYPE.RemoveMemoryCallback;
pub const IncludeVmRegionCallback = MINIDUMP_CALLBACK_TYPE.IncludeVmRegionCallback;
pub const IoStartCallback = MINIDUMP_CALLBACK_TYPE.IoStartCallback;
pub const IoWriteAllCallback = MINIDUMP_CALLBACK_TYPE.IoWriteAllCallback;
pub const IoFinishCallback = MINIDUMP_CALLBACK_TYPE.IoFinishCallback;
pub const ReadMemoryFailureCallback = MINIDUMP_CALLBACK_TYPE.ReadMemoryFailureCallback;
pub const SecondaryFlagsCallback = MINIDUMP_CALLBACK_TYPE.SecondaryFlagsCallback;
pub const IsProcessSnapshotCallback = MINIDUMP_CALLBACK_TYPE.IsProcessSnapshotCallback;
pub const VmStartCallback = MINIDUMP_CALLBACK_TYPE.VmStartCallback;
pub const VmQueryCallback = MINIDUMP_CALLBACK_TYPE.VmQueryCallback;
pub const VmPreReadCallback = MINIDUMP_CALLBACK_TYPE.VmPreReadCallback;
pub const VmPostReadCallback = MINIDUMP_CALLBACK_TYPE.VmPostReadCallback;

pub const MINIDUMP_INCLUDE_THREAD_CALLBACK = extern struct {
    ThreadId: u32,
};

pub const THREAD_WRITE_FLAGS = enum(i32) {
    Thread = 1,
    Stack = 2,
    Context = 4,
    BackingStore = 8,
    InstructionWindow = 16,
    ThreadData = 32,
    ThreadInfo = 64,
};
pub const ThreadWriteThread = THREAD_WRITE_FLAGS.Thread;
pub const ThreadWriteStack = THREAD_WRITE_FLAGS.Stack;
pub const ThreadWriteContext = THREAD_WRITE_FLAGS.Context;
pub const ThreadWriteBackingStore = THREAD_WRITE_FLAGS.BackingStore;
pub const ThreadWriteInstructionWindow = THREAD_WRITE_FLAGS.InstructionWindow;
pub const ThreadWriteThreadData = THREAD_WRITE_FLAGS.ThreadData;
pub const ThreadWriteThreadInfo = THREAD_WRITE_FLAGS.ThreadInfo;

pub const MINIDUMP_MODULE_CALLBACK = extern struct {
    FullPath: ?[*]u16 align(4),
    BaseOfImage: u64 align(4),
    SizeOfImage: u32 align(4),
    CheckSum: u32 align(4),
    TimeDateStamp: u32 align(4),
    VersionInfo: VS_FIXEDFILEINFO align(4),
    CvRecord: ?*anyopaque align(4),
    SizeOfCvRecord: u32 align(4),
    MiscRecord: ?*anyopaque align(4),
    SizeOfMiscRecord: u32 align(4),
};

pub const MINIDUMP_INCLUDE_MODULE_CALLBACK = extern struct {
    BaseOfImage: u64 align(4),
};

pub const MODULE_WRITE_FLAGS = enum(i32) {
    WriteModule = 1,
    WriteDataSeg = 2,
    WriteMiscRecord = 4,
    WriteCvRecord = 8,
    ReferencedByMemory = 16,
    WriteTlsData = 32,
    WriteCodeSegs = 64,
};
pub const ModuleWriteModule = MODULE_WRITE_FLAGS.WriteModule;
pub const ModuleWriteDataSeg = MODULE_WRITE_FLAGS.WriteDataSeg;
pub const ModuleWriteMiscRecord = MODULE_WRITE_FLAGS.WriteMiscRecord;
pub const ModuleWriteCvRecord = MODULE_WRITE_FLAGS.WriteCvRecord;
pub const ModuleReferencedByMemory = MODULE_WRITE_FLAGS.ReferencedByMemory;
pub const ModuleWriteTlsData = MODULE_WRITE_FLAGS.WriteTlsData;
pub const ModuleWriteCodeSegs = MODULE_WRITE_FLAGS.WriteCodeSegs;

pub const MINIDUMP_IO_CALLBACK = extern struct {
    Handle: ?HANDLE align(4),
    Offset: u64 align(4),
    Buffer: ?*anyopaque align(4),
    BufferBytes: u32 align(4),
};

pub const MINIDUMP_READ_MEMORY_FAILURE_CALLBACK = extern struct {
    Offset: u64 align(4),
    Bytes: u32 align(4),
    FailureStatus: HRESULT align(4),
};

pub const MINIDUMP_VM_QUERY_CALLBACK = extern struct {
    Offset: u64 align(4),
};

pub const MINIDUMP_VM_PRE_READ_CALLBACK = extern struct {
    Offset: u64 align(4),
    Buffer: ?*anyopaque align(4),
    Size: u32 align(4),
};

pub const MINIDUMP_VM_POST_READ_CALLBACK = extern struct {
    Offset: u64 align(4),
    Buffer: ?*anyopaque align(4),
    Size: u32 align(4),
    Completed: u32 align(4),
    Status: HRESULT align(4),
};

pub const MINIDUMP_CALLBACK_INPUT = extern struct {
    ProcessId: u32,
    ProcessHandle: ?HANDLE,
    CallbackType: u32,
    Anonymous: extern union {
        Status: HRESULT,
        Thread: MINIDUMP_THREAD_CALLBACK,
        ThreadEx: MINIDUMP_THREAD_EX_CALLBACK,
        Module: MINIDUMP_MODULE_CALLBACK,
        IncludeThread: MINIDUMP_INCLUDE_THREAD_CALLBACK,
        IncludeModule: MINIDUMP_INCLUDE_MODULE_CALLBACK,
        Io: MINIDUMP_IO_CALLBACK,
        ReadMemoryFailure: MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
        SecondaryFlags: u32,
        VmQuery: MINIDUMP_VM_QUERY_CALLBACK,
        VmPreRead: MINIDUMP_VM_PRE_READ_CALLBACK,
        VmPostRead: MINIDUMP_VM_POST_READ_CALLBACK,
    },
};

pub const MINIDUMP_CALLBACK_OUTPUT = extern struct {
    Anonymous: extern union {
        ModuleWriteFlags: u32 align(4),
        ThreadWriteFlags: u32 align(4),
        SecondaryFlags: u32 align(4),
        Anonymous1: extern struct {
            MemoryBase: u64 align(4),
            MemorySize: u32 align(4),
        } align(4),
        Anonymous2: extern struct {
            CheckCancel: BOOL,
            Cancel: BOOL,
        } align(4),
        Handle: ?HANDLE align(4),
        Anonymous3: extern struct {
            VmRegion: MINIDUMP_MEMORY_INFO,
            Continue: BOOL,
        } align(4),
        Anonymous4: extern struct {
            VmQueryStatus: HRESULT,
            VmQueryResult: MINIDUMP_MEMORY_INFO,
        } align(4),
        Anonymous5: extern struct {
            VmReadStatus: HRESULT,
            VmReadBytesCompleted: u32,
        } align(4),
        Status: HRESULT align(4),
    },
};

pub const MINIDUMP_TYPE = enum(u32) {
    Normal = 0,
    WithDataSegs = 1,
    WithFullMemory = 2,
    WithHandleData = 4,
    FilterMemory = 8,
    ScanMemory = 16,
    WithUnloadedModules = 32,
    WithIndirectlyReferencedMemory = 64,
    FilterModulePaths = 128,
    WithProcessThreadData = 256,
    WithPrivateReadWriteMemory = 512,
    WithoutOptionalData = 1024,
    WithFullMemoryInfo = 2048,
    WithThreadInfo = 4096,
    WithCodeSegs = 8192,
    WithoutAuxiliaryState = 16384,
    WithFullAuxiliaryState = 32768,
    WithPrivateWriteCopyMemory = 65536,
    IgnoreInaccessibleMemory = 131072,
    WithTokenInformation = 262144,
    WithModuleHeaders = 524288,
    FilterTriage = 1048576,
    WithAvxXStateContext = 2097152,
    WithIptTrace = 4194304,
    ScanInaccessiblePartialPages = 8388608,
    FilterWriteCombinedMemory = 16777216,
    ValidTypeFlags = 33554431,
    _,
    pub fn initFlags(o: struct {
        Normal: u1 = 0,
        WithDataSegs: u1 = 0,
        WithFullMemory: u1 = 0,
        WithHandleData: u1 = 0,
        FilterMemory: u1 = 0,
        ScanMemory: u1 = 0,
        WithUnloadedModules: u1 = 0,
        WithIndirectlyReferencedMemory: u1 = 0,
        FilterModulePaths: u1 = 0,
        WithProcessThreadData: u1 = 0,
        WithPrivateReadWriteMemory: u1 = 0,
        WithoutOptionalData: u1 = 0,
        WithFullMemoryInfo: u1 = 0,
        WithThreadInfo: u1 = 0,
        WithCodeSegs: u1 = 0,
        WithoutAuxiliaryState: u1 = 0,
        WithFullAuxiliaryState: u1 = 0,
        WithPrivateWriteCopyMemory: u1 = 0,
        IgnoreInaccessibleMemory: u1 = 0,
        WithTokenInformation: u1 = 0,
        WithModuleHeaders: u1 = 0,
        FilterTriage: u1 = 0,
        WithAvxXStateContext: u1 = 0,
        WithIptTrace: u1 = 0,
        ScanInaccessiblePartialPages: u1 = 0,
        FilterWriteCombinedMemory: u1 = 0,
        ValidTypeFlags: u1 = 0,
    }) MINIDUMP_TYPE {
        return @as(MINIDUMP_TYPE, @enumFromInt((if (o.Normal == 1) @intFromEnum(MINIDUMP_TYPE.Normal) else 0) | (if (o.WithDataSegs == 1) @intFromEnum(MINIDUMP_TYPE.WithDataSegs) else 0) | (if (o.WithFullMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithFullMemory) else 0) | (if (o.WithHandleData == 1) @intFromEnum(MINIDUMP_TYPE.WithHandleData) else 0) | (if (o.FilterMemory == 1) @intFromEnum(MINIDUMP_TYPE.FilterMemory) else 0) | (if (o.ScanMemory == 1) @intFromEnum(MINIDUMP_TYPE.ScanMemory) else 0) | (if (o.WithUnloadedModules == 1) @intFromEnum(MINIDUMP_TYPE.WithUnloadedModules) else 0) | (if (o.WithIndirectlyReferencedMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithIndirectlyReferencedMemory) else 0) | (if (o.FilterModulePaths == 1) @intFromEnum(MINIDUMP_TYPE.FilterModulePaths) else 0) | (if (o.WithProcessThreadData == 1) @intFromEnum(MINIDUMP_TYPE.WithProcessThreadData) else 0) | (if (o.WithPrivateReadWriteMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithPrivateReadWriteMemory) else 0) | (if (o.WithoutOptionalData == 1) @intFromEnum(MINIDUMP_TYPE.WithoutOptionalData) else 0) | (if (o.WithFullMemoryInfo == 1) @intFromEnum(MINIDUMP_TYPE.WithFullMemoryInfo) else 0) | (if (o.WithThreadInfo == 1) @intFromEnum(MINIDUMP_TYPE.WithThreadInfo) else 0) | (if (o.WithCodeSegs == 1) @intFromEnum(MINIDUMP_TYPE.WithCodeSegs) else 0) | (if (o.WithoutAuxiliaryState == 1) @intFromEnum(MINIDUMP_TYPE.WithoutAuxiliaryState) else 0) | (if (o.WithFullAuxiliaryState == 1) @intFromEnum(MINIDUMP_TYPE.WithFullAuxiliaryState) else 0) | (if (o.WithPrivateWriteCopyMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithPrivateWriteCopyMemory) else 0) | (if (o.IgnoreInaccessibleMemory == 1) @intFromEnum(MINIDUMP_TYPE.IgnoreInaccessibleMemory) else 0) | (if (o.WithTokenInformation == 1) @intFromEnum(MINIDUMP_TYPE.WithTokenInformation) else 0) | (if (o.WithModuleHeaders == 1) @intFromEnum(MINIDUMP_TYPE.WithModuleHeaders) else 0) | (if (o.FilterTriage == 1) @intFromEnum(MINIDUMP_TYPE.FilterTriage) else 0) | (if (o.WithAvxXStateContext == 1) @intFromEnum(MINIDUMP_TYPE.WithAvxXStateContext) else 0) | (if (o.WithIptTrace == 1) @intFromEnum(MINIDUMP_TYPE.WithIptTrace) else 0) | (if (o.ScanInaccessiblePartialPages == 1) @intFromEnum(MINIDUMP_TYPE.ScanInaccessiblePartialPages) else 0) | (if (o.FilterWriteCombinedMemory == 1) @intFromEnum(MINIDUMP_TYPE.FilterWriteCombinedMemory) else 0) | (if (o.ValidTypeFlags == 1) @intFromEnum(MINIDUMP_TYPE.ValidTypeFlags) else 0)));
    }
};
pub const MiniDumpNormal = MINIDUMP_TYPE.Normal;
pub const MiniDumpWithDataSegs = MINIDUMP_TYPE.WithDataSegs;
pub const MiniDumpWithFullMemory = MINIDUMP_TYPE.WithFullMemory;
pub const MiniDumpWithHandleData = MINIDUMP_TYPE.WithHandleData;
pub const MiniDumpFilterMemory = MINIDUMP_TYPE.FilterMemory;
pub const MiniDumpScanMemory = MINIDUMP_TYPE.ScanMemory;
pub const MiniDumpWithUnloadedModules = MINIDUMP_TYPE.WithUnloadedModules;
pub const MiniDumpWithIndirectlyReferencedMemory = MINIDUMP_TYPE.WithIndirectlyReferencedMemory;
pub const MiniDumpFilterModulePaths = MINIDUMP_TYPE.FilterModulePaths;
pub const MiniDumpWithProcessThreadData = MINIDUMP_TYPE.WithProcessThreadData;
pub const MiniDumpWithPrivateReadWriteMemory = MINIDUMP_TYPE.WithPrivateReadWriteMemory;
pub const MiniDumpWithoutOptionalData = MINIDUMP_TYPE.WithoutOptionalData;
pub const MiniDumpWithFullMemoryInfo = MINIDUMP_TYPE.WithFullMemoryInfo;
pub const MiniDumpWithThreadInfo = MINIDUMP_TYPE.WithThreadInfo;
pub const MiniDumpWithCodeSegs = MINIDUMP_TYPE.WithCodeSegs;
pub const MiniDumpWithoutAuxiliaryState = MINIDUMP_TYPE.WithoutAuxiliaryState;
pub const MiniDumpWithFullAuxiliaryState = MINIDUMP_TYPE.WithFullAuxiliaryState;
pub const MiniDumpWithPrivateWriteCopyMemory = MINIDUMP_TYPE.WithPrivateWriteCopyMemory;
pub const MiniDumpIgnoreInaccessibleMemory = MINIDUMP_TYPE.IgnoreInaccessibleMemory;
pub const MiniDumpWithTokenInformation = MINIDUMP_TYPE.WithTokenInformation;
pub const MiniDumpWithModuleHeaders = MINIDUMP_TYPE.WithModuleHeaders;
pub const MiniDumpFilterTriage = MINIDUMP_TYPE.FilterTriage;
pub const MiniDumpWithAvxXStateContext = MINIDUMP_TYPE.WithAvxXStateContext;
pub const MiniDumpWithIptTrace = MINIDUMP_TYPE.WithIptTrace;
pub const MiniDumpScanInaccessiblePartialPages = MINIDUMP_TYPE.ScanInaccessiblePartialPages;
pub const MiniDumpFilterWriteCombinedMemory = MINIDUMP_TYPE.FilterWriteCombinedMemory;
pub const MiniDumpValidTypeFlags = MINIDUMP_TYPE.ValidTypeFlags;

pub const MINIDUMP_SECONDARY_FLAGS = enum(i32) {
    WithoutPowerInfo = 1,
    // ValidFlags = 1, this enum value conflicts with WithoutPowerInfo
};
pub const MiniSecondaryWithoutPowerInfo = MINIDUMP_SECONDARY_FLAGS.WithoutPowerInfo;
pub const MiniSecondaryValidFlags = MINIDUMP_SECONDARY_FLAGS.WithoutPowerInfo;

pub const MINIDUMP_CALLBACK_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        CallbackParam: ?*anyopaque,
        CallbackInput: ?*MINIDUMP_CALLBACK_INPUT,
        CallbackOutput: ?*MINIDUMP_CALLBACK_OUTPUT,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        CallbackParam: ?*anyopaque,
        CallbackInput: ?*MINIDUMP_CALLBACK_INPUT,
        CallbackOutput: ?*MINIDUMP_CALLBACK_OUTPUT,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const MINIDUMP_CALLBACK_INFORMATION = extern struct {
    CallbackRoutine: ?MINIDUMP_CALLBACK_ROUTINE align(4),
    CallbackParam: ?*anyopaque align(4),
};

const CLSID_ProcessDebugManager_Value = Guid.initString("78a51822-51f4-11d0-8f20-00805f2cd064");
pub const CLSID_ProcessDebugManager = &CLSID_ProcessDebugManager_Value;

const CLSID_DebugHelper_Value = Guid.initString("0bfcc060-8c1d-11d0-accd-00aa0060275c");
pub const CLSID_DebugHelper = &CLSID_DebugHelper_Value;

const CLSID_CDebugDocumentHelper_Value = Guid.initString("83b8bca6-687c-11d0-a405-00aa0060275c");
pub const CLSID_CDebugDocumentHelper = &CLSID_CDebugDocumentHelper_Value;

const CLSID_MachineDebugManager_RETAIL_Value = Guid.initString("0c0a3666-30c9-11d0-8f20-00805f2cd064");
pub const CLSID_MachineDebugManager_RETAIL = &CLSID_MachineDebugManager_RETAIL_Value;

const CLSID_MachineDebugManager_DEBUG_Value = Guid.initString("49769cec-3a55-4bb0-b697-88fede77e8ea");
pub const CLSID_MachineDebugManager_DEBUG = &CLSID_MachineDebugManager_DEBUG_Value;

const CLSID_DefaultDebugSessionProvider_Value = Guid.initString("834128a2-51f4-11d0-8f20-00805f2cd064");
pub const CLSID_DefaultDebugSessionProvider = &CLSID_DefaultDebugSessionProvider_Value;

pub const SCRIPTLANGUAGEVERSION = enum(i32) {
    DEFAULT = 0,
    @"5_7" = 1,
    @"5_8" = 2,
    MAX = 255,
};
pub const SCRIPTLANGUAGEVERSION_DEFAULT = SCRIPTLANGUAGEVERSION.DEFAULT;
pub const SCRIPTLANGUAGEVERSION_5_7 = SCRIPTLANGUAGEVERSION.@"5_7";
pub const SCRIPTLANGUAGEVERSION_5_8 = SCRIPTLANGUAGEVERSION.@"5_8";
pub const SCRIPTLANGUAGEVERSION_MAX = SCRIPTLANGUAGEVERSION.MAX;

pub const SCRIPTSTATE = enum(i32) {
    UNINITIALIZED = 0,
    INITIALIZED = 5,
    STARTED = 1,
    CONNECTED = 2,
    DISCONNECTED = 3,
    CLOSED = 4,
};
pub const SCRIPTSTATE_UNINITIALIZED = SCRIPTSTATE.UNINITIALIZED;
pub const SCRIPTSTATE_INITIALIZED = SCRIPTSTATE.INITIALIZED;
pub const SCRIPTSTATE_STARTED = SCRIPTSTATE.STARTED;
pub const SCRIPTSTATE_CONNECTED = SCRIPTSTATE.CONNECTED;
pub const SCRIPTSTATE_DISCONNECTED = SCRIPTSTATE.DISCONNECTED;
pub const SCRIPTSTATE_CLOSED = SCRIPTSTATE.CLOSED;

pub const SCRIPTTRACEINFO = enum(i32) {
    SCRIPTSTART = 0,
    SCRIPTEND = 1,
    COMCALLSTART = 2,
    COMCALLEND = 3,
    CREATEOBJSTART = 4,
    CREATEOBJEND = 5,
    GETOBJSTART = 6,
    GETOBJEND = 7,
};
pub const SCRIPTTRACEINFO_SCRIPTSTART = SCRIPTTRACEINFO.SCRIPTSTART;
pub const SCRIPTTRACEINFO_SCRIPTEND = SCRIPTTRACEINFO.SCRIPTEND;
pub const SCRIPTTRACEINFO_COMCALLSTART = SCRIPTTRACEINFO.COMCALLSTART;
pub const SCRIPTTRACEINFO_COMCALLEND = SCRIPTTRACEINFO.COMCALLEND;
pub const SCRIPTTRACEINFO_CREATEOBJSTART = SCRIPTTRACEINFO.CREATEOBJSTART;
pub const SCRIPTTRACEINFO_CREATEOBJEND = SCRIPTTRACEINFO.CREATEOBJEND;
pub const SCRIPTTRACEINFO_GETOBJSTART = SCRIPTTRACEINFO.GETOBJSTART;
pub const SCRIPTTRACEINFO_GETOBJEND = SCRIPTTRACEINFO.GETOBJEND;

pub const SCRIPTTHREADSTATE = enum(i32) {
    NOTINSCRIPT = 0,
    RUNNING = 1,
};
pub const SCRIPTTHREADSTATE_NOTINSCRIPT = SCRIPTTHREADSTATE.NOTINSCRIPT;
pub const SCRIPTTHREADSTATE_RUNNING = SCRIPTTHREADSTATE.RUNNING;

pub const SCRIPTGCTYPE = enum(i32) {
    NORMAL = 0,
    EXHAUSTIVE = 1,
};
pub const SCRIPTGCTYPE_NORMAL = SCRIPTGCTYPE.NORMAL;
pub const SCRIPTGCTYPE_EXHAUSTIVE = SCRIPTGCTYPE.EXHAUSTIVE;

pub const SCRIPTUICITEM = enum(i32) {
    INPUTBOX = 1,
    MSGBOX = 2,
};
pub const SCRIPTUICITEM_INPUTBOX = SCRIPTUICITEM.INPUTBOX;
pub const SCRIPTUICITEM_MSGBOX = SCRIPTUICITEM.MSGBOX;

pub const SCRIPTUICHANDLING = enum(i32) {
    ALLOW = 0,
    NOUIERROR = 1,
    NOUIDEFAULT = 2,
};
pub const SCRIPTUICHANDLING_ALLOW = SCRIPTUICHANDLING.ALLOW;
pub const SCRIPTUICHANDLING_NOUIERROR = SCRIPTUICHANDLING.NOUIERROR;
pub const SCRIPTUICHANDLING_NOUIDEFAULT = SCRIPTUICHANDLING.NOUIDEFAULT;

const IID_IActiveScriptSite_Value = Guid.initString("db01a1e3-a42b-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptSite = &IID_IActiveScriptSite_Value;
pub const IActiveScriptSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
                pstrName: ?[*:0]const u16,
                dwReturnMask: u32,
                ppiunkItem: ?*?*IUnknown,
                ppti: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
                pstrName: ?[*:0]const u16,
                dwReturnMask: u32,
                ppiunkItem: ?*?*IUnknown,
                ppti: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
                pbstrVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
                pbstrVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptTerminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
                pvarResult: ?*const VARIANT,
                pexcepinfo: ?*const EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
                pvarResult: ?*const VARIANT,
                pexcepinfo: ?*const EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
                ssScriptState: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
                ssScriptState: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
                pscripterror: ?*IActiveScriptError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
                pscripterror: ?*IActiveScriptError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEnterScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLeaveScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_GetLCID(self: *const T, plcid: ?*u32) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).GetLCID(@as(*const IActiveScriptSite, @ptrCast(self)), plcid);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_GetItemInfo(self: *const T, pstrName: ?[*:0]const u16, dwReturnMask: u32, ppiunkItem: ?*?*IUnknown, ppti: ?*?*ITypeInfo) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).GetItemInfo(@as(*const IActiveScriptSite, @ptrCast(self)), pstrName, dwReturnMask, ppiunkItem, ppti);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_GetDocVersionString(self: *const T, pbstrVersion: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).GetDocVersionString(@as(*const IActiveScriptSite, @ptrCast(self)), pbstrVersion);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_OnScriptTerminate(self: *const T, pvarResult: ?*const VARIANT, pexcepinfo: ?*const EXCEPINFO) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnScriptTerminate(@as(*const IActiveScriptSite, @ptrCast(self)), pvarResult, pexcepinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_OnStateChange(self: *const T, ssScriptState: SCRIPTSTATE) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnStateChange(@as(*const IActiveScriptSite, @ptrCast(self)), ssScriptState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_OnScriptError(self: *const T, pscripterror: ?*IActiveScriptError) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnScriptError(@as(*const IActiveScriptSite, @ptrCast(self)), pscripterror);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_OnEnterScript(self: *const T) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnEnterScript(@as(*const IActiveScriptSite, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSite_OnLeaveScript(self: *const T) HRESULT {
                return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnLeaveScript(@as(*const IActiveScriptSite, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError_Value = Guid.initString("eae1ba61-a4ed-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptError = &IID_IActiveScriptError_Value;
pub const IActiveScriptError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExceptionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptError,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptError,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptError,
                pdwSourceContext: ?*u32,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptError,
                pdwSourceContext: ?*u32,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceLineText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptError,
                pbstrSourceLine: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptError,
                pbstrSourceLine: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptError_GetExceptionInfo(self: *const T, pexcepinfo: ?*EXCEPINFO) HRESULT {
                return @as(*const IActiveScriptError.VTable, @ptrCast(self.vtable)).GetExceptionInfo(@as(*const IActiveScriptError, @ptrCast(self)), pexcepinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptError_GetSourcePosition(self: *const T, pdwSourceContext: ?*u32, pulLineNumber: ?*u32, plCharacterPosition: ?*i32) HRESULT {
                return @as(*const IActiveScriptError.VTable, @ptrCast(self.vtable)).GetSourcePosition(@as(*const IActiveScriptError, @ptrCast(self)), pdwSourceContext, pulLineNumber, plCharacterPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptError_GetSourceLineText(self: *const T, pbstrSourceLine: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptError.VTable, @ptrCast(self.vtable)).GetSourceLineText(@as(*const IActiveScriptError, @ptrCast(self)), pbstrSourceLine);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError64_Value = Guid.initString("b21fb2a1-5b8f-4963-8c21-21450f84ed7f");
pub const IID_IActiveScriptError64 = &IID_IActiveScriptError64_Value;
pub const IActiveScriptError64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetSourcePosition64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptError64,
                pdwSourceContext: ?*u64,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptError64,
                pdwSourceContext: ?*u64,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptError.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptError64_GetSourcePosition64(self: *const T, pdwSourceContext: ?*u64, pulLineNumber: ?*u32, plCharacterPosition: ?*i32) HRESULT {
                return @as(*const IActiveScriptError64.VTable, @ptrCast(self.vtable)).GetSourcePosition64(@as(*const IActiveScriptError64, @ptrCast(self)), pdwSourceContext, pulLineNumber, plCharacterPosition);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteWindow_Value = Guid.initString("d10f6761-83e9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptSiteWindow = &IID_IActiveScriptSiteWindow_Value;
pub const IActiveScriptSiteWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteWindow,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteWindow,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteWindow,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteWindow,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteWindow_GetWindow(self: *const T, phwnd: ?*?HWND) HRESULT {
                return @as(*const IActiveScriptSiteWindow.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const IActiveScriptSiteWindow, @ptrCast(self)), phwnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteWindow_EnableModeless(self: *const T, fEnable: BOOL) HRESULT {
                return @as(*const IActiveScriptSiteWindow.VTable, @ptrCast(self.vtable)).EnableModeless(@as(*const IActiveScriptSiteWindow, @ptrCast(self)), fEnable);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteUIControl_Value = Guid.initString("aedae97e-d7ee-4796-b960-7f092ae844ab");
pub const IID_IActiveScriptSiteUIControl = &IID_IActiveScriptSiteUIControl_Value;
pub const IActiveScriptSiteUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUIBehavior: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteUIControl,
                UicItem: SCRIPTUICITEM,
                pUicHandling: ?*SCRIPTUICHANDLING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteUIControl,
                UicItem: SCRIPTUICITEM,
                pUicHandling: ?*SCRIPTUICHANDLING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteUIControl_GetUIBehavior(self: *const T, UicItem: SCRIPTUICITEM, pUicHandling: ?*SCRIPTUICHANDLING) HRESULT {
                return @as(*const IActiveScriptSiteUIControl.VTable, @ptrCast(self.vtable)).GetUIBehavior(@as(*const IActiveScriptSiteUIControl, @ptrCast(self)), UicItem, pUicHandling);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteInterruptPoll_Value = Guid.initString("539698a0-cdca-11cf-a5eb-00aa0047a063");
pub const IID_IActiveScriptSiteInterruptPoll = &IID_IActiveScriptSiteInterruptPoll_Value;
pub const IActiveScriptSiteInterruptPoll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteInterruptPoll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteInterruptPoll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteInterruptPoll_QueryContinue(self: *const T) HRESULT {
                return @as(*const IActiveScriptSiteInterruptPoll.VTable, @ptrCast(self.vtable)).QueryContinue(@as(*const IActiveScriptSiteInterruptPoll, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScript_Value = Guid.initString("bb1a2ae1-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScript = &IID_IActiveScript_Value;
pub const IActiveScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScriptSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                pass: ?*IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                pass: ?*IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScriptState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                ss: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                ss: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                pssState: ?*SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                pssState: ?*SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                pstrName: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                pstrName: ?[*:0]const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                pstrItemName: ?[*:0]const u16,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                pstrItemName: ?[*:0]const u16,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScriptThreadID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptThreadID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                dwWin32ThreadId: u32,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                dwWin32ThreadId: u32,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptThreadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                stidThread: u32,
                pstsState: ?*SCRIPTTHREADSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                stidThread: u32,
                pstsState: ?*SCRIPTTHREADSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InterruptScriptThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                stidThread: u32,
                pexcepinfo: ?*const EXCEPINFO,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                stidThread: u32,
                pexcepinfo: ?*const EXCEPINFO,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScript,
                ppscript: ?*?*IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScript,
                ppscript: ?*?*IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_SetScriptSite(self: *const T, pass: ?*IActiveScriptSite) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).SetScriptSite(@as(*const IActiveScript, @ptrCast(self)), pass);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_GetScriptSite(self: *const T, riid: ?*const Guid, ppvObject: ?*?*anyopaque) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptSite(@as(*const IActiveScript, @ptrCast(self)), riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_SetScriptState(self: *const T, ss: SCRIPTSTATE) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).SetScriptState(@as(*const IActiveScript, @ptrCast(self)), ss);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_GetScriptState(self: *const T, pssState: ?*SCRIPTSTATE) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptState(@as(*const IActiveScript, @ptrCast(self)), pssState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_Close(self: *const T) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).Close(@as(*const IActiveScript, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_AddNamedItem(self: *const T, pstrName: ?[*:0]const u16, dwFlags: u32) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).AddNamedItem(@as(*const IActiveScript, @ptrCast(self)), pstrName, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_AddTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32, dwFlags: u32) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).AddTypeLib(@as(*const IActiveScript, @ptrCast(self)), rguidTypeLib, dwMajor, dwMinor, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_GetScriptDispatch(self: *const T, pstrItemName: ?[*:0]const u16, ppdisp: ?*?*IDispatch) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptDispatch(@as(*const IActiveScript, @ptrCast(self)), pstrItemName, ppdisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_GetCurrentScriptThreadID(self: *const T, pstidThread: ?*u32) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetCurrentScriptThreadID(@as(*const IActiveScript, @ptrCast(self)), pstidThread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_GetScriptThreadID(self: *const T, dwWin32ThreadId: u32, pstidThread: ?*u32) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptThreadID(@as(*const IActiveScript, @ptrCast(self)), dwWin32ThreadId, pstidThread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_GetScriptThreadState(self: *const T, stidThread: u32, pstsState: ?*SCRIPTTHREADSTATE) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptThreadState(@as(*const IActiveScript, @ptrCast(self)), stidThread, pstsState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_InterruptScriptThread(self: *const T, stidThread: u32, pexcepinfo: ?*const EXCEPINFO, dwFlags: u32) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).InterruptScriptThread(@as(*const IActiveScript, @ptrCast(self)), stidThread, pexcepinfo, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScript_Clone(self: *const T, ppscript: ?*?*IActiveScript) HRESULT {
                return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).Clone(@as(*const IActiveScript, @ptrCast(self)), ppscript);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse32_Value = Guid.initString("bb1a2ae2-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptParse32 = &IID_IActiveScriptParse32_Value;
pub const IActiveScriptParse32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParse32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParse32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScriptlet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParse32,
                pstrDefaultName: ?[*:0]const u16,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                pstrSubItemName: ?[*:0]const u16,
                pstrEventName: ?[*:0]const u16,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParse32,
                pstrDefaultName: ?[*:0]const u16,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                pstrSubItemName: ?[*:0]const u16,
                pstrEventName: ?[*:0]const u16,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseScriptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParse32,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParse32,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParse32_InitNew(self: *const T) HRESULT {
                return @as(*const IActiveScriptParse32.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IActiveScriptParse32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParse32_AddScriptlet(self: *const T, pstrDefaultName: ?[*:0]const u16, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, pstrSubItemName: ?[*:0]const u16, pstrEventName: ?[*:0]const u16, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: ?*?BSTR, pexcepinfo: ?*EXCEPINFO) HRESULT {
                return @as(*const IActiveScriptParse32.VTable, @ptrCast(self.vtable)).AddScriptlet(@as(*const IActiveScriptParse32, @ptrCast(self)), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParse32_ParseScriptText(self: *const T, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO) HRESULT {
                return @as(*const IActiveScriptParse32.VTable, @ptrCast(self.vtable)).ParseScriptText(@as(*const IActiveScriptParse32, @ptrCast(self)), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse64_Value = Guid.initString("c7ef7658-e1ee-480e-97ea-d52cb4d76d17");
pub const IID_IActiveScriptParse64 = &IID_IActiveScriptParse64_Value;
pub const IActiveScriptParse64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParse64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParse64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScriptlet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParse64,
                pstrDefaultName: ?[*:0]const u16,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                pstrSubItemName: ?[*:0]const u16,
                pstrEventName: ?[*:0]const u16,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParse64,
                pstrDefaultName: ?[*:0]const u16,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                pstrSubItemName: ?[*:0]const u16,
                pstrEventName: ?[*:0]const u16,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseScriptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParse64,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParse64,
                pstrCode: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParse64_InitNew(self: *const T) HRESULT {
                return @as(*const IActiveScriptParse64.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IActiveScriptParse64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParse64_AddScriptlet(self: *const T, pstrDefaultName: ?[*:0]const u16, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, pstrSubItemName: ?[*:0]const u16, pstrEventName: ?[*:0]const u16, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: ?*?BSTR, pexcepinfo: ?*EXCEPINFO) HRESULT {
                return @as(*const IActiveScriptParse64.VTable, @ptrCast(self.vtable)).AddScriptlet(@as(*const IActiveScriptParse64, @ptrCast(self)), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParse64_ParseScriptText(self: *const T, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO) HRESULT {
                return @as(*const IActiveScriptParse64.VTable, @ptrCast(self.vtable)).ParseScriptText(@as(*const IActiveScriptParse64, @ptrCast(self)), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld32_Value = Guid.initString("1cff0050-6fdd-11d0-9328-00a0c90dcaa9");
pub const IID_IActiveScriptParseProcedureOld32 = &IID_IActiveScriptParseProcedureOld32_Value;
pub const IActiveScriptParseProcedureOld32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParseProcedureOld32,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParseProcedureOld32,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParseProcedureOld32_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) HRESULT {
                return @as(*const IActiveScriptParseProcedureOld32.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedureOld32, @ptrCast(self)), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld64_Value = Guid.initString("21f57128-08c9-4638-ba12-22d15d88dc5c");
pub const IID_IActiveScriptParseProcedureOld64 = &IID_IActiveScriptParseProcedureOld64_Value;
pub const IActiveScriptParseProcedureOld64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParseProcedureOld64,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParseProcedureOld64,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParseProcedureOld64_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) HRESULT {
                return @as(*const IActiveScriptParseProcedureOld64.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedureOld64, @ptrCast(self)), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure32_Value = Guid.initString("aa5b6a80-b834-11d0-932f-00a0c90dcaa9");
pub const IID_IActiveScriptParseProcedure32 = &IID_IActiveScriptParseProcedure32_Value;
pub const IActiveScriptParseProcedure32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParseProcedure32,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrProcedureName: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParseProcedure32,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrProcedureName: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParseProcedure32_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrProcedureName: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) HRESULT {
                return @as(*const IActiveScriptParseProcedure32.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedure32, @ptrCast(self)), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure64_Value = Guid.initString("c64713b6-e029-4cc5-9200-438b72890b6a");
pub const IID_IActiveScriptParseProcedure64 = &IID_IActiveScriptParseProcedure64_Value;
pub const IActiveScriptParseProcedure64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptParseProcedure64,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrProcedureName: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptParseProcedure64,
                pstrCode: ?[*:0]const u16,
                pstrFormalParams: ?[*:0]const u16,
                pstrProcedureName: ?[*:0]const u16,
                pstrItemName: ?[*:0]const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptParseProcedure64_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrProcedureName: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) HRESULT {
                return @as(*const IActiveScriptParseProcedure64.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedure64, @ptrCast(self)), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_32_Value = Guid.initString("71ee5b20-fb04-11d1-b3a8-00a0c911e8b2");
pub const IID_IActiveScriptParseProcedure2_32 = &IID_IActiveScriptParseProcedure2_32_Value;
pub const IActiveScriptParseProcedure2_32 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure32.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptParseProcedure32.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_64_Value = Guid.initString("fe7c4271-210c-448d-9f54-76dab7047b28");
pub const IID_IActiveScriptParseProcedure2_64 = &IID_IActiveScriptParseProcedure2_64_Value;
pub const IActiveScriptParseProcedure2_64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure64.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptParseProcedure64.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptEncode_Value = Guid.initString("bb1a2ae3-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptEncode = &IID_IActiveScriptEncode_Value;
pub const IActiveScriptEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DecodeScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEncodeProgId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptEncode,
                pbstrOut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptEncode,
                pbstrOut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptEncode_EncodeSection(self: *const T, pchIn: ?[*:0]const u16, cchIn: u32, pchOut: ?PWSTR, cchOut: u32, pcchRet: ?*u32) HRESULT {
                return @as(*const IActiveScriptEncode.VTable, @ptrCast(self.vtable)).EncodeSection(@as(*const IActiveScriptEncode, @ptrCast(self)), pchIn, cchIn, pchOut, cchOut, pcchRet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptEncode_DecodeScript(self: *const T, pchIn: ?[*:0]const u16, cchIn: u32, pchOut: ?PWSTR, cchOut: u32, pcchRet: ?*u32) HRESULT {
                return @as(*const IActiveScriptEncode.VTable, @ptrCast(self.vtable)).DecodeScript(@as(*const IActiveScriptEncode, @ptrCast(self)), pchIn, cchIn, pchOut, cchOut, pcchRet);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptEncode_GetEncodeProgId(self: *const T, pbstrOut: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptEncode.VTable, @ptrCast(self.vtable)).GetEncodeProgId(@as(*const IActiveScriptEncode, @ptrCast(self)), pbstrOut);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptHostEncode_Value = Guid.initString("bee9b76e-cfe3-11d1-b747-00c04fc2b085");
pub const IID_IActiveScriptHostEncode = &IID_IActiveScriptHostEncode_Value;
pub const IActiveScriptHostEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeScriptHostFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptHostEncode,
                bstrInFile: ?BSTR,
                pbstrOutFile: ?*?BSTR,
                cFlags: u32,
                bstrDefaultLang: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptHostEncode,
                bstrInFile: ?BSTR,
                pbstrOutFile: ?*?BSTR,
                cFlags: u32,
                bstrDefaultLang: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptHostEncode_EncodeScriptHostFile(self: *const T, bstrInFile: ?BSTR, pbstrOutFile: ?*?BSTR, cFlags: u32, bstrDefaultLang: ?BSTR) HRESULT {
                return @as(*const IActiveScriptHostEncode.VTable, @ptrCast(self.vtable)).EncodeScriptHostFile(@as(*const IActiveScriptHostEncode, @ptrCast(self)), bstrInFile, pbstrOutFile, cFlags, bstrDefaultLang);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindEventHandler_Value = Guid.initString("63cdbcb0-c1b1-11d0-9336-00a0c90dcaa9");
pub const IID_IBindEventHandler = &IID_IBindEventHandler_Value;
pub const IBindEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IBindEventHandler,
                pstrEvent: ?[*:0]const u16,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IBindEventHandler,
                pstrEvent: ?[*:0]const u16,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IBindEventHandler_BindHandler(self: *const T, pstrEvent: ?[*:0]const u16, pdisp: ?*IDispatch) HRESULT {
                return @as(*const IBindEventHandler.VTable, @ptrCast(self.vtable)).BindHandler(@as(*const IBindEventHandler, @ptrCast(self)), pstrEvent, pdisp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStats_Value = Guid.initString("b8da6310-e19b-11d0-933c-00a0c90dcaa9");
pub const IID_IActiveScriptStats = &IID_IActiveScriptStats_Value;
pub const IActiveScriptStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStat: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptStats,
                stid: u32,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptStats,
                stid: u32,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptStats,
                guid: ?*const Guid,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptStats,
                guid: ?*const Guid,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptStats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptStats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptStats_GetStat(self: *const T, stid: u32, pluHi: ?*u32, pluLo: ?*u32) HRESULT {
                return @as(*const IActiveScriptStats.VTable, @ptrCast(self.vtable)).GetStat(@as(*const IActiveScriptStats, @ptrCast(self)), stid, pluHi, pluLo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptStats_GetStatEx(self: *const T, guid: ?*const Guid, pluHi: ?*u32, pluLo: ?*u32) HRESULT {
                return @as(*const IActiveScriptStats.VTable, @ptrCast(self.vtable)).GetStatEx(@as(*const IActiveScriptStats, @ptrCast(self)), guid, pluHi, pluLo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptStats_ResetStats(self: *const T) HRESULT {
                return @as(*const IActiveScriptStats.VTable, @ptrCast(self.vtable)).ResetStats(@as(*const IActiveScriptStats, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProperty_Value = Guid.initString("4954e0d0-fbc7-11d1-8410-006008c3fbfc");
pub const IID_IActiveScriptProperty = &IID_IActiveScriptProperty_Value;
pub const IActiveScriptProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProperty_GetProperty(self: *const T, dwProperty: u32, pvarIndex: ?*VARIANT, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const IActiveScriptProperty.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IActiveScriptProperty, @ptrCast(self)), dwProperty, pvarIndex, pvarValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProperty_SetProperty(self: *const T, dwProperty: u32, pvarIndex: ?*VARIANT, pvarValue: ?*VARIANT) HRESULT {
                return @as(*const IActiveScriptProperty.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IActiveScriptProperty, @ptrCast(self)), dwProperty, pvarIndex, pvarValue);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ITridentEventSink_Value = Guid.initString("1dc9ca50-06ef-11d2-8415-006008c3fbfc");
pub const IID_ITridentEventSink = &IID_ITridentEventSink_Value;
pub const ITridentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ITridentEventSink,
                pstrEvent: ?[*:0]const u16,
                pdp: ?*DISPPARAMS,
                pvarRes: ?*VARIANT,
                pei: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ITridentEventSink,
                pstrEvent: ?[*:0]const u16,
                pdp: ?*DISPPARAMS,
                pvarRes: ?*VARIANT,
                pei: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ITridentEventSink_FireEvent(self: *const T, pstrEvent: ?[*:0]const u16, pdp: ?*DISPPARAMS, pvarRes: ?*VARIANT, pei: ?*EXCEPINFO) HRESULT {
                return @as(*const ITridentEventSink.VTable, @ptrCast(self.vtable)).FireEvent(@as(*const ITridentEventSink, @ptrCast(self)), pstrEvent, pdp, pvarRes, pei);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptGarbageCollector_Value = Guid.initString("6aa2c4a0-2b53-11d4-a2a0-00104bd35090");
pub const IID_IActiveScriptGarbageCollector = &IID_IActiveScriptGarbageCollector_Value;
pub const IActiveScriptGarbageCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CollectGarbage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptGarbageCollector,
                scriptgctype: SCRIPTGCTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptGarbageCollector,
                scriptgctype: SCRIPTGCTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptGarbageCollector_CollectGarbage(self: *const T, scriptgctype: SCRIPTGCTYPE) HRESULT {
                return @as(*const IActiveScriptGarbageCollector.VTable, @ptrCast(self.vtable)).CollectGarbage(@as(*const IActiveScriptGarbageCollector, @ptrCast(self)), scriptgctype);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSIPInfo_Value = Guid.initString("764651d0-38de-11d4-a2a3-00104bd35090");
pub const IID_IActiveScriptSIPInfo = &IID_IActiveScriptSIPInfo_Value;
pub const IActiveScriptSIPInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSIPOID: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSIPInfo,
                poid_sip: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSIPInfo,
                poid_sip: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSIPInfo_GetSIPOID(self: *const T, poid_sip: ?*Guid) HRESULT {
                return @as(*const IActiveScriptSIPInfo.VTable, @ptrCast(self.vtable)).GetSIPOID(@as(*const IActiveScriptSIPInfo, @ptrCast(self)), poid_sip);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteTraceInfo_Value = Guid.initString("4b7272ae-1955-4bfe-98b0-780621888569");
pub const IID_IActiveScriptSiteTraceInfo = &IID_IActiveScriptSiteTraceInfo_Value;
pub const IActiveScriptSiteTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendScriptTraceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteTraceInfo,
                stiEventType: SCRIPTTRACEINFO,
                guidContextID: Guid,
                dwScriptContextCookie: u32,
                lScriptStatementStart: i32,
                lScriptStatementEnd: i32,
                dwReserved: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteTraceInfo,
                stiEventType: SCRIPTTRACEINFO,
                guidContextID: Guid,
                dwScriptContextCookie: u32,
                lScriptStatementStart: i32,
                lScriptStatementEnd: i32,
                dwReserved: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteTraceInfo_SendScriptTraceInfo(self: *const T, stiEventType: SCRIPTTRACEINFO, guidContextID: Guid, dwScriptContextCookie: u32, lScriptStatementStart: i32, lScriptStatementEnd: i32, dwReserved: u64) HRESULT {
                return @as(*const IActiveScriptSiteTraceInfo.VTable, @ptrCast(self.vtable)).SendScriptTraceInfo(@as(*const IActiveScriptSiteTraceInfo, @ptrCast(self)), stiEventType, guidContextID, dwScriptContextCookie, lScriptStatementStart, lScriptStatementEnd, dwReserved);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptTraceInfo_Value = Guid.initString("c35456e7-bebf-4a1b-86a9-24d56be8b369");
pub const IID_IActiveScriptTraceInfo = &IID_IActiveScriptTraceInfo_Value;
pub const IActiveScriptTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartScriptTracing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptTraceInfo,
                pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo,
                guidContextID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptTraceInfo,
                pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo,
                guidContextID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopScriptTracing: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptTraceInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptTraceInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptTraceInfo_StartScriptTracing(self: *const T, pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo, guidContextID: Guid) HRESULT {
                return @as(*const IActiveScriptTraceInfo.VTable, @ptrCast(self.vtable)).StartScriptTracing(@as(*const IActiveScriptTraceInfo, @ptrCast(self)), pSiteTraceInfo, guidContextID);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptTraceInfo_StopScriptTracing(self: *const T) HRESULT {
                return @as(*const IActiveScriptTraceInfo.VTable, @ptrCast(self.vtable)).StopScriptTracing(@as(*const IActiveScriptTraceInfo, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStringCompare_Value = Guid.initString("58562769-ed52-42f7-8403-4963514e1f11");
pub const IID_IActiveScriptStringCompare = &IID_IActiveScriptStringCompare_Value;
pub const IActiveScriptStringCompare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StrComp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptStringCompare,
                bszStr1: ?BSTR,
                bszStr2: ?BSTR,
                iRet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptStringCompare,
                bszStr1: ?BSTR,
                bszStr2: ?BSTR,
                iRet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptStringCompare_StrComp(self: *const T, bszStr1: ?BSTR, bszStr2: ?BSTR, iRet: ?*i32) HRESULT {
                return @as(*const IActiveScriptStringCompare.VTable, @ptrCast(self.vtable)).StrComp(@as(*const IActiveScriptStringCompare, @ptrCast(self)), bszStr1, bszStr2, iRet);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DBGPROP_ATTRIB_FLAGS = enum(u32) {
    NO_ATTRIB = 0,
    VALUE_IS_INVALID = 8,
    VALUE_IS_EXPANDABLE = 16,
    VALUE_IS_FAKE = 32,
    VALUE_IS_METHOD = 256,
    VALUE_IS_EVENT = 512,
    VALUE_IS_RAW_STRING = 1024,
    VALUE_READONLY = 2048,
    ACCESS_PUBLIC = 4096,
    ACCESS_PRIVATE = 8192,
    ACCESS_PROTECTED = 16384,
    ACCESS_FINAL = 32768,
    STORAGE_GLOBAL = 65536,
    STORAGE_STATIC = 131072,
    STORAGE_FIELD = 262144,
    STORAGE_VIRTUAL = 524288,
    TYPE_IS_CONSTANT = 1048576,
    TYPE_IS_SYNCHRONIZED = 2097152,
    TYPE_IS_VOLATILE = 4194304,
    HAS_EXTENDED_ATTRIBS = 8388608,
    FRAME_INTRYBLOCK = 16777216,
    FRAME_INCATCHBLOCK = 33554432,
    FRAME_INFINALLYBLOCK = 67108864,
    VALUE_IS_RETURN_VALUE = 134217728,
    VALUE_PENDING_MUTATION = 268435456,
    _,
    pub fn initFlags(o: struct {
        NO_ATTRIB: u1 = 0,
        VALUE_IS_INVALID: u1 = 0,
        VALUE_IS_EXPANDABLE: u1 = 0,
        VALUE_IS_FAKE: u1 = 0,
        VALUE_IS_METHOD: u1 = 0,
        VALUE_IS_EVENT: u1 = 0,
        VALUE_IS_RAW_STRING: u1 = 0,
        VALUE_READONLY: u1 = 0,
        ACCESS_PUBLIC: u1 = 0,
        ACCESS_PRIVATE: u1 = 0,
        ACCESS_PROTECTED: u1 = 0,
        ACCESS_FINAL: u1 = 0,
        STORAGE_GLOBAL: u1 = 0,
        STORAGE_STATIC: u1 = 0,
        STORAGE_FIELD: u1 = 0,
        STORAGE_VIRTUAL: u1 = 0,
        TYPE_IS_CONSTANT: u1 = 0,
        TYPE_IS_SYNCHRONIZED: u1 = 0,
        TYPE_IS_VOLATILE: u1 = 0,
        HAS_EXTENDED_ATTRIBS: u1 = 0,
        FRAME_INTRYBLOCK: u1 = 0,
        FRAME_INCATCHBLOCK: u1 = 0,
        FRAME_INFINALLYBLOCK: u1 = 0,
        VALUE_IS_RETURN_VALUE: u1 = 0,
        VALUE_PENDING_MUTATION: u1 = 0,
    }) DBGPROP_ATTRIB_FLAGS {
        return @as(DBGPROP_ATTRIB_FLAGS, @enumFromInt((if (o.NO_ATTRIB == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.NO_ATTRIB) else 0) | (if (o.VALUE_IS_INVALID == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_INVALID) else 0) | (if (o.VALUE_IS_EXPANDABLE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_EXPANDABLE) else 0) | (if (o.VALUE_IS_FAKE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_FAKE) else 0) | (if (o.VALUE_IS_METHOD == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_METHOD) else 0) | (if (o.VALUE_IS_EVENT == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_EVENT) else 0) | (if (o.VALUE_IS_RAW_STRING == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_RAW_STRING) else 0) | (if (o.VALUE_READONLY == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_READONLY) else 0) | (if (o.ACCESS_PUBLIC == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_PUBLIC) else 0) | (if (o.ACCESS_PRIVATE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_PRIVATE) else 0) | (if (o.ACCESS_PROTECTED == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_PROTECTED) else 0) | (if (o.ACCESS_FINAL == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_FINAL) else 0) | (if (o.STORAGE_GLOBAL == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_GLOBAL) else 0) | (if (o.STORAGE_STATIC == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_STATIC) else 0) | (if (o.STORAGE_FIELD == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_FIELD) else 0) | (if (o.STORAGE_VIRTUAL == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_VIRTUAL) else 0) | (if (o.TYPE_IS_CONSTANT == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.TYPE_IS_CONSTANT) else 0) | (if (o.TYPE_IS_SYNCHRONIZED == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED) else 0) | (if (o.TYPE_IS_VOLATILE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.TYPE_IS_VOLATILE) else 0) | (if (o.HAS_EXTENDED_ATTRIBS == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS) else 0) | (if (o.FRAME_INTRYBLOCK == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.FRAME_INTRYBLOCK) else 0) | (if (o.FRAME_INCATCHBLOCK == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.FRAME_INCATCHBLOCK) else 0) | (if (o.FRAME_INFINALLYBLOCK == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.FRAME_INFINALLYBLOCK) else 0) | (if (o.VALUE_IS_RETURN_VALUE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_RETURN_VALUE) else 0) | (if (o.VALUE_PENDING_MUTATION == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_PENDING_MUTATION) else 0)));
    }
};
pub const DBGPROP_ATTRIB_NO_ATTRIB = DBGPROP_ATTRIB_FLAGS.NO_ATTRIB;
pub const DBGPROP_ATTRIB_VALUE_IS_INVALID = DBGPROP_ATTRIB_FLAGS.VALUE_IS_INVALID;
pub const DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_EXPANDABLE;
pub const DBGPROP_ATTRIB_VALUE_IS_FAKE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_FAKE;
pub const DBGPROP_ATTRIB_VALUE_IS_METHOD = DBGPROP_ATTRIB_FLAGS.VALUE_IS_METHOD;
pub const DBGPROP_ATTRIB_VALUE_IS_EVENT = DBGPROP_ATTRIB_FLAGS.VALUE_IS_EVENT;
pub const DBGPROP_ATTRIB_VALUE_IS_RAW_STRING = DBGPROP_ATTRIB_FLAGS.VALUE_IS_RAW_STRING;
pub const DBGPROP_ATTRIB_VALUE_READONLY = DBGPROP_ATTRIB_FLAGS.VALUE_READONLY;
pub const DBGPROP_ATTRIB_ACCESS_PUBLIC = DBGPROP_ATTRIB_FLAGS.ACCESS_PUBLIC;
pub const DBGPROP_ATTRIB_ACCESS_PRIVATE = DBGPROP_ATTRIB_FLAGS.ACCESS_PRIVATE;
pub const DBGPROP_ATTRIB_ACCESS_PROTECTED = DBGPROP_ATTRIB_FLAGS.ACCESS_PROTECTED;
pub const DBGPROP_ATTRIB_ACCESS_FINAL = DBGPROP_ATTRIB_FLAGS.ACCESS_FINAL;
pub const DBGPROP_ATTRIB_STORAGE_GLOBAL = DBGPROP_ATTRIB_FLAGS.STORAGE_GLOBAL;
pub const DBGPROP_ATTRIB_STORAGE_STATIC = DBGPROP_ATTRIB_FLAGS.STORAGE_STATIC;
pub const DBGPROP_ATTRIB_STORAGE_FIELD = DBGPROP_ATTRIB_FLAGS.STORAGE_FIELD;
pub const DBGPROP_ATTRIB_STORAGE_VIRTUAL = DBGPROP_ATTRIB_FLAGS.STORAGE_VIRTUAL;
pub const DBGPROP_ATTRIB_TYPE_IS_CONSTANT = DBGPROP_ATTRIB_FLAGS.TYPE_IS_CONSTANT;
pub const DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED = DBGPROP_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED;
pub const DBGPROP_ATTRIB_TYPE_IS_VOLATILE = DBGPROP_ATTRIB_FLAGS.TYPE_IS_VOLATILE;
pub const DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS = DBGPROP_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS;
pub const DBGPROP_ATTRIB_FRAME_INTRYBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INTRYBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INCATCHBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INCATCHBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INFINALLYBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INFINALLYBLOCK;
pub const DBGPROP_ATTRIB_VALUE_IS_RETURN_VALUE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_RETURN_VALUE;
pub const DBGPROP_ATTRIB_VALUE_PENDING_MUTATION = DBGPROP_ATTRIB_FLAGS.VALUE_PENDING_MUTATION;

pub const DBGPROP_INFO = enum(u32) {
    NAME = 1,
    TYPE = 2,
    VALUE = 4,
    FULLNAME = 32,
    ATTRIBUTES = 8,
    DEBUGPROP = 16,
    BEAUTIFY = 33554432,
    CALLTOSTRING = 67108864,
    AUTOEXPAND = 134217728,
    _,
    pub fn initFlags(o: struct {
        NAME: u1 = 0,
        TYPE: u1 = 0,
        VALUE: u1 = 0,
        FULLNAME: u1 = 0,
        ATTRIBUTES: u1 = 0,
        DEBUGPROP: u1 = 0,
        BEAUTIFY: u1 = 0,
        CALLTOSTRING: u1 = 0,
        AUTOEXPAND: u1 = 0,
    }) DBGPROP_INFO {
        return @as(DBGPROP_INFO, @enumFromInt((if (o.NAME == 1) @intFromEnum(DBGPROP_INFO.NAME) else 0) | (if (o.TYPE == 1) @intFromEnum(DBGPROP_INFO.TYPE) else 0) | (if (o.VALUE == 1) @intFromEnum(DBGPROP_INFO.VALUE) else 0) | (if (o.FULLNAME == 1) @intFromEnum(DBGPROP_INFO.FULLNAME) else 0) | (if (o.ATTRIBUTES == 1) @intFromEnum(DBGPROP_INFO.ATTRIBUTES) else 0) | (if (o.DEBUGPROP == 1) @intFromEnum(DBGPROP_INFO.DEBUGPROP) else 0) | (if (o.BEAUTIFY == 1) @intFromEnum(DBGPROP_INFO.BEAUTIFY) else 0) | (if (o.CALLTOSTRING == 1) @intFromEnum(DBGPROP_INFO.CALLTOSTRING) else 0) | (if (o.AUTOEXPAND == 1) @intFromEnum(DBGPROP_INFO.AUTOEXPAND) else 0)));
    }
};
pub const DBGPROP_INFO_NAME = DBGPROP_INFO.NAME;
pub const DBGPROP_INFO_TYPE = DBGPROP_INFO.TYPE;
pub const DBGPROP_INFO_VALUE = DBGPROP_INFO.VALUE;
pub const DBGPROP_INFO_FULLNAME = DBGPROP_INFO.FULLNAME;
pub const DBGPROP_INFO_ATTRIBUTES = DBGPROP_INFO.ATTRIBUTES;
pub const DBGPROP_INFO_DEBUGPROP = DBGPROP_INFO.DEBUGPROP;
pub const DBGPROP_INFO_BEAUTIFY = DBGPROP_INFO.BEAUTIFY;
pub const DBGPROP_INFO_CALLTOSTRING = DBGPROP_INFO.CALLTOSTRING;
pub const DBGPROP_INFO_AUTOEXPAND = DBGPROP_INFO.AUTOEXPAND;

pub const OBJECT_ATTRIB_FLAG = enum(u32) {
    NO_ATTRIB = 0,
    NO_NAME = 1,
    NO_TYPE = 2,
    NO_VALUE = 4,
    VALUE_IS_INVALID = 8,
    VALUE_IS_OBJECT = 16,
    VALUE_IS_ENUM = 32,
    VALUE_IS_CUSTOM = 64,
    OBJECT_IS_EXPANDABLE = 112,
    VALUE_HAS_CODE = 128,
    TYPE_IS_OBJECT = 256,
    TYPE_HAS_CODE = 512,
    // TYPE_IS_EXPANDABLE = 256, this enum value conflicts with TYPE_IS_OBJECT
    SLOT_IS_CATEGORY = 1024,
    VALUE_READONLY = 2048,
    ACCESS_PUBLIC = 4096,
    ACCESS_PRIVATE = 8192,
    ACCESS_PROTECTED = 16384,
    ACCESS_FINAL = 32768,
    STORAGE_GLOBAL = 65536,
    STORAGE_STATIC = 131072,
    STORAGE_FIELD = 262144,
    STORAGE_VIRTUAL = 524288,
    TYPE_IS_CONSTANT = 1048576,
    TYPE_IS_SYNCHRONIZED = 2097152,
    TYPE_IS_VOLATILE = 4194304,
    HAS_EXTENDED_ATTRIBS = 8388608,
    IS_CLASS = 16777216,
    IS_FUNCTION = 33554432,
    IS_VARIABLE = 67108864,
    IS_PROPERTY = 134217728,
    IS_MACRO = 268435456,
    IS_TYPE = 536870912,
    IS_INHERITED = 1073741824,
    IS_INTERFACE = 2147483648,
    _,
    pub fn initFlags(o: struct {
        NO_ATTRIB: u1 = 0,
        NO_NAME: u1 = 0,
        NO_TYPE: u1 = 0,
        NO_VALUE: u1 = 0,
        VALUE_IS_INVALID: u1 = 0,
        VALUE_IS_OBJECT: u1 = 0,
        VALUE_IS_ENUM: u1 = 0,
        VALUE_IS_CUSTOM: u1 = 0,
        OBJECT_IS_EXPANDABLE: u1 = 0,
        VALUE_HAS_CODE: u1 = 0,
        TYPE_IS_OBJECT: u1 = 0,
        TYPE_HAS_CODE: u1 = 0,
        SLOT_IS_CATEGORY: u1 = 0,
        VALUE_READONLY: u1 = 0,
        ACCESS_PUBLIC: u1 = 0,
        ACCESS_PRIVATE: u1 = 0,
        ACCESS_PROTECTED: u1 = 0,
        ACCESS_FINAL: u1 = 0,
        STORAGE_GLOBAL: u1 = 0,
        STORAGE_STATIC: u1 = 0,
        STORAGE_FIELD: u1 = 0,
        STORAGE_VIRTUAL: u1 = 0,
        TYPE_IS_CONSTANT: u1 = 0,
        TYPE_IS_SYNCHRONIZED: u1 = 0,
        TYPE_IS_VOLATILE: u1 = 0,
        HAS_EXTENDED_ATTRIBS: u1 = 0,
        IS_CLASS: u1 = 0,
        IS_FUNCTION: u1 = 0,
        IS_VARIABLE: u1 = 0,
        IS_PROPERTY: u1 = 0,
        IS_MACRO: u1 = 0,
        IS_TYPE: u1 = 0,
        IS_INHERITED: u1 = 0,
        IS_INTERFACE: u1 = 0,
    }) OBJECT_ATTRIB_FLAG {
        return @as(OBJECT_ATTRIB_FLAG, @enumFromInt((if (o.NO_ATTRIB == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.NO_ATTRIB) else 0) | (if (o.NO_NAME == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.NO_NAME) else 0) | (if (o.NO_TYPE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.NO_TYPE) else 0) | (if (o.NO_VALUE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.NO_VALUE) else 0) | (if (o.VALUE_IS_INVALID == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.VALUE_IS_INVALID) else 0) | (if (o.VALUE_IS_OBJECT == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.VALUE_IS_OBJECT) else 0) | (if (o.VALUE_IS_ENUM == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.VALUE_IS_ENUM) else 0) | (if (o.VALUE_IS_CUSTOM == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.VALUE_IS_CUSTOM) else 0) | (if (o.OBJECT_IS_EXPANDABLE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.OBJECT_IS_EXPANDABLE) else 0) | (if (o.VALUE_HAS_CODE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.VALUE_HAS_CODE) else 0) | (if (o.TYPE_IS_OBJECT == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.TYPE_IS_OBJECT) else 0) | (if (o.TYPE_HAS_CODE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.TYPE_HAS_CODE) else 0) | (if (o.SLOT_IS_CATEGORY == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.SLOT_IS_CATEGORY) else 0) | (if (o.VALUE_READONLY == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.VALUE_READONLY) else 0) | (if (o.ACCESS_PUBLIC == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.ACCESS_PUBLIC) else 0) | (if (o.ACCESS_PRIVATE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.ACCESS_PRIVATE) else 0) | (if (o.ACCESS_PROTECTED == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.ACCESS_PROTECTED) else 0) | (if (o.ACCESS_FINAL == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.ACCESS_FINAL) else 0) | (if (o.STORAGE_GLOBAL == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.STORAGE_GLOBAL) else 0) | (if (o.STORAGE_STATIC == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.STORAGE_STATIC) else 0) | (if (o.STORAGE_FIELD == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.STORAGE_FIELD) else 0) | (if (o.STORAGE_VIRTUAL == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.STORAGE_VIRTUAL) else 0) | (if (o.TYPE_IS_CONSTANT == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.TYPE_IS_CONSTANT) else 0) | (if (o.TYPE_IS_SYNCHRONIZED == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.TYPE_IS_SYNCHRONIZED) else 0) | (if (o.TYPE_IS_VOLATILE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.TYPE_IS_VOLATILE) else 0) | (if (o.HAS_EXTENDED_ATTRIBS == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.HAS_EXTENDED_ATTRIBS) else 0) | (if (o.IS_CLASS == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_CLASS) else 0) | (if (o.IS_FUNCTION == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_FUNCTION) else 0) | (if (o.IS_VARIABLE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_VARIABLE) else 0) | (if (o.IS_PROPERTY == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_PROPERTY) else 0) | (if (o.IS_MACRO == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_MACRO) else 0) | (if (o.IS_TYPE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_TYPE) else 0) | (if (o.IS_INHERITED == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_INHERITED) else 0) | (if (o.IS_INTERFACE == 1) @intFromEnum(OBJECT_ATTRIB_FLAG.IS_INTERFACE) else 0)));
    }
};
pub const OBJECT_ATTRIB_NO_ATTRIB = OBJECT_ATTRIB_FLAG.NO_ATTRIB;
pub const OBJECT_ATTRIB_NO_NAME = OBJECT_ATTRIB_FLAG.NO_NAME;
pub const OBJECT_ATTRIB_NO_TYPE = OBJECT_ATTRIB_FLAG.NO_TYPE;
pub const OBJECT_ATTRIB_NO_VALUE = OBJECT_ATTRIB_FLAG.NO_VALUE;
pub const OBJECT_ATTRIB_VALUE_IS_INVALID = OBJECT_ATTRIB_FLAG.VALUE_IS_INVALID;
pub const OBJECT_ATTRIB_VALUE_IS_OBJECT = OBJECT_ATTRIB_FLAG.VALUE_IS_OBJECT;
pub const OBJECT_ATTRIB_VALUE_IS_ENUM = OBJECT_ATTRIB_FLAG.VALUE_IS_ENUM;
pub const OBJECT_ATTRIB_VALUE_IS_CUSTOM = OBJECT_ATTRIB_FLAG.VALUE_IS_CUSTOM;
pub const OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE = OBJECT_ATTRIB_FLAG.OBJECT_IS_EXPANDABLE;
pub const OBJECT_ATTRIB_VALUE_HAS_CODE = OBJECT_ATTRIB_FLAG.VALUE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_OBJECT = OBJECT_ATTRIB_FLAG.TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_TYPE_HAS_CODE = OBJECT_ATTRIB_FLAG.TYPE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_EXPANDABLE = OBJECT_ATTRIB_FLAG.TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_SLOT_IS_CATEGORY = OBJECT_ATTRIB_FLAG.SLOT_IS_CATEGORY;
pub const OBJECT_ATTRIB_VALUE_READONLY = OBJECT_ATTRIB_FLAG.VALUE_READONLY;
pub const OBJECT_ATTRIB_ACCESS_PUBLIC = OBJECT_ATTRIB_FLAG.ACCESS_PUBLIC;
pub const OBJECT_ATTRIB_ACCESS_PRIVATE = OBJECT_ATTRIB_FLAG.ACCESS_PRIVATE;
pub const OBJECT_ATTRIB_ACCESS_PROTECTED = OBJECT_ATTRIB_FLAG.ACCESS_PROTECTED;
pub const OBJECT_ATTRIB_ACCESS_FINAL = OBJECT_ATTRIB_FLAG.ACCESS_FINAL;
pub const OBJECT_ATTRIB_STORAGE_GLOBAL = OBJECT_ATTRIB_FLAG.STORAGE_GLOBAL;
pub const OBJECT_ATTRIB_STORAGE_STATIC = OBJECT_ATTRIB_FLAG.STORAGE_STATIC;
pub const OBJECT_ATTRIB_STORAGE_FIELD = OBJECT_ATTRIB_FLAG.STORAGE_FIELD;
pub const OBJECT_ATTRIB_STORAGE_VIRTUAL = OBJECT_ATTRIB_FLAG.STORAGE_VIRTUAL;
pub const OBJECT_ATTRIB_TYPE_IS_CONSTANT = OBJECT_ATTRIB_FLAG.TYPE_IS_CONSTANT;
pub const OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED = OBJECT_ATTRIB_FLAG.TYPE_IS_SYNCHRONIZED;
pub const OBJECT_ATTRIB_TYPE_IS_VOLATILE = OBJECT_ATTRIB_FLAG.TYPE_IS_VOLATILE;
pub const OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS = OBJECT_ATTRIB_FLAG.HAS_EXTENDED_ATTRIBS;
pub const OBJECT_ATTRIB_IS_CLASS = OBJECT_ATTRIB_FLAG.IS_CLASS;
pub const OBJECT_ATTRIB_IS_FUNCTION = OBJECT_ATTRIB_FLAG.IS_FUNCTION;
pub const OBJECT_ATTRIB_IS_VARIABLE = OBJECT_ATTRIB_FLAG.IS_VARIABLE;
pub const OBJECT_ATTRIB_IS_PROPERTY = OBJECT_ATTRIB_FLAG.IS_PROPERTY;
pub const OBJECT_ATTRIB_IS_MACRO = OBJECT_ATTRIB_FLAG.IS_MACRO;
pub const OBJECT_ATTRIB_IS_TYPE = OBJECT_ATTRIB_FLAG.IS_TYPE;
pub const OBJECT_ATTRIB_IS_INHERITED = OBJECT_ATTRIB_FLAG.IS_INHERITED;
pub const OBJECT_ATTRIB_IS_INTERFACE = OBJECT_ATTRIB_FLAG.IS_INTERFACE;

pub const PROP_INFO_FLAGS = enum(i32) {
    NAME = 1,
    TYPE = 2,
    VALUE = 4,
    FULLNAME = 32,
    ATTRIBUTES = 8,
    DEBUGPROP = 16,
    AUTOEXPAND = 134217728,
};
pub const PROP_INFO_NAME = PROP_INFO_FLAGS.NAME;
pub const PROP_INFO_TYPE = PROP_INFO_FLAGS.TYPE;
pub const PROP_INFO_VALUE = PROP_INFO_FLAGS.VALUE;
pub const PROP_INFO_FULLNAME = PROP_INFO_FLAGS.FULLNAME;
pub const PROP_INFO_ATTRIBUTES = PROP_INFO_FLAGS.ATTRIBUTES;
pub const PROP_INFO_DEBUGPROP = PROP_INFO_FLAGS.DEBUGPROP;
pub const PROP_INFO_AUTOEXPAND = PROP_INFO_FLAGS.AUTOEXPAND;

pub const DebugPropertyInfo = extern struct {
    m_dwValidFields: u32,
    m_bstrName: ?BSTR,
    m_bstrType: ?BSTR,
    m_bstrValue: ?BSTR,
    m_bstrFullName: ?BSTR,
    m_dwAttrib: u32,
    m_pDebugProp: ?*IDebugProperty,
};

pub const EX_PROP_INFO_FLAGS = enum(i32) {
    ID = 256,
    NTYPE = 512,
    NVALUE = 1024,
    LOCKBYTES = 2048,
    DEBUGEXTPROP = 4096,
};
pub const EX_PROP_INFO_ID = EX_PROP_INFO_FLAGS.ID;
pub const EX_PROP_INFO_NTYPE = EX_PROP_INFO_FLAGS.NTYPE;
pub const EX_PROP_INFO_NVALUE = EX_PROP_INFO_FLAGS.NVALUE;
pub const EX_PROP_INFO_LOCKBYTES = EX_PROP_INFO_FLAGS.LOCKBYTES;
pub const EX_PROP_INFO_DEBUGEXTPROP = EX_PROP_INFO_FLAGS.DEBUGEXTPROP;

pub const ExtendedDebugPropertyInfo = extern struct {
    dwValidFields: u32,
    pszName: ?PWSTR,
    pszType: ?PWSTR,
    pszValue: ?PWSTR,
    pszFullName: ?PWSTR,
    dwAttrib: u32,
    pDebugProp: ?*IDebugProperty,
    nDISPID: u32,
    nType: u32,
    varValue: VARIANT,
    plbValue: ?*ILockBytes,
    pDebugExtProp: ?*IDebugExtendedProperty,
};

const IID_IDebugProperty_Value = Guid.initString("51973c50-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugProperty = &IID_IDebugProperty_Value;
pub const IDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pPropertyInfo: ?*DebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pPropertyInfo: ?*DebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtendedInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugProperty,
                cInfos: u32,
                rgguidExtendedInfo: [*]Guid,
                rgvar: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugProperty,
                cInfos: u32,
                rgguidExtendedInfo: [*]Guid,
                rgvar: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValueAsString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugProperty,
                pszValue: ?[*:0]const u16,
                nRadix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugProperty,
                pszValue: ?[*:0]const u16,
                nRadix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                refiid: ?*const Guid,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                refiid: ?*const Guid,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugProperty,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugProperty,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugProperty_GetPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pPropertyInfo: ?*DebugPropertyInfo) HRESULT {
                return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IDebugProperty, @ptrCast(self)), dwFieldSpec, nRadix, pPropertyInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugProperty_GetExtendedInfo(self: *const T, cInfos: u32, rgguidExtendedInfo: [*]Guid, rgvar: [*]VARIANT) HRESULT {
                return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).GetExtendedInfo(@as(*const IDebugProperty, @ptrCast(self)), cInfos, rgguidExtendedInfo, rgvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugProperty_SetValueAsString(self: *const T, pszValue: ?[*:0]const u16, nRadix: u32) HRESULT {
                return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).SetValueAsString(@as(*const IDebugProperty, @ptrCast(self)), pszValue, nRadix);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugProperty_EnumMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, refiid: ?*const Guid, ppepi: ?*?*IEnumDebugPropertyInfo) HRESULT {
                return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).EnumMembers(@as(*const IDebugProperty, @ptrCast(self)), dwFieldSpec, nRadix, refiid, ppepi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugProperty_GetParent(self: *const T, ppDebugProp: ?*?*IDebugProperty) HRESULT {
                return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IDebugProperty, @ptrCast(self)), ppDebugProp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugPropertyInfo_Value = Guid.initString("51973c51-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugPropertyInfo = &IID_IEnumDebugPropertyInfo_Value;
pub const IEnumDebugPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
                pi: [*]DebugPropertyInfo,
                pcEltsfetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
                pi: [*]DebugPropertyInfo,
                pcEltsfetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugPropertyInfo,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugPropertyInfo,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugPropertyInfo_Next(self: *const T, celt: u32, pi: [*]DebugPropertyInfo, pcEltsfetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), celt, pi, pcEltsfetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugPropertyInfo_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugPropertyInfo_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugPropertyInfo_Clone(self: *const T, ppepi: ?*?*IEnumDebugPropertyInfo) HRESULT {
                return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), ppepi);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugPropertyInfo_GetCount(self: *const T, pcelt: ?*u32) HRESULT {
                return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), pcelt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExtendedProperty_Value = Guid.initString("51973c52-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExtendedProperty = &IID_IDebugExtendedProperty_Value;
pub const IDebugExtendedProperty = extern struct {
    pub const VTable = extern struct {
        base: IDebugProperty.VTable,
        GetExtendedPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumExtendedMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                ppeepi: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                ppeepi: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugProperty.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExtendedProperty_GetExtendedPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo) HRESULT {
                return @as(*const IDebugExtendedProperty.VTable, @ptrCast(self.vtable)).GetExtendedPropertyInfo(@as(*const IDebugExtendedProperty, @ptrCast(self)), dwFieldSpec, nRadix, pExtendedPropertyInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExtendedProperty_EnumExtendedMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, ppeepi: ?*?*IEnumDebugExtendedPropertyInfo) HRESULT {
                return @as(*const IDebugExtendedProperty.VTable, @ptrCast(self.vtable)).EnumExtendedMembers(@as(*const IDebugExtendedProperty, @ptrCast(self)), dwFieldSpec, nRadix, ppeepi);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExtendedPropertyInfo_Value = Guid.initString("51973c53-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugExtendedPropertyInfo = &IID_IEnumDebugExtendedPropertyInfo_Value;
pub const IEnumDebugExtendedPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
                rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
                rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                pedpe: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                pedpe: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExtendedPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExtendedPropertyInfo_Next(self: *const T, celt: u32, rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), celt, rgExtendedPropertyInfo, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExtendedPropertyInfo_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExtendedPropertyInfo_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExtendedPropertyInfo_Clone(self: *const T, pedpe: ?*?*IEnumDebugExtendedPropertyInfo) HRESULT {
                return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), pedpe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExtendedPropertyInfo_GetCount(self: *const T, pcelt: ?*u32) HRESULT {
                return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), pcelt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IPerPropertyBrowsing2_Value = Guid.initString("51973c54-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IPerPropertyBrowsing2 = &IID_IPerPropertyBrowsing2_Value;
pub const IPerPropertyBrowsing2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapPropertyToPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pClsidPropPage: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pClsidPropPage: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPredefinedStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pCaStrings: ?*CALPOLESTR,
                pCaCookies: ?*CADWORD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pCaStrings: ?*CALPOLESTR,
                pCaCookies: ?*CADWORD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPredefinedValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing2_GetDisplayString(self: *const T, dispid: i32, pBstr: ?*?BSTR) HRESULT {
                return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).GetDisplayString(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, pBstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing2_MapPropertyToPage(self: *const T, dispid: i32, pClsidPropPage: ?*Guid) HRESULT {
                return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).MapPropertyToPage(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, pClsidPropPage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing2_GetPredefinedStrings(self: *const T, dispid: i32, pCaStrings: ?*CALPOLESTR, pCaCookies: ?*CADWORD) HRESULT {
                return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).GetPredefinedStrings(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, pCaStrings, pCaCookies);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IPerPropertyBrowsing2_SetPredefinedValue(self: *const T, dispid: i32, dwCookie: u32) HRESULT {
                return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).SetPredefinedValue(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_All_Value = Guid.initString("51973c55-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_All = &IID_IDebugPropertyEnumType_All_Value;
pub const IDebugPropertyEnumType_All = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugPropertyEnumType_All,
                __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugPropertyEnumType_All,
                __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugPropertyEnumType_All_GetName(self: *const T, __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR) HRESULT {
                return @as(*const IDebugPropertyEnumType_All.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDebugPropertyEnumType_All, @ptrCast(self)), __MIDL__IDebugPropertyEnumType_All0000);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Locals_Value = Guid.initString("51973c56-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Locals = &IID_IDebugPropertyEnumType_Locals_Value;
pub const IDebugPropertyEnumType_Locals = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Arguments_Value = Guid.initString("51973c57-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Arguments = &IID_IDebugPropertyEnumType_Arguments_Value;
pub const IDebugPropertyEnumType_Arguments = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_LocalsPlusArgs_Value = Guid.initString("51973c58-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_LocalsPlusArgs = &IID_IDebugPropertyEnumType_LocalsPlusArgs_Value;
pub const IDebugPropertyEnumType_LocalsPlusArgs = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Registers_Value = Guid.initString("51973c59-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Registers = &IID_IDebugPropertyEnumType_Registers_Value;
pub const IDebugPropertyEnumType_Registers = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const BREAKPOINT_STATE = enum(i32) {
    DELETED = 0,
    DISABLED = 1,
    ENABLED = 2,
};
pub const BREAKPOINT_DELETED = BREAKPOINT_STATE.DELETED;
pub const BREAKPOINT_DISABLED = BREAKPOINT_STATE.DISABLED;
pub const BREAKPOINT_ENABLED = BREAKPOINT_STATE.ENABLED;

pub const BREAKREASON = enum(i32) {
    STEP = 0,
    BREAKPOINT = 1,
    DEBUGGER_BLOCK = 2,
    HOST_INITIATED = 3,
    LANGUAGE_INITIATED = 4,
    DEBUGGER_HALT = 5,
    ERROR = 6,
    JIT = 7,
    MUTATION_BREAKPOINT = 8,
};
pub const BREAKREASON_STEP = BREAKREASON.STEP;
pub const BREAKREASON_BREAKPOINT = BREAKREASON.BREAKPOINT;
pub const BREAKREASON_DEBUGGER_BLOCK = BREAKREASON.DEBUGGER_BLOCK;
pub const BREAKREASON_HOST_INITIATED = BREAKREASON.HOST_INITIATED;
pub const BREAKREASON_LANGUAGE_INITIATED = BREAKREASON.LANGUAGE_INITIATED;
pub const BREAKREASON_DEBUGGER_HALT = BREAKREASON.DEBUGGER_HALT;
pub const BREAKREASON_ERROR = BREAKREASON.ERROR;
pub const BREAKREASON_JIT = BREAKREASON.JIT;
pub const BREAKREASON_MUTATION_BREAKPOINT = BREAKREASON.MUTATION_BREAKPOINT;

pub const BREAKRESUME_ACTION = enum(i32) {
    ABORT = 0,
    CONTINUE = 1,
    STEP_INTO = 2,
    STEP_OVER = 3,
    STEP_OUT = 4,
    IGNORE = 5,
    STEP_DOCUMENT = 6,
};
pub const BREAKRESUMEACTION_ABORT = BREAKRESUME_ACTION.ABORT;
pub const BREAKRESUMEACTION_CONTINUE = BREAKRESUME_ACTION.CONTINUE;
pub const BREAKRESUMEACTION_STEP_INTO = BREAKRESUME_ACTION.STEP_INTO;
pub const BREAKRESUMEACTION_STEP_OVER = BREAKRESUME_ACTION.STEP_OVER;
pub const BREAKRESUMEACTION_STEP_OUT = BREAKRESUME_ACTION.STEP_OUT;
pub const BREAKRESUMEACTION_IGNORE = BREAKRESUME_ACTION.IGNORE;
pub const BREAKRESUMEACTION_STEP_DOCUMENT = BREAKRESUME_ACTION.STEP_DOCUMENT;

pub const ERRORRESUMEACTION = enum(i32) {
    ReexecuteErrorStatement = 0,
    AbortCallAndReturnErrorToCaller = 1,
    SkipErrorStatement = 2,
};
pub const ERRORRESUMEACTION_ReexecuteErrorStatement = ERRORRESUMEACTION.ReexecuteErrorStatement;
pub const ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller = ERRORRESUMEACTION.AbortCallAndReturnErrorToCaller;
pub const ERRORRESUMEACTION_SkipErrorStatement = ERRORRESUMEACTION.SkipErrorStatement;

pub const DOCUMENTNAMETYPE = enum(i32) {
    APPNODE = 0,
    TITLE = 1,
    FILE_TAIL = 2,
    URL = 3,
    UNIQUE_TITLE = 4,
    SOURCE_MAP_URL = 5,
};
pub const DOCUMENTNAMETYPE_APPNODE = DOCUMENTNAMETYPE.APPNODE;
pub const DOCUMENTNAMETYPE_TITLE = DOCUMENTNAMETYPE.TITLE;
pub const DOCUMENTNAMETYPE_FILE_TAIL = DOCUMENTNAMETYPE.FILE_TAIL;
pub const DOCUMENTNAMETYPE_URL = DOCUMENTNAMETYPE.URL;
pub const DOCUMENTNAMETYPE_UNIQUE_TITLE = DOCUMENTNAMETYPE.UNIQUE_TITLE;
pub const DOCUMENTNAMETYPE_SOURCE_MAP_URL = DOCUMENTNAMETYPE.SOURCE_MAP_URL;

const IID_IActiveScriptDebug32_Value = Guid.initString("51973c10-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptDebug32 = &IID_IActiveScriptDebug32_Value;
pub const IActiveScriptDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptletTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCodeContextsOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptDebug32_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IActiveScriptDebug32.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IActiveScriptDebug32, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptDebug32_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IActiveScriptDebug32.VTable, @ptrCast(self.vtable)).GetScriptletTextAttributes(@as(*const IActiveScriptDebug32, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptDebug32_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppescc: ?*?*IEnumDebugCodeContexts) HRESULT {
                return @as(*const IActiveScriptDebug32.VTable, @ptrCast(self.vtable)).EnumCodeContextsOfPosition(@as(*const IActiveScriptDebug32, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptDebug64_Value = Guid.initString("bc437e23-f5b8-47f4-bb79-7d1ce5483b86");
pub const IID_IActiveScriptDebug64 = &IID_IActiveScriptDebug64_Value;
pub const IActiveScriptDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptletTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCodeContextsOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptDebug64_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IActiveScriptDebug64.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IActiveScriptDebug64, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptDebug64_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IActiveScriptDebug64.VTable, @ptrCast(self.vtable)).GetScriptletTextAttributes(@as(*const IActiveScriptDebug64, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptDebug64_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppescc: ?*?*IEnumDebugCodeContexts) HRESULT {
                return @as(*const IActiveScriptDebug64.VTable, @ptrCast(self.vtable)).EnumCodeContextsOfPosition(@as(*const IActiveScriptDebug64, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug32_Value = Guid.initString("51973c11-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptSiteDebug32 = &IID_IActiveScriptSiteDebug32_Value;
pub const IActiveScriptSiteDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug32,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug32,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptErrorDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug32_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppsc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).GetDocumentContextFromPosition(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug32_GetApplication(self: *const T, ppda: ?*?*IDebugApplication32) HRESULT {
                return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).GetApplication(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), ppda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug32_GetRootApplicationNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).GetRootApplicationNode(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), ppdanRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug32_OnScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfEnterDebugger: ?*BOOL, pfCallOnScriptErrorWhenContinuing: ?*BOOL) HRESULT {
                return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).OnScriptErrorDebug(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug64_Value = Guid.initString("d6b96b0a-7463-402c-92ac-89984226942f");
pub const IID_IActiveScriptSiteDebug64 = &IID_IActiveScriptSiteDebug64_Value;
pub const IActiveScriptSiteDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug64,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug64,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptErrorDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebug64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebug64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug64_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppsc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).GetDocumentContextFromPosition(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug64_GetApplication(self: *const T, ppda: ?*?*IDebugApplication64) HRESULT {
                return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).GetApplication(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), ppda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug64_GetRootApplicationNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).GetRootApplicationNode(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), ppdanRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebug64_OnScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfEnterDebugger: ?*BOOL, pfCallOnScriptErrorWhenContinuing: ?*BOOL) HRESULT {
                return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).OnScriptErrorDebug(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebugEx_Value = Guid.initString("bb722ccb-6ad2-41c6-b780-af9c03ee69f5");
pub const IID_IActiveScriptSiteDebugEx = &IID_IActiveScriptSiteDebugEx_Value;
pub const IActiveScriptSiteDebugEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCanNotJITScriptErrorDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptSiteDebugEx,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptSiteDebugEx,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptSiteDebugEx_OnCanNotJITScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfCallOnScriptErrorWhenContinuing: ?*BOOL) HRESULT {
                return @as(*const IActiveScriptSiteDebugEx.VTable, @ptrCast(self.vtable)).OnCanNotJITScriptErrorDebug(@as(*const IActiveScriptSiteDebugEx, @ptrCast(self)), pErrorDebug, pfCallOnScriptErrorWhenContinuing);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptErrorDebug_Value = Guid.initString("51973c12-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptErrorDebug = &IID_IActiveScriptErrorDebug_Value;
pub const IActiveScriptErrorDebug = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptErrorDebug,
                ppssc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptErrorDebug,
                ppssc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptErrorDebug,
                ppdsf: ?*?*IDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptErrorDebug,
                ppdsf: ?*?*IDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptError.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptErrorDebug_GetDocumentContext(self: *const T, ppssc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IActiveScriptErrorDebug.VTable, @ptrCast(self.vtable)).GetDocumentContext(@as(*const IActiveScriptErrorDebug, @ptrCast(self)), ppssc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptErrorDebug_GetStackFrame(self: *const T, ppdsf: ?*?*IDebugStackFrame) HRESULT {
                return @as(*const IActiveScriptErrorDebug.VTable, @ptrCast(self.vtable)).GetStackFrame(@as(*const IActiveScriptErrorDebug, @ptrCast(self)), ppdsf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCodeContext_Value = Guid.initString("51973c13-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugCodeContext = &IID_IDebugCodeContext_Value;
pub const IDebugCodeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugCodeContext,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugCodeContext,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugCodeContext,
                bps: BREAKPOINT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugCodeContext,
                bps: BREAKPOINT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugCodeContext_GetDocumentContext(self: *const T, ppsc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IDebugCodeContext.VTable, @ptrCast(self.vtable)).GetDocumentContext(@as(*const IDebugCodeContext, @ptrCast(self)), ppsc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugCodeContext_SetBreakPoint(self: *const T, bps: BREAKPOINT_STATE) HRESULT {
                return @as(*const IDebugCodeContext.VTable, @ptrCast(self.vtable)).SetBreakPoint(@as(*const IDebugCodeContext, @ptrCast(self)), bps);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpression_Value = Guid.initString("51973c14-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpression = &IID_IDebugExpression_Value;
pub const IDebugExpression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpression,
                pdecb: ?*IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpression,
                pdecb: ?*IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResultAsString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResultAsDebugProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                ppdp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                ppdp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpression_Start(self: *const T, pdecb: ?*IDebugExpressionCallBack) HRESULT {
                return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).Start(@as(*const IDebugExpression, @ptrCast(self)), pdecb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpression_Abort(self: *const T) HRESULT {
                return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).Abort(@as(*const IDebugExpression, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpression_QueryIsComplete(self: *const T) HRESULT {
                return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).QueryIsComplete(@as(*const IDebugExpression, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpression_GetResultAsString(self: *const T, phrResult: ?*HRESULT, pbstrResult: ?*?BSTR) HRESULT {
                return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).GetResultAsString(@as(*const IDebugExpression, @ptrCast(self)), phrResult, pbstrResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpression_GetResultAsDebugProperty(self: *const T, phrResult: ?*HRESULT, ppdp: ?*?*IDebugProperty) HRESULT {
                return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).GetResultAsDebugProperty(@as(*const IDebugExpression, @ptrCast(self)), phrResult, ppdp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionContext_Value = Guid.initString("51973c15-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpressionContext = &IID_IDebugExpressionContext_Value;
pub const IDebugExpressionContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseLanguageText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpressionContext,
                pstrCode: ?[*:0]const u16,
                nRadix: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                ppe: ?*?*IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpressionContext,
                pstrCode: ?[*:0]const u16,
                nRadix: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                ppe: ?*?*IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpressionContext,
                pbstrLanguageName: ?*?BSTR,
                pLanguageID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpressionContext,
                pbstrLanguageName: ?*?BSTR,
                pLanguageID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpressionContext_ParseLanguageText(self: *const T, pstrCode: ?[*:0]const u16, nRadix: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, ppe: ?*?*IDebugExpression) HRESULT {
                return @as(*const IDebugExpressionContext.VTable, @ptrCast(self.vtable)).ParseLanguageText(@as(*const IDebugExpressionContext, @ptrCast(self)), pstrCode, nRadix, pstrDelimiter, dwFlags, ppe);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpressionContext_GetLanguageInfo(self: *const T, pbstrLanguageName: ?*?BSTR, pLanguageID: ?*Guid) HRESULT {
                return @as(*const IDebugExpressionContext.VTable, @ptrCast(self.vtable)).GetLanguageInfo(@as(*const IDebugExpressionContext, @ptrCast(self)), pbstrLanguageName, pLanguageID);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionCallBack_Value = Guid.initString("51973c16-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpressionCallBack = &IID_IDebugExpressionCallBack_Value;
pub const IDebugExpressionCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugExpressionCallBack_onComplete(self: *const T) HRESULT {
                return @as(*const IDebugExpressionCallBack.VTable, @ptrCast(self.vtable)).onComplete(@as(*const IDebugExpressionCallBack, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrame_Value = Guid.initString("51973c17-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrame = &IID_IDebugStackFrame_Value;
pub const IDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodeContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame,
                ppcc: ?*?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame,
                ppcc: ?*?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrLanguage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrLanguage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame,
                ppat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame,
                ppat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame_GetCodeContext(self: *const T, ppcc: ?*?*IDebugCodeContext) HRESULT {
                return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetCodeContext(@as(*const IDebugStackFrame, @ptrCast(self)), ppcc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame_GetDescriptionString(self: *const T, fLong: BOOL, pbstrDescription: ?*?BSTR) HRESULT {
                return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetDescriptionString(@as(*const IDebugStackFrame, @ptrCast(self)), fLong, pbstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame_GetLanguageString(self: *const T, fLong: BOOL, pbstrLanguage: ?*?BSTR) HRESULT {
                return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetLanguageString(@as(*const IDebugStackFrame, @ptrCast(self)), fLong, pbstrLanguage);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame_GetThread(self: *const T, ppat: ?*?*IDebugApplicationThread) HRESULT {
                return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetThread(@as(*const IDebugStackFrame, @ptrCast(self)), ppat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame_GetDebugProperty(self: *const T, ppDebugProp: ?*?*IDebugProperty) HRESULT {
                return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetDebugProperty(@as(*const IDebugStackFrame, @ptrCast(self)), ppDebugProp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSniffer_Value = Guid.initString("51973c18-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrameSniffer = &IID_IDebugStackFrameSniffer_Value;
pub const IDebugStackFrameSniffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumStackFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrameSniffer,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrameSniffer,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrameSniffer_EnumStackFrames(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) HRESULT {
                return @as(*const IDebugStackFrameSniffer.VTable, @ptrCast(self.vtable)).EnumStackFrames(@as(*const IDebugStackFrameSniffer, @ptrCast(self)), ppedsf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx32_Value = Guid.initString("51973c19-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrameSnifferEx32 = &IID_IDebugStackFrameSnifferEx32_Value;
pub const IDebugStackFrameSnifferEx32 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrameSnifferEx32,
                dwSpMin: u32,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrameSnifferEx32,
                dwSpMin: u32,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrameSnifferEx32_EnumStackFramesEx32(self: *const T, dwSpMin: u32, ppedsf: ?*?*IEnumDebugStackFrames) HRESULT {
                return @as(*const IDebugStackFrameSnifferEx32.VTable, @ptrCast(self.vtable)).EnumStackFramesEx32(@as(*const IDebugStackFrameSnifferEx32, @ptrCast(self)), dwSpMin, ppedsf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx64_Value = Guid.initString("8cd12af4-49c1-4d52-8d8a-c146f47581aa");
pub const IID_IDebugStackFrameSnifferEx64 = &IID_IDebugStackFrameSnifferEx64_Value;
pub const IDebugStackFrameSnifferEx64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrameSnifferEx64,
                dwSpMin: u64,
                ppedsf: ?*?*IEnumDebugStackFrames64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrameSnifferEx64,
                dwSpMin: u64,
                ppedsf: ?*?*IEnumDebugStackFrames64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrameSnifferEx64_EnumStackFramesEx64(self: *const T, dwSpMin: u64, ppedsf: ?*?*IEnumDebugStackFrames64) HRESULT {
                return @as(*const IDebugStackFrameSnifferEx64.VTable, @ptrCast(self.vtable)).EnumStackFramesEx64(@as(*const IDebugStackFrameSnifferEx64, @ptrCast(self)), dwSpMin, ppedsf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSyncOperation_Value = Guid.initString("51973c1a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugSyncOperation = &IID_IDebugSyncOperation_Value;
pub const IDebugSyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSyncOperation,
                ppatTarget: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSyncOperation,
                ppatTarget: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSyncOperation,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSyncOperation,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InProgressAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSyncOperation_GetTargetThread(self: *const T, ppatTarget: ?*?*IDebugApplicationThread) HRESULT {
                return @as(*const IDebugSyncOperation.VTable, @ptrCast(self.vtable)).GetTargetThread(@as(*const IDebugSyncOperation, @ptrCast(self)), ppatTarget);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSyncOperation_Execute(self: *const T, ppunkResult: ?*?*IUnknown) HRESULT {
                return @as(*const IDebugSyncOperation.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugSyncOperation, @ptrCast(self)), ppunkResult);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSyncOperation_InProgressAbort(self: *const T) HRESULT {
                return @as(*const IDebugSyncOperation.VTable, @ptrCast(self.vtable)).InProgressAbort(@as(*const IDebugSyncOperation, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperation_Value = Guid.initString("51973c1b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugAsyncOperation = &IID_IDebugAsyncOperation_Value;
pub const IDebugAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncDebugOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAsyncOperation,
                ppsdo: ?*?*IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAsyncOperation,
                ppsdo: ?*?*IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAsyncOperation,
                padocb: ?*IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAsyncOperation,
                padocb: ?*IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAsyncOperation,
                phrResult: ?*HRESULT,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAsyncOperation,
                phrResult: ?*HRESULT,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAsyncOperation_GetSyncDebugOperation(self: *const T, ppsdo: ?*?*IDebugSyncOperation) HRESULT {
                return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).GetSyncDebugOperation(@as(*const IDebugAsyncOperation, @ptrCast(self)), ppsdo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAsyncOperation_Start(self: *const T, padocb: ?*IDebugAsyncOperationCallBack) HRESULT {
                return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).Start(@as(*const IDebugAsyncOperation, @ptrCast(self)), padocb);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAsyncOperation_Abort(self: *const T) HRESULT {
                return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).Abort(@as(*const IDebugAsyncOperation, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAsyncOperation_QueryIsComplete(self: *const T) HRESULT {
                return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).QueryIsComplete(@as(*const IDebugAsyncOperation, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAsyncOperation_GetResult(self: *const T, phrResult: ?*HRESULT, ppunkResult: ?*?*IUnknown) HRESULT {
                return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).GetResult(@as(*const IDebugAsyncOperation, @ptrCast(self)), phrResult, ppunkResult);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperationCallBack_Value = Guid.initString("51973c1c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugAsyncOperationCallBack = &IID_IDebugAsyncOperationCallBack_Value;
pub const IDebugAsyncOperationCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugAsyncOperationCallBack_onComplete(self: *const T) HRESULT {
                return @as(*const IDebugAsyncOperationCallBack.VTable, @ptrCast(self.vtable)).onComplete(@as(*const IDebugAsyncOperationCallBack, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugCodeContexts_Value = Guid.initString("51973c1d-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugCodeContexts = &IID_IEnumDebugCodeContexts_Value;
pub const IEnumDebugCodeContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugCodeContexts,
                celt: u32,
                pscc: ?*?*IDebugCodeContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugCodeContexts,
                celt: u32,
                pscc: ?*?*IDebugCodeContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugCodeContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugCodeContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugCodeContexts,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugCodeContexts,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugCodeContexts_Next(self: *const T, celt: u32, pscc: ?*?*IDebugCodeContext, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugCodeContexts, @ptrCast(self)), celt, pscc, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugCodeContexts_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugCodeContexts, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugCodeContexts_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugCodeContexts, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugCodeContexts_Clone(self: *const T, ppescc: ?*?*IEnumDebugCodeContexts) HRESULT {
                return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugCodeContexts, @ptrCast(self)), ppescc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DebugStackFrameDescriptor = extern struct {
    pdsf: ?*IDebugStackFrame,
    dwMin: u32,
    dwLim: u32,
    fFinal: BOOL,
    punkFinal: ?*IUnknown,
};

pub const DebugStackFrameDescriptor64 = extern struct {
    pdsf: ?*IDebugStackFrame,
    dwMin: u64,
    dwLim: u64,
    fFinal: BOOL,
    punkFinal: ?*IUnknown,
};

const IID_IEnumDebugStackFrames_Value = Guid.initString("51973c1e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugStackFrames = &IID_IEnumDebugStackFrames_Value;
pub const IEnumDebugStackFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugStackFrames,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugStackFrames,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugStackFrames,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugStackFrames,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugStackFrames,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugStackFrames,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugStackFrames_Next(self: *const T, celt: u32, prgdsfd: ?*DebugStackFrameDescriptor, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugStackFrames, @ptrCast(self)), celt, prgdsfd, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugStackFrames_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugStackFrames, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugStackFrames_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugStackFrames, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugStackFrames_Clone(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) HRESULT {
                return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugStackFrames, @ptrCast(self)), ppedsf);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugStackFrames64_Value = Guid.initString("0dc38853-c1b0-4176-a984-b298361027af");
pub const IID_IEnumDebugStackFrames64 = &IID_IEnumDebugStackFrames64_Value;
pub const IEnumDebugStackFrames64 = extern struct {
    pub const VTable = extern struct {
        base: IEnumDebugStackFrames.VTable,
        Next64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugStackFrames64,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor64,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugStackFrames64,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor64,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IEnumDebugStackFrames.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugStackFrames64_Next64(self: *const T, celt: u32, prgdsfd: ?*DebugStackFrameDescriptor64, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugStackFrames64.VTable, @ptrCast(self.vtable)).Next64(@as(*const IEnumDebugStackFrames64, @ptrCast(self)), celt, prgdsfd, pceltFetched);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentInfo_Value = Guid.initString("51973c1f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentInfo = &IID_IDebugDocumentInfo_Value;
pub const IDebugDocumentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentInfo,
                dnt: DOCUMENTNAMETYPE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentInfo,
                dnt: DOCUMENTNAMETYPE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentClassId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentInfo,
                pclsidDocument: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentInfo,
                pclsidDocument: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentInfo_GetName(self: *const T, dnt: DOCUMENTNAMETYPE, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IDebugDocumentInfo.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDebugDocumentInfo, @ptrCast(self)), dnt, pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentInfo_GetDocumentClassId(self: *const T, pclsidDocument: ?*Guid) HRESULT {
                return @as(*const IDebugDocumentInfo.VTable, @ptrCast(self.vtable)).GetDocumentClassId(@as(*const IDebugDocumentInfo, @ptrCast(self)), pclsidDocument);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentProvider_Value = Guid.initString("51973c20-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentProvider = &IID_IDebugDocumentProvider_Value;
pub const IDebugDocumentProvider = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentProvider,
                ppssd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentProvider,
                ppssd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentProvider_GetDocument(self: *const T, ppssd: ?*?*IDebugDocument) HRESULT {
                return @as(*const IDebugDocumentProvider.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IDebugDocumentProvider, @ptrCast(self)), ppssd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocument_Value = Guid.initString("51973c21-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocument = &IID_IDebugDocument_Value;
pub const IDebugDocument = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentText_Value = Guid.initString("51973c22-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentText = &IID_IDebugDocumentText_Value;
pub const IDebugDocumentText = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocument.VTable,
        GetDocumentAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                ptextdocattr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                ptextdocattr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                pcNumLines: ?*u32,
                pcNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                pcNumLines: ?*u32,
                pcNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositionOfLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                cLineNumber: u32,
                pcCharacterPosition: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                cLineNumber: u32,
                pcCharacterPosition: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcLineNumber: ?*u32,
                pcCharacterOffsetInLine: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcLineNumber: ?*u32,
                pcCharacterOffsetInLine: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: ?[*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: ?[*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositionOfContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                psc: ?*IDebugDocumentContext,
                pcCharacterPosition: ?*u32,
                cNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                psc: ?*IDebugDocumentContext,
                pcCharacterPosition: ?*u32,
                cNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                cNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                cNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugDocument.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetDocumentAttributes(self: *const T, ptextdocattr: ?*u32) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetDocumentAttributes(@as(*const IDebugDocumentText, @ptrCast(self)), ptextdocattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetSize(self: *const T, pcNumLines: ?*u32, pcNumChars: ?*u32) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IDebugDocumentText, @ptrCast(self)), pcNumLines, pcNumChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetPositionOfLine(self: *const T, cLineNumber: u32, pcCharacterPosition: ?*u32) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetPositionOfLine(@as(*const IDebugDocumentText, @ptrCast(self)), cLineNumber, pcCharacterPosition);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetLineOfPosition(self: *const T, cCharacterPosition: u32, pcLineNumber: ?*u32, pcCharacterOffsetInLine: ?*u32) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetLineOfPosition(@as(*const IDebugDocumentText, @ptrCast(self)), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetText(self: *const T, cCharacterPosition: u32, pcharText: [*:0]u16, pstaTextAttr: ?[*:0]u16, pcNumChars: ?*u32, cMaxChars: u32) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetText(@as(*const IDebugDocumentText, @ptrCast(self)), cCharacterPosition, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetPositionOfContext(self: *const T, psc: ?*IDebugDocumentContext, pcCharacterPosition: ?*u32, cNumChars: ?*u32) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetPositionOfContext(@as(*const IDebugDocumentText, @ptrCast(self)), psc, pcCharacterPosition, cNumChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentText_GetContextOfPosition(self: *const T, cCharacterPosition: u32, cNumChars: u32, ppsc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetContextOfPosition(@as(*const IDebugDocumentText, @ptrCast(self)), cCharacterPosition, cNumChars, ppsc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextEvents_Value = Guid.initString("51973c23-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextEvents = &IID_IDebugDocumentTextEvents_Value;
pub const IDebugDocumentTextEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onDestroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onInsertText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToInsert: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToInsert: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onRemoveText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onReplaceText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToReplace: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToReplace: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onUpdateTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToUpdate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToUpdate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onUpdateDocumentAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextEvents,
                textdocattr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextEvents,
                textdocattr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextEvents_onDestroy(self: *const T) HRESULT {
                return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onDestroy(@as(*const IDebugDocumentTextEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextEvents_onInsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32) HRESULT {
                return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onInsertText(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToInsert);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextEvents_onRemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) HRESULT {
                return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onRemoveText(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToRemove);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextEvents_onReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32) HRESULT {
                return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onReplaceText(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToReplace);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextEvents_onUpdateTextAttributes(self: *const T, cCharacterPosition: u32, cNumToUpdate: u32) HRESULT {
                return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onUpdateTextAttributes(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToUpdate);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextEvents_onUpdateDocumentAttributes(self: *const T, textdocattr: u32) HRESULT {
                return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onUpdateDocumentAttributes(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), textdocattr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextAuthor_Value = Guid.initString("51973c24-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextAuthor = &IID_IDebugDocumentTextAuthor_Value;
pub const IDebugDocumentTextAuthor = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentText.VTable,
        InsertText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToInsert: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToInsert: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplaceText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToReplace: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToReplace: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugDocumentText.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextAuthor_InsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32, pcharText: [*:0]u16) HRESULT {
                return @as(*const IDebugDocumentTextAuthor.VTable, @ptrCast(self.vtable)).InsertText(@as(*const IDebugDocumentTextAuthor, @ptrCast(self)), cCharacterPosition, cNumToInsert, pcharText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextAuthor_RemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) HRESULT {
                return @as(*const IDebugDocumentTextAuthor.VTable, @ptrCast(self.vtable)).RemoveText(@as(*const IDebugDocumentTextAuthor, @ptrCast(self)), cCharacterPosition, cNumToRemove);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextAuthor_ReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32, pcharText: [*:0]u16) HRESULT {
                return @as(*const IDebugDocumentTextAuthor.VTable, @ptrCast(self.vtable)).ReplaceText(@as(*const IDebugDocumentTextAuthor, @ptrCast(self)), cCharacterPosition, cNumToReplace, pcharText);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextExternalAuthor_Value = Guid.initString("51973c25-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextExternalAuthor = &IID_IDebugDocumentTextExternalAuthor_Value;
pub const IDebugDocumentTextExternalAuthor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentTextExternalAuthor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentTextExternalAuthor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextExternalAuthor_GetPathName(self: *const T, pbstrLongName: ?*?BSTR, pfIsOriginalFile: ?*BOOL) HRESULT {
                return @as(*const IDebugDocumentTextExternalAuthor.VTable, @ptrCast(self.vtable)).GetPathName(@as(*const IDebugDocumentTextExternalAuthor, @ptrCast(self)), pbstrLongName, pfIsOriginalFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextExternalAuthor_GetFileName(self: *const T, pbstrShortName: ?*?BSTR) HRESULT {
                return @as(*const IDebugDocumentTextExternalAuthor.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IDebugDocumentTextExternalAuthor, @ptrCast(self)), pbstrShortName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentTextExternalAuthor_NotifyChanged(self: *const T) HRESULT {
                return @as(*const IDebugDocumentTextExternalAuthor.VTable, @ptrCast(self.vtable)).NotifyChanged(@as(*const IDebugDocumentTextExternalAuthor, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper32_Value = Guid.initString("51973c26-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentHelper32 = &IID_IDebugDocumentHelper32_Value;
pub const IDebugDocumentHelper32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pda: ?*IDebugApplication32,
                pszShortName: ?[*:0]const u16,
                pszLongName: ?[*:0]const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pda: ?*IDebugApplication32,
                pszShortName: ?[*:0]const u16,
                pszLongName: ?[*:0]const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pddhParent: ?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pddhParent: ?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddUnicodeText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDBCSText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDebugDocumentHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDeferredText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineScriptBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultTextAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pszLongName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pszLongName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShortName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pszShortName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pszShortName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptBlockInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                dwSourceContext: u32,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                dwSourceContext: u32,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentContextToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper32,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper32,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_Init(self: *const T, pda: ?*IDebugApplication32, pszShortName: ?[*:0]const u16, pszLongName: ?[*:0]const u16, docAttr: u32) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).Init(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pda, pszShortName, pszLongName, docAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_Attach(self: *const T, pddhParent: ?*IDebugDocumentHelper32) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).Attach(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pddhParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_Detach(self: *const T) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).Detach(@as(*const IDebugDocumentHelper32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_AddUnicodeText(self: *const T, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).AddUnicodeText(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_AddDBCSText(self: *const T, pszText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).AddDBCSText(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_SetDebugDocumentHost(self: *const T, pddh: ?*IDebugDocumentHost) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetDebugDocumentHost(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pddh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).AddDeferredText(@as(*const IDebugDocumentHelper32, @ptrCast(self)), cChars, dwTextStartCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: ?*IActiveScript, fScriptlet: BOOL, pdwSourceContext: ?*u32) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).DefineScriptBlock(@as(*const IDebugDocumentHelper32, @ptrCast(self)), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_SetDefaultTextAttr(self: *const T, staTextAttr: u16) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetDefaultTextAttr(@as(*const IDebugDocumentHelper32, @ptrCast(self)), staTextAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetTextAttributes(@as(*const IDebugDocumentHelper32, @ptrCast(self)), ulCharOffset, cChars, pstaTextAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_SetLongName(self: *const T, pszLongName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetLongName(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszLongName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_SetShortName(self: *const T, pszShortName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetShortName(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszShortName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_SetDocumentAttr(self: *const T, pszAttributes: u32) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetDocumentAttr(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_GetDebugApplicationNode(self: *const T, ppdan: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).GetDebugApplicationNode(@as(*const IDebugDocumentHelper32, @ptrCast(self)), ppdan);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_GetScriptBlockInfo(self: *const T, dwSourceContext: u32, ppasd: ?*?*IActiveScript, piCharPos: ?*u32, pcChars: ?*u32) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).GetScriptBlockInfo(@as(*const IDebugDocumentHelper32, @ptrCast(self)), dwSourceContext, ppasd, piCharPos, pcChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).CreateDebugDocumentContext(@as(*const IDebugDocumentHelper32, @ptrCast(self)), iCharPos, cChars, ppddc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_BringDocumentToTop(self: *const T) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).BringDocumentToTop(@as(*const IDebugDocumentHelper32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper32_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) HRESULT {
                return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).BringDocumentContextToTop(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pddc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper64_Value = Guid.initString("c4c7363c-20fd-47f9-bd82-4855e0150871");
pub const IID_IDebugDocumentHelper64 = &IID_IDebugDocumentHelper64_Value;
pub const IDebugDocumentHelper64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pda: ?*IDebugApplication64,
                pszShortName: ?[*:0]const u16,
                pszLongName: ?[*:0]const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pda: ?*IDebugApplication64,
                pszShortName: ?[*:0]const u16,
                pszLongName: ?[*:0]const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pddhParent: ?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pddhParent: ?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddUnicodeText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDBCSText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDebugDocumentHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDeferredText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineScriptBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultTextAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pszLongName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pszLongName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShortName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pszShortName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pszShortName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptBlockInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                dwSourceContext: u64,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                dwSourceContext: u64,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentContextToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHelper64,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHelper64,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_Init(self: *const T, pda: ?*IDebugApplication64, pszShortName: ?[*:0]const u16, pszLongName: ?[*:0]const u16, docAttr: u32) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).Init(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pda, pszShortName, pszLongName, docAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_Attach(self: *const T, pddhParent: ?*IDebugDocumentHelper64) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).Attach(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pddhParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_Detach(self: *const T) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).Detach(@as(*const IDebugDocumentHelper64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_AddUnicodeText(self: *const T, pszText: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).AddUnicodeText(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_AddDBCSText(self: *const T, pszText: ?[*:0]const u8) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).AddDBCSText(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszText);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_SetDebugDocumentHost(self: *const T, pddh: ?*IDebugDocumentHost) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetDebugDocumentHost(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pddh);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).AddDeferredText(@as(*const IDebugDocumentHelper64, @ptrCast(self)), cChars, dwTextStartCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: ?*IActiveScript, fScriptlet: BOOL, pdwSourceContext: ?*u64) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).DefineScriptBlock(@as(*const IDebugDocumentHelper64, @ptrCast(self)), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_SetDefaultTextAttr(self: *const T, staTextAttr: u16) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetDefaultTextAttr(@as(*const IDebugDocumentHelper64, @ptrCast(self)), staTextAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetTextAttributes(@as(*const IDebugDocumentHelper64, @ptrCast(self)), ulCharOffset, cChars, pstaTextAttr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_SetLongName(self: *const T, pszLongName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetLongName(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszLongName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_SetShortName(self: *const T, pszShortName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetShortName(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszShortName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_SetDocumentAttr(self: *const T, pszAttributes: u32) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetDocumentAttr(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszAttributes);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_GetDebugApplicationNode(self: *const T, ppdan: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).GetDebugApplicationNode(@as(*const IDebugDocumentHelper64, @ptrCast(self)), ppdan);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_GetScriptBlockInfo(self: *const T, dwSourceContext: u64, ppasd: ?*?*IActiveScript, piCharPos: ?*u32, pcChars: ?*u32) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).GetScriptBlockInfo(@as(*const IDebugDocumentHelper64, @ptrCast(self)), dwSourceContext, ppasd, piCharPos, pcChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).CreateDebugDocumentContext(@as(*const IDebugDocumentHelper64, @ptrCast(self)), iCharPos, cChars, ppddc);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_BringDocumentToTop(self: *const T) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).BringDocumentToTop(@as(*const IDebugDocumentHelper64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHelper64_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) HRESULT {
                return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).BringDocumentContextToTop(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pddc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHost_Value = Guid.initString("51973c27-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentHost = &IID_IDebugDocumentHost_Value;
pub const IDebugDocumentHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeferredText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHost,
                dwTextStartCookie: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: [*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHost,
                dwTextStartCookie: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: [*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHost,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHost,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreateDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHost,
                ppunkOuter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHost,
                ppunkOuter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPathName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHost,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHost,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHost,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHost,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHost_GetDeferredText(self: *const T, dwTextStartCookie: u32, pcharText: [*:0]u16, pstaTextAttr: [*:0]u16, pcNumChars: ?*u32, cMaxChars: u32) HRESULT {
                return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetDeferredText(@as(*const IDebugDocumentHost, @ptrCast(self)), dwTextStartCookie, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHost_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IDebugDocumentHost, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHost_OnCreateDocumentContext(self: *const T, ppunkOuter: ?*?*IUnknown) HRESULT {
                return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).OnCreateDocumentContext(@as(*const IDebugDocumentHost, @ptrCast(self)), ppunkOuter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHost_GetPathName(self: *const T, pbstrLongName: ?*?BSTR, pfIsOriginalFile: ?*BOOL) HRESULT {
                return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetPathName(@as(*const IDebugDocumentHost, @ptrCast(self)), pbstrLongName, pfIsOriginalFile);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHost_GetFileName(self: *const T, pbstrShortName: ?*?BSTR) HRESULT {
                return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IDebugDocumentHost, @ptrCast(self)), pbstrShortName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentHost_NotifyChanged(self: *const T) HRESULT {
                return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).NotifyChanged(@as(*const IDebugDocumentHost, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentContext_Value = Guid.initString("51973c28-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentContext = &IID_IDebugDocumentContext_Value;
pub const IDebugDocumentContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentContext,
                ppsd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentContext,
                ppsd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCodeContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugDocumentContext,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugDocumentContext,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentContext_GetDocument(self: *const T, ppsd: ?*?*IDebugDocument) HRESULT {
                return @as(*const IDebugDocumentContext.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IDebugDocumentContext, @ptrCast(self)), ppsd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugDocumentContext_EnumCodeContexts(self: *const T, ppescc: ?*?*IEnumDebugCodeContexts) HRESULT {
                return @as(*const IDebugDocumentContext.VTable, @ptrCast(self.vtable)).EnumCodeContexts(@as(*const IDebugDocumentContext, @ptrCast(self)), ppescc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSessionProvider_Value = Guid.initString("51973c29-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugSessionProvider = &IID_IDebugSessionProvider_Value;
pub const IDebugSessionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartDebugSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugSessionProvider,
                pda: ?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugSessionProvider,
                pda: ?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugSessionProvider_StartDebugSession(self: *const T, pda: ?*IRemoteDebugApplication) HRESULT {
                return @as(*const IDebugSessionProvider.VTable, @ptrCast(self.vtable)).StartDebugSession(@as(*const IDebugSessionProvider, @ptrCast(self)), pda);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebugger_Value = Guid.initString("51973c2a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IApplicationDebugger = &IID_IApplicationDebugger_Value;
pub const IApplicationDebugger = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAlive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstanceAtDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebugger,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebugger,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebugger,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebugger,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onHandleBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebugger,
                prpt: ?*IRemoteDebugApplicationThread,
                br: BREAKREASON,
                pError: ?*IActiveScriptErrorDebug,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebugger,
                prpt: ?*IRemoteDebugApplicationThread,
                br: BREAKREASON,
                pError: ?*IActiveScriptErrorDebug,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onDebuggerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebugger,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebugger,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebugger_QueryAlive(self: *const T) HRESULT {
                return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).QueryAlive(@as(*const IApplicationDebugger, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebugger_CreateInstanceAtDebugger(self: *const T, rclsid: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*IUnknown) HRESULT {
                return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).CreateInstanceAtDebugger(@as(*const IApplicationDebugger, @ptrCast(self)), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebugger_onDebugOutput(self: *const T, pstr: ?[*:0]const u16) HRESULT {
                return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onDebugOutput(@as(*const IApplicationDebugger, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebugger_onHandleBreakPoint(self: *const T, prpt: ?*IRemoteDebugApplicationThread, br: BREAKREASON, pError: ?*IActiveScriptErrorDebug) HRESULT {
                return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onHandleBreakPoint(@as(*const IApplicationDebugger, @ptrCast(self)), prpt, br, pError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebugger_onClose(self: *const T) HRESULT {
                return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onClose(@as(*const IApplicationDebugger, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebugger_onDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onDebuggerEvent(@as(*const IApplicationDebugger, @ptrCast(self)), riid, punk);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebuggerUI_Value = Guid.initString("51973c2b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IApplicationDebuggerUI = &IID_IApplicationDebuggerUI_Value;
pub const IApplicationDebuggerUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BringDocumentToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebuggerUI,
                pddt: ?*IDebugDocumentText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebuggerUI,
                pddt: ?*IDebugDocumentText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentContextToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IApplicationDebuggerUI,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IApplicationDebuggerUI,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebuggerUI_BringDocumentToTop(self: *const T, pddt: ?*IDebugDocumentText) HRESULT {
                return @as(*const IApplicationDebuggerUI.VTable, @ptrCast(self.vtable)).BringDocumentToTop(@as(*const IApplicationDebuggerUI, @ptrCast(self)), pddt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IApplicationDebuggerUI_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) HRESULT {
                return @as(*const IApplicationDebuggerUI.VTable, @ptrCast(self.vtable)).BringDocumentContextToTop(@as(*const IApplicationDebuggerUI, @ptrCast(self)), pddc);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManager_Value = Guid.initString("51973c2c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManager = &IID_IMachineDebugManager_Value;
pub const IMachineDebugManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManager,
                pda: ?*IRemoteDebugApplication,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManager,
                pda: ?*IRemoteDebugApplication,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManager,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManager,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumApplications: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManager,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManager,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManager_AddApplication(self: *const T, pda: ?*IRemoteDebugApplication, pdwAppCookie: ?*u32) HRESULT {
                return @as(*const IMachineDebugManager.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IMachineDebugManager, @ptrCast(self)), pda, pdwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManager_RemoveApplication(self: *const T, dwAppCookie: u32) HRESULT {
                return @as(*const IMachineDebugManager.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IMachineDebugManager, @ptrCast(self)), dwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManager_EnumApplications(self: *const T, ppeda: ?*?*IEnumRemoteDebugApplications) HRESULT {
                return @as(*const IMachineDebugManager.VTable, @ptrCast(self.vtable)).EnumApplications(@as(*const IMachineDebugManager, @ptrCast(self)), ppeda);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerCookie_Value = Guid.initString("51973c2d-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManagerCookie = &IID_IMachineDebugManagerCookie_Value;
pub const IMachineDebugManagerCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManagerCookie,
                pda: ?*IRemoteDebugApplication,
                dwDebugAppCookie: u32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManagerCookie,
                pda: ?*IRemoteDebugApplication,
                dwDebugAppCookie: u32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManagerCookie,
                dwDebugAppCookie: u32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManagerCookie,
                dwDebugAppCookie: u32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumApplications: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManagerCookie,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManagerCookie,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManagerCookie_AddApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwDebugAppCookie: u32, pdwAppCookie: ?*u32) HRESULT {
                return @as(*const IMachineDebugManagerCookie.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IMachineDebugManagerCookie, @ptrCast(self)), pda, dwDebugAppCookie, pdwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManagerCookie_RemoveApplication(self: *const T, dwDebugAppCookie: u32, dwAppCookie: u32) HRESULT {
                return @as(*const IMachineDebugManagerCookie.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IMachineDebugManagerCookie, @ptrCast(self)), dwDebugAppCookie, dwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManagerCookie_EnumApplications(self: *const T, ppeda: ?*?*IEnumRemoteDebugApplications) HRESULT {
                return @as(*const IMachineDebugManagerCookie.VTable, @ptrCast(self.vtable)).EnumApplications(@as(*const IMachineDebugManagerCookie, @ptrCast(self)), ppeda);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerEvents_Value = Guid.initString("51973c2e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManagerEvents = &IID_IMachineDebugManagerEvents_Value;
pub const IMachineDebugManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onRemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManagerEvents_onAddApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwAppCookie: u32) HRESULT {
                return @as(*const IMachineDebugManagerEvents.VTable, @ptrCast(self.vtable)).onAddApplication(@as(*const IMachineDebugManagerEvents, @ptrCast(self)), pda, dwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IMachineDebugManagerEvents_onRemoveApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwAppCookie: u32) HRESULT {
                return @as(*const IMachineDebugManagerEvents.VTable, @ptrCast(self.vtable)).onRemoveApplication(@as(*const IMachineDebugManagerEvents, @ptrCast(self)), pda, dwAppCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager32_Value = Guid.initString("51973c2f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IProcessDebugManager32 = &IID_IProcessDebugManager32_Value;
pub const IProcessDebugManager32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager32,
                pda: ?*IDebugApplication32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager32,
                pda: ?*IDebugApplication32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager32,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager32,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager32_CreateApplication(self: *const T, ppda: ?*?*IDebugApplication32) HRESULT {
                return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).CreateApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), ppda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager32_GetDefaultApplication(self: *const T, ppda: ?*?*IDebugApplication32) HRESULT {
                return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).GetDefaultApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), ppda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager32_AddApplication(self: *const T, pda: ?*IDebugApplication32, pdwAppCookie: ?*u32) HRESULT {
                return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), pda, pdwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager32_RemoveApplication(self: *const T, dwAppCookie: u32) HRESULT {
                return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), dwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager32_CreateDebugDocumentHelper(self: *const T, punkOuter: ?*IUnknown, pddh: ?*?*IDebugDocumentHelper32) HRESULT {
                return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).CreateDebugDocumentHelper(@as(*const IProcessDebugManager32, @ptrCast(self)), punkOuter, pddh);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager64_Value = Guid.initString("56b9fc1c-63a9-4cc1-ac21-087d69a17fab");
pub const IID_IProcessDebugManager64 = &IID_IProcessDebugManager64_Value;
pub const IProcessDebugManager64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager64,
                pda: ?*IDebugApplication64,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager64,
                pda: ?*IDebugApplication64,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager64,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager64,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProcessDebugManager64,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProcessDebugManager64,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager64_CreateApplication(self: *const T, ppda: ?*?*IDebugApplication64) HRESULT {
                return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).CreateApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), ppda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager64_GetDefaultApplication(self: *const T, ppda: ?*?*IDebugApplication64) HRESULT {
                return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).GetDefaultApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), ppda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager64_AddApplication(self: *const T, pda: ?*IDebugApplication64, pdwAppCookie: ?*u32) HRESULT {
                return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), pda, pdwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager64_RemoveApplication(self: *const T, dwAppCookie: u32) HRESULT {
                return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), dwAppCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProcessDebugManager64_CreateDebugDocumentHelper(self: *const T, punkOuter: ?*IUnknown, pddh: ?*?*IDebugDocumentHelper64) HRESULT {
                return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).CreateDebugDocumentHelper(@as(*const IProcessDebugManager64, @ptrCast(self)), punkOuter, pddh);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplication_Value = Guid.initString("51973c30-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplication = &IID_IRemoteDebugApplication_Value;
pub const IRemoteDebugApplication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResumeFromBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                prptFocus: ?*IRemoteDebugApplicationThread,
                bra: BREAKRESUME_ACTION,
                era: ERRORRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                prptFocus: ?*IRemoteDebugApplicationThread,
                bra: BREAKRESUME_ACTION,
                era: ERRORRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CauseBreak: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                pad: ?*?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                pad: ?*?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstanceAtApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAlive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumGlobalExpressionContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_ResumeFromBreakPoint(self: *const T, prptFocus: ?*IRemoteDebugApplicationThread, bra: BREAKRESUME_ACTION, era: ERRORRESUMEACTION) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).ResumeFromBreakPoint(@as(*const IRemoteDebugApplication, @ptrCast(self)), prptFocus, bra, era);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_CauseBreak(self: *const T) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).CauseBreak(@as(*const IRemoteDebugApplication, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_ConnectDebugger(self: *const T, pad: ?*IApplicationDebugger) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).ConnectDebugger(@as(*const IRemoteDebugApplication, @ptrCast(self)), pad);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_DisconnectDebugger(self: *const T) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).DisconnectDebugger(@as(*const IRemoteDebugApplication, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_GetDebugger(self: *const T, pad: ?*?*IApplicationDebugger) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).GetDebugger(@as(*const IRemoteDebugApplication, @ptrCast(self)), pad);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_CreateInstanceAtApplication(self: *const T, rclsid: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*IUnknown) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).CreateInstanceAtApplication(@as(*const IRemoteDebugApplication, @ptrCast(self)), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_QueryAlive(self: *const T) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).QueryAlive(@as(*const IRemoteDebugApplication, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_EnumThreads(self: *const T, pperdat: ?*?*IEnumRemoteDebugApplicationThreads) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).EnumThreads(@as(*const IRemoteDebugApplication, @ptrCast(self)), pperdat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_GetName(self: *const T, pbstrName: ?*?BSTR) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).GetName(@as(*const IRemoteDebugApplication, @ptrCast(self)), pbstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_GetRootNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).GetRootNode(@as(*const IRemoteDebugApplication, @ptrCast(self)), ppdanRoot);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication_EnumGlobalExpressionContexts(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) HRESULT {
                return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).EnumGlobalExpressionContexts(@as(*const IRemoteDebugApplication, @ptrCast(self)), ppedec);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication32_Value = Guid.initString("51973c32-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplication32 = &IID_IDebugApplication32_Value;
pub const IDebugApplication32 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pstrName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pstrName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StepOutComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartDebugSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                br: BREAKREASON,
                pbra: ?*BREAKRESUME_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                br: BREAKREASON,
                pbra: ?*BREAKRESUME_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAsyncDebugOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCurrentThreadIsDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SynchronousCallInDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pptc: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pptc: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDebuggerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleRuntimeError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUME_ACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUME_ACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FCanJitDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        FIsAutoJitDebugEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        AddGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_SetName(self: *const T, pstrName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).SetName(@as(*const IDebugApplication32, @ptrCast(self)), pstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_StepOutComplete(self: *const T) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).StepOutComplete(@as(*const IDebugApplication32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_DebugOutput(self: *const T, pstr: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).DebugOutput(@as(*const IDebugApplication32, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_StartDebugSession(self: *const T) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).StartDebugSession(@as(*const IDebugApplication32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: ?*BREAKRESUME_ACTION) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).HandleBreakPoint(@as(*const IDebugApplication32, @ptrCast(self)), br, pbra);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_Close(self: *const T) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).Close(@as(*const IDebugApplication32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_GetBreakFlags(self: *const T, pabf: ?*u32, pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).GetBreakFlags(@as(*const IDebugApplication32, @ptrCast(self)), pabf, pprdatSteppingThread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_GetCurrentThread(self: *const T, pat: ?*?*IDebugApplicationThread) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).GetCurrentThread(@as(*const IDebugApplication32, @ptrCast(self)), pat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_CreateAsyncDebugOperation(self: *const T, psdo: ?*IDebugSyncOperation, ppado: ?*?*IDebugAsyncOperation) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).CreateAsyncDebugOperation(@as(*const IDebugApplication32, @ptrCast(self)), psdo, ppado);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_AddStackFrameSniffer(self: *const T, pdsfs: ?*IDebugStackFrameSniffer, pdwCookie: ?*u32) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).AddStackFrameSniffer(@as(*const IDebugApplication32, @ptrCast(self)), pdsfs, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).RemoveStackFrameSniffer(@as(*const IDebugApplication32, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_QueryCurrentThreadIsDebuggerThread(self: *const T) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).QueryCurrentThreadIsDebuggerThread(@as(*const IDebugApplication32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_SynchronousCallInDebuggerThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).SynchronousCallInDebuggerThread(@as(*const IDebugApplication32, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_CreateApplicationNode(self: *const T, ppdanNew: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).CreateApplicationNode(@as(*const IDebugApplication32, @ptrCast(self)), ppdanNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_FireDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).FireDebuggerEvent(@as(*const IDebugApplication32, @ptrCast(self)), riid, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_HandleRuntimeError(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pScriptSite: ?*IActiveScriptSite, pbra: ?*BREAKRESUME_ACTION, perra: ?*ERRORRESUMEACTION, pfCallOnScriptError: ?*BOOL) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).HandleRuntimeError(@as(*const IDebugApplication32, @ptrCast(self)), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_FCanJitDebug(self: *const T) BOOL {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).FCanJitDebug(@as(*const IDebugApplication32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_FIsAutoJitDebugEnabled(self: *const T) BOOL {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).FIsAutoJitDebugEnabled(@as(*const IDebugApplication32, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_AddGlobalExpressionContextProvider(self: *const T, pdsfs: ?*IProvideExpressionContexts, pdwCookie: ?*u32) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).AddGlobalExpressionContextProvider(@as(*const IDebugApplication32, @ptrCast(self)), pdsfs, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication32_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).RemoveGlobalExpressionContextProvider(@as(*const IDebugApplication32, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication64_Value = Guid.initString("4dedc754-04c7-4f10-9e60-16a390fe6e62");
pub const IID_IDebugApplication64 = &IID_IDebugApplication64_Value;
pub const IDebugApplication64 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pstrName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pstrName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StepOutComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartDebugSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                br: BREAKREASON,
                pbra: ?*BREAKRESUME_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                br: BREAKREASON,
                pbra: ?*BREAKRESUME_ACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAsyncDebugOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCurrentThreadIsDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SynchronousCallInDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pptc: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pptc: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDebuggerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleRuntimeError: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUME_ACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUME_ACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FCanJitDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        FIsAutoJitDebugEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn (
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        AddGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication64,
                dwCookie: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication64,
                dwCookie: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_SetName(self: *const T, pstrName: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).SetName(@as(*const IDebugApplication64, @ptrCast(self)), pstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_StepOutComplete(self: *const T) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).StepOutComplete(@as(*const IDebugApplication64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_DebugOutput(self: *const T, pstr: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).DebugOutput(@as(*const IDebugApplication64, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_StartDebugSession(self: *const T) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).StartDebugSession(@as(*const IDebugApplication64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: ?*BREAKRESUME_ACTION) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).HandleBreakPoint(@as(*const IDebugApplication64, @ptrCast(self)), br, pbra);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_Close(self: *const T) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).Close(@as(*const IDebugApplication64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_GetBreakFlags(self: *const T, pabf: ?*u32, pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).GetBreakFlags(@as(*const IDebugApplication64, @ptrCast(self)), pabf, pprdatSteppingThread);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_GetCurrentThread(self: *const T, pat: ?*?*IDebugApplicationThread) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).GetCurrentThread(@as(*const IDebugApplication64, @ptrCast(self)), pat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_CreateAsyncDebugOperation(self: *const T, psdo: ?*IDebugSyncOperation, ppado: ?*?*IDebugAsyncOperation) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).CreateAsyncDebugOperation(@as(*const IDebugApplication64, @ptrCast(self)), psdo, ppado);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_AddStackFrameSniffer(self: *const T, pdsfs: ?*IDebugStackFrameSniffer, pdwCookie: ?*u32) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).AddStackFrameSniffer(@as(*const IDebugApplication64, @ptrCast(self)), pdsfs, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).RemoveStackFrameSniffer(@as(*const IDebugApplication64, @ptrCast(self)), dwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_QueryCurrentThreadIsDebuggerThread(self: *const T) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).QueryCurrentThreadIsDebuggerThread(@as(*const IDebugApplication64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_SynchronousCallInDebuggerThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).SynchronousCallInDebuggerThread(@as(*const IDebugApplication64, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_CreateApplicationNode(self: *const T, ppdanNew: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).CreateApplicationNode(@as(*const IDebugApplication64, @ptrCast(self)), ppdanNew);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_FireDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).FireDebuggerEvent(@as(*const IDebugApplication64, @ptrCast(self)), riid, punk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_HandleRuntimeError(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pScriptSite: ?*IActiveScriptSite, pbra: ?*BREAKRESUME_ACTION, perra: ?*ERRORRESUMEACTION, pfCallOnScriptError: ?*BOOL) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).HandleRuntimeError(@as(*const IDebugApplication64, @ptrCast(self)), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_FCanJitDebug(self: *const T) BOOL {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).FCanJitDebug(@as(*const IDebugApplication64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_FIsAutoJitDebugEnabled(self: *const T) BOOL {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).FIsAutoJitDebugEnabled(@as(*const IDebugApplication64, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_AddGlobalExpressionContextProvider(self: *const T, pdsfs: ?*IProvideExpressionContexts, pdwCookie: ?*u64) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).AddGlobalExpressionContextProvider(@as(*const IDebugApplication64, @ptrCast(self)), pdsfs, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication64_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u64) HRESULT {
                return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).RemoveGlobalExpressionContextProvider(@as(*const IDebugApplication64, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationEvents_Value = Guid.initString("51973c33-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplicationEvents = &IID_IRemoteDebugApplicationEvents_Value;
pub const IRemoteDebugApplicationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDisconnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                pstrName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                pstrName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                pstr: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEnterBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLeaveBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDestroyThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBreakFlagChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationEvents,
                abf: u32,
                prdatSteppingThread: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationEvents,
                abf: u32,
                prdatSteppingThread: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnConnectDebugger(self: *const T, pad: ?*IApplicationDebugger) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnConnectDebugger(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), pad);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnDisconnectDebugger(self: *const T) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnDisconnectDebugger(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnSetName(self: *const T, pstrName: ?[*:0]const u16) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnSetName(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), pstrName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnDebugOutput(self: *const T, pstr: ?[*:0]const u16) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnDebugOutput(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), pstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnClose(self: *const T) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnClose(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnEnterBreakPoint(self: *const T, prdat: ?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnEnterBreakPoint(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnLeaveBreakPoint(self: *const T, prdat: ?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnLeaveBreakPoint(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnCreateThread(self: *const T, prdat: ?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnCreateThread(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnDestroyThread(self: *const T, prdat: ?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnDestroyThread(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationEvents_OnBreakFlagChange(self: *const T, abf: u32, prdatSteppingThread: ?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnBreakFlagChange(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), abf, prdatSteppingThread);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNode_Value = Guid.initString("51973c34-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationNode = &IID_IDebugApplicationNode_Value;
pub const IDebugApplicationNode = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentProvider.VTable,
        EnumChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode,
                pprddp: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode,
                pprddp: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode,
                pddp: ?*IDebugDocumentProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode,
                pddp: ?*IDebugDocumentProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode,
                pdanParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode,
                pdanParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugDocumentProvider.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode_EnumChildren(self: *const T, pperddp: ?*?*IEnumDebugApplicationNodes) HRESULT {
                return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).EnumChildren(@as(*const IDebugApplicationNode, @ptrCast(self)), pperddp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode_GetParent(self: *const T, pprddp: ?*?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IDebugApplicationNode, @ptrCast(self)), pprddp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode_SetDocumentProvider(self: *const T, pddp: ?*IDebugDocumentProvider) HRESULT {
                return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).SetDocumentProvider(@as(*const IDebugApplicationNode, @ptrCast(self)), pddp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode_Close(self: *const T) HRESULT {
                return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).Close(@as(*const IDebugApplicationNode, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode_Attach(self: *const T, pdanParent: ?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).Attach(@as(*const IDebugApplicationNode, @ptrCast(self)), pdanParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode_Detach(self: *const T) HRESULT {
                return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).Detach(@as(*const IDebugApplicationNode, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNodeEvents_Value = Guid.initString("51973c35-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationNodeEvents = &IID_IDebugApplicationNodeEvents_Value;
pub const IDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onRemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNodeEvents_onAddChild(self: *const T, prddpChild: ?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onAddChild(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNodeEvents_onRemoveChild(self: *const T, prddpChild: ?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onRemoveChild(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNodeEvents_onDetach(self: *const T) HRESULT {
                return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onDetach(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNodeEvents_onAttach(self: *const T, prddpParent: ?*IDebugApplicationNode) HRESULT {
                return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onAttach(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)), prddpParent);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIDebugApplicationNodeEvents_Value = Guid.initString("a2e3aa3b-aa8d-4ebf-84cd-648b737b8c13");
pub const IID_AsyncIDebugApplicationNodeEvents = &IID_AsyncIDebugApplicationNodeEvents_Value;
pub const AsyncIDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_onAddChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onAddChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_onRemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onRemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_onDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_onAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Begin_onAddChild(self: *const T, prddpChild: ?*IDebugApplicationNode) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onAddChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Finish_onAddChild(self: *const T) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onAddChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Begin_onRemoveChild(self: *const T, prddpChild: ?*IDebugApplicationNode) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onRemoveChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Finish_onRemoveChild(self: *const T) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onRemoveChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Begin_onDetach(self: *const T) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onDetach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Finish_onDetach(self: *const T) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onDetach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Begin_onAttach(self: *const T, prddpParent: ?*IDebugApplicationNode) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onAttach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)), prddpParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn AsyncIDebugApplicationNodeEvents_Finish_onAttach(self: *const T) HRESULT {
                return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onAttach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall32_Value = Guid.initString("51973c36-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugThreadCall32 = &IID_IDebugThreadCall32_Value;
pub const IDebugThreadCall32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugThreadCall32_ThreadCallHandler(self: *const T, dwParam1: u32, dwParam2: u32, dwParam3: u32) HRESULT {
                return @as(*const IDebugThreadCall32.VTable, @ptrCast(self.vtable)).ThreadCallHandler(@as(*const IDebugThreadCall32, @ptrCast(self)), dwParam1, dwParam2, dwParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall64_Value = Guid.initString("cb3fa335-e979-42fd-9fcf-a7546a0f3905");
pub const IID_IDebugThreadCall64 = &IID_IDebugThreadCall64_Value;
pub const IDebugThreadCall64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugThreadCall64_ThreadCallHandler(self: *const T, dwParam1: u64, dwParam2: u64, dwParam3: u64) HRESULT {
                return @as(*const IDebugThreadCall64.VTable, @ptrCast(self.vtable)).ThreadCallHandler(@as(*const IDebugThreadCall64, @ptrCast(self)), dwParam1, dwParam2, dwParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationThread_Value = Guid.initString("51973c37-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplicationThread = &IID_IRemoteDebugApplicationThread_Value;
pub const IRemoteDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSystemThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                dwThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                dwThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pprda: ?*?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pprda: ?*?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStackFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pbstrDescription: ?*?BSTR,
                pbstrState: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pbstrDescription: ?*?BSTR,
                pbstrState: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextStatement: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pStackFrame: ?*IDebugStackFrame,
                pCodeContext: ?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pStackFrame: ?*IDebugStackFrame,
                pCodeContext: ?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSuspendCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_GetSystemThreadId(self: *const T, dwThreadId: ?*u32) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetSystemThreadId(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), dwThreadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_GetApplication(self: *const T, pprda: ?*?*IRemoteDebugApplication) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetApplication(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pprda);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_EnumStackFrames(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).EnumStackFrames(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), ppedsf);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_GetDescription(self: *const T, pbstrDescription: ?*?BSTR, pbstrState: ?*?BSTR) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pbstrDescription, pbstrState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_SetNextStatement(self: *const T, pStackFrame: ?*IDebugStackFrame, pCodeContext: ?*IDebugCodeContext) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).SetNextStatement(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pStackFrame, pCodeContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_GetState(self: *const T, pState: ?*u32) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetState(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pState);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_Suspend(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_Resume(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).Resume(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pdwCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplicationThread_GetSuspendCount(self: *const T, pdwCount: ?*u32) HRESULT {
                return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetSuspendCount(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pdwCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread_Value = Guid.initString("51973c38-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationThread = &IID_IDebugApplicationThread_Value;
pub const IDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplicationThread.VTable,
        SynchronousCallIntoThread32: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread,
                pstcb: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread,
                pstcb: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread,
                pstrDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread,
                pstrDescription: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStateString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread,
                pstrState: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread,
                pstrState: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRemoteDebugApplicationThread.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread_SynchronousCallIntoThread32(self: *const T, pstcb: ?*IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) HRESULT {
                return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).SynchronousCallIntoThread32(@as(*const IDebugApplicationThread, @ptrCast(self)), pstcb, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread_QueryIsCurrentThread(self: *const T) HRESULT {
                return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).QueryIsCurrentThread(@as(*const IDebugApplicationThread, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread_QueryIsDebuggerThread(self: *const T) HRESULT {
                return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).QueryIsDebuggerThread(@as(*const IDebugApplicationThread, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread_SetDescription(self: *const T, pstrDescription: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const IDebugApplicationThread, @ptrCast(self)), pstrDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread_SetStateString(self: *const T, pstrState: ?[*:0]const u16) HRESULT {
                return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).SetStateString(@as(*const IDebugApplicationThread, @ptrCast(self)), pstrState);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread64_Value = Guid.initString("9dac5886-dbad-456d-9dee-5dec39ab3dda");
pub const IID_IDebugApplicationThread64 = &IID_IDebugApplicationThread64_Value;
pub const IDebugApplicationThread64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugApplicationThread.VTable,
        SynchronousCallIntoThread64: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread64,
                pstcb: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread64,
                pstcb: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugApplicationThread.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread64_SynchronousCallIntoThread64(self: *const T, pstcb: ?*IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) HRESULT {
                return @as(*const IDebugApplicationThread64.VTable, @ptrCast(self.vtable)).SynchronousCallIntoThread64(@as(*const IDebugApplicationThread64, @ptrCast(self)), pstcb, dwParam1, dwParam2, dwParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCookie_Value = Guid.initString("51973c39-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugCookie = &IID_IDebugCookie_Value;
pub const IDebugCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDebugCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugCookie,
                dwDebugAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugCookie,
                dwDebugAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugCookie_SetDebugCookie(self: *const T, dwDebugAppCookie: u32) HRESULT {
                return @as(*const IDebugCookie.VTable, @ptrCast(self.vtable)).SetDebugCookie(@as(*const IDebugCookie, @ptrCast(self)), dwDebugAppCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugApplicationNodes_Value = Guid.initString("51973c3a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugApplicationNodes = &IID_IEnumDebugApplicationNodes_Value;
pub const IEnumDebugApplicationNodes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
                pprddp: ?*?*IDebugApplicationNode,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
                pprddp: ?*?*IDebugApplicationNode,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugApplicationNodes,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugApplicationNodes,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugApplicationNodes_Next(self: *const T, celt: u32, pprddp: ?*?*IDebugApplicationNode, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)), celt, pprddp, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugApplicationNodes_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugApplicationNodes_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugApplicationNodes_Clone(self: *const T, pperddp: ?*?*IEnumDebugApplicationNodes) HRESULT {
                return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)), pperddp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplications_Value = Guid.initString("51973c3b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumRemoteDebugApplications = &IID_IEnumRemoteDebugApplications_Value;
pub const IEnumRemoteDebugApplications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
                ppda: ?*?*IRemoteDebugApplication,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
                ppda: ?*?*IRemoteDebugApplication,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplications,
                ppessd: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplications,
                ppessd: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplications_Next(self: *const T, celt: u32, ppda: ?*?*IRemoteDebugApplication, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)), celt, ppda, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplications_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplications_Reset(self: *const T) HRESULT {
                return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplications_Clone(self: *const T, ppessd: ?*?*IEnumRemoteDebugApplications) HRESULT {
                return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)), ppessd);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplicationThreads_Value = Guid.initString("51973c3c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumRemoteDebugApplicationThreads = &IID_IEnumRemoteDebugApplicationThreads_Value;
pub const IEnumRemoteDebugApplicationThreads = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
                pprdat: ?*?*IRemoteDebugApplicationThread,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
                pprdat: ?*?*IRemoteDebugApplicationThread,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumRemoteDebugApplicationThreads,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumRemoteDebugApplicationThreads,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplicationThreads_Next(self: *const T, celt: u32, pprdat: ?*?*IRemoteDebugApplicationThread, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)), celt, pprdat, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplicationThreads_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplicationThreads_Reset(self: *const T) HRESULT {
                return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumRemoteDebugApplicationThreads_Clone(self: *const T, pperdat: ?*?*IEnumRemoteDebugApplicationThreads) HRESULT {
                return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)), pperdat);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugFormatter_Value = Guid.initString("51973c05-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugFormatter = &IID_IDebugFormatter_Value;
pub const IDebugFormatter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringForVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugFormatter,
                pvar: ?*VARIANT,
                nRadix: u32,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugFormatter,
                pvar: ?*VARIANT,
                nRadix: u32,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVariantForString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugFormatter,
                pwstrValue: ?[*:0]const u16,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugFormatter,
                pwstrValue: ?[*:0]const u16,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringForVarType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugFormatter,
                vt: u16,
                ptdescArrayType: ?*TYPEDESC,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugFormatter,
                vt: u16,
                ptdescArrayType: ?*TYPEDESC,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugFormatter_GetStringForVariant(self: *const T, pvar: ?*VARIANT, nRadix: u32, pbstrValue: ?*?BSTR) HRESULT {
                return @as(*const IDebugFormatter.VTable, @ptrCast(self.vtable)).GetStringForVariant(@as(*const IDebugFormatter, @ptrCast(self)), pvar, nRadix, pbstrValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugFormatter_GetVariantForString(self: *const T, pwstrValue: ?[*:0]const u16, pvar: ?*VARIANT) HRESULT {
                return @as(*const IDebugFormatter.VTable, @ptrCast(self.vtable)).GetVariantForString(@as(*const IDebugFormatter, @ptrCast(self)), pwstrValue, pvar);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugFormatter_GetStringForVarType(self: *const T, vt: u16, ptdescArrayType: ?*TYPEDESC, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IDebugFormatter.VTable, @ptrCast(self.vtable)).GetStringForVarType(@as(*const IDebugFormatter, @ptrCast(self)), vt, ptdescArrayType, pbstr);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleConnectionPoint_Value = Guid.initString("51973c3e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_ISimpleConnectionPoint = &IID_ISimpleConnectionPoint_Value;
pub const ISimpleConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleConnectionPoint,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleConnectionPoint,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DescribeEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleConnectionPoint,
                iEvent: u32,
                cEvents: u32,
                prgid: [*]i32,
                prgbstr: [*]?BSTR,
                pcEventsFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleConnectionPoint,
                iEvent: u32,
                cEvents: u32,
                prgid: [*]i32,
                prgbstr: [*]?BSTR,
                pcEventsFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleConnectionPoint,
                pdisp: ?*IDispatch,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleConnectionPoint,
                pdisp: ?*IDispatch,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const ISimpleConnectionPoint,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const ISimpleConnectionPoint,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleConnectionPoint_GetEventCount(self: *const T, pulCount: ?*u32) HRESULT {
                return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).GetEventCount(@as(*const ISimpleConnectionPoint, @ptrCast(self)), pulCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleConnectionPoint_DescribeEvents(self: *const T, iEvent: u32, cEvents: u32, prgid: [*]i32, prgbstr: [*]?BSTR, pcEventsFetched: ?*u32) HRESULT {
                return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).DescribeEvents(@as(*const ISimpleConnectionPoint, @ptrCast(self)), iEvent, cEvents, prgid, prgbstr, pcEventsFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleConnectionPoint_Advise(self: *const T, pdisp: ?*IDispatch, pdwCookie: ?*u32) HRESULT {
                return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).Advise(@as(*const ISimpleConnectionPoint, @ptrCast(self)), pdisp, pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn ISimpleConnectionPoint_Unadvise(self: *const T, dwCookie: u32) HRESULT {
                return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const ISimpleConnectionPoint, @ptrCast(self)), dwCookie);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHelper_Value = Guid.initString("51973c3f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugHelper = &IID_IDebugHelper_Value;
pub const IDebugHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyBrowser: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]const u16,
                pdat: ?*IDebugApplicationThread,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]const u16,
                pdat: ?*IDebugApplicationThread,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePropertyBrowserEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]const u16,
                pdat: ?*IDebugApplicationThread,
                pdf: ?*IDebugFormatter,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]const u16,
                pdat: ?*IDebugApplicationThread,
                pdf: ?*IDebugFormatter,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSimpleConnectionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugHelper,
                pdisp: ?*IDispatch,
                ppscp: ?*?*ISimpleConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugHelper,
                pdisp: ?*IDispatch,
                ppscp: ?*?*ISimpleConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHelper_CreatePropertyBrowser(self: *const T, pvar: ?*VARIANT, bstrName: ?[*:0]const u16, pdat: ?*IDebugApplicationThread, ppdob: ?*?*IDebugProperty) HRESULT {
                return @as(*const IDebugHelper.VTable, @ptrCast(self.vtable)).CreatePropertyBrowser(@as(*const IDebugHelper, @ptrCast(self)), pvar, bstrName, pdat, ppdob);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHelper_CreatePropertyBrowserEx(self: *const T, pvar: ?*VARIANT, bstrName: ?[*:0]const u16, pdat: ?*IDebugApplicationThread, pdf: ?*IDebugFormatter, ppdob: ?*?*IDebugProperty) HRESULT {
                return @as(*const IDebugHelper.VTable, @ptrCast(self.vtable)).CreatePropertyBrowserEx(@as(*const IDebugHelper, @ptrCast(self)), pvar, bstrName, pdat, pdf, ppdob);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugHelper_CreateSimpleConnectionPoint(self: *const T, pdisp: ?*IDispatch, ppscp: ?*?*ISimpleConnectionPoint) HRESULT {
                return @as(*const IDebugHelper.VTable, @ptrCast(self.vtable)).CreateSimpleConnectionPoint(@as(*const IDebugHelper, @ptrCast(self)), pdisp, ppscp);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExpressionContexts_Value = Guid.initString("51973c40-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugExpressionContexts = &IID_IEnumDebugExpressionContexts_Value;
pub const IEnumDebugExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
                ppdec: ?*?*IDebugExpressionContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
                ppdec: ?*?*IDebugExpressionContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumDebugExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumDebugExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExpressionContexts_Next(self: *const T, celt: u32, ppdec: ?*?*IDebugExpressionContext, pceltFetched: ?*u32) HRESULT {
                return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)), celt, ppdec, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExpressionContexts_Skip(self: *const T, celt: u32) HRESULT {
                return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)), celt);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExpressionContexts_Reset(self: *const T) HRESULT {
                return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumDebugExpressionContexts_Clone(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) HRESULT {
                return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)), ppedec);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideExpressionContexts_Value = Guid.initString("51973c41-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IProvideExpressionContexts = &IID_IProvideExpressionContexts_Value;
pub const IProvideExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumExpressionContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IProvideExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IProvideExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IProvideExpressionContexts_EnumExpressionContexts(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) HRESULT {
                return @as(*const IProvideExpressionContexts.VTable, @ptrCast(self.vtable)).EnumExpressionContexts(@as(*const IProvideExpressionContexts, @ptrCast(self)), ppedec);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_SCRIPT_TYPE = enum(i32) {
    USER = 0,
    DYNAMIC = 1,
    NATIVE = 2,
    DOM = 3,
};
pub const PROFILER_SCRIPT_TYPE_USER = PROFILER_SCRIPT_TYPE.USER;
pub const PROFILER_SCRIPT_TYPE_DYNAMIC = PROFILER_SCRIPT_TYPE.DYNAMIC;
pub const PROFILER_SCRIPT_TYPE_NATIVE = PROFILER_SCRIPT_TYPE.NATIVE;
pub const PROFILER_SCRIPT_TYPE_DOM = PROFILER_SCRIPT_TYPE.DOM;

pub const PROFILER_EVENT_MASK = enum(u32) {
    SCRIPT_FUNCTION_CALL = 1,
    NATIVE_FUNCTION_CALL = 2,
    DOM_FUNCTION_CALL = 4,
    ALL = 3,
    ALL_WITH_DOM = 7,
    _,
    pub fn initFlags(o: struct {
        SCRIPT_FUNCTION_CALL: u1 = 0,
        NATIVE_FUNCTION_CALL: u1 = 0,
        DOM_FUNCTION_CALL: u1 = 0,
        ALL: u1 = 0,
        ALL_WITH_DOM: u1 = 0,
    }) PROFILER_EVENT_MASK {
        return @as(PROFILER_EVENT_MASK, @enumFromInt((if (o.SCRIPT_FUNCTION_CALL == 1) @intFromEnum(PROFILER_EVENT_MASK.SCRIPT_FUNCTION_CALL) else 0) | (if (o.NATIVE_FUNCTION_CALL == 1) @intFromEnum(PROFILER_EVENT_MASK.NATIVE_FUNCTION_CALL) else 0) | (if (o.DOM_FUNCTION_CALL == 1) @intFromEnum(PROFILER_EVENT_MASK.DOM_FUNCTION_CALL) else 0) | (if (o.ALL == 1) @intFromEnum(PROFILER_EVENT_MASK.ALL) else 0) | (if (o.ALL_WITH_DOM == 1) @intFromEnum(PROFILER_EVENT_MASK.ALL_WITH_DOM) else 0)));
    }
};
pub const PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL = PROFILER_EVENT_MASK.SCRIPT_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL = PROFILER_EVENT_MASK.NATIVE_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL = PROFILER_EVENT_MASK.DOM_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL = PROFILER_EVENT_MASK.ALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL_WITH_DOM = PROFILER_EVENT_MASK.ALL_WITH_DOM;

const IID_IActiveScriptProfilerControl_Value = Guid.initString("784b5ff0-69b0-47d1-a7dc-2518f4230e90");
pub const IID_IActiveScriptProfilerControl = &IID_IActiveScriptProfilerControl_Value;
pub const IActiveScriptProfilerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProfiling: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl,
                clsidProfilerObject: ?*const Guid,
                dwEventMask: u32,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl,
                clsidProfilerObject: ?*const Guid,
                dwEventMask: u32,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProfilerEventMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl,
                dwEventMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl,
                dwEventMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopProfiling: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl,
                hrShutdownReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl,
                hrShutdownReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl_StartProfiling(self: *const T, clsidProfilerObject: ?*const Guid, dwEventMask: u32, dwContext: u32) HRESULT {
                return @as(*const IActiveScriptProfilerControl.VTable, @ptrCast(self.vtable)).StartProfiling(@as(*const IActiveScriptProfilerControl, @ptrCast(self)), clsidProfilerObject, dwEventMask, dwContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl_SetProfilerEventMask(self: *const T, dwEventMask: u32) HRESULT {
                return @as(*const IActiveScriptProfilerControl.VTable, @ptrCast(self.vtable)).SetProfilerEventMask(@as(*const IActiveScriptProfilerControl, @ptrCast(self)), dwEventMask);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl_StopProfiling(self: *const T, hrShutdownReason: HRESULT) HRESULT {
                return @as(*const IActiveScriptProfilerControl.VTable, @ptrCast(self.vtable)).StopProfiling(@as(*const IActiveScriptProfilerControl, @ptrCast(self)), hrShutdownReason);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl2_Value = Guid.initString("47810165-498f-40be-94f1-653557e9e7da");
pub const IID_IActiveScriptProfilerControl2 = &IID_IActiveScriptProfilerControl2_Value;
pub const IActiveScriptProfilerControl2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl.VTable,
        CompleteProfilerStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareProfilerStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptProfilerControl.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl2_CompleteProfilerStart(self: *const T) HRESULT {
                return @as(*const IActiveScriptProfilerControl2.VTable, @ptrCast(self.vtable)).CompleteProfilerStart(@as(*const IActiveScriptProfilerControl2, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl2_PrepareProfilerStop(self: *const T) HRESULT {
                return @as(*const IActiveScriptProfilerControl2.VTable, @ptrCast(self.vtable)).PrepareProfilerStop(@as(*const IActiveScriptProfilerControl2, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_HEAP_OBJECT_FLAGS = enum(u32) {
    NEW_OBJECT = 1,
    IS_ROOT = 2,
    SITE_CLOSED = 4,
    EXTERNAL = 8,
    EXTERNAL_UNKNOWN = 16,
    EXTERNAL_DISPATCH = 32,
    SIZE_APPROXIMATE = 64,
    SIZE_UNAVAILABLE = 128,
    NEW_STATE_UNAVAILABLE = 256,
    WINRT_INSTANCE = 512,
    WINRT_RUNTIMECLASS = 1024,
    WINRT_DELEGATE = 2048,
    WINRT_NAMESPACE = 4096,
    _,
    pub fn initFlags(o: struct {
        NEW_OBJECT: u1 = 0,
        IS_ROOT: u1 = 0,
        SITE_CLOSED: u1 = 0,
        EXTERNAL: u1 = 0,
        EXTERNAL_UNKNOWN: u1 = 0,
        EXTERNAL_DISPATCH: u1 = 0,
        SIZE_APPROXIMATE: u1 = 0,
        SIZE_UNAVAILABLE: u1 = 0,
        NEW_STATE_UNAVAILABLE: u1 = 0,
        WINRT_INSTANCE: u1 = 0,
        WINRT_RUNTIMECLASS: u1 = 0,
        WINRT_DELEGATE: u1 = 0,
        WINRT_NAMESPACE: u1 = 0,
    }) PROFILER_HEAP_OBJECT_FLAGS {
        return @as(PROFILER_HEAP_OBJECT_FLAGS, @enumFromInt((if (o.NEW_OBJECT == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.NEW_OBJECT) else 0) | (if (o.IS_ROOT == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.IS_ROOT) else 0) | (if (o.SITE_CLOSED == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.SITE_CLOSED) else 0) | (if (o.EXTERNAL == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL) else 0) | (if (o.EXTERNAL_UNKNOWN == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_UNKNOWN) else 0) | (if (o.EXTERNAL_DISPATCH == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_DISPATCH) else 0) | (if (o.SIZE_APPROXIMATE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.SIZE_APPROXIMATE) else 0) | (if (o.SIZE_UNAVAILABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.SIZE_UNAVAILABLE) else 0) | (if (o.NEW_STATE_UNAVAILABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.NEW_STATE_UNAVAILABLE) else 0) | (if (o.WINRT_INSTANCE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_INSTANCE) else 0) | (if (o.WINRT_RUNTIMECLASS == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_RUNTIMECLASS) else 0) | (if (o.WINRT_DELEGATE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_DELEGATE) else 0) | (if (o.WINRT_NAMESPACE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_NAMESPACE) else 0)));
    }
};
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_OBJECT = PROFILER_HEAP_OBJECT_FLAGS.NEW_OBJECT;
pub const PROFILER_HEAP_OBJECT_FLAGS_IS_ROOT = PROFILER_HEAP_OBJECT_FLAGS.IS_ROOT;
pub const PROFILER_HEAP_OBJECT_FLAGS_SITE_CLOSED = PROFILER_HEAP_OBJECT_FLAGS.SITE_CLOSED;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_UNKNOWN = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_UNKNOWN;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_DISPATCH = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_DISPATCH;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_APPROXIMATE = PROFILER_HEAP_OBJECT_FLAGS.SIZE_APPROXIMATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_UNAVAILABLE = PROFILER_HEAP_OBJECT_FLAGS.SIZE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_STATE_UNAVAILABLE = PROFILER_HEAP_OBJECT_FLAGS.NEW_STATE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_INSTANCE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_INSTANCE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_RUNTIMECLASS = PROFILER_HEAP_OBJECT_FLAGS.WINRT_RUNTIMECLASS;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_DELEGATE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_DELEGATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_NAMESPACE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_NAMESPACE;

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE = enum(i32) {
    PROTOTYPE = 1,
    FUNCTION_NAME = 2,
    SCOPE_LIST = 3,
    INTERNAL_PROPERTY = 4,
    NAME_PROPERTIES = 5,
    INDEX_PROPERTIES = 6,
    ELEMENT_ATTRIBUTES_SIZE = 7,
    ELEMENT_TEXT_CHILDREN_SIZE = 8,
    RELATIONSHIPS = 9,
    WINRTEVENTS = 10,
    WEAKMAP_COLLECTION_LIST = 11,
    MAP_COLLECTION_LIST = 12,
    SET_COLLECTION_LIST = 13,
    // MAX_VALUE = 13, this enum value conflicts with SET_COLLECTION_LIST
};
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_PROTOTYPE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.PROTOTYPE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_FUNCTION_NAME = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.FUNCTION_NAME;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SCOPE_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SCOPE_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INTERNAL_PROPERTY = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.INTERNAL_PROPERTY;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_NAME_PROPERTIES = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.NAME_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INDEX_PROPERTIES = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.INDEX_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_ATTRIBUTES_SIZE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.ELEMENT_ATTRIBUTES_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_TEXT_CHILDREN_SIZE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.ELEMENT_TEXT_CHILDREN_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_RELATIONSHIPS = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.RELATIONSHIPS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WINRTEVENTS = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.WINRTEVENTS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WEAKMAP_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.WEAKMAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAP_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.MAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SET_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SET_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAX_VALUE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SET_COLLECTION_LIST;

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS = enum(u32) {
    NONE = 0,
    IS_GET_ACCESSOR = 65536,
    IS_SET_ACCESSOR = 131072,
    LET_VARIABLE = 262144,
    CONST_VARIABLE = 524288,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        IS_GET_ACCESSOR: u1 = 0,
        IS_SET_ACCESSOR: u1 = 0,
        LET_VARIABLE: u1 = 0,
        CONST_VARIABLE: u1 = 0,
    }) PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS {
        return @as(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.NONE) else 0) | (if (o.IS_GET_ACCESSOR == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_GET_ACCESSOR) else 0) | (if (o.IS_SET_ACCESSOR == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_SET_ACCESSOR) else 0) | (if (o.LET_VARIABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.LET_VARIABLE) else 0) | (if (o.CONST_VARIABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.CONST_VARIABLE) else 0)));
    }
};
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_NONE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.NONE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_GET_ACCESSOR = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_GET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_SET_ACCESSOR = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_SET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_LET_VARIABLE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.LET_VARIABLE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_CONST_VARIABLE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.CONST_VARIABLE;

pub const PROFILER_HEAP_ENUM_FLAGS = enum(u32) {
    NONE = 0,
    STORE_RELATIONSHIP_FLAGS = 1,
    SUBSTRINGS = 2,
    RELATIONSHIP_SUBSTRINGS = 3,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        STORE_RELATIONSHIP_FLAGS: u1 = 0,
        SUBSTRINGS: u1 = 0,
        RELATIONSHIP_SUBSTRINGS: u1 = 0,
    }) PROFILER_HEAP_ENUM_FLAGS {
        return @as(PROFILER_HEAP_ENUM_FLAGS, @enumFromInt((if (o.NONE == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.NONE) else 0) | (if (o.STORE_RELATIONSHIP_FLAGS == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.STORE_RELATIONSHIP_FLAGS) else 0) | (if (o.SUBSTRINGS == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.SUBSTRINGS) else 0) | (if (o.RELATIONSHIP_SUBSTRINGS == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.RELATIONSHIP_SUBSTRINGS) else 0)));
    }
};
pub const PROFILER_HEAP_ENUM_FLAGS_NONE = PROFILER_HEAP_ENUM_FLAGS.NONE;
pub const PROFILER_HEAP_ENUM_FLAGS_STORE_RELATIONSHIP_FLAGS = PROFILER_HEAP_ENUM_FLAGS.STORE_RELATIONSHIP_FLAGS;
pub const PROFILER_HEAP_ENUM_FLAGS_SUBSTRINGS = PROFILER_HEAP_ENUM_FLAGS.SUBSTRINGS;
pub const PROFILER_HEAP_ENUM_FLAGS_RELATIONSHIP_SUBSTRINGS = PROFILER_HEAP_ENUM_FLAGS.RELATIONSHIP_SUBSTRINGS;

pub const PROFILER_HEAP_OBJECT_SCOPE_LIST = extern struct {
    count: u32,
    scopes: [1]usize,
};

pub const PROFILER_RELATIONSHIP_INFO = enum(i32) {
    NUMBER = 1,
    STRING = 2,
    HEAP_OBJECT = 3,
    EXTERNAL_OBJECT = 4,
    BSTR = 5,
    SUBSTRING = 6,
};
pub const PROFILER_PROPERTY_TYPE_NUMBER = PROFILER_RELATIONSHIP_INFO.NUMBER;
pub const PROFILER_PROPERTY_TYPE_STRING = PROFILER_RELATIONSHIP_INFO.STRING;
pub const PROFILER_PROPERTY_TYPE_HEAP_OBJECT = PROFILER_RELATIONSHIP_INFO.HEAP_OBJECT;
pub const PROFILER_PROPERTY_TYPE_EXTERNAL_OBJECT = PROFILER_RELATIONSHIP_INFO.EXTERNAL_OBJECT;
pub const PROFILER_PROPERTY_TYPE_BSTR = PROFILER_RELATIONSHIP_INFO.BSTR;
pub const PROFILER_PROPERTY_TYPE_SUBSTRING = PROFILER_RELATIONSHIP_INFO.SUBSTRING;

pub const PROFILER_PROPERTY_TYPE_SUBSTRING_INFO = extern struct {
    length: u32,
    value: ?[*:0]const u16,
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP = extern struct {
    relationshipId: u32,
    relationshipInfo: PROFILER_RELATIONSHIP_INFO,
    Anonymous: extern union {
        numberValue: f64,
        stringValue: ?[*:0]const u16,
        bstrValue: ?BSTR,
        objectId: usize,
        externalObjectAddress: ?*anyopaque,
        subString: ?*PROFILER_PROPERTY_TYPE_SUBSTRING_INFO,
    },
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST = extern struct {
    count: u32,
    elements: [1]PROFILER_HEAP_OBJECT_RELATIONSHIP,
};

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO = extern struct {
    infoType: PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE,
    Anonymous: extern union {
        prototype: usize,
        functionName: ?[*:0]const u16,
        elementAttributesSize: u32,
        elementTextChildrenSize: u32,
        scopeList: ?*PROFILER_HEAP_OBJECT_SCOPE_LIST,
        internalProperty: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP,
        namePropertyList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        indexPropertyList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        relationshipList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        eventList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        weakMapCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        mapCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        setCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
    },
};

pub const PROFILER_HEAP_OBJECT = extern struct {
    size: u32,
    Anonymous: extern union {
        objectId: usize,
        externalObjectAddress: ?*anyopaque,
    },
    typeNameId: u32,
    flags: u32,
    unused: u16,
    optionalInfoCount: u16,
};

const IID_IActiveScriptProfilerHeapEnum_Value = Guid.initString("32e4694e-0d37-419b-b93d-fa20ded6e8ea");
pub const IID_IActiveScriptProfilerHeapEnum = &IID_IActiveScriptProfilerHeapEnum_Value;
pub const IActiveScriptProfilerHeapEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptionalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerHeapEnum,
                heapObject: ?*PROFILER_HEAP_OBJECT,
                celt: u32,
                optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerHeapEnum,
                heapObject: ?*PROFILER_HEAP_OBJECT,
                celt: u32,
                optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeObjectAndOptionalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameIdMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerHeapEnum,
                pNameList: [*]?*?*?PWSTR,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerHeapEnum,
                pNameList: [*]?*?*?PWSTR,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerHeapEnum_Next(self: *const T, celt: u32, heapObjects: [*]?*PROFILER_HEAP_OBJECT, pceltFetched: ?*u32) HRESULT {
                return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), celt, heapObjects, pceltFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerHeapEnum_GetOptionalInfo(self: *const T, heapObject: ?*PROFILER_HEAP_OBJECT, celt: u32, optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO) HRESULT {
                return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).GetOptionalInfo(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), heapObject, celt, optionalInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerHeapEnum_FreeObjectAndOptionalInfo(self: *const T, celt: u32, heapObjects: [*]?*PROFILER_HEAP_OBJECT) HRESULT {
                return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).FreeObjectAndOptionalInfo(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), celt, heapObjects);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerHeapEnum_GetNameIdMap(self: *const T, pNameList: [*]?*?*?PWSTR, pcelt: ?*u32) HRESULT {
                return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).GetNameIdMap(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), pNameList, pcelt);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl3_Value = Guid.initString("0b403015-f381-4023-a5d0-6fed076de716");
pub const IID_IActiveScriptProfilerControl3 = &IID_IActiveScriptProfilerControl3_Value;
pub const IActiveScriptProfilerControl3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl2.VTable,
        EnumHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl3,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl3,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptProfilerControl2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl3_EnumHeap(self: *const T, ppEnum: ?*?*IActiveScriptProfilerHeapEnum) HRESULT {
                return @as(*const IActiveScriptProfilerControl3.VTable, @ptrCast(self.vtable)).EnumHeap(@as(*const IActiveScriptProfilerControl3, @ptrCast(self)), ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_HEAP_SUMMARY_VERSION = enum(i32) {
    @"1" = 1,
};
pub const PROFILER_HEAP_SUMMARY_VERSION_1 = PROFILER_HEAP_SUMMARY_VERSION.@"1";

pub const PROFILER_HEAP_SUMMARY = extern struct {
    version: PROFILER_HEAP_SUMMARY_VERSION,
    totalHeapSize: u32,
};

const IID_IActiveScriptProfilerControl4_Value = Guid.initString("160f94fd-9dbc-40d4-9eac-2b71db3132f4");
pub const IID_IActiveScriptProfilerControl4 = &IID_IActiveScriptProfilerControl4_Value;
pub const IActiveScriptProfilerControl4 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl3.VTable,
        SummarizeHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl4,
                heapSummary: ?*PROFILER_HEAP_SUMMARY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl4,
                heapSummary: ?*PROFILER_HEAP_SUMMARY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptProfilerControl3.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl4_SummarizeHeap(self: *const T, heapSummary: ?*PROFILER_HEAP_SUMMARY) HRESULT {
                return @as(*const IActiveScriptProfilerControl4.VTable, @ptrCast(self.vtable)).SummarizeHeap(@as(*const IActiveScriptProfilerControl4, @ptrCast(self)), heapSummary);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl5_Value = Guid.initString("1c01a2d1-8f0f-46a5-9720-0d7ed2c62f0a");
pub const IID_IActiveScriptProfilerControl5 = &IID_IActiveScriptProfilerControl5_Value;
pub const IActiveScriptProfilerControl5 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl4.VTable,
        EnumHeap2: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerControl5,
                enumFlags: PROFILER_HEAP_ENUM_FLAGS,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerControl5,
                enumFlags: PROFILER_HEAP_ENUM_FLAGS,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptProfilerControl4.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerControl5_EnumHeap2(self: *const T, enumFlags: PROFILER_HEAP_ENUM_FLAGS, ppEnum: ?*?*IActiveScriptProfilerHeapEnum) HRESULT {
                return @as(*const IActiveScriptProfilerControl5.VTable, @ptrCast(self.vtable)).EnumHeap2(@as(*const IActiveScriptProfilerControl5, @ptrCast(self)), enumFlags, ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback_Value = Guid.initString("740eca23-7d9d-42e5-ba9d-f8b24b1c7a9b");
pub const IID_IActiveScriptProfilerCallback = &IID_IActiveScriptProfilerCallback_Value;
pub const IActiveScriptProfilerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback,
                hrReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback,
                hrReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScriptCompiled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                type: PROFILER_SCRIPT_TYPE,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                type: PROFILER_SCRIPT_TYPE,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FunctionCompiled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback,
                functionId: i32,
                scriptId: i32,
                pwszFunctionName: ?[*:0]const u16,
                pwszFunctionNameHint: ?[*:0]const u16,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback,
                functionId: i32,
                scriptId: i32,
                pwszFunctionName: ?[*:0]const u16,
                pwszFunctionNameHint: ?[*:0]const u16,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFunctionEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFunctionExit: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback_Initialize(self: *const T, dwContext: u32) HRESULT {
                return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), dwContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback_Shutdown(self: *const T, hrReason: HRESULT) HRESULT {
                return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), hrReason);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback_ScriptCompiled(self: *const T, scriptId: i32, type_: PROFILER_SCRIPT_TYPE, pIDebugDocumentContext: ?*IUnknown) HRESULT {
                return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).ScriptCompiled(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), scriptId, type_, pIDebugDocumentContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback_FunctionCompiled(self: *const T, functionId: i32, scriptId: i32, pwszFunctionName: ?[*:0]const u16, pwszFunctionNameHint: ?[*:0]const u16, pIDebugDocumentContext: ?*IUnknown) HRESULT {
                return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).FunctionCompiled(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, pIDebugDocumentContext);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback_OnFunctionEnter(self: *const T, scriptId: i32, functionId: i32) HRESULT {
                return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).OnFunctionEnter(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), scriptId, functionId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback_OnFunctionExit(self: *const T, scriptId: i32, functionId: i32) HRESULT {
                return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).OnFunctionExit(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), scriptId, functionId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback2_Value = Guid.initString("31b7f8ad-a637-409c-b22f-040995b6103d");
pub const IID_IActiveScriptProfilerCallback2 = &IID_IActiveScriptProfilerCallback2_Value;
pub const IActiveScriptProfilerCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback.VTable,
        OnFunctionEnterByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFunctionExitByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptProfilerCallback.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback2_OnFunctionEnterByName(self: *const T, pwszFunctionName: ?[*:0]const u16, type_: PROFILER_SCRIPT_TYPE) HRESULT {
                return @as(*const IActiveScriptProfilerCallback2.VTable, @ptrCast(self.vtable)).OnFunctionEnterByName(@as(*const IActiveScriptProfilerCallback2, @ptrCast(self)), pwszFunctionName, type_);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback2_OnFunctionExitByName(self: *const T, pwszFunctionName: ?[*:0]const u16, type_: PROFILER_SCRIPT_TYPE) HRESULT {
                return @as(*const IActiveScriptProfilerCallback2.VTable, @ptrCast(self.vtable)).OnFunctionExitByName(@as(*const IActiveScriptProfilerCallback2, @ptrCast(self)), pwszFunctionName, type_);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback3_Value = Guid.initString("6ac5ad25-2037-4687-91df-b59979d93d73");
pub const IID_IActiveScriptProfilerCallback3 = &IID_IActiveScriptProfilerCallback3_Value;
pub const IActiveScriptProfilerCallback3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback2.VTable,
        SetWebWorkerId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptProfilerCallback3,
                webWorkerId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptProfilerCallback3,
                webWorkerId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptProfilerCallback2.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptProfilerCallback3_SetWebWorkerId(self: *const T, webWorkerId: u32) HRESULT {
                return @as(*const IActiveScriptProfilerCallback3.VTable, @ptrCast(self.vtable)).SetWebWorkerId(@as(*const IActiveScriptProfilerCallback3, @ptrCast(self)), webWorkerId);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const IMAGEHLP_STATUS_REASON = enum(i32) {
    OutOfMemory = 0,
    RvaToVaFailed = 1,
    NoRoomInImage = 2,
    ImportModuleFailed = 3,
    ImportProcedureFailed = 4,
    ImportModule = 5,
    ImportProcedure = 6,
    Forwarder = 7,
    ForwarderNOT = 8,
    ImageModified = 9,
    ExpandFileHeaders = 10,
    ImageComplete = 11,
    MismatchedSymbols = 12,
    SymbolsNotUpdated = 13,
    ImportProcedure32 = 14,
    ImportProcedure64 = 15,
    Forwarder32 = 16,
    Forwarder64 = 17,
    ForwarderNOT32 = 18,
    ForwarderNOT64 = 19,
};
pub const BindOutOfMemory = IMAGEHLP_STATUS_REASON.OutOfMemory;
pub const BindRvaToVaFailed = IMAGEHLP_STATUS_REASON.RvaToVaFailed;
pub const BindNoRoomInImage = IMAGEHLP_STATUS_REASON.NoRoomInImage;
pub const BindImportModuleFailed = IMAGEHLP_STATUS_REASON.ImportModuleFailed;
pub const BindImportProcedureFailed = IMAGEHLP_STATUS_REASON.ImportProcedureFailed;
pub const BindImportModule = IMAGEHLP_STATUS_REASON.ImportModule;
pub const BindImportProcedure = IMAGEHLP_STATUS_REASON.ImportProcedure;
pub const BindForwarder = IMAGEHLP_STATUS_REASON.Forwarder;
pub const BindForwarderNOT = IMAGEHLP_STATUS_REASON.ForwarderNOT;
pub const BindImageModified = IMAGEHLP_STATUS_REASON.ImageModified;
pub const BindExpandFileHeaders = IMAGEHLP_STATUS_REASON.ExpandFileHeaders;
pub const BindImageComplete = IMAGEHLP_STATUS_REASON.ImageComplete;
pub const BindMismatchedSymbols = IMAGEHLP_STATUS_REASON.MismatchedSymbols;
pub const BindSymbolsNotUpdated = IMAGEHLP_STATUS_REASON.SymbolsNotUpdated;
pub const BindImportProcedure32 = IMAGEHLP_STATUS_REASON.ImportProcedure32;
pub const BindImportProcedure64 = IMAGEHLP_STATUS_REASON.ImportProcedure64;
pub const BindForwarder32 = IMAGEHLP_STATUS_REASON.Forwarder32;
pub const BindForwarder64 = IMAGEHLP_STATUS_REASON.Forwarder64;
pub const BindForwarderNOT32 = IMAGEHLP_STATUS_REASON.ForwarderNOT32;
pub const BindForwarderNOT64 = IMAGEHLP_STATUS_REASON.ForwarderNOT64;

pub const PIMAGEHLP_STATUS_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]const u8,
        DllName: ?[*:0]const u8,
        Va: usize,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]const u8,
        DllName: ?[*:0]const u8,
        Va: usize,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PIMAGEHLP_STATUS_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]const u8,
        DllName: ?[*:0]const u8,
        Va: u32,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]const u8,
        DllName: ?[*:0]const u8,
        Va: u32,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PIMAGEHLP_STATUS_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]const u8,
        DllName: ?[*:0]const u8,
        Va: u64,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]const u8,
        DllName: ?[*:0]const u8,
        Va: u64,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const DIGEST_FUNCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        refdata: ?*anyopaque,
        pData: ?*u8,
        dwLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        refdata: ?*anyopaque,
        pData: ?*u8,
        dwLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFIND_DEBUG_FILE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFIND_DEBUG_FILE_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFINDFILEINPATHCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        filename: ?[*:0]const u8,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        filename: ?[*:0]const u8,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFINDFILEINPATHCALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        filename: ?[*:0]const u16,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        filename: ?[*:0]const u16,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFIND_EXE_FILE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFIND_EXE_FILE_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        FileHandle: ?HANDLE,
        FileName: ?[*:0]const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PENUMDIRTREE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FilePath: ?[*:0]const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        FilePath: ?[*:0]const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PENUMDIRTREE_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        FilePath: ?[*:0]const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        FilePath: ?[*:0]const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const MODLOAD_DATA = extern struct {
    ssize: u32,
    ssig: MODLOAD_DATA_TYPE,
    data: ?*anyopaque,
    size: u32,
    flags: u32,
};

pub const MODLOAD_CVMISC = extern struct {
    oCV: u32,
    cCV: usize,
    oMisc: u32,
    cMisc: usize,
    dtImage: u32,
    cImage: u32,
};

pub const MODLOAD_PDBGUID_PDBAGE = extern struct {
    PdbGuid: Guid,
    PdbAge: u32,
};

pub const ADDRESS_MODE = enum(i32) {
    @"1616" = 0,
    @"1632" = 1,
    Real = 2,
    Flat = 3,
};
pub const AddrMode1616 = ADDRESS_MODE.@"1616";
pub const AddrMode1632 = ADDRESS_MODE.@"1632";
pub const AddrModeReal = ADDRESS_MODE.Real;
pub const AddrModeFlat = ADDRESS_MODE.Flat;

pub const ADDRESS64 = extern struct {
    Offset: u64,
    Segment: u16,
    Mode: ADDRESS_MODE,
};

pub const KDHELP64 = extern struct {
    Thread: u64,
    ThCallbackStack: u32,
    ThCallbackBStore: u32,
    NextCallback: u32,
    FramePointer: u32,
    KiCallUserMode: u64,
    KeUserCallbackDispatcher: u64,
    SystemRangeStart: u64,
    KiUserExceptionDispatcher: u64,
    StackBase: u64,
    StackLimit: u64,
    BuildVersion: u32,
    RetpolineStubFunctionTableSize: u32,
    RetpolineStubFunctionTable: u64,
    RetpolineStubOffset: u32,
    RetpolineStubSize: u32,
    Reserved0: [2]u64,
};

pub const STACKFRAME64 = extern struct {
    AddrPC: ADDRESS64,
    AddrReturn: ADDRESS64,
    AddrFrame: ADDRESS64,
    AddrStack: ADDRESS64,
    AddrBStore: ADDRESS64,
    FuncTableEntry: ?*anyopaque,
    Params: [4]u64,
    Far: BOOL,
    Virtual: BOOL,
    Reserved: [3]u64,
    KdHelp: KDHELP64,
};

pub const STACKFRAME_EX = extern struct {
    AddrPC: ADDRESS64,
    AddrReturn: ADDRESS64,
    AddrFrame: ADDRESS64,
    AddrStack: ADDRESS64,
    AddrBStore: ADDRESS64,
    FuncTableEntry: ?*anyopaque,
    Params: [4]u64,
    Far: BOOL,
    Virtual: BOOL,
    Reserved: [3]u64,
    KdHelp: KDHELP64,
    StackFrameSize: u32,
    InlineFrameContext: u32,
};

pub const PREAD_PROCESS_MEMORY_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        qwBaseAddress: u64,
        // TODO: what to do with BytesParamIndex 3?
        lpBuffer: ?*anyopaque,
        nSize: u32,
        lpNumberOfBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hProcess: ?HANDLE,
        qwBaseAddress: u64,
        // TODO: what to do with BytesParamIndex 3?
        lpBuffer: ?*anyopaque,
        nSize: u32,
        lpNumberOfBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PFUNCTION_TABLE_ACCESS_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ahProcess: ?HANDLE,
        AddrBase: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn (
        ahProcess: ?HANDLE,
        AddrBase: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
};

pub const PGET_MODULE_BASE_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        Address: u64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
    else => *const fn (
        hProcess: ?HANDLE,
        Address: u64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
};

pub const PTRANSLATE_ADDRESS_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        hThread: ?HANDLE,
        lpaddr: ?*ADDRESS64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
    else => *const fn (
        hProcess: ?HANDLE,
        hThread: ?HANDLE,
        lpaddr: ?*ADDRESS64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
};

pub const API_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    Revision: u16,
    Reserved: u16,
};

pub const PSYM_ENUMMODULES_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ModuleName: ?[*:0]const u8,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        ModuleName: ?[*:0]const u8,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMMODULES_CALLBACKW64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ModuleName: ?[*:0]const u16,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        ModuleName: ?[*:0]const u16,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PENUMLOADED_MODULES_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ModuleName: ?[*:0]const u8,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        ModuleName: ?[*:0]const u8,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PENUMLOADED_MODULES_CALLBACKW64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ModuleName: ?[*:0]const u16,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        ModuleName: ?[*:0]const u16,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMSYMBOLS_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        SymbolName: ?[*:0]const u8,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        SymbolName: ?[*:0]const u8,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMSYMBOLS_CALLBACK64W = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        SymbolName: ?[*:0]const u16,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        SymbolName: ?[*:0]const u16,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOL_REGISTERED_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        ActionCode: u32,
        CallbackData: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hProcess: ?HANDLE,
        ActionCode: u32,
        CallbackData: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOL_FUNCENTRY_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        AddrBase: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn (
        hProcess: ?HANDLE,
        AddrBase: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
};

pub const PSYMBOL_FUNCENTRY_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        AddrBase: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn (
        hProcess: ?HANDLE,
        AddrBase: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
};

pub const SYM_TYPE = enum(i32) {
    SymNone = 0,
    SymCoff = 1,
    SymCv = 2,
    SymPdb = 3,
    SymExport = 4,
    SymDeferred = 5,
    SymSym = 6,
    SymDia = 7,
    SymVirtual = 8,
    NumSymTypes = 9,
};
pub const SymNone = SYM_TYPE.SymNone;
pub const SymCoff = SYM_TYPE.SymCoff;
pub const SymCv = SYM_TYPE.SymCv;
pub const SymPdb = SYM_TYPE.SymPdb;
pub const SymExport = SYM_TYPE.SymExport;
pub const SymDeferred = SYM_TYPE.SymDeferred;
pub const SymSym = SYM_TYPE.SymSym;
pub const SymDia = SYM_TYPE.SymDia;
pub const SymVirtual = SYM_TYPE.SymVirtual;
pub const NumSymTypes = SYM_TYPE.NumSymTypes;

pub const IMAGEHLP_SYMBOL64 = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    Size: u32,
    Flags: u32,
    MaxNameLength: u32,
    Name: [1]CHAR,
};

pub const IMAGEHLP_SYMBOL64_PACKAGE = extern struct {
    sym: IMAGEHLP_SYMBOL64,
    name: [2001]CHAR,
};

pub const IMAGEHLP_SYMBOLW64 = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    Size: u32,
    Flags: u32,
    MaxNameLength: u32,
    Name: [1]u16,
};

pub const IMAGEHLP_SYMBOLW64_PACKAGE = extern struct {
    sym: IMAGEHLP_SYMBOLW64,
    name: [2001]u16,
};

pub const IMAGEHLP_MODULE64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    ImageSize: u32,
    TimeDateStamp: u32,
    CheckSum: u32,
    NumSyms: u32,
    SymType: SYM_TYPE,
    ModuleName: [32]CHAR,
    ImageName: [256]CHAR,
    LoadedImageName: [256]CHAR,
    LoadedPdbName: [256]CHAR,
    CVSig: u32,
    CVData: [780]CHAR,
    PdbSig: u32,
    PdbSig70: Guid,
    PdbAge: u32,
    PdbUnmatched: BOOL,
    DbgUnmatched: BOOL,
    LineNumbers: BOOL,
    GlobalSymbols: BOOL,
    TypeInfo: BOOL,
    SourceIndexed: BOOL,
    Publics: BOOL,
    MachineType: u32,
    Reserved: u32,
};

pub const IMAGEHLP_MODULE64_EX = extern struct {
    Module: IMAGEHLP_MODULE64,
    RegionFlags: u32,
};

pub const IMAGEHLP_MODULEW64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    ImageSize: u32,
    TimeDateStamp: u32,
    CheckSum: u32,
    NumSyms: u32,
    SymType: SYM_TYPE,
    ModuleName: [32]u16,
    ImageName: [256]u16,
    LoadedImageName: [256]u16,
    LoadedPdbName: [256]u16,
    CVSig: u32,
    CVData: [780]u16,
    PdbSig: u32,
    PdbSig70: Guid,
    PdbAge: u32,
    PdbUnmatched: BOOL,
    DbgUnmatched: BOOL,
    LineNumbers: BOOL,
    GlobalSymbols: BOOL,
    TypeInfo: BOOL,
    SourceIndexed: BOOL,
    Publics: BOOL,
    MachineType: u32,
    Reserved: u32,
};

pub const IMAGEHLP_MODULEW64_EX = extern struct {
    Module: IMAGEHLP_MODULEW64,
    RegionFlags: u32,
};

pub const IMAGEHLP_LINE64 = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    LineNumber: u32,
    FileName: ?[*]u8,
    Address: u64,
};

pub const IMAGEHLP_LINEW64 = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    LineNumber: u32,
    FileName: ?PWSTR,
    Address: u64,
};

pub const SOURCEFILE = extern struct {
    ModBase: u64,
    FileName: ?[*]u8,
};

pub const SOURCEFILEW = extern struct {
    ModBase: u64,
    FileName: ?PWSTR,
};

pub const IMAGEHLP_CBA_READ_MEMORY = extern struct {
    addr: u64,
    buf: ?*anyopaque,
    bytes: u32,
    bytesread: ?*u32,
};

pub const IMAGEHLP_CBA_EVENT = extern struct {
    severity: IMAGEHLP_CBA_EVENT_SEVERITY,
    code: u32,
    desc: ?[*]u8,
    object: ?*anyopaque,
};

pub const IMAGEHLP_CBA_EVENTW = extern struct {
    severity: IMAGEHLP_CBA_EVENT_SEVERITY,
    code: u32,
    desc: ?[*:0]const u16,
    object: ?*anyopaque,
};

pub const IMAGEHLP_DEFERRED_SYMBOL_LOAD64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    CheckSum: u32,
    TimeDateStamp: u32,
    FileName: [260]CHAR,
    Reparse: BOOLEAN,
    hFile: ?HANDLE,
    Flags: u32,
};

pub const IMAGEHLP_DEFERRED_SYMBOL_LOADW64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    CheckSum: u32,
    TimeDateStamp: u32,
    FileName: [261]u16,
    Reparse: BOOLEAN,
    hFile: ?HANDLE,
    Flags: u32,
};

pub const IMAGEHLP_DUPLICATE_SYMBOL64 = extern struct {
    SizeOfStruct: u32,
    NumberOfDups: u32,
    Symbol: ?*IMAGEHLP_SYMBOL64,
    SelectedSymbol: u32,
};

pub const _IMAGEHLP_JIT_SYMBOL_MAP = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    BaseOfImage: u64,
};

pub const IMAGEHLP_HD_TYPE = enum(i32) {
    Base = 0,
    Sym = 1,
    Src = 2,
    Max = 3,
};
pub const hdBase = IMAGEHLP_HD_TYPE.Base;
pub const hdSym = IMAGEHLP_HD_TYPE.Sym;
pub const hdSrc = IMAGEHLP_HD_TYPE.Src;
pub const hdMax = IMAGEHLP_HD_TYPE.Max;

pub const OMAP = extern struct {
    rva: u32,
    rvaTo: u32,
};

pub const IMAGEHLP_EXTENDED_OPTIONS = enum(i32) {
    DISABLEACCESSTIMEUPDATE = 0,
    LASTVALIDDEBUGDIRECTORY = 1,
    NOIMPLICITPATTERNSEARCH = 2,
    NEVERLOADSYMBOLS = 3,
    MAX = 4,
};
pub const SYMOPT_EX_DISABLEACCESSTIMEUPDATE = IMAGEHLP_EXTENDED_OPTIONS.DISABLEACCESSTIMEUPDATE;
pub const SYMOPT_EX_LASTVALIDDEBUGDIRECTORY = IMAGEHLP_EXTENDED_OPTIONS.LASTVALIDDEBUGDIRECTORY;
pub const SYMOPT_EX_NOIMPLICITPATTERNSEARCH = IMAGEHLP_EXTENDED_OPTIONS.NOIMPLICITPATTERNSEARCH;
pub const SYMOPT_EX_NEVERLOADSYMBOLS = IMAGEHLP_EXTENDED_OPTIONS.NEVERLOADSYMBOLS;
pub const SYMOPT_EX_MAX = IMAGEHLP_EXTENDED_OPTIONS.MAX;

pub const PSYM_ENUMSOURCEFILES_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pSourceFile: ?*SOURCEFILE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        pSourceFile: ?*SOURCEFILE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMSOURCEFILES_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pSourceFile: ?*SOURCEFILEW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        pSourceFile: ?*SOURCEFILEW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const SRCCODEINFO = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    ModBase: u64,
    Obj: [261]CHAR,
    FileName: [261]CHAR,
    LineNumber: u32,
    Address: u64,
};

pub const SRCCODEINFOW = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    ModBase: u64,
    Obj: [261]u16,
    FileName: [261]u16,
    LineNumber: u32,
    Address: u64,
};

pub const PSYM_ENUMLINES_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        LineInfo: ?*SRCCODEINFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        LineInfo: ?*SRCCODEINFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMLINES_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        LineInfo: ?*SRCCODEINFOW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        LineInfo: ?*SRCCODEINFOW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PENUMSOURCEFILETOKENSCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        token: ?*anyopaque,
        size: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        token: ?*anyopaque,
        size: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const IMAGEHLP_SYMBOL_SRC = extern struct {
    sizeofstruct: u32,
    type: u32,
    file: [260]CHAR,
};

pub const MODULE_TYPE_INFO = extern struct {
    dataLength: u16,
    leaf: u16,
    data: [1]u8,
};

pub const SYMBOL_INFO = extern struct {
    SizeOfStruct: u32,
    TypeIndex: u32,
    Reserved: [2]u64,
    Index: u32,
    Size: u32,
    ModBase: u64,
    Flags: SYMBOL_INFO_FLAGS,
    Value: u64,
    Address: u64,
    Register: u32,
    Scope: u32,
    Tag: u32,
    NameLen: u32,
    MaxNameLen: u32,
    Name: [1]CHAR,
};

pub const SYMBOL_INFO_PACKAGE = extern struct {
    si: SYMBOL_INFO,
    name: [2001]CHAR,
};

pub const SYMBOL_INFOW = extern struct {
    SizeOfStruct: u32,
    TypeIndex: u32,
    Reserved: [2]u64,
    Index: u32,
    Size: u32,
    ModBase: u64,
    Flags: SYMBOL_INFO_FLAGS,
    Value: u64,
    Address: u64,
    Register: u32,
    Scope: u32,
    Tag: u32,
    NameLen: u32,
    MaxNameLen: u32,
    Name: [1]u16,
};

pub const SYMBOL_INFO_PACKAGEW = extern struct {
    si: SYMBOL_INFOW,
    name: [2001]u16,
};

pub const IMAGEHLP_STACK_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    BackingStoreOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [5]u64,
    Virtual: BOOL,
    Reserved2: u32,
};

pub const PSYM_ENUMPROCESSES_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        hProcess: ?HANDLE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        hProcess: ?HANDLE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMERATESYMBOLS_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pSymInfo: ?*SYMBOL_INFO,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        pSymInfo: ?*SYMBOL_INFO,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYM_ENUMERATESYMBOLS_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pSymInfo: ?*SYMBOL_INFOW,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        pSymInfo: ?*SYMBOL_INFOW,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const IMAGEHLP_SYMBOL_TYPE_INFO = enum(i32) {
    TI_GET_SYMTAG = 0,
    TI_GET_SYMNAME = 1,
    TI_GET_LENGTH = 2,
    TI_GET_TYPE = 3,
    TI_GET_TYPEID = 4,
    TI_GET_BASETYPE = 5,
    TI_GET_ARRAYINDEXTYPEID = 6,
    TI_FINDCHILDREN = 7,
    TI_GET_DATAKIND = 8,
    TI_GET_ADDRESSOFFSET = 9,
    TI_GET_OFFSET = 10,
    TI_GET_VALUE = 11,
    TI_GET_COUNT = 12,
    TI_GET_CHILDRENCOUNT = 13,
    TI_GET_BITPOSITION = 14,
    TI_GET_VIRTUALBASECLASS = 15,
    TI_GET_VIRTUALTABLESHAPEID = 16,
    TI_GET_VIRTUALBASEPOINTEROFFSET = 17,
    TI_GET_CLASSPARENTID = 18,
    TI_GET_NESTED = 19,
    TI_GET_SYMINDEX = 20,
    TI_GET_LEXICALPARENT = 21,
    TI_GET_ADDRESS = 22,
    TI_GET_THISADJUST = 23,
    TI_GET_UDTKIND = 24,
    TI_IS_EQUIV_TO = 25,
    TI_GET_CALLING_CONVENTION = 26,
    TI_IS_CLOSE_EQUIV_TO = 27,
    TI_GTIEX_REQS_VALID = 28,
    TI_GET_VIRTUALBASEOFFSET = 29,
    TI_GET_VIRTUALBASEDISPINDEX = 30,
    TI_GET_IS_REFERENCE = 31,
    TI_GET_INDIRECTVIRTUALBASECLASS = 32,
    TI_GET_VIRTUALBASETABLETYPE = 33,
    TI_GET_OBJECTPOINTERTYPE = 34,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX = 35,
};
pub const TI_GET_SYMTAG = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMTAG;
pub const TI_GET_SYMNAME = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMNAME;
pub const TI_GET_LENGTH = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_LENGTH;
pub const TI_GET_TYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_TYPE;
pub const TI_GET_TYPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_TYPEID;
pub const TI_GET_BASETYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_BASETYPE;
pub const TI_GET_ARRAYINDEXTYPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ARRAYINDEXTYPEID;
pub const TI_FINDCHILDREN = IMAGEHLP_SYMBOL_TYPE_INFO.TI_FINDCHILDREN;
pub const TI_GET_DATAKIND = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_DATAKIND;
pub const TI_GET_ADDRESSOFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ADDRESSOFFSET;
pub const TI_GET_OFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_OFFSET;
pub const TI_GET_VALUE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VALUE;
pub const TI_GET_COUNT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_COUNT;
pub const TI_GET_CHILDRENCOUNT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CHILDRENCOUNT;
pub const TI_GET_BITPOSITION = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_BITPOSITION;
pub const TI_GET_VIRTUALBASECLASS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASECLASS;
pub const TI_GET_VIRTUALTABLESHAPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALTABLESHAPEID;
pub const TI_GET_VIRTUALBASEPOINTEROFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEPOINTEROFFSET;
pub const TI_GET_CLASSPARENTID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CLASSPARENTID;
pub const TI_GET_NESTED = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_NESTED;
pub const TI_GET_SYMINDEX = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMINDEX;
pub const TI_GET_LEXICALPARENT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_LEXICALPARENT;
pub const TI_GET_ADDRESS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ADDRESS;
pub const TI_GET_THISADJUST = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_THISADJUST;
pub const TI_GET_UDTKIND = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_UDTKIND;
pub const TI_IS_EQUIV_TO = IMAGEHLP_SYMBOL_TYPE_INFO.TI_IS_EQUIV_TO;
pub const TI_GET_CALLING_CONVENTION = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CALLING_CONVENTION;
pub const TI_IS_CLOSE_EQUIV_TO = IMAGEHLP_SYMBOL_TYPE_INFO.TI_IS_CLOSE_EQUIV_TO;
pub const TI_GTIEX_REQS_VALID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GTIEX_REQS_VALID;
pub const TI_GET_VIRTUALBASEOFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEOFFSET;
pub const TI_GET_VIRTUALBASEDISPINDEX = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEDISPINDEX;
pub const TI_GET_IS_REFERENCE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_IS_REFERENCE;
pub const TI_GET_INDIRECTVIRTUALBASECLASS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_INDIRECTVIRTUALBASECLASS;
pub const TI_GET_VIRTUALBASETABLETYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASETABLETYPE;
pub const TI_GET_OBJECTPOINTERTYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_OBJECTPOINTERTYPE;
pub const IMAGEHLP_SYMBOL_TYPE_INFO_MAX = IMAGEHLP_SYMBOL_TYPE_INFO.IMAGEHLP_SYMBOL_TYPE_INFO_MAX;

pub const TI_FINDCHILDREN_PARAMS = extern struct {
    Count: u32,
    Start: u32,
    ChildId: [1]u32,
};

pub const IMAGEHLP_GET_TYPE_INFO_PARAMS = extern struct {
    SizeOfStruct: u32,
    Flags: IMAGEHLP_GET_TYPE_INFO_FLAGS,
    NumIds: u32,
    TypeIds: ?*u32,
    TagFilter: u64,
    NumReqs: u32,
    ReqKinds: ?*IMAGEHLP_SYMBOL_TYPE_INFO,
    ReqOffsets: ?*usize,
    ReqSizes: ?*u32,
    ReqStride: usize,
    BufferSize: usize,
    Buffer: ?*anyopaque,
    EntriesMatched: u32,
    EntriesFilled: u32,
    TagsFound: u64,
    AllReqsValid: u64,
    NumReqsValid: u32,
    ReqsValid: ?*u64,
};

pub const SYMADDSOURCESTREAM = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const SYMADDSOURCESTREAMA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const SYMSRV_INDEX_INFO = extern struct {
    sizeofstruct: u32,
    file: [261]CHAR,
    stripped: BOOL,
    timestamp: u32,
    size: u32,
    dbgfile: [261]CHAR,
    pdbfile: [261]CHAR,
    guid: Guid,
    sig: u32,
    age: u32,
};

pub const SYMSRV_INDEX_INFOW = extern struct {
    sizeofstruct: u32,
    file: [261]u16,
    stripped: BOOL,
    timestamp: u32,
    size: u32,
    dbgfile: [261]u16,
    pdbfile: [261]u16,
    guid: Guid,
    sig: u32,
    age: u32,
};

pub const IMAGEHLP_SF_TYPE = enum(i32) {
    Image = 0,
    Dbg = 1,
    Pdb = 2,
    Mpd = 3,
    Max = 4,
};
pub const sfImage = IMAGEHLP_SF_TYPE.Image;
pub const sfDbg = IMAGEHLP_SF_TYPE.Dbg;
pub const sfPdb = IMAGEHLP_SF_TYPE.Pdb;
pub const sfMpd = IMAGEHLP_SF_TYPE.Mpd;
pub const sfMax = IMAGEHLP_SF_TYPE.Max;

pub const PDBGHELP_CREATE_USER_DUMP_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        DataType: u32,
        Data: ?*?*anyopaque,
        DataLength: ?*u32,
        UserData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        DataType: u32,
        Data: ?*?*anyopaque,
        DataLength: ?*u32,
        UserData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const SYMSRV_EXTENDED_OUTPUT_DATA = extern struct {
    sizeOfStruct: u32,
    version: u32,
    filePtrMsg: [261]u16,
};

pub const PSYMBOLSERVERPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERBYINDEXPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERBYINDEXPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERBYINDEXPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?[*:0]const u16,
        param3: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?[*:0]const u16,
        param3: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVEROPENPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERCLOSEPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSETOPTIONSPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSETOPTIONSWPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERCALLBACKPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETOPTIONSPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) usize,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) usize,
};

pub const PSYMBOLSERVERPINGPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERPINGPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERPINGPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETVERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*API_VERSION,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*API_VERSION,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERDELTANAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERDELTANAMEW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PWSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PWSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETSUPPLEMENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETSUPPLEMENTW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?[*:0]const u16,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?[*:0]const u16,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSTORESUPPLEMENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?[*:0]const u8,
        param3: ?PSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSTORESUPPLEMENTW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?[*:0]const u16,
        param3: ?PWSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?[*:0]const u16,
        param3: ?PWSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETINDEXSTRING = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETINDEXSTRINGW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSTOREFILE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
        param1: ?[*:0]const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSTOREFILEW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERISSTORE = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERISSTOREW = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERVERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) u32,
};

pub const PSYMBOLSERVERMESSAGEPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERWEXPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: ?*SYMSRV_EXTENDED_OUTPUT_DATA,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
        param1: ?[*:0]const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: ?*SYMSRV_EXTENDED_OUTPUT_DATA,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERPINGPROCWEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERGETOPTIONDATAPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        param0: usize,
        param1: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        param0: usize,
        param1: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const PSYMBOLSERVERSETHTTPAUTHHEADER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        pszAuthHeader: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn (
        pszAuthHeader: ?[*:0]const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
};

pub const LPCALL_BACK_USER_INTERRUPT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn () callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn () callconv(@import("std").os.windows.WINAPI) u32,
};

pub const DBGHELP_DATA_REPORT_STRUCT = extern struct {
    pBinPathNonExist: ?[*:0]const u16,
    pSymbolPathNonExist: ?[*:0]const u16,
};

const IID_IScriptNode_Value = Guid.initString("0aee2a94-bcbb-11d0-8c72-00c04fc2b085");
pub const IID_IScriptNode = &IID_IScriptNode_Value;
pub const IScriptNode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alive: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                ppsnParent: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                ppsnParent: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexInParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                pisn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                pisn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                pcsn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                pcsn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                isn: u32,
                ppsn: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                isn: u32,
                ppsn: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateChildEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                isn: u32,
                dwCookie: u32,
                pszDelimiter: ?[*:0]const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                isn: u32,
                dwCookie: u32,
                pszDelimiter: ?[*:0]const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateChildHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptNode,
                pszDefaultName: ?[*:0]const u16,
                prgpszNames: [*]?PWSTR,
                cpszNames: u32,
                pszEvent: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                ptiSignature: ?*ITypeInfo,
                iMethodSignature: u32,
                isn: u32,
                dwCookie: u32,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptNode,
                pszDefaultName: ?[*:0]const u16,
                prgpszNames: [*]?PWSTR,
                cpszNames: u32,
                pszEvent: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                ptiSignature: ?*ITypeInfo,
                iMethodSignature: u32,
                isn: u32,
                dwCookie: u32,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_Alive(self: *const T) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).Alive(@as(*const IScriptNode, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_Delete(self: *const T) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).Delete(@as(*const IScriptNode, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_GetParent(self: *const T, ppsnParent: ?*?*IScriptNode) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IScriptNode, @ptrCast(self)), ppsnParent);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_GetIndexInParent(self: *const T, pisn: ?*u32) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetIndexInParent(@as(*const IScriptNode, @ptrCast(self)), pisn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_GetCookie(self: *const T, pdwCookie: ?*u32) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const IScriptNode, @ptrCast(self)), pdwCookie);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_GetNumberOfChildren(self: *const T, pcsn: ?*u32) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetNumberOfChildren(@as(*const IScriptNode, @ptrCast(self)), pcsn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_GetChild(self: *const T, isn: u32, ppsn: ?*?*IScriptNode) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetChild(@as(*const IScriptNode, @ptrCast(self)), isn, ppsn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_GetLanguage(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IScriptNode, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_CreateChildEntry(self: *const T, isn: u32, dwCookie: u32, pszDelimiter: ?[*:0]const u16, ppse: ?*?*IScriptEntry) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).CreateChildEntry(@as(*const IScriptNode, @ptrCast(self)), isn, dwCookie, pszDelimiter, ppse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptNode_CreateChildHandler(self: *const T, pszDefaultName: ?[*:0]const u16, prgpszNames: [*]?PWSTR, cpszNames: u32, pszEvent: ?[*:0]const u16, pszDelimiter: ?[*:0]const u16, ptiSignature: ?*ITypeInfo, iMethodSignature: u32, isn: u32, dwCookie: u32, ppse: ?*?*IScriptEntry) HRESULT {
                return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).CreateChildHandler(@as(*const IScriptNode, @ptrCast(self)), pszDefaultName, prgpszNames, cpszNames, pszEvent, pszDelimiter, ptiSignature, iMethodSignature, isn, dwCookie, ppse);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptEntry_Value = Guid.initString("0aee2a95-bcbb-11d0-8c72-00c04fc2b085");
pub const IID_IScriptEntry = &IID_IScriptEntry_Value;
pub const IScriptEntry = extern struct {
    pub const VTable = extern struct {
        base: IScriptNode.VTable,
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                ppti: ?*?*ITypeInfo,
                piMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                ppti: ?*?*ITypeInfo,
                piMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                pti: ?*ITypeInfo,
                iMethod: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                pti: ?*ITypeInfo,
                iMethod: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptEntry,
                pichMin: ?*u32,
                pcch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptEntry,
                pichMin: ?*u32,
                pcch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IScriptNode.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_GetText(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetText(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_SetText(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetText(@as(*const IScriptEntry, @ptrCast(self)), psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_GetBody(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetBody(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_SetBody(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetBody(@as(*const IScriptEntry, @ptrCast(self)), psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_GetName(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetName(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_SetName(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetName(@as(*const IScriptEntry, @ptrCast(self)), psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_GetItemName(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetItemName(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_SetItemName(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetItemName(@as(*const IScriptEntry, @ptrCast(self)), psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_GetSignature(self: *const T, ppti: ?*?*ITypeInfo, piMethod: ?*u32) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetSignature(@as(*const IScriptEntry, @ptrCast(self)), ppti, piMethod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_SetSignature(self: *const T, pti: ?*ITypeInfo, iMethod: u32) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetSignature(@as(*const IScriptEntry, @ptrCast(self)), pti, iMethod);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptEntry_GetRange(self: *const T, pichMin: ?*u32, pcch: ?*u32) HRESULT {
                return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetRange(@as(*const IScriptEntry, @ptrCast(self)), pichMin, pcch);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptScriptlet_Value = Guid.initString("0aee2a96-bcbb-11d0-8c72-00c04fc2b085");
pub const IID_IScriptScriptlet = &IID_IScriptScriptlet_Value;
pub const IScriptScriptlet = extern struct {
    pub const VTable = extern struct {
        base: IScriptEntry.VTable,
        GetSubItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptScriptlet,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptScriptlet,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptScriptlet,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptScriptlet,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSimpleEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSimpleEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptScriptlet,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptScriptlet,
                psz: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IScriptEntry.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptScriptlet_GetSubItemName(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).GetSubItemName(@as(*const IScriptScriptlet, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptScriptlet_SetSubItemName(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).SetSubItemName(@as(*const IScriptScriptlet, @ptrCast(self)), psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptScriptlet_GetEventName(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).GetEventName(@as(*const IScriptScriptlet, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptScriptlet_SetEventName(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).SetEventName(@as(*const IScriptScriptlet, @ptrCast(self)), psz);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptScriptlet_GetSimpleEventName(self: *const T, pbstr: ?*?BSTR) HRESULT {
                return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).GetSimpleEventName(@as(*const IScriptScriptlet, @ptrCast(self)), pbstr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptScriptlet_SetSimpleEventName(self: *const T, psz: ?[*:0]const u16) HRESULT {
                return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).SetSimpleEventName(@as(*const IScriptScriptlet, @ptrCast(self)), psz);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptAuthor_Value = Guid.initString("9c109da0-7006-11d1-b36c-00a0c911e8b2");
pub const IID_IActiveScriptAuthor = &IID_IActiveScriptAuthor_Value;
pub const IActiveScriptAuthor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]const u16,
                dwFlags: u32,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]const u16,
                dwFlags: u32,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScriptlet: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszDefaultName: ?[*:0]const u16,
                pszCode: ?[*:0]const u16,
                pszItemName: ?[*:0]const u16,
                pszSubItemName: ?[*:0]const u16,
                pszEventName: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszDefaultName: ?[*:0]const u16,
                pszCode: ?[*:0]const u16,
                pszItemName: ?[*:0]const u16,
                pszSubItemName: ?[*:0]const u16,
                pszEventName: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseScriptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]const u16,
                pszItemName: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]const u16,
                pszItemName: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptletTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                ppsp: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                ppsp: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pgrfasa: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pgrfasa: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pdisp: ?*IDispatch,
                pszItem: ?[*:0]const u16,
                pszSubItem: ?[*:0]const u16,
                pszEvent: ?[*:0]const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pdisp: ?*IDispatch,
                pszItem: ?[*:0]const u16,
                pszSubItem: ?[*:0]const u16,
                pszEvent: ?[*:0]const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChars: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                fRequestedList: u32,
                pbstrChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                fRequestedList: u32,
                pbstrChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfoFromContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]const u16,
                cchCode: u32,
                ichCurrentPosition: u32,
                dwListTypesRequested: u32,
                pdwListTypesProvided: ?*u32,
                pichListAnchorPosition: ?*u32,
                pichFuncAnchorPosition: ?*u32,
                pmemid: ?*i32,
                piCurrentParameter: ?*i32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]const u16,
                cchCode: u32,
                ichCurrentPosition: u32,
                dwListTypesRequested: u32,
                pdwListTypesProvided: ?*u32,
                pichListAnchorPosition: ?*u32,
                pichFuncAnchorPosition: ?*u32,
                pmemid: ?*i32,
                piCurrentParameter: ?*i32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCommitChar: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthor,
                ch: u16,
                pfcommit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthor,
                ch: u16,
                pfcommit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_AddNamedItem(self: *const T, pszName: ?[*:0]const u16, dwFlags: u32, pdisp: ?*IDispatch) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).AddNamedItem(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszName, dwFlags, pdisp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_AddScriptlet(self: *const T, pszDefaultName: ?[*:0]const u16, pszCode: ?[*:0]const u16, pszItemName: ?[*:0]const u16, pszSubItemName: ?[*:0]const u16, pszEventName: ?[*:0]const u16, pszDelimiter: ?[*:0]const u16, dwCookie: u32, dwFlags: u32) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).AddScriptlet(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszDefaultName, pszCode, pszItemName, pszSubItemName, pszEventName, pszDelimiter, dwCookie, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_ParseScriptText(self: *const T, pszCode: ?[*:0]const u16, pszItemName: ?[*:0]const u16, pszDelimiter: ?[*:0]const u16, dwCookie: u32, dwFlags: u32) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).ParseScriptText(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, pszItemName, pszDelimiter, dwCookie, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetScriptTextAttributes(self: *const T, pszCode: [*:0]const u16, cch: u32, pszDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, cch, pszDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetScriptletTextAttributes(self: *const T, pszCode: [*:0]const u16, cch: u32, pszDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetScriptletTextAttributes(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, cch, pszDelimiter, dwFlags, pattr);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetRoot(self: *const T, ppsp: ?*?*IScriptNode) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetRoot(@as(*const IActiveScriptAuthor, @ptrCast(self)), ppsp);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetLanguageFlags(self: *const T, pgrfasa: ?*u32) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetLanguageFlags(@as(*const IActiveScriptAuthor, @ptrCast(self)), pgrfasa);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetEventHandler(self: *const T, pdisp: ?*IDispatch, pszItem: ?[*:0]const u16, pszSubItem: ?[*:0]const u16, pszEvent: ?[*:0]const u16, ppse: ?*?*IScriptEntry) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetEventHandler(@as(*const IActiveScriptAuthor, @ptrCast(self)), pdisp, pszItem, pszSubItem, pszEvent, ppse);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_RemoveNamedItem(self: *const T, pszName: ?[*:0]const u16) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).RemoveNamedItem(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_AddTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32, dwFlags: u32) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).AddTypeLib(@as(*const IActiveScriptAuthor, @ptrCast(self)), rguidTypeLib, dwMajor, dwMinor, dwFlags);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_RemoveTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).RemoveTypeLib(@as(*const IActiveScriptAuthor, @ptrCast(self)), rguidTypeLib, dwMajor, dwMinor);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetChars(self: *const T, fRequestedList: u32, pbstrChars: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetChars(@as(*const IActiveScriptAuthor, @ptrCast(self)), fRequestedList, pbstrChars);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_GetInfoFromContext(self: *const T, pszCode: ?[*:0]const u16, cchCode: u32, ichCurrentPosition: u32, dwListTypesRequested: u32, pdwListTypesProvided: ?*u32, pichListAnchorPosition: ?*u32, pichFuncAnchorPosition: ?*u32, pmemid: ?*i32, piCurrentParameter: ?*i32, ppunk: ?*?*IUnknown) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetInfoFromContext(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, cchCode, ichCurrentPosition, dwListTypesRequested, pdwListTypesProvided, pichListAnchorPosition, pichFuncAnchorPosition, pmemid, piCurrentParameter, ppunk);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthor_IsCommitChar(self: *const T, ch: u16, pfcommit: ?*BOOL) HRESULT {
                return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).IsCommitChar(@as(*const IActiveScriptAuthor, @ptrCast(self)), ch, pfcommit);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptAuthorProcedure_Value = Guid.initString("7e2d4b70-bd9a-11d0-9336-00a0c90dcaa9");
pub const IID_IActiveScriptAuthorProcedure = &IID_IActiveScriptAuthorProcedure_Value;
pub const IActiveScriptAuthorProcedure = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptAuthorProcedure,
                pszCode: ?[*:0]const u16,
                pszFormalParams: ?[*:0]const u16,
                pszProcedureName: ?[*:0]const u16,
                pszItemName: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                dwCookie: u32,
                dwFlags: u32,
                pdispFor: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptAuthorProcedure,
                pszCode: ?[*:0]const u16,
                pszFormalParams: ?[*:0]const u16,
                pszProcedureName: ?[*:0]const u16,
                pszItemName: ?[*:0]const u16,
                pszDelimiter: ?[*:0]const u16,
                dwCookie: u32,
                dwFlags: u32,
                pdispFor: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptAuthorProcedure_ParseProcedureText(self: *const T, pszCode: ?[*:0]const u16, pszFormalParams: ?[*:0]const u16, pszProcedureName: ?[*:0]const u16, pszItemName: ?[*:0]const u16, pszDelimiter: ?[*:0]const u16, dwCookie: u32, dwFlags: u32, pdispFor: ?*IDispatch) HRESULT {
                return @as(*const IActiveScriptAuthorProcedure.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptAuthorProcedure, @ptrCast(self)), pszCode, pszFormalParams, pszProcedureName, pszItemName, pszDelimiter, dwCookie, dwFlags, pdispFor);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const APPLICATION_NODE_EVENT_FILTER = enum(i32) {
    NOTHING = 0,
    ANONYMOUS_CODE = 1,
    EVAL_CODE = 2,
};
pub const FILTER_EXCLUDE_NOTHING = APPLICATION_NODE_EVENT_FILTER.NOTHING;
pub const FILTER_EXCLUDE_ANONYMOUS_CODE = APPLICATION_NODE_EVENT_FILTER.ANONYMOUS_CODE;
pub const FILTER_EXCLUDE_EVAL_CODE = APPLICATION_NODE_EVENT_FILTER.EVAL_CODE;

pub const TEXT_DOCUMENT_ARRAY = extern struct {
    dwCount: u32,
    Members: ?*?*IDebugDocumentText,
};

const IID_IDebugApplicationNode100_Value = Guid.initString("90a7734e-841b-4f77-9384-a2891e76e7e2");
pub const IID_IDebugApplicationNode100 = &IID_IDebugApplicationNode100_Value;
pub const IDebugApplicationNode100 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFilterForEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode100,
                dwCookie: u32,
                filter: APPLICATION_NODE_EVENT_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode100,
                dwCookie: u32,
                filter: APPLICATION_NODE_EVENT_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExcludedDocuments: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode100,
                filter: APPLICATION_NODE_EVENT_FILTER,
                pDocuments: ?*TEXT_DOCUMENT_ARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode100,
                filter: APPLICATION_NODE_EVENT_FILTER,
                pDocuments: ?*TEXT_DOCUMENT_ARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsChildNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationNode100,
                pSearchKey: ?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationNode100,
                pSearchKey: ?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode100_SetFilterForEventSink(self: *const T, dwCookie: u32, filter: APPLICATION_NODE_EVENT_FILTER) HRESULT {
                return @as(*const IDebugApplicationNode100.VTable, @ptrCast(self.vtable)).SetFilterForEventSink(@as(*const IDebugApplicationNode100, @ptrCast(self)), dwCookie, filter);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode100_GetExcludedDocuments(self: *const T, filter: APPLICATION_NODE_EVENT_FILTER, pDocuments: ?*TEXT_DOCUMENT_ARRAY) HRESULT {
                return @as(*const IDebugApplicationNode100.VTable, @ptrCast(self.vtable)).GetExcludedDocuments(@as(*const IDebugApplicationNode100, @ptrCast(self)), filter, pDocuments);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationNode100_QueryIsChildNode(self: *const T, pSearchKey: ?*IDebugDocument) HRESULT {
                return @as(*const IDebugApplicationNode100.VTable, @ptrCast(self.vtable)).QueryIsChildNode(@as(*const IDebugApplicationNode100, @ptrCast(self)), pSearchKey);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebAppDiagnosticsSetup_Value = Guid.initString("379bfbe1-c6c9-432a-93e1-6d17656c538c");
pub const IID_IWebAppDiagnosticsSetup = &IID_IWebAppDiagnosticsSetup_Value;
pub const IWebAppDiagnosticsSetup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DiagnosticsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebAppDiagnosticsSetup,
                pRetVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebAppDiagnosticsSetup,
                pRetVal: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateObjectWithSiteAtWebApp: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebAppDiagnosticsSetup,
                rclsid: ?*const Guid,
                dwClsContext: u32,
                riid: ?*const Guid,
                hPassToObject: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebAppDiagnosticsSetup,
                rclsid: ?*const Guid,
                dwClsContext: u32,
                riid: ?*const Guid,
                hPassToObject: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebAppDiagnosticsSetup_DiagnosticsSupported(self: *const T, pRetVal: ?*i16) HRESULT {
                return @as(*const IWebAppDiagnosticsSetup.VTable, @ptrCast(self.vtable)).DiagnosticsSupported(@as(*const IWebAppDiagnosticsSetup, @ptrCast(self)), pRetVal);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebAppDiagnosticsSetup_CreateObjectWithSiteAtWebApp(self: *const T, rclsid: ?*const Guid, dwClsContext: u32, riid: ?*const Guid, hPassToObject: usize) HRESULT {
                return @as(*const IWebAppDiagnosticsSetup.VTable, @ptrCast(self.vtable)).CreateObjectWithSiteAtWebApp(@as(*const IWebAppDiagnosticsSetup, @ptrCast(self)), rclsid, dwClsContext, riid, hPassToObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_DEBUGGER_OPTIONS = enum(i32) {
    NONE = 0,
    ENABLE_FIRST_CHANCE_EXCEPTIONS = 1,
    ENABLE_WEB_WORKER_SUPPORT = 2,
    ENABLE_NONUSER_CODE_SUPPORT = 4,
    ENABLE_LIBRARY_STACK_FRAME = 8,
};
pub const SDO_NONE = SCRIPT_DEBUGGER_OPTIONS.NONE;
pub const SDO_ENABLE_FIRST_CHANCE_EXCEPTIONS = SCRIPT_DEBUGGER_OPTIONS.ENABLE_FIRST_CHANCE_EXCEPTIONS;
pub const SDO_ENABLE_WEB_WORKER_SUPPORT = SCRIPT_DEBUGGER_OPTIONS.ENABLE_WEB_WORKER_SUPPORT;
pub const SDO_ENABLE_NONUSER_CODE_SUPPORT = SCRIPT_DEBUGGER_OPTIONS.ENABLE_NONUSER_CODE_SUPPORT;
pub const SDO_ENABLE_LIBRARY_STACK_FRAME = SCRIPT_DEBUGGER_OPTIONS.ENABLE_LIBRARY_STACK_FRAME;

const IID_IRemoteDebugApplication110_Value = Guid.initString("d5fe005b-2836-485e-b1f9-89d91aa24fd4");
pub const IID_IRemoteDebugApplication110 = &IID_IRemoteDebugApplication110_Value;
pub const IRemoteDebugApplication110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDebuggerOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication110,
                mask: SCRIPT_DEBUGGER_OPTIONS,
                value: SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication110,
                mask: SCRIPT_DEBUGGER_OPTIONS,
                value: SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentDebuggerOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication110,
                pCurrentOptions: ?*SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication110,
                pCurrentOptions: ?*SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugApplication110,
                ppThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugApplication110,
                ppThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication110_SetDebuggerOptions(self: *const T, mask: SCRIPT_DEBUGGER_OPTIONS, value: SCRIPT_DEBUGGER_OPTIONS) HRESULT {
                return @as(*const IRemoteDebugApplication110.VTable, @ptrCast(self.vtable)).SetDebuggerOptions(@as(*const IRemoteDebugApplication110, @ptrCast(self)), mask, value);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication110_GetCurrentDebuggerOptions(self: *const T, pCurrentOptions: ?*SCRIPT_DEBUGGER_OPTIONS) HRESULT {
                return @as(*const IRemoteDebugApplication110.VTable, @ptrCast(self.vtable)).GetCurrentDebuggerOptions(@as(*const IRemoteDebugApplication110, @ptrCast(self)), pCurrentOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugApplication110_GetMainThread(self: *const T, ppThread: ?*?*IRemoteDebugApplicationThread) HRESULT {
                return @as(*const IRemoteDebugApplication110.VTable, @ptrCast(self.vtable)).GetMainThread(@as(*const IRemoteDebugApplication110, @ptrCast(self)), ppThread);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication11032_Value = Guid.initString("bdb3b5de-89f2-4e11-84a5-97445f941c7d");
pub const IID_IDebugApplication11032 = &IID_IDebugApplication11032_Value;
pub const IDebugApplication11032 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication110.VTable,
        SynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallableWaitForHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication11032,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication11032,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRemoteDebugApplication110.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication11032_SynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: usize, dwParam2: usize, dwParam3: usize) HRESULT {
                return @as(*const IDebugApplication11032.VTable, @ptrCast(self.vtable)).SynchronousCallInMainThread(@as(*const IDebugApplication11032, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication11032_AsynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: usize, dwParam2: usize, dwParam3: usize) HRESULT {
                return @as(*const IDebugApplication11032.VTable, @ptrCast(self.vtable)).AsynchronousCallInMainThread(@as(*const IDebugApplication11032, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication11032_CallableWaitForHandles(self: *const T, handleCount: u32, pHandles: [*]const ?HANDLE, pIndex: ?*u32) HRESULT {
                return @as(*const IDebugApplication11032.VTable, @ptrCast(self.vtable)).CallableWaitForHandles(@as(*const IDebugApplication11032, @ptrCast(self)), handleCount, pHandles, pIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication11064_Value = Guid.initString("2039d958-4eeb-496a-87bb-2e5201eadeef");
pub const IID_IDebugApplication11064 = &IID_IDebugApplication11064_Value;
pub const IDebugApplication11064 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication110.VTable,
        SynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallableWaitForHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplication11064,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplication11064,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IRemoteDebugApplication110.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication11064_SynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: usize, dwParam2: usize, dwParam3: usize) HRESULT {
                return @as(*const IDebugApplication11064.VTable, @ptrCast(self.vtable)).SynchronousCallInMainThread(@as(*const IDebugApplication11064, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication11064_AsynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: usize, dwParam2: usize, dwParam3: usize) HRESULT {
                return @as(*const IDebugApplication11064.VTable, @ptrCast(self.vtable)).AsynchronousCallInMainThread(@as(*const IDebugApplication11064, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplication11064_CallableWaitForHandles(self: *const T, handleCount: u32, pHandles: [*]const ?HANDLE, pIndex: ?*u32) HRESULT {
                return @as(*const IDebugApplication11064.VTable, @ptrCast(self.vtable)).CallableWaitForHandles(@as(*const IDebugApplication11064, @ptrCast(self)), handleCount, pHandles, pIndex);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebAppDiagnosticsObjectInitialization_Value = Guid.initString("16ff3a42-a5f5-432b-b625-8e8e16f57e15");
pub const IID_IWebAppDiagnosticsObjectInitialization = &IID_IWebAppDiagnosticsObjectInitialization_Value;
pub const IWebAppDiagnosticsObjectInitialization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IWebAppDiagnosticsObjectInitialization,
                hPassedHandle: HANDLE_PTR,
                pDebugApplication: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IWebAppDiagnosticsObjectInitialization,
                hPassedHandle: HANDLE_PTR,
                pDebugApplication: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IWebAppDiagnosticsObjectInitialization_Initialize(self: *const T, hPassedHandle: HANDLE_PTR, pDebugApplication: ?*IUnknown) HRESULT {
                return @as(*const IWebAppDiagnosticsObjectInitialization.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWebAppDiagnosticsObjectInitialization, @ptrCast(self)), hPassedHandle, pDebugApplication);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptWinRTErrorDebug_Value = Guid.initString("73a3f82a-0fe9-4b33-ba3b-fe095f697e0a");
pub const IID_IActiveScriptWinRTErrorDebug = &IID_IActiveScriptWinRTErrorDebug_Value;
pub const IActiveScriptWinRTErrorDebug = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetRestrictedErrorString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptWinRTErrorDebug,
                errorString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptWinRTErrorDebug,
                errorString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRestrictedErrorReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptWinRTErrorDebug,
                referenceString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptWinRTErrorDebug,
                referenceString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilitySid: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptWinRTErrorDebug,
                capabilitySid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptWinRTErrorDebug,
                capabilitySid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IActiveScriptError.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptWinRTErrorDebug_GetRestrictedErrorString(self: *const T, errorString: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptWinRTErrorDebug.VTable, @ptrCast(self.vtable)).GetRestrictedErrorString(@as(*const IActiveScriptWinRTErrorDebug, @ptrCast(self)), errorString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptWinRTErrorDebug_GetRestrictedErrorReference(self: *const T, referenceString: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptWinRTErrorDebug.VTable, @ptrCast(self.vtable)).GetRestrictedErrorReference(@as(*const IActiveScriptWinRTErrorDebug, @ptrCast(self)), referenceString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptWinRTErrorDebug_GetCapabilitySid(self: *const T, capabilitySid: ?*?BSTR) HRESULT {
                return @as(*const IActiveScriptWinRTErrorDebug.VTable, @ptrCast(self.vtable)).GetCapabilitySid(@as(*const IActiveScriptWinRTErrorDebug, @ptrCast(self)), capabilitySid);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND = enum(i32) {
    FIRST_CHANCE = 0,
    USER_UNHANDLED = 1,
    UNHANDLED = 2,
};
pub const ETK_FIRST_CHANCE = SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND.FIRST_CHANCE;
pub const ETK_USER_UNHANDLED = SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND.USER_UNHANDLED;
pub const ETK_UNHANDLED = SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND.UNHANDLED;

const IID_IActiveScriptErrorDebug110_Value = Guid.initString("516e42b6-89a8-4530-937b-5f0708431442");
pub const IID_IActiveScriptErrorDebug110 = &IID_IActiveScriptErrorDebug110_Value;
pub const IActiveScriptErrorDebug110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExceptionThrownKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IActiveScriptErrorDebug110,
                pExceptionKind: ?*SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IActiveScriptErrorDebug110,
                pExceptionKind: ?*SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IActiveScriptErrorDebug110_GetExceptionThrownKind(self: *const T, pExceptionKind: ?*SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND) HRESULT {
                return @as(*const IActiveScriptErrorDebug110.VTable, @ptrCast(self.vtable)).GetExceptionThrownKind(@as(*const IActiveScriptErrorDebug110, @ptrCast(self)), pExceptionKind);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThreadEvents110_Value = Guid.initString("84e5e468-d5da-48a8-83f4-40366429007b");
pub const IID_IDebugApplicationThreadEvents110 = &IID_IDebugApplicationThreadEvents110_Value;
pub const IDebugApplicationThreadEvents110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSuspendForBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnResumeFromBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnThreadRequestComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeginThreadRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThreadEvents110_OnSuspendForBreakPoint(self: *const T) HRESULT {
                return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnSuspendForBreakPoint(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThreadEvents110_OnResumeFromBreakPoint(self: *const T) HRESULT {
                return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnResumeFromBreakPoint(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThreadEvents110_OnThreadRequestComplete(self: *const T) HRESULT {
                return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnThreadRequestComplete(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThreadEvents110_OnBeginThreadRequest(self: *const T) HRESULT {
                return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnBeginThreadRequest(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread11032_Value = Guid.initString("2194ac5c-6561-404a-a2e9-f57d72de3702");
pub const IID_IDebugApplicationThread11032 = &IID_IDebugApplicationThread11032_Value;
pub const IDebugApplicationThread11032 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActiveThreadRequestCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11032,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11032,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSuspendedForBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11032,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11032,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsThreadCallable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11032,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11032,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallIntoThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11032_GetActiveThreadRequestCount(self: *const T, puiThreadRequests: ?*u32) HRESULT {
                return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).GetActiveThreadRequestCount(@as(*const IDebugApplicationThread11032, @ptrCast(self)), puiThreadRequests);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11032_IsSuspendedForBreakPoint(self: *const T, pfIsSuspended: ?*BOOL) HRESULT {
                return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).IsSuspendedForBreakPoint(@as(*const IDebugApplicationThread11032, @ptrCast(self)), pfIsSuspended);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11032_IsThreadCallable(self: *const T, pfIsCallable: ?*BOOL) HRESULT {
                return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).IsThreadCallable(@as(*const IDebugApplicationThread11032, @ptrCast(self)), pfIsCallable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11032_AsynchronousCallIntoThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: usize, dwParam2: usize, dwParam3: usize) HRESULT {
                return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).AsynchronousCallIntoThread(@as(*const IDebugApplicationThread11032, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread11064_Value = Guid.initString("420aa4cc-efd8-4dac-983b-47127826917d");
pub const IID_IDebugApplicationThread11064 = &IID_IDebugApplicationThread11064_Value;
pub const IDebugApplicationThread11064 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActiveThreadRequestCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11064,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11064,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSuspendedForBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11064,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11064,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsThreadCallable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11064,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11064,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallIntoThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugApplicationThread11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugApplicationThread11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11064_GetActiveThreadRequestCount(self: *const T, puiThreadRequests: ?*u32) HRESULT {
                return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).GetActiveThreadRequestCount(@as(*const IDebugApplicationThread11064, @ptrCast(self)), puiThreadRequests);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11064_IsSuspendedForBreakPoint(self: *const T, pfIsSuspended: ?*BOOL) HRESULT {
                return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).IsSuspendedForBreakPoint(@as(*const IDebugApplicationThread11064, @ptrCast(self)), pfIsSuspended);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11064_IsThreadCallable(self: *const T, pfIsCallable: ?*BOOL) HRESULT {
                return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).IsThreadCallable(@as(*const IDebugApplicationThread11064, @ptrCast(self)), pfIsCallable);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugApplicationThread11064_AsynchronousCallIntoThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: usize, dwParam2: usize, dwParam3: usize) HRESULT {
                return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).AsynchronousCallIntoThread(@as(*const IDebugApplicationThread11064, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugCriticalErrorEvent110_Value = Guid.initString("2f69c611-6b14-47e8-9260-4bb7c52f504b");
pub const IID_IRemoteDebugCriticalErrorEvent110 = &IID_IRemoteDebugCriticalErrorEvent110_Value;
pub const IRemoteDebugCriticalErrorEvent110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugCriticalErrorEvent110,
                pbstrSource: ?*?BSTR,
                pMessageId: ?*i32,
                pbstrMessage: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugCriticalErrorEvent110,
                pbstrSource: ?*?BSTR,
                pMessageId: ?*i32,
                pbstrMessage: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugCriticalErrorEvent110_GetErrorInfo(self: *const T, pbstrSource: ?*?BSTR, pMessageId: ?*i32, pbstrMessage: ?*?BSTR, ppLocation: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IRemoteDebugCriticalErrorEvent110.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const IRemoteDebugCriticalErrorEvent110, @ptrCast(self)), pbstrSource, pMessageId, pbstrMessage, ppLocation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_INVOCATION_CONTEXT_TYPE = enum(i32) {
    Event = 0,
    SetTimeout = 1,
    SetInterval = 2,
    SetImmediate = 3,
    RequestAnimationFrame = 4,
    ToString = 5,
    MutationObserverCheckpoint = 6,
    WWAExecUnsafeLocalFunction = 7,
    WWAExecAtPriority = 8,
};
pub const SICT_Event = SCRIPT_INVOCATION_CONTEXT_TYPE.Event;
pub const SICT_SetTimeout = SCRIPT_INVOCATION_CONTEXT_TYPE.SetTimeout;
pub const SICT_SetInterval = SCRIPT_INVOCATION_CONTEXT_TYPE.SetInterval;
pub const SICT_SetImmediate = SCRIPT_INVOCATION_CONTEXT_TYPE.SetImmediate;
pub const SICT_RequestAnimationFrame = SCRIPT_INVOCATION_CONTEXT_TYPE.RequestAnimationFrame;
pub const SICT_ToString = SCRIPT_INVOCATION_CONTEXT_TYPE.ToString;
pub const SICT_MutationObserverCheckpoint = SCRIPT_INVOCATION_CONTEXT_TYPE.MutationObserverCheckpoint;
pub const SICT_WWAExecUnsafeLocalFunction = SCRIPT_INVOCATION_CONTEXT_TYPE.WWAExecUnsafeLocalFunction;
pub const SICT_WWAExecAtPriority = SCRIPT_INVOCATION_CONTEXT_TYPE.WWAExecAtPriority;

const IID_IScriptInvocationContext_Value = Guid.initString("5d7741b7-af7e-4a2a-85e5-c77f4d0659fb");
pub const IID_IScriptInvocationContext = &IID_IScriptInvocationContext_Value;
pub const IScriptInvocationContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContextType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptInvocationContext,
                pInvocationContextType: ?*SCRIPT_INVOCATION_CONTEXT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptInvocationContext,
                pInvocationContextType: ?*SCRIPT_INVOCATION_CONTEXT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptInvocationContext,
                pDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptInvocationContext,
                pDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IScriptInvocationContext,
                ppContextObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IScriptInvocationContext,
                ppContextObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptInvocationContext_GetContextType(self: *const T, pInvocationContextType: ?*SCRIPT_INVOCATION_CONTEXT_TYPE) HRESULT {
                return @as(*const IScriptInvocationContext.VTable, @ptrCast(self.vtable)).GetContextType(@as(*const IScriptInvocationContext, @ptrCast(self)), pInvocationContextType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptInvocationContext_GetContextDescription(self: *const T, pDescription: ?*?BSTR) HRESULT {
                return @as(*const IScriptInvocationContext.VTable, @ptrCast(self.vtable)).GetContextDescription(@as(*const IScriptInvocationContext, @ptrCast(self)), pDescription);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IScriptInvocationContext_GetContextObject(self: *const T, ppContextObject: ?*?*IUnknown) HRESULT {
                return @as(*const IScriptInvocationContext.VTable, @ptrCast(self.vtable)).GetContextObject(@as(*const IScriptInvocationContext, @ptrCast(self)), ppContextObject);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_STACKFRAME_TYPE = enum(i32) {
    SCRIPT_FRAME = 0,
    INTERNAL_FRAME = 1,
    INVOCATION_FRAME = 2,
};
pub const DST_SCRIPT_FRAME = DEBUG_STACKFRAME_TYPE.SCRIPT_FRAME;
pub const DST_INTERNAL_FRAME = DEBUG_STACKFRAME_TYPE.INTERNAL_FRAME;
pub const DST_INVOCATION_FRAME = DEBUG_STACKFRAME_TYPE.INVOCATION_FRAME;

const IID_IDebugStackFrame110_Value = Guid.initString("4b509611-b6ea-4b24-adcb-d0ccfd1a7e33");
pub const IID_IDebugStackFrame110 = &IID_IDebugStackFrame110_Value;
pub const IDebugStackFrame110 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrame.VTable,
        GetStackFrameType: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame110,
                pStackFrameKind: ?*DEBUG_STACKFRAME_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame110,
                pStackFrameKind: ?*DEBUG_STACKFRAME_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptInvocationContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IDebugStackFrame110,
                ppInvocationContext: ?*?*IScriptInvocationContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IDebugStackFrame110,
                ppInvocationContext: ?*?*IScriptInvocationContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IDebugStackFrame.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame110_GetStackFrameType(self: *const T, pStackFrameKind: ?*DEBUG_STACKFRAME_TYPE) HRESULT {
                return @as(*const IDebugStackFrame110.VTable, @ptrCast(self.vtable)).GetStackFrameType(@as(*const IDebugStackFrame110, @ptrCast(self)), pStackFrameKind);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IDebugStackFrame110_GetScriptInvocationContext(self: *const T, ppInvocationContext: ?*?*IScriptInvocationContext) HRESULT {
                return @as(*const IDebugStackFrame110.VTable, @ptrCast(self.vtable)).GetScriptInvocationContext(@as(*const IDebugStackFrame110, @ptrCast(self)), ppInvocationContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_EVENT_INFO_TYPE = enum(i32) {
    GENERAL = 0,
    ASMJS_IN_DEBUGGING = 1,
    ASMJS_SUCCEEDED = 2,
    ASMJS_FAILED = 3,
};
pub const DEIT_GENERAL = DEBUG_EVENT_INFO_TYPE.GENERAL;
pub const DEIT_ASMJS_IN_DEBUGGING = DEBUG_EVENT_INFO_TYPE.ASMJS_IN_DEBUGGING;
pub const DEIT_ASMJS_SUCCEEDED = DEBUG_EVENT_INFO_TYPE.ASMJS_SUCCEEDED;
pub const DEIT_ASMJS_FAILED = DEBUG_EVENT_INFO_TYPE.ASMJS_FAILED;

const IID_IRemoteDebugInfoEvent110_Value = Guid.initString("9ff56bb6-eb89-4c0f-8823-cc2a4c0b7f26");
pub const IID_IRemoteDebugInfoEvent110 = &IID_IRemoteDebugInfoEvent110_Value;
pub const IRemoteDebugInfoEvent110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IRemoteDebugInfoEvent110,
                pMessageType: ?*DEBUG_EVENT_INFO_TYPE,
                pbstrMessage: ?*?BSTR,
                pbstrUrl: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IRemoteDebugInfoEvent110,
                pMessageType: ?*DEBUG_EVENT_INFO_TYPE,
                pbstrMessage: ?*?BSTR,
                pbstrUrl: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IRemoteDebugInfoEvent110_GetEventInfo(self: *const T, pMessageType: ?*DEBUG_EVENT_INFO_TYPE, pbstrMessage: ?*?BSTR, pbstrUrl: ?*?BSTR, ppLocation: ?*?*IDebugDocumentContext) HRESULT {
                return @as(*const IRemoteDebugInfoEvent110.VTable, @ptrCast(self.vtable)).GetEventInfo(@as(*const IRemoteDebugInfoEvent110, @ptrCast(self)), pMessageType, pbstrMessage, pbstrUrl, ppLocation);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebug_Value = Guid.initString("be0e89da-2ac5-4c04-ac5e-59956aae3613");
pub const IID_IJsDebug = &IID_IJsDebug_Value;
pub const IJsDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenVirtualProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebug,
                processId: u32,
                runtimeJsBaseAddress: u64,
                pDataTarget: ?*IJsDebugDataTarget,
                ppProcess: ?*?*IJsDebugProcess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebug,
                processId: u32,
                runtimeJsBaseAddress: u64,
                pDataTarget: ?*IJsDebugDataTarget,
                ppProcess: ?*?*IJsDebugProcess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebug_OpenVirtualProcess(self: *const T, processId: u32, runtimeJsBaseAddress: u64, pDataTarget: ?*IJsDebugDataTarget, ppProcess: ?*?*IJsDebugProcess) HRESULT {
                return @as(*const IJsDebug.VTable, @ptrCast(self.vtable)).OpenVirtualProcess(@as(*const IJsDebug, @ptrCast(self)), processId, runtimeJsBaseAddress, pDataTarget, ppProcess);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugProcess_Value = Guid.initString("3d587168-6a2d-4041-bd3b-0de674502862");
pub const IID_IJsDebugProcess = &IID_IJsDebugProcess_Value;
pub const IJsDebugProcess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStackWalker: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugProcess,
                threadId: u32,
                ppStackWalker: ?*?*IJsDebugStackWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugProcess,
                threadId: u32,
                ppStackWalker: ?*?*IJsDebugStackWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugProcess,
                documentId: u64,
                characterOffset: u32,
                characterCount: u32,
                isEnabled: BOOL,
                ppDebugBreakPoint: ?*?*IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugProcess,
                documentId: u64,
                characterOffset: u32,
                characterCount: u32,
                isEnabled: BOOL,
                ppDebugBreakPoint: ?*?*IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PerformAsyncBreak: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugProcess,
                threadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugProcess,
                threadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExternalStepAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugProcess,
                pCodeAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugProcess,
                pCodeAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugProcess_CreateStackWalker(self: *const T, threadId: u32, ppStackWalker: ?*?*IJsDebugStackWalker) HRESULT {
                return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).CreateStackWalker(@as(*const IJsDebugProcess, @ptrCast(self)), threadId, ppStackWalker);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugProcess_CreateBreakPoint(self: *const T, documentId: u64, characterOffset: u32, characterCount: u32, isEnabled: BOOL, ppDebugBreakPoint: ?*?*IJsDebugBreakPoint) HRESULT {
                return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).CreateBreakPoint(@as(*const IJsDebugProcess, @ptrCast(self)), documentId, characterOffset, characterCount, isEnabled, ppDebugBreakPoint);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugProcess_PerformAsyncBreak(self: *const T, threadId: u32) HRESULT {
                return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).PerformAsyncBreak(@as(*const IJsDebugProcess, @ptrCast(self)), threadId);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugProcess_GetExternalStepAddress(self: *const T, pCodeAddress: ?*u64) HRESULT {
                return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).GetExternalStepAddress(@as(*const IJsDebugProcess, @ptrCast(self)), pCodeAddress);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugStackWalker_Value = Guid.initString("db24b094-73c4-456c-a4ec-e90ea00bdfe3");
pub const IID_IJsDebugStackWalker = &IID_IJsDebugStackWalker_Value;
pub const IJsDebugStackWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugStackWalker,
                ppFrame: ?*?*IJsDebugFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugStackWalker,
                ppFrame: ?*?*IJsDebugFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugStackWalker_GetNext(self: *const T, ppFrame: ?*?*IJsDebugFrame) HRESULT {
                return @as(*const IJsDebugStackWalker.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IJsDebugStackWalker, @ptrCast(self)), ppFrame);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugFrame_Value = Guid.initString("c9196637-ab9d-44b2-bad2-13b95b3f390e");
pub const IID_IJsDebugFrame = &IID_IJsDebugFrame_Value;
pub const IJsDebugFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStackRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                pStart: ?*u64,
                pEnd: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                pStart: ?*u64,
                pEnd: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPositionWithId: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPositionWithName: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                pDocumentName: ?*?BSTR,
                pLine: ?*u32,
                pColumn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                pDocumentName: ?*?BSTR,
                pLine: ?*u32,
                pColumn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                ppDebugProperty: ?*?*IJsDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                ppDebugProperty: ?*?*IJsDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                pReturnAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                pReturnAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugFrame,
                pExpressionText: ?[*:0]const u16,
                ppDebugProperty: ?*?*IJsDebugProperty,
                pError: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugFrame,
                pExpressionText: ?[*:0]const u16,
                ppDebugProperty: ?*?*IJsDebugProperty,
                pError: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_GetStackRange(self: *const T, pStart: ?*u64, pEnd: ?*u64) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetStackRange(@as(*const IJsDebugFrame, @ptrCast(self)), pStart, pEnd);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_GetName(self: *const T, pName: ?*?BSTR) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetName(@as(*const IJsDebugFrame, @ptrCast(self)), pName);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_GetDocumentPositionWithId(self: *const T, pDocumentId: ?*u64, pCharacterOffset: ?*u32, pStatementCharCount: ?*u32) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetDocumentPositionWithId(@as(*const IJsDebugFrame, @ptrCast(self)), pDocumentId, pCharacterOffset, pStatementCharCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_GetDocumentPositionWithName(self: *const T, pDocumentName: ?*?BSTR, pLine: ?*u32, pColumn: ?*u32) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetDocumentPositionWithName(@as(*const IJsDebugFrame, @ptrCast(self)), pDocumentName, pLine, pColumn);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_GetDebugProperty(self: *const T, ppDebugProperty: ?*?*IJsDebugProperty) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetDebugProperty(@as(*const IJsDebugFrame, @ptrCast(self)), ppDebugProperty);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_GetReturnAddress(self: *const T, pReturnAddress: ?*u64) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetReturnAddress(@as(*const IJsDebugFrame, @ptrCast(self)), pReturnAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugFrame_Evaluate(self: *const T, pExpressionText: ?[*:0]const u16, ppDebugProperty: ?*?*IJsDebugProperty, pError: ?*?BSTR) HRESULT {
                return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IJsDebugFrame, @ptrCast(self)), pExpressionText, ppDebugProperty, pError);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const JS_PROPERTY_MEMBERS = enum(i32) {
    LL = 0,
    RGUMENTS = 1,
};
pub const JS_PROPERTY_MEMBERS_ALL = JS_PROPERTY_MEMBERS.LL;
pub const JS_PROPERTY_MEMBERS_ARGUMENTS = JS_PROPERTY_MEMBERS.RGUMENTS;

pub const JS_PROPERTY_ATTRIBUTES = enum(i32) {
    ATTRIBUTE_NONE = 0,
    HAS_CHILDREN = 1,
    FAKE = 2,
    METHOD = 4,
    READONLY = 8,
    NATIVE_WINRT_POINTER = 16,
    FRAME_INTRYBLOCK = 32,
    FRAME_INCATCHBLOCK = 64,
    FRAME_INFINALLYBLOCK = 128,
};
pub const JS_PROPERTY_ATTRIBUTE_NONE = JS_PROPERTY_ATTRIBUTES.ATTRIBUTE_NONE;
pub const JS_PROPERTY_HAS_CHILDREN = JS_PROPERTY_ATTRIBUTES.HAS_CHILDREN;
pub const JS_PROPERTY_FAKE = JS_PROPERTY_ATTRIBUTES.FAKE;
pub const JS_PROPERTY_METHOD = JS_PROPERTY_ATTRIBUTES.METHOD;
pub const JS_PROPERTY_READONLY = JS_PROPERTY_ATTRIBUTES.READONLY;
pub const JS_PROPERTY_NATIVE_WINRT_POINTER = JS_PROPERTY_ATTRIBUTES.NATIVE_WINRT_POINTER;
pub const JS_PROPERTY_FRAME_INTRYBLOCK = JS_PROPERTY_ATTRIBUTES.FRAME_INTRYBLOCK;
pub const JS_PROPERTY_FRAME_INCATCHBLOCK = JS_PROPERTY_ATTRIBUTES.FRAME_INCATCHBLOCK;
pub const JS_PROPERTY_FRAME_INFINALLYBLOCK = JS_PROPERTY_ATTRIBUTES.FRAME_INFINALLYBLOCK;

pub const JsDebugPropertyInfo = extern struct {
    name: ?BSTR,
    type: ?BSTR,
    value: ?BSTR,
    fullName: ?BSTR,
    attr: JS_PROPERTY_ATTRIBUTES,
};

const IID_IJsDebugProperty_Value = Guid.initString("f8ffcf2b-3aa4-4320-85c3-52a312ba9633");
pub const IID_IJsDebugProperty = &IID_IJsDebugProperty_Value;
pub const IJsDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugProperty,
                nRadix: u32,
                pPropertyInfo: ?*JsDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugProperty,
                nRadix: u32,
                pPropertyInfo: ?*JsDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugProperty,
                members: JS_PROPERTY_MEMBERS,
                ppEnum: ?*?*IJsEnumDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugProperty,
                members: JS_PROPERTY_MEMBERS,
                ppEnum: ?*?*IJsEnumDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugProperty_GetPropertyInfo(self: *const T, nRadix: u32, pPropertyInfo: ?*JsDebugPropertyInfo) HRESULT {
                return @as(*const IJsDebugProperty.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IJsDebugProperty, @ptrCast(self)), nRadix, pPropertyInfo);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugProperty_GetMembers(self: *const T, members: JS_PROPERTY_MEMBERS, ppEnum: ?*?*IJsEnumDebugProperty) HRESULT {
                return @as(*const IJsDebugProperty.VTable, @ptrCast(self.vtable)).GetMembers(@as(*const IJsDebugProperty, @ptrCast(self)), members, ppEnum);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsEnumDebugProperty_Value = Guid.initString("4092432f-2f0f-4fe1-b638-5b74a52cdcbe");
pub const IID_IJsEnumDebugProperty = &IID_IJsEnumDebugProperty_Value;
pub const IJsEnumDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsEnumDebugProperty,
                count: u32,
                ppDebugProperty: [*]?*IJsDebugProperty,
                pActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsEnumDebugProperty,
                count: u32,
                ppDebugProperty: [*]?*IJsDebugProperty,
                pActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsEnumDebugProperty,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsEnumDebugProperty,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsEnumDebugProperty_Next(self: *const T, count: u32, ppDebugProperty: [*]?*IJsDebugProperty, pActualCount: ?*u32) HRESULT {
                return @as(*const IJsEnumDebugProperty.VTable, @ptrCast(self.vtable)).Next(@as(*const IJsEnumDebugProperty, @ptrCast(self)), count, ppDebugProperty, pActualCount);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsEnumDebugProperty_GetCount(self: *const T, pCount: ?*u32) HRESULT {
                return @as(*const IJsEnumDebugProperty.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IJsEnumDebugProperty, @ptrCast(self)), pCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugBreakPoint_Value = Guid.initString("df6773e3-ed8d-488b-8a3e-5812577d1542");
pub const IID_IJsDebugBreakPoint = &IID_IJsDebugBreakPoint_Value;
pub const IJsDebugBreakPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugBreakPoint,
                pIsEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugBreakPoint,
                pIsEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disable: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugBreakPoint,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugBreakPoint,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugBreakPoint_IsEnabled(self: *const T, pIsEnabled: ?*BOOL) HRESULT {
                return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IJsDebugBreakPoint, @ptrCast(self)), pIsEnabled);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugBreakPoint_Enable(self: *const T) HRESULT {
                return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).Enable(@as(*const IJsDebugBreakPoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugBreakPoint_Disable(self: *const T) HRESULT {
                return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).Disable(@as(*const IJsDebugBreakPoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugBreakPoint_Delete(self: *const T) HRESULT {
                return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).Delete(@as(*const IJsDebugBreakPoint, @ptrCast(self)));
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugBreakPoint_GetDocumentPosition(self: *const T, pDocumentId: ?*u64, pCharacterOffset: ?*u32, pStatementCharCount: ?*u32) HRESULT {
                return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).GetDocumentPosition(@as(*const IJsDebugBreakPoint, @ptrCast(self)), pDocumentId, pCharacterOffset, pStatementCharCount);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_jscript9diag_0000_0007_0001 = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
};

const IID_IEnumJsStackFrames_Value = Guid.initString("5e7da34b-fb51-4791-abe7-cb5bdf419755");
pub const IID_IEnumJsStackFrames = &IID_IEnumJsStackFrames_Value;
pub const IEnumJsStackFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumJsStackFrames,
                cFrameCount: u32,
                pFrames: [*]__MIDL___MIDL_itf_jscript9diag_0000_0007_0001,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumJsStackFrames,
                cFrameCount: u32,
                pFrames: [*]__MIDL___MIDL_itf_jscript9diag_0000_0007_0001,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumJsStackFrames_Next(self: *const T, cFrameCount: u32, pFrames: [*]__MIDL___MIDL_itf_jscript9diag_0000_0007_0001, pcFetched: ?*u32) HRESULT {
                return @as(*const IEnumJsStackFrames.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumJsStackFrames, @ptrCast(self)), cFrameCount, pFrames, pcFetched);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IEnumJsStackFrames_Reset(self: *const T) HRESULT {
                return @as(*const IEnumJsStackFrames.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumJsStackFrames, @ptrCast(self)));
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const JsDebugReadMemoryFlags = enum(i32) {
    None = 0,
    d = 1,
};
pub const JsDebugAllowPartialRead = JsDebugReadMemoryFlags.d;

const IID_IJsDebugDataTarget_Value = Guid.initString("53b28977-53a1-48e5-9000-5d0dfa893931");
pub const IID_IJsDebugDataTarget = &IID_IJsDebugDataTarget_Value;
pub const IJsDebugDataTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                flags: JsDebugReadMemoryFlags,
                pBuffer: [*:0]u8,
                size: u32,
                pBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                flags: JsDebugReadMemoryFlags,
                pBuffer: [*:0]u8,
                size: u32,
                pBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                pMemory: [*:0]u8,
                size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                pMemory: [*:0]u8,
                size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateVirtualMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                allocationType: u32,
                pageProtection: u32,
                pAllocatedAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                allocationType: u32,
                pageProtection: u32,
                pAllocatedAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeVirtualMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                freeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                freeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTlsValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                threadId: u32,
                tlsIndex: u32,
                pValue: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                threadId: u32,
                tlsIndex: u32,
                pValue: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBSTR: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadNullTerminatedString: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                characterSize: u16,
                maxCharacters: u32,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                address: u64,
                characterSize: u16,
                maxCharacters: u32,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStackFrameEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                threadId: u32,
                ppEnumerator: ?*?*IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                threadId: u32,
                ppEnumerator: ?*?*IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IJsDebugDataTarget,
                threadId: u32,
                contextFlags: u32,
                contextSize: u32,
                pContext: [*]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IJsDebugDataTarget,
                threadId: u32,
                contextFlags: u32,
                contextSize: u32,
                pContext: [*]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_ReadMemory(self: *const T, address: u64, flags: JsDebugReadMemoryFlags, pBuffer: [*:0]u8, size: u32, pBytesRead: ?*u32) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).ReadMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, flags, pBuffer, size, pBytesRead);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_WriteMemory(self: *const T, address: u64, pMemory: [*:0]u8, size: u32) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).WriteMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, pMemory, size);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_AllocateVirtualMemory(self: *const T, address: u64, size: u32, allocationType: u32, pageProtection: u32, pAllocatedAddress: ?*u64) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).AllocateVirtualMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, size, allocationType, pageProtection, pAllocatedAddress);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_FreeVirtualMemory(self: *const T, address: u64, size: u32, freeType: u32) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).FreeVirtualMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, size, freeType);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_GetTlsValue(self: *const T, threadId: u32, tlsIndex: u32, pValue: ?*u64) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).GetTlsValue(@as(*const IJsDebugDataTarget, @ptrCast(self)), threadId, tlsIndex, pValue);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_ReadBSTR(self: *const T, address: u64, pString: ?*?BSTR) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).ReadBSTR(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, pString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_ReadNullTerminatedString(self: *const T, address: u64, characterSize: u16, maxCharacters: u32, pString: ?*?BSTR) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).ReadNullTerminatedString(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, characterSize, maxCharacters, pString);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_CreateStackFrameEnumerator(self: *const T, threadId: u32, ppEnumerator: ?*?*IEnumJsStackFrames) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).CreateStackFrameEnumerator(@as(*const IJsDebugDataTarget, @ptrCast(self)), threadId, ppEnumerator);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IJsDebugDataTarget_GetThreadContext(self: *const T, threadId: u32, contextFlags: u32, contextSize: u32, pContext: [*]u8) HRESULT {
                return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IJsDebugDataTarget, @ptrCast(self)), threadId, contextFlags, contextSize, pContext);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const _DUMP_TYPES = enum(i32) {
    INVALID = -1,
    UNKNOWN = 0,
    FULL = 1,
    SUMMARY = 2,
    HEADER = 3,
    TRIAGE = 4,
    BITMAP_FULL = 5,
    BITMAP_KERNEL = 6,
    AUTOMATIC = 7,
};
pub const DUMP_TYPE_INVALID = _DUMP_TYPES.INVALID;
pub const DUMP_TYPE_UNKNOWN = _DUMP_TYPES.UNKNOWN;
pub const DUMP_TYPE_FULL = _DUMP_TYPES.FULL;
pub const DUMP_TYPE_SUMMARY = _DUMP_TYPES.SUMMARY;
pub const DUMP_TYPE_HEADER = _DUMP_TYPES.HEADER;
pub const DUMP_TYPE_TRIAGE = _DUMP_TYPES.TRIAGE;
pub const DUMP_TYPE_BITMAP_FULL = _DUMP_TYPES.BITMAP_FULL;
pub const DUMP_TYPE_BITMAP_KERNEL = _DUMP_TYPES.BITMAP_KERNEL;
pub const DUMP_TYPE_AUTOMATIC = _DUMP_TYPES.AUTOMATIC;

pub const PHYSICAL_MEMORY_RUN32 = extern struct {
    BasePage: u32,
    PageCount: u32,
};

pub const PHYSICAL_MEMORY_DESCRIPTOR32 = extern struct {
    NumberOfRuns: u32,
    NumberOfPages: u32,
    Run: [1]PHYSICAL_MEMORY_RUN32,
};

pub const PHYSICAL_MEMORY_RUN64 = extern struct {
    BasePage: u64,
    PageCount: u64,
};

pub const PHYSICAL_MEMORY_DESCRIPTOR64 = extern struct {
    NumberOfRuns: u32,
    NumberOfPages: u64,
    Run: [1]PHYSICAL_MEMORY_RUN64,
};

pub const DUMP_FILE_ATTRIBUTES = extern union {
    Anonymous: extern struct {
        _bitfield: u32,
    },
    Attributes: u32,
};

pub const DUMP_HEADER32 = extern struct {
    Signature: u32,
    ValidDump: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    DirectoryTableBase: u32,
    PfnDataBase: u32,
    PsLoadedModuleList: u32,
    PsActiveProcessHead: u32,
    MachineImageType: u32,
    NumberProcessors: u32,
    BugCheckCode: u32,
    BugCheckParameter1: u32,
    BugCheckParameter2: u32,
    BugCheckParameter3: u32,
    BugCheckParameter4: u32,
    VersionUser: [32]CHAR,
    PaeEnabled: u8,
    KdSecondaryVersion: u8,
    Spare3: [2]u8,
    KdDebuggerDataBlock: u32,
    Anonymous: extern union {
        PhysicalMemoryBlock: PHYSICAL_MEMORY_DESCRIPTOR32,
        PhysicalMemoryBlockBuffer: [700]u8,
    },
    ContextRecord: [1200]u8,
    Exception: EXCEPTION_RECORD32,
    Comment: [128]CHAR,
    Attributes: DUMP_FILE_ATTRIBUTES,
    BootId: u32,
    _reserved0: [1760]u8,
    DumpType: u32,
    MiniDumpFields: u32,
    SecondaryDataState: u32,
    ProductType: u32,
    SuiteMask: u32,
    WriterStatus: u32,
    RequiredDumpSpace: LARGE_INTEGER,
    _reserved2: [16]u8,
    SystemUpTime: LARGE_INTEGER,
    SystemTime: LARGE_INTEGER,
    _reserved3: [56]u8,
};

pub const DUMP_HEADER64 = extern struct {
    Signature: u32,
    ValidDump: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    DirectoryTableBase: u64,
    PfnDataBase: u64,
    PsLoadedModuleList: u64,
    PsActiveProcessHead: u64,
    MachineImageType: u32,
    NumberProcessors: u32,
    BugCheckCode: u32,
    BugCheckParameter1: u64,
    BugCheckParameter2: u64,
    BugCheckParameter3: u64,
    BugCheckParameter4: u64,
    VersionUser: [32]CHAR,
    KdDebuggerDataBlock: u64,
    Anonymous: extern union {
        PhysicalMemoryBlock: PHYSICAL_MEMORY_DESCRIPTOR64,
        PhysicalMemoryBlockBuffer: [700]u8,
    },
    ContextRecord: [3000]u8,
    Exception: EXCEPTION_RECORD64,
    DumpType: u32,
    RequiredDumpSpace: LARGE_INTEGER,
    SystemTime: LARGE_INTEGER,
    Comment: [128]CHAR,
    SystemUpTime: LARGE_INTEGER,
    MiniDumpFields: u32,
    SecondaryDataState: u32,
    ProductType: u32,
    SuiteMask: u32,
    WriterStatus: u32,
    Unused1: u8,
    KdSecondaryVersion: u8,
    Unused: [2]u8,
    Attributes: DUMP_FILE_ATTRIBUTES,
    BootId: u32,
    _reserved0: [4008]u8,
};

const IID_IObjectSafety_Value = Guid.initString("cb5bdc81-93c1-11cf-8f20-00805f2cd064");
pub const IID_IObjectSafety = &IID_IObjectSafety_Value;
pub const IObjectSafety = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterfaceSafetyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectSafety,
                riid: ?*const Guid,
                pdwSupportedOptions: ?*u32,
                pdwEnabledOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectSafety,
                riid: ?*const Guid,
                pdwSupportedOptions: ?*u32,
                pdwEnabledOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterfaceSafetyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn (
                self: *const IObjectSafety,
                riid: ?*const Guid,
                dwOptionSetMask: u32,
                dwEnabledOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn (
                self: *const IObjectSafety,
                riid: ?*const Guid,
                dwOptionSetMask: u32,
                dwEnabledOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type {
        return struct {
            pub usingnamespace IUnknown.MethodMixin(T);
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectSafety_GetInterfaceSafetyOptions(self: *const T, riid: ?*const Guid, pdwSupportedOptions: ?*u32, pdwEnabledOptions: ?*u32) HRESULT {
                return @as(*const IObjectSafety.VTable, @ptrCast(self.vtable)).GetInterfaceSafetyOptions(@as(*const IObjectSafety, @ptrCast(self)), riid, pdwSupportedOptions, pdwEnabledOptions);
            }
            // NOTE: method is namespaced with interface name to avoid conflicts for now
            pub inline fn IObjectSafety_SetInterfaceSafetyOptions(self: *const T, riid: ?*const Guid, dwOptionSetMask: u32, dwEnabledOptions: u32) HRESULT {
                return @as(*const IObjectSafety.VTable, @ptrCast(self.vtable)).SetInterfaceSafetyOptions(@as(*const IObjectSafety, @ptrCast(self)), riid, dwOptionSetMask, dwEnabledOptions);
            }
        };
    }
    pub usingnamespace MethodMixin(@This());
};

pub const WHEA_ERROR_SOURCE_TYPE = enum(i32) {
    MCE = 0,
    CMC = 1,
    CPE = 2,
    NMI = 3,
    PCIe = 4,
    Generic = 5,
    INIT = 6,
    BOOT = 7,
    SCIGeneric = 8,
    IPFMCA = 9,
    IPFCMC = 10,
    IPFCPE = 11,
    GenericV2 = 12,
    SCIGenericV2 = 13,
    BMC = 14,
    PMEM = 15,
    DeviceDriver = 16,
    Max = 17,
};
pub const WheaErrSrcTypeMCE = WHEA_ERROR_SOURCE_TYPE.MCE;
pub const WheaErrSrcTypeCMC = WHEA_ERROR_SOURCE_TYPE.CMC;
pub const WheaErrSrcTypeCPE = WHEA_ERROR_SOURCE_TYPE.CPE;
pub const WheaErrSrcTypeNMI = WHEA_ERROR_SOURCE_TYPE.NMI;
pub const WheaErrSrcTypePCIe = WHEA_ERROR_SOURCE_TYPE.PCIe;
pub const WheaErrSrcTypeGeneric = WHEA_ERROR_SOURCE_TYPE.Generic;
pub const WheaErrSrcTypeINIT = WHEA_ERROR_SOURCE_TYPE.INIT;
pub const WheaErrSrcTypeBOOT = WHEA_ERROR_SOURCE_TYPE.BOOT;
pub const WheaErrSrcTypeSCIGeneric = WHEA_ERROR_SOURCE_TYPE.SCIGeneric;
pub const WheaErrSrcTypeIPFMCA = WHEA_ERROR_SOURCE_TYPE.IPFMCA;
pub const WheaErrSrcTypeIPFCMC = WHEA_ERROR_SOURCE_TYPE.IPFCMC;
pub const WheaErrSrcTypeIPFCPE = WHEA_ERROR_SOURCE_TYPE.IPFCPE;
pub const WheaErrSrcTypeGenericV2 = WHEA_ERROR_SOURCE_TYPE.GenericV2;
pub const WheaErrSrcTypeSCIGenericV2 = WHEA_ERROR_SOURCE_TYPE.SCIGenericV2;
pub const WheaErrSrcTypeBMC = WHEA_ERROR_SOURCE_TYPE.BMC;
pub const WheaErrSrcTypePMEM = WHEA_ERROR_SOURCE_TYPE.PMEM;
pub const WheaErrSrcTypeDeviceDriver = WHEA_ERROR_SOURCE_TYPE.DeviceDriver;
pub const WheaErrSrcTypeMax = WHEA_ERROR_SOURCE_TYPE.Max;

pub const WHEA_ERROR_SOURCE_STATE = enum(i32) {
    Stopped = 1,
    Started = 2,
    Removed = 3,
    RemovePending = 4,
};
pub const WheaErrSrcStateStopped = WHEA_ERROR_SOURCE_STATE.Stopped;
pub const WheaErrSrcStateStarted = WHEA_ERROR_SOURCE_STATE.Started;
pub const WheaErrSrcStateRemoved = WHEA_ERROR_SOURCE_STATE.Removed;
pub const WheaErrSrcStateRemovePending = WHEA_ERROR_SOURCE_STATE.RemovePending;

pub const WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Context: ?*anyopaque,
        ErrorSourceId: u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
    else => *const fn (
        Context: ?*anyopaque,
        ErrorSourceId: u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
};

pub const WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn (
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
};

pub const WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER = switch (@import("builtin").zig_backend) {
    .stage1 => fn (
        ErrorSourceDesc: ?*anyopaque,
        MaximumSectionLength: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
    else => *const fn (
        ErrorSourceDesc: ?*anyopaque,
        MaximumSectionLength: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
};

pub const WHEA_ERROR_SOURCE_CONFIGURATION_DD = extern struct {
    Initialize: ?WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER align(1),
    Uninitialize: ?WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER align(1),
    Correct: ?WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER align(1),
};

pub const WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1 = extern struct {
    Version: u32 align(1),
    SourceGuid: Guid align(1),
    LogTag: u16 align(1),
    Reserved: [6]u8 align(1),
    Initialize: ?WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER align(1),
    Uninitialize: ?WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER align(1),
};

pub const WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER = extern struct {
    Version: u32 align(1),
    SourceGuid: Guid align(1),
    LogTag: u16 align(1),
    Reserved: [6]u8 align(1),
    Initialize: ?WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER align(1),
    Uninitialize: ?WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER align(1),
    MaxSectionDataLength: u32 align(1),
    MaxSectionsPerReport: u32 align(1),
    CreatorId: Guid align(1),
    PartitionId: Guid align(1),
};

pub const WHEA_DRIVER_BUFFER_SET = extern struct {
    Version: u32 align(1),
    Data: ?*u8 align(1),
    DataSize: u32 align(1),
    SectionTypeGuid: ?*Guid align(1),
    SectionFriendlyName: ?*u8 align(1),
    Flags: ?*u8 align(1),
};

pub const WHEA_NOTIFICATION_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const XPF_MC_BANK_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u8,
    },
    AsUCHAR: u8,
};

pub const XPF_MCE_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u32 align(1),
    } align(1),
    AsULONG: u32 align(1),
};

pub const AER_ROOTPORT_DESCRIPTOR_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const AER_ENDPOINT_DESCRIPTOR_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const AER_BRIDGE_DESCRIPTOR_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const WHEA_NOTIFICATION_DESCRIPTOR = extern struct {
    Type: u8,
    Length: u8,
    Flags: WHEA_NOTIFICATION_FLAGS,
    u: extern union {
        Polled: extern struct {
            PollInterval: u32 align(1),
        },
        Interrupt: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        LocalInterrupt: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Sci: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Nmi: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Sea: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Sei: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Gsiv: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
    },
};

pub const WHEA_XPF_MC_BANK_DESCRIPTOR = extern struct {
    BankNumber: u8 align(1),
    ClearOnInitialization: BOOLEAN align(1),
    StatusDataFormat: u8 align(1),
    Flags: XPF_MC_BANK_FLAGS align(1),
    ControlMsr: u32 align(1),
    StatusMsr: u32 align(1),
    AddressMsr: u32 align(1),
    MiscMsr: u32 align(1),
    ControlData: u64 align(1),
};

pub const WHEA_XPF_MCE_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    NumberOfBanks: u8 align(1),
    Flags: XPF_MCE_FLAGS align(1),
    MCG_Capability: u64 align(1),
    MCG_GlobalControl: u64 align(1),
    Banks: [32]WHEA_XPF_MC_BANK_DESCRIPTOR align(1),
};

pub const WHEA_XPF_CMC_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    NumberOfBanks: u8 align(1),
    Reserved: u32 align(1),
    Notify: WHEA_NOTIFICATION_DESCRIPTOR align(1),
    Banks: [32]WHEA_XPF_MC_BANK_DESCRIPTOR align(1),
};

pub const WHEA_PCI_SLOT_NUMBER = extern struct {
    u: extern union {
        bits: extern struct {
            _bitfield: u32 align(1),
        } align(1),
        AsULONG: u32 align(1),
    },
};

pub const WHEA_XPF_NMI_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
};

pub const WHEA_AER_ROOTPORT_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    BusNumber: u32 align(1),
    Slot: WHEA_PCI_SLOT_NUMBER align(1),
    DeviceControl: u16 align(1),
    Flags: AER_ROOTPORT_DESCRIPTOR_FLAGS align(1),
    UncorrectableErrorMask: u32 align(1),
    UncorrectableErrorSeverity: u32 align(1),
    CorrectableErrorMask: u32 align(1),
    AdvancedCapsAndControl: u32 align(1),
    RootErrorCommand: u32 align(1),
};

pub const WHEA_AER_ENDPOINT_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    BusNumber: u32 align(1),
    Slot: WHEA_PCI_SLOT_NUMBER align(1),
    DeviceControl: u16 align(1),
    Flags: AER_ENDPOINT_DESCRIPTOR_FLAGS align(1),
    UncorrectableErrorMask: u32 align(1),
    UncorrectableErrorSeverity: u32 align(1),
    CorrectableErrorMask: u32 align(1),
    AdvancedCapsAndControl: u32 align(1),
};

pub const WHEA_AER_BRIDGE_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    BusNumber: u32 align(1),
    Slot: WHEA_PCI_SLOT_NUMBER align(1),
    DeviceControl: u16 align(1),
    Flags: AER_BRIDGE_DESCRIPTOR_FLAGS align(1),
    UncorrectableErrorMask: u32 align(1),
    UncorrectableErrorSeverity: u32 align(1),
    CorrectableErrorMask: u32 align(1),
    AdvancedCapsAndControl: u32 align(1),
    SecondaryUncorrectableErrorMask: u32 align(1),
    SecondaryUncorrectableErrorSev: u32 align(1),
    SecondaryCapsAndControl: u32 align(1),
};

pub const WHEA_GENERIC_ERROR_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Reserved: u8 align(1),
    Enabled: u8 align(1),
    ErrStatusBlockLength: u32 align(1),
    RelatedErrorSourceId: u32 align(1),
    ErrStatusAddressSpaceID: u8 align(1),
    ErrStatusAddressBitWidth: u8 align(1),
    ErrStatusAddressBitOffset: u8 align(1),
    ErrStatusAddressAccessSize: u8 align(1),
    ErrStatusAddress: LARGE_INTEGER align(1),
    Notify: WHEA_NOTIFICATION_DESCRIPTOR align(1),
};

pub const WHEA_GENERIC_ERROR_DESCRIPTOR_V2 = extern struct {
    Type: u16 align(1),
    Reserved: u8 align(1),
    Enabled: u8 align(1),
    ErrStatusBlockLength: u32 align(1),
    RelatedErrorSourceId: u32 align(1),
    ErrStatusAddressSpaceID: u8 align(1),
    ErrStatusAddressBitWidth: u8 align(1),
    ErrStatusAddressBitOffset: u8 align(1),
    ErrStatusAddressAccessSize: u8 align(1),
    ErrStatusAddress: LARGE_INTEGER align(1),
    Notify: WHEA_NOTIFICATION_DESCRIPTOR align(1),
    ReadAckAddressSpaceID: u8 align(1),
    ReadAckAddressBitWidth: u8 align(1),
    ReadAckAddressBitOffset: u8 align(1),
    ReadAckAddressAccessSize: u8 align(1),
    ReadAckAddress: LARGE_INTEGER align(1),
    ReadAckPreserveMask: u64 align(1),
    ReadAckWriteMask: u64 align(1),
};

pub const WHEA_DEVICE_DRIVER_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    SourceGuid: Guid align(1),
    LogTag: u16 align(1),
    Reserved2: u16 align(1),
    PacketLength: u32 align(1),
    PacketCount: u32 align(1),
    PacketBuffer: ?*u8 align(1),
    Config: WHEA_ERROR_SOURCE_CONFIGURATION_DD align(1),
    CreatorId: Guid align(1),
    PartitionId: Guid align(1),
    MaxSectionDataLength: u32 align(1),
    MaxSectionsPerRecord: u32 align(1),
    PacketStateBuffer: ?*u8 align(1),
    OpenHandles: i32 align(1),
};

pub const WHEA_IPF_MCA_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    Reserved: u8 align(1),
};

pub const WHEA_IPF_CMC_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    Reserved: u8 align(1),
};

pub const WHEA_IPF_CPE_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    Reserved: u8 align(1),
};

pub const WHEA_ERROR_SOURCE_DESCRIPTOR = extern struct {
    Length: u32 align(1),
    Version: u32 align(1),
    Type: WHEA_ERROR_SOURCE_TYPE align(1),
    State: WHEA_ERROR_SOURCE_STATE align(1),
    MaxRawDataLength: u32 align(1),
    NumRecordsToPreallocate: u32 align(1),
    MaxSectionsPerRecord: u32 align(1),
    ErrorSourceId: u32 align(1),
    PlatformErrorSourceId: u32 align(1),
    Flags: u32 align(1),
    Info: extern union {
        XpfMceDescriptor: WHEA_XPF_MCE_DESCRIPTOR,
        XpfCmcDescriptor: WHEA_XPF_CMC_DESCRIPTOR,
        XpfNmiDescriptor: WHEA_XPF_NMI_DESCRIPTOR,
        IpfMcaDescriptor: WHEA_IPF_MCA_DESCRIPTOR,
        IpfCmcDescriptor: WHEA_IPF_CMC_DESCRIPTOR,
        IpfCpeDescriptor: WHEA_IPF_CPE_DESCRIPTOR,
        AerRootportDescriptor: WHEA_AER_ROOTPORT_DESCRIPTOR,
        AerEndpointDescriptor: WHEA_AER_ENDPOINT_DESCRIPTOR,
        AerBridgeDescriptor: WHEA_AER_BRIDGE_DESCRIPTOR,
        GenErrDescriptor: WHEA_GENERIC_ERROR_DESCRIPTOR,
        GenErrDescriptorV2: WHEA_GENERIC_ERROR_DESCRIPTOR_V2,
        DeviceDriverDescriptor: WHEA_DEVICE_DRIVER_DESCRIPTOR,
    } align(1),
};

pub const IPMI_OS_SEL_RECORD_TYPE = enum(i32) {
    Whea = 0,
    Other = 1,
    WheaErrorXpfMca = 2,
    WheaErrorPci = 3,
    WheaErrorNmi = 4,
    WheaErrorOther = 5,
    Raw = 6,
    Driver = 7,
    BugcheckRecovery = 8,
    BugcheckData = 9,
    Max = 10,
};
pub const IpmiOsSelRecordTypeWhea = IPMI_OS_SEL_RECORD_TYPE.Whea;
pub const IpmiOsSelRecordTypeOther = IPMI_OS_SEL_RECORD_TYPE.Other;
pub const IpmiOsSelRecordTypeWheaErrorXpfMca = IPMI_OS_SEL_RECORD_TYPE.WheaErrorXpfMca;
pub const IpmiOsSelRecordTypeWheaErrorPci = IPMI_OS_SEL_RECORD_TYPE.WheaErrorPci;
pub const IpmiOsSelRecordTypeWheaErrorNmi = IPMI_OS_SEL_RECORD_TYPE.WheaErrorNmi;
pub const IpmiOsSelRecordTypeWheaErrorOther = IPMI_OS_SEL_RECORD_TYPE.WheaErrorOther;
pub const IpmiOsSelRecordTypeRaw = IPMI_OS_SEL_RECORD_TYPE.Raw;
pub const IpmiOsSelRecordTypeDriver = IPMI_OS_SEL_RECORD_TYPE.Driver;
pub const IpmiOsSelRecordTypeBugcheckRecovery = IPMI_OS_SEL_RECORD_TYPE.BugcheckRecovery;
pub const IpmiOsSelRecordTypeBugcheckData = IPMI_OS_SEL_RECORD_TYPE.BugcheckData;
pub const IpmiOsSelRecordTypeMax = IPMI_OS_SEL_RECORD_TYPE.Max;

pub const IPMI_OS_SEL_RECORD = extern struct {
    Signature: u32 align(1),
    Version: u32 align(1),
    Length: u32 align(1),
    RecordType: IPMI_OS_SEL_RECORD_TYPE align(1),
    DataLength: u32 align(1),
    Data: [1]u8 align(1),
};

pub const CONTEXT = switch (@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ContextFlags: u32,
        Cpsr: u32,
        Anonymous: extern union {
            Anonymous: extern struct {
                X0: u64,
                X1: u64,
                X2: u64,
                X3: u64,
                X4: u64,
                X5: u64,
                X6: u64,
                X7: u64,
                X8: u64,
                X9: u64,
                X10: u64,
                X11: u64,
                X12: u64,
                X13: u64,
                X14: u64,
                X15: u64,
                X16: u64,
                X17: u64,
                X18: u64,
                X19: u64,
                X20: u64,
                X21: u64,
                X22: u64,
                X23: u64,
                X24: u64,
                X25: u64,
                X26: u64,
                X27: u64,
                X28: u64,
                Fp: u64,
                Lr: u64,
            },
            X: [31]u64,
        },
        Sp: u64,
        Pc: u64,
        V: [32]ARM64_NT_NEON128,
        Fpcr: u32,
        Fpsr: u32,
        Bcr: [8]u32,
        Bvr: [8]u64,
        Wcr: [2]u32,
        Wvr: [2]u64,
    },
    .X64 => extern struct {
        P1Home: u64,
        P2Home: u64,
        P3Home: u64,
        P4Home: u64,
        P5Home: u64,
        P6Home: u64,
        ContextFlags: u32,
        MxCsr: u32,
        SegCs: u16,
        SegDs: u16,
        SegEs: u16,
        SegFs: u16,
        SegGs: u16,
        SegSs: u16,
        EFlags: u32,
        Dr0: u64,
        Dr1: u64,
        Dr2: u64,
        Dr3: u64,
        Dr6: u64,
        Dr7: u64,
        Rax: u64,
        Rcx: u64,
        Rdx: u64,
        Rbx: u64,
        Rsp: u64,
        Rbp: u64,
        Rsi: u64,
        Rdi: u64,
        R8: u64,
        R9: u64,
        R10: u64,
        R11: u64,
        R12: u64,
        R13: u64,
        R14: u64,
        R15: u64,
        Rip: u64,
        Anonymous: extern union {
            FltSave: XSAVE_FORMAT,
            Anonymous: extern struct {
                Header: [2]M128A,
                Legacy: [8]M128A,
                Xmm0: M128A,
                Xmm1: M128A,
                Xmm2: M128A,
                Xmm3: M128A,
                Xmm4: M128A,
                Xmm5: M128A,
                Xmm6: M128A,
                Xmm7: M128A,
                Xmm8: M128A,
                Xmm9: M128A,
                Xmm10: M128A,
                Xmm11: M128A,
                Xmm12: M128A,
                Xmm13: M128A,
                Xmm14: M128A,
                Xmm15: M128A,
            },
        },
        VectorRegister: [26]M128A,
        VectorControl: u64,
        DebugControl: u64,
        LastBranchToRip: u64,
        LastBranchFromRip: u64,
        LastExceptionToRip: u64,
        LastExceptionFromRip: u64,
    },
    .X86 => extern struct {
        ContextFlags: u32,
        Dr0: u32,
        Dr1: u32,
        Dr2: u32,
        Dr3: u32,
        Dr6: u32,
        Dr7: u32,
        FloatSave: FLOATING_SAVE_AREA,
        SegGs: u32,
        SegFs: u32,
        SegEs: u32,
        SegDs: u32,
        Edi: u32,
        Esi: u32,
        Ebx: u32,
        Edx: u32,
        Ecx: u32,
        Eax: u32,
        Ebp: u32,
        Eip: u32,
        SegCs: u32,
        EFlags: u32,
        Esp: u32,
        SegSs: u32,
        ExtendedRegisters: [512]u8,
    },
};
pub const DISPATCHER_CONTEXT = switch (@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ControlPc: usize,
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
        EstablisherFrame: usize,
        TargetPc: usize,
        ContextRecord: ?*CONTEXT,
        LanguageHandler: ?EXCEPTION_ROUTINE,
        HandlerData: ?*anyopaque,
        HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ScopeIndex: u32,
        ControlPcIsUnwound: BOOLEAN,
        NonVolatileRegisters: ?*u8,
    },
    .X64 => extern struct {
        ControlPc: u64,
        ImageBase: u64,
        FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
        EstablisherFrame: u64,
        TargetIp: u64,
        ContextRecord: ?*CONTEXT,
        LanguageHandler: ?EXCEPTION_ROUTINE,
        HandlerData: ?*anyopaque,
        HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ScopeIndex: u32,
        Fill0: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PGET_RUNTIME_FUNCTION_CALLBACK = switch (@import("../../zig.zig").arch) {
    .Arm64 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
        else => *const fn (
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    },
    .X64 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
        else => *const fn (
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const KNONVOLATILE_CONTEXT_POINTERS_ARM64 = switch (@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        X19: ?*u64,
        X20: ?*u64,
        X21: ?*u64,
        X22: ?*u64,
        X23: ?*u64,
        X24: ?*u64,
        X25: ?*u64,
        X26: ?*u64,
        X27: ?*u64,
        X28: ?*u64,
        Fp: ?*u64,
        Lr: ?*u64,
        D8: ?*u64,
        D9: ?*u64,
        D10: ?*u64,
        D11: ?*u64,
        D12: ?*u64,
        D13: ?*u64,
        D14: ?*u64,
        D15: ?*u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const UNWIND_HISTORY_TABLE_ENTRY = switch (@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    },
    .X64 => extern struct {
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const MINIDUMP_THREAD_CALLBACK = switch (@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Pad: u32,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
    },
    .X64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
    },
    .X86 => extern struct {
        ThreadId: u32 align(4),
        ThreadHandle: ?HANDLE align(4),
        Context: CONTEXT align(4),
        SizeOfContext: u32 align(4),
        StackBase: u64 align(4),
        StackEnd: u64 align(4),
    },
};
pub const MINIDUMP_THREAD_EX_CALLBACK = switch (@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Pad: u32,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
        BackingStoreBase: u64,
        BackingStoreEnd: u64,
    },
    .X64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
        BackingStoreBase: u64,
        BackingStoreEnd: u64,
    },
    .X86 => extern struct {
        ThreadId: u32 align(4),
        ThreadHandle: ?HANDLE align(4),
        Context: CONTEXT align(4),
        SizeOfContext: u32 align(4),
        StackBase: u64 align(4),
        StackEnd: u64 align(4),
        BackingStoreBase: u64 align(4),
        BackingStoreEnd: u64 align(4),
    },
};
pub const XSAVE_FORMAT = switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ControlWord: u16,
        StatusWord: u16,
        TagWord: u8,
        Reserved1: u8,
        ErrorOpcode: u16,
        ErrorOffset: u32,
        ErrorSelector: u16,
        Reserved2: u16,
        DataOffset: u32,
        DataSelector: u16,
        Reserved3: u16,
        MxCsr: u32,
        MxCsr_Mask: u32,
        FloatRegisters: [8]M128A,
        XmmRegisters: [16]M128A,
        Reserved4: [96]u8,
    },
    .X86 => extern struct {
        ControlWord: u16,
        StatusWord: u16,
        TagWord: u8,
        Reserved1: u8,
        ErrorOpcode: u16,
        ErrorOffset: u32,
        ErrorSelector: u16,
        Reserved2: u16,
        DataOffset: u32,
        DataSelector: u16,
        Reserved3: u16,
        MxCsr: u32,
        MxCsr_Mask: u32,
        FloatRegisters: [8]M128A,
        XmmRegisters: [8]M128A,
        Reserved4: [224]u8,
    },
};
pub const XSTATE_CONTEXT = switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Mask: u64,
        Length: u32,
        Reserved1: u32,
        Area: ?*XSAVE_AREA,
        Buffer: ?*anyopaque,
    },
    .X86 => extern struct {
        Mask: u64,
        Length: u32,
        Reserved1: u32,
        Area: ?*XSAVE_AREA,
        Reserved2: u32,
        Buffer: ?*anyopaque,
        Reserved3: u32,
    },
};
pub const KNONVOLATILE_CONTEXT_POINTERS = switch (@import("../../zig.zig").arch) {
    .X64 => extern struct {
        Anonymous1: extern union {
            FloatingContext: [16]?*M128A,
            Anonymous: extern struct {
                Xmm0: ?*M128A,
                Xmm1: ?*M128A,
                Xmm2: ?*M128A,
                Xmm3: ?*M128A,
                Xmm4: ?*M128A,
                Xmm5: ?*M128A,
                Xmm6: ?*M128A,
                Xmm7: ?*M128A,
                Xmm8: ?*M128A,
                Xmm9: ?*M128A,
                Xmm10: ?*M128A,
                Xmm11: ?*M128A,
                Xmm12: ?*M128A,
                Xmm13: ?*M128A,
                Xmm14: ?*M128A,
                Xmm15: ?*M128A,
            },
        },
        Anonymous2: extern union {
            IntegerContext: [16]?*u64,
            Anonymous: extern struct {
                Rax: ?*u64,
                Rcx: ?*u64,
                Rdx: ?*u64,
                Rbx: ?*u64,
                Rsp: ?*u64,
                Rbp: ?*u64,
                Rsi: ?*u64,
                Rdi: ?*u64,
                R8: ?*u64,
                R9: ?*u64,
                R10: ?*u64,
                R11: ?*u64,
                R12: ?*u64,
                R13: ?*u64,
                R14: ?*u64,
                R15: ?*u64,
            },
        },
    },
    .X86 => extern struct {
        Dummy: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const ARM64_NT_CONTEXT = switch (@import("../../zig.zig").arch) {
    .X86, .X64 => extern struct {
        ContextFlags: u32,
        Cpsr: u32,
        Anonymous: extern union {
            Anonymous: extern struct {
                X0: u64,
                X1: u64,
                X2: u64,
                X3: u64,
                X4: u64,
                X5: u64,
                X6: u64,
                X7: u64,
                X8: u64,
                X9: u64,
                X10: u64,
                X11: u64,
                X12: u64,
                X13: u64,
                X14: u64,
                X15: u64,
                X16: u64,
                X17: u64,
                X18: u64,
                X19: u64,
                X20: u64,
                X21: u64,
                X22: u64,
                X23: u64,
                X24: u64,
                X25: u64,
                X26: u64,
                X27: u64,
                X28: u64,
                Fp: u64,
                Lr: u64,
            },
            X: [31]u64,
        },
        Sp: u64,
        Pc: u64,
        V: [32]ARM64_NT_NEON128,
        Fpcr: u32,
        Fpsr: u32,
        Bcr: [8]u32,
        Bvr: [8]u64,
        Wcr: [2]u32,
        Wvr: [2]u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const DISPATCHER_CONTEXT_ARM64 = switch (@import("../../zig.zig").arch) {
    .X86, .X64 => extern struct {
        ControlPc: usize,
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
        EstablisherFrame: usize,
        TargetPc: usize,
        ContextRecord: ?*ARM64_NT_CONTEXT,
        LanguageHandler: ?EXCEPTION_ROUTINE,
        HandlerData: ?*anyopaque,
        HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ScopeIndex: u32,
        ControlPcIsUnwound: BOOLEAN,
        NonVolatileRegisters: ?*u8,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const UNWIND_HISTORY_TABLE = switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Count: u32,
        LocalHint: u8,
        GlobalHint: u8,
        Search: u8,
        Once: u8,
        LowAddress: usize,
        HighAddress: usize,
        Entry: [12]UNWIND_HISTORY_TABLE_ENTRY,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const LOADED_IMAGE = switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ModuleName: ?PSTR,
        hFile: ?HANDLE,
        MappedAddress: ?*u8,
        FileHeader: ?*IMAGE_NT_HEADERS64,
        LastRvaSection: ?*IMAGE_SECTION_HEADER,
        NumberOfSections: u32,
        Sections: ?*IMAGE_SECTION_HEADER,
        Characteristics: IMAGE_FILE_CHARACTERISTICS2,
        fSystemImage: BOOLEAN,
        fDOSImage: BOOLEAN,
        fReadOnly: BOOLEAN,
        Version: u8,
        Links: LIST_ENTRY,
        SizeOfImage: u32,
    },
    .X86 => extern struct {
        ModuleName: ?PSTR,
        hFile: ?HANDLE,
        MappedAddress: ?*u8,
        FileHeader: ?*IMAGE_NT_HEADERS32,
        LastRvaSection: ?*IMAGE_SECTION_HEADER,
        NumberOfSections: u32,
        Sections: ?*IMAGE_SECTION_HEADER,
        Characteristics: IMAGE_FILE_CHARACTERISTICS2,
        fSystemImage: BOOLEAN,
        fDOSImage: BOOLEAN,
        fReadOnly: BOOLEAN,
        Version: u8,
        Links: LIST_ENTRY,
        SizeOfImage: u32,
    },
};
pub const IMAGE_DEBUG_INFORMATION = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        List: LIST_ENTRY,
        ReservedSize: u32,
        ReservedMappedBase: ?*anyopaque,
        ReservedMachine: u16,
        ReservedCharacteristics: u16,
        ReservedCheckSum: u32,
        ImageBase: u32,
        SizeOfImage: u32,
        ReservedNumberOfSections: u32,
        ReservedSections: ?*IMAGE_SECTION_HEADER,
        ReservedExportedNamesSize: u32,
        ReservedExportedNames: ?PSTR,
        ReservedNumberOfFunctionTableEntries: u32,
        ReservedFunctionTableEntries: ?*IMAGE_FUNCTION_ENTRY,
        ReservedLowestFunctionStartingAddress: u32,
        ReservedHighestFunctionEndingAddress: u32,
        ReservedNumberOfFpoTableEntries: u32,
        ReservedFpoTableEntries: ?*FPO_DATA,
        SizeOfCoffSymbols: u32,
        CoffSymbols: ?*IMAGE_COFF_SYMBOLS_HEADER,
        ReservedSizeOfCodeViewSymbols: u32,
        ReservedCodeViewSymbols: ?*anyopaque,
        ImageFilePath: ?PSTR,
        ImageFileName: ?PSTR,
        ReservedDebugFilePath: ?PSTR,
        ReservedTimeDateStamp: u32,
        ReservedRomImage: BOOL,
        ReservedDebugDirectory: ?*IMAGE_DEBUG_DIRECTORY,
        ReservedNumberOfDebugDirectories: u32,
        ReservedOriginalFunctionTableBaseAddress: u32,
        Reserved: [2]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const ADDRESS = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        Offset: u32,
        Segment: u16,
        Mode: ADDRESS_MODE,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const KDHELP = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        Thread: u32,
        ThCallbackStack: u32,
        NextCallback: u32,
        FramePointer: u32,
        KiCallUserMode: u32,
        KeUserCallbackDispatcher: u32,
        SystemRangeStart: u32,
        ThCallbackBStore: u32,
        KiUserExceptionDispatcher: u32,
        StackBase: u32,
        StackLimit: u32,
        Reserved: [5]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const STACKFRAME = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        AddrPC: ADDRESS,
        AddrReturn: ADDRESS,
        AddrFrame: ADDRESS,
        AddrStack: ADDRESS,
        FuncTableEntry: ?*anyopaque,
        Params: [4]u32,
        Far: BOOL,
        Virtual: BOOL,
        Reserved: [3]u32,
        KdHelp: KDHELP,
        AddrBStore: ADDRESS,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PREAD_PROCESS_MEMORY_ROUTINE = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            hProcess: ?HANDLE,
            lpBaseAddress: u32,
            // TODO: what to do with BytesParamIndex 3?
            lpBuffer: ?*anyopaque,
            nSize: u32,
            lpNumberOfBytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn (
            hProcess: ?HANDLE,
            lpBaseAddress: u32,
            // TODO: what to do with BytesParamIndex 3?
            lpBuffer: ?*anyopaque,
            nSize: u32,
            lpNumberOfBytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PFUNCTION_TABLE_ACCESS_ROUTINE = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            hProcess: ?HANDLE,
            AddrBase: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        else => *const fn (
            hProcess: ?HANDLE,
            AddrBase: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PGET_MODULE_BASE_ROUTINE = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            hProcess: ?HANDLE,
            Address: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        else => *const fn (
            hProcess: ?HANDLE,
            Address: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PTRANSLATE_ADDRESS_ROUTINE = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            hProcess: ?HANDLE,
            hThread: ?HANDLE,
            lpaddr: ?*ADDRESS,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        else => *const fn (
            hProcess: ?HANDLE,
            hThread: ?HANDLE,
            lpaddr: ?*ADDRESS,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMMODULES_CALLBACK = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            ModuleName: ?[*:0]const u8,
            BaseOfDll: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn (
            ModuleName: ?[*:0]const u8,
            BaseOfDll: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMSYMBOLS_CALLBACK = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            SymbolName: ?[*:0]const u8,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn (
            SymbolName: ?[*:0]const u8,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMSYMBOLS_CALLBACKW = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            SymbolName: ?[*:0]const u16,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn (
            SymbolName: ?[*:0]const u16,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PENUMLOADED_MODULES_CALLBACK = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            ModuleName: ?[*:0]const u8,
            ModuleBase: u32,
            ModuleSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn (
            ModuleName: ?[*:0]const u8,
            ModuleBase: u32,
            ModuleSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYMBOL_REGISTERED_CALLBACK = switch (@import("../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn (
            hProcess: ?HANDLE,
            ActionCode: u32,
            CallbackData: ?*anyopaque,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn (
            hProcess: ?HANDLE,
            ActionCode: u32,
            CallbackData: ?*anyopaque,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOL = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Address: u32,
        Size: u32,
        Flags: u32,
        MaxNameLength: u32,
        Name: [1]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOL_PACKAGE = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        sym: IMAGEHLP_SYMBOL,
        name: [2001]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOLW = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Address: u32,
        Size: u32,
        Flags: u32,
        MaxNameLength: u32,
        Name: [1]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOLW_PACKAGE = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        sym: IMAGEHLP_SYMBOLW,
        name: [2001]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_MODULE = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        ImageSize: u32,
        TimeDateStamp: u32,
        CheckSum: u32,
        NumSyms: u32,
        SymType: SYM_TYPE,
        ModuleName: [32]CHAR,
        ImageName: [256]CHAR,
        LoadedImageName: [256]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_MODULEW = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        ImageSize: u32,
        TimeDateStamp: u32,
        CheckSum: u32,
        NumSyms: u32,
        SymType: SYM_TYPE,
        ModuleName: [32]u16,
        ImageName: [256]u16,
        LoadedImageName: [256]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_LINE = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Key: ?*anyopaque,
        LineNumber: u32,
        FileName: ?[*]u8,
        Address: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_LINEW = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Key: ?*anyopaque,
        LineNumber: u32,
        FileName: ?[*]u8,
        Address: u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_DEFERRED_SYMBOL_LOAD = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        CheckSum: u32,
        TimeDateStamp: u32,
        FileName: [260]CHAR,
        Reparse: BOOLEAN,
        hFile: ?HANDLE,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_DUPLICATE_SYMBOL = switch (@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        NumberOfDups: u32,
        Symbol: ?*IMAGEHLP_SYMBOL,
        SelectedSymbol: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

//--------------------------------------------------------------------------------
// Section: Functions (328)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../../zig.zig").arch) {
    .Arm64 => struct {
        pub extern "kernel32" fn RtlAddFunctionTable(
            FunctionTable: [*]IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
            EntryCount: u32,
            BaseAddress: usize,
        ) callconv(@import("std").os.windows.WINAPI) BOOLEAN;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .Arm64 => struct {
        pub extern "kernel32" fn RtlDeleteFunctionTable(
            FunctionTable: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) BOOLEAN;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .Arm64 => struct {

        // TODO: this type is limited to platform 'windows8.0'
        pub extern "ntdll" fn RtlAddGrowableFunctionTable(
            DynamicTable: ?*?*anyopaque,
            FunctionTable: [*]IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
            EntryCount: u32,
            MaximumEntryCount: u32,
            RangeBase: usize,
            RangeEnd: usize,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .Arm64 => struct {
        pub extern "kernel32" fn RtlLookupFunctionEntry(
            ControlPc: usize,
            ImageBase: ?*usize,
            HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .Arm64 => struct {
        pub extern "kernel32" fn RtlVirtualUnwind(
            HandlerType: RTL_VIRTUAL_UNWIND_HANDLER_TYPE,
            ImageBase: usize,
            ControlPc: usize,
            FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
            ContextRecord: ?*CONTEXT,
            HandlerData: ?*?*anyopaque,
            EstablisherFrame: ?*usize,
            ContextPointers: ?*KNONVOLATILE_CONTEXT_POINTERS_ARM64,
        ) callconv(@import("std").os.windows.WINAPI) ?EXCEPTION_ROUTINE;
    },
    else => struct {},
};

pub extern "dbgeng" fn DebugConnect(
    RemoteOptions: ?[*:0]const u8,
    InterfaceId: ?*const Guid,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugConnectWide(
    RemoteOptions: ?[*:0]const u16,
    InterfaceId: ?*const Guid,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugCreate(
    InterfaceId: ?*const Guid,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugCreateEx(
    InterfaceId: ?*const Guid,
    DbgEngOptions: u32,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgmodel" fn CreateDataModelManager(
    debugHost: ?*IDebugHost,
    manager: ?*?*IDataModelManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReadProcessMemory(
    hProcess: ?HANDLE,
    lpBaseAddress: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    nSize: usize,
    lpNumberOfBytesRead: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WriteProcessMemory(
    hProcess: ?HANDLE,
    lpBaseAddress: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*const anyopaque,
    nSize: usize,
    lpNumberOfBytesWritten: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*const CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FlushInstructionCache(
    hProcess: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBaseAddress: ?*const anyopaque,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64GetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64SetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*const WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RtlCaptureStackBackTrace(
    FramesToSkip: u32,
    FramesToCapture: u32,
    BackTrace: [*]?*anyopaque,
    BackTraceHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RtlCaptureContext(
    ContextRecord: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64 => struct {
        pub extern "kernel32" fn RtlCaptureContext2(
            ContextRecord: ?*CONTEXT,
        ) callconv(@import("std").os.windows.WINAPI) void;
    },
    else => struct {},
};

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RtlUnwind(
    TargetFrame: ?*anyopaque,
    TargetIp: ?*anyopaque,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ReturnValue: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64 => struct {
        pub extern "kernel32" fn RtlAddFunctionTable(
            FunctionTable: [*]IMAGE_RUNTIME_FUNCTION_ENTRY,
            EntryCount: u32,
            BaseAddress: u64,
        ) callconv(@import("std").os.windows.WINAPI) BOOLEAN;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64 => struct {
        pub extern "kernel32" fn RtlDeleteFunctionTable(
            FunctionTable: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) BOOLEAN;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "kernel32" fn RtlInstallFunctionTableCallback(
            TableIdentifier: u64,
            BaseAddress: u64,
            Length: u32,
            Callback: ?PGET_RUNTIME_FUNCTION_CALLBACK,
            Context: ?*anyopaque,
            OutOfProcessCallbackDll: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) BOOLEAN;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64 => struct {

        // TODO: this type is limited to platform 'windows8.0'
        pub extern "ntdll" fn RtlAddGrowableFunctionTable(
            DynamicTable: ?*?*anyopaque,
            FunctionTable: [*]IMAGE_RUNTIME_FUNCTION_ENTRY,
            EntryCount: u32,
            MaximumEntryCount: u32,
            RangeBase: usize,
            RangeEnd: usize,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {

        // TODO: this type is limited to platform 'windows8.0'
        pub extern "ntdll" fn RtlGrowFunctionTable(
            DynamicTable: ?*anyopaque,
            NewEntryCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) void;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {

        // TODO: this type is limited to platform 'windows8.0'
        pub extern "ntdll" fn RtlDeleteGrowableFunctionTable(
            DynamicTable: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) void;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64 => struct {
        pub extern "kernel32" fn RtlLookupFunctionEntry(
            ControlPc: u64,
            ImageBase: ?*u64,
            HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY;
    },
    else => struct {},
};

pub extern "kernel32" fn RtlRestoreContext(
    ContextRecord: ?*CONTEXT,
    ExceptionRecord: ?*EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "kernel32" fn RtlUnwindEx(
            TargetFrame: ?*anyopaque,
            TargetIp: ?*anyopaque,
            ExceptionRecord: ?*EXCEPTION_RECORD,
            ReturnValue: ?*anyopaque,
            ContextRecord: ?*CONTEXT,
            HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ) callconv(@import("std").os.windows.WINAPI) void;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64 => struct {
        pub extern "kernel32" fn RtlVirtualUnwind(
            HandlerType: RTL_VIRTUAL_UNWIND_HANDLER_TYPE,
            ImageBase: u64,
            ControlPc: u64,
            FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
            ContextRecord: ?*CONTEXT,
            HandlerData: ?*?*anyopaque,
            EstablisherFrame: ?*u64,
            ContextPointers: ?*KNONVOLATILE_CONTEXT_POINTERS,
        ) callconv(@import("std").os.windows.WINAPI) ?EXCEPTION_ROUTINE;
    },
    else => struct {},
};

pub extern "kernel32" fn RtlRaiseException(
    ExceptionRecord: ?*EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn RtlPcToFileHeader(
    PcValue: ?*anyopaque,
    BaseOfImage: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn IsDebuggerPresent() callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugBreak() callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn OutputDebugStringA(
    lpOutputString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn OutputDebugStringW(
    lpOutputString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ContinueDebugEvent(
    dwProcessId: u32,
    dwThreadId: u32,
    dwContinueStatus: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WaitForDebugEvent(
    lpDebugEvent: ?*DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugActiveProcess(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugActiveProcessStop(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CheckRemoteDebuggerPresent(
    hProcess: ?HANDLE,
    pbDebuggerPresent: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "kernel32" fn WaitForDebugEventEx(
    lpDebugEvent: ?*DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn EncodePointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn DecodePointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn EncodeSystemPointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn DecodeSystemPointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "api-ms-win-core-util-l1-1-1" fn EncodeRemotePointer(
    ProcessHandle: ?HANDLE,
    Ptr: ?*anyopaque,
    EncodedPtr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-util-l1-1-1" fn DecodeRemotePointer(
    ProcessHandle: ?HANDLE,
    Ptr: ?*anyopaque,
    DecodedPtr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn Beep(
    dwFreq: u32,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RaiseException(
    dwExceptionCode: u32,
    dwExceptionFlags: u32,
    nNumberOfArguments: u32,
    lpArguments: ?[*]const usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn UnhandledExceptionFilter(
    ExceptionInfo: ?*EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetUnhandledExceptionFilter(
    lpTopLevelExceptionFilter: ?LPTOP_LEVEL_EXCEPTION_FILTER,
) callconv(@import("std").os.windows.WINAPI) ?LPTOP_LEVEL_EXCEPTION_FILTER;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetErrorMode() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetErrorMode(
    uMode: THREAD_ERROR_MODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn AddVectoredExceptionHandler(
    First: u32,
    Handler: ?PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RemoveVectoredExceptionHandler(
    Handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn AddVectoredContinueHandler(
    First: u32,
    Handler: ?PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn RemoveVectoredContinueHandler(
    Handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn RaiseFailFastException(
    pExceptionRecord: ?*EXCEPTION_RECORD,
    pContextRecord: ?*CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FatalAppExitA(
    uAction: u32,
    lpMessageText: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FatalAppExitW(
    uAction: u32,
    lpMessageText: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn GetThreadErrorMode() callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn SetThreadErrorMode(
    dwNewMode: THREAD_ERROR_MODE,
    lpOldMode: ?*THREAD_ERROR_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-errorhandling-l1-1-3" fn TerminateProcessOnMemoryExhaustion(
    FailedAllocationSize: usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn OpenThreadWaitChainSession(
    Flags: OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS,
    callback: ?PWAITCHAINCALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn CloseThreadWaitChainSession(
    WctHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn GetThreadWaitChain(
    WctHandle: ?*anyopaque,
    Context: usize,
    Flags: WAIT_CHAIN_THREAD_OPTIONS,
    ThreadId: u32,
    NodeCount: ?*u32,
    NodeInfoArray: [*]WAITCHAIN_NODE_INFO,
    IsCycle: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn RegisterWaitChainCOMCallback(
    CallStateCallback: ?PCOGETCALLSTATE,
    ActivationStateCallback: ?PCOGETACTIVATIONSTATE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn MiniDumpWriteDump(
    hProcess: ?HANDLE,
    ProcessId: u32,
    hFile: ?HANDLE,
    DumpType: MINIDUMP_TYPE,
    ExceptionParam: ?*MINIDUMP_EXCEPTION_INFORMATION,
    UserStreamParam: ?*MINIDUMP_USER_STREAM_INFORMATION,
    CallbackParam: ?*MINIDUMP_CALLBACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MiniDumpReadDumpStream(
    BaseOfDump: ?*anyopaque,
    StreamNumber: u32,
    Dir: ?*?*MINIDUMP_DIRECTORY,
    StreamPointer: ?*?*anyopaque,
    StreamSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn BindImage(
    ImageName: ?[*:0]const u8,
    DllPath: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn BindImageEx(
    Flags: u32,
    ImageName: ?[*:0]const u8,
    DllPath: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    StatusRoutine: ?PIMAGEHLP_STATUS_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ReBaseImage(
    CurrentImageName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    fReBase: BOOL,
    fRebaseSysfileOk: BOOL,
    fGoingDown: BOOL,
    CheckImageSize: u32,
    OldImageSize: ?*u32,
    OldImageBase: ?*usize,
    NewImageSize: ?*u32,
    NewImageBase: ?*usize,
    TimeStamp: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ReBaseImage64(
    CurrentImageName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    fReBase: BOOL,
    fRebaseSysfileOk: BOOL,
    fGoingDown: BOOL,
    CheckImageSize: u32,
    OldImageSize: ?*u32,
    OldImageBase: ?*u64,
    NewImageSize: ?*u32,
    NewImageBase: ?*u64,
    TimeStamp: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {

        // TODO: this type is limited to platform 'windows5.1.2600'
        pub extern "imagehlp" fn CheckSumMappedFile(
            BaseAddress: ?*anyopaque,
            FileLength: u32,
            HeaderSum: ?*u32,
            CheckSum: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS64;
    },
    else => struct {},
};

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn MapFileAndCheckSumA(
    Filename: ?[*:0]const u8,
    HeaderSum: ?*u32,
    CheckSum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn MapFileAndCheckSumW(
    Filename: ?[*:0]const u16,
    HeaderSum: ?*u32,
    CheckSum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {

        // TODO: this type is limited to platform 'windows5.1.2600'
        pub extern "imagehlp" fn GetImageConfigInformation(
            LoadedImage: ?*LOADED_IMAGE,
            ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn GetImageUnusedHeaderBytes(
    LoadedImage: ?*LOADED_IMAGE,
    SizeUnusedHeaderBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {

        // TODO: this type is limited to platform 'windows5.1.2600'
        pub extern "imagehlp" fn SetImageConfigInformation(
            LoadedImage: ?*LOADED_IMAGE,
            ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageGetDigestStream(
    FileHandle: ?HANDLE,
    DigestLevel: u32,
    DigestFunction: ?DIGEST_FUNCTION,
    DigestHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageAddCertificate(
    FileHandle: ?HANDLE,
    Certificate: ?*WIN_CERTIFICATE,
    Index: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageRemoveCertificate(
    FileHandle: ?HANDLE,
    Index: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageEnumerateCertificates(
    FileHandle: ?HANDLE,
    TypeFilter: u16,
    CertificateCount: ?*u32,
    Indices: ?[*]u32,
    IndexCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageGetCertificateData(
    FileHandle: ?HANDLE,
    CertificateIndex: u32,
    Certificate: ?*WIN_CERTIFICATE,
    RequiredLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageGetCertificateHeader(
    FileHandle: ?HANDLE,
    CertificateIndex: u32,
    Certificateheader: ?*WIN_CERTIFICATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageLoad(
    DllName: ?[*:0]const u8,
    DllPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*LOADED_IMAGE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageUnload(
    LoadedImage: ?*LOADED_IMAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn MapAndLoad(
    ImageName: ?[*:0]const u8,
    DllPath: ?[*:0]const u8,
    LoadedImage: ?*LOADED_IMAGE,
    DotDll: BOOL,
    ReadOnly: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn UnMapAndLoad(
    LoadedImage: ?*LOADED_IMAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn TouchFileTimes(
    FileHandle: ?HANDLE,
    pSystemTime: ?*SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn UpdateDebugInfoFile(
    ImageFileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
    NtHeaders: ?*IMAGE_NT_HEADERS32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn UpdateDebugInfoFileEx(
    ImageFileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
    NtHeaders: ?*IMAGE_NT_HEADERS32,
    OldCheckSum: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindDebugInfoFile(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindDebugInfoFileW(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u16,
    DebugFilePath: ?PWSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFile(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFileEx(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFileExW(
    FileName: ?[*:0]const u16,
    SymbolPath: ?[*:0]const u16,
    DebugFilePath: ?PWSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindFileInPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    id: ?*anyopaque,
    two: u32,
    three: u32,
    flags: SYM_FIND_ID_OPTION,
    FoundFile: ?PSTR,
    callback: ?PFINDFILEINPATHCALLBACK,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindFileInPathW(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u16,
    FileName: ?[*:0]const u16,
    id: ?*anyopaque,
    two: u32,
    three: u32,
    flags: SYM_FIND_ID_OPTION,
    FoundFile: ?PWSTR,
    callback: ?PFINDFILEINPATHCALLBACKW,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindExecutableImage(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u8,
    ImageFilePath: ?PSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindExecutableImageW(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u16,
    ImageFilePath: ?PWSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImage(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    ImageFilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImageEx(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    ImageFilePath: ?PSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImageExW(
    FileName: ?[*:0]const u16,
    SymbolPath: ?[*:0]const u16,
    ImageFilePath: ?PWSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "dbghelp" fn ImageNtHeader(
            Base: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS64;
    },
    else => struct {},
};

pub extern "dbghelp" fn ImageDirectoryEntryToDataEx(
    Base: ?*anyopaque,
    MappedAsImage: BOOLEAN,
    DirectoryEntry: IMAGE_DIRECTORY_ENTRY,
    Size: ?*u32,
    FoundHeader: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn ImageDirectoryEntryToData(
    Base: ?*anyopaque,
    MappedAsImage: BOOLEAN,
    DirectoryEntry: IMAGE_DIRECTORY_ENTRY,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "dbghelp" fn ImageRvaToSection(
            NtHeaders: ?*IMAGE_NT_HEADERS64,
            Base: ?*anyopaque,
            Rva: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_SECTION_HEADER;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X64, .Arm64 => struct {
        pub extern "dbghelp" fn ImageRvaToVa(
            NtHeaders: ?*IMAGE_NT_HEADERS64,
            Base: ?*anyopaque,
            Rva: u32,
            LastRvaSection: ?*?*IMAGE_SECTION_HEADER,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;
    },
    else => struct {},
};

pub extern "dbghelp" fn SearchTreeForFile(
    RootPath: ?[*:0]const u8,
    InputPathName: ?[*:0]const u8,
    OutputPathBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SearchTreeForFileW(
    RootPath: ?[*:0]const u16,
    InputPathName: ?[*:0]const u16,
    OutputPathBuffer: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumDirTree(
    hProcess: ?HANDLE,
    RootPath: ?[*:0]const u8,
    InputPathName: ?[*:0]const u8,
    OutputPathBuffer: ?PSTR,
    cb: ?PENUMDIRTREE_CALLBACK,
    data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumDirTreeW(
    hProcess: ?HANDLE,
    RootPath: ?[*:0]const u16,
    InputPathName: ?[*:0]const u16,
    OutputPathBuffer: ?PWSTR,
    cb: ?PENUMDIRTREE_CALLBACKW,
    data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MakeSureDirectoryPathExists(
    DirPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn UnDecorateSymbolName(
    name: ?[*:0]const u8,
    outputString: [*:0]u8,
    maxStringLength: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn UnDecorateSymbolNameW(
    name: ?[*:0]const u16,
    outputString: [*:0]u16,
    maxStringLength: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn StackWalk64(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME64,
    ContextRecord: ?*anyopaque,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn StackWalkEx(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME_EX,
    ContextRecord: ?*anyopaque,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn ImagehlpApiVersion() callconv(@import("std").os.windows.WINAPI) ?*API_VERSION;

pub extern "dbghelp" fn ImagehlpApiVersionEx(
    AppVersion: ?*API_VERSION,
) callconv(@import("std").os.windows.WINAPI) ?*API_VERSION;

pub extern "dbghelp" fn GetTimestampForLoadedLibrary(
    Module: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymSetParentWindow(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetHomeDirectory(
    hProcess: ?HANDLE,
    dir: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSetHomeDirectoryW(
    hProcess: ?HANDLE,
    dir: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetHomeDirectory(
    type: IMAGEHLP_HD_TYPE,
    dir: [*:0]u8,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymGetHomeDirectoryW(
    type: IMAGEHLP_HD_TYPE,
    dir: [*:0]u16,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetOmaps(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    OmapTo: ?*?*OMAP,
    cOmapTo: ?*u64,
    OmapFrom: ?*?*OMAP,
    cOmapFrom: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetOptions(
    SymOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymGetOptions() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymCleanup(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetExtendedOption(
    option: IMAGEHLP_EXTENDED_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetExtendedOption(
    option: IMAGEHLP_EXTENDED_OPTIONS,
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchString(
    string: ?[*:0]const u8,
    expression: ?[*:0]const u8,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchStringA(
    string: ?[*:0]const u8,
    expression: ?[*:0]const u8,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchStringW(
    string: ?[*:0]const u16,
    expression: ?[*:0]const u16,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFiles(
    hProcess: ?HANDLE,
    ModBase: u64,
    Mask: ?[*:0]const u8,
    cbSrcFiles: ?PSYM_ENUMSOURCEFILES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFilesW(
    hProcess: ?HANDLE,
    ModBase: u64,
    Mask: ?[*:0]const u16,
    cbSrcFiles: ?PSYM_ENUMSOURCEFILES_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateModules64(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateModulesW64(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACKW64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesEx(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesExW(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACKW64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModules64(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesW64(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACKW64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFunctionTableAccess64(
    hProcess: ?HANDLE,
    AddrBase: u64,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn SymFunctionTableAccess64AccessRoutines(
    hProcess: ?HANDLE,
    AddrBase: u64,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn SymGetUnwindInfo(
    hProcess: ?HANDLE,
    Address: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleInfo64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    ModuleInfo: ?*IMAGEHLP_MODULE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleInfoW64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    ModuleInfo: ?*IMAGEHLP_MODULEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleBase64(
    hProcess: ?HANDLE,
    qwAddr: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "dbghelp" fn SymEnumLines(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u8,
    File: ?[*:0]const u8,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumLinesW(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u16,
    File: ?[*:0]const u16,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromAddr64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    pdwDisplacement: ?*u32,
    Line64: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromAddrW64(
    hProcess: ?HANDLE,
    dwAddr: u64,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromInlineContext(
    hProcess: ?HANDLE,
    qwAddr: u64,
    InlineContext: u32,
    qwModuleBaseAddress: u64,
    pdwDisplacement: ?*u32,
    Line64: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromInlineContextW(
    hProcess: ?HANDLE,
    dwAddr: u64,
    InlineContext: u32,
    qwModuleBaseAddress: u64,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceLines(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Line: u32,
    Flags: u32,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceLinesW(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Line: u32,
    Flags: u32,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddrIncludeInlineTrace(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymCompareInlineTrace(
    hProcess: ?HANDLE,
    Address1: u64,
    InlineContext1: u32,
    RetAddress1: u64,
    Address2: u64,
    RetAddress2: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymQueryInlineTrace(
    hProcess: ?HANDLE,
    StartAddress: u64,
    StartContext: u32,
    StartRetAddress: u64,
    CurAddress: u64,
    CurContext: ?*u32,
    CurFrameIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromName64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromNameW64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u16,
    FileName: ?[*:0]const u16,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineNext64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineNextW64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLinePrev64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLinePrevW64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetFileLineOffsets64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    Buffer: [*]u64,
    BufferLines: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymMatchFileName(
    FileName: ?[*:0]const u8,
    Match: ?[*:0]const u8,
    FileNameStop: ?*?PSTR,
    MatchStop: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchFileNameW(
    FileName: ?[*:0]const u16,
    Match: ?[*:0]const u16,
    FileNameStop: ?*?PWSTR,
    MatchStop: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFile(
    hProcess: ?HANDLE,
    Base: u64,
    Params: ?[*:0]const u8,
    FileSpec: ?[*:0]const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileW(
    hProcess: ?HANDLE,
    Base: u64,
    Params: ?[*:0]const u16,
    FileSpec: ?[*:0]const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileToken(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u8,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenByTokenName(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u8,
    TokenName: ?[*:0]const u8,
    TokenParameters: ?[*:0]const u8,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileChecksumW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    pCheckSumType: ?*u32,
    pChecksum: [*:0]u8,
    checksumSize: u32,
    pActualBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileChecksum(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u8,
    pCheckSumType: ?*u32,
    pChecksum: [*:0]u8,
    checksumSize: u32,
    pActualBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenByTokenNameW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    TokenName: ?[*:0]const u16,
    TokenParameters: ?[*:0]const u16,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromToken(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenByTokenName(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    TokenName: ?[*:0]const u8,
    Params: ?[*:0]const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenW(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenByTokenNameW(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    TokenName: ?[*:0]const u16,
    Params: ?[*:0]const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceVarFromToken(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]const u8,
    VarName: ?[*:0]const u8,
    Value: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceVarFromTokenW(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]const u16,
    VarName: ?[*:0]const u16,
    Value: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFileTokens(
    hProcess: ?HANDLE,
    Base: u64,
    Callback: ?PENUMSOURCEFILETOKENSCALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymInitialize(
    hProcess: ?HANDLE,
    UserSearchPath: ?[*:0]const u8,
    fInvadeProcess: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymInitializeW(
    hProcess: ?HANDLE,
    UserSearchPath: ?[*:0]const u16,
    fInvadeProcess: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSearchPath(
    hProcess: ?HANDLE,
    SearchPathA: [*:0]u8,
    SearchPathLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSearchPathW(
    hProcess: ?HANDLE,
    SearchPathA: [*:0]u16,
    SearchPathLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetSearchPath(
    hProcess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetSearchPathW(
    hProcess: ?HANDLE,
    SearchPathA: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// This function from dll 'dbghelp' is being skipped because it has some sort of issue
pub fn SymLoadModuleEx() void {
    @panic("this function is not working");
}

// This function from dll 'dbghelp' is being skipped because it has some sort of issue
pub fn SymLoadModuleExW() void {
    @panic("this function is not working");
}

pub extern "dbghelp" fn SymUnloadModule64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymUnDName64(
    sym: ?*IMAGEHLP_SYMBOL64,
    UnDecName: [*:0]u8,
    UnDecNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterCallback64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterCallbackW64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterFunctionEntryCallback64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_FUNCENTRY_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetContext(
    hProcess: ?HANDLE,
    StackFrame: ?*IMAGEHLP_STACK_FRAME,
    Context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromAddr(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromInlineContext(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromIndex(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumProcesses(
    EnumProcessesCallback: ?PSYM_ENUMPROCESSES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromAddr(
    hProcess: ?HANDLE,
    Address: u64,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromAddrW(
    hProcess: ?HANDLE,
    Address: u64,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromInlineContext(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromInlineContextW(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromToken(
    hProcess: ?HANDLE,
    Base: u64,
    Token: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromTokenW(
    hProcess: ?HANDLE,
    Base: u64,
    Token: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymNext(
    hProcess: ?HANDLE,
    si: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymNextW(
    hProcess: ?HANDLE,
    siw: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymPrev(
    hProcess: ?HANDLE,
    si: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymPrevW(
    hProcess: ?HANDLE,
    siw: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromName(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u8,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromNameW(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u16,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbols(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsEx(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsExW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsForAddr(
    hProcess: ?HANDLE,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsForAddrW(
    hProcess: ?HANDLE,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSearch(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    SymTag: u32,
    Mask: ?[*:0]const u8,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSearchW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    SymTag: u32,
    Mask: ?[*:0]const u16,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetScope(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetScopeW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromIndex(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromIndexW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeInfo(
    hProcess: ?HANDLE,
    ModBase: u64,
    TypeId: u32,
    GetType: IMAGEHLP_SYMBOL_TYPE_INFO,
    pInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeInfoEx(
    hProcess: ?HANDLE,
    ModBase: u64,
    Params: ?*IMAGEHLP_GET_TYPE_INFO_PARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypes(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesByName(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    mask: ?[*:0]const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesByNameW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    mask: ?[*:0]const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeFromName(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u8,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeFromNameW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u16,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSymbol(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u8,
    Address: u64,
    Size: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSymbolW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u16,
    Address: u64,
    Size: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymDeleteSymbol(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u8,
    Address: u64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymDeleteSymbolW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u16,
    Address: u64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRefreshModuleList(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStream(
    hProcess: ?HANDLE,
    Base: u64,
    StreamFile: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStreamA(
    hProcess: ?HANDLE,
    Base: u64,
    StreamFile: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStreamW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvIsStoreW(
    hProcess: ?HANDLE,
    path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvIsStore(
    hProcess: ?HANDLE,
    path: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvDeltaName(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u8,
    Type: ?[*:0]const u8,
    File1: ?[*:0]const u8,
    File2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvDeltaNameW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    Type: ?[*:0]const u16,
    File1: ?[*:0]const u16,
    File2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvGetSupplement(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u8,
    Node: ?[*:0]const u8,
    File: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvGetSupplementW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    Node: ?[*:0]const u16,
    File: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvGetFileIndexes(
    File: ?[*:0]const u8,
    Id: ?*Guid,
    Val1: ?*u32,
    Val2: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexesW(
    File: ?[*:0]const u16,
    Id: ?*Guid,
    Val1: ?*u32,
    Val2: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexStringW(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Index: [*:0]u16,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexString(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Index: [*:0]u8,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexInfo(
    File: ?[*:0]const u8,
    Info: ?*SYMSRV_INDEX_INFO,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexInfoW(
    File: ?[*:0]const u16,
    Info: ?*SYMSRV_INDEX_INFOW,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvStoreSupplement(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u8,
    Node: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvStoreSupplementW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    Node: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvStoreFile(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Flags: SYM_SRV_STORE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvStoreFileW(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Flags: SYM_SRV_STORE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetSymbolFile(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u8,
    ImageFile: ?[*:0]const u8,
    Type: IMAGEHLP_SF_TYPE,
    SymbolFile: [*:0]u8,
    cSymbolFile: usize,
    DbgFile: [*:0]u8,
    cDbgFile: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymbolFileW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    ImageFile: ?[*:0]const u16,
    Type: IMAGEHLP_SF_TYPE,
    SymbolFile: [*:0]u16,
    cSymbolFile: usize,
    DbgFile: [*:0]u16,
    cDbgFile: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn DbgHelpCreateUserDump(
    FileName: ?[*:0]const u8,
    Callback: ?PDBGHELP_CREATE_USER_DUMP_CALLBACK,
    UserData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn DbgHelpCreateUserDumpW(
    FileName: ?[*:0]const u16,
    Callback: ?PDBGHELP_CREATE_USER_DUMP_CALLBACK,
    UserData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymFromAddr64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    pdwDisplacement: ?*u64,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymFromName64(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u8,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn FindFileInPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    id: ?*anyopaque,
    two: u32,
    three: u32,
    flags: u32,
    FilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn FindFileInSearchPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    one: u32,
    two: u32,
    three: u32,
    FilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSym(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateSymbols64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateSymbolsW64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK64W,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymLoadModule64(
    hProcess: ?HANDLE,
    hFile: ?HANDLE,
    ImageName: ?[*:0]const u8,
    ModuleName: ?[*:0]const u8,
    BaseOfDll: u64,
    SizeOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "dbghelp" fn SymGetSymNext64(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymPrev64(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SetCheckUserInterruptShared(
    lpStartAddress: ?LPCALL_BACK_USER_INTERRUPT_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn GetSymLoadError() callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SetSymLoadError(
    @"error": u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn ReportSymbolLoadSummary(
    hProcess: ?HANDLE,
    pLoadModule: ?[*:0]const u16,
    pSymbolData: ?*DBGHELP_DATA_REPORT_STRUCT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RemoveInvalidModuleList(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn RangeMapCreate() callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn RangeMapFree(
    RmapHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn RangeMapAddPeImageSections(
    RmapHandle: ?*anyopaque,
    ImageName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    MappedImage: ?*anyopaque,
    MappingBytes: u32,
    ImageBase: u64,
    UserTag: u64,
    MappingFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapRemove(
    RmapHandle: ?*anyopaque,
    UserTag: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapRead(
    RmapHandle: ?*anyopaque,
    Offset: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    RequestBytes: u32,
    Flags: u32,
    DoneBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapWrite(
    RmapHandle: ?*anyopaque,
    Offset: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    RequestBytes: u32,
    Flags: u32,
    DoneBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn MessageBeep(
    uType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FatalExit(
    ExitCode: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetThreadSelectorEntry(
    hThread: ?HANDLE,
    dwSelector: u32,
    lpSelectorEntry: ?*LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn Wow64GetThreadSelectorEntry(
    hThread: ?HANDLE,
    dwSelector: u32,
    lpSelectorEntry: ?*WOW64_LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugSetProcessKillOnExit(
    KillOnExit: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugBreakProcess(
    Process: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FormatMessageA(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const anyopaque,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: ?PSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FormatMessageW(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const anyopaque,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: ?PWSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn CopyContext(
    Destination: ?*CONTEXT,
    ContextFlags: u32,
    Source: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn InitializeContext(
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    ContextFlags: u32,
    Context: ?*?*CONTEXT,
    ContextLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn InitializeContext2(
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    ContextFlags: u32,
    Context: ?*?*CONTEXT,
    ContextLength: ?*u32,
    XStateCompactionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86, .X64 => struct {

        // TODO: this type is limited to platform 'windows6.1'
        pub extern "kernel32" fn GetEnabledXStateFeatures() callconv(@import("std").os.windows.WINAPI) u64;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86, .X64 => struct {

        // TODO: this type is limited to platform 'windows6.1'
        pub extern "kernel32" fn GetXStateFeaturesMask(
            Context: ?*CONTEXT,
            FeatureMask: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86, .X64 => struct {

        // TODO: this type is limited to platform 'windows6.1'
        pub extern "kernel32" fn LocateXStateFeature(
            Context: ?*CONTEXT,
            FeatureId: u32,
            Length: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86, .X64 => struct {

        // TODO: this type is limited to platform 'windows6.1'
        pub extern "kernel32" fn SetXStateFeaturesMask(
            Context: ?*CONTEXT,
            FeatureMask: u64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {

        // TODO: this type is limited to platform 'windows5.1.2600'
        pub extern "imagehlp" fn CheckSumMappedFile(
            BaseAddress: ?*anyopaque,
            FileLength: u32,
            HeaderSum: ?*u32,
            CheckSum: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {

        // TODO: this type is limited to platform 'windows5.1.2600'
        pub extern "imagehlp" fn GetImageConfigInformation(
            LoadedImage: ?*LOADED_IMAGE,
            ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {

        // TODO: this type is limited to platform 'windows5.1.2600'
        pub extern "imagehlp" fn SetImageConfigInformation(
            LoadedImage: ?*LOADED_IMAGE,
            ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn ImageNtHeader(
            Base: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn ImageRvaToSection(
            NtHeaders: ?*IMAGE_NT_HEADERS32,
            Base: ?*anyopaque,
            Rva: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_SECTION_HEADER;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn ImageRvaToVa(
            NtHeaders: ?*IMAGE_NT_HEADERS32,
            Base: ?*anyopaque,
            Rva: u32,
            LastRvaSection: ?*?*IMAGE_SECTION_HEADER,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn StackWalk(
            MachineType: u32,
            hProcess: ?HANDLE,
            hThread: ?HANDLE,
            StackFrame: ?*STACKFRAME,
            ContextRecord: ?*anyopaque,
            ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE,
            FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE,
            GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE,
            TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymEnumerateModules(
            hProcess: ?HANDLE,
            EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACK,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn EnumerateLoadedModules(
            hProcess: ?HANDLE,
            EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymFunctionTableAccess(
            hProcess: ?HANDLE,
            AddrBase: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetModuleInfo(
            hProcess: ?HANDLE,
            dwAddr: u32,
            ModuleInfo: ?*IMAGEHLP_MODULE,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetModuleInfoW(
            hProcess: ?HANDLE,
            dwAddr: u32,
            ModuleInfo: ?*IMAGEHLP_MODULEW,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetModuleBase(
            hProcess: ?HANDLE,
            dwAddr: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetLineFromAddr(
            hProcess: ?HANDLE,
            dwAddr: u32,
            pdwDisplacement: ?*u32,
            Line: ?*IMAGEHLP_LINE,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetLineFromName(
            hProcess: ?HANDLE,
            ModuleName: ?[*:0]const u8,
            FileName: ?[*:0]const u8,
            dwLineNumber: u32,
            plDisplacement: ?*i32,
            Line: ?*IMAGEHLP_LINE,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetLineNext(
            hProcess: ?HANDLE,
            Line: ?*IMAGEHLP_LINE,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetLinePrev(
            hProcess: ?HANDLE,
            Line: ?*IMAGEHLP_LINE,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymUnloadModule(
            hProcess: ?HANDLE,
            BaseOfDll: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymUnDName(
            sym: ?*IMAGEHLP_SYMBOL,
            UnDecName: [*:0]u8,
            UnDecNameLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymRegisterCallback(
            hProcess: ?HANDLE,
            CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymRegisterFunctionEntryCallback(
            hProcess: ?HANDLE,
            CallbackFunction: ?PSYMBOL_FUNCENTRY_CALLBACK,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetSymFromAddr(
            hProcess: ?HANDLE,
            dwAddr: u32,
            pdwDisplacement: ?*u32,
            Symbol: ?*IMAGEHLP_SYMBOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetSymFromName(
            hProcess: ?HANDLE,
            Name: ?[*:0]const u8,
            Symbol: ?*IMAGEHLP_SYMBOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymEnumerateSymbols(
            hProcess: ?HANDLE,
            BaseOfDll: u32,
            EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymEnumerateSymbolsW(
            hProcess: ?HANDLE,
            BaseOfDll: u32,
            EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACKW,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymLoadModule(
            hProcess: ?HANDLE,
            hFile: ?HANDLE,
            ImageName: ?[*:0]const u8,
            ModuleName: ?[*:0]const u8,
            BaseOfDll: u32,
            SizeOfDll: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetSymNext(
            hProcess: ?HANDLE,
            Symbol: ?*IMAGEHLP_SYMBOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

pub usingnamespace switch (@import("../../zig.zig").arch) {
    .X86 => struct {
        pub extern "dbghelp" fn SymGetSymPrev(
            hProcess: ?HANDLE,
            Symbol: ?*IMAGEHLP_SYMBOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL;
    },
    else => struct {},
};

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (4)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OutputDebugString = thismodule.OutputDebugStringA;
        pub const FatalAppExit = thismodule.FatalAppExitA;
        pub const MapFileAndCheckSum = thismodule.MapFileAndCheckSumA;
        pub const FormatMessage = thismodule.FormatMessageA;
    },
    .wide => struct {
        pub const OutputDebugString = thismodule.OutputDebugStringW;
        pub const FatalAppExit = thismodule.FatalAppExitW;
        pub const MapFileAndCheckSum = thismodule.MapFileAndCheckSumW;
        pub const FormatMessage = thismodule.FormatMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OutputDebugString = *opaque {};
        pub const FatalAppExit = *opaque {};
        pub const MapFileAndCheckSum = *opaque {};
        pub const FormatMessage = *opaque {};
    } else struct {
        pub const OutputDebugString = @compileError("'OutputDebugString' requires that UNICODE be set to true or false in the root module");
        pub const FatalAppExit = @compileError("'FatalAppExit' requires that UNICODE be set to true or false in the root module");
        pub const MapFileAndCheckSum = @compileError("'MapFileAndCheckSum' requires that UNICODE be set to true or false in the root module");
        pub const FormatMessage = @compileError("'FormatMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (38)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BOOLEAN = @import("../../foundation.zig").BOOLEAN;
const BSTR = @import("../../foundation.zig").BSTR;
const CADWORD = @import("../../system/ole.zig").CADWORD;
const CALPOLESTR = @import("../../system/ole.zig").CALPOLESTR;
const CHAR = @import("../../foundation.zig").CHAR;
const DISPPARAMS = @import("../../system/com.zig").DISPPARAMS;
const EXCEPINFO = @import("../../system/com.zig").EXCEPINFO;
const EXCEPTION_ROUTINE = @import("../../system/kernel.zig").EXCEPTION_ROUTINE;
const FARPROC = @import("../../foundation.zig").FARPROC;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HANDLE_PTR = @import("../../foundation.zig").HANDLE_PTR;
const HINSTANCE = @import("../../foundation.zig").HINSTANCE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IDispatch = @import("../../system/com.zig").IDispatch;
const ILockBytes = @import("../../system/com/structured_storage.zig").ILockBytes;
const IStream = @import("../../system/com.zig").IStream;
const ITypeInfo = @import("../../system/com.zig").ITypeInfo;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../../foundation.zig").LARGE_INTEGER;
const LIST_ENTRY = @import("../../system/kernel.zig").LIST_ENTRY;
const LIST_ENTRY32 = @import("../../system/kernel.zig").LIST_ENTRY32;
const LIST_ENTRY64 = @import("../../system/kernel.zig").LIST_ENTRY64;
const LPTHREAD_START_ROUTINE = @import("../../system/threading.zig").LPTHREAD_START_ROUTINE;
const MEMORY_BASIC_INFORMATION64 = @import("../../system/memory.zig").MEMORY_BASIC_INFORMATION64;
const NTSTATUS = @import("../../foundation.zig").NTSTATUS;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const SYSTEMTIME = @import("../../foundation.zig").SYSTEMTIME;
const TIME_ZONE_INFORMATION = @import("../../system/time.zig").TIME_ZONE_INFORMATION;
const TYPEDESC = @import("../../system/com.zig").TYPEDESC;
const VARIANT = @import("../../system/com.zig").VARIANT;
const VIRTUAL_ALLOCATION_TYPE = @import("../../system/memory.zig").VIRTUAL_ALLOCATION_TYPE;
const VS_FIXEDFILEINFO = @import("../../storage/file_system.zig").VS_FIXEDFILEINFO;
const WIN_CERTIFICATE = @import("../../security/win_trust.zig").WIN_CERTIFICATE;
// 1 arch-specific imports
const FLOATING_SAVE_AREA = switch (@import("../../zig.zig").arch) {
    .X86 => @import("../../system/kernel.zig").FLOATING_SAVE_AREA,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_INITIALIZE")) {
        _ = PDEBUG_EXTENSION_INITIALIZE;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_UNINITIALIZE")) {
        _ = PDEBUG_EXTENSION_UNINITIALIZE;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_CANUNLOAD")) {
        _ = PDEBUG_EXTENSION_CANUNLOAD;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_UNLOAD")) {
        _ = PDEBUG_EXTENSION_UNLOAD;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_NOTIFY")) {
        _ = PDEBUG_EXTENSION_NOTIFY;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_CALL")) {
        _ = PDEBUG_EXTENSION_CALL;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_KNOWN_STRUCT")) {
        _ = PDEBUG_EXTENSION_KNOWN_STRUCT;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_KNOWN_STRUCT_EX")) {
        _ = PDEBUG_EXTENSION_KNOWN_STRUCT_EX;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_QUERY_VALUE_NAMES")) {
        _ = PDEBUG_EXTENSION_QUERY_VALUE_NAMES;
    }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_PROVIDE_VALUE")) {
        _ = PDEBUG_EXTENSION_PROVIDE_VALUE;
    }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION")) {
        _ = PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION;
    }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK")) {
        _ = PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK;
    }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES")) {
        _ = PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES;
    }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION")) {
        _ = PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION;
    }
    if (@hasDecl(@This(), "PWINDBG_OUTPUT_ROUTINE")) {
        _ = PWINDBG_OUTPUT_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION")) {
        _ = PWINDBG_GET_EXPRESSION;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION32")) {
        _ = PWINDBG_GET_EXPRESSION32;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION64")) {
        _ = PWINDBG_GET_EXPRESSION64;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL")) {
        _ = PWINDBG_GET_SYMBOL;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL32")) {
        _ = PWINDBG_GET_SYMBOL32;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL64")) {
        _ = PWINDBG_GET_SYMBOL64;
    }
    if (@hasDecl(@This(), "PWINDBG_DISASM")) {
        _ = PWINDBG_DISASM;
    }
    if (@hasDecl(@This(), "PWINDBG_DISASM32")) {
        _ = PWINDBG_DISASM32;
    }
    if (@hasDecl(@This(), "PWINDBG_DISASM64")) {
        _ = PWINDBG_DISASM64;
    }
    if (@hasDecl(@This(), "PWINDBG_CHECK_CONTROL_C")) {
        _ = PWINDBG_CHECK_CONTROL_C;
    }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE")) {
        _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE32")) {
        _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE32;
    }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE64")) {
        _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE64;
    }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE")) {
        _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32")) {
        _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32;
    }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64")) {
        _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64;
    }
    if (@hasDecl(@This(), "PWINDBG_GET_THREAD_CONTEXT_ROUTINE")) {
        _ = PWINDBG_GET_THREAD_CONTEXT_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_SET_THREAD_CONTEXT_ROUTINE")) {
        _ = PWINDBG_SET_THREAD_CONTEXT_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_IOCTL_ROUTINE")) {
        _ = PWINDBG_IOCTL_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_READ_PHYSICAL_MEMORY")) {
        _ = PWINDBG_OLDKD_READ_PHYSICAL_MEMORY;
    }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY")) {
        _ = PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY;
    }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE")) {
        _ = PWINDBG_STACKTRACE_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE32")) {
        _ = PWINDBG_STACKTRACE_ROUTINE32;
    }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE64")) {
        _ = PWINDBG_STACKTRACE_ROUTINE64;
    }
    if (@hasDecl(@This(), "PWINDBG_OLD_EXTENSION_ROUTINE")) {
        _ = PWINDBG_OLD_EXTENSION_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE")) {
        _ = PWINDBG_EXTENSION_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE32")) {
        _ = PWINDBG_EXTENSION_ROUTINE32;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE64")) {
        _ = PWINDBG_EXTENSION_ROUTINE64;
    }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_EXTENSION_ROUTINE")) {
        _ = PWINDBG_OLDKD_EXTENSION_ROUTINE;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT")) {
        _ = PWINDBG_EXTENSION_DLL_INIT;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT32")) {
        _ = PWINDBG_EXTENSION_DLL_INIT32;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT64")) {
        _ = PWINDBG_EXTENSION_DLL_INIT64;
    }
    if (@hasDecl(@This(), "PWINDBG_CHECK_VERSION")) {
        _ = PWINDBG_CHECK_VERSION;
    }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_API_VERSION")) {
        _ = PWINDBG_EXTENSION_API_VERSION;
    }
    if (@hasDecl(@This(), "PSYM_DUMP_FIELD_CALLBACK")) {
        _ = PSYM_DUMP_FIELD_CALLBACK;
    }
    if (@hasDecl(@This(), "PVECTORED_EXCEPTION_HANDLER")) {
        _ = PVECTORED_EXCEPTION_HANDLER;
    }
    if (@hasDecl(@This(), "LPTOP_LEVEL_EXCEPTION_FILTER")) {
        _ = LPTOP_LEVEL_EXCEPTION_FILTER;
    }
    if (@hasDecl(@This(), "PWAITCHAINCALLBACK")) {
        _ = PWAITCHAINCALLBACK;
    }
    if (@hasDecl(@This(), "PCOGETCALLSTATE")) {
        _ = PCOGETCALLSTATE;
    }
    if (@hasDecl(@This(), "PCOGETACTIVATIONSTATE")) {
        _ = PCOGETACTIVATIONSTATE;
    }
    if (@hasDecl(@This(), "MINIDUMP_CALLBACK_ROUTINE")) {
        _ = MINIDUMP_CALLBACK_ROUTINE;
    }
    if (@hasDecl(@This(), "PIMAGEHLP_STATUS_ROUTINE")) {
        _ = PIMAGEHLP_STATUS_ROUTINE;
    }
    if (@hasDecl(@This(), "PIMAGEHLP_STATUS_ROUTINE32")) {
        _ = PIMAGEHLP_STATUS_ROUTINE32;
    }
    if (@hasDecl(@This(), "PIMAGEHLP_STATUS_ROUTINE64")) {
        _ = PIMAGEHLP_STATUS_ROUTINE64;
    }
    if (@hasDecl(@This(), "DIGEST_FUNCTION")) {
        _ = DIGEST_FUNCTION;
    }
    if (@hasDecl(@This(), "PFIND_DEBUG_FILE_CALLBACK")) {
        _ = PFIND_DEBUG_FILE_CALLBACK;
    }
    if (@hasDecl(@This(), "PFIND_DEBUG_FILE_CALLBACKW")) {
        _ = PFIND_DEBUG_FILE_CALLBACKW;
    }
    if (@hasDecl(@This(), "PFINDFILEINPATHCALLBACK")) {
        _ = PFINDFILEINPATHCALLBACK;
    }
    if (@hasDecl(@This(), "PFINDFILEINPATHCALLBACKW")) {
        _ = PFINDFILEINPATHCALLBACKW;
    }
    if (@hasDecl(@This(), "PFIND_EXE_FILE_CALLBACK")) {
        _ = PFIND_EXE_FILE_CALLBACK;
    }
    if (@hasDecl(@This(), "PFIND_EXE_FILE_CALLBACKW")) {
        _ = PFIND_EXE_FILE_CALLBACKW;
    }
    if (@hasDecl(@This(), "PENUMDIRTREE_CALLBACK")) {
        _ = PENUMDIRTREE_CALLBACK;
    }
    if (@hasDecl(@This(), "PENUMDIRTREE_CALLBACKW")) {
        _ = PENUMDIRTREE_CALLBACKW;
    }
    if (@hasDecl(@This(), "PREAD_PROCESS_MEMORY_ROUTINE64")) {
        _ = PREAD_PROCESS_MEMORY_ROUTINE64;
    }
    if (@hasDecl(@This(), "PFUNCTION_TABLE_ACCESS_ROUTINE64")) {
        _ = PFUNCTION_TABLE_ACCESS_ROUTINE64;
    }
    if (@hasDecl(@This(), "PGET_MODULE_BASE_ROUTINE64")) {
        _ = PGET_MODULE_BASE_ROUTINE64;
    }
    if (@hasDecl(@This(), "PTRANSLATE_ADDRESS_ROUTINE64")) {
        _ = PTRANSLATE_ADDRESS_ROUTINE64;
    }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACK64")) {
        _ = PSYM_ENUMMODULES_CALLBACK64;
    }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACKW64")) {
        _ = PSYM_ENUMMODULES_CALLBACKW64;
    }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACK64")) {
        _ = PENUMLOADED_MODULES_CALLBACK64;
    }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACKW64")) {
        _ = PENUMLOADED_MODULES_CALLBACKW64;
    }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK64")) {
        _ = PSYM_ENUMSYMBOLS_CALLBACK64;
    }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK64W")) {
        _ = PSYM_ENUMSYMBOLS_CALLBACK64W;
    }
    if (@hasDecl(@This(), "PSYMBOL_REGISTERED_CALLBACK64")) {
        _ = PSYMBOL_REGISTERED_CALLBACK64;
    }
    if (@hasDecl(@This(), "PSYMBOL_FUNCENTRY_CALLBACK")) {
        _ = PSYMBOL_FUNCENTRY_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYMBOL_FUNCENTRY_CALLBACK64")) {
        _ = PSYMBOL_FUNCENTRY_CALLBACK64;
    }
    if (@hasDecl(@This(), "PSYM_ENUMSOURCEFILES_CALLBACK")) {
        _ = PSYM_ENUMSOURCEFILES_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMSOURCEFILES_CALLBACKW")) {
        _ = PSYM_ENUMSOURCEFILES_CALLBACKW;
    }
    if (@hasDecl(@This(), "PSYM_ENUMLINES_CALLBACK")) {
        _ = PSYM_ENUMLINES_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMLINES_CALLBACKW")) {
        _ = PSYM_ENUMLINES_CALLBACKW;
    }
    if (@hasDecl(@This(), "PENUMSOURCEFILETOKENSCALLBACK")) {
        _ = PENUMSOURCEFILETOKENSCALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMPROCESSES_CALLBACK")) {
        _ = PSYM_ENUMPROCESSES_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMERATESYMBOLS_CALLBACK")) {
        _ = PSYM_ENUMERATESYMBOLS_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMERATESYMBOLS_CALLBACKW")) {
        _ = PSYM_ENUMERATESYMBOLS_CALLBACKW;
    }
    if (@hasDecl(@This(), "SYMADDSOURCESTREAM")) {
        _ = SYMADDSOURCESTREAM;
    }
    if (@hasDecl(@This(), "SYMADDSOURCESTREAMA")) {
        _ = SYMADDSOURCESTREAMA;
    }
    if (@hasDecl(@This(), "PDBGHELP_CREATE_USER_DUMP_CALLBACK")) {
        _ = PDBGHELP_CREATE_USER_DUMP_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROC")) {
        _ = PSYMBOLSERVERPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROCA")) {
        _ = PSYMBOLSERVERPROCA;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROCW")) {
        _ = PSYMBOLSERVERPROCW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROC")) {
        _ = PSYMBOLSERVERBYINDEXPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROCA")) {
        _ = PSYMBOLSERVERBYINDEXPROCA;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROCW")) {
        _ = PSYMBOLSERVERBYINDEXPROCW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVEROPENPROC")) {
        _ = PSYMBOLSERVEROPENPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERCLOSEPROC")) {
        _ = PSYMBOLSERVERCLOSEPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETOPTIONSPROC")) {
        _ = PSYMBOLSERVERSETOPTIONSPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETOPTIONSWPROC")) {
        _ = PSYMBOLSERVERSETOPTIONSWPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERCALLBACKPROC")) {
        _ = PSYMBOLSERVERCALLBACKPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETOPTIONSPROC")) {
        _ = PSYMBOLSERVERGETOPTIONSPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROC")) {
        _ = PSYMBOLSERVERPINGPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCA")) {
        _ = PSYMBOLSERVERPINGPROCA;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCW")) {
        _ = PSYMBOLSERVERPINGPROCW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETVERSION")) {
        _ = PSYMBOLSERVERGETVERSION;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERDELTANAME")) {
        _ = PSYMBOLSERVERDELTANAME;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERDELTANAMEW")) {
        _ = PSYMBOLSERVERDELTANAMEW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETSUPPLEMENT")) {
        _ = PSYMBOLSERVERGETSUPPLEMENT;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETSUPPLEMENTW")) {
        _ = PSYMBOLSERVERGETSUPPLEMENTW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTORESUPPLEMENT")) {
        _ = PSYMBOLSERVERSTORESUPPLEMENT;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTORESUPPLEMENTW")) {
        _ = PSYMBOLSERVERSTORESUPPLEMENTW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETINDEXSTRING")) {
        _ = PSYMBOLSERVERGETINDEXSTRING;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETINDEXSTRINGW")) {
        _ = PSYMBOLSERVERGETINDEXSTRINGW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTOREFILE")) {
        _ = PSYMBOLSERVERSTOREFILE;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTOREFILEW")) {
        _ = PSYMBOLSERVERSTOREFILEW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERISSTORE")) {
        _ = PSYMBOLSERVERISSTORE;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERISSTOREW")) {
        _ = PSYMBOLSERVERISSTOREW;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERVERSION")) {
        _ = PSYMBOLSERVERVERSION;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERMESSAGEPROC")) {
        _ = PSYMBOLSERVERMESSAGEPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERWEXPROC")) {
        _ = PSYMBOLSERVERWEXPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCWEX")) {
        _ = PSYMBOLSERVERPINGPROCWEX;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETOPTIONDATAPROC")) {
        _ = PSYMBOLSERVERGETOPTIONDATAPROC;
    }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETHTTPAUTHHEADER")) {
        _ = PSYMBOLSERVERSETHTTPAUTHHEADER;
    }
    if (@hasDecl(@This(), "LPCALL_BACK_USER_INTERRUPT_ROUTINE")) {
        _ = LPCALL_BACK_USER_INTERRUPT_ROUTINE;
    }
    if (@hasDecl(@This(), "WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER")) {
        _ = WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER;
    }
    if (@hasDecl(@This(), "WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER")) {
        _ = WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER;
    }
    if (@hasDecl(@This(), "WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER")) {
        _ = WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER;
    }
    if (@hasDecl(@This(), "PGET_RUNTIME_FUNCTION_CALLBACK")) {
        _ = PGET_RUNTIME_FUNCTION_CALLBACK;
    }
    if (@hasDecl(@This(), "PGET_RUNTIME_FUNCTION_CALLBACK")) {
        _ = PGET_RUNTIME_FUNCTION_CALLBACK;
    }
    if (@hasDecl(@This(), "PREAD_PROCESS_MEMORY_ROUTINE")) {
        _ = PREAD_PROCESS_MEMORY_ROUTINE;
    }
    if (@hasDecl(@This(), "PFUNCTION_TABLE_ACCESS_ROUTINE")) {
        _ = PFUNCTION_TABLE_ACCESS_ROUTINE;
    }
    if (@hasDecl(@This(), "PGET_MODULE_BASE_ROUTINE")) {
        _ = PGET_MODULE_BASE_ROUTINE;
    }
    if (@hasDecl(@This(), "PTRANSLATE_ADDRESS_ROUTINE")) {
        _ = PTRANSLATE_ADDRESS_ROUTINE;
    }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACK")) {
        _ = PSYM_ENUMMODULES_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK")) {
        _ = PSYM_ENUMSYMBOLS_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACKW")) {
        _ = PSYM_ENUMSYMBOLS_CALLBACKW;
    }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACK")) {
        _ = PENUMLOADED_MODULES_CALLBACK;
    }
    if (@hasDecl(@This(), "PSYMBOL_REGISTERED_CALLBACK")) {
        _ = PSYMBOL_REGISTERED_CALLBACK;
    }

    @setEvalBranchQuota(comptime @import("std").meta.declarations(@This()).len * 3);

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (1)
//--------------------------------------------------------------------------------
pub const web_app = @import("debug/web_app.zig");
