//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (558)
//--------------------------------------------------------------------------------
pub const WLDP_LOCKDOWN_UNDEFINED = @as(u32, 0);
pub const WLDP_LOCKDOWN_DEFINED_FLAG = @as(u32, 2147483648);
pub const WLDP_LOCKDOWN_CONFIG_CI_FLAG = @as(u32, 1);
pub const WLDP_LOCKDOWN_CONFIG_CI_AUDIT_FLAG = @as(u32, 2);
pub const WLDP_LOCKDOWN_UMCIENFORCE_FLAG = @as(u32, 4);
pub const WLDP_LOCKDOWN_AUDIT_FLAG = @as(u32, 8);
pub const WLDP_LOCKDOWN_EXCLUSION_FLAG = @as(u32, 16);
pub const WLDP_LOCKDOWN_OFF = @as(u32, 2147483648);
pub const WLDP_HOST_INFORMATION_REVISION = @as(u32, 1);
pub const WLDP_FLAGS_SKIPSIGNATUREVALIDATION = @as(u32, 256);
pub const MAX_TDI_ENTITIES = @as(u32, 4096);
pub const INFO_CLASS_GENERIC = @as(u32, 256);
pub const INFO_CLASS_PROTOCOL = @as(u32, 512);
pub const INFO_CLASS_IMPLEMENTATION = @as(u32, 768);
pub const INFO_TYPE_PROVIDER = @as(u32, 256);
pub const INFO_TYPE_ADDRESS_OBJECT = @as(u32, 512);
pub const INFO_TYPE_CONNECTION = @as(u32, 768);
pub const ENTITY_LIST_ID = @as(u32, 0);
pub const INVALID_ENTITY_INSTANCE = @as(i32, -1);
pub const CONTEXT_SIZE = @as(u32, 16);
pub const ENTITY_TYPE_ID = @as(u32, 1);
pub const CO_TL_NBF = @as(u32, 1024);
pub const CO_TL_SPX = @as(u32, 1026);
pub const CO_TL_TCP = @as(u32, 1028);
pub const CO_TL_SPP = @as(u32, 1030);
pub const CL_TL_NBF = @as(u32, 1025);
pub const CL_TL_UDP = @as(u32, 1027);
pub const ER_ICMP = @as(u32, 896);
pub const CL_NL_IPX = @as(u32, 769);
pub const CL_NL_IP = @as(u32, 771);
pub const AT_ARP = @as(u32, 640);
pub const AT_NULL = @as(u32, 642);
pub const IF_GENERIC = @as(u32, 512);
pub const IF_MIB = @as(u32, 514);
pub const IOCTL_TDI_TL_IO_CONTROL_ENDPOINT = @as(u32, 2162744);
pub const DCI_VERSION = @as(u32, 256);
pub const DCICREATEPRIMARYSURFACE = @as(u32, 1);
pub const DCICREATEOFFSCREENSURFACE = @as(u32, 2);
pub const DCICREATEOVERLAYSURFACE = @as(u32, 3);
pub const DCIENUMSURFACE = @as(u32, 4);
pub const DCIESCAPE = @as(u32, 5);
pub const DCI_OK = @as(u32, 0);
pub const DCI_FAIL_GENERIC = @as(i32, -1);
pub const DCI_FAIL_UNSUPPORTEDVERSION = @as(i32, -2);
pub const DCI_FAIL_INVALIDSURFACE = @as(i32, -3);
pub const DCI_FAIL_UNSUPPORTED = @as(i32, -4);
pub const DCI_ERR_CURRENTLYNOTAVAIL = @as(i32, -5);
pub const DCI_ERR_INVALIDRECT = @as(i32, -6);
pub const DCI_ERR_UNSUPPORTEDFORMAT = @as(i32, -7);
pub const DCI_ERR_UNSUPPORTEDMASK = @as(i32, -8);
pub const DCI_ERR_TOOBIGHEIGHT = @as(i32, -9);
pub const DCI_ERR_TOOBIGWIDTH = @as(i32, -10);
pub const DCI_ERR_TOOBIGSIZE = @as(i32, -11);
pub const DCI_ERR_OUTOFMEMORY = @as(i32, -12);
pub const DCI_ERR_INVALIDPOSITION = @as(i32, -13);
pub const DCI_ERR_INVALIDSTRETCH = @as(i32, -14);
pub const DCI_ERR_INVALIDCLIPLIST = @as(i32, -15);
pub const DCI_ERR_SURFACEISOBSCURED = @as(i32, -16);
pub const DCI_ERR_XALIGN = @as(i32, -17);
pub const DCI_ERR_YALIGN = @as(i32, -18);
pub const DCI_ERR_XYALIGN = @as(i32, -19);
pub const DCI_ERR_WIDTHALIGN = @as(i32, -20);
pub const DCI_ERR_HEIGHTALIGN = @as(i32, -21);
pub const DCI_STATUS_POINTERCHANGED = @as(u32, 1);
pub const DCI_STATUS_STRIDECHANGED = @as(u32, 2);
pub const DCI_STATUS_FORMATCHANGED = @as(u32, 4);
pub const DCI_STATUS_SURFACEINFOCHANGED = @as(u32, 8);
pub const DCI_STATUS_CHROMAKEYCHANGED = @as(u32, 16);
pub const DCI_STATUS_WASSTILLDRAWING = @as(u32, 32);
pub const DCI_SURFACE_TYPE = @as(u32, 15);
pub const DCI_PRIMARY = @as(u32, 0);
pub const DCI_OFFSCREEN = @as(u32, 1);
pub const DCI_OVERLAY = @as(u32, 2);
pub const DCI_VISIBLE = @as(u32, 16);
pub const DCI_CHROMAKEY = @as(u32, 32);
pub const DCI_1632_ACCESS = @as(u32, 64);
pub const DCI_DWORDSIZE = @as(u32, 128);
pub const DCI_DWORDALIGN = @as(u32, 256);
pub const DCI_WRITEONLY = @as(u32, 512);
pub const DCI_ASYNC = @as(u32, 1024);
pub const DCI_CAN_STRETCHX = @as(u32, 4096);
pub const DCI_CAN_STRETCHY = @as(u32, 8192);
pub const DCI_CAN_STRETCHXN = @as(u32, 16384);
pub const DCI_CAN_STRETCHYN = @as(u32, 32768);
pub const DCI_CANOVERLAY = @as(u32, 65536);
pub const FILE_FLAG_OPEN_REQUIRING_OPLOCK = @as(u32, 262144);
pub const PROGRESS_CONTINUE = @as(u32, 0);
pub const PROGRESS_CANCEL = @as(u32, 1);
pub const PROGRESS_STOP = @as(u32, 2);
pub const PROGRESS_QUIET = @as(u32, 3);
pub const COPY_FILE_FAIL_IF_EXISTS = @as(u32, 1);
pub const COPY_FILE_RESTARTABLE = @as(u32, 2);
pub const COPY_FILE_OPEN_SOURCE_FOR_WRITE = @as(u32, 4);
pub const COPY_FILE_ALLOW_DECRYPTED_DESTINATION = @as(u32, 8);
pub const COPY_FILE_COPY_SYMLINK = @as(u32, 2048);
pub const COPY_FILE_NO_BUFFERING = @as(u32, 4096);
pub const COPY_FILE_REQUEST_SECURITY_PRIVILEGES = @as(u32, 8192);
pub const COPY_FILE_RESUME_FROM_PAUSE = @as(u32, 16384);
pub const COPY_FILE_NO_OFFLOAD = @as(u32, 262144);
pub const COPY_FILE_IGNORE_EDP_BLOCK = @as(u32, 4194304);
pub const COPY_FILE_IGNORE_SOURCE_ENCRYPTION = @as(u32, 8388608);
pub const COPY_FILE_DONT_REQUEST_DEST_WRITE_DAC = @as(u32, 33554432);
pub const COPY_FILE_REQUEST_COMPRESSED_TRAFFIC = @as(u32, 268435456);
pub const COPY_FILE_OPEN_AND_COPY_REPARSE_POINT = @as(u32, 2097152);
pub const COPY_FILE_DIRECTORY = @as(u32, 128);
pub const COPY_FILE_SKIP_ALTERNATE_STREAMS = @as(u32, 32768);
pub const COPY_FILE_DISABLE_PRE_ALLOCATION = @as(u32, 67108864);
pub const COPY_FILE_ENABLE_LOW_FREE_SPACE_MODE = @as(u32, 134217728);
pub const FAIL_FAST_GENERATE_EXCEPTION_ADDRESS = @as(u32, 1);
pub const FAIL_FAST_NO_HARD_ERROR_DLG = @as(u32, 2);
pub const DTR_CONTROL_DISABLE = @as(u32, 0);
pub const DTR_CONTROL_ENABLE = @as(u32, 1);
pub const DTR_CONTROL_HANDSHAKE = @as(u32, 2);
pub const RTS_CONTROL_DISABLE = @as(u32, 0);
pub const RTS_CONTROL_ENABLE = @as(u32, 1);
pub const RTS_CONTROL_HANDSHAKE = @as(u32, 2);
pub const RTS_CONTROL_TOGGLE = @as(u32, 3);
pub const GMEM_NOCOMPACT = @as(u32, 16);
pub const GMEM_NODISCARD = @as(u32, 32);
pub const GMEM_MODIFY = @as(u32, 128);
pub const GMEM_DISCARDABLE = @as(u32, 256);
pub const GMEM_NOT_BANKED = @as(u32, 4096);
pub const GMEM_SHARE = @as(u32, 8192);
pub const GMEM_DDESHARE = @as(u32, 8192);
pub const GMEM_NOTIFY = @as(u32, 16384);
pub const GMEM_LOWER = @as(u32, 4096);
pub const GMEM_VALID_FLAGS = @as(u32, 32626);
pub const GMEM_INVALID_HANDLE = @as(u32, 32768);
pub const GMEM_DISCARDED = @as(u32, 16384);
pub const GMEM_LOCKCOUNT = @as(u32, 255);
pub const THREAD_PRIORITY_ERROR_RETURN = @as(u32, 2147483647);
pub const VOLUME_NAME_DOS = @as(u32, 0);
pub const VOLUME_NAME_GUID = @as(u32, 1);
pub const VOLUME_NAME_NT = @as(u32, 2);
pub const VOLUME_NAME_NONE = @as(u32, 4);
pub const DRIVE_UNKNOWN = @as(u32, 0);
pub const DRIVE_NO_ROOT_DIR = @as(u32, 1);
pub const DRIVE_REMOVABLE = @as(u32, 2);
pub const DRIVE_FIXED = @as(u32, 3);
pub const DRIVE_REMOTE = @as(u32, 4);
pub const DRIVE_CDROM = @as(u32, 5);
pub const DRIVE_RAMDISK = @as(u32, 6);
pub const FILE_TYPE_UNKNOWN = @as(u32, 0);
pub const FILE_TYPE_DISK = @as(u32, 1);
pub const FILE_TYPE_CHAR = @as(u32, 2);
pub const FILE_TYPE_PIPE = @as(u32, 3);
pub const FILE_TYPE_REMOTE = @as(u32, 32768);
pub const NOPARITY = @as(u32, 0);
pub const ODDPARITY = @as(u32, 1);
pub const EVENPARITY = @as(u32, 2);
pub const MARKPARITY = @as(u32, 3);
pub const SPACEPARITY = @as(u32, 4);
pub const ONESTOPBIT = @as(u32, 0);
pub const ONE5STOPBITS = @as(u32, 1);
pub const TWOSTOPBITS = @as(u32, 2);
pub const IGNORE = @as(u32, 0);
pub const INFINITE = @as(u32, 4294967295);
pub const CBR_110 = @as(u32, 110);
pub const CBR_300 = @as(u32, 300);
pub const CBR_600 = @as(u32, 600);
pub const CBR_1200 = @as(u32, 1200);
pub const CBR_2400 = @as(u32, 2400);
pub const CBR_4800 = @as(u32, 4800);
pub const CBR_9600 = @as(u32, 9600);
pub const CBR_14400 = @as(u32, 14400);
pub const CBR_19200 = @as(u32, 19200);
pub const CBR_38400 = @as(u32, 38400);
pub const CBR_56000 = @as(u32, 56000);
pub const CBR_57600 = @as(u32, 57600);
pub const CBR_115200 = @as(u32, 115200);
pub const CBR_128000 = @as(u32, 128000);
pub const CBR_256000 = @as(u32, 256000);
pub const CE_TXFULL = @as(u32, 256);
pub const CE_PTO = @as(u32, 512);
pub const CE_IOE = @as(u32, 1024);
pub const CE_DNS = @as(u32, 2048);
pub const CE_OOP = @as(u32, 4096);
pub const CE_MODE = @as(u32, 32768);
pub const IE_BADID = @as(i32, -1);
pub const IE_OPEN = @as(i32, -2);
pub const IE_NOPEN = @as(i32, -3);
pub const IE_MEMORY = @as(i32, -4);
pub const IE_DEFAULT = @as(i32, -5);
pub const IE_HARDWARE = @as(i32, -10);
pub const IE_BYTESIZE = @as(i32, -11);
pub const IE_BAUDRATE = @as(i32, -12);
pub const RESETDEV = @as(u32, 7);
pub const LPTx = @as(u32, 128);
pub const S_QUEUEEMPTY = @as(u32, 0);
pub const S_THRESHOLD = @as(u32, 1);
pub const S_ALLTHRESHOLD = @as(u32, 2);
pub const S_NORMAL = @as(u32, 0);
pub const S_LEGATO = @as(u32, 1);
pub const S_STACCATO = @as(u32, 2);
pub const S_PERIOD512 = @as(u32, 0);
pub const S_PERIOD1024 = @as(u32, 1);
pub const S_PERIOD2048 = @as(u32, 2);
pub const S_PERIODVOICE = @as(u32, 3);
pub const S_WHITE512 = @as(u32, 4);
pub const S_WHITE1024 = @as(u32, 5);
pub const S_WHITE2048 = @as(u32, 6);
pub const S_WHITEVOICE = @as(u32, 7);
pub const S_SERDVNA = @as(i32, -1);
pub const S_SEROFM = @as(i32, -2);
pub const S_SERMACT = @as(i32, -3);
pub const S_SERQFUL = @as(i32, -4);
pub const S_SERBDNT = @as(i32, -5);
pub const S_SERDLN = @as(i32, -6);
pub const S_SERDCC = @as(i32, -7);
pub const S_SERDTP = @as(i32, -8);
pub const S_SERDVL = @as(i32, -9);
pub const S_SERDMD = @as(i32, -10);
pub const S_SERDSH = @as(i32, -11);
pub const S_SERDPT = @as(i32, -12);
pub const S_SERDFQ = @as(i32, -13);
pub const S_SERDDR = @as(i32, -14);
pub const S_SERDSR = @as(i32, -15);
pub const S_SERDST = @as(i32, -16);
pub const FS_CASE_IS_PRESERVED = @as(u32, 2);
pub const FS_CASE_SENSITIVE = @as(u32, 1);
pub const FS_UNICODE_STORED_ON_DISK = @as(u32, 4);
pub const FS_PERSISTENT_ACLS = @as(u32, 8);
pub const FS_VOL_IS_COMPRESSED = @as(u32, 32768);
pub const FS_FILE_COMPRESSION = @as(u32, 16);
pub const FS_FILE_ENCRYPTION = @as(u32, 131072);
pub const OFS_MAXPATHNAME = @as(u32, 128);
pub const MAXINTATOM = @as(u32, 49152);
pub const SCS_32BIT_BINARY = @as(u32, 0);
pub const SCS_DOS_BINARY = @as(u32, 1);
pub const SCS_WOW_BINARY = @as(u32, 2);
pub const SCS_PIF_BINARY = @as(u32, 3);
pub const SCS_POSIX_BINARY = @as(u32, 4);
pub const SCS_OS216_BINARY = @as(u32, 5);
pub const SCS_64BIT_BINARY = @as(u32, 6);
pub const FIBER_FLAG_FLOAT_SWITCH = @as(u32, 1);
pub const UMS_VERSION = @as(u32, 256);
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = @as(u32, 1);
pub const FILE_SKIP_SET_EVENT_ON_HANDLE = @as(u32, 2);
pub const CRITICAL_SECTION_NO_DEBUG_INFO = @as(u32, 16777216);
pub const HINSTANCE_ERROR = @as(u32, 32);
pub const FORMAT_MESSAGE_MAX_WIDTH_MASK = @as(u32, 255);
pub const FILE_ENCRYPTABLE = @as(u32, 0);
pub const FILE_IS_ENCRYPTED = @as(u32, 1);
pub const FILE_SYSTEM_ATTR = @as(u32, 2);
pub const FILE_ROOT_DIR = @as(u32, 3);
pub const FILE_SYSTEM_DIR = @as(u32, 4);
pub const FILE_UNKNOWN = @as(u32, 5);
pub const FILE_SYSTEM_NOT_SUPPORT = @as(u32, 6);
pub const FILE_USER_DISALLOWED = @as(u32, 7);
pub const FILE_READ_ONLY = @as(u32, 8);
pub const FILE_DIR_DISALLOWED = @as(u32, 9);
pub const EFS_USE_RECOVERY_KEYS = @as(u32, 1);
pub const CREATE_FOR_IMPORT = @as(u32, 1);
pub const CREATE_FOR_DIR = @as(u32, 2);
pub const OVERWRITE_HIDDEN = @as(u32, 4);
pub const EFSRPC_SECURE_ONLY = @as(u32, 8);
pub const EFS_DROP_ALTERNATE_STREAMS = @as(u32, 16);
pub const BACKUP_INVALID = @as(u32, 0);
pub const BACKUP_GHOSTED_FILE_EXTENTS = @as(u32, 11);
pub const STREAM_NORMAL_ATTRIBUTE = @as(u32, 0);
pub const STREAM_MODIFIED_WHEN_READ = @as(u32, 1);
pub const STREAM_CONTAINS_SECURITY = @as(u32, 2);
pub const STREAM_CONTAINS_PROPERTIES = @as(u32, 4);
pub const STREAM_SPARSE_ATTRIBUTE = @as(u32, 8);
pub const STREAM_CONTAINS_GHOSTED_FILE_EXTENTS = @as(u32, 16);
pub const STARTF_HOLOGRAPHIC = @as(u32, 262144);
pub const SHUTDOWN_NORETRY = @as(u32, 1);
pub const PROTECTION_LEVEL_SAME = @as(u32, 4294967295);
pub const PROC_THREAD_ATTRIBUTE_NUMBER = @as(u32, 65535);
pub const PROC_THREAD_ATTRIBUTE_THREAD = @as(u32, 65536);
pub const PROC_THREAD_ATTRIBUTE_INPUT = @as(u32, 131072);
pub const PROC_THREAD_ATTRIBUTE_ADDITIVE = @as(u32, 262144);
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE = @as(u32, 1);
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE = @as(u32, 2);
pub const PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE = @as(u32, 4);
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED = @as(u32, 1);
pub const PROCESS_CREATION_CHILD_PROCESS_OVERRIDE = @as(u32, 2);
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED_UNLESS_SECURE = @as(u32, 4);
pub const PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT = @as(u32, 1);
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_ENABLE_PROCESS_TREE = @as(u32, 1);
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_DISABLE_PROCESS_TREE = @as(u32, 2);
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_OVERRIDE = @as(u32, 4);
pub const ATOM_FLAG_GLOBAL = @as(u32, 2);
pub const BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = @as(u32, 1);
pub const BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = @as(u32, 65536);
pub const BASE_SEARCH_PATH_PERMANENT = @as(u32, 32768);
pub const COPYFILE2_MESSAGE_COPY_OFFLOAD = @as(i32, 1);
pub const COPYFILE2_IO_CYCLE_SIZE_MIN = @as(u32, 4096);
pub const COPYFILE2_IO_CYCLE_SIZE_MAX = @as(u32, 1073741824);
pub const COPYFILE2_IO_RATE_MIN = @as(u32, 512);
pub const EVENTLOG_FULL_INFO = @as(u32, 0);
pub const OPERATION_API_VERSION = @as(u32, 1);
pub const MAX_COMPUTERNAME_LENGTH = @as(u32, 15);
pub const LOGON32_PROVIDER_WINNT35 = @as(u32, 1);
pub const LOGON32_PROVIDER_VIRTUAL = @as(u32, 4);
pub const LOGON_ZERO_PASSWORD_BUFFER = @as(u32, 2147483648);
pub const HW_PROFILE_GUIDLEN = @as(u32, 39);
pub const DOCKINFO_UNDOCKED = @as(u32, 1);
pub const DOCKINFO_DOCKED = @as(u32, 2);
pub const DOCKINFO_USER_SUPPLIED = @as(u32, 4);
pub const TC_NORMAL = @as(u32, 0);
pub const TC_HARDERR = @as(u32, 1);
pub const TC_GP_TRAP = @as(u32, 2);
pub const TC_SIGNAL = @as(u32, 3);
pub const AC_LINE_OFFLINE = @as(u32, 0);
pub const AC_LINE_ONLINE = @as(u32, 1);
pub const AC_LINE_BACKUP_POWER = @as(u32, 2);
pub const AC_LINE_UNKNOWN = @as(u32, 255);
pub const BATTERY_FLAG_HIGH = @as(u32, 1);
pub const BATTERY_FLAG_LOW = @as(u32, 2);
pub const BATTERY_FLAG_CRITICAL = @as(u32, 4);
pub const BATTERY_FLAG_CHARGING = @as(u32, 8);
pub const BATTERY_FLAG_NO_BATTERY = @as(u32, 128);
pub const BATTERY_FLAG_UNKNOWN = @as(u32, 255);
pub const BATTERY_PERCENTAGE_UNKNOWN = @as(u32, 255);
pub const SYSTEM_STATUS_FLAG_POWER_SAVING_ON = @as(u32, 1);
pub const BATTERY_LIFE_UNKNOWN = @as(u32, 4294967295);
pub const ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID = @as(u32, 1);
pub const ACTCTX_FLAG_LANGID_VALID = @as(u32, 2);
pub const ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID = @as(u32, 4);
pub const ACTCTX_FLAG_RESOURCE_NAME_VALID = @as(u32, 8);
pub const ACTCTX_FLAG_SET_PROCESS_DEFAULT = @as(u32, 16);
pub const ACTCTX_FLAG_APPLICATION_NAME_VALID = @as(u32, 32);
pub const ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF = @as(u32, 64);
pub const ACTCTX_FLAG_HMODULE_VALID = @as(u32, 128);
pub const DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION = @as(u32, 1);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX = @as(u32, 1);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS = @as(u32, 2);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA = @as(u32, 4);
pub const ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED = @as(u32, 1);
pub const QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX = @as(u32, 4);
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE = @as(u32, 8);
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS = @as(u32, 16);
pub const QUERY_ACTCTX_FLAG_NO_ADDREF = @as(u32, 2147483648);
pub const RESTART_MAX_CMD_LINE = @as(u32, 1024);
pub const RECOVERY_DEFAULT_PING_INTERVAL = @as(u32, 5000);
pub const FILE_RENAME_FLAG_REPLACE_IF_EXISTS = @as(u32, 1);
pub const FILE_RENAME_FLAG_POSIX_SEMANTICS = @as(u32, 2);
pub const FILE_RENAME_FLAG_SUPPRESS_PIN_STATE_INHERITANCE = @as(u32, 4);
pub const FILE_DISPOSITION_FLAG_DO_NOT_DELETE = @as(u32, 0);
pub const FILE_DISPOSITION_FLAG_DELETE = @as(u32, 1);
pub const FILE_DISPOSITION_FLAG_POSIX_SEMANTICS = @as(u32, 2);
pub const FILE_DISPOSITION_FLAG_FORCE_IMAGE_SECTION_CHECK = @as(u32, 4);
pub const FILE_DISPOSITION_FLAG_ON_CLOSE = @as(u32, 8);
pub const FILE_DISPOSITION_FLAG_IGNORE_READONLY_ATTRIBUTE = @as(u32, 16);
pub const STORAGE_INFO_FLAGS_ALIGNED_DEVICE = @as(u32, 1);
pub const STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE = @as(u32, 2);
pub const STORAGE_INFO_OFFSET_UNKNOWN = @as(u32, 4294967295);
pub const REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK = @as(u32, 1);
pub const REMOTE_PROTOCOL_INFO_FLAG_OFFLINE = @as(u32, 2);
pub const REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE = @as(u32, 4);
pub const RPI_FLAG_SMB2_SHARECAP_TIMEWARP = @as(u32, 2);
pub const RPI_FLAG_SMB2_SHARECAP_DFS = @as(u32, 8);
pub const RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY = @as(u32, 16);
pub const RPI_FLAG_SMB2_SHARECAP_SCALEOUT = @as(u32, 32);
pub const RPI_FLAG_SMB2_SHARECAP_CLUSTER = @as(u32, 64);
pub const RPI_SMB2_FLAG_SERVERCAP_DFS = @as(u32, 1);
pub const RPI_SMB2_FLAG_SERVERCAP_LEASING = @as(u32, 2);
pub const RPI_SMB2_FLAG_SERVERCAP_LARGEMTU = @as(u32, 4);
pub const RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL = @as(u32, 8);
pub const RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES = @as(u32, 16);
pub const RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING = @as(u32, 32);
pub const MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = @as(u32, 0);
pub const MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = @as(u32, 0);
pub const CODEINTEGRITY_OPTION_ENABLED = @as(u32, 1);
pub const CODEINTEGRITY_OPTION_TESTSIGN = @as(u32, 2);
pub const CODEINTEGRITY_OPTION_UMCI_ENABLED = @as(u32, 4);
pub const CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED = @as(u32, 8);
pub const CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED = @as(u32, 16);
pub const CODEINTEGRITY_OPTION_TEST_BUILD = @as(u32, 32);
pub const CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD = @as(u32, 64);
pub const CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED = @as(u32, 128);
pub const CODEINTEGRITY_OPTION_FLIGHT_BUILD = @as(u32, 256);
pub const CODEINTEGRITY_OPTION_FLIGHTING_ENABLED = @as(u32, 512);
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED = @as(u32, 1024);
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED = @as(u32, 2048);
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED = @as(u32, 4096);
pub const CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED = @as(u32, 8192);
pub const FILE_MAXIMUM_DISPOSITION = @as(u32, 5);
pub const FILE_DIRECTORY_FILE = @as(u32, 1);
pub const FILE_WRITE_THROUGH = @as(u32, 2);
pub const FILE_SEQUENTIAL_ONLY = @as(u32, 4);
pub const FILE_NO_INTERMEDIATE_BUFFERING = @as(u32, 8);
pub const FILE_SYNCHRONOUS_IO_ALERT = @as(u32, 16);
pub const FILE_SYNCHRONOUS_IO_NONALERT = @as(u32, 32);
pub const FILE_NON_DIRECTORY_FILE = @as(u32, 64);
pub const FILE_CREATE_TREE_CONNECTION = @as(u32, 128);
pub const FILE_COMPLETE_IF_OPLOCKED = @as(u32, 256);
pub const FILE_NO_EA_KNOWLEDGE = @as(u32, 512);
pub const FILE_OPEN_REMOTE_INSTANCE = @as(u32, 1024);
pub const FILE_RANDOM_ACCESS = @as(u32, 2048);
pub const FILE_DELETE_ON_CLOSE = @as(u32, 4096);
pub const FILE_OPEN_BY_FILE_ID = @as(u32, 8192);
pub const FILE_OPEN_FOR_BACKUP_INTENT = @as(u32, 16384);
pub const FILE_NO_COMPRESSION = @as(u32, 32768);
pub const FILE_OPEN_REQUIRING_OPLOCK = @as(u32, 65536);
pub const FILE_RESERVE_OPFILTER = @as(u32, 1048576);
pub const FILE_OPEN_REPARSE_POINT = @as(u32, 2097152);
pub const FILE_OPEN_NO_RECALL = @as(u32, 4194304);
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY = @as(u32, 8388608);
pub const FILE_VALID_OPTION_FLAGS = @as(u32, 16777215);
pub const FILE_VALID_PIPE_OPTION_FLAGS = @as(u32, 50);
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS = @as(u32, 50);
pub const FILE_VALID_SET_FLAGS = @as(u32, 54);
pub const FILE_SUPERSEDED = @as(u32, 0);
pub const FILE_OPENED = @as(u32, 1);
pub const FILE_CREATED = @as(u32, 2);
pub const FILE_OVERWRITTEN = @as(u32, 3);
pub const FILE_EXISTS = @as(u32, 4);
pub const FILE_DOES_NOT_EXIST = @as(u32, 5);
pub const WINWATCHNOTIFY_START = @as(u32, 0);
pub const WINWATCHNOTIFY_STOP = @as(u32, 1);
pub const WINWATCHNOTIFY_DESTROY = @as(u32, 2);
pub const WINWATCHNOTIFY_CHANGING = @as(u32, 3);
pub const WINWATCHNOTIFY_CHANGED = @as(u32, 4);
pub const RSC_FLAG_INF = @as(u32, 1);
pub const RSC_FLAG_SKIPDISKSPACECHECK = @as(u32, 2);
pub const RSC_FLAG_QUIET = @as(u32, 4);
pub const RSC_FLAG_NGCONV = @as(u32, 8);
pub const RSC_FLAG_UPDHLPDLLS = @as(u32, 16);
pub const RSC_FLAG_DELAYREGISTEROCX = @as(u32, 512);
pub const RSC_FLAG_SETUPAPI = @as(u32, 1024);
pub const ALINF_QUIET = @as(u32, 4);
pub const ALINF_NGCONV = @as(u32, 8);
pub const ALINF_UPDHLPDLLS = @as(u32, 16);
pub const ALINF_BKINSTALL = @as(u32, 32);
pub const ALINF_ROLLBACK = @as(u32, 64);
pub const ALINF_CHECKBKDATA = @as(u32, 128);
pub const ALINF_ROLLBKDOALL = @as(u32, 256);
pub const ALINF_DELAYREGISTEROCX = @as(u32, 512);
pub const AIF_WARNIFSKIP = @as(u32, 1);
pub const AIF_NOSKIP = @as(u32, 2);
pub const AIF_NOVERSIONCHECK = @as(u32, 4);
pub const AIF_FORCE_FILE_IN_USE = @as(u32, 8);
pub const AIF_NOOVERWRITE = @as(u32, 16);
pub const AIF_NO_VERSION_DIALOG = @as(u32, 32);
pub const AIF_REPLACEONLY = @as(u32, 1024);
pub const AIF_NOLANGUAGECHECK = @as(u32, 268435456);
pub const AIF_QUIET = @as(u32, 536870912);
pub const IE4_RESTORE = @as(u32, 1);
pub const IE4_BACKNEW = @as(u32, 2);
pub const IE4_NODELETENEW = @as(u32, 4);
pub const IE4_NOMESSAGES = @as(u32, 8);
pub const IE4_NOPROGRESS = @as(u32, 16);
pub const IE4_NOENUMKEY = @as(u32, 32);
pub const IE4_NO_CRC_MAPPING = @as(u32, 64);
pub const IE4_REGSECTION = @as(u32, 128);
pub const IE4_FRDOALL = @as(u32, 256);
pub const IE4_UPDREFCNT = @as(u32, 512);
pub const IE4_USEREFCNT = @as(u32, 1024);
pub const IE4_EXTRAINCREFCNT = @as(u32, 2048);
pub const IE4_REMOVREGBKDATA = @as(u32, 4096);
pub const ARSR_RESTORE = @as(u32, 1);
pub const ARSR_NOMESSAGES = @as(u32, 8);
pub const ARSR_REGSECTION = @as(u32, 128);
pub const ARSR_REMOVREGBKDATA = @as(u32, 4096);
pub const AFSR_RESTORE = @as(u32, 1);
pub const AFSR_BACKNEW = @as(u32, 2);
pub const AFSR_NODELETENEW = @as(u32, 4);
pub const AFSR_NOMESSAGES = @as(u32, 8);
pub const AFSR_NOPROGRESS = @as(u32, 16);
pub const AFSR_UPDREFCNT = @as(u32, 512);
pub const AFSR_USEREFCNT = @as(u32, 1024);
pub const AFSR_EXTRAINCREFCNT = @as(u32, 2048);
pub const AADBE_ADD_ENTRY = @as(u32, 1);
pub const AADBE_DEL_ENTRY = @as(u32, 2);
pub const ADN_DEL_IF_EMPTY = @as(u32, 1);
pub const ADN_DONT_DEL_SUBDIRS = @as(u32, 2);
pub const ADN_DONT_DEL_DIR = @as(u32, 4);
pub const ADN_DEL_UNC_PATHS = @as(u32, 8);
pub const LIS_QUIET = @as(u32, 1);
pub const LIS_NOGRPCONV = @as(u32, 2);
pub const RUNCMDS_QUIET = @as(u32, 1);
pub const RUNCMDS_NOWAIT = @as(u32, 2);
pub const RUNCMDS_DELAYPOSTCMD = @as(u32, 4);
pub const IME_MAXPROCESS = @as(u32, 32);
pub const CP_HWND = @as(u32, 0);
pub const CP_OPEN = @as(u32, 1);
pub const CP_DIRECT = @as(u32, 2);
pub const CP_LEVEL = @as(u32, 3);
pub const MCW_DEFAULT = @as(u32, 0);
pub const MCW_RECT = @as(u32, 1);
pub const MCW_WINDOW = @as(u32, 2);
pub const MCW_SCREEN = @as(u32, 4);
pub const MCW_VERTICAL = @as(u32, 8);
pub const MCW_HIDDEN = @as(u32, 16);
pub const IME_MODE_ALPHANUMERIC = @as(u32, 1);
pub const IME_MODE_SBCSCHAR = @as(u32, 2);
pub const IME_MODE_KATAKANA = @as(u32, 2);
pub const IME_MODE_HIRAGANA = @as(u32, 4);
pub const IME_MODE_HANJACONVERT = @as(u32, 4);
pub const IME_MODE_DBCSCHAR = @as(u32, 16);
pub const IME_MODE_ROMAN = @as(u32, 32);
pub const IME_MODE_NOROMAN = @as(u32, 64);
pub const IME_MODE_CODEINPUT = @as(u32, 128);
pub const IME_MODE_NOCODEINPUT = @as(u32, 256);
pub const IME_GETIMECAPS = @as(u32, 3);
pub const IME_SETOPEN = @as(u32, 4);
pub const IME_GETOPEN = @as(u32, 5);
pub const IME_GETVERSION = @as(u32, 7);
pub const IME_SETCONVERSIONWINDOW = @as(u32, 8);
pub const IME_MOVEIMEWINDOW = @as(u32, 8);
pub const IME_SETCONVERSIONMODE = @as(u32, 16);
pub const IME_GETCONVERSIONMODE = @as(u32, 17);
pub const IME_SET_MODE = @as(u32, 18);
pub const IME_SENDVKEY = @as(u32, 19);
pub const IME_ENTERWORDREGISTERMODE = @as(u32, 24);
pub const IME_SETCONVERSIONFONTEX = @as(u32, 25);
pub const IME_BANJAtoJUNJA = @as(u32, 19);
pub const IME_JUNJAtoBANJA = @as(u32, 20);
pub const IME_JOHABtoKS = @as(u32, 21);
pub const IME_KStoJOHAB = @as(u32, 22);
pub const IMEA_INIT = @as(u32, 1);
pub const IMEA_NEXT = @as(u32, 2);
pub const IMEA_PREV = @as(u32, 3);
pub const IME_REQUEST_CONVERT = @as(u32, 1);
pub const IME_ENABLE_CONVERT = @as(u32, 2);
pub const INTERIM_WINDOW = @as(u32, 0);
pub const MODE_WINDOW = @as(u32, 1);
pub const HANJA_WINDOW = @as(u32, 2);
pub const IME_RS_ERROR = @as(u32, 1);
pub const IME_RS_NOIME = @as(u32, 2);
pub const IME_RS_TOOLONG = @as(u32, 5);
pub const IME_RS_ILLEGAL = @as(u32, 6);
pub const IME_RS_NOTFOUND = @as(u32, 7);
pub const IME_RS_NOROOM = @as(u32, 10);
pub const IME_RS_DISKERROR = @as(u32, 14);
pub const IME_RS_INVALID = @as(u32, 17);
pub const IME_RS_NEST = @as(u32, 18);
pub const IME_RS_SYSTEMMODAL = @as(u32, 19);
pub const WM_IME_REPORT = @as(u32, 640);
pub const IR_STRINGSTART = @as(u32, 256);
pub const IR_STRINGEND = @as(u32, 257);
pub const IR_OPENCONVERT = @as(u32, 288);
pub const IR_CHANGECONVERT = @as(u32, 289);
pub const IR_CLOSECONVERT = @as(u32, 290);
pub const IR_FULLCONVERT = @as(u32, 291);
pub const IR_IMESELECT = @as(u32, 304);
pub const IR_STRING = @as(u32, 320);
pub const IR_DBCSCHAR = @as(u32, 352);
pub const IR_UNDETERMINE = @as(u32, 368);
pub const IR_STRINGEX = @as(u32, 384);
pub const IR_MODEINFO = @as(u32, 400);
pub const WM_WNT_CONVERTREQUESTEX = @as(u32, 265);
pub const WM_CONVERTREQUEST = @as(u32, 266);
pub const WM_CONVERTRESULT = @as(u32, 267);
pub const WM_INTERIM = @as(u32, 268);
pub const WM_IMEKEYDOWN = @as(u32, 656);
pub const WM_IMEKEYUP = @as(u32, 657);
pub const DELAYLOAD_GPA_FAILURE = @as(u32, 4);
pub const CATID_DeleteBrowsingHistory = Guid.initString("31caf6e4-d6aa-4090-a050-a5ac8972e9ef");
pub const DELETE_BROWSING_HISTORY_HISTORY = @as(u32, 1);
pub const DELETE_BROWSING_HISTORY_COOKIES = @as(u32, 2);
pub const DELETE_BROWSING_HISTORY_TIF = @as(u32, 4);
pub const DELETE_BROWSING_HISTORY_FORMDATA = @as(u32, 8);
pub const DELETE_BROWSING_HISTORY_PASSWORDS = @as(u32, 16);
pub const DELETE_BROWSING_HISTORY_PRESERVEFAVORITES = @as(u32, 32);
pub const DELETE_BROWSING_HISTORY_DOWNLOADHISTORY = @as(u32, 64);

//--------------------------------------------------------------------------------
// Section: Types (133)
//--------------------------------------------------------------------------------
pub const TDIENTITY_ENTITY_TYPE = enum(u32) {
    GENERIC_ENTITY = 0,
    AT_ENTITY = 640,
    CL_NL_ENTITY = 769,
    CO_NL_ENTITY = 768,
    CL_TL_ENTITY = 1025,
    CO_TL_ENTITY = 1024,
    ER_ENTITY = 896,
    IF_ENTITY = 512,
};
pub const GENERIC_ENTITY = TDIENTITY_ENTITY_TYPE.GENERIC_ENTITY;
pub const AT_ENTITY = TDIENTITY_ENTITY_TYPE.AT_ENTITY;
pub const CL_NL_ENTITY = TDIENTITY_ENTITY_TYPE.CL_NL_ENTITY;
pub const CO_NL_ENTITY = TDIENTITY_ENTITY_TYPE.CO_NL_ENTITY;
pub const CL_TL_ENTITY = TDIENTITY_ENTITY_TYPE.CL_TL_ENTITY;
pub const CO_TL_ENTITY = TDIENTITY_ENTITY_TYPE.CO_TL_ENTITY;
pub const ER_ENTITY = TDIENTITY_ENTITY_TYPE.ER_ENTITY;
pub const IF_ENTITY = TDIENTITY_ENTITY_TYPE.IF_ENTITY;

pub const _D3DHAL_CALLBACKS = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const _D3DHAL_GLOBALDRIVERDATA = extern struct {
    placeholder: usize, // TODO: why is this type empty?
};

pub const HWINWATCH = *opaque{};

pub const FEATURE_STATE_CHANGE_SUBSCRIPTION = isize;

pub const FH_SERVICE_PIPE_HANDLE = isize;

pub const IMAGE_THUNK_DATA64 = extern struct {
    u1: extern union {
        ForwarderString: u64,
        Function: u64,
        Ordinal: u64,
        AddressOfData: u64,
    },
};

pub const IMAGE_THUNK_DATA32 = extern struct {
    u1: extern union {
        ForwarderString: u32,
        Function: u32,
        Ordinal: u32,
        AddressOfData: u32,
    },
};

pub const IMAGE_DELAYLOAD_DESCRIPTOR = extern struct {
    Attributes: extern union {
        AllAttributes: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
    DllNameRVA: u32,
    ModuleHandleRVA: u32,
    ImportAddressTableRVA: u32,
    ImportNameTableRVA: u32,
    BoundImportAddressTableRVA: u32,
    UnloadInformationTableRVA: u32,
    TimeDateStamp: u32,
};

pub const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = extern struct {
    Size: u32,
    TriggerId: ?[*:0]const u16,
};

pub const PFIBER_CALLOUT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpParameter: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn(
        lpParameter: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
} ;

pub const JIT_DEBUG_INFO = extern struct {
    dwSize: u32,
    dwProcessorArchitecture: u32,
    dwThreadID: u32,
    dwReserved0: u32,
    lpExceptionAddress: u64,
    lpExceptionRecord: u64,
    lpContextRecord: u64,
};

pub const PROC_THREAD_ATTRIBUTE_NUM = enum(i32) {
    ParentProcess = 0,
    HandleList = 2,
    GroupAffinity = 3,
    PreferredNode = 4,
    IdealProcessor = 5,
    UmsThread = 6,
    MitigationPolicy = 7,
    SecurityCapabilities = 9,
    ProtectionLevel = 11,
    JobList = 13,
    ChildProcessPolicy = 14,
    AllApplicationPackagesPolicy = 15,
    Win32kFilter = 16,
    SafeOpenPromptOriginClaim = 17,
    DesktopAppPolicy = 18,
    PseudoConsole = 22,
    MitigationAuditPolicy = 24,
    MachineType = 25,
    ComponentFilter = 26,
    EnableOptionalXStateFeatures = 27,
};
pub const ProcThreadAttributeParentProcess = PROC_THREAD_ATTRIBUTE_NUM.ParentProcess;
pub const ProcThreadAttributeHandleList = PROC_THREAD_ATTRIBUTE_NUM.HandleList;
pub const ProcThreadAttributeGroupAffinity = PROC_THREAD_ATTRIBUTE_NUM.GroupAffinity;
pub const ProcThreadAttributePreferredNode = PROC_THREAD_ATTRIBUTE_NUM.PreferredNode;
pub const ProcThreadAttributeIdealProcessor = PROC_THREAD_ATTRIBUTE_NUM.IdealProcessor;
pub const ProcThreadAttributeUmsThread = PROC_THREAD_ATTRIBUTE_NUM.UmsThread;
pub const ProcThreadAttributeMitigationPolicy = PROC_THREAD_ATTRIBUTE_NUM.MitigationPolicy;
pub const ProcThreadAttributeSecurityCapabilities = PROC_THREAD_ATTRIBUTE_NUM.SecurityCapabilities;
pub const ProcThreadAttributeProtectionLevel = PROC_THREAD_ATTRIBUTE_NUM.ProtectionLevel;
pub const ProcThreadAttributeJobList = PROC_THREAD_ATTRIBUTE_NUM.JobList;
pub const ProcThreadAttributeChildProcessPolicy = PROC_THREAD_ATTRIBUTE_NUM.ChildProcessPolicy;
pub const ProcThreadAttributeAllApplicationPackagesPolicy = PROC_THREAD_ATTRIBUTE_NUM.AllApplicationPackagesPolicy;
pub const ProcThreadAttributeWin32kFilter = PROC_THREAD_ATTRIBUTE_NUM.Win32kFilter;
pub const ProcThreadAttributeSafeOpenPromptOriginClaim = PROC_THREAD_ATTRIBUTE_NUM.SafeOpenPromptOriginClaim;
pub const ProcThreadAttributeDesktopAppPolicy = PROC_THREAD_ATTRIBUTE_NUM.DesktopAppPolicy;
pub const ProcThreadAttributePseudoConsole = PROC_THREAD_ATTRIBUTE_NUM.PseudoConsole;
pub const ProcThreadAttributeMitigationAuditPolicy = PROC_THREAD_ATTRIBUTE_NUM.MitigationAuditPolicy;
pub const ProcThreadAttributeMachineType = PROC_THREAD_ATTRIBUTE_NUM.MachineType;
pub const ProcThreadAttributeComponentFilter = PROC_THREAD_ATTRIBUTE_NUM.ComponentFilter;
pub const ProcThreadAttributeEnableOptionalXStateFeatures = PROC_THREAD_ATTRIBUTE_NUM.EnableOptionalXStateFeatures;

pub const HW_PROFILE_INFOA = extern struct {
    dwDockInfo: u32,
    szHwProfileGuid: [39]CHAR,
    szHwProfileName: [80]CHAR,
};

pub const HW_PROFILE_INFOW = extern struct {
    dwDockInfo: u32,
    szHwProfileGuid: [39]u16,
    szHwProfileName: [80]u16,
};

pub const ACTCTX_SECTION_KEYED_DATA_2600 = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: ?*anyopaque,
    ulLength: u32,
    lpSectionGlobalData: ?*anyopaque,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: ?*anyopaque,
    ulSectionTotalLength: u32,
    hActCtx: ?HANDLE,
    ulAssemblyRosterIndex: u32,
};

pub const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = extern struct {
    lpInformation: ?*anyopaque,
    lpSectionBase: ?*anyopaque,
    ulSectionLength: u32,
    lpSectionGlobalDataBase: ?*anyopaque,
    ulSectionGlobalDataLength: u32,
};

pub const ACTIVATION_CONTEXT_BASIC_INFORMATION = extern struct {
    hActCtx: ?HANDLE,
    dwFlags: u32,
};

pub const PQUERYACTCTXW_FUNC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwFlags: u32,
        hActCtx: ?HANDLE,
        pvSubInstance: ?*anyopaque,
        ulInfoClass: u32,
        // TODO: what to do with BytesParamIndex 5?
        pvBuffer: ?*anyopaque,
        cbBuffer: usize,
        pcbWrittenOrRequired: ?*usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        dwFlags: u32,
        hActCtx: ?HANDLE,
        pvSubInstance: ?*anyopaque,
        ulInfoClass: u32,
        // TODO: what to do with BytesParamIndex 5?
        pvBuffer: ?*anyopaque,
        cbBuffer: usize,
        pcbWrittenOrRequired: ?*usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const APPLICATION_RECOVERY_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pvParameter: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        pvParameter: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const FILE_CASE_SENSITIVE_INFO = extern struct {
    Flags: u32,
};

pub const FILE_DISPOSITION_INFO_EX = extern struct {
    Flags: u32,
};

pub const CLIENT_ID = extern struct {
    UniqueProcess: ?HANDLE,
    UniqueThread: ?HANDLE,
};

pub const LDR_DATA_TABLE_ENTRY = extern struct {
    Reserved1: [2]?*anyopaque,
    InMemoryOrderLinks: LIST_ENTRY,
    Reserved2: [2]?*anyopaque,
    DllBase: ?*anyopaque,
    Reserved3: [2]?*anyopaque,
    FullDllName: UNICODE_STRING,
    Reserved4: [8]u8,
    Reserved5: [3]?*anyopaque,
    Anonymous: extern union {
        CheckSum: u32,
        Reserved6: ?*anyopaque,
    },
    TimeDateStamp: u32,
};

pub const OBJECT_ATTRIBUTES = extern struct {
    Length: u32,
    RootDirectory: ?HANDLE,
    ObjectName: ?*UNICODE_STRING,
    Attributes: u32,
    SecurityDescriptor: ?*anyopaque,
    SecurityQualityOfService: ?*anyopaque,
};

pub const IO_STATUS_BLOCK = extern struct {
    Anonymous: extern union {
        Status: NTSTATUS,
        Pointer: ?*anyopaque,
    },
    Information: usize,
};

pub const PIO_APC_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ApcContext: ?*anyopaque,
        IoStatusBlock: ?*IO_STATUS_BLOCK,
        Reserved: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        ApcContext: ?*anyopaque,
        IoStatusBlock: ?*IO_STATUS_BLOCK,
        Reserved: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = extern struct {
    IdleTime: LARGE_INTEGER,
    KernelTime: LARGE_INTEGER,
    UserTime: LARGE_INTEGER,
    Reserved1: [2]LARGE_INTEGER,
    Reserved2: u32,
};

pub const SYSTEM_PROCESS_INFORMATION = extern struct {
    NextEntryOffset: u32,
    NumberOfThreads: u32,
    Reserved1: [48]u8,
    ImageName: UNICODE_STRING,
    BasePriority: i32,
    UniqueProcessId: ?HANDLE,
    Reserved2: ?*anyopaque,
    HandleCount: u32,
    SessionId: u32,
    Reserved3: ?*anyopaque,
    PeakVirtualSize: usize,
    VirtualSize: usize,
    Reserved4: u32,
    PeakWorkingSetSize: usize,
    WorkingSetSize: usize,
    Reserved5: ?*anyopaque,
    QuotaPagedPoolUsage: usize,
    Reserved6: ?*anyopaque,
    QuotaNonPagedPoolUsage: usize,
    PagefileUsage: usize,
    PeakPagefileUsage: usize,
    PrivatePageCount: usize,
    Reserved7: [6]LARGE_INTEGER,
};

pub const SYSTEM_THREAD_INFORMATION = extern struct {
    Reserved1: [3]LARGE_INTEGER,
    Reserved2: u32,
    StartAddress: ?*anyopaque,
    ClientId: CLIENT_ID,
    Priority: i32,
    BasePriority: i32,
    Reserved3: u32,
    ThreadState: u32,
    WaitReason: u32,
};

pub const SYSTEM_REGISTRY_QUOTA_INFORMATION = extern struct {
    RegistryQuotaAllowed: u32,
    RegistryQuotaUsed: u32,
    Reserved1: ?*anyopaque,
};

pub const SYSTEM_BASIC_INFORMATION = extern struct {
    Reserved1: [24]u8,
    Reserved2: [4]?*anyopaque,
    NumberOfProcessors: i8,
};

pub const SYSTEM_TIMEOFDAY_INFORMATION = extern struct {
    Reserved1: [48]u8,
};

pub const SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    Reserved1: [312]u8,
};

pub const SYSTEM_EXCEPTION_INFORMATION = extern struct {
    Reserved1: [16]u8,
};

pub const SYSTEM_LOOKASIDE_INFORMATION = extern struct {
    Reserved1: [32]u8,
};

pub const SYSTEM_INTERRUPT_INFORMATION = extern struct {
    Reserved1: [24]u8,
};

pub const SYSTEM_POLICY_INFORMATION = extern struct {
    Reserved1: [2]?*anyopaque,
    Reserved2: [3]u32,
};

pub const FILE_INFORMATION_CLASS = enum(i32) {
    n = 1,
};
pub const FileDirectoryInformation = FILE_INFORMATION_CLASS.n;

pub const THREAD_NAME_INFORMATION = extern struct {
    ThreadName: UNICODE_STRING,
};

pub const SYSTEM_CODEINTEGRITY_INFORMATION = extern struct {
    Length: u32,
    CodeIntegrityOptions: u32,
};

pub const SYSTEM_INFORMATION_CLASS = enum(i32) {
    BasicInformation = 0,
    PerformanceInformation = 2,
    TimeOfDayInformation = 3,
    ProcessInformation = 5,
    ProcessorPerformanceInformation = 8,
    InterruptInformation = 23,
    ExceptionInformation = 33,
    RegistryQuotaInformation = 37,
    LookasideInformation = 45,
    CodeIntegrityInformation = 103,
    PolicyInformation = 134,
};
pub const SystemBasicInformation = SYSTEM_INFORMATION_CLASS.BasicInformation;
pub const SystemPerformanceInformation = SYSTEM_INFORMATION_CLASS.PerformanceInformation;
pub const SystemTimeOfDayInformation = SYSTEM_INFORMATION_CLASS.TimeOfDayInformation;
pub const SystemProcessInformation = SYSTEM_INFORMATION_CLASS.ProcessInformation;
pub const SystemProcessorPerformanceInformation = SYSTEM_INFORMATION_CLASS.ProcessorPerformanceInformation;
pub const SystemInterruptInformation = SYSTEM_INFORMATION_CLASS.InterruptInformation;
pub const SystemExceptionInformation = SYSTEM_INFORMATION_CLASS.ExceptionInformation;
pub const SystemRegistryQuotaInformation = SYSTEM_INFORMATION_CLASS.RegistryQuotaInformation;
pub const SystemLookasideInformation = SYSTEM_INFORMATION_CLASS.LookasideInformation;
pub const SystemCodeIntegrityInformation = SYSTEM_INFORMATION_CLASS.CodeIntegrityInformation;
pub const SystemPolicyInformation = SYSTEM_INFORMATION_CLASS.PolicyInformation;

pub const OBJECT_INFORMATION_CLASS = enum(i32) {
    BasicInformation = 0,
    TypeInformation = 2,
};
pub const ObjectBasicInformation = OBJECT_INFORMATION_CLASS.BasicInformation;
pub const ObjectTypeInformation = OBJECT_INFORMATION_CLASS.TypeInformation;

pub const PUBLIC_OBJECT_BASIC_INFORMATION = extern struct {
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
    Reserved: [10]u32,
};

pub const PUBLIC_OBJECT_TYPE_INFORMATION = extern struct {
    TypeName: UNICODE_STRING,
    Reserved: [22]u32,
};

pub const KEY_VALUE_ENTRY = extern struct {
    ValueName: ?*UNICODE_STRING,
    DataLength: u32,
    DataOffset: u32,
    Type: u32,
};

pub const KEY_SET_INFORMATION_CLASS = enum(i32) {
    KeyWriteTimeInformation = 0,
    KeyWow64FlagsInformation = 1,
    KeyControlFlagsInformation = 2,
    KeySetVirtualizationInformation = 3,
    KeySetDebugInformation = 4,
    KeySetHandleTagsInformation = 5,
    MaxKeySetInfoClass = 6,
};
pub const KeyWriteTimeInformation = KEY_SET_INFORMATION_CLASS.KeyWriteTimeInformation;
pub const KeyWow64FlagsInformation = KEY_SET_INFORMATION_CLASS.KeyWow64FlagsInformation;
pub const KeyControlFlagsInformation = KEY_SET_INFORMATION_CLASS.KeyControlFlagsInformation;
pub const KeySetVirtualizationInformation = KEY_SET_INFORMATION_CLASS.KeySetVirtualizationInformation;
pub const KeySetDebugInformation = KEY_SET_INFORMATION_CLASS.KeySetDebugInformation;
pub const KeySetHandleTagsInformation = KEY_SET_INFORMATION_CLASS.KeySetHandleTagsInformation;
pub const MaxKeySetInfoClass = KEY_SET_INFORMATION_CLASS.MaxKeySetInfoClass;

pub const WINSTATIONINFOCLASS = enum(i32) {
    n = 8,
};
pub const WinStationInformation = WINSTATIONINFOCLASS.n;

pub const WINSTATIONINFORMATIONW = extern struct {
    Reserved2: [70]u8,
    LogonId: u32,
    Reserved3: [1140]u8,
};

pub const PWINSTATIONQUERYINFORMATIONW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?HANDLE,
        param1: u32,
        param2: WINSTATIONINFOCLASS,
        param3: ?*anyopaque,
        param4: u32,
        param5: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
    else => *const fn(
        param0: ?HANDLE,
        param1: u32,
        param2: WINSTATIONINFOCLASS,
        param3: ?*anyopaque,
        param4: u32,
        param5: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
} ;

const CLSID_CameraUIControl_Value = Guid.initString("16d5a2be-b1c5-47b3-8eae-ccbcf452c7e8");
pub const CLSID_CameraUIControl = &CLSID_CameraUIControl_Value;

pub const CameraUIControlMode = enum(i32) {
    Browse = 0,
    Linear = 1,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const CameraUIControlLinearSelectionMode = enum(i32) {
    Single = 0,
    Multiple = 1,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const CameraUIControlCaptureMode = enum(i32) {
    PhotoOrVideo = 0,
    Photo = 1,
    Video = 2,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const CameraUIControlPhotoFormat = enum(i32) {
    Jpeg = 0,
    Png = 1,
    JpegXR = 2,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const CameraUIControlVideoFormat = enum(i32) {
    Mp4 = 0,
    Wmv = 1,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const CameraUIControlViewType = enum(i32) {
    SingleItem = 0,
    ItemList = 1,
};
// NOTE: not creating aliases because this enum is 'Scoped'

// TODO: this type is limited to platform 'windows8.0'
const IID_ICameraUIControlEventCallback_Value = Guid.initString("1bfa0c2c-fbcd-4776-bda4-88bf974e74f4");
pub const IID_ICameraUIControlEventCallback = &IID_ICameraUIControlEventCallback_Value;
pub const ICameraUIControlEventCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartupComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnSuspendComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnItemCaptured: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControlEventCallback,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ICameraUIControlEventCallback,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnItemDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControlEventCallback,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ICameraUIControlEventCallback,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        OnClosed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnStartupComplete(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnStartupComplete(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnSuspendComplete(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnSuspendComplete(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnItemCaptured(self: *const T, pszPath: ?[*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnItemCaptured(@ptrCast(*const ICameraUIControlEventCallback, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnItemDeleted(self: *const T, pszPath: ?[*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnItemDeleted(@ptrCast(*const ICameraUIControlEventCallback, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnClosed(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnClosed(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ICameraUIControl_Value = Guid.initString("b8733adf-3d68-4b8f-bb08-e28a0bed0376");
pub const IID_ICameraUIControl = &IID_ICameraUIControl_Value;
pub const ICameraUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Show: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
                pWindow: ?*IUnknown,
                mode: CameraUIControlMode,
                selectionMode: CameraUIControlLinearSelectionMode,
                captureMode: CameraUIControlCaptureMode,
                photoFormat: CameraUIControlPhotoFormat,
                videoFormat: CameraUIControlVideoFormat,
                bHasCloseButton: BOOL,
                pEventCallback: ?*ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
                pWindow: ?*IUnknown,
                mode: CameraUIControlMode,
                selectionMode: CameraUIControlLinearSelectionMode,
                captureMode: CameraUIControlCaptureMode,
                photoFormat: CameraUIControlPhotoFormat,
                videoFormat: CameraUIControlVideoFormat,
                bHasCloseButton: BOOL,
                pEventCallback: ?*ICameraUIControlEventCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
                pbDeferralRequired: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
                pbDeferralRequired: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentViewType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
                pViewType: ?*CameraUIControlViewType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
                pViewType: ?*CameraUIControlViewType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActiveItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
                pbstrActiveItemPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
                pbstrActiveItemPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectedItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
                ppSelectedItemPaths: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
                ppSelectedItemPaths: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveCapturedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraUIControl,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraUIControl,
                pszPath: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Show(self: *const T, pWindow: ?*IUnknown, mode: CameraUIControlMode, selectionMode: CameraUIControlLinearSelectionMode, captureMode: CameraUIControlCaptureMode, photoFormat: CameraUIControlPhotoFormat, videoFormat: CameraUIControlVideoFormat, bHasCloseButton: BOOL, pEventCallback: ?*ICameraUIControlEventCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Show(@ptrCast(*const ICameraUIControl, self), pWindow, mode, selectionMode, captureMode, photoFormat, videoFormat, bHasCloseButton, pEventCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Close(@ptrCast(*const ICameraUIControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Suspend(self: *const T, pbDeferralRequired: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Suspend(@ptrCast(*const ICameraUIControl, self), pbDeferralRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Resume(@ptrCast(*const ICameraUIControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetCurrentViewType(self: *const T, pViewType: ?*CameraUIControlViewType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetCurrentViewType(@ptrCast(*const ICameraUIControl, self), pViewType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetActiveItem(self: *const T, pbstrActiveItemPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetActiveItem(@ptrCast(*const ICameraUIControl, self), pbstrActiveItemPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetSelectedItems(self: *const T, ppSelectedItemPaths: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetSelectedItems(@ptrCast(*const ICameraUIControl, self), ppSelectedItemPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_RemoveCapturedItem(self: *const T, pszPath: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).RemoveCapturedItem(@ptrCast(*const ICameraUIControl, self), pszPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_EditionUpgradeHelper_Value = Guid.initString("01776df3-b9af-4e50-9b1c-56e93116d704");
pub const CLSID_EditionUpgradeHelper = &CLSID_EditionUpgradeHelper_Value;

const CLSID_EditionUpgradeBroker_Value = Guid.initString("c4270827-4f39-45df-9288-12ff6b85a921");
pub const CLSID_EditionUpgradeBroker = &CLSID_EditionUpgradeBroker_Value;

// TODO: this type is limited to platform 'windows10.0.10240'
const IID_IEditionUpgradeHelper_Value = Guid.initString("d3e9e342-5deb-43b6-849e-6913b85d503a");
pub const IID_IEditionUpgradeHelper = &IID_IEditionUpgradeHelper_Value;
pub const IEditionUpgradeHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanUpgrade: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeHelper,
                isAllowed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeHelper,
                isAllowed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateOperatingSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeHelper,
                contentId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeHelper,
                contentId: ?[*:0]const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowProductKeyUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeHelper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOsProductContentId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeHelper,
                contentId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeHelper,
                contentId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenuineLocalStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeHelper,
                isGenuine: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeHelper,
                isGenuine: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_CanUpgrade(self: *const T, isAllowed: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).CanUpgrade(@ptrCast(*const IEditionUpgradeHelper, self), isAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_UpdateOperatingSystem(self: *const T, contentId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).UpdateOperatingSystem(@ptrCast(*const IEditionUpgradeHelper, self), contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_ShowProductKeyUI(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).ShowProductKeyUI(@ptrCast(*const IEditionUpgradeHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_GetOsProductContentId(self: *const T, contentId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).GetOsProductContentId(@ptrCast(*const IEditionUpgradeHelper, self), contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_GetGenuineLocalStatus(self: *const T, isGenuine: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).GetGenuineLocalStatus(@ptrCast(*const IEditionUpgradeHelper, self), isGenuine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWindowsLockModeHelper_Value = Guid.initString("f342d19e-cc22-4648-bb5d-03ccf75b47c5");
pub const IID_IWindowsLockModeHelper = &IID_IWindowsLockModeHelper_Value;
pub const IWindowsLockModeHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWindowsLockModeHelper,
                isSmode: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWindowsLockModeHelper,
                isSmode: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsLockModeHelper_GetSMode(self: *const T, isSmode: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowsLockModeHelper.VTable, self.vtable).GetSMode(@ptrCast(*const IWindowsLockModeHelper, self), isSmode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEditionUpgradeBroker_Value = Guid.initString("ff19cbcf-9455-4937-b872-6b7929a460af");
pub const IID_IEditionUpgradeBroker = &IID_IEditionUpgradeBroker_Value;
pub const IEditionUpgradeBroker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeParentWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeBroker,
                parentHandle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeBroker,
                parentHandle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateOperatingSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeBroker,
                parameter: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeBroker,
                parameter: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowProductKeyUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeBroker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeBroker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanUpgrade: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEditionUpgradeBroker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEditionUpgradeBroker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_InitializeParentWindow(self: *const T, parentHandle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).InitializeParentWindow(@ptrCast(*const IEditionUpgradeBroker, self), parentHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_UpdateOperatingSystem(self: *const T, parameter: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).UpdateOperatingSystem(@ptrCast(*const IEditionUpgradeBroker, self), parameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_ShowProductKeyUI(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).ShowProductKeyUI(@ptrCast(*const IEditionUpgradeBroker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_CanUpgrade(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).CanUpgrade(@ptrCast(*const IEditionUpgradeBroker, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IContainerActivationHelper_Value = Guid.initString("b524f93f-80d5-4ec7-ae9e-d66e93ade1fa");
pub const IID_IContainerActivationHelper = &IID_IContainerActivationHelper_Value;
pub const IContainerActivationHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanActivateClientVM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IContainerActivationHelper,
                isAllowed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IContainerActivationHelper,
                isAllowed: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContainerActivationHelper_CanActivateClientVM(self: *const T, isAllowed: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContainerActivationHelper.VTable, self.vtable).CanActivateClientVM(@ptrCast(*const IContainerActivationHelper, self), isAllowed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClipServiceNotificationHelper_Value = Guid.initString("c39948f0-6142-44fd-98ca-e1681a8d68b5");
pub const IID_IClipServiceNotificationHelper = &IID_IClipServiceNotificationHelper_Value;
pub const IClipServiceNotificationHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowToast: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IClipServiceNotificationHelper,
                titleText: ?BSTR,
                bodyText: ?BSTR,
                packageName: ?BSTR,
                appId: ?BSTR,
                launchCommand: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IClipServiceNotificationHelper,
                titleText: ?BSTR,
                bodyText: ?BSTR,
                packageName: ?BSTR,
                appId: ?BSTR,
                launchCommand: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClipServiceNotificationHelper_ShowToast(self: *const T, titleText: ?BSTR, bodyText: ?BSTR, packageName: ?BSTR, appId: ?BSTR, launchCommand: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClipServiceNotificationHelper.VTable, self.vtable).ShowToast(@ptrCast(*const IClipServiceNotificationHelper, self), titleText, bodyText, packageName, appId, launchCommand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FEATURE_CHANGE_TIME = enum(i32) {
    READ = 0,
    MODULE_RELOAD = 1,
    SESSION = 2,
    REBOOT = 3,
};
pub const FEATURE_CHANGE_TIME_READ = FEATURE_CHANGE_TIME.READ;
pub const FEATURE_CHANGE_TIME_MODULE_RELOAD = FEATURE_CHANGE_TIME.MODULE_RELOAD;
pub const FEATURE_CHANGE_TIME_SESSION = FEATURE_CHANGE_TIME.SESSION;
pub const FEATURE_CHANGE_TIME_REBOOT = FEATURE_CHANGE_TIME.REBOOT;

pub const FEATURE_ENABLED_STATE = enum(i32) {
    DEFAULT = 0,
    DISABLED = 1,
    ENABLED = 2,
};
pub const FEATURE_ENABLED_STATE_DEFAULT = FEATURE_ENABLED_STATE.DEFAULT;
pub const FEATURE_ENABLED_STATE_DISABLED = FEATURE_ENABLED_STATE.DISABLED;
pub const FEATURE_ENABLED_STATE_ENABLED = FEATURE_ENABLED_STATE.ENABLED;

pub const FEATURE_ERROR = extern struct {
    hr: HRESULT,
    lineNumber: u16,
    file: ?[*:0]const u8,
    process: ?[*:0]const u8,
    module: ?[*:0]const u8,
    callerReturnAddressOffset: u32,
    callerModule: ?[*:0]const u8,
    message: ?[*:0]const u8,
    originLineNumber: u16,
    originFile: ?[*:0]const u8,
    originModule: ?[*:0]const u8,
    originCallerReturnAddressOffset: u32,
    originCallerModule: ?[*:0]const u8,
    originName: ?[*:0]const u8,
};

pub const PFEATURE_STATE_CHANGE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const DCICMD = extern struct {
    dwCommand: u32,
    dwParam1: u32,
    dwParam2: u32,
    dwVersion: u32,
    dwReserved: u32,
};

pub const DCICREATEINPUT = extern struct {
    cmd: DCICMD,
    dwCompression: u32,
    dwMask: [3]u32,
    dwWidth: u32,
    dwHeight: u32,
    dwDCICaps: u32,
    dwBitCount: u32,
    lpSurface: ?*anyopaque,
};

pub const DCISURFACEINFO = extern struct {
    dwSize: u32,
    dwDCICaps: u32,
    dwCompression: u32,
    dwMask: [3]u32,
    dwWidth: u32,
    dwHeight: u32,
    lStride: i32,
    dwBitCount: u32,
    dwOffSurface: usize,
    wSelSurface: u16,
    wReserved: u16,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    BeginAccess: isize,
    EndAccess: isize,
    DestroySurface: isize,
};

pub const ENUM_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpSurfaceInfo: ?*DCISURFACEINFO,
        lpContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpSurfaceInfo: ?*DCISURFACEINFO,
        lpContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const DCIENUMINPUT = extern struct {
    cmd: DCICMD,
    rSrc: RECT,
    rDst: RECT,
    EnumCallback: isize,
    lpContext: ?*anyopaque,
};

pub const DCIOFFSCREEN = extern struct {
    dciInfo: DCISURFACEINFO,
    Draw: isize,
    SetClipList: isize,
    SetDestination: isize,
};

pub const DCIOVERLAY = extern struct {
    dciInfo: DCISURFACEINFO,
    dwChromakeyValue: u32,
    dwChromakeyMask: u32,
};

pub const WINWATCHNOTIFYPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hww: ?HWINWATCH,
        hwnd: ?HWND,
        code: u32,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hww: ?HWINWATCH,
        hwnd: ?HWND,
        code: u32,
        lParam: LPARAM,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const STRENTRYA = extern struct {
    pszName: ?PSTR,
    pszValue: ?PSTR,
};

pub const STRENTRYW = extern struct {
    pszName: ?PWSTR,
    pszValue: ?PWSTR,
};

pub const STRTABLEA = extern struct {
    cEntries: u32,
    pse: ?*STRENTRYA,
};

pub const STRTABLEW = extern struct {
    cEntries: u32,
    pse: ?*STRENTRYW,
};

pub const REGINSTALLA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hm: ?HINSTANCE,
        pszSection: ?[*:0]const u8,
        pstTable: ?*STRTABLEA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hm: ?HINSTANCE,
        pszSection: ?[*:0]const u8,
        pstTable: ?*STRTABLEA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const CABINFOA = extern struct {
    pszCab: ?PSTR,
    pszInf: ?PSTR,
    pszSection: ?PSTR,
    szSrcPath: [260]CHAR,
    dwFlags: u32,
};

pub const CABINFOW = extern struct {
    pszCab: ?PWSTR,
    pszInf: ?PWSTR,
    pszSection: ?PWSTR,
    szSrcPath: [260]u16,
    dwFlags: u32,
};

pub const PERUSERSECTIONA = extern struct {
    szGUID: [59]CHAR,
    szDispName: [128]CHAR,
    szLocale: [10]CHAR,
    szStub: [1040]CHAR,
    szVersion: [32]CHAR,
    szCompID: [128]CHAR,
    dwIsInstalled: u32,
    bRollback: BOOL,
};

pub const PERUSERSECTIONW = extern struct {
    szGUID: [59]u16,
    szDispName: [128]u16,
    szLocale: [10]u16,
    szStub: [1040]u16,
    szVersion: [32]u16,
    szCompID: [128]u16,
    dwIsInstalled: u32,
    bRollback: BOOL,
};

pub const IMESTRUCT = extern struct {
    fnc: u32,
    wParam: WPARAM,
    wCount: u32,
    dchSource: u32,
    dchDest: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
    lParam3: LPARAM,
};

pub const UNDETERMINESTRUCT = extern struct {
    dwSize: u32,
    uDefIMESize: u32,
    uDefIMEPos: u32,
    uUndetTextLen: u32,
    uUndetTextPos: u32,
    uUndetAttrPos: u32,
    uCursorPos: u32,
    uDeltaStart: u32,
    uDetermineTextLen: u32,
    uDetermineTextPos: u32,
    uDetermineDelimPos: u32,
    uYomiTextLen: u32,
    uYomiTextPos: u32,
    uYomiDelimPos: u32,
};

pub const STRINGEXSTRUCT = extern struct {
    dwSize: u32,
    uDeterminePos: u32,
    uDetermineDelimPos: u32,
    uYomiPos: u32,
    uYomiDelimPos: u32,
};

pub const DATETIME = extern struct {
    year: u16,
    month: u16,
    day: u16,
    hour: u16,
    min: u16,
    sec: u16,
};

pub const IMEPROA = extern struct {
    hWnd: ?HWND,
    InstDate: DATETIME,
    wVersion: u32,
    szDescription: [50]u8,
    szName: [80]u8,
    szOptions: [30]u8,
};

pub const IMEPROW = extern struct {
    hWnd: ?HWND,
    InstDate: DATETIME,
    wVersion: u32,
    szDescription: [50]u16,
    szName: [80]u16,
    szOptions: [30]u16,
};

pub const JAVA_TRUST = extern struct {
    cbSize: u32,
    flag: u32,
    fAllActiveXPermissions: BOOL,
    fAllPermissions: BOOL,
    dwEncodingType: u32,
    pbJavaPermissions: ?*u8,
    cbJavaPermissions: u32,
    pbSigner: ?*u8,
    cbSigner: u32,
    pwszZone: ?[*:0]const u16,
    guidZone: Guid,
    hVerify: HRESULT,
};

pub const TDIEntityID = extern struct {
    tei_entity: TDIENTITY_ENTITY_TYPE,
    tei_instance: u32,
};

pub const TDIObjectID = extern struct {
    toi_entity: TDIEntityID,
    toi_class: u32,
    toi_type: u32,
    toi_id: u32,
};

pub const tcp_request_query_information_ex_xp = extern struct {
    ID: TDIObjectID,
    Context: [2]usize,
};


pub const tcp_request_query_information_ex_w2k = extern struct {
    ID: TDIObjectID,
    Context: [16]u8,
};

pub const tcp_request_set_information_ex = extern struct {
    ID: TDIObjectID,
    BufferSize: u32,
    Buffer: [1]u8,
};

pub const TDI_TL_IO_CONTROL_TYPE = enum(i32) {
    EndpointIoControlType = 0,
    SetSockOptIoControlType = 1,
    GetSockOptIoControlType = 2,
    SocketIoControlType = 3,
};
pub const EndpointIoControlType = TDI_TL_IO_CONTROL_TYPE.EndpointIoControlType;
pub const SetSockOptIoControlType = TDI_TL_IO_CONTROL_TYPE.SetSockOptIoControlType;
pub const GetSockOptIoControlType = TDI_TL_IO_CONTROL_TYPE.GetSockOptIoControlType;
pub const SocketIoControlType = TDI_TL_IO_CONTROL_TYPE.SocketIoControlType;

pub const TDI_TL_IO_CONTROL_ENDPOINT = extern struct {
    Type: TDI_TL_IO_CONTROL_TYPE,
    Level: u32,
    Anonymous: extern union {
        IoControlCode: u32,
        OptionName: u32,
    },
    InputBuffer: ?*anyopaque,
    InputBufferLength: u32,
    OutputBuffer: ?*anyopaque,
    OutputBufferLength: u32,
};

pub const WLDP_HOST = enum(i32) {
    RUNDLL32 = 0,
    SVCHOST = 1,
    MAX = 2,
};
pub const WLDP_HOST_RUNDLL32 = WLDP_HOST.RUNDLL32;
pub const WLDP_HOST_SVCHOST = WLDP_HOST.SVCHOST;
pub const WLDP_HOST_MAX = WLDP_HOST.MAX;

pub const WLDP_HOST_ID = enum(i32) {
    UNKNOWN = 0,
    GLOBAL = 1,
    VBA = 2,
    WSH = 3,
    POWERSHELL = 4,
    IE = 5,
    MSI = 6,
    ALL = 7,
    MAX = 8,
};
pub const WLDP_HOST_ID_UNKNOWN = WLDP_HOST_ID.UNKNOWN;
pub const WLDP_HOST_ID_GLOBAL = WLDP_HOST_ID.GLOBAL;
pub const WLDP_HOST_ID_VBA = WLDP_HOST_ID.VBA;
pub const WLDP_HOST_ID_WSH = WLDP_HOST_ID.WSH;
pub const WLDP_HOST_ID_POWERSHELL = WLDP_HOST_ID.POWERSHELL;
pub const WLDP_HOST_ID_IE = WLDP_HOST_ID.IE;
pub const WLDP_HOST_ID_MSI = WLDP_HOST_ID.MSI;
pub const WLDP_HOST_ID_ALL = WLDP_HOST_ID.ALL;
pub const WLDP_HOST_ID_MAX = WLDP_HOST_ID.MAX;

pub const DECISION_LOCATION = enum(i32) {
    REFRESH_GLOBAL_DATA = 0,
    PARAMETER_VALIDATION = 1,
    AUDIT = 2,
    FAILED_CONVERT_GUID = 3,
    ENTERPRISE_DEFINED_CLASS_ID = 4,
    GLOBAL_BUILT_IN_LIST = 5,
    PROVIDER_BUILT_IN_LIST = 6,
    ENFORCE_STATE_LIST = 7,
    NOT_FOUND = 8,
    UNKNOWN = 9,
};
pub const DECISION_LOCATION_REFRESH_GLOBAL_DATA = DECISION_LOCATION.REFRESH_GLOBAL_DATA;
pub const DECISION_LOCATION_PARAMETER_VALIDATION = DECISION_LOCATION.PARAMETER_VALIDATION;
pub const DECISION_LOCATION_AUDIT = DECISION_LOCATION.AUDIT;
pub const DECISION_LOCATION_FAILED_CONVERT_GUID = DECISION_LOCATION.FAILED_CONVERT_GUID;
pub const DECISION_LOCATION_ENTERPRISE_DEFINED_CLASS_ID = DECISION_LOCATION.ENTERPRISE_DEFINED_CLASS_ID;
pub const DECISION_LOCATION_GLOBAL_BUILT_IN_LIST = DECISION_LOCATION.GLOBAL_BUILT_IN_LIST;
pub const DECISION_LOCATION_PROVIDER_BUILT_IN_LIST = DECISION_LOCATION.PROVIDER_BUILT_IN_LIST;
pub const DECISION_LOCATION_ENFORCE_STATE_LIST = DECISION_LOCATION.ENFORCE_STATE_LIST;
pub const DECISION_LOCATION_NOT_FOUND = DECISION_LOCATION.NOT_FOUND;
pub const DECISION_LOCATION_UNKNOWN = DECISION_LOCATION.UNKNOWN;

pub const WLDP_KEY = enum(i32) {
    UNKNOWN = 0,
    OVERRIDE = 1,
    ALL_KEYS = 2,
};
pub const KEY_UNKNOWN = WLDP_KEY.UNKNOWN;
pub const KEY_OVERRIDE = WLDP_KEY.OVERRIDE;
pub const KEY_ALL_KEYS = WLDP_KEY.ALL_KEYS;

pub const VALUENAME = enum(i32) {
    UNKNOWN = 0,
    ENTERPRISE_DEFINED_CLASS_ID = 1,
    BUILT_IN_LIST = 2,
};
pub const VALUENAME_UNKNOWN = VALUENAME.UNKNOWN;
pub const VALUENAME_ENTERPRISE_DEFINED_CLASS_ID = VALUENAME.ENTERPRISE_DEFINED_CLASS_ID;
pub const VALUENAME_BUILT_IN_LIST = VALUENAME.BUILT_IN_LIST;

pub const WLDP_WINDOWS_LOCKDOWN_MODE = enum(i32) {
    UNLOCKED = 0,
    TRIAL = 1,
    LOCKED = 2,
    MAX = 3,
};
pub const WLDP_WINDOWS_LOCKDOWN_MODE_UNLOCKED = WLDP_WINDOWS_LOCKDOWN_MODE.UNLOCKED;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_TRIAL = WLDP_WINDOWS_LOCKDOWN_MODE.TRIAL;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_LOCKED = WLDP_WINDOWS_LOCKDOWN_MODE.LOCKED;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_MAX = WLDP_WINDOWS_LOCKDOWN_MODE.MAX;

pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION = enum(i32) {
    NONE = 0,
    NOUNLOCK = 1,
    NOUNLOCK_PERMANENT = 2,
    MAX = 3,
};
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NONE = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NONE;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NOUNLOCK = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NOUNLOCK;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NOUNLOCK_PERMANENT = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NOUNLOCK_PERMANENT;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_MAX = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.MAX;

pub const WLDP_POLICY_SETTING = enum(i32) {
    E = 1000,
};
pub const WLDP_POLICY_SETTING_AV_PERF_MODE = WLDP_POLICY_SETTING.E;

pub const WLDP_HOST_INFORMATION = extern struct {
    dwRevision: u32,
    dwHostId: WLDP_HOST_ID,
    szSource: ?[*:0]const u16,
    hSource: ?HANDLE,
};

pub const WLDP_DEVICE_SECURITY_INFORMATION = extern struct {
    UnlockIdSize: u32,
    UnlockId: ?*u8,
    ManufacturerIDLength: u32,
    ManufacturerID: ?PWSTR,
};

pub const PWLDP_SETDYNAMICCODETRUST_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hFileHandle: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hFileHandle: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_ISDYNAMICCODEPOLICYENABLED_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pbEnabled: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pbEnabled: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_QUERYDYNAMICODETRUST_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        fileHandle: ?HANDLE,
        // TODO: what to do with BytesParamIndex 2?
        baseImage: ?*anyopaque,
        imageSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        fileHandle: ?HANDLE,
        // TODO: what to do with BytesParamIndex 2?
        baseImage: ?*anyopaque,
        imageSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_QUERYWINDOWSLOCKDOWNMODE_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lockdownMode: ?*WLDP_WINDOWS_LOCKDOWN_MODE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        lockdownMode: ?*WLDP_WINDOWS_LOCKDOWN_MODE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_QUERYDEVICESECURITYINFORMATION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        information: ?[*]WLDP_DEVICE_SECURITY_INFORMATION,
        informationLength: u32,
        returnLength: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        information: ?[*]WLDP_DEVICE_SECURITY_INFORMATION,
        informationLength: u32,
        returnLength: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        LockdownRestriction: ?*WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        LockdownRestriction: ?*WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        LockdownRestriction: WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        LockdownRestriction: WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_ISAPPAPPROVEDBYPOLICY_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        PackageFamilyName: ?[*:0]const u16,
        PackageVersion: u64,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        PackageFamilyName: ?[*:0]const u16,
        PackageVersion: u64,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_QUERYPOLICYSETTINGENABLED_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Setting: WLDP_POLICY_SETTING,
        Enabled: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Setting: WLDP_POLICY_SETTING,
        Enabled: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_QUERYPOLICYSETTINGENABLED2_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Setting: ?[*:0]const u16,
        Enabled: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Setting: ?[*:0]const u16,
        Enabled: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_ISWCOSPRODUCTIONCONFIGURATION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        IsProductionConfiguration: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        IsProductionConfiguration: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_RESETWCOSPRODUCTIONCONFIGURATION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_ISPRODUCTIONCONFIGURATION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        IsProductionConfiguration: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        IsProductionConfiguration: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PWLDP_RESETPRODUCTIONCONFIGURATION_API = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

const CLSID_DefaultBrowserSyncSettings_Value = Guid.initString("3ac83423-3112-4aa6-9b5b-1feb23d0c5f9");
pub const CLSID_DefaultBrowserSyncSettings = &CLSID_DefaultBrowserSyncSettings_Value;

const IID_IDefaultBrowserSyncSettings_Value = Guid.initString("7a27faad-5ae6-4255-9030-c530936292e3");
pub const IID_IDefaultBrowserSyncSettings = &IID_IDefaultBrowserSyncSettings_Value;
pub const IDefaultBrowserSyncSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDefaultBrowserSyncSettings,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDefaultBrowserSyncSettings,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDefaultBrowserSyncSettings_IsEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDefaultBrowserSyncSettings.VTable, self.vtable).IsEnabled(@ptrCast(*const IDefaultBrowserSyncSettings, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DELAYLOAD_PROC_DESCRIPTOR = extern struct {
    ImportDescribedByName: u32,
    Description: extern union {
        Name: ?[*:0]const u8,
        Ordinal: u32,
    },
};


pub const PDELAYLOAD_FAILURE_DLL_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        NotificationReason: u32,
        DelayloadInfo: ?*DELAYLOAD_INFO,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn(
        NotificationReason: u32,
        DelayloadInfo: ?*DELAYLOAD_INFO,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
} ;

const IID_IDeleteBrowsingHistory_Value = Guid.initString("cf38ed4b-2be7-4461-8b5e-9a466dc82ae3");
pub const IID_IDeleteBrowsingHistory = &IID_IDeleteBrowsingHistory_Value;
pub const IDeleteBrowsingHistory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteBrowsingHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDeleteBrowsingHistory,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDeleteBrowsingHistory,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeleteBrowsingHistory_DeleteBrowsingHistory(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeleteBrowsingHistory.VTable, self.vtable).DeleteBrowsingHistory(@ptrCast(*const IDeleteBrowsingHistory, self), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


pub const tcp_request_query_information_ex32_xp = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ID: TDIObjectID,
        Context: [4]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const DELAYLOAD_INFO = switch(@import("../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Size: u32,
        DelayloadDescriptor: ?*IMAGE_DELAYLOAD_DESCRIPTOR,
        ThunkAddress: ?*IMAGE_THUNK_DATA64,
        TargetDllName: ?[*:0]const u8,
        TargetApiDescriptor: DELAYLOAD_PROC_DESCRIPTOR,
        TargetModuleBase: ?*anyopaque,
        Unused: ?*anyopaque,
        LastError: u32,
    },
    .X86 => extern struct {
        Size: u32,
        DelayloadDescriptor: ?*IMAGE_DELAYLOAD_DESCRIPTOR,
        ThunkAddress: ?*IMAGE_THUNK_DATA32,
        TargetDllName: ?[*:0]const u8,
        TargetApiDescriptor: DELAYLOAD_PROC_DESCRIPTOR,
        TargetModuleBase: ?*anyopaque,
        Unused: ?*anyopaque,
        LastError: u32,
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (227)
//--------------------------------------------------------------------------------
pub extern "ntdll" fn RtlGetReturnAddressHijackTarget(
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "ntdll" fn RtlRaiseCustomSystemEventTrigger(
    TriggerConfig: ?*CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-apiquery-l2-1-0" fn IsApiSetImplemented(
    Contract: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn QueryThreadCycleTime(
    ThreadHandle: ?HANDLE,
    CycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn QueryProcessCycleTime(
    ProcessHandle: ?HANDLE,
    CycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn QueryIdleProcessorCycleTime(
    BufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 0?
    ProcessorIdleCycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn QueryIdleProcessorCycleTimeEx(
    Group: u16,
    BufferLength: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    ProcessorIdleCycleTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryInterruptTimePrecise(
    lpInterruptTimePrecise: ?*u64,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryUnbiasedInterruptTimePrecise(
    lpUnbiasedInterruptTimePrecise: ?*u64,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryInterruptTime(
    lpInterruptTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn QueryUnbiasedInterruptTime(
    UnbiasedTime: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-realtime-l1-1-2" fn QueryAuxiliaryCounterFrequency(
    lpAuxiliaryCounterFrequency: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-realtime-l1-1-2" fn ConvertAuxiliaryCounterToPerformanceCounter(
    ullAuxiliaryCounterValue: u64,
    lpPerformanceCounterValue: ?*u64,
    lpConversionError: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "api-ms-win-core-realtime-l1-1-2" fn ConvertPerformanceCounterToAuxiliaryCounter(
    ullPerformanceCounterValue: u64,
    lpAuxiliaryCounterValue: ?*u64,
    lpConversionError: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "kernel32" fn GlobalCompact(
    dwMinFree: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "kernel32" fn GlobalFix(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn GlobalUnfix(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn GlobalWire(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn GlobalUnWire(
    hMem: isize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn LocalShrink(
    hMem: isize,
    cbNewSize: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "kernel32" fn LocalCompact(
    uMinFree: u32,
) callconv(@import("std").os.windows.WINAPI) usize;

pub extern "kernel32" fn SetEnvironmentStringsA(
    NewEnvironment: ?[*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn SetHandleCount(
    uNumber: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "kernel32" fn RequestDeviceWakeup(
    hDevice: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn CancelDeviceWakeupRequest(
    hDevice: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn SetMessageWaitingIndicator(
    hMsgIndicator: ?HANDLE,
    ulMsgCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn MulDiv(
    nNumber: i32,
    nNumerator: i32,
    nDenominator: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetSystemRegistryQuota(
    pdwQuotaAllowed: ?*u32,
    pdwQuotaUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn FileTimeToDosDateTime(
    lpFileTime: ?*const FILETIME,
    lpFatDate: ?*u16,
    lpFatTime: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn DosDateTimeToFileTime(
    wFatDate: u16,
    wFatTime: u16,
    lpFileTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn _lopen(
    lpPathName: ?[*:0]const u8,
    iReadWrite: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "kernel32" fn _lcreat(
    lpPathName: ?[*:0]const u8,
    iAttribute: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "kernel32" fn _lread(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*anyopaque,
    uBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "kernel32" fn _lwrite(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?[*]const u8,
    uBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "kernel32" fn _hread(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?*anyopaque,
    lBytes: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "kernel32" fn _hwrite(
    hFile: i32,
    // TODO: what to do with BytesParamIndex 2?
    lpBuffer: ?[*]const u8,
    lBytes: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "kernel32" fn _lclose(
    hFile: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "kernel32" fn _llseek(
    hFile: i32,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SignalObjectAndWait(
    hObjectToSignal: ?HANDLE,
    hObjectToWaitOn: ?HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "kernel32" fn OpenMutexA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "kernel32" fn OpenSemaphoreA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "kernel32" fn CreateWaitableTimerA(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    lpTimerName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "kernel32" fn OpenWaitableTimerA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpTimerName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "kernel32" fn CreateWaitableTimerExA(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    lpTimerName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFirmwareEnvironmentVariableA(
    lpName: ?[*:0]const u8,
    lpGuid: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetFirmwareEnvironmentVariableW(
    lpName: ?[*:0]const u16,
    lpGuid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetFirmwareEnvironmentVariableExA(
    lpName: ?[*:0]const u8,
    lpGuid: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    nSize: u32,
    pdwAttribubutes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn GetFirmwareEnvironmentVariableExW(
    lpName: ?[*:0]const u16,
    lpGuid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pBuffer: ?*anyopaque,
    nSize: u32,
    pdwAttribubutes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFirmwareEnvironmentVariableA(
    lpName: ?[*:0]const u8,
    lpGuid: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*anyopaque,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn SetFirmwareEnvironmentVariableW(
    lpName: ?[*:0]const u16,
    lpGuid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*anyopaque,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn SetFirmwareEnvironmentVariableExA(
    lpName: ?[*:0]const u8,
    lpGuid: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*anyopaque,
    nSize: u32,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn SetFirmwareEnvironmentVariableExW(
    lpName: ?[*:0]const u16,
    lpGuid: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    pValue: ?*anyopaque,
    nSize: u32,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "kernel32" fn IsNativeVhdBoot(
    NativeVhdBoot: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetProfileIntA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    nDefault: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetProfileIntW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    nDefault: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpDefault: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpDefault: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WriteProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WriteProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetProfileSectionA(
    lpAppName: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetProfileSectionW(
    lpAppName: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WriteProfileSectionA(
    lpAppName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WriteProfileSectionW(
    lpAppName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileIntA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    nDefault: i32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileIntW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    nDefault: i32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpDefault: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpDefault: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WritePrivateProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WritePrivateProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileSectionA(
    lpAppName: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileSectionW(
    lpAppName: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WritePrivateProfileSectionA(
    lpAppName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WritePrivateProfileSectionW(
    lpAppName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileSectionNamesA(
    lpszReturnBuffer: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileSectionNamesW(
    lpszReturnBuffer: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileStructA(
    lpszSection: ?[*:0]const u8,
    lpszKey: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*anyopaque,
    uSizeStruct: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetPrivateProfileStructW(
    lpszSection: ?[*:0]const u16,
    lpszKey: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*anyopaque,
    uSizeStruct: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WritePrivateProfileStructA(
    lpszSection: ?[*:0]const u8,
    lpszKey: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*anyopaque,
    uSizeStruct: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn WritePrivateProfileStructW(
    lpszSection: ?[*:0]const u16,
    lpszKey: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    lpStruct: ?*anyopaque,
    uSizeStruct: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn IsBadHugeReadPtr(
    lp: ?*const anyopaque,
    ucb: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn IsBadHugeWritePtr(
    lp: ?*anyopaque,
    ucb: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetComputerNameA(
    lpBuffer: ?[*:0]u8,
    nSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn GetComputerNameW(
    lpBuffer: ?[*:0]u16,
    nSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn DnsHostnameToComputerNameA(
    Hostname: ?[*:0]const u8,
    ComputerName: ?[*:0]u8,
    nSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "kernel32" fn DnsHostnameToComputerNameW(
    Hostname: ?[*:0]const u16,
    ComputerName: ?[*:0]u16,
    nSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "advapi32" fn GetUserNameA(
    lpBuffer: ?[*:0]u8,
    pcbBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "advapi32" fn GetUserNameW(
    lpBuffer: ?[*:0]u16,
    pcbBuffer: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "advapi32" fn IsTokenUntrusted(
    TokenHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn CancelTimerQueueTimer(
    TimerQueue: ?HANDLE,
    Timer: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "advapi32" fn GetCurrentHwProfileA(
    lpHwProfileInfo: ?*HW_PROFILE_INFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "advapi32" fn GetCurrentHwProfileW(
    lpHwProfileInfo: ?*HW_PROFILE_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn ReplacePartitionUnit(
    TargetPartition: ?PWSTR,
    SparePartition: ?PWSTR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86, .X64 => struct {

pub extern "kernel32" fn GetThreadEnabledXStateFeatures(
) callconv(@import("std").os.windows.WINAPI) u64;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X86, .X64 => struct {

pub extern "kernel32" fn EnableProcessOptionalXStateFeatures(
    Features: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "api-ms-win-core-backgroundtask-l1-1-0" fn RaiseCustomSystemEventTrigger(
    CustomSystemEventTriggerConfig: ?*CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_lstrcmpW(
    String1: ?*u16,
    String2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_lstrcmpiW(
    String1: ?*u16,
    String2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_lstrlenW(
    String: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_wcschr(
    String: ?*u16,
    Character: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_wcscpy(
    Destination: ?*u16,
    Source: ?*u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_wcsicmp(
    String1: ?*u16,
    String2: ?*u16,
) callconv(@import("std").os.windows.WINAPI) i32;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_wcslen(
    String: ?*u16,
) callconv(@import("std").os.windows.WINAPI) usize;

}, else => struct { } };

pub usingnamespace switch (@import("../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn uaw_wcsrchr(
    String: ?*u16,
    Character: u16,
) callconv(@import("std").os.windows.WINAPI) ?*u16;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn NtClose(
    Handle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtOpenFile(
    FileHandle: ?*?HANDLE,
    DesiredAccess: u32,
    ObjectAttributes: ?*OBJECT_ATTRIBUTES,
    IoStatusBlock: ?*IO_STATUS_BLOCK,
    ShareAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtRenameKey(
    KeyHandle: ?HANDLE,
    NewName: ?*UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtNotifyChangeMultipleKeys(
    MasterKeyHandle: ?HANDLE,
    Count: u32,
    SubordinateObjects: ?[*]OBJECT_ATTRIBUTES,
    Event: ?HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*anyopaque,
    IoStatusBlock: ?*IO_STATUS_BLOCK,
    CompletionFilter: u32,
    WatchTree: BOOLEAN,
    // TODO: what to do with BytesParamIndex 10?
    Buffer: ?*anyopaque,
    BufferSize: u32,
    Asynchronous: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQueryMultipleValueKey(
    KeyHandle: ?HANDLE,
    ValueEntries: [*]KEY_VALUE_ENTRY,
    EntryCount: u32,
    // TODO: what to do with BytesParamIndex 4?
    ValueBuffer: ?*anyopaque,
    BufferLength: ?*u32,
    RequiredBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtSetInformationKey(
    KeyHandle: ?HANDLE,
    KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    KeySetInformation: ?*anyopaque,
    KeySetInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn NtDeviceIoControlFile(
    FileHandle: ?HANDLE,
    Event: ?HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*anyopaque,
    IoStatusBlock: ?*IO_STATUS_BLOCK,
    IoControlCode: u32,
    InputBuffer: ?*anyopaque,
    InputBufferLength: u32,
    OutputBuffer: ?*anyopaque,
    OutputBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn NtWaitForSingleObject(
    Handle: ?HANDLE,
    Alertable: BOOLEAN,
    Timeout: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlIsNameLegalDOS8Dot3(
    Name: ?*UNICODE_STRING,
    OemName: ?*STRING,
    NameContainsSpaces: ?*BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

pub extern "ntdll" fn NtQueryObject(
    Handle: ?HANDLE,
    ObjectInformationClass: OBJECT_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    ObjectInformation: ?*anyopaque,
    ObjectInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQuerySystemInformation(
    SystemInformationClass: SYSTEM_INFORMATION_CLASS,
    SystemInformation: ?*anyopaque,
    SystemInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQuerySystemTime(
    SystemTime: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQueryTimerResolution(
    MaximumTime: ?*u32,
    MinimumTime: ?*u32,
    CurrentTime: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlLocalTimeToSystemTime(
    LocalTime: ?*LARGE_INTEGER,
    SystemTime: ?*LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlTimeToSecondsSince1970(
    Time: ?*LARGE_INTEGER,
    ElapsedSeconds: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlFreeAnsiString(
    AnsiString: ?*STRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlFreeUnicodeString(
    UnicodeString: ?*UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlFreeOemString(
    OemString: ?*STRING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitString(
    DestinationString: ?*STRING,
    SourceString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitStringEx(
    DestinationString: ?*STRING,
    SourceString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlInitAnsiString(
    DestinationString: ?*STRING,
    SourceString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitAnsiStringEx(
    DestinationString: ?*STRING,
    SourceString: ?*i8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlInitUnicodeString(
    DestinationString: ?*UNICODE_STRING,
    SourceString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlAnsiStringToUnicodeString(
    DestinationString: ?*UNICODE_STRING,
    SourceString: ?*STRING,
    AllocateDestinationString: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlUnicodeStringToAnsiString(
    DestinationString: ?*STRING,
    SourceString: ?*UNICODE_STRING,
    AllocateDestinationString: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlUnicodeStringToOemString(
    DestinationString: ?*STRING,
    SourceString: ?*UNICODE_STRING,
    AllocateDestinationString: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlUnicodeToMultiByteSize(
    BytesInMultiByteString: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    UnicodeString: ?[*]u16,
    BytesInUnicodeString: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ntdll" fn RtlCharToInteger(
    String: ?*i8,
    Base: u32,
    Value: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlUniform(
    Seed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn GetFeatureEnabledState(
    featureId: u32,
    changeTime: FEATURE_CHANGE_TIME,
) callconv(@import("std").os.windows.WINAPI) FEATURE_ENABLED_STATE;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn RecordFeatureUsage(
    featureId: u32,
    kind: u32,
    addend: u32,
    originName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn RecordFeatureError(
    featureId: u32,
    @"error": ?*const FEATURE_ERROR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn SubscribeFeatureStateChangeNotification(
    subscription: ?*FEATURE_STATE_CHANGE_SUBSCRIPTION,
    callback: ?PFEATURE_STATE_CHANGE_CALLBACK,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn UnsubscribeFeatureStateChangeNotification(
    subscription: FEATURE_STATE_CHANGE_SUBSCRIPTION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-1" fn GetFeatureVariant(
    featureId: u32,
    changeTime: FEATURE_CHANGE_TIME,
    payloadId: ?*u32,
    hasNotification: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "dciman32" fn DCIOpenProvider(
) callconv(@import("std").os.windows.WINAPI) ?HDC;

// TODO: this type is limited to platform 'windows5.0'
pub extern "dciman32" fn DCICloseProvider(
    hdc: ?HDC,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "dciman32" fn DCICreatePrimary(
    hdc: ?HDC,
    lplpSurface: ?*?*DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn DCICreateOffscreen(
    hdc: ?HDC,
    dwCompression: u32,
    dwRedMask: u32,
    dwGreenMask: u32,
    dwBlueMask: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwDCICaps: u32,
    dwBitCount: u32,
    lplpSurface: ?*?*DCIOFFSCREEN,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn DCICreateOverlay(
    hdc: ?HDC,
    lpOffscreenSurf: ?*anyopaque,
    lplpSurface: ?*?*DCIOVERLAY,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn DCIEnum(
    hdc: ?HDC,
    lprDst: ?*RECT,
    lprSrc: ?*RECT,
    lpFnCallback: ?*anyopaque,
    lpContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn DCISetSrcDestClip(
    pdci: ?*DCIOFFSCREEN,
    srcrc: ?*RECT,
    destrc: ?*RECT,
    prd: ?*RGNDATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn WinWatchOpen(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) ?HWINWATCH;

pub extern "dciman32" fn WinWatchClose(
    hWW: ?HWINWATCH,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dciman32" fn WinWatchGetClipList(
    hWW: ?HWINWATCH,
    prc: ?*RECT,
    size: u32,
    prd: ?*RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dciman32" fn WinWatchDidStatusChange(
    hWW: ?HWINWATCH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dciman32" fn GetWindowRegionData(
    hwnd: ?HWND,
    size: u32,
    prd: ?*RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dciman32" fn GetDCRegionData(
    hdc: ?HDC,
    size: u32,
    prd: ?*RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dciman32" fn WinWatchNotify(
    hWW: ?HWINWATCH,
    NotifyCallback: ?WINWATCHNOTIFYPROC,
    NotifyParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "dciman32" fn DCIEndAccess(
    pdci: ?*DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "dciman32" fn DCIBeginAccess(
    pdci: ?*DCISURFACEINFO,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "dciman32" fn DCIDestroy(
    pdci: ?*DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dciman32" fn DCIDraw(
    pdci: ?*DCIOFFSCREEN,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn DCISetClipList(
    pdci: ?*DCIOFFSCREEN,
    prd: ?*RGNDATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "dciman32" fn DCISetDestination(
    pdci: ?*DCIOFFSCREEN,
    dst: ?*RECT,
    src: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-dx-d3dkmt-l1-1-0" fn GdiEntry13(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "advpack" fn RunSetupCommandA(
    hWnd: ?HWND,
    szCmdName: ?[*:0]const u8,
    szInfSection: ?[*:0]const u8,
    szDir: ?[*:0]const u8,
    lpszTitle: ?[*:0]const u8,
    phEXE: ?*?HANDLE,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RunSetupCommandW(
    hWnd: ?HWND,
    szCmdName: ?[*:0]const u16,
    szInfSection: ?[*:0]const u16,
    szDir: ?[*:0]const u16,
    lpszTitle: ?[*:0]const u16,
    phEXE: ?*?HANDLE,
    dwFlags: u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn NeedRebootInit(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "advpack" fn NeedReboot(
    dwRebootCheck: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "advpack" fn RebootCheckOnInstallA(
    hwnd: ?HWND,
    pszINF: ?[*:0]const u8,
    pszSec: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RebootCheckOnInstallW(
    hwnd: ?HWND,
    pszINF: ?[*:0]const u16,
    pszSec: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn TranslateInfStringA(
    pszInfFilename: ?[*:0]const u8,
    pszInstallSection: ?[*:0]const u8,
    pszTranslateSection: ?[*:0]const u8,
    pszTranslateKey: ?[*:0]const u8,
    pszBuffer: ?[*:0]u8,
    cchBuffer: u32,
    pdwRequiredSize: ?*u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn TranslateInfStringW(
    pszInfFilename: ?[*:0]const u16,
    pszInstallSection: ?[*:0]const u16,
    pszTranslateSection: ?[*:0]const u16,
    pszTranslateKey: ?[*:0]const u16,
    pszBuffer: ?[*:0]u16,
    cchBuffer: u32,
    pdwRequiredSize: ?*u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "advpack" fn RegInstallA(
    hmod: ?HINSTANCE,
    pszSection: ?[*:0]const u8,
    pstTable: ?*const STRTABLEA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "advpack" fn RegInstallW(
    hmod: ?HINSTANCE,
    pszSection: ?[*:0]const u16,
    pstTable: ?*const STRTABLEW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn LaunchINFSectionExW(
    hwnd: ?HWND,
    hInstance: ?HINSTANCE,
    pszParms: ?PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn ExecuteCabA(
    hwnd: ?HWND,
    pCab: ?*CABINFOA,
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn ExecuteCabW(
    hwnd: ?HWND,
    pCab: ?*CABINFOW,
    pReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn AdvInstallFileA(
    hwnd: ?HWND,
    lpszSourceDir: ?[*:0]const u8,
    lpszSourceFile: ?[*:0]const u8,
    lpszDestDir: ?[*:0]const u8,
    lpszDestFile: ?[*:0]const u8,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn AdvInstallFileW(
    hwnd: ?HWND,
    lpszSourceDir: ?[*:0]const u16,
    lpszSourceFile: ?[*:0]const u16,
    lpszDestDir: ?[*:0]const u16,
    lpszDestFile: ?[*:0]const u16,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RegSaveRestoreA(
    hWnd: ?HWND,
    pszTitleString: ?[*:0]const u8,
    hkBckupKey: ?HKEY,
    pcszRootKey: ?[*:0]const u8,
    pcszSubKey: ?[*:0]const u8,
    pcszValueName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RegSaveRestoreW(
    hWnd: ?HWND,
    pszTitleString: ?[*:0]const u16,
    hkBckupKey: ?HKEY,
    pcszRootKey: ?[*:0]const u16,
    pcszSubKey: ?[*:0]const u16,
    pcszValueName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RegSaveRestoreOnINFA(
    hWnd: ?HWND,
    pszTitle: ?[*:0]const u8,
    pszINF: ?[*:0]const u8,
    pszSection: ?[*:0]const u8,
    hHKLMBackKey: ?HKEY,
    hHKCUBackKey: ?HKEY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RegSaveRestoreOnINFW(
    hWnd: ?HWND,
    pszTitle: ?[*:0]const u16,
    pszINF: ?[*:0]const u16,
    pszSection: ?[*:0]const u16,
    hHKLMBackKey: ?HKEY,
    hHKCUBackKey: ?HKEY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RegRestoreAllA(
    hWnd: ?HWND,
    pszTitleString: ?[*:0]const u8,
    hkBckupKey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn RegRestoreAllW(
    hWnd: ?HWND,
    pszTitleString: ?[*:0]const u16,
    hkBckupKey: ?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn FileSaveRestoreW(
    hDlg: ?HWND,
    lpFileList: ?PWSTR,
    lpDir: ?[*:0]const u16,
    lpBaseName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn FileSaveRestoreOnINFA(
    hWnd: ?HWND,
    pszTitle: ?[*:0]const u8,
    pszINF: ?[*:0]const u8,
    pszSection: ?[*:0]const u8,
    pszBackupDir: ?[*:0]const u8,
    pszBaseBackupFile: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn FileSaveRestoreOnINFW(
    hWnd: ?HWND,
    pszTitle: ?[*:0]const u16,
    pszINF: ?[*:0]const u16,
    pszSection: ?[*:0]const u16,
    pszBackupDir: ?[*:0]const u16,
    pszBaseBackupFile: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn AddDelBackupEntryA(
    lpcszFileList: ?[*:0]const u8,
    lpcszBackupDir: ?[*:0]const u8,
    lpcszBaseName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn AddDelBackupEntryW(
    lpcszFileList: ?[*:0]const u16,
    lpcszBackupDir: ?[*:0]const u16,
    lpcszBaseName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn FileSaveMarkNotExistA(
    lpFileList: ?[*:0]const u8,
    lpDir: ?[*:0]const u8,
    lpBaseName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn FileSaveMarkNotExistW(
    lpFileList: ?[*:0]const u16,
    lpDir: ?[*:0]const u16,
    lpBaseName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn GetVersionFromFileA(
    lpszFilename: ?[*:0]const u8,
    pdwMSVer: ?*u32,
    pdwLSVer: ?*u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn GetVersionFromFileW(
    lpszFilename: ?[*:0]const u16,
    pdwMSVer: ?*u32,
    pdwLSVer: ?*u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn GetVersionFromFileExA(
    lpszFilename: ?[*:0]const u8,
    pdwMSVer: ?*u32,
    pdwLSVer: ?*u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn GetVersionFromFileExW(
    lpszFilename: ?[*:0]const u16,
    pdwMSVer: ?*u32,
    pdwLSVer: ?*u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn IsNTAdmin(
    dwReserved: u32,
    lpdwReserved: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "advpack" fn DelNodeA(
    pszFileOrDirName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn DelNodeW(
    pszFileOrDirName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn DelNodeRunDLL32W(
    hwnd: ?HWND,
    hInstance: ?HINSTANCE,
    pszParms: ?PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn OpenINFEngineA(
    pszInfFilename: ?[*:0]const u8,
    pszInstallSection: ?[*:0]const u8,
    dwFlags: u32,
    phInf: ?*?*anyopaque,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn OpenINFEngineW(
    pszInfFilename: ?[*:0]const u16,
    pszInstallSection: ?[*:0]const u16,
    dwFlags: u32,
    phInf: ?*?*anyopaque,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn TranslateInfStringExA(
    hInf: ?*anyopaque,
    pszInfFilename: ?[*:0]const u8,
    pszTranslateSection: ?[*:0]const u8,
    pszTranslateKey: ?[*:0]const u8,
    pszBuffer: [*:0]u8,
    dwBufferSize: u32,
    pdwRequiredSize: ?*u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn TranslateInfStringExW(
    hInf: ?*anyopaque,
    pszInfFilename: ?[*:0]const u16,
    pszTranslateSection: ?[*:0]const u16,
    pszTranslateKey: ?[*:0]const u16,
    pszBuffer: [*:0]u16,
    dwBufferSize: u32,
    pdwRequiredSize: ?*u32,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn CloseINFEngine(
    hInf: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn ExtractFilesA(
    pszCabName: ?[*:0]const u8,
    pszExpandDir: ?[*:0]const u8,
    dwFlags: u32,
    pszFileList: ?[*:0]const u8,
    lpReserved: ?*anyopaque,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn ExtractFilesW(
    pszCabName: ?[*:0]const u16,
    pszExpandDir: ?[*:0]const u16,
    dwFlags: u32,
    pszFileList: ?[*:0]const u16,
    lpReserved: ?*anyopaque,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn LaunchINFSectionW(
    hwndOwner: ?HWND,
    hInstance: ?HINSTANCE,
    pszParams: ?PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "advpack" fn UserInstStubWrapperA(
    hwnd: ?HWND,
    hInstance: ?HINSTANCE,
    pszParms: ?[*:0]const u8,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn UserInstStubWrapperW(
    hwnd: ?HWND,
    hInstance: ?HINSTANCE,
    pszParms: ?[*:0]const u16,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn UserUnInstStubWrapperA(
    hwnd: ?HWND,
    hInstance: ?HINSTANCE,
    pszParms: ?[*:0]const u8,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn UserUnInstStubWrapperW(
    hwnd: ?HWND,
    hInstance: ?HINSTANCE,
    pszParms: ?[*:0]const u16,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn SetPerUserSecValuesA(
    pPerUser: ?*PERUSERSECTIONA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "advpack" fn SetPerUserSecValuesW(
    pPerUser: ?*PERUSERSECTIONW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "user32" fn SendIMEMessageExA(
    param0: ?HWND,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "user32" fn SendIMEMessageExW(
    param0: ?HWND,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "user32" fn IMPGetIMEA(
    param0: ?HWND,
    param1: ?*IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn IMPGetIMEW(
    param0: ?HWND,
    param1: ?*IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn IMPQueryIMEA(
    param0: ?*IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn IMPQueryIMEW(
    param0: ?*IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn IMPSetIMEA(
    param0: ?HWND,
    param1: ?*IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn IMPSetIMEW(
    param0: ?HWND,
    param1: ?*IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn WINNLSGetIMEHotkey(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "user32" fn WINNLSEnableIME(
    param0: ?HWND,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "user32" fn WINNLSGetEnableStatus(
    param0: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "apphelp" fn ApphelpCheckShellObject(
    ObjectCLSID: ?*const Guid,
    bShimIfNecessary: BOOL,
    pullFlags: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "wldp" fn WldpGetLockdownPolicy(
    hostInformation: ?*WLDP_HOST_INFORMATION,
    lockdownState: ?*u32,
    lockdownFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wldp" fn WldpIsClassInApprovedList(
    classID: ?*const Guid,
    hostInformation: ?*WLDP_HOST_INFORMATION,
    isApproved: ?*BOOL,
    optionalFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wldp" fn WldpSetDynamicCodeTrust(
    fileHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wldp" fn WldpIsDynamicCodePolicyEnabled(
    isEnabled: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wldp" fn WldpQueryDynamicCodeTrust(
    fileHandle: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    baseImage: ?*anyopaque,
    imageSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "wldp" fn WldpQueryDeviceSecurityInformation(
    information: ?[*]WLDP_DEVICE_SECURITY_INFORMATION,
    informationLength: u32,
    returnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (52)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const HW_PROFILE_INFO = thismodule.HW_PROFILE_INFOA;
        pub const STRENTRY = thismodule.STRENTRYA;
        pub const STRTABLE = thismodule.STRTABLEA;
        pub const CABINFO = thismodule.CABINFOA;
        pub const PERUSERSECTION = thismodule.PERUSERSECTIONA;
        pub const IMEPRO = thismodule.IMEPROA;
        pub const GetFirmwareEnvironmentVariable = thismodule.GetFirmwareEnvironmentVariableA;
        pub const GetFirmwareEnvironmentVariableEx = thismodule.GetFirmwareEnvironmentVariableExA;
        pub const SetFirmwareEnvironmentVariable = thismodule.SetFirmwareEnvironmentVariableA;
        pub const SetFirmwareEnvironmentVariableEx = thismodule.SetFirmwareEnvironmentVariableExA;
        pub const GetProfileInt = thismodule.GetProfileIntA;
        pub const GetProfileString = thismodule.GetProfileStringA;
        pub const WriteProfileString = thismodule.WriteProfileStringA;
        pub const GetProfileSection = thismodule.GetProfileSectionA;
        pub const WriteProfileSection = thismodule.WriteProfileSectionA;
        pub const GetPrivateProfileInt = thismodule.GetPrivateProfileIntA;
        pub const GetPrivateProfileString = thismodule.GetPrivateProfileStringA;
        pub const WritePrivateProfileString = thismodule.WritePrivateProfileStringA;
        pub const GetPrivateProfileSection = thismodule.GetPrivateProfileSectionA;
        pub const WritePrivateProfileSection = thismodule.WritePrivateProfileSectionA;
        pub const GetPrivateProfileSectionNames = thismodule.GetPrivateProfileSectionNamesA;
        pub const GetPrivateProfileStruct = thismodule.GetPrivateProfileStructA;
        pub const WritePrivateProfileStruct = thismodule.WritePrivateProfileStructA;
        pub const GetComputerName = thismodule.GetComputerNameA;
        pub const DnsHostnameToComputerName = thismodule.DnsHostnameToComputerNameA;
        pub const GetUserName = thismodule.GetUserNameA;
        pub const GetCurrentHwProfile = thismodule.GetCurrentHwProfileA;
        pub const RunSetupCommand = thismodule.RunSetupCommandA;
        pub const RebootCheckOnInstall = thismodule.RebootCheckOnInstallA;
        pub const TranslateInfString = thismodule.TranslateInfStringA;
        pub const RegInstall = thismodule.RegInstallA;
        pub const ExecuteCab = thismodule.ExecuteCabA;
        pub const AdvInstallFile = thismodule.AdvInstallFileA;
        pub const RegSaveRestore = thismodule.RegSaveRestoreA;
        pub const RegSaveRestoreOnINF = thismodule.RegSaveRestoreOnINFA;
        pub const RegRestoreAll = thismodule.RegRestoreAllA;
        pub const FileSaveRestoreOnINF = thismodule.FileSaveRestoreOnINFA;
        pub const AddDelBackupEntry = thismodule.AddDelBackupEntryA;
        pub const FileSaveMarkNotExist = thismodule.FileSaveMarkNotExistA;
        pub const GetVersionFromFile = thismodule.GetVersionFromFileA;
        pub const GetVersionFromFileEx = thismodule.GetVersionFromFileExA;
        pub const DelNode = thismodule.DelNodeA;
        pub const OpenINFEngine = thismodule.OpenINFEngineA;
        pub const TranslateInfStringEx = thismodule.TranslateInfStringExA;
        pub const ExtractFiles = thismodule.ExtractFilesA;
        pub const UserInstStubWrapper = thismodule.UserInstStubWrapperA;
        pub const UserUnInstStubWrapper = thismodule.UserUnInstStubWrapperA;
        pub const SetPerUserSecValues = thismodule.SetPerUserSecValuesA;
        pub const SendIMEMessageEx = thismodule.SendIMEMessageExA;
        pub const IMPGetIME = thismodule.IMPGetIMEA;
        pub const IMPQueryIME = thismodule.IMPQueryIMEA;
        pub const IMPSetIME = thismodule.IMPSetIMEA;
    },
    .wide => struct {
        pub const HW_PROFILE_INFO = thismodule.HW_PROFILE_INFOW;
        pub const STRENTRY = thismodule.STRENTRYW;
        pub const STRTABLE = thismodule.STRTABLEW;
        pub const CABINFO = thismodule.CABINFOW;
        pub const PERUSERSECTION = thismodule.PERUSERSECTIONW;
        pub const IMEPRO = thismodule.IMEPROW;
        pub const GetFirmwareEnvironmentVariable = thismodule.GetFirmwareEnvironmentVariableW;
        pub const GetFirmwareEnvironmentVariableEx = thismodule.GetFirmwareEnvironmentVariableExW;
        pub const SetFirmwareEnvironmentVariable = thismodule.SetFirmwareEnvironmentVariableW;
        pub const SetFirmwareEnvironmentVariableEx = thismodule.SetFirmwareEnvironmentVariableExW;
        pub const GetProfileInt = thismodule.GetProfileIntW;
        pub const GetProfileString = thismodule.GetProfileStringW;
        pub const WriteProfileString = thismodule.WriteProfileStringW;
        pub const GetProfileSection = thismodule.GetProfileSectionW;
        pub const WriteProfileSection = thismodule.WriteProfileSectionW;
        pub const GetPrivateProfileInt = thismodule.GetPrivateProfileIntW;
        pub const GetPrivateProfileString = thismodule.GetPrivateProfileStringW;
        pub const WritePrivateProfileString = thismodule.WritePrivateProfileStringW;
        pub const GetPrivateProfileSection = thismodule.GetPrivateProfileSectionW;
        pub const WritePrivateProfileSection = thismodule.WritePrivateProfileSectionW;
        pub const GetPrivateProfileSectionNames = thismodule.GetPrivateProfileSectionNamesW;
        pub const GetPrivateProfileStruct = thismodule.GetPrivateProfileStructW;
        pub const WritePrivateProfileStruct = thismodule.WritePrivateProfileStructW;
        pub const GetComputerName = thismodule.GetComputerNameW;
        pub const DnsHostnameToComputerName = thismodule.DnsHostnameToComputerNameW;
        pub const GetUserName = thismodule.GetUserNameW;
        pub const GetCurrentHwProfile = thismodule.GetCurrentHwProfileW;
        pub const RunSetupCommand = thismodule.RunSetupCommandW;
        pub const RebootCheckOnInstall = thismodule.RebootCheckOnInstallW;
        pub const TranslateInfString = thismodule.TranslateInfStringW;
        pub const RegInstall = thismodule.RegInstallW;
        pub const ExecuteCab = thismodule.ExecuteCabW;
        pub const AdvInstallFile = thismodule.AdvInstallFileW;
        pub const RegSaveRestore = thismodule.RegSaveRestoreW;
        pub const RegSaveRestoreOnINF = thismodule.RegSaveRestoreOnINFW;
        pub const RegRestoreAll = thismodule.RegRestoreAllW;
        pub const FileSaveRestoreOnINF = thismodule.FileSaveRestoreOnINFW;
        pub const AddDelBackupEntry = thismodule.AddDelBackupEntryW;
        pub const FileSaveMarkNotExist = thismodule.FileSaveMarkNotExistW;
        pub const GetVersionFromFile = thismodule.GetVersionFromFileW;
        pub const GetVersionFromFileEx = thismodule.GetVersionFromFileExW;
        pub const DelNode = thismodule.DelNodeW;
        pub const OpenINFEngine = thismodule.OpenINFEngineW;
        pub const TranslateInfStringEx = thismodule.TranslateInfStringExW;
        pub const ExtractFiles = thismodule.ExtractFilesW;
        pub const UserInstStubWrapper = thismodule.UserInstStubWrapperW;
        pub const UserUnInstStubWrapper = thismodule.UserUnInstStubWrapperW;
        pub const SetPerUserSecValues = thismodule.SetPerUserSecValuesW;
        pub const SendIMEMessageEx = thismodule.SendIMEMessageExW;
        pub const IMPGetIME = thismodule.IMPGetIMEW;
        pub const IMPQueryIME = thismodule.IMPQueryIMEW;
        pub const IMPSetIME = thismodule.IMPSetIMEW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const HW_PROFILE_INFO = *opaque{};
        pub const STRENTRY = *opaque{};
        pub const STRTABLE = *opaque{};
        pub const CABINFO = *opaque{};
        pub const PERUSERSECTION = *opaque{};
        pub const IMEPRO = *opaque{};
        pub const GetFirmwareEnvironmentVariable = *opaque{};
        pub const GetFirmwareEnvironmentVariableEx = *opaque{};
        pub const SetFirmwareEnvironmentVariable = *opaque{};
        pub const SetFirmwareEnvironmentVariableEx = *opaque{};
        pub const GetProfileInt = *opaque{};
        pub const GetProfileString = *opaque{};
        pub const WriteProfileString = *opaque{};
        pub const GetProfileSection = *opaque{};
        pub const WriteProfileSection = *opaque{};
        pub const GetPrivateProfileInt = *opaque{};
        pub const GetPrivateProfileString = *opaque{};
        pub const WritePrivateProfileString = *opaque{};
        pub const GetPrivateProfileSection = *opaque{};
        pub const WritePrivateProfileSection = *opaque{};
        pub const GetPrivateProfileSectionNames = *opaque{};
        pub const GetPrivateProfileStruct = *opaque{};
        pub const WritePrivateProfileStruct = *opaque{};
        pub const GetComputerName = *opaque{};
        pub const DnsHostnameToComputerName = *opaque{};
        pub const GetUserName = *opaque{};
        pub const GetCurrentHwProfile = *opaque{};
        pub const RunSetupCommand = *opaque{};
        pub const RebootCheckOnInstall = *opaque{};
        pub const TranslateInfString = *opaque{};
        pub const RegInstall = *opaque{};
        pub const ExecuteCab = *opaque{};
        pub const AdvInstallFile = *opaque{};
        pub const RegSaveRestore = *opaque{};
        pub const RegSaveRestoreOnINF = *opaque{};
        pub const RegRestoreAll = *opaque{};
        pub const FileSaveRestoreOnINF = *opaque{};
        pub const AddDelBackupEntry = *opaque{};
        pub const FileSaveMarkNotExist = *opaque{};
        pub const GetVersionFromFile = *opaque{};
        pub const GetVersionFromFileEx = *opaque{};
        pub const DelNode = *opaque{};
        pub const OpenINFEngine = *opaque{};
        pub const TranslateInfStringEx = *opaque{};
        pub const ExtractFiles = *opaque{};
        pub const UserInstStubWrapper = *opaque{};
        pub const UserUnInstStubWrapper = *opaque{};
        pub const SetPerUserSecValues = *opaque{};
        pub const SendIMEMessageEx = *opaque{};
        pub const IMPGetIME = *opaque{};
        pub const IMPQueryIME = *opaque{};
        pub const IMPSetIME = *opaque{};
    } else struct {
        pub const HW_PROFILE_INFO = @compileError("'HW_PROFILE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const STRENTRY = @compileError("'STRENTRY' requires that UNICODE be set to true or false in the root module");
        pub const STRTABLE = @compileError("'STRTABLE' requires that UNICODE be set to true or false in the root module");
        pub const CABINFO = @compileError("'CABINFO' requires that UNICODE be set to true or false in the root module");
        pub const PERUSERSECTION = @compileError("'PERUSERSECTION' requires that UNICODE be set to true or false in the root module");
        pub const IMEPRO = @compileError("'IMEPRO' requires that UNICODE be set to true or false in the root module");
        pub const GetFirmwareEnvironmentVariable = @compileError("'GetFirmwareEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const GetFirmwareEnvironmentVariableEx = @compileError("'GetFirmwareEnvironmentVariableEx' requires that UNICODE be set to true or false in the root module");
        pub const SetFirmwareEnvironmentVariable = @compileError("'SetFirmwareEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const SetFirmwareEnvironmentVariableEx = @compileError("'SetFirmwareEnvironmentVariableEx' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileInt = @compileError("'GetProfileInt' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileString = @compileError("'GetProfileString' requires that UNICODE be set to true or false in the root module");
        pub const WriteProfileString = @compileError("'WriteProfileString' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileSection = @compileError("'GetProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const WriteProfileSection = @compileError("'WriteProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileInt = @compileError("'GetPrivateProfileInt' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileString = @compileError("'GetPrivateProfileString' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileString = @compileError("'WritePrivateProfileString' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileSection = @compileError("'GetPrivateProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileSection = @compileError("'WritePrivateProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileSectionNames = @compileError("'GetPrivateProfileSectionNames' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileStruct = @compileError("'GetPrivateProfileStruct' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileStruct = @compileError("'WritePrivateProfileStruct' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerName = @compileError("'GetComputerName' requires that UNICODE be set to true or false in the root module");
        pub const DnsHostnameToComputerName = @compileError("'DnsHostnameToComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetUserName = @compileError("'GetUserName' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrentHwProfile = @compileError("'GetCurrentHwProfile' requires that UNICODE be set to true or false in the root module");
        pub const RunSetupCommand = @compileError("'RunSetupCommand' requires that UNICODE be set to true or false in the root module");
        pub const RebootCheckOnInstall = @compileError("'RebootCheckOnInstall' requires that UNICODE be set to true or false in the root module");
        pub const TranslateInfString = @compileError("'TranslateInfString' requires that UNICODE be set to true or false in the root module");
        pub const RegInstall = @compileError("'RegInstall' requires that UNICODE be set to true or false in the root module");
        pub const ExecuteCab = @compileError("'ExecuteCab' requires that UNICODE be set to true or false in the root module");
        pub const AdvInstallFile = @compileError("'AdvInstallFile' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveRestore = @compileError("'RegSaveRestore' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveRestoreOnINF = @compileError("'RegSaveRestoreOnINF' requires that UNICODE be set to true or false in the root module");
        pub const RegRestoreAll = @compileError("'RegRestoreAll' requires that UNICODE be set to true or false in the root module");
        pub const FileSaveRestoreOnINF = @compileError("'FileSaveRestoreOnINF' requires that UNICODE be set to true or false in the root module");
        pub const AddDelBackupEntry = @compileError("'AddDelBackupEntry' requires that UNICODE be set to true or false in the root module");
        pub const FileSaveMarkNotExist = @compileError("'FileSaveMarkNotExist' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionFromFile = @compileError("'GetVersionFromFile' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionFromFileEx = @compileError("'GetVersionFromFileEx' requires that UNICODE be set to true or false in the root module");
        pub const DelNode = @compileError("'DelNode' requires that UNICODE be set to true or false in the root module");
        pub const OpenINFEngine = @compileError("'OpenINFEngine' requires that UNICODE be set to true or false in the root module");
        pub const TranslateInfStringEx = @compileError("'TranslateInfStringEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractFiles = @compileError("'ExtractFiles' requires that UNICODE be set to true or false in the root module");
        pub const UserInstStubWrapper = @compileError("'UserInstStubWrapper' requires that UNICODE be set to true or false in the root module");
        pub const UserUnInstStubWrapper = @compileError("'UserUnInstStubWrapper' requires that UNICODE be set to true or false in the root module");
        pub const SetPerUserSecValues = @compileError("'SetPerUserSecValues' requires that UNICODE be set to true or false in the root module");
        pub const SendIMEMessageEx = @compileError("'SendIMEMessageEx' requires that UNICODE be set to true or false in the root module");
        pub const IMPGetIME = @compileError("'IMPGetIME' requires that UNICODE be set to true or false in the root module");
        pub const IMPQueryIME = @compileError("'IMPQueryIME' requires that UNICODE be set to true or false in the root module");
        pub const IMPSetIME = @compileError("'IMPSetIME' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (27)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const BOOL = @import("../foundation.zig").BOOL;
const BOOLEAN = @import("../foundation.zig").BOOLEAN;
const BSTR = @import("../foundation.zig").BSTR;
const CHAR = @import("../foundation.zig").CHAR;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HDC = @import("../graphics/gdi.zig").HDC;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const LIST_ENTRY = @import("../system/kernel.zig").LIST_ENTRY;
const LPARAM = @import("../foundation.zig").LPARAM;
const LRESULT = @import("../foundation.zig").LRESULT;
const NTSTATUS = @import("../foundation.zig").NTSTATUS;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const RECT = @import("../foundation.zig").RECT;
const RGNDATA = @import("../graphics/gdi.zig").RGNDATA;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const SECURITY_ATTRIBUTES = @import("../security.zig").SECURITY_ATTRIBUTES;
const STRING = @import("../system/kernel.zig").STRING;
const UNICODE_STRING = @import("../foundation.zig").UNICODE_STRING;
const WPARAM = @import("../foundation.zig").WPARAM;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PFIBER_CALLOUT_ROUTINE")) { _ = PFIBER_CALLOUT_ROUTINE; }
    if (@hasDecl(@This(), "PQUERYACTCTXW_FUNC")) { _ = PQUERYACTCTXW_FUNC; }
    if (@hasDecl(@This(), "APPLICATION_RECOVERY_CALLBACK")) { _ = APPLICATION_RECOVERY_CALLBACK; }
    if (@hasDecl(@This(), "PIO_APC_ROUTINE")) { _ = PIO_APC_ROUTINE; }
    if (@hasDecl(@This(), "PWINSTATIONQUERYINFORMATIONW")) { _ = PWINSTATIONQUERYINFORMATIONW; }
    if (@hasDecl(@This(), "PFEATURE_STATE_CHANGE_CALLBACK")) { _ = PFEATURE_STATE_CHANGE_CALLBACK; }
    if (@hasDecl(@This(), "ENUM_CALLBACK")) { _ = ENUM_CALLBACK; }
    if (@hasDecl(@This(), "WINWATCHNOTIFYPROC")) { _ = WINWATCHNOTIFYPROC; }
    if (@hasDecl(@This(), "REGINSTALLA")) { _ = REGINSTALLA; }
    if (@hasDecl(@This(), "PWLDP_SETDYNAMICCODETRUST_API")) { _ = PWLDP_SETDYNAMICCODETRUST_API; }
    if (@hasDecl(@This(), "PWLDP_ISDYNAMICCODEPOLICYENABLED_API")) { _ = PWLDP_ISDYNAMICCODEPOLICYENABLED_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYDYNAMICODETRUST_API")) { _ = PWLDP_QUERYDYNAMICODETRUST_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYWINDOWSLOCKDOWNMODE_API")) { _ = PWLDP_QUERYWINDOWSLOCKDOWNMODE_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYDEVICESECURITYINFORMATION_API")) { _ = PWLDP_QUERYDEVICESECURITYINFORMATION_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API")) { _ = PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API; }
    if (@hasDecl(@This(), "PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API")) { _ = PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API; }
    if (@hasDecl(@This(), "PWLDP_ISAPPAPPROVEDBYPOLICY_API")) { _ = PWLDP_ISAPPAPPROVEDBYPOLICY_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYPOLICYSETTINGENABLED_API")) { _ = PWLDP_QUERYPOLICYSETTINGENABLED_API; }
    if (@hasDecl(@This(), "PWLDP_QUERYPOLICYSETTINGENABLED2_API")) { _ = PWLDP_QUERYPOLICYSETTINGENABLED2_API; }
    if (@hasDecl(@This(), "PWLDP_ISWCOSPRODUCTIONCONFIGURATION_API")) { _ = PWLDP_ISWCOSPRODUCTIONCONFIGURATION_API; }
    if (@hasDecl(@This(), "PWLDP_RESETWCOSPRODUCTIONCONFIGURATION_API")) { _ = PWLDP_RESETWCOSPRODUCTIONCONFIGURATION_API; }
    if (@hasDecl(@This(), "PWLDP_ISPRODUCTIONCONFIGURATION_API")) { _ = PWLDP_ISPRODUCTIONCONFIGURATION_API; }
    if (@hasDecl(@This(), "PWLDP_RESETPRODUCTIONCONFIGURATION_API")) { _ = PWLDP_RESETPRODUCTIONCONFIGURATION_API; }
    if (@hasDecl(@This(), "PDELAYLOAD_FAILURE_DLL_CALLBACK")) { _ = PDELAYLOAD_FAILURE_DLL_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = @field(@This(), decl.name);
        }
    }
}
