//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (613)
//--------------------------------------------------------------------------------
pub const UIALL = @as(u32, 32768);
pub const LOGTOKEN_TYPE_MASK = @as(u32, 3);
pub const LOGTOKEN_UNSPECIFIED = @as(u32, 0);
pub const LOGTOKEN_NO_LOG = @as(u32, 1);
pub const LOGTOKEN_SETUPAPI_APPLOG = @as(u32, 2);
pub const LOGTOKEN_SETUPAPI_DEVLOG = @as(u32, 3);
pub const TXTLOG_SETUPAPI_DEVLOG = @as(u32, 1);
pub const TXTLOG_SETUPAPI_CMDLINE = @as(u32, 2);
pub const TXTLOG_SETUPAPI_BITS = @as(u32, 3);
pub const TXTLOG_ERROR = @as(u32, 1);
pub const TXTLOG_WARNING = @as(u32, 2);
pub const TXTLOG_SYSTEM_STATE_CHANGE = @as(u32, 3);
pub const TXTLOG_SUMMARY = @as(u32, 4);
pub const TXTLOG_DETAILS = @as(u32, 5);
pub const TXTLOG_VERBOSE = @as(u32, 6);
pub const TXTLOG_VERY_VERBOSE = @as(u32, 7);
pub const TXTLOG_RESERVED_FLAGS = @as(u32, 65520);
pub const TXTLOG_TIMESTAMP = @as(u32, 65536);
pub const TXTLOG_DEPTH_INCR = @as(u32, 131072);
pub const TXTLOG_DEPTH_DECR = @as(u32, 262144);
pub const TXTLOG_TAB_1 = @as(u32, 524288);
pub const TXTLOG_FLUSH_FILE = @as(u32, 1048576);
pub const TXTLOG_DEVINST = @as(u32, 1);
pub const TXTLOG_INF = @as(u32, 2);
pub const TXTLOG_FILEQ = @as(u32, 4);
pub const TXTLOG_COPYFILES = @as(u32, 8);
pub const TXTLOG_SIGVERIF = @as(u32, 32);
pub const TXTLOG_BACKUP = @as(u32, 128);
pub const TXTLOG_UI = @as(u32, 256);
pub const TXTLOG_UTIL = @as(u32, 512);
pub const TXTLOG_INFDB = @as(u32, 1024);
pub const TXTLOG_DRVSETUP = @as(u32, 4194304);
pub const TXTLOG_POLICY = @as(u32, 8388608);
pub const TXTLOG_NEWDEV = @as(u32, 16777216);
pub const TXTLOG_UMPNPMGR = @as(u32, 33554432);
pub const TXTLOG_DRIVER_STORE = @as(u32, 67108864);
pub const TXTLOG_SETUP = @as(u32, 134217728);
pub const TXTLOG_CMI = @as(u32, 268435456);
pub const TXTLOG_DEVMGR = @as(u32, 536870912);
pub const TXTLOG_INSTALLER = @as(u32, 1073741824);
pub const TXTLOG_VENDOR = @as(u32, 2147483648);
pub const CLSID_EvalCom2 = Guid.initString("6e5e1910-8053-4660-b795-6b612e29bc58");
pub const _WIN32_MSM = @as(u32, 100);
pub const LIBID_MsmMergeTypeLib = Guid.initString("0adda82f-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge2 = Guid.initString("f94985d5-29f9-4743-9805-99bc3f35b678");
pub const _WIN32_MSI = @as(u32, 500);
pub const MAX_GUID_CHARS = @as(u32, 38);
pub const MAX_FEATURE_CHARS = @as(u32, 38);
pub const INSTALLPROPERTY_PACKAGENAME = "PackageName";
pub const INSTALLPROPERTY_TRANSFORMS = "Transforms";
pub const INSTALLPROPERTY_LANGUAGE = "Language";
pub const INSTALLPROPERTY_PRODUCTNAME = "ProductName";
pub const INSTALLPROPERTY_ASSIGNMENTTYPE = "AssignmentType";
pub const INSTALLPROPERTY_INSTANCETYPE = "InstanceType";
pub const INSTALLPROPERTY_AUTHORIZED_LUA_APP = "AuthorizedLUAApp";
pub const INSTALLPROPERTY_PACKAGECODE = "PackageCode";
pub const INSTALLPROPERTY_VERSION = "Version";
pub const INSTALLPROPERTY_PRODUCTICON = "ProductIcon";
pub const INSTALLPROPERTY_INSTALLEDPRODUCTNAME = "InstalledProductName";
pub const INSTALLPROPERTY_VERSIONSTRING = "VersionString";
pub const INSTALLPROPERTY_HELPLINK = "HelpLink";
pub const INSTALLPROPERTY_HELPTELEPHONE = "HelpTelephone";
pub const INSTALLPROPERTY_INSTALLLOCATION = "InstallLocation";
pub const INSTALLPROPERTY_INSTALLSOURCE = "InstallSource";
pub const INSTALLPROPERTY_INSTALLDATE = "InstallDate";
pub const INSTALLPROPERTY_PUBLISHER = "Publisher";
pub const INSTALLPROPERTY_LOCALPACKAGE = "LocalPackage";
pub const INSTALLPROPERTY_URLINFOABOUT = "URLInfoAbout";
pub const INSTALLPROPERTY_URLUPDATEINFO = "URLUpdateInfo";
pub const INSTALLPROPERTY_VERSIONMINOR = "VersionMinor";
pub const INSTALLPROPERTY_VERSIONMAJOR = "VersionMajor";
pub const INSTALLPROPERTY_PRODUCTID = "ProductID";
pub const INSTALLPROPERTY_REGCOMPANY = "RegCompany";
pub const INSTALLPROPERTY_REGOWNER = "RegOwner";
pub const INSTALLPROPERTY_INSTALLEDLANGUAGE = "InstalledLanguage";
pub const INSTALLPROPERTY_UNINSTALLABLE = "Uninstallable";
pub const INSTALLPROPERTY_PRODUCTSTATE = "State";
pub const INSTALLPROPERTY_PATCHSTATE = "State";
pub const INSTALLPROPERTY_PATCHTYPE = "PatchType";
pub const INSTALLPROPERTY_LUAENABLED = "LUAEnabled";
pub const INSTALLPROPERTY_DISPLAYNAME = "DisplayName";
pub const INSTALLPROPERTY_MOREINFOURL = "MoreInfoURL";
pub const INSTALLPROPERTY_LASTUSEDSOURCE = "LastUsedSource";
pub const INSTALLPROPERTY_LASTUSEDTYPE = "LastUsedType";
pub const INSTALLPROPERTY_MEDIAPACKAGEPATH = "MediaPackagePath";
pub const INSTALLPROPERTY_DISKPROMPT = "DiskPrompt";
pub const MSI_INVALID_HASH_IS_FATAL = @as(u32, 1);
pub const ERROR_ROLLBACK_DISABLED = @as(u32, 1653);
pub const MSI_NULL_INTEGER = @as(u32, 2147483648);
pub const INSTALLMESSAGE_TYPEMASK = @as(i32, -16777216);
pub const STREAM_FORMAT_COMPLIB_MODULE = @as(u32, 0);
pub const STREAM_FORMAT_COMPLIB_MANIFEST = @as(u32, 1);
pub const STREAM_FORMAT_WIN32_MODULE = @as(u32, 2);
pub const STREAM_FORMAT_WIN32_MANIFEST = @as(u32, 4);
pub const IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_INSTALLED = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_PAYLOADRESIDENT = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED = @as(u32, 1);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED = @as(u32, 3);
pub const FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID = Guid.initString("8cedc215-ac4b-488b-93c0-a50a49cb2fb8");
pub const FUSION_REFCOUNT_FILEPATH_GUID = Guid.initString("b02f9d65-fb77-4f7a-afa5-b391309f11c9");
pub const FUSION_REFCOUNT_OPAQUE_STRING_GUID = Guid.initString("2ec93463-b0c3-45e1-8364-327e96aea856");
pub const SFC_DISABLE_NORMAL = @as(u32, 0);
pub const SFC_DISABLE_ASK = @as(u32, 1);
pub const SFC_DISABLE_ONCE = @as(u32, 2);
pub const SFC_DISABLE_SETUP = @as(u32, 3);
pub const SFC_DISABLE_NOPOPUPS = @as(u32, 4);
pub const SFC_SCAN_NORMAL = @as(u32, 0);
pub const SFC_SCAN_ALWAYS = @as(u32, 1);
pub const SFC_SCAN_ONCE = @as(u32, 2);
pub const SFC_SCAN_IMMEDIATE = @as(u32, 3);
pub const SFC_QUOTA_DEFAULT = @as(u32, 50);
pub const SFC_IDLE_TRIGGER = "WFP_IDLE_TRIGGER";
pub const IPROPNAME_PRODUCTNAME = "ProductName";
pub const IPROPNAME_PRODUCTCODE = "ProductCode";
pub const IPROPNAME_PRODUCTVERSION = "ProductVersion";
pub const IPROPNAME_INSTALLLANGUAGE = "ProductLanguage";
pub const IPROPNAME_MANUFACTURER = "Manufacturer";
pub const IPROPNAME_UPGRADECODE = "UpgradeCode";
pub const IPROPNAME_PIDTEMPLATE = "PIDTemplate";
pub const IPROPNAME_DISKPROMPT = "DiskPrompt";
pub const IPROPNAME_LEFTUNIT = "LeftUnit";
pub const IPROPNAME_ADMIN_PROPERTIES = "AdminProperties";
pub const IPROPNAME_DEFAULTUIFONT = "DefaultUIFont";
pub const IPROPNAME_ALLOWEDPROPERTIES = "SecureCustomProperties";
pub const IPROPNAME_ENABLEUSERCONTROL = "EnableUserControl";
pub const IPROPNAME_HIDDEN_PROPERTIES = "MsiHiddenProperties";
pub const IPROPNAME_USERNAME = "USERNAME";
pub const IPROPNAME_COMPANYNAME = "COMPANYNAME";
pub const IPROPNAME_PIDKEY = "PIDKEY";
pub const IPROPNAME_PATCH = "PATCH";
pub const IPROPNAME_MSIPATCHREMOVE = "MSIPATCHREMOVE";
pub const IPROPNAME_TARGETDIR = "TARGETDIR";
pub const IPROPNAME_ACTION = "ACTION";
pub const IPROPNAME_LIMITUI = "LIMITUI";
pub const IPROPNAME_LOGACTION = "LOGACTION";
pub const IPROPNAME_ALLUSERS = "ALLUSERS";
pub const IPROPNAME_INSTALLLEVEL = "INSTALLLEVEL";
pub const IPROPNAME_REBOOT = "REBOOT";
pub const IPROPNAME_REBOOTPROMPT = "REBOOTPROMPT";
pub const IPROPNAME_EXECUTEMODE = "EXECUTEMODE";
pub const IPROPVALUE_EXECUTEMODE_NONE = "NONE";
pub const IPROPVALUE_EXECUTEMODE_SCRIPT = "SCRIPT";
pub const IPROPNAME_EXECUTEACTION = "EXECUTEACTION";
pub const IPROPNAME_SOURCELIST = "SOURCELIST";
pub const IPROPNAME_ROOTDRIVE = "ROOTDRIVE";
pub const IPROPNAME_TRANSFORMS = "TRANSFORMS";
pub const IPROPNAME_TRANSFORMSATSOURCE = "TRANSFORMSATSOURCE";
pub const IPROPNAME_TRANSFORMSSECURE = "TRANSFORMSSECURE";
pub const IPROPNAME_SEQUENCE = "SEQUENCE";
pub const IPROPNAME_SHORTFILENAMES = "SHORTFILENAMES";
pub const IPROPNAME_PRIMARYFOLDER = "PRIMARYFOLDER";
pub const IPROPNAME_AFTERREBOOT = "AFTERREBOOT";
pub const IPROPNAME_NOCOMPANYNAME = "NOCOMPANYNAME";
pub const IPROPNAME_NOUSERNAME = "NOUSERNAME";
pub const IPROPNAME_DISABLEROLLBACK = "DISABLEROLLBACK";
pub const IPROPNAME_AVAILABLEFREEREG = "AVAILABLEFREEREG";
pub const IPROPNAME_DISABLEADVTSHORTCUTS = "DISABLEADVTSHORTCUTS";
pub const IPROPNAME_PATCHNEWPACKAGECODE = "PATCHNEWPACKAGECODE";
pub const IPROPNAME_PATCHNEWSUMMARYSUBJECT = "PATCHNEWSUMMARYSUBJECT";
pub const IPROPNAME_PATCHNEWSUMMARYCOMMENTS = "PATCHNEWSUMMARYCOMMENTS";
pub const IPROPNAME_PRODUCTLANGUAGE = "PRODUCTLANGUAGE";
pub const IPROPNAME_CHECKCRCS = "MSICHECKCRCS";
pub const IPROPNAME_MSINODISABLEMEDIA = "MSINODISABLEMEDIA";
pub const IPROPNAME_CARRYINGNDP = "CARRYINGNDP";
pub const IPROPVALUE__CARRYINGNDP_URTREINSTALL = "URTREINSTALL";
pub const IPROPVALUE__CARRYINGNDP_URTUPGRADE = "URTUPGRADE";
pub const IPROPNAME_ENFORCE_UPGRADE_COMPONENT_RULES = "MSIENFORCEUPGRADECOMPONENTRULES";
pub const IPROPNAME_MSINEWINSTANCE = "MSINEWINSTANCE";
pub const IPROPNAME_MSIINSTANCEGUID = "MSIINSTANCEGUID";
pub const IPROPNAME_MSIPACKAGEDOWNLOADLOCALCOPY = "MSIPACKAGEDOWNLOADLOCALCOPY";
pub const IPROPNAME_MSIPATCHDOWNLOADLOCALCOPY = "MSIPATCHDOWNLOADLOCALCOPY";
pub const IPROPNAME_MSIDISABLELUAPATCHING = "MSIDISABLELUAPATCHING";
pub const IPROPNAME_MSILOGGINGMODE = "MsiLogging";
pub const IPROPNAME_MSILOGFILELOCATION = "MsiLogFileLocation";
pub const IPROPNAME_MSI_RM_CONTROL = "MSIRESTARTMANAGERCONTROL";
pub const IPROPVALUE_MSI_RM_CONTROL_DISABLE = "Disable";
pub const IPROPVALUE_MSI_RM_CONTROL_DISABLESHUTDOWN = "DisableShutdown";
pub const IPROPNAME_MSI_RM_SESSION_KEY = "MsiRestartManagerSessionKey";
pub const IPROPNAME_MSI_REBOOT_PENDING = "MsiSystemRebootPending";
pub const IPROPNAME_MSI_RM_SHUTDOWN = "MSIRMSHUTDOWN";
pub const IPROPNAME_MSI_RM_DISABLE_RESTART = "MSIDISABLERMRESTART";
pub const IPROPNAME_MSI_UAC_DEPLOYMENT_COMPLIANT = "MSIDEPLOYMENTCOMPLIANT";
pub const IPROPNAME_MSI_USE_REAL_ADMIN_DETECTION = "MSIUSEREALADMINDETECTION";
pub const IPROPNAME_MSI_UNINSTALL_SUPERSEDED_COMPONENTS = "MSIUNINSTALLSUPERSEDEDCOMPONENTS";
pub const IPROPNAME_MSIDISABLEEEUI = "MSIDISABLEEEUI";
pub const IPROPNAME_MSI_FASTINSTALL = "MSIFASTINSTALL";
pub const IPROPNAME_INSTALLPERUSER = "MSIINSTALLPERUSER";
pub const IPROPNAME_INTERNALINSTALLEDPERUSER = "MSIINTERNALINSTALLEDPERUSER";
pub const IPROPNAME_ARPAUTHORIZEDCDFPREFIX = "ARPAUTHORIZEDCDFPREFIX";
pub const IPROPNAME_ARPCOMMENTS = "ARPCOMMENTS";
pub const IPROPNAME_ARPCONTACT = "ARPCONTACT";
pub const IPROPNAME_ARPHELPLINK = "ARPHELPLINK";
pub const IPROPNAME_ARPHELPTELEPHONE = "ARPHELPTELEPHONE";
pub const IPROPNAME_ARPINSTALLLOCATION = "ARPINSTALLLOCATION";
pub const IPROPNAME_ARPNOMODIFY = "ARPNOMODIFY";
pub const IPROPNAME_ARPNOREMOVE = "ARPNOREMOVE";
pub const IPROPNAME_ARPNOREPAIR = "ARPNOREPAIR";
pub const IPROPNAME_ARPREADME = "ARPREADME";
pub const IPROPNAME_ARPSIZE = "ARPSIZE";
pub const IPROPNAME_ARPSYSTEMCOMPONENT = "ARPSYSTEMCOMPONENT";
pub const IPROPNAME_ARPURLINFOABOUT = "ARPURLINFOABOUT";
pub const IPROPNAME_ARPURLUPDATEINFO = "ARPURLUPDATEINFO";
pub const IPROPNAME_ARPPRODUCTICON = "ARPPRODUCTICON";
pub const IPROPNAME_ARPSETTINGSIDENTIFIER = "MSIARPSETTINGSIDENTIFIER";
pub const IPROPNAME_ARPSHIMFLAGS = "SHIMFLAGS";
pub const IPROPNAME_ARPSHIMVERSIONNT = "SHIMVERSIONNT";
pub const IPROPNAME_ARPSHIMSERVICEPACKLEVEL = "SHIMSERVICEPACKLEVEL";
pub const IPROPNAME_INSTALLED = "Installed";
pub const IPROPNAME_PRODUCTSTATE = "ProductState";
pub const IPROPNAME_PRESELECTED = "Preselected";
pub const IPROPNAME_RESUME = "RESUME";
pub const IPROPNAME_UPDATESTARTED = "UpdateStarted";
pub const IPROPNAME_PRODUCTID = "ProductID";
pub const IPROPNAME_OUTOFDISKSPACE = "OutOfDiskSpace";
pub const IPROPNAME_OUTOFNORBDISKSPACE = "OutOfNoRbDiskSpace";
pub const IPROPNAME_COSTINGCOMPLETE = "CostingComplete";
pub const IPROPNAME_SOURCEDIR = "SourceDir";
pub const IPROPNAME_REPLACEDINUSEFILES = "ReplacedInUseFiles";
pub const IPROPNAME_PRIMARYFOLDER_PATH = "PrimaryVolumePath";
pub const IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE = "PrimaryVolumeSpaceAvailable";
pub const IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED = "PrimaryVolumeSpaceRequired";
pub const IPROPNAME_PRIMARYFOLDER_SPACEREMAINING = "PrimaryVolumeSpaceRemaining";
pub const IPROPNAME_ISADMINPACKAGE = "IsAdminPackage";
pub const IPROPNAME_ROLLBACKDISABLED = "RollbackDisabled";
pub const IPROPNAME_RESTRICTEDUSERCONTROL = "RestrictedUserControl";
pub const IPROPNAME_SOURCERESONLY = "MsiUISourceResOnly";
pub const IPROPNAME_HIDECANCEL = "MsiUIHideCancel";
pub const IPROPNAME_PROGRESSONLY = "MsiUIProgressOnly";
pub const IPROPNAME_UACONLY = "MsiUIUACOnly";
pub const IPROPNAME_TIME = "Time";
pub const IPROPNAME_DATE = "Date";
pub const IPROPNAME_DATETIME = "DateTime";
pub const IPROPNAME_ARM = "Arm";
pub const IPROPNAME_ARM64 = "Arm64";
pub const IPROPNAME_INTEL = "Intel";
pub const IPROPNAME_TEMPLATE_AMD64 = "AMD64";
pub const IPROPNAME_TEMPLATE_X64 = "x64";
pub const IPROPNAME_MSIAMD64 = "MsiAMD64";
pub const IPROPNAME_MSIX64 = "Msix64";
pub const IPROPNAME_INTEL64 = "Intel64";
pub const IPROPNAME_IA64 = "IA64";
pub const IPROPNAME_TEXTHEIGHT = "TextHeight";
pub const IPROPNAME_TEXTINTERNALLEADING = "TextInternalLeading";
pub const IPROPNAME_SCREENX = "ScreenX";
pub const IPROPNAME_SCREENY = "ScreenY";
pub const IPROPNAME_CAPTIONHEIGHT = "CaptionHeight";
pub const IPROPNAME_BORDERTOP = "BorderTop";
pub const IPROPNAME_BORDERSIDE = "BorderSide";
pub const IPROPNAME_COLORBITS = "ColorBits";
pub const IPROPNAME_PHYSICALMEMORY = "PhysicalMemory";
pub const IPROPNAME_VIRTUALMEMORY = "VirtualMemory";
pub const IPROPNAME_TEXTHEIGHT_CORRECTION = "TextHeightCorrection";
pub const IPROPNAME_MSITABLETPC = "MsiTabletPC";
pub const IPROPNAME_VERSIONNT = "VersionNT";
pub const IPROPNAME_VERSION9X = "Version9X";
pub const IPROPNAME_VERSIONNT64 = "VersionNT64";
pub const IPROPNAME_WINDOWSBUILD = "WindowsBuild";
pub const IPROPNAME_SERVICEPACKLEVEL = "ServicePackLevel";
pub const IPROPNAME_SERVICEPACKLEVELMINOR = "ServicePackLevelMinor";
pub const IPROPNAME_SHAREDWINDOWS = "SharedWindows";
pub const IPROPNAME_COMPUTERNAME = "ComputerName";
pub const IPROPNAME_SHELLADVTSUPPORT = "ShellAdvtSupport";
pub const IPROPNAME_OLEADVTSUPPORT = "OLEAdvtSupport";
pub const IPROPNAME_SYSTEMLANGUAGEID = "SystemLanguageID";
pub const IPROPNAME_TTCSUPPORT = "TTCSupport";
pub const IPROPNAME_TERMSERVER = "TerminalServer";
pub const IPROPNAME_REMOTEADMINTS = "RemoteAdminTS";
pub const IPROPNAME_REDIRECTEDDLLSUPPORT = "RedirectedDllSupport";
pub const IPROPNAME_NTPRODUCTTYPE = "MsiNTProductType";
pub const IPROPNAME_NTSUITEBACKOFFICE = "MsiNTSuiteBackOffice";
pub const IPROPNAME_NTSUITEDATACENTER = "MsiNTSuiteDataCenter";
pub const IPROPNAME_NTSUITEENTERPRISE = "MsiNTSuiteEnterprise";
pub const IPROPNAME_NTSUITESMALLBUSINESS = "MsiNTSuiteSmallBusiness";
pub const IPROPNAME_NTSUITESMALLBUSINESSRESTRICTED = "MsiNTSuiteSmallBusinessRestricted";
pub const IPROPNAME_NTSUITEPERSONAL = "MsiNTSuitePersonal";
pub const IPROPNAME_NTSUITEWEBSERVER = "MsiNTSuiteWebServer";
pub const IPROPNAME_NETASSEMBLYSUPPORT = "MsiNetAssemblySupport";
pub const IPROPNAME_WIN32ASSEMBLYSUPPORT = "MsiWin32AssemblySupport";
pub const IPROPNAME_LOGONUSER = "LogonUser";
pub const IPROPNAME_USERSID = "UserSID";
pub const IPROPNAME_ADMINUSER = "AdminUser";
pub const IPROPNAME_USERLANGUAGEID = "UserLanguageID";
pub const IPROPNAME_PRIVILEGED = "Privileged";
pub const IPROPNAME_RUNNINGELEVATED = "MsiRunningElevated";
pub const IPROPNAME_TRUEADMINUSER = "MsiTrueAdminUser";
pub const IPROPNAME_WINDOWS_FOLDER = "WindowsFolder";
pub const IPROPNAME_SYSTEM_FOLDER = "SystemFolder";
pub const IPROPNAME_SYSTEM16_FOLDER = "System16Folder";
pub const IPROPNAME_WINDOWS_VOLUME = "WindowsVolume";
pub const IPROPNAME_TEMP_FOLDER = "TempFolder";
pub const IPROPNAME_PROGRAMFILES_FOLDER = "ProgramFilesFolder";
pub const IPROPNAME_COMMONFILES_FOLDER = "CommonFilesFolder";
pub const IPROPNAME_SYSTEM64_FOLDER = "System64Folder";
pub const IPROPNAME_PROGRAMFILES64_FOLDER = "ProgramFiles64Folder";
pub const IPROPNAME_COMMONFILES64_FOLDER = "CommonFiles64Folder";
pub const IPROPNAME_STARTMENU_FOLDER = "StartMenuFolder";
pub const IPROPNAME_PROGRAMMENU_FOLDER = "ProgramMenuFolder";
pub const IPROPNAME_STARTUP_FOLDER = "StartupFolder";
pub const IPROPNAME_NETHOOD_FOLDER = "NetHoodFolder";
pub const IPROPNAME_PERSONAL_FOLDER = "PersonalFolder";
pub const IPROPNAME_SENDTO_FOLDER = "SendToFolder";
pub const IPROPNAME_DESKTOP_FOLDER = "DesktopFolder";
pub const IPROPNAME_TEMPLATE_FOLDER = "TemplateFolder";
pub const IPROPNAME_FONTS_FOLDER = "FontsFolder";
pub const IPROPNAME_FAVORITES_FOLDER = "FavoritesFolder";
pub const IPROPNAME_RECENT_FOLDER = "RecentFolder";
pub const IPROPNAME_APPDATA_FOLDER = "AppDataFolder";
pub const IPROPNAME_PRINTHOOD_FOLDER = "PrintHoodFolder";
pub const IPROPNAME_ADMINTOOLS_FOLDER = "AdminToolsFolder";
pub const IPROPNAME_COMMONAPPDATA_FOLDER = "CommonAppDataFolder";
pub const IPROPNAME_LOCALAPPDATA_FOLDER = "LocalAppDataFolder";
pub const IPROPNAME_MYPICTURES_FOLDER = "MyPicturesFolder";
pub const IPROPNAME_FEATUREADDLOCAL = "ADDLOCAL";
pub const IPROPNAME_FEATUREADDSOURCE = "ADDSOURCE";
pub const IPROPNAME_FEATUREADDDEFAULT = "ADDDEFAULT";
pub const IPROPNAME_FEATUREREMOVE = "REMOVE";
pub const IPROPNAME_FEATUREADVERTISE = "ADVERTISE";
pub const IPROPVALUE_FEATURE_ALL = "ALL";
pub const IPROPNAME_COMPONENTADDLOCAL = "COMPADDLOCAL";
pub const IPROPNAME_COMPONENTADDSOURCE = "COMPADDSOURCE";
pub const IPROPNAME_COMPONENTADDDEFAULT = "COMPADDDEFAULT";
pub const IPROPNAME_FILEADDLOCAL = "FILEADDLOCAL";
pub const IPROPNAME_FILEADDSOURCE = "FILEADDSOURCE";
pub const IPROPNAME_FILEADDDEFAULT = "FILEADDDEFAULT";
pub const IPROPNAME_REINSTALL = "REINSTALL";
pub const IPROPNAME_REINSTALLMODE = "REINSTALLMODE";
pub const IPROPNAME_PROMPTROLLBACKCOST = "PROMPTROLLBACKCOST";
pub const IPROPVALUE_RBCOST_PROMPT = "P";
pub const IPROPVALUE_RBCOST_SILENT = "D";
pub const IPROPVALUE_RBCOST_FAIL = "F";
pub const IPROPNAME_CUSTOMACTIONDATA = "CustomActionData";
pub const IACTIONNAME_INSTALL = "INSTALL";
pub const IACTIONNAME_ADVERTISE = "ADVERTISE";
pub const IACTIONNAME_ADMIN = "ADMIN";
pub const IACTIONNAME_SEQUENCE = "SEQUENCE";
pub const IACTIONNAME_COLLECTUSERINFO = "CollectUserInfo";
pub const IACTIONNAME_FIRSTRUN = "FirstRun";
pub const PID_TITLE = @as(u32, 2);
pub const PID_SUBJECT = @as(u32, 3);
pub const PID_AUTHOR = @as(u32, 4);
pub const PID_KEYWORDS = @as(u32, 5);
pub const PID_COMMENTS = @as(u32, 6);
pub const PID_TEMPLATE = @as(u32, 7);
pub const PID_LASTAUTHOR = @as(u32, 8);
pub const PID_REVNUMBER = @as(u32, 9);
pub const PID_EDITTIME = @as(u32, 10);
pub const PID_LASTPRINTED = @as(u32, 11);
pub const PID_CREATE_DTM = @as(u32, 12);
pub const PID_LASTSAVE_DTM = @as(u32, 13);
pub const PID_PAGECOUNT = @as(u32, 14);
pub const PID_WORDCOUNT = @as(u32, 15);
pub const PID_CHARCOUNT = @as(u32, 16);
pub const PID_THUMBNAIL = @as(u32, 17);
pub const PID_APPNAME = @as(u32, 18);
pub const PID_MSIVERSION = @as(u32, 14);
pub const PID_MSISOURCE = @as(u32, 15);
pub const PID_MSIRESTRICT = @as(u32, 16);
pub const PATCH_OPTION_USE_BEST = @as(u32, 0);
pub const PATCH_OPTION_USE_LZX_BEST = @as(u32, 3);
pub const PATCH_OPTION_USE_LZX_A = @as(u32, 1);
pub const PATCH_OPTION_USE_LZX_B = @as(u32, 2);
pub const PATCH_OPTION_USE_LZX_LARGE = @as(u32, 4);
pub const PATCH_OPTION_NO_BINDFIX = @as(u32, 65536);
pub const PATCH_OPTION_NO_LOCKFIX = @as(u32, 131072);
pub const PATCH_OPTION_NO_REBASE = @as(u32, 262144);
pub const PATCH_OPTION_FAIL_IF_SAME_FILE = @as(u32, 524288);
pub const PATCH_OPTION_FAIL_IF_BIGGER = @as(u32, 1048576);
pub const PATCH_OPTION_NO_CHECKSUM = @as(u32, 2097152);
pub const PATCH_OPTION_NO_RESTIMEFIX = @as(u32, 4194304);
pub const PATCH_OPTION_NO_TIMESTAMP = @as(u32, 8388608);
pub const PATCH_OPTION_SIGNATURE_MD5 = @as(u32, 16777216);
pub const PATCH_OPTION_INTERLEAVE_FILES = @as(u32, 1073741824);
pub const PATCH_OPTION_RESERVED1 = @as(u32, 2147483648);
pub const PATCH_OPTION_VALID_FLAGS = @as(u32, 3237937159);
pub const PATCH_SYMBOL_NO_IMAGEHLP = @as(u32, 1);
pub const PATCH_SYMBOL_NO_FAILURES = @as(u32, 2);
pub const PATCH_SYMBOL_UNDECORATED_TOO = @as(u32, 4);
pub const PATCH_SYMBOL_RESERVED1 = @as(u32, 2147483648);
pub const PATCH_TRANSFORM_PE_RESOURCE_2 = @as(u32, 256);
pub const PATCH_TRANSFORM_PE_IRELOC_2 = @as(u32, 512);
pub const APPLY_OPTION_FAIL_IF_EXACT = @as(u32, 1);
pub const APPLY_OPTION_FAIL_IF_CLOSE = @as(u32, 2);
pub const APPLY_OPTION_TEST_ONLY = @as(u32, 4);
pub const APPLY_OPTION_VALID_FLAGS = @as(u32, 7);
pub const ERROR_PATCH_ENCODE_FAILURE = @as(u32, 3222155521);
pub const ERROR_PATCH_INVALID_OPTIONS = @as(u32, 3222155522);
pub const ERROR_PATCH_SAME_FILE = @as(u32, 3222155523);
pub const ERROR_PATCH_RETAIN_RANGES_DIFFER = @as(u32, 3222155524);
pub const ERROR_PATCH_BIGGER_THAN_COMPRESSED = @as(u32, 3222155525);
pub const ERROR_PATCH_IMAGEHLP_FAILURE = @as(u32, 3222155526);
pub const ERROR_PATCH_DECODE_FAILURE = @as(u32, 3222159617);
pub const ERROR_PATCH_CORRUPT = @as(u32, 3222159618);
pub const ERROR_PATCH_NEWER_FORMAT = @as(u32, 3222159619);
pub const ERROR_PATCH_WRONG_FILE = @as(u32, 3222159620);
pub const ERROR_PATCH_NOT_NECESSARY = @as(u32, 3222159621);
pub const ERROR_PATCH_NOT_AVAILABLE = @as(u32, 3222159622);
pub const ERROR_PCW_BASE = @as(u32, 3222163713);
pub const ERROR_PCW_PCP_DOESNT_EXIST = @as(u32, 3222163713);
pub const ERROR_PCW_PCP_BAD_FORMAT = @as(u32, 3222163714);
pub const ERROR_PCW_CANT_CREATE_TEMP_FOLDER = @as(u32, 3222163715);
pub const ERROR_PCW_MISSING_PATCH_PATH = @as(u32, 3222163716);
pub const ERROR_PCW_CANT_OVERWRITE_PATCH = @as(u32, 3222163717);
pub const ERROR_PCW_CANT_CREATE_PATCH_FILE = @as(u32, 3222163718);
pub const ERROR_PCW_MISSING_PATCH_GUID = @as(u32, 3222163719);
pub const ERROR_PCW_BAD_PATCH_GUID = @as(u32, 3222163720);
pub const ERROR_PCW_BAD_GUIDS_TO_REPLACE = @as(u32, 3222163721);
pub const ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST = @as(u32, 3222163722);
pub const ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH = @as(u32, 3222163723);
pub const ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS = @as(u32, 3222163725);
pub const ERROR_PCW_OODS_COPYING_MSI = @as(u32, 3222163726);
pub const ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG = @as(u32, 3222163727);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_NAME = @as(u32, 3222163728);
pub const ERROR_PCW_DUP_UPGRADED_IMAGE_NAME = @as(u32, 3222163729);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG = @as(u32, 3222163730);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY = @as(u32, 3222163731);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163732);
pub const ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI = @as(u32, 3222163733);
pub const ERROR_PCW_UPGRADED_IMAGE_COMPRESSED = @as(u32, 3222163734);
pub const ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG = @as(u32, 3222163735);
pub const ERROR_PCW_BAD_TARGET_IMAGE_NAME = @as(u32, 3222163736);
pub const ERROR_PCW_DUP_TARGET_IMAGE_NAME = @as(u32, 3222163737);
pub const ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG = @as(u32, 3222163738);
pub const ERROR_PCW_TARGET_IMAGE_PATH_EMPTY = @as(u32, 3222163739);
pub const ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163740);
pub const ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI = @as(u32, 3222163741);
pub const ERROR_PCW_TARGET_IMAGE_COMPRESSED = @as(u32, 3222163742);
pub const ERROR_PCW_TARGET_BAD_PROD_VALIDATE = @as(u32, 3222163743);
pub const ERROR_PCW_TARGET_BAD_PROD_CODE_VAL = @as(u32, 3222163744);
pub const ERROR_PCW_UPGRADED_MISSING_SRC_FILES = @as(u32, 3222163745);
pub const ERROR_PCW_TARGET_MISSING_SRC_FILES = @as(u32, 3222163746);
pub const ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG = @as(u32, 3222163747);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_NAME = @as(u32, 3222163748);
pub const ERROR_PCW_DUP_IMAGE_FAMILY_NAME = @as(u32, 3222163749);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP = @as(u32, 3222163750);
pub const ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY = @as(u32, 3222163751);
pub const ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY = @as(u32, 3222163752);
pub const ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY = @as(u32, 3222163753);
pub const ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY = @as(u32, 3222163754);
pub const ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163755);
pub const ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD = @as(u32, 3222163756);
pub const ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE = @as(u32, 3222163757);
pub const ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE = @as(u32, 3222163758);
pub const ERROR_PCW_EXTFILE_MISSING_FILE = @as(u32, 3222163759);
pub const ERROR_PCW_BAD_FILE_SEQUENCE_START = @as(u32, 3222163770);
pub const ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER = @as(u32, 3222163771);
pub const ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE = @as(u32, 3222163772);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_DISKID = @as(u32, 3222163773);
pub const ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART = @as(u32, 3222163774);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY = @as(u32, 3222163775);
pub const ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED = @as(u32, 3222163776);
pub const ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE = @as(u32, 3222163777);
pub const ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD = @as(u32, 3222163778);
pub const ERROR_PCW_MISMATCHED_PRODUCT_CODES = @as(u32, 3222163779);
pub const ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS = @as(u32, 3222163780);
pub const ERROR_PCW_CANNOT_WRITE_DDF = @as(u32, 3222163781);
pub const ERROR_PCW_CANNOT_RUN_MAKECAB = @as(u32, 3222163782);
pub const ERROR_PCW_WRITE_SUMMARY_PROPERTIES = @as(u32, 3222163787);
pub const ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY = @as(u32, 3222163788);
pub const ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY = @as(u32, 3222163789);
pub const ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY = @as(u32, 3222163790);
pub const ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD = @as(u32, 3222163791);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG = @as(u32, 3222163792);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST = @as(u32, 3222163793);
pub const ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI = @as(u32, 3222163794);
pub const ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE = @as(u32, 3222163795);
pub const ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD = @as(u32, 3222163796);
pub const ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY = @as(u32, 3222163797);
pub const ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163798);
pub const ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY = @as(u32, 3222163799);
pub const ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG = @as(u32, 3222163800);
pub const ERROR_PCW_BAD_FAMILY_RANGE_NAME = @as(u32, 3222163801);
pub const ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY = @as(u32, 3222163802);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY = @as(u32, 3222163803);
pub const ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS = @as(u32, 3222163804);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS = @as(u32, 3222163805);
pub const ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS = @as(u32, 3222163806);
pub const ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS = @as(u32, 3222163807);
pub const ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS = @as(u32, 3222163808);
pub const ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS = @as(u32, 3222163809);
pub const ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH = @as(u32, 3222163810);
pub const ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS = @as(u32, 3222163811);
pub const ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS = @as(u32, 3222163812);
pub const ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS = @as(u32, 3222163813);
pub const ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS = @as(u32, 3222163814);
pub const ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH = @as(u32, 3222163815);
pub const ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS = @as(u32, 3222163816);
pub const ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS = @as(u32, 3222163817);
pub const ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS = @as(u32, 3222163819);
pub const ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS = @as(u32, 3222163820);
pub const ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS = @as(u32, 3222163821);
pub const ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS = @as(u32, 3222163822);
pub const ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH = @as(u32, 3222163823);
pub const ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS = @as(u32, 3222163824);
pub const ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS = @as(u32, 3222163825);
pub const ERROR_PCW_CANT_GENERATE_TRANSFORM = @as(u32, 3222163827);
pub const ERROR_PCW_CANT_CREATE_SUMMARY_INFO = @as(u32, 3222163828);
pub const ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND = @as(u32, 3222163829);
pub const ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND = @as(u32, 3222163830);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE = @as(u32, 3222163831);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION = @as(u32, 3222163832);
pub const ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE = @as(u32, 3222163833);
pub const ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE = @as(u32, 3222163834);
pub const ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION = @as(u32, 3222163835);
pub const ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE = @as(u32, 3222163836);
pub const ERROR_PCW_MATCHED_PRODUCT_VERSIONS = @as(u32, 3222163837);
pub const ERROR_PCW_OBSOLETION_WITH_SEQUENCE_DATA = @as(u32, 3222163838);
pub const ERROR_PCW_OBSOLETION_WITH_MSI30 = @as(u32, 3222163839);
pub const ERROR_PCW_OBSOLETION_WITH_PATCHSEQUENCE = @as(u32, 3222163840);
pub const ERROR_PCW_CANNOT_CREATE_TABLE = @as(u32, 3222163841);
pub const ERROR_PCW_CANT_GENERATE_SEQUENCEINFO_MAJORUPGD = @as(u32, 3222163842);
pub const ERROR_PCW_MAJOR_UPGD_WITHOUT_SEQUENCING = @as(u32, 3222163843);
pub const ERROR_PCW_BAD_PRODUCTVERSION_VALIDATION = @as(u32, 3222163844);
pub const ERROR_PCW_BAD_TRANSFORMSET = @as(u32, 3222163845);
pub const ERROR_PCW_BAD_TGT_UPD_IMAGES = @as(u32, 3222163846);
pub const ERROR_PCW_BAD_SUPERCEDENCE = @as(u32, 3222163847);
pub const ERROR_PCW_BAD_SEQUENCE = @as(u32, 3222163848);
pub const ERROR_PCW_BAD_TARGET = @as(u32, 3222163849);
pub const ERROR_PCW_NULL_PATCHFAMILY = @as(u32, 3222163850);
pub const ERROR_PCW_NULL_SEQUENCE_NUMBER = @as(u32, 3222163851);
pub const ERROR_PCW_BAD_VERSION_STRING = @as(u32, 3222163852);
pub const ERROR_PCW_BAD_MAJOR_VERSION = @as(u32, 3222163853);
pub const ERROR_PCW_SEQUENCING_BAD_TARGET = @as(u32, 3222163854);
pub const ERROR_PCW_PATCHMETADATA_PROP_NOT_SET = @as(u32, 3222163855);
pub const ERROR_PCW_INVALID_PATCHMETADATA_PROP = @as(u32, 3222163856);
pub const ERROR_PCW_INVALID_SUPERCEDENCE = @as(u32, 3222163857);
pub const ERROR_PCW_DUPLICATE_SEQUENCE_RECORD = @as(u32, 3222163858);
pub const ERROR_PCW_WRONG_PATCHMETADATA_STRD_PROP = @as(u32, 3222163859);
pub const ERROR_PCW_INVALID_PARAMETER = @as(u32, 3222163860);
pub const ERROR_PCW_CREATEFILE_LOG_FAILED = @as(u32, 3222163861);
pub const ERROR_PCW_INVALID_LOG_LEVEL = @as(u32, 3222163862);
pub const ERROR_PCW_INVALID_UI_LEVEL = @as(u32, 3222163863);
pub const ERROR_PCW_ERROR_WRITING_TO_LOG = @as(u32, 3222163864);
pub const ERROR_PCW_OUT_OF_MEMORY = @as(u32, 3222163865);
pub const ERROR_PCW_UNKNOWN_ERROR = @as(u32, 3222163866);
pub const ERROR_PCW_UNKNOWN_INFO = @as(u32, 3222163867);
pub const ERROR_PCW_UNKNOWN_WARN = @as(u32, 3222163868);
pub const ERROR_PCW_OPEN_VIEW = @as(u32, 3222163869);
pub const ERROR_PCW_EXECUTE_VIEW = @as(u32, 3222163870);
pub const ERROR_PCW_VIEW_FETCH = @as(u32, 3222163871);
pub const ERROR_PCW_FAILED_EXPAND_PATH = @as(u32, 3222163872);
pub const ERROR_PCW_INTERNAL_ERROR = @as(u32, 3222163969);
pub const ERROR_PCW_INVALID_PCP_PROPERTY = @as(u32, 3222163970);
pub const ERROR_PCW_INVALID_PCP_TARGETIMAGES = @as(u32, 3222163971);
pub const ERROR_PCW_LAX_VALIDATION_FLAGS = @as(u32, 3222163972);
pub const ERROR_PCW_FAILED_CREATE_TRANSFORM = @as(u32, 3222163973);
pub const ERROR_PCW_CANT_DELETE_TEMP_FOLDER = @as(u32, 3222163974);
pub const ERROR_PCW_MISSING_DIRECTORY_TABLE = @as(u32, 3222163975);
pub const ERROR_PCW_INVALID_SUPERSEDENCE_VALUE = @as(u32, 3222163976);
pub const ERROR_PCW_INVALID_PATCH_TYPE_SEQUENCING = @as(u32, 3222163977);
pub const ERROR_PCW_CANT_READ_FILE = @as(u32, 3222163978);
pub const ERROR_PCW_TARGET_WRONG_PRODUCT_VERSION_COMP = @as(u32, 3222163979);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDFILESTOIGNORE = @as(u32, 3222163980);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDIMAGES = @as(u32, 3222163981);
pub const ERROR_PCW_INVALID_PCP_EXTERNALFILES = @as(u32, 3222163982);
pub const ERROR_PCW_INVALID_PCP_IMAGEFAMILIES = @as(u32, 3222163983);
pub const ERROR_PCW_INVALID_PCP_PATCHSEQUENCE = @as(u32, 3222163984);
pub const ERROR_PCW_INVALID_PCP_TARGETFILES_OPTIONALDATA = @as(u32, 3222163985);
pub const ERROR_PCW_INVALID_PCP_UPGRADEDFILES_OPTIONALDATA = @as(u32, 3222163986);
pub const ERROR_PCW_MISSING_PATCHMETADATA = @as(u32, 3222163987);
pub const ERROR_PCW_IMAGE_PATH_NOT_EXIST = @as(u32, 3222163988);
pub const ERROR_PCW_INVALID_RANGE_ELEMENT = @as(u32, 3222163989);
pub const ERROR_PCW_INVALID_MAJOR_VERSION = @as(u32, 3222163990);
pub const ERROR_PCW_INVALID_PCP_PROPERTIES = @as(u32, 3222163991);
pub const ERROR_PCW_INVALID_PCP_FAMILYFILERANGES = @as(u32, 3222163992);
pub const INFO_BASE = @as(u32, 3222229249);
pub const INFO_PASSED_MAIN_CONTROL = @as(u32, 3222229249);
pub const INFO_ENTERING_PHASE_I_VALIDATION = @as(u32, 3222229250);
pub const INFO_ENTERING_PHASE_I = @as(u32, 3222229251);
pub const INFO_PCP_PATH = @as(u32, 3222229252);
pub const INFO_TEMP_DIR = @as(u32, 3222229253);
pub const INFO_SET_OPTIONS = @as(u32, 3222229254);
pub const INFO_PROPERTY = @as(u32, 3222229255);
pub const INFO_ENTERING_PHASE_II = @as(u32, 3222229256);
pub const INFO_ENTERING_PHASE_III = @as(u32, 3222229257);
pub const INFO_ENTERING_PHASE_IV = @as(u32, 3222229258);
pub const INFO_ENTERING_PHASE_V = @as(u32, 3222229259);
pub const INFO_GENERATING_METADATA = @as(u32, 3222229265);
pub const INFO_TEMP_DIR_CLEANUP = @as(u32, 3222229266);
pub const INFO_PATCHCACHE_FILEINFO_FAILURE = @as(u32, 3222229267);
pub const INFO_PATCHCACHE_PCI_READFAILURE = @as(u32, 3222229268);
pub const INFO_PATCHCACHE_PCI_WRITEFAILURE = @as(u32, 3222229269);
pub const INFO_USING_USER_MSI_FOR_PATCH_TABLES = @as(u32, 3222229270);
pub const INFO_SUCCESSFUL_PATCH_CREATION = @as(u32, 3222229271);
pub const WARN_BASE = @as(u32, 3222294785);
pub const WARN_MAJOR_UPGRADE_PATCH = @as(u32, 3222294785);
pub const WARN_SEQUENCE_DATA_GENERATION_DISABLED = @as(u32, 3222294786);
pub const WARN_SEQUENCE_DATA_SUPERSEDENCE_IGNORED = @as(u32, 3222294787);
pub const WARN_IMPROPER_TRANSFORM_VALIDATION = @as(u32, 3222294788);
pub const WARN_PCW_MISMATCHED_PRODUCT_CODES = @as(u32, 3222294789);
pub const WARN_PCW_MISMATCHED_PRODUCT_VERSIONS = @as(u32, 3222294790);
pub const WARN_INVALID_TRANSFORM_VALIDATION = @as(u32, 3222294791);
pub const WARN_BAD_MAJOR_VERSION = @as(u32, 3222294792);
pub const WARN_FILE_VERSION_DOWNREV = @as(u32, 3222294793);
pub const WARN_EQUAL_FILE_VERSION = @as(u32, 3222294794);
pub const WARN_PATCHPROPERTYNOTSET = @as(u32, 3222294795);
pub const WARN_OBSOLETION_WITH_SEQUENCE_DATA = @as(u32, 3222294802);
pub const WARN_OBSOLETION_WITH_MSI30 = @as(u32, 3222294801);
pub const WARN_OBSOLETION_WITH_PATCHSEQUENCE = @as(u32, 3222294803);
pub const DELTA_MAX_HASH_SIZE = @as(u32, 32);
pub const cchMaxInteger = @as(i32, 12);
pub const LOGNONE = @as(u32, 0);
pub const LOGINFO = @as(u32, 1);
pub const LOGWARN = @as(u32, 2);
pub const LOGERR = @as(u32, 4);
pub const LOGPERFMESSAGES = @as(u32, 8);
pub const LOGALL = @as(u32, 15);
pub const UINONE = @as(u32, 0);
pub const UILOGBITS = @as(u32, 15);
pub const DEFAULT_MINIMUM_REQUIRED_MSI_VERSION = @as(u32, 100);
pub const DEFAULT_FILE_SEQUENCE_START = @as(u32, 2);
pub const DEFAULT_DISK_ID = @as(u32, 2);

//--------------------------------------------------------------------------------
// Section: Types (179)
//--------------------------------------------------------------------------------
pub const MSIASSEMBLYINFO = enum(u32) {
    NETASSEMBLY = 0,
    WIN32ASSEMBLY = 1,
};
pub const MSIASSEMBLYINFO_NETASSEMBLY = MSIASSEMBLYINFO.NETASSEMBLY;
pub const MSIASSEMBLYINFO_WIN32ASSEMBLY = MSIASSEMBLYINFO.WIN32ASSEMBLY;

pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION = enum(u32) {
    UNINSTALLED = 1,
    STILL_IN_USE = 2,
    ALREADY_UNINSTALLED = 3,
    DELETE_PENDING = 4,
};
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.STILL_IN_USE;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.ALREADY_UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.DELETE_PENDING;

pub const QUERYASMINFO_FLAGS = packed struct(u32) {
    E: u1 = 0,
    _1: u1 = 0,
    _2: u1 = 0,
    _3: u1 = 0,
    _4: u1 = 0,
    _5: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const QUERYASMINFO_FLAG_VALIDATE = QUERYASMINFO_FLAGS{ .E = 1 };

// TODO: this type has a FreeFunc 'MsiCloseHandle', what can Zig do with this information?
// TODO: this type has an InvalidHandleValue of '0', what can Zig do with this information?
pub const MSIHANDLE = u32;

pub const RESULTTYPES = enum(i32) {
    Unknown = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
};
pub const ieUnknown = RESULTTYPES.Unknown;
pub const ieError = RESULTTYPES.Error;
pub const ieWarning = RESULTTYPES.Warning;
pub const ieInfo = RESULTTYPES.Info;

pub const STATUSTYPES = enum(i32) {
    GetCUB = 0,
    ICECount = 1,
    Merge = 2,
    SummaryInfo = 3,
    CreateEngine = 4,
    Starting = 5,
    RunICE = 6,
    Shutdown = 7,
    Success = 8,
    Fail = 9,
    Cancel = 10,
};
pub const ieStatusGetCUB = STATUSTYPES.GetCUB;
pub const ieStatusICECount = STATUSTYPES.ICECount;
pub const ieStatusMerge = STATUSTYPES.Merge;
pub const ieStatusSummaryInfo = STATUSTYPES.SummaryInfo;
pub const ieStatusCreateEngine = STATUSTYPES.CreateEngine;
pub const ieStatusStarting = STATUSTYPES.Starting;
pub const ieStatusRunICE = STATUSTYPES.RunICE;
pub const ieStatusShutdown = STATUSTYPES.Shutdown;
pub const ieStatusSuccess = STATUSTYPES.Success;
pub const ieStatusFail = STATUSTYPES.Fail;
pub const ieStatusCancel = STATUSTYPES.Cancel;

pub const LPDISPLAYVAL = *const fn(
    pContext: ?*anyopaque,
    uiType: RESULTTYPES,
    szwVal: ?[*:0]const u16,
    szwDescription: ?[*:0]const u16,
    szwLocation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPEVALCOMCALLBACK = *const fn(
    iStatus: STATUSTYPES,
    szData: ?[*:0]const u16,
    pContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IValidate_Value = Guid.initString("e482e5c6-e31e-4143-a2e6-dbc3d8e4b8d3");
pub const IID_IValidate = &IID_IValidate_Value;
pub const IValidate = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDatabase: *const fn(
            self: *const IValidate,
            szDatabase: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenCUB: *const fn(
            self: *const IValidate,
            szCUBFile: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: *const fn(
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseCUB: *const fn(
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplay: *const fn(
            self: *const IValidate,
            pDisplayFunction: ?LPDISPLAYVAL,
            pContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: *const fn(
            self: *const IValidate,
            pStatusFunction: ?LPEVALCOMCALLBACK,
            pContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: *const fn(
            self: *const IValidate,
            wzICEs: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn OpenDatabase(self: *const IValidate, szDatabase: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.OpenDatabase(self, szDatabase);
    }
    pub fn OpenCUB(self: *const IValidate, szCUBFile: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.OpenCUB(self, szCUBFile);
    }
    pub fn CloseDatabase(self: *const IValidate) callconv(.Inline) HRESULT {
        return self.vtable.CloseDatabase(self);
    }
    pub fn CloseCUB(self: *const IValidate) callconv(.Inline) HRESULT {
        return self.vtable.CloseCUB(self);
    }
    pub fn SetDisplay(self: *const IValidate, pDisplayFunction: ?LPDISPLAYVAL, pContext: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.SetDisplay(self, pDisplayFunction, pContext);
    }
    pub fn SetStatus(self: *const IValidate, pStatusFunction: ?LPEVALCOMCALLBACK, pContext: ?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.SetStatus(self, pStatusFunction, pContext);
    }
    pub fn Validate(self: *const IValidate, wzICEs: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.Validate(self, wzICEs);
    }
};

const CLSID_MsmMerge_Value = Guid.initString("0adda830-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge = &CLSID_MsmMerge_Value;

pub const msmErrorType = enum(i32) {
    LanguageUnsupported = 1,
    LanguageFailed = 2,
    Exclusion = 3,
    TableMerge = 4,
    ResequenceMerge = 5,
    FileCreate = 6,
    DirCreate = 7,
    FeatureRequired = 8,
};
pub const msmErrorLanguageUnsupported = msmErrorType.LanguageUnsupported;
pub const msmErrorLanguageFailed = msmErrorType.LanguageFailed;
pub const msmErrorExclusion = msmErrorType.Exclusion;
pub const msmErrorTableMerge = msmErrorType.TableMerge;
pub const msmErrorResequenceMerge = msmErrorType.ResequenceMerge;
pub const msmErrorFileCreate = msmErrorType.FileCreate;
pub const msmErrorDirCreate = msmErrorType.DirCreate;
pub const msmErrorFeatureRequired = msmErrorType.FeatureRequired;

const IID_IEnumMsmString_Value = Guid.initString("0adda826-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmString = &IID_IEnumMsmString_Value;
pub const IEnumMsmString = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumMsmString,
            cFetch: u32,
            rgbstrStrings: ?*?BSTR,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumMsmString,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumMsmString,
            pemsmStrings: ?*?*IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumMsmString, cFetch: u32, rgbstrStrings: ?*?BSTR, pcFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, cFetch, rgbstrStrings, pcFetched);
    }
    pub fn Skip(self: *const IEnumMsmString, cSkip: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, cSkip);
    }
    pub fn Reset(self: *const IEnumMsmString) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumMsmString, pemsmStrings: ?*?*IEnumMsmString) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, pemsmStrings);
    }
};

const IID_IMsmStrings_Value = Guid.initString("0adda827-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmStrings = &IID_IMsmStrings_Value;
pub const IMsmStrings = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_Item: *const fn(
            self: *const IMsmStrings,
            Item: i32,
            Return: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn(
            self: *const IMsmStrings,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn(
            self: *const IMsmStrings,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_Item(self: *const IMsmStrings, Item: i32, Return: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Item(self, Item, Return);
    }
    pub fn get_Count(self: *const IMsmStrings, Count: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_Count(self, Count);
    }
    pub fn get__NewEnum(self: *const IMsmStrings, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.get__NewEnum(self, NewEnum);
    }
};

const IID_IMsmError_Value = Guid.initString("0adda828-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmError = &IID_IMsmError_Value;
pub const IMsmError = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: *const fn(
            self: *const IMsmError,
            ErrorType: ?*msmErrorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: *const fn(
            self: *const IMsmError,
            ErrorPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: *const fn(
            self: *const IMsmError,
            ErrorLanguage: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseTable: *const fn(
            self: *const IMsmError,
            ErrorTable: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseKeys: *const fn(
            self: *const IMsmError,
            ErrorKeys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleTable: *const fn(
            self: *const IMsmError,
            ErrorTable: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleKeys: *const fn(
            self: *const IMsmError,
            ErrorKeys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_Type(self: *const IMsmError, ErrorType: ?*msmErrorType) callconv(.Inline) HRESULT {
        return self.vtable.get_Type(self, ErrorType);
    }
    pub fn get_Path(self: *const IMsmError, ErrorPath: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Path(self, ErrorPath);
    }
    pub fn get_Language(self: *const IMsmError, ErrorLanguage: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.get_Language(self, ErrorLanguage);
    }
    pub fn get_DatabaseTable(self: *const IMsmError, ErrorTable: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_DatabaseTable(self, ErrorTable);
    }
    pub fn get_DatabaseKeys(self: *const IMsmError, ErrorKeys: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
        return self.vtable.get_DatabaseKeys(self, ErrorKeys);
    }
    pub fn get_ModuleTable(self: *const IMsmError, ErrorTable: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ModuleTable(self, ErrorTable);
    }
    pub fn get_ModuleKeys(self: *const IMsmError, ErrorKeys: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
        return self.vtable.get_ModuleKeys(self, ErrorKeys);
    }
};

const IID_IEnumMsmError_Value = Guid.initString("0adda829-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmError = &IID_IEnumMsmError_Value;
pub const IEnumMsmError = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumMsmError,
            cFetch: u32,
            rgmsmErrors: ?*?*IMsmError,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumMsmError,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumMsmError,
            pemsmErrors: ?*?*IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumMsmError, cFetch: u32, rgmsmErrors: ?*?*IMsmError, pcFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, cFetch, rgmsmErrors, pcFetched);
    }
    pub fn Skip(self: *const IEnumMsmError, cSkip: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, cSkip);
    }
    pub fn Reset(self: *const IEnumMsmError) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumMsmError, pemsmErrors: ?*?*IEnumMsmError) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, pemsmErrors);
    }
};

const IID_IMsmErrors_Value = Guid.initString("0adda82a-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmErrors = &IID_IMsmErrors_Value;
pub const IMsmErrors = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_Item: *const fn(
            self: *const IMsmErrors,
            Item: i32,
            Return: ?*?*IMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn(
            self: *const IMsmErrors,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn(
            self: *const IMsmErrors,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_Item(self: *const IMsmErrors, Item: i32, Return: ?*?*IMsmError) callconv(.Inline) HRESULT {
        return self.vtable.get_Item(self, Item, Return);
    }
    pub fn get_Count(self: *const IMsmErrors, Count: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_Count(self, Count);
    }
    pub fn get__NewEnum(self: *const IMsmErrors, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.get__NewEnum(self, NewEnum);
    }
};

const IID_IMsmDependency_Value = Guid.initString("0adda82b-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependency = &IID_IMsmDependency_Value;
pub const IMsmDependency = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Module: *const fn(
            self: *const IMsmDependency,
            Module: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: *const fn(
            self: *const IMsmDependency,
            Language: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: *const fn(
            self: *const IMsmDependency,
            Version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_Module(self: *const IMsmDependency, Module: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Module(self, Module);
    }
    pub fn get_Language(self: *const IMsmDependency, Language: ?*i16) callconv(.Inline) HRESULT {
        return self.vtable.get_Language(self, Language);
    }
    pub fn get_Version(self: *const IMsmDependency, Version: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Version(self, Version);
    }
};

const IID_IEnumMsmDependency_Value = Guid.initString("0adda82c-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmDependency = &IID_IEnumMsmDependency_Value;
pub const IEnumMsmDependency = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: *const fn(
            self: *const IEnumMsmDependency,
            cFetch: u32,
            rgmsmDependencies: ?*?*IMsmDependency,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: *const fn(
            self: *const IEnumMsmDependency,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: *const fn(
            self: *const IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IEnumMsmDependency,
            pemsmDependencies: ?*?*IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn Next(self: *const IEnumMsmDependency, cFetch: u32, rgmsmDependencies: ?*?*IMsmDependency, pcFetched: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Next(self, cFetch, rgmsmDependencies, pcFetched);
    }
    pub fn Skip(self: *const IEnumMsmDependency, cSkip: u32) callconv(.Inline) HRESULT {
        return self.vtable.Skip(self, cSkip);
    }
    pub fn Reset(self: *const IEnumMsmDependency) callconv(.Inline) HRESULT {
        return self.vtable.Reset(self);
    }
    pub fn Clone(self: *const IEnumMsmDependency, pemsmDependencies: ?*?*IEnumMsmDependency) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, pemsmDependencies);
    }
};

const IID_IMsmDependencies_Value = Guid.initString("0adda82d-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependencies = &IID_IMsmDependencies_Value;
pub const IMsmDependencies = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_Item: *const fn(
            self: *const IMsmDependencies,
            Item: i32,
            Return: ?*?*IMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: *const fn(
            self: *const IMsmDependencies,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: *const fn(
            self: *const IMsmDependencies,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_Item(self: *const IMsmDependencies, Item: i32, Return: ?*?*IMsmDependency) callconv(.Inline) HRESULT {
        return self.vtable.get_Item(self, Item, Return);
    }
    pub fn get_Count(self: *const IMsmDependencies, Count: ?*i32) callconv(.Inline) HRESULT {
        return self.vtable.get_Count(self, Count);
    }
    pub fn get__NewEnum(self: *const IMsmDependencies, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.get__NewEnum(self, NewEnum);
    }
};

const IID_IMsmMerge_Value = Guid.initString("0adda82e-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmMerge = &IID_IMsmMerge_Value;
pub const IMsmMerge = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OpenDatabase: *const fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenModule: *const fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
            Language: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: *const fn(
            self: *const IMsmMerge,
            Commit: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseModule: *const fn(
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLog: *const fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLog: *const fn(
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Log: *const fn(
            self: *const IMsmMerge,
            Message: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Errors: *const fn(
            self: *const IMsmMerge,
            Errors: ?*?*IMsmErrors,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dependencies: *const fn(
            self: *const IMsmMerge,
            Dependencies: ?*?*IMsmDependencies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: *const fn(
            self: *const IMsmMerge,
            Feature: ?BSTR,
            RedirectDir: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: *const fn(
            self: *const IMsmMerge,
            Feature: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractCAB: *const fn(
            self: *const IMsmMerge,
            FileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractFiles: *const fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn OpenDatabase(self: *const IMsmMerge, Path: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.OpenDatabase(self, Path);
    }
    pub fn OpenModule(self: *const IMsmMerge, Path: ?BSTR, Language: i16) callconv(.Inline) HRESULT {
        return self.vtable.OpenModule(self, Path, Language);
    }
    pub fn CloseDatabase(self: *const IMsmMerge, Commit: i16) callconv(.Inline) HRESULT {
        return self.vtable.CloseDatabase(self, Commit);
    }
    pub fn CloseModule(self: *const IMsmMerge) callconv(.Inline) HRESULT {
        return self.vtable.CloseModule(self);
    }
    pub fn OpenLog(self: *const IMsmMerge, Path: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.OpenLog(self, Path);
    }
    pub fn CloseLog(self: *const IMsmMerge) callconv(.Inline) HRESULT {
        return self.vtable.CloseLog(self);
    }
    pub fn Log(self: *const IMsmMerge, Message: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Log(self, Message);
    }
    pub fn get_Errors(self: *const IMsmMerge, Errors: ?*?*IMsmErrors) callconv(.Inline) HRESULT {
        return self.vtable.get_Errors(self, Errors);
    }
    pub fn get_Dependencies(self: *const IMsmMerge, Dependencies: ?*?*IMsmDependencies) callconv(.Inline) HRESULT {
        return self.vtable.get_Dependencies(self, Dependencies);
    }
    pub fn Merge(self: *const IMsmMerge, Feature: ?BSTR, RedirectDir: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Merge(self, Feature, RedirectDir);
    }
    pub fn Connect(self: *const IMsmMerge, Feature: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.Connect(self, Feature);
    }
    pub fn ExtractCAB(self: *const IMsmMerge, FileName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ExtractCAB(self, FileName);
    }
    pub fn ExtractFiles(self: *const IMsmMerge, Path: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ExtractFiles(self, Path);
    }
};

const IID_IMsmGetFiles_Value = Guid.initString("7041ae26-2d78-11d2-888a-00a0c981b015");
pub const IID_IMsmGetFiles = &IID_IMsmGetFiles_Value;
pub const IMsmGetFiles = extern union {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleFiles: *const fn(
            self: *const IMsmGetFiles,
            Files: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IDispatch: IDispatch,
    IUnknown: IUnknown,
    pub fn get_ModuleFiles(self: *const IMsmGetFiles, Files: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
        return self.vtable.get_ModuleFiles(self, Files);
    }
};

pub const PMSIHANDLE = extern struct {
    m_h: MSIHANDLE,
};

pub const INSTALLMESSAGE = enum(i32) {
    FATALEXIT = 0,
    ERROR = 16777216,
    WARNING = 33554432,
    USER = 50331648,
    INFO = 67108864,
    FILESINUSE = 83886080,
    RESOLVESOURCE = 100663296,
    OUTOFDISKSPACE = 117440512,
    ACTIONSTART = 134217728,
    ACTIONDATA = 150994944,
    PROGRESS = 167772160,
    COMMONDATA = 184549376,
    INITIALIZE = 201326592,
    TERMINATE = 218103808,
    SHOWDIALOG = 234881024,
    PERFORMANCE = 251658240,
    RMFILESINUSE = 419430400,
    INSTALLSTART = 436207616,
    INSTALLEND = 452984832,
};
pub const INSTALLMESSAGE_FATALEXIT = INSTALLMESSAGE.FATALEXIT;
pub const INSTALLMESSAGE_ERROR = INSTALLMESSAGE.ERROR;
pub const INSTALLMESSAGE_WARNING = INSTALLMESSAGE.WARNING;
pub const INSTALLMESSAGE_USER = INSTALLMESSAGE.USER;
pub const INSTALLMESSAGE_INFO = INSTALLMESSAGE.INFO;
pub const INSTALLMESSAGE_FILESINUSE = INSTALLMESSAGE.FILESINUSE;
pub const INSTALLMESSAGE_RESOLVESOURCE = INSTALLMESSAGE.RESOLVESOURCE;
pub const INSTALLMESSAGE_OUTOFDISKSPACE = INSTALLMESSAGE.OUTOFDISKSPACE;
pub const INSTALLMESSAGE_ACTIONSTART = INSTALLMESSAGE.ACTIONSTART;
pub const INSTALLMESSAGE_ACTIONDATA = INSTALLMESSAGE.ACTIONDATA;
pub const INSTALLMESSAGE_PROGRESS = INSTALLMESSAGE.PROGRESS;
pub const INSTALLMESSAGE_COMMONDATA = INSTALLMESSAGE.COMMONDATA;
pub const INSTALLMESSAGE_INITIALIZE = INSTALLMESSAGE.INITIALIZE;
pub const INSTALLMESSAGE_TERMINATE = INSTALLMESSAGE.TERMINATE;
pub const INSTALLMESSAGE_SHOWDIALOG = INSTALLMESSAGE.SHOWDIALOG;
pub const INSTALLMESSAGE_PERFORMANCE = INSTALLMESSAGE.PERFORMANCE;
pub const INSTALLMESSAGE_RMFILESINUSE = INSTALLMESSAGE.RMFILESINUSE;
pub const INSTALLMESSAGE_INSTALLSTART = INSTALLMESSAGE.INSTALLSTART;
pub const INSTALLMESSAGE_INSTALLEND = INSTALLMESSAGE.INSTALLEND;

pub const INSTALLUI_HANDLERA = *const fn(
    pvContext: ?*anyopaque,
    iMessageType: u32,
    szMessage: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUI_HANDLERW = *const fn(
    pvContext: ?*anyopaque,
    iMessageType: u32,
    szMessage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PINSTALLUI_HANDLER_RECORD = *const fn(
    pvContext: ?*anyopaque,
    iMessageType: u32,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUILEVEL = enum(i32) {
    NOCHANGE = 0,
    DEFAULT = 1,
    NONE = 2,
    BASIC = 3,
    REDUCED = 4,
    FULL = 5,
    ENDDIALOG = 128,
    PROGRESSONLY = 64,
    HIDECANCEL = 32,
    SOURCERESONLY = 256,
    UACONLY = 512,
};
pub const INSTALLUILEVEL_NOCHANGE = INSTALLUILEVEL.NOCHANGE;
pub const INSTALLUILEVEL_DEFAULT = INSTALLUILEVEL.DEFAULT;
pub const INSTALLUILEVEL_NONE = INSTALLUILEVEL.NONE;
pub const INSTALLUILEVEL_BASIC = INSTALLUILEVEL.BASIC;
pub const INSTALLUILEVEL_REDUCED = INSTALLUILEVEL.REDUCED;
pub const INSTALLUILEVEL_FULL = INSTALLUILEVEL.FULL;
pub const INSTALLUILEVEL_ENDDIALOG = INSTALLUILEVEL.ENDDIALOG;
pub const INSTALLUILEVEL_PROGRESSONLY = INSTALLUILEVEL.PROGRESSONLY;
pub const INSTALLUILEVEL_HIDECANCEL = INSTALLUILEVEL.HIDECANCEL;
pub const INSTALLUILEVEL_SOURCERESONLY = INSTALLUILEVEL.SOURCERESONLY;
pub const INSTALLUILEVEL_UACONLY = INSTALLUILEVEL.UACONLY;

pub const INSTALLSTATE = enum(i32) {
    NOTUSED = -7,
    BADCONFIG = -6,
    INCOMPLETE = -5,
    SOURCEABSENT = -4,
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    BROKEN = 0,
    ADVERTISED = 1,
    ABSENT = 2,
    LOCAL = 3,
    SOURCE = 4,
    DEFAULT = 5,
    pub const REMOVED = .ADVERTISED;
};
pub const INSTALLSTATE_NOTUSED = INSTALLSTATE.NOTUSED;
pub const INSTALLSTATE_BADCONFIG = INSTALLSTATE.BADCONFIG;
pub const INSTALLSTATE_INCOMPLETE = INSTALLSTATE.INCOMPLETE;
pub const INSTALLSTATE_SOURCEABSENT = INSTALLSTATE.SOURCEABSENT;
pub const INSTALLSTATE_MOREDATA = INSTALLSTATE.MOREDATA;
pub const INSTALLSTATE_INVALIDARG = INSTALLSTATE.INVALIDARG;
pub const INSTALLSTATE_UNKNOWN = INSTALLSTATE.UNKNOWN;
pub const INSTALLSTATE_BROKEN = INSTALLSTATE.BROKEN;
pub const INSTALLSTATE_ADVERTISED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_REMOVED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_ABSENT = INSTALLSTATE.ABSENT;
pub const INSTALLSTATE_LOCAL = INSTALLSTATE.LOCAL;
pub const INSTALLSTATE_SOURCE = INSTALLSTATE.SOURCE;
pub const INSTALLSTATE_DEFAULT = INSTALLSTATE.DEFAULT;

pub const USERINFOSTATE = enum(i32) {
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    ABSENT = 0,
    PRESENT = 1,
};
pub const USERINFOSTATE_MOREDATA = USERINFOSTATE.MOREDATA;
pub const USERINFOSTATE_INVALIDARG = USERINFOSTATE.INVALIDARG;
pub const USERINFOSTATE_UNKNOWN = USERINFOSTATE.UNKNOWN;
pub const USERINFOSTATE_ABSENT = USERINFOSTATE.ABSENT;
pub const USERINFOSTATE_PRESENT = USERINFOSTATE.PRESENT;

pub const INSTALLLEVEL = enum(i32) {
    DEFAULT = 0,
    MINIMUM = 1,
    MAXIMUM = 65535,
};
pub const INSTALLLEVEL_DEFAULT = INSTALLLEVEL.DEFAULT;
pub const INSTALLLEVEL_MINIMUM = INSTALLLEVEL.MINIMUM;
pub const INSTALLLEVEL_MAXIMUM = INSTALLLEVEL.MAXIMUM;

pub const REINSTALLMODE = enum(i32) {
    REPAIR = 1,
    FILEMISSING = 2,
    FILEOLDERVERSION = 4,
    FILEEQUALVERSION = 8,
    FILEEXACT = 16,
    FILEVERIFY = 32,
    FILEREPLACE = 64,
    MACHINEDATA = 128,
    USERDATA = 256,
    SHORTCUT = 512,
    PACKAGE = 1024,
};
pub const REINSTALLMODE_REPAIR = REINSTALLMODE.REPAIR;
pub const REINSTALLMODE_FILEMISSING = REINSTALLMODE.FILEMISSING;
pub const REINSTALLMODE_FILEOLDERVERSION = REINSTALLMODE.FILEOLDERVERSION;
pub const REINSTALLMODE_FILEEQUALVERSION = REINSTALLMODE.FILEEQUALVERSION;
pub const REINSTALLMODE_FILEEXACT = REINSTALLMODE.FILEEXACT;
pub const REINSTALLMODE_FILEVERIFY = REINSTALLMODE.FILEVERIFY;
pub const REINSTALLMODE_FILEREPLACE = REINSTALLMODE.FILEREPLACE;
pub const REINSTALLMODE_MACHINEDATA = REINSTALLMODE.MACHINEDATA;
pub const REINSTALLMODE_USERDATA = REINSTALLMODE.USERDATA;
pub const REINSTALLMODE_SHORTCUT = REINSTALLMODE.SHORTCUT;
pub const REINSTALLMODE_PACKAGE = REINSTALLMODE.PACKAGE;

pub const INSTALLOGMODE = enum(i32) {
    FATALEXIT = 1,
    ERROR = 2,
    WARNING = 4,
    USER = 8,
    INFO = 16,
    RESOLVESOURCE = 64,
    OUTOFDISKSPACE = 128,
    ACTIONSTART = 256,
    ACTIONDATA = 512,
    COMMONDATA = 2048,
    PROPERTYDUMP = 1024,
    VERBOSE = 4096,
    EXTRADEBUG = 8192,
    LOGONLYONERROR = 16384,
    LOGPERFORMANCE = 32768,
    FILESINUSE = 32,
    RMFILESINUSE = 33554432,
    INSTALLSTART = 67108864,
    INSTALLEND = 134217728,
    pub const PROGRESS = .PROPERTYDUMP;
    pub const INITIALIZE = .VERBOSE;
    pub const TERMINATE = .EXTRADEBUG;
    pub const SHOWDIALOG = .LOGONLYONERROR;
};
pub const INSTALLLOGMODE_FATALEXIT = INSTALLOGMODE.FATALEXIT;
pub const INSTALLLOGMODE_ERROR = INSTALLOGMODE.ERROR;
pub const INSTALLLOGMODE_WARNING = INSTALLOGMODE.WARNING;
pub const INSTALLLOGMODE_USER = INSTALLOGMODE.USER;
pub const INSTALLLOGMODE_INFO = INSTALLOGMODE.INFO;
pub const INSTALLLOGMODE_RESOLVESOURCE = INSTALLOGMODE.RESOLVESOURCE;
pub const INSTALLLOGMODE_OUTOFDISKSPACE = INSTALLOGMODE.OUTOFDISKSPACE;
pub const INSTALLLOGMODE_ACTIONSTART = INSTALLOGMODE.ACTIONSTART;
pub const INSTALLLOGMODE_ACTIONDATA = INSTALLOGMODE.ACTIONDATA;
pub const INSTALLLOGMODE_COMMONDATA = INSTALLOGMODE.COMMONDATA;
pub const INSTALLLOGMODE_PROPERTYDUMP = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_VERBOSE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_EXTRADEBUG = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_LOGONLYONERROR = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_LOGPERFORMANCE = INSTALLOGMODE.LOGPERFORMANCE;
pub const INSTALLLOGMODE_PROGRESS = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_INITIALIZE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_TERMINATE = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_SHOWDIALOG = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_FILESINUSE = INSTALLOGMODE.FILESINUSE;
pub const INSTALLLOGMODE_RMFILESINUSE = INSTALLOGMODE.RMFILESINUSE;
pub const INSTALLLOGMODE_INSTALLSTART = INSTALLOGMODE.INSTALLSTART;
pub const INSTALLLOGMODE_INSTALLEND = INSTALLOGMODE.INSTALLEND;

pub const INSTALLLOGATTRIBUTES = enum(i32) {
    APPEND = 1,
    FLUSHEACHLINE = 2,
};
pub const INSTALLLOGATTRIBUTES_APPEND = INSTALLLOGATTRIBUTES.APPEND;
pub const INSTALLLOGATTRIBUTES_FLUSHEACHLINE = INSTALLLOGATTRIBUTES.FLUSHEACHLINE;

pub const INSTALLFEATUREATTRIBUTE = enum(i32) {
    FAVORLOCAL = 1,
    FAVORSOURCE = 2,
    FOLLOWPARENT = 4,
    FAVORADVERTISE = 8,
    DISALLOWADVERTISE = 16,
    NOUNSUPPORTEDADVERTISE = 32,
};
pub const INSTALLFEATUREATTRIBUTE_FAVORLOCAL = INSTALLFEATUREATTRIBUTE.FAVORLOCAL;
pub const INSTALLFEATUREATTRIBUTE_FAVORSOURCE = INSTALLFEATUREATTRIBUTE.FAVORSOURCE;
pub const INSTALLFEATUREATTRIBUTE_FOLLOWPARENT = INSTALLFEATUREATTRIBUTE.FOLLOWPARENT;
pub const INSTALLFEATUREATTRIBUTE_FAVORADVERTISE = INSTALLFEATUREATTRIBUTE.FAVORADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE = INSTALLFEATUREATTRIBUTE.DISALLOWADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = INSTALLFEATUREATTRIBUTE.NOUNSUPPORTEDADVERTISE;

pub const INSTALLMODE = enum(i32) {
    NODETECTION_ANY = -4,
    NOSOURCERESOLUTION = -3,
    NODETECTION = -2,
    EXISTING = -1,
    DEFAULT = 0,
};
pub const INSTALLMODE_NODETECTION_ANY = INSTALLMODE.NODETECTION_ANY;
pub const INSTALLMODE_NOSOURCERESOLUTION = INSTALLMODE.NOSOURCERESOLUTION;
pub const INSTALLMODE_NODETECTION = INSTALLMODE.NODETECTION;
pub const INSTALLMODE_EXISTING = INSTALLMODE.EXISTING;
pub const INSTALLMODE_DEFAULT = INSTALLMODE.DEFAULT;

pub const MSIPATCHSTATE = enum(i32) {
    INVALID = 0,
    APPLIED = 1,
    SUPERSEDED = 2,
    OBSOLETED = 4,
    REGISTERED = 8,
    ALL = 15,
};
pub const MSIPATCHSTATE_INVALID = MSIPATCHSTATE.INVALID;
pub const MSIPATCHSTATE_APPLIED = MSIPATCHSTATE.APPLIED;
pub const MSIPATCHSTATE_SUPERSEDED = MSIPATCHSTATE.SUPERSEDED;
pub const MSIPATCHSTATE_OBSOLETED = MSIPATCHSTATE.OBSOLETED;
pub const MSIPATCHSTATE_REGISTERED = MSIPATCHSTATE.REGISTERED;
pub const MSIPATCHSTATE_ALL = MSIPATCHSTATE.ALL;

pub const MSIINSTALLCONTEXT = enum(i32) {
    FIRSTVISIBLE = 0,
    USERMANAGED = 1,
    USERUNMANAGED = 2,
    MACHINE = 4,
    ALL = 7,
    ALLUSERMANAGED = 8,
    pub const NONE = .FIRSTVISIBLE;
};
pub const MSIINSTALLCONTEXT_FIRSTVISIBLE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_NONE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_USERMANAGED = MSIINSTALLCONTEXT.USERMANAGED;
pub const MSIINSTALLCONTEXT_USERUNMANAGED = MSIINSTALLCONTEXT.USERUNMANAGED;
pub const MSIINSTALLCONTEXT_MACHINE = MSIINSTALLCONTEXT.MACHINE;
pub const MSIINSTALLCONTEXT_ALL = MSIINSTALLCONTEXT.ALL;
pub const MSIINSTALLCONTEXT_ALLUSERMANAGED = MSIINSTALLCONTEXT.ALLUSERMANAGED;

pub const MSIPATCHDATATYPE = enum(i32) {
    PATCHFILE = 0,
    XMLPATH = 1,
    XMLBLOB = 2,
};
pub const MSIPATCH_DATATYPE_PATCHFILE = MSIPATCHDATATYPE.PATCHFILE;
pub const MSIPATCH_DATATYPE_XMLPATH = MSIPATCHDATATYPE.XMLPATH;
pub const MSIPATCH_DATATYPE_XMLBLOB = MSIPATCHDATATYPE.XMLBLOB;

pub const MSIPATCHSEQUENCEINFOA = extern struct {
    szPatchData: ?[*:0]const u8,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const MSIPATCHSEQUENCEINFOW = extern struct {
    szPatchData: ?[*:0]const u16,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const SCRIPTFLAGS = enum(i32) {
    CACHEINFO = 1,
    SHORTCUTS = 4,
    MACHINEASSIGN = 8,
    REGDATA_CNFGINFO = 32,
    VALIDATE_TRANSFORMS_LIST = 64,
    REGDATA_CLASSINFO = 128,
    REGDATA_EXTENSIONINFO = 256,
    REGDATA_APPINFO = 384,
    REGDATA = 416,
};
pub const SCRIPTFLAGS_CACHEINFO = SCRIPTFLAGS.CACHEINFO;
pub const SCRIPTFLAGS_SHORTCUTS = SCRIPTFLAGS.SHORTCUTS;
pub const SCRIPTFLAGS_MACHINEASSIGN = SCRIPTFLAGS.MACHINEASSIGN;
pub const SCRIPTFLAGS_REGDATA_CNFGINFO = SCRIPTFLAGS.REGDATA_CNFGINFO;
pub const SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST = SCRIPTFLAGS.VALIDATE_TRANSFORMS_LIST;
pub const SCRIPTFLAGS_REGDATA_CLASSINFO = SCRIPTFLAGS.REGDATA_CLASSINFO;
pub const SCRIPTFLAGS_REGDATA_EXTENSIONINFO = SCRIPTFLAGS.REGDATA_EXTENSIONINFO;
pub const SCRIPTFLAGS_REGDATA_APPINFO = SCRIPTFLAGS.REGDATA_APPINFO;
pub const SCRIPTFLAGS_REGDATA = SCRIPTFLAGS.REGDATA;

pub const ADVERTISEFLAGS = enum(i32) {
    MACHINEASSIGN = 0,
    USERASSIGN = 1,
};
pub const ADVERTISEFLAGS_MACHINEASSIGN = ADVERTISEFLAGS.MACHINEASSIGN;
pub const ADVERTISEFLAGS_USERASSIGN = ADVERTISEFLAGS.USERASSIGN;

pub const INSTALLTYPE = enum(i32) {
    DEFAULT = 0,
    NETWORK_IMAGE = 1,
    SINGLE_INSTANCE = 2,
};
pub const INSTALLTYPE_DEFAULT = INSTALLTYPE.DEFAULT;
pub const INSTALLTYPE_NETWORK_IMAGE = INSTALLTYPE.NETWORK_IMAGE;
pub const INSTALLTYPE_SINGLE_INSTANCE = INSTALLTYPE.SINGLE_INSTANCE;

pub const MSIFILEHASHINFO = extern struct {
    dwFileHashInfoSize: u32,
    dwData: [4]u32,
};

pub const MSIARCHITECTUREFLAGS = enum(i32) {
    X86 = 1,
    IA64 = 2,
    AMD64 = 4,
    ARM = 8,
};
pub const MSIARCHITECTUREFLAGS_X86 = MSIARCHITECTUREFLAGS.X86;
pub const MSIARCHITECTUREFLAGS_IA64 = MSIARCHITECTUREFLAGS.IA64;
pub const MSIARCHITECTUREFLAGS_AMD64 = MSIARCHITECTUREFLAGS.AMD64;
pub const MSIARCHITECTUREFLAGS_ARM = MSIARCHITECTUREFLAGS.ARM;

pub const MSIOPENPACKAGEFLAGS = enum(i32) {
    E = 1,
};
pub const MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE = MSIOPENPACKAGEFLAGS.E;

pub const MSIADVERTISEOPTIONFLAGS = enum(i32) {
    E = 1,
};
pub const MSIADVERTISEOPTIONFLAGS_INSTANCE = MSIADVERTISEOPTIONFLAGS.E;

pub const MSISOURCETYPE = enum(i32) {
    UNKNOWN = 0,
    NETWORK = 1,
    URL = 2,
    MEDIA = 4,
};
pub const MSISOURCETYPE_UNKNOWN = MSISOURCETYPE.UNKNOWN;
pub const MSISOURCETYPE_NETWORK = MSISOURCETYPE.NETWORK;
pub const MSISOURCETYPE_URL = MSISOURCETYPE.URL;
pub const MSISOURCETYPE_MEDIA = MSISOURCETYPE.MEDIA;

pub const MSICODE = enum(i32) {
    RODUCT = 0,
    ATCH = 1073741824,
};
pub const MSICODE_PRODUCT = MSICODE.RODUCT;
pub const MSICODE_PATCH = MSICODE.ATCH;

pub const MSITRANSACTION = enum(i32) {
    CHAIN_EMBEDDEDUI = 1,
    JOIN_EXISTING_EMBEDDEDUI = 2,
};
pub const MSITRANSACTION_CHAIN_EMBEDDEDUI = MSITRANSACTION.CHAIN_EMBEDDEDUI;
pub const MSITRANSACTION_JOIN_EXISTING_EMBEDDEDUI = MSITRANSACTION.JOIN_EXISTING_EMBEDDEDUI;

pub const MSITRANSACTIONSTATE = enum(u32) {
    ROLLBACK = 0,
    COMMIT = 1,
};
pub const MSITRANSACTIONSTATE_ROLLBACK = MSITRANSACTIONSTATE.ROLLBACK;
pub const MSITRANSACTIONSTATE_COMMIT = MSITRANSACTIONSTATE.COMMIT;

pub const MSIDBSTATE = enum(i32) {
    ERROR = -1,
    READ = 0,
    WRITE = 1,
};
pub const MSIDBSTATE_ERROR = MSIDBSTATE.ERROR;
pub const MSIDBSTATE_READ = MSIDBSTATE.READ;
pub const MSIDBSTATE_WRITE = MSIDBSTATE.WRITE;

pub const MSIMODIFY = enum(i32) {
    SEEK = -1,
    REFRESH = 0,
    INSERT = 1,
    UPDATE = 2,
    ASSIGN = 3,
    REPLACE = 4,
    MERGE = 5,
    DELETE = 6,
    INSERT_TEMPORARY = 7,
    VALIDATE = 8,
    VALIDATE_NEW = 9,
    VALIDATE_FIELD = 10,
    VALIDATE_DELETE = 11,
};
pub const MSIMODIFY_SEEK = MSIMODIFY.SEEK;
pub const MSIMODIFY_REFRESH = MSIMODIFY.REFRESH;
pub const MSIMODIFY_INSERT = MSIMODIFY.INSERT;
pub const MSIMODIFY_UPDATE = MSIMODIFY.UPDATE;
pub const MSIMODIFY_ASSIGN = MSIMODIFY.ASSIGN;
pub const MSIMODIFY_REPLACE = MSIMODIFY.REPLACE;
pub const MSIMODIFY_MERGE = MSIMODIFY.MERGE;
pub const MSIMODIFY_DELETE = MSIMODIFY.DELETE;
pub const MSIMODIFY_INSERT_TEMPORARY = MSIMODIFY.INSERT_TEMPORARY;
pub const MSIMODIFY_VALIDATE = MSIMODIFY.VALIDATE;
pub const MSIMODIFY_VALIDATE_NEW = MSIMODIFY.VALIDATE_NEW;
pub const MSIMODIFY_VALIDATE_FIELD = MSIMODIFY.VALIDATE_FIELD;
pub const MSIMODIFY_VALIDATE_DELETE = MSIMODIFY.VALIDATE_DELETE;

pub const MSICOLINFO = enum(i32) {
    NAMES = 0,
    TYPES = 1,
};
pub const MSICOLINFO_NAMES = MSICOLINFO.NAMES;
pub const MSICOLINFO_TYPES = MSICOLINFO.TYPES;

pub const MSICONDITION = enum(i32) {
    FALSE = 0,
    TRUE = 1,
    NONE = 2,
    ERROR = 3,
};
pub const MSICONDITION_FALSE = MSICONDITION.FALSE;
pub const MSICONDITION_TRUE = MSICONDITION.TRUE;
pub const MSICONDITION_NONE = MSICONDITION.NONE;
pub const MSICONDITION_ERROR = MSICONDITION.ERROR;

pub const MSICOSTTREE = enum(i32) {
    SELFONLY = 0,
    CHILDREN = 1,
    PARENTS = 2,
    RESERVED = 3,
};
pub const MSICOSTTREE_SELFONLY = MSICOSTTREE.SELFONLY;
pub const MSICOSTTREE_CHILDREN = MSICOSTTREE.CHILDREN;
pub const MSICOSTTREE_PARENTS = MSICOSTTREE.PARENTS;
pub const MSICOSTTREE_RESERVED = MSICOSTTREE.RESERVED;

pub const MSIDBERROR = enum(i32) {
    INVALIDARG = -3,
    MOREDATA = -2,
    FUNCTIONERROR = -1,
    NOERROR = 0,
    DUPLICATEKEY = 1,
    REQUIRED = 2,
    BADLINK = 3,
    OVERFLOW = 4,
    UNDERFLOW = 5,
    NOTINSET = 6,
    BADVERSION = 7,
    BADCASE = 8,
    BADGUID = 9,
    BADWILDCARD = 10,
    BADIDENTIFIER = 11,
    BADLANGUAGE = 12,
    BADFILENAME = 13,
    BADPATH = 14,
    BADCONDITION = 15,
    BADFORMATTED = 16,
    BADTEMPLATE = 17,
    BADDEFAULTDIR = 18,
    BADREGPATH = 19,
    BADCUSTOMSOURCE = 20,
    BADPROPERTY = 21,
    MISSINGDATA = 22,
    BADCATEGORY = 23,
    BADKEYTABLE = 24,
    BADMAXMINVALUES = 25,
    BADCABINET = 26,
    BADSHORTCUT = 27,
    STRINGOVERFLOW = 28,
    BADLOCALIZEATTRIB = 29,
};
pub const MSIDBERROR_INVALIDARG = MSIDBERROR.INVALIDARG;
pub const MSIDBERROR_MOREDATA = MSIDBERROR.MOREDATA;
pub const MSIDBERROR_FUNCTIONERROR = MSIDBERROR.FUNCTIONERROR;
pub const MSIDBERROR_NOERROR = MSIDBERROR.NOERROR;
pub const MSIDBERROR_DUPLICATEKEY = MSIDBERROR.DUPLICATEKEY;
pub const MSIDBERROR_REQUIRED = MSIDBERROR.REQUIRED;
pub const MSIDBERROR_BADLINK = MSIDBERROR.BADLINK;
pub const MSIDBERROR_OVERFLOW = MSIDBERROR.OVERFLOW;
pub const MSIDBERROR_UNDERFLOW = MSIDBERROR.UNDERFLOW;
pub const MSIDBERROR_NOTINSET = MSIDBERROR.NOTINSET;
pub const MSIDBERROR_BADVERSION = MSIDBERROR.BADVERSION;
pub const MSIDBERROR_BADCASE = MSIDBERROR.BADCASE;
pub const MSIDBERROR_BADGUID = MSIDBERROR.BADGUID;
pub const MSIDBERROR_BADWILDCARD = MSIDBERROR.BADWILDCARD;
pub const MSIDBERROR_BADIDENTIFIER = MSIDBERROR.BADIDENTIFIER;
pub const MSIDBERROR_BADLANGUAGE = MSIDBERROR.BADLANGUAGE;
pub const MSIDBERROR_BADFILENAME = MSIDBERROR.BADFILENAME;
pub const MSIDBERROR_BADPATH = MSIDBERROR.BADPATH;
pub const MSIDBERROR_BADCONDITION = MSIDBERROR.BADCONDITION;
pub const MSIDBERROR_BADFORMATTED = MSIDBERROR.BADFORMATTED;
pub const MSIDBERROR_BADTEMPLATE = MSIDBERROR.BADTEMPLATE;
pub const MSIDBERROR_BADDEFAULTDIR = MSIDBERROR.BADDEFAULTDIR;
pub const MSIDBERROR_BADREGPATH = MSIDBERROR.BADREGPATH;
pub const MSIDBERROR_BADCUSTOMSOURCE = MSIDBERROR.BADCUSTOMSOURCE;
pub const MSIDBERROR_BADPROPERTY = MSIDBERROR.BADPROPERTY;
pub const MSIDBERROR_MISSINGDATA = MSIDBERROR.MISSINGDATA;
pub const MSIDBERROR_BADCATEGORY = MSIDBERROR.BADCATEGORY;
pub const MSIDBERROR_BADKEYTABLE = MSIDBERROR.BADKEYTABLE;
pub const MSIDBERROR_BADMAXMINVALUES = MSIDBERROR.BADMAXMINVALUES;
pub const MSIDBERROR_BADCABINET = MSIDBERROR.BADCABINET;
pub const MSIDBERROR_BADSHORTCUT = MSIDBERROR.BADSHORTCUT;
pub const MSIDBERROR_STRINGOVERFLOW = MSIDBERROR.STRINGOVERFLOW;
pub const MSIDBERROR_BADLOCALIZEATTRIB = MSIDBERROR.BADLOCALIZEATTRIB;

pub const MSIRUNMODE = enum(i32) {
    ADMIN = 0,
    ADVERTISE = 1,
    MAINTENANCE = 2,
    ROLLBACKENABLED = 3,
    LOGENABLED = 4,
    OPERATIONS = 5,
    REBOOTATEND = 6,
    REBOOTNOW = 7,
    CABINET = 8,
    SOURCESHORTNAMES = 9,
    TARGETSHORTNAMES = 10,
    RESERVED11 = 11,
    WINDOWS9X = 12,
    ZAWENABLED = 13,
    RESERVED14 = 14,
    RESERVED15 = 15,
    SCHEDULED = 16,
    ROLLBACK = 17,
    COMMIT = 18,
};
pub const MSIRUNMODE_ADMIN = MSIRUNMODE.ADMIN;
pub const MSIRUNMODE_ADVERTISE = MSIRUNMODE.ADVERTISE;
pub const MSIRUNMODE_MAINTENANCE = MSIRUNMODE.MAINTENANCE;
pub const MSIRUNMODE_ROLLBACKENABLED = MSIRUNMODE.ROLLBACKENABLED;
pub const MSIRUNMODE_LOGENABLED = MSIRUNMODE.LOGENABLED;
pub const MSIRUNMODE_OPERATIONS = MSIRUNMODE.OPERATIONS;
pub const MSIRUNMODE_REBOOTATEND = MSIRUNMODE.REBOOTATEND;
pub const MSIRUNMODE_REBOOTNOW = MSIRUNMODE.REBOOTNOW;
pub const MSIRUNMODE_CABINET = MSIRUNMODE.CABINET;
pub const MSIRUNMODE_SOURCESHORTNAMES = MSIRUNMODE.SOURCESHORTNAMES;
pub const MSIRUNMODE_TARGETSHORTNAMES = MSIRUNMODE.TARGETSHORTNAMES;
pub const MSIRUNMODE_RESERVED11 = MSIRUNMODE.RESERVED11;
pub const MSIRUNMODE_WINDOWS9X = MSIRUNMODE.WINDOWS9X;
pub const MSIRUNMODE_ZAWENABLED = MSIRUNMODE.ZAWENABLED;
pub const MSIRUNMODE_RESERVED14 = MSIRUNMODE.RESERVED14;
pub const MSIRUNMODE_RESERVED15 = MSIRUNMODE.RESERVED15;
pub const MSIRUNMODE_SCHEDULED = MSIRUNMODE.SCHEDULED;
pub const MSIRUNMODE_ROLLBACK = MSIRUNMODE.ROLLBACK;
pub const MSIRUNMODE_COMMIT = MSIRUNMODE.COMMIT;

pub const MSITRANSFORM_ERROR = enum(i32) {
    ADDEXISTINGROW = 1,
    DELMISSINGROW = 2,
    ADDEXISTINGTABLE = 4,
    DELMISSINGTABLE = 8,
    UPDATEMISSINGROW = 16,
    CHANGECODEPAGE = 32,
    VIEWTRANSFORM = 256,
    NONE = 0,
};
pub const MSITRANSFORM_ERROR_ADDEXISTINGROW = MSITRANSFORM_ERROR.ADDEXISTINGROW;
pub const MSITRANSFORM_ERROR_DELMISSINGROW = MSITRANSFORM_ERROR.DELMISSINGROW;
pub const MSITRANSFORM_ERROR_ADDEXISTINGTABLE = MSITRANSFORM_ERROR.ADDEXISTINGTABLE;
pub const MSITRANSFORM_ERROR_DELMISSINGTABLE = MSITRANSFORM_ERROR.DELMISSINGTABLE;
pub const MSITRANSFORM_ERROR_UPDATEMISSINGROW = MSITRANSFORM_ERROR.UPDATEMISSINGROW;
pub const MSITRANSFORM_ERROR_CHANGECODEPAGE = MSITRANSFORM_ERROR.CHANGECODEPAGE;
pub const MSITRANSFORM_ERROR_VIEWTRANSFORM = MSITRANSFORM_ERROR.VIEWTRANSFORM;
pub const MSITRANSFORM_ERROR_NONE = MSITRANSFORM_ERROR.NONE;

pub const MSITRANSFORM_VALIDATE = enum(i32) {
    LANGUAGE = 1,
    PRODUCT = 2,
    PLATFORM = 4,
    MAJORVERSION = 8,
    MINORVERSION = 16,
    UPDATEVERSION = 32,
    NEWLESSBASEVERSION = 64,
    NEWLESSEQUALBASEVERSION = 128,
    NEWEQUALBASEVERSION = 256,
    NEWGREATEREQUALBASEVERSION = 512,
    NEWGREATERBASEVERSION = 1024,
    UPGRADECODE = 2048,
};
pub const MSITRANSFORM_VALIDATE_LANGUAGE = MSITRANSFORM_VALIDATE.LANGUAGE;
pub const MSITRANSFORM_VALIDATE_PRODUCT = MSITRANSFORM_VALIDATE.PRODUCT;
pub const MSITRANSFORM_VALIDATE_PLATFORM = MSITRANSFORM_VALIDATE.PLATFORM;
pub const MSITRANSFORM_VALIDATE_MAJORVERSION = MSITRANSFORM_VALIDATE.MAJORVERSION;
pub const MSITRANSFORM_VALIDATE_MINORVERSION = MSITRANSFORM_VALIDATE.MINORVERSION;
pub const MSITRANSFORM_VALIDATE_UPDATEVERSION = MSITRANSFORM_VALIDATE.UPDATEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATEREQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATERBASEVERSION;
pub const MSITRANSFORM_VALIDATE_UPGRADECODE = MSITRANSFORM_VALIDATE.UPGRADECODE;

pub const ASSEMBLY_INFO = extern struct {
    cbAssemblyInfo: u32,
    dwAssemblyFlags: u32,
    uliAssemblySizeInKB: ULARGE_INTEGER,
    pszCurrentAssemblyPathBuf: ?PWSTR,
    cchBuf: u32,
};

pub const FUSION_INSTALL_REFERENCE = extern struct {
    cbSize: u32,
    dwFlags: u32,
    guidScheme: Guid,
    szIdentifier: ?[*:0]const u16,
    szNonCannonicalData: ?[*:0]const u16,
};

pub const ASM_NAME = enum(i32) {
    PUBLIC_KEY = 0,
    PUBLIC_KEY_TOKEN = 1,
    HASH_VALUE = 2,
    NAME = 3,
    MAJOR_VERSION = 4,
    MINOR_VERSION = 5,
    BUILD_NUMBER = 6,
    REVISION_NUMBER = 7,
    CULTURE = 8,
    PROCESSOR_ID_ARRAY = 9,
    OSINFO_ARRAY = 10,
    HASH_ALGID = 11,
    ALIAS = 12,
    CODEBASE_URL = 13,
    CODEBASE_LASTMOD = 14,
    NULL_PUBLIC_KEY = 15,
    NULL_PUBLIC_KEY_TOKEN = 16,
    CUSTOM = 17,
    NULL_CUSTOM = 18,
    MVID = 19,
    MAX_PARAMS = 20,
};
pub const ASM_NAME_PUBLIC_KEY = ASM_NAME.PUBLIC_KEY;
pub const ASM_NAME_PUBLIC_KEY_TOKEN = ASM_NAME.PUBLIC_KEY_TOKEN;
pub const ASM_NAME_HASH_VALUE = ASM_NAME.HASH_VALUE;
pub const ASM_NAME_NAME = ASM_NAME.NAME;
pub const ASM_NAME_MAJOR_VERSION = ASM_NAME.MAJOR_VERSION;
pub const ASM_NAME_MINOR_VERSION = ASM_NAME.MINOR_VERSION;
pub const ASM_NAME_BUILD_NUMBER = ASM_NAME.BUILD_NUMBER;
pub const ASM_NAME_REVISION_NUMBER = ASM_NAME.REVISION_NUMBER;
pub const ASM_NAME_CULTURE = ASM_NAME.CULTURE;
pub const ASM_NAME_PROCESSOR_ID_ARRAY = ASM_NAME.PROCESSOR_ID_ARRAY;
pub const ASM_NAME_OSINFO_ARRAY = ASM_NAME.OSINFO_ARRAY;
pub const ASM_NAME_HASH_ALGID = ASM_NAME.HASH_ALGID;
pub const ASM_NAME_ALIAS = ASM_NAME.ALIAS;
pub const ASM_NAME_CODEBASE_URL = ASM_NAME.CODEBASE_URL;
pub const ASM_NAME_CODEBASE_LASTMOD = ASM_NAME.CODEBASE_LASTMOD;
pub const ASM_NAME_NULL_PUBLIC_KEY = ASM_NAME.NULL_PUBLIC_KEY;
pub const ASM_NAME_NULL_PUBLIC_KEY_TOKEN = ASM_NAME.NULL_PUBLIC_KEY_TOKEN;
pub const ASM_NAME_CUSTOM = ASM_NAME.CUSTOM;
pub const ASM_NAME_NULL_CUSTOM = ASM_NAME.NULL_CUSTOM;
pub const ASM_NAME_MVID = ASM_NAME.MVID;
pub const ASM_NAME_MAX_PARAMS = ASM_NAME.MAX_PARAMS;

pub const ASM_BIND_FLAGS = packed struct(u32) {
    FORCE_CACHE_INSTALL: u1 = 0,
    RFS_INTEGRITY_CHECK: u1 = 0,
    RFS_MODULE_CHECK: u1 = 0,
    BINPATH_PROBE_ONLY: u1 = 0,
    SHARED_BINPATH_HINT: u1 = 0,
    PARENT_ASM_HINT: u1 = 0,
    _6: u1 = 0,
    _7: u1 = 0,
    _8: u1 = 0,
    _9: u1 = 0,
    _10: u1 = 0,
    _11: u1 = 0,
    _12: u1 = 0,
    _13: u1 = 0,
    _14: u1 = 0,
    _15: u1 = 0,
    _16: u1 = 0,
    _17: u1 = 0,
    _18: u1 = 0,
    _19: u1 = 0,
    _20: u1 = 0,
    _21: u1 = 0,
    _22: u1 = 0,
    _23: u1 = 0,
    _24: u1 = 0,
    _25: u1 = 0,
    _26: u1 = 0,
    _27: u1 = 0,
    _28: u1 = 0,
    _29: u1 = 0,
    _30: u1 = 0,
    _31: u1 = 0,
};
pub const ASM_BINDF_FORCE_CACHE_INSTALL = ASM_BIND_FLAGS{ .FORCE_CACHE_INSTALL = 1 };
pub const ASM_BINDF_RFS_INTEGRITY_CHECK = ASM_BIND_FLAGS{ .RFS_INTEGRITY_CHECK = 1 };
pub const ASM_BINDF_RFS_MODULE_CHECK = ASM_BIND_FLAGS{ .RFS_MODULE_CHECK = 1 };
pub const ASM_BINDF_BINPATH_PROBE_ONLY = ASM_BIND_FLAGS{ .BINPATH_PROBE_ONLY = 1 };
pub const ASM_BINDF_SHARED_BINPATH_HINT = ASM_BIND_FLAGS{ .SHARED_BINPATH_HINT = 1 };
pub const ASM_BINDF_PARENT_ASM_HINT = ASM_BIND_FLAGS{ .PARENT_ASM_HINT = 1 };

pub const ASM_DISPLAY_FLAGS = enum(i32) {
    VERSION = 1,
    CULTURE = 2,
    PUBLIC_KEY_TOKEN = 4,
    PUBLIC_KEY = 8,
    CUSTOM = 16,
    PROCESSORARCHITECTURE = 32,
    LANGUAGEID = 64,
};
pub const ASM_DISPLAYF_VERSION = ASM_DISPLAY_FLAGS.VERSION;
pub const ASM_DISPLAYF_CULTURE = ASM_DISPLAY_FLAGS.CULTURE;
pub const ASM_DISPLAYF_PUBLIC_KEY_TOKEN = ASM_DISPLAY_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_DISPLAYF_PUBLIC_KEY = ASM_DISPLAY_FLAGS.PUBLIC_KEY;
pub const ASM_DISPLAYF_CUSTOM = ASM_DISPLAY_FLAGS.CUSTOM;
pub const ASM_DISPLAYF_PROCESSORARCHITECTURE = ASM_DISPLAY_FLAGS.PROCESSORARCHITECTURE;
pub const ASM_DISPLAYF_LANGUAGEID = ASM_DISPLAY_FLAGS.LANGUAGEID;

pub const ASM_CMP_FLAGS = enum(i32) {
    NAME = 1,
    MAJOR_VERSION = 2,
    MINOR_VERSION = 4,
    BUILD_NUMBER = 8,
    REVISION_NUMBER = 16,
    PUBLIC_KEY_TOKEN = 32,
    CULTURE = 64,
    CUSTOM = 128,
    ALL = 255,
    DEFAULT = 256,
};
pub const ASM_CMPF_NAME = ASM_CMP_FLAGS.NAME;
pub const ASM_CMPF_MAJOR_VERSION = ASM_CMP_FLAGS.MAJOR_VERSION;
pub const ASM_CMPF_MINOR_VERSION = ASM_CMP_FLAGS.MINOR_VERSION;
pub const ASM_CMPF_BUILD_NUMBER = ASM_CMP_FLAGS.BUILD_NUMBER;
pub const ASM_CMPF_REVISION_NUMBER = ASM_CMP_FLAGS.REVISION_NUMBER;
pub const ASM_CMPF_PUBLIC_KEY_TOKEN = ASM_CMP_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_CMPF_CULTURE = ASM_CMP_FLAGS.CULTURE;
pub const ASM_CMPF_CUSTOM = ASM_CMP_FLAGS.CUSTOM;
pub const ASM_CMPF_ALL = ASM_CMP_FLAGS.ALL;
pub const ASM_CMPF_DEFAULT = ASM_CMP_FLAGS.DEFAULT;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyName_Value = Guid.initString("cd193bc0-b4bc-11d2-9833-00c04fc31d2e");
pub const IID_IAssemblyName = &IID_IAssemblyName_Value;
pub const IAssemblyName = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperty: *const fn(
            self: *const IAssemblyName,
            PropertyId: u32,
            pvProperty: ?*anyopaque,
            cbProperty: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: *const fn(
            self: *const IAssemblyName,
            PropertyId: u32,
            pvProperty: ?*anyopaque,
            pcbProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: *const fn(
            self: *const IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: *const fn(
            self: *const IAssemblyName,
            szDisplayName: ?[*:0]u16,
            pccDisplayName: ?*u32,
            dwDisplayFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: *const fn(
            self: *const IAssemblyName,
            refIID: ?*const Guid,
            pUnkReserved1: ?*IUnknown,
            pUnkReserved2: ?*IUnknown,
            szReserved: ?[*:0]const u16,
            llReserved: i64,
            pvReserved: ?*anyopaque,
            cbReserved: u32,
            ppReserved: ?*?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: *const fn(
            self: *const IAssemblyName,
            lpcwBuffer: ?*u32,
            pwzName: ?[*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: *const fn(
            self: *const IAssemblyName,
            pdwVersionHi: ?*u32,
            pdwVersionLow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: *const fn(
            self: *const IAssemblyName,
            pName: ?*IAssemblyName,
            dwCmpFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: *const fn(
            self: *const IAssemblyName,
            pName: ?*?*IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn SetProperty(self: *const IAssemblyName, PropertyId: u32, pvProperty: ?*anyopaque, cbProperty: u32) callconv(.Inline) HRESULT {
        return self.vtable.SetProperty(self, PropertyId, pvProperty, cbProperty);
    }
    pub fn GetProperty(self: *const IAssemblyName, PropertyId: u32, pvProperty: ?*anyopaque, pcbProperty: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetProperty(self, PropertyId, pvProperty, pcbProperty);
    }
    pub fn Finalize(self: *const IAssemblyName) callconv(.Inline) HRESULT {
        return self.vtable.Finalize(self);
    }
    pub fn GetDisplayName(self: *const IAssemblyName, szDisplayName: ?[*:0]u16, pccDisplayName: ?*u32, dwDisplayFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.GetDisplayName(self, szDisplayName, pccDisplayName, dwDisplayFlags);
    }
    pub fn Reserved(self: *const IAssemblyName, refIID: ?*const Guid, pUnkReserved1: ?*IUnknown, pUnkReserved2: ?*IUnknown, szReserved: ?[*:0]const u16, llReserved: i64, pvReserved: ?*anyopaque, cbReserved: u32, ppReserved: ?*?*anyopaque) callconv(.Inline) HRESULT {
        return self.vtable.Reserved(self, refIID, pUnkReserved1, pUnkReserved2, szReserved, llReserved, pvReserved, cbReserved, ppReserved);
    }
    pub fn GetName(self: *const IAssemblyName, lpcwBuffer: ?*u32, pwzName: ?[*:0]u16) callconv(.Inline) HRESULT {
        return self.vtable.GetName(self, lpcwBuffer, pwzName);
    }
    pub fn GetVersion(self: *const IAssemblyName, pdwVersionHi: ?*u32, pdwVersionLow: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetVersion(self, pdwVersionHi, pdwVersionLow);
    }
    pub fn IsEqual(self: *const IAssemblyName, pName: ?*IAssemblyName, dwCmpFlags: u32) callconv(.Inline) HRESULT {
        return self.vtable.IsEqual(self, pName, dwCmpFlags);
    }
    pub fn Clone(self: *const IAssemblyName, pName: ?*?*IAssemblyName) callconv(.Inline) HRESULT {
        return self.vtable.Clone(self, pName);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCacheItem_Value = Guid.initString("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCacheItem = &IID_IAssemblyCacheItem_Value;
pub const IAssemblyCacheItem = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: *const fn(
            self: *const IAssemblyCacheItem,
            dwFlags: u32,
            pszStreamName: ?[*:0]const u16,
            dwFormat: u32,
            dwFormatFlags: u32,
            ppIStream: ?*?*IStream,
            puliMaxSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: *const fn(
            self: *const IAssemblyCacheItem,
            dwFlags: u32,
            pulDisposition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItem: *const fn(
            self: *const IAssemblyCacheItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn CreateStream(self: *const IAssemblyCacheItem, dwFlags: u32, pszStreamName: ?[*:0]const u16, dwFormat: u32, dwFormatFlags: u32, ppIStream: ?*?*IStream, puliMaxSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
        return self.vtable.CreateStream(self, dwFlags, pszStreamName, dwFormat, dwFormatFlags, ppIStream, puliMaxSize);
    }
    pub fn Commit(self: *const IAssemblyCacheItem, dwFlags: u32, pulDisposition: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.Commit(self, dwFlags, pulDisposition);
    }
    pub fn AbortItem(self: *const IAssemblyCacheItem) callconv(.Inline) HRESULT {
        return self.vtable.AbortItem(self);
    }
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCache_Value = Guid.initString("e707dcde-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCache = &IID_IAssemblyCache_Value;
pub const IAssemblyCache = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UninstallAssembly: *const fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pszAssemblyName: ?[*:0]const u16,
            pRefData: ?*FUSION_INSTALL_REFERENCE,
            pulDisposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssemblyInfo: *const fn(
            self: *const IAssemblyCache,
            dwFlags: QUERYASMINFO_FLAGS,
            pszAssemblyName: ?[*:0]const u16,
            pAsmInfo: ?*ASSEMBLY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAssemblyCacheItem: *const fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pvReserved: ?*anyopaque,
            ppAsmItem: ?*?*IAssemblyCacheItem,
            pszAssemblyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: *const fn(
            self: *const IAssemblyCache,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallAssembly: *const fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pszManifestFilePath: ?[*:0]const u16,
            pRefData: ?*FUSION_INSTALL_REFERENCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn UninstallAssembly(self: *const IAssemblyCache, dwFlags: u32, pszAssemblyName: ?[*:0]const u16, pRefData: ?*FUSION_INSTALL_REFERENCE, pulDisposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION) callconv(.Inline) HRESULT {
        return self.vtable.UninstallAssembly(self, dwFlags, pszAssemblyName, pRefData, pulDisposition);
    }
    pub fn QueryAssemblyInfo(self: *const IAssemblyCache, dwFlags: QUERYASMINFO_FLAGS, pszAssemblyName: ?[*:0]const u16, pAsmInfo: ?*ASSEMBLY_INFO) callconv(.Inline) HRESULT {
        return self.vtable.QueryAssemblyInfo(self, dwFlags, pszAssemblyName, pAsmInfo);
    }
    pub fn CreateAssemblyCacheItem(self: *const IAssemblyCache, dwFlags: u32, pvReserved: ?*anyopaque, ppAsmItem: ?*?*IAssemblyCacheItem, pszAssemblyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
        return self.vtable.CreateAssemblyCacheItem(self, dwFlags, pvReserved, ppAsmItem, pszAssemblyName);
    }
    pub fn Reserved(self: *const IAssemblyCache, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
        return self.vtable.Reserved(self, ppUnk);
    }
    pub fn InstallAssembly(self: *const IAssemblyCache, dwFlags: u32, pszManifestFilePath: ?[*:0]const u16, pRefData: ?*FUSION_INSTALL_REFERENCE) callconv(.Inline) HRESULT {
        return self.vtable.InstallAssembly(self, dwFlags, pszManifestFilePath, pRefData);
    }
};

pub const CREATE_ASM_NAME_OBJ_FLAGS = enum(i32) {
    PARSE_DISPLAY_NAME = 1,
    SET_DEFAULT_VALUES = 2,
};
pub const CANOF_PARSE_DISPLAY_NAME = CREATE_ASM_NAME_OBJ_FLAGS.PARSE_DISPLAY_NAME;
pub const CANOF_SET_DEFAULT_VALUES = CREATE_ASM_NAME_OBJ_FLAGS.SET_DEFAULT_VALUES;

pub const PROTECTED_FILE_DATA = extern struct {
    FileName: [260]u16,
    FileNumber: u32,
};

pub const msidbControlAttributes = enum(i32) {
    AttributesVisible = 1,
    AttributesEnabled = 2,
    AttributesSunken = 4,
    AttributesIndirect = 8,
    AttributesInteger = 16,
    AttributesRTLRO = 32,
    AttributesRightAligned = 64,
    AttributesLeftScroll = 128,
    AttributesBiDi = 224,
    AttributesTransparent = 65536,
    AttributesNoPrefix = 131072,
    AttributesNoWrap = 262144,
    AttributesFormatSize = 524288,
    AttributesUsersLanguage = 1048576,
    AttributesPasswordInput = 2097152,
    ShowRollbackCost = 4194304,
    AttributesIconSize48 = 6291456,
    AttributesElevationShield = 8388608,
    AttributesHasBorder = 16777216,
    pub const AttributesMultiline = .AttributesTransparent;
    pub const AttributesProgress95 = .AttributesTransparent;
    pub const AttributesRemovableVolume = .AttributesTransparent;
    pub const AttributesFixedVolume = .AttributesNoPrefix;
    pub const AttributesRemoteVolume = .AttributesNoWrap;
    pub const AttributesCDROMVolume = .AttributesFormatSize;
    pub const AttributesRAMDiskVolume = .AttributesUsersLanguage;
    pub const AttributesFloppyVolume = .AttributesPasswordInput;
    pub const AttributesSorted = .AttributesTransparent;
    pub const AttributesComboList = .AttributesNoPrefix;
    pub const AttributesImageHandle = .AttributesTransparent;
    pub const AttributesPushLike = .AttributesNoPrefix;
    pub const AttributesBitmap = .AttributesNoWrap;
    pub const AttributesIcon = .AttributesFormatSize;
    pub const AttributesFixedSize = .AttributesUsersLanguage;
    pub const AttributesIconSize16 = .AttributesPasswordInput;
    pub const AttributesIconSize32 = .ShowRollbackCost;
};
pub const msidbControlAttributesVisible = msidbControlAttributes.AttributesVisible;
pub const msidbControlAttributesEnabled = msidbControlAttributes.AttributesEnabled;
pub const msidbControlAttributesSunken = msidbControlAttributes.AttributesSunken;
pub const msidbControlAttributesIndirect = msidbControlAttributes.AttributesIndirect;
pub const msidbControlAttributesInteger = msidbControlAttributes.AttributesInteger;
pub const msidbControlAttributesRTLRO = msidbControlAttributes.AttributesRTLRO;
pub const msidbControlAttributesRightAligned = msidbControlAttributes.AttributesRightAligned;
pub const msidbControlAttributesLeftScroll = msidbControlAttributes.AttributesLeftScroll;
pub const msidbControlAttributesBiDi = msidbControlAttributes.AttributesBiDi;
pub const msidbControlAttributesTransparent = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesNoPrefix = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesNoWrap = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesFormatSize = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesUsersLanguage = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesMultiline = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesPasswordInput = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlAttributesProgress95 = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesRemovableVolume = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesFixedVolume = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesRemoteVolume = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesCDROMVolume = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesRAMDiskVolume = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesFloppyVolume = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlShowRollbackCost = msidbControlAttributes.ShowRollbackCost;
pub const msidbControlAttributesSorted = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesComboList = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesImageHandle = msidbControlAttributes.AttributesTransparent;
pub const msidbControlAttributesPushLike = msidbControlAttributes.AttributesNoPrefix;
pub const msidbControlAttributesBitmap = msidbControlAttributes.AttributesNoWrap;
pub const msidbControlAttributesIcon = msidbControlAttributes.AttributesFormatSize;
pub const msidbControlAttributesFixedSize = msidbControlAttributes.AttributesUsersLanguage;
pub const msidbControlAttributesIconSize16 = msidbControlAttributes.AttributesPasswordInput;
pub const msidbControlAttributesIconSize32 = msidbControlAttributes.ShowRollbackCost;
pub const msidbControlAttributesIconSize48 = msidbControlAttributes.AttributesIconSize48;
pub const msidbControlAttributesElevationShield = msidbControlAttributes.AttributesElevationShield;
pub const msidbControlAttributesHasBorder = msidbControlAttributes.AttributesHasBorder;

pub const msidbLocatorType = enum(i32) {
    Directory = 0,
    FileName = 1,
    RawValue = 2,
    @"64bit" = 16,
};
pub const msidbLocatorTypeDirectory = msidbLocatorType.Directory;
pub const msidbLocatorTypeFileName = msidbLocatorType.FileName;
pub const msidbLocatorTypeRawValue = msidbLocatorType.RawValue;
pub const msidbLocatorType64bit = msidbLocatorType.@"64bit";

pub const msidbComponentAttributes = enum(i32) {
    LocalOnly = 0,
    SourceOnly = 1,
    Optional = 2,
    RegistryKeyPath = 4,
    SharedDllRefCount = 8,
    Permanent = 16,
    ODBCDataSource = 32,
    Transitive = 64,
    NeverOverwrite = 128,
    @"64bit" = 256,
    DisableRegistryReflection = 512,
    UninstallOnSupersedence = 1024,
    Shared = 2048,
};
pub const msidbComponentAttributesLocalOnly = msidbComponentAttributes.LocalOnly;
pub const msidbComponentAttributesSourceOnly = msidbComponentAttributes.SourceOnly;
pub const msidbComponentAttributesOptional = msidbComponentAttributes.Optional;
pub const msidbComponentAttributesRegistryKeyPath = msidbComponentAttributes.RegistryKeyPath;
pub const msidbComponentAttributesSharedDllRefCount = msidbComponentAttributes.SharedDllRefCount;
pub const msidbComponentAttributesPermanent = msidbComponentAttributes.Permanent;
pub const msidbComponentAttributesODBCDataSource = msidbComponentAttributes.ODBCDataSource;
pub const msidbComponentAttributesTransitive = msidbComponentAttributes.Transitive;
pub const msidbComponentAttributesNeverOverwrite = msidbComponentAttributes.NeverOverwrite;
pub const msidbComponentAttributes64bit = msidbComponentAttributes.@"64bit";
pub const msidbComponentAttributesDisableRegistryReflection = msidbComponentAttributes.DisableRegistryReflection;
pub const msidbComponentAttributesUninstallOnSupersedence = msidbComponentAttributes.UninstallOnSupersedence;
pub const msidbComponentAttributesShared = msidbComponentAttributes.Shared;

pub const msidbAssemblyAttributes = enum(i32) {
    URT = 0,
    Win32 = 1,
};
pub const msidbAssemblyAttributesURT = msidbAssemblyAttributes.URT;
pub const msidbAssemblyAttributesWin32 = msidbAssemblyAttributes.Win32;

pub const msidbCustomActionType = enum(i32) {
    Dll = 1,
    Exe = 2,
    TextData = 3,
    JScript = 5,
    VBScript = 6,
    Install = 7,
    BinaryData = 0,
    SourceFile = 16,
    Directory = 32,
    Property = 48,
    Continue = 64,
    Async = 128,
    FirstSequence = 256,
    OncePerProcess = 512,
    ClientRepeat = 768,
    InScript = 1024,
    NoImpersonate = 2048,
    TSAware = 16384,
    @"64BitScript" = 4096,
    HideTarget = 8192,
    PatchUninstall = 32768,
    pub const Rollback = .FirstSequence;
    pub const Commit = .OncePerProcess;
};
pub const msidbCustomActionTypeDll = msidbCustomActionType.Dll;
pub const msidbCustomActionTypeExe = msidbCustomActionType.Exe;
pub const msidbCustomActionTypeTextData = msidbCustomActionType.TextData;
pub const msidbCustomActionTypeJScript = msidbCustomActionType.JScript;
pub const msidbCustomActionTypeVBScript = msidbCustomActionType.VBScript;
pub const msidbCustomActionTypeInstall = msidbCustomActionType.Install;
pub const msidbCustomActionTypeBinaryData = msidbCustomActionType.BinaryData;
pub const msidbCustomActionTypeSourceFile = msidbCustomActionType.SourceFile;
pub const msidbCustomActionTypeDirectory = msidbCustomActionType.Directory;
pub const msidbCustomActionTypeProperty = msidbCustomActionType.Property;
pub const msidbCustomActionTypeContinue = msidbCustomActionType.Continue;
pub const msidbCustomActionTypeAsync = msidbCustomActionType.Async;
pub const msidbCustomActionTypeFirstSequence = msidbCustomActionType.FirstSequence;
pub const msidbCustomActionTypeOncePerProcess = msidbCustomActionType.OncePerProcess;
pub const msidbCustomActionTypeClientRepeat = msidbCustomActionType.ClientRepeat;
pub const msidbCustomActionTypeInScript = msidbCustomActionType.InScript;
pub const msidbCustomActionTypeRollback = msidbCustomActionType.FirstSequence;
pub const msidbCustomActionTypeCommit = msidbCustomActionType.OncePerProcess;
pub const msidbCustomActionTypeNoImpersonate = msidbCustomActionType.NoImpersonate;
pub const msidbCustomActionTypeTSAware = msidbCustomActionType.TSAware;
pub const msidbCustomActionType64BitScript = msidbCustomActionType.@"64BitScript";
pub const msidbCustomActionTypeHideTarget = msidbCustomActionType.HideTarget;
pub const msidbCustomActionTypePatchUninstall = msidbCustomActionType.PatchUninstall;

pub const msidbDialogAttributes = enum(i32) {
    Visible = 1,
    Modal = 2,
    Minimize = 4,
    SysModal = 8,
    KeepModeless = 16,
    TrackDiskSpace = 32,
    UseCustomPalette = 64,
    RTLRO = 128,
    RightAligned = 256,
    LeftScroll = 512,
    BiDi = 896,
    Error = 65536,
};
pub const msidbDialogAttributesVisible = msidbDialogAttributes.Visible;
pub const msidbDialogAttributesModal = msidbDialogAttributes.Modal;
pub const msidbDialogAttributesMinimize = msidbDialogAttributes.Minimize;
pub const msidbDialogAttributesSysModal = msidbDialogAttributes.SysModal;
pub const msidbDialogAttributesKeepModeless = msidbDialogAttributes.KeepModeless;
pub const msidbDialogAttributesTrackDiskSpace = msidbDialogAttributes.TrackDiskSpace;
pub const msidbDialogAttributesUseCustomPalette = msidbDialogAttributes.UseCustomPalette;
pub const msidbDialogAttributesRTLRO = msidbDialogAttributes.RTLRO;
pub const msidbDialogAttributesRightAligned = msidbDialogAttributes.RightAligned;
pub const msidbDialogAttributesLeftScroll = msidbDialogAttributes.LeftScroll;
pub const msidbDialogAttributesBiDi = msidbDialogAttributes.BiDi;
pub const msidbDialogAttributesError = msidbDialogAttributes.Error;

pub const msidbFeatureAttributes = enum(i32) {
    FavorLocal = 0,
    FavorSource = 1,
    FollowParent = 2,
    FavorAdvertise = 4,
    DisallowAdvertise = 8,
    UIDisallowAbsent = 16,
    NoUnsupportedAdvertise = 32,
};
pub const msidbFeatureAttributesFavorLocal = msidbFeatureAttributes.FavorLocal;
pub const msidbFeatureAttributesFavorSource = msidbFeatureAttributes.FavorSource;
pub const msidbFeatureAttributesFollowParent = msidbFeatureAttributes.FollowParent;
pub const msidbFeatureAttributesFavorAdvertise = msidbFeatureAttributes.FavorAdvertise;
pub const msidbFeatureAttributesDisallowAdvertise = msidbFeatureAttributes.DisallowAdvertise;
pub const msidbFeatureAttributesUIDisallowAbsent = msidbFeatureAttributes.UIDisallowAbsent;
pub const msidbFeatureAttributesNoUnsupportedAdvertise = msidbFeatureAttributes.NoUnsupportedAdvertise;

pub const msidbFileAttributes = enum(i32) {
    ReadOnly = 1,
    Hidden = 2,
    System = 4,
    Reserved0 = 8,
    IsolatedComp = 16,
    Reserved1 = 64,
    Reserved2 = 128,
    Reserved3 = 256,
    Vital = 512,
    Checksum = 1024,
    PatchAdded = 4096,
    Noncompressed = 8192,
    Compressed = 16384,
    Reserved4 = 32768,
};
pub const msidbFileAttributesReadOnly = msidbFileAttributes.ReadOnly;
pub const msidbFileAttributesHidden = msidbFileAttributes.Hidden;
pub const msidbFileAttributesSystem = msidbFileAttributes.System;
pub const msidbFileAttributesReserved0 = msidbFileAttributes.Reserved0;
pub const msidbFileAttributesIsolatedComp = msidbFileAttributes.IsolatedComp;
pub const msidbFileAttributesReserved1 = msidbFileAttributes.Reserved1;
pub const msidbFileAttributesReserved2 = msidbFileAttributes.Reserved2;
pub const msidbFileAttributesReserved3 = msidbFileAttributes.Reserved3;
pub const msidbFileAttributesVital = msidbFileAttributes.Vital;
pub const msidbFileAttributesChecksum = msidbFileAttributes.Checksum;
pub const msidbFileAttributesPatchAdded = msidbFileAttributes.PatchAdded;
pub const msidbFileAttributesNoncompressed = msidbFileAttributes.Noncompressed;
pub const msidbFileAttributesCompressed = msidbFileAttributes.Compressed;
pub const msidbFileAttributesReserved4 = msidbFileAttributes.Reserved4;

pub const msidbIniFileAction = enum(i32) {
    AddLine = 0,
    CreateLine = 1,
    RemoveLine = 2,
    AddTag = 3,
    RemoveTag = 4,
};
pub const msidbIniFileActionAddLine = msidbIniFileAction.AddLine;
pub const msidbIniFileActionCreateLine = msidbIniFileAction.CreateLine;
pub const msidbIniFileActionRemoveLine = msidbIniFileAction.RemoveLine;
pub const msidbIniFileActionAddTag = msidbIniFileAction.AddTag;
pub const msidbIniFileActionRemoveTag = msidbIniFileAction.RemoveTag;

pub const msidbMoveFileOptions = enum(i32) {
    e = 1,
};
pub const msidbMoveFileOptionsMove = msidbMoveFileOptions.e;

pub const msidbODBCDataSourceRegistration = enum(i32) {
    Machine = 0,
    User = 1,
};
pub const msidbODBCDataSourceRegistrationPerMachine = msidbODBCDataSourceRegistration.Machine;
pub const msidbODBCDataSourceRegistrationPerUser = msidbODBCDataSourceRegistration.User;

pub const msidbClassAttributes = enum(i32) {
    h = 1,
};
pub const msidbClassAttributesRelativePath = msidbClassAttributes.h;

pub const msidbPatchAttributes = enum(i32) {
    l = 1,
};
pub const msidbPatchAttributesNonVital = msidbPatchAttributes.l;

pub const msidbRegistryRoot = enum(i32) {
    ClassesRoot = 0,
    CurrentUser = 1,
    LocalMachine = 2,
    Users = 3,
};
pub const msidbRegistryRootClassesRoot = msidbRegistryRoot.ClassesRoot;
pub const msidbRegistryRootCurrentUser = msidbRegistryRoot.CurrentUser;
pub const msidbRegistryRootLocalMachine = msidbRegistryRoot.LocalMachine;
pub const msidbRegistryRootUsers = msidbRegistryRoot.Users;

pub const msidbRemoveFileInstallMode = enum(i32) {
    Install = 1,
    Remove = 2,
    Both = 3,
};
pub const msidbRemoveFileInstallModeOnInstall = msidbRemoveFileInstallMode.Install;
pub const msidbRemoveFileInstallModeOnRemove = msidbRemoveFileInstallMode.Remove;
pub const msidbRemoveFileInstallModeOnBoth = msidbRemoveFileInstallMode.Both;

pub const msidbServiceControlEvent = enum(i32) {
    Start = 1,
    Stop = 2,
    Delete = 8,
    UninstallStart = 16,
    UninstallStop = 32,
    UninstallDelete = 128,
};
pub const msidbServiceControlEventStart = msidbServiceControlEvent.Start;
pub const msidbServiceControlEventStop = msidbServiceControlEvent.Stop;
pub const msidbServiceControlEventDelete = msidbServiceControlEvent.Delete;
pub const msidbServiceControlEventUninstallStart = msidbServiceControlEvent.UninstallStart;
pub const msidbServiceControlEventUninstallStop = msidbServiceControlEvent.UninstallStop;
pub const msidbServiceControlEventUninstallDelete = msidbServiceControlEvent.UninstallDelete;

pub const msidbServiceConfigEvent = enum(i32) {
    Install = 1,
    Uninstall = 2,
    Reinstall = 4,
};
pub const msidbServiceConfigEventInstall = msidbServiceConfigEvent.Install;
pub const msidbServiceConfigEventUninstall = msidbServiceConfigEvent.Uninstall;
pub const msidbServiceConfigEventReinstall = msidbServiceConfigEvent.Reinstall;

pub const msidbServiceInstallErrorControl = enum(i32) {
    l = 32768,
};
pub const msidbServiceInstallErrorControlVital = msidbServiceInstallErrorControl.l;

pub const msidbTextStyleStyleBits = enum(i32) {
    Bold = 1,
    Italic = 2,
    Underline = 4,
    Strike = 8,
};
pub const msidbTextStyleStyleBitsBold = msidbTextStyleStyleBits.Bold;
pub const msidbTextStyleStyleBitsItalic = msidbTextStyleStyleBits.Italic;
pub const msidbTextStyleStyleBitsUnderline = msidbTextStyleStyleBits.Underline;
pub const msidbTextStyleStyleBitsStrike = msidbTextStyleStyleBits.Strike;

pub const msidbUpgradeAttributes = enum(i32) {
    MigrateFeatures = 1,
    OnlyDetect = 2,
    IgnoreRemoveFailure = 4,
    VersionMinInclusive = 256,
    VersionMaxInclusive = 512,
    LanguagesExclusive = 1024,
};
pub const msidbUpgradeAttributesMigrateFeatures = msidbUpgradeAttributes.MigrateFeatures;
pub const msidbUpgradeAttributesOnlyDetect = msidbUpgradeAttributes.OnlyDetect;
pub const msidbUpgradeAttributesIgnoreRemoveFailure = msidbUpgradeAttributes.IgnoreRemoveFailure;
pub const msidbUpgradeAttributesVersionMinInclusive = msidbUpgradeAttributes.VersionMinInclusive;
pub const msidbUpgradeAttributesVersionMaxInclusive = msidbUpgradeAttributes.VersionMaxInclusive;
pub const msidbUpgradeAttributesLanguagesExclusive = msidbUpgradeAttributes.LanguagesExclusive;

pub const msidbEmbeddedUIAttributes = enum(i32) {
    UI = 1,
    HandlesBasic = 2,
};
pub const msidbEmbeddedUI = msidbEmbeddedUIAttributes.UI;
pub const msidbEmbeddedHandlesBasic = msidbEmbeddedUIAttributes.HandlesBasic;

pub const msidbSumInfoSourceType = enum(i32) {
    SFN = 1,
    Compressed = 2,
    AdminImage = 4,
    LUAPackage = 8,
};
pub const msidbSumInfoSourceTypeSFN = msidbSumInfoSourceType.SFN;
pub const msidbSumInfoSourceTypeCompressed = msidbSumInfoSourceType.Compressed;
pub const msidbSumInfoSourceTypeAdminImage = msidbSumInfoSourceType.AdminImage;
pub const msidbSumInfoSourceTypeLUAPackage = msidbSumInfoSourceType.LUAPackage;

pub const msirbRebootType = enum(i32) {
    Immediate = 1,
    Deferred = 2,
};
pub const msirbRebootImmediate = msirbRebootType.Immediate;
pub const msirbRebootDeferred = msirbRebootType.Deferred;

pub const msirbRebootReason = enum(i32) {
    UndeterminedReason = 0,
    InUseFilesReason = 1,
    ScheduleRebootReason = 2,
    ForceRebootReason = 3,
    CustomActionReason = 4,
};
pub const msirbRebootUndeterminedReason = msirbRebootReason.UndeterminedReason;
pub const msirbRebootInUseFilesReason = msirbRebootReason.InUseFilesReason;
pub const msirbRebootScheduleRebootReason = msirbRebootReason.ScheduleRebootReason;
pub const msirbRebootForceRebootReason = msirbRebootReason.ForceRebootReason;
pub const msirbRebootCustomActionReason = msirbRebootReason.CustomActionReason;

pub const msifiFastInstallBits = enum(i32) {
    NoSR = 1,
    QuickCosting = 2,
    LessPrgMsg = 4,
};
pub const msifiFastInstallNoSR = msifiFastInstallBits.NoSR;
pub const msifiFastInstallQuickCosting = msifiFastInstallBits.QuickCosting;
pub const msifiFastInstallLessPrgMsg = msifiFastInstallBits.LessPrgMsg;

const CLSID_PMSvc_Value = Guid.initString("b9e511fc-e364-497a-a121-b7b3612cedce");
pub const CLSID_PMSvc = &CLSID_PMSvc_Value;

pub const TILE_TEMPLATE_TYPE = enum(i32) {
    INVALID = 0,
    FLIP = 5,
    DEEPLINK = 13,
    CYCLE = 14,
    METROCOUNT = 1,
    AGILESTORE = 2,
    GAMES = 3,
    CALENDAR = 4,
    MUSICVIDEO = 7,
    PEOPLE = 10,
    CONTACT = 11,
    GROUP = 12,
    DEFAULT = 15,
    BADGE = 16,
    BLOCK = 17,
    TEXT01 = 18,
    TEXT02 = 19,
    TEXT03 = 20,
    TEXT04 = 21,
    TEXT05 = 22,
    TEXT06 = 23,
    TEXT07 = 24,
    TEXT08 = 25,
    TEXT09 = 26,
    TEXT10 = 27,
    TEXT11 = 28,
    IMAGE = 29,
    IMAGECOLLECTION = 30,
    IMAGEANDTEXT01 = 31,
    IMAGEANDTEXT02 = 32,
    BLOCKANDTEXT01 = 33,
    BLOCKANDTEXT02 = 34,
    PEEKIMAGEANDTEXT01 = 35,
    PEEKIMAGEANDTEXT02 = 36,
    PEEKIMAGEANDTEXT03 = 37,
    PEEKIMAGEANDTEXT04 = 38,
    PEEKIMAGE01 = 39,
    PEEKIMAGE02 = 40,
    PEEKIMAGE03 = 41,
    PEEKIMAGE04 = 42,
    PEEKIMAGE05 = 43,
    PEEKIMAGE06 = 44,
    PEEKIMAGECOLLECTION01 = 45,
    PEEKIMAGECOLLECTION02 = 46,
    PEEKIMAGECOLLECTION03 = 47,
    PEEKIMAGECOLLECTION04 = 48,
    PEEKIMAGECOLLECTION05 = 49,
    PEEKIMAGECOLLECTION06 = 50,
    SMALLIMAGEANDTEXT01 = 51,
    SMALLIMAGEANDTEXT02 = 52,
    SMALLIMAGEANDTEXT03 = 53,
    SMALLIMAGEANDTEXT04 = 54,
    SMALLIMAGEANDTEXT05 = 55,
    METROCOUNTQUEUE = 56,
    SEARCH = 57,
    TILEFLYOUT01 = 58,
    FOLDER = 59,
    ALL = 100,
};
pub const TILE_TEMPLATE_INVALID = TILE_TEMPLATE_TYPE.INVALID;
pub const TILE_TEMPLATE_FLIP = TILE_TEMPLATE_TYPE.FLIP;
pub const TILE_TEMPLATE_DEEPLINK = TILE_TEMPLATE_TYPE.DEEPLINK;
pub const TILE_TEMPLATE_CYCLE = TILE_TEMPLATE_TYPE.CYCLE;
pub const TILE_TEMPLATE_METROCOUNT = TILE_TEMPLATE_TYPE.METROCOUNT;
pub const TILE_TEMPLATE_AGILESTORE = TILE_TEMPLATE_TYPE.AGILESTORE;
pub const TILE_TEMPLATE_GAMES = TILE_TEMPLATE_TYPE.GAMES;
pub const TILE_TEMPLATE_CALENDAR = TILE_TEMPLATE_TYPE.CALENDAR;
pub const TILE_TEMPLATE_MUSICVIDEO = TILE_TEMPLATE_TYPE.MUSICVIDEO;
pub const TILE_TEMPLATE_PEOPLE = TILE_TEMPLATE_TYPE.PEOPLE;
pub const TILE_TEMPLATE_CONTACT = TILE_TEMPLATE_TYPE.CONTACT;
pub const TILE_TEMPLATE_GROUP = TILE_TEMPLATE_TYPE.GROUP;
pub const TILE_TEMPLATE_DEFAULT = TILE_TEMPLATE_TYPE.DEFAULT;
pub const TILE_TEMPLATE_BADGE = TILE_TEMPLATE_TYPE.BADGE;
pub const TILE_TEMPLATE_BLOCK = TILE_TEMPLATE_TYPE.BLOCK;
pub const TILE_TEMPLATE_TEXT01 = TILE_TEMPLATE_TYPE.TEXT01;
pub const TILE_TEMPLATE_TEXT02 = TILE_TEMPLATE_TYPE.TEXT02;
pub const TILE_TEMPLATE_TEXT03 = TILE_TEMPLATE_TYPE.TEXT03;
pub const TILE_TEMPLATE_TEXT04 = TILE_TEMPLATE_TYPE.TEXT04;
pub const TILE_TEMPLATE_TEXT05 = TILE_TEMPLATE_TYPE.TEXT05;
pub const TILE_TEMPLATE_TEXT06 = TILE_TEMPLATE_TYPE.TEXT06;
pub const TILE_TEMPLATE_TEXT07 = TILE_TEMPLATE_TYPE.TEXT07;
pub const TILE_TEMPLATE_TEXT08 = TILE_TEMPLATE_TYPE.TEXT08;
pub const TILE_TEMPLATE_TEXT09 = TILE_TEMPLATE_TYPE.TEXT09;
pub const TILE_TEMPLATE_TEXT10 = TILE_TEMPLATE_TYPE.TEXT10;
pub const TILE_TEMPLATE_TEXT11 = TILE_TEMPLATE_TYPE.TEXT11;
pub const TILE_TEMPLATE_IMAGE = TILE_TEMPLATE_TYPE.IMAGE;
pub const TILE_TEMPLATE_IMAGECOLLECTION = TILE_TEMPLATE_TYPE.IMAGECOLLECTION;
pub const TILE_TEMPLATE_IMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.IMAGEANDTEXT01;
pub const TILE_TEMPLATE_IMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.IMAGEANDTEXT02;
pub const TILE_TEMPLATE_BLOCKANDTEXT01 = TILE_TEMPLATE_TYPE.BLOCKANDTEXT01;
pub const TILE_TEMPLATE_BLOCKANDTEXT02 = TILE_TEMPLATE_TYPE.BLOCKANDTEXT02;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT01;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT02;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT03 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT03;
pub const TILE_TEMPLATE_PEEKIMAGEANDTEXT04 = TILE_TEMPLATE_TYPE.PEEKIMAGEANDTEXT04;
pub const TILE_TEMPLATE_PEEKIMAGE01 = TILE_TEMPLATE_TYPE.PEEKIMAGE01;
pub const TILE_TEMPLATE_PEEKIMAGE02 = TILE_TEMPLATE_TYPE.PEEKIMAGE02;
pub const TILE_TEMPLATE_PEEKIMAGE03 = TILE_TEMPLATE_TYPE.PEEKIMAGE03;
pub const TILE_TEMPLATE_PEEKIMAGE04 = TILE_TEMPLATE_TYPE.PEEKIMAGE04;
pub const TILE_TEMPLATE_PEEKIMAGE05 = TILE_TEMPLATE_TYPE.PEEKIMAGE05;
pub const TILE_TEMPLATE_PEEKIMAGE06 = TILE_TEMPLATE_TYPE.PEEKIMAGE06;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION01 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION01;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION02 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION02;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION03 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION03;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION04 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION04;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION05 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION05;
pub const TILE_TEMPLATE_PEEKIMAGECOLLECTION06 = TILE_TEMPLATE_TYPE.PEEKIMAGECOLLECTION06;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT01 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT01;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT02 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT02;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT03 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT03;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT04 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT04;
pub const TILE_TEMPLATE_SMALLIMAGEANDTEXT05 = TILE_TEMPLATE_TYPE.SMALLIMAGEANDTEXT05;
pub const TILE_TEMPLATE_METROCOUNTQUEUE = TILE_TEMPLATE_TYPE.METROCOUNTQUEUE;
pub const TILE_TEMPLATE_SEARCH = TILE_TEMPLATE_TYPE.SEARCH;
pub const TILE_TEMPLATE_TILEFLYOUT01 = TILE_TEMPLATE_TYPE.TILEFLYOUT01;
pub const TILE_TEMPLATE_FOLDER = TILE_TEMPLATE_TYPE.FOLDER;
pub const TILE_TEMPLATE_ALL = TILE_TEMPLATE_TYPE.ALL;

pub const PM_APP_GENRE = enum(i32) {
    GAMES = 0,
    OTHER = 1,
    INVALID = 2,
};
pub const PM_APP_GENRE_GAMES = PM_APP_GENRE.GAMES;
pub const PM_APP_GENRE_OTHER = PM_APP_GENRE.OTHER;
pub const PM_APP_GENRE_INVALID = PM_APP_GENRE.INVALID;

pub const PM_APPLICATION_INSTALL_TYPE = enum(i32) {
    NORMAL = 0,
    IN_ROM = 1,
    PA = 2,
    DEBUG = 3,
    ENTERPRISE = 4,
    INVALID = 5,
};
pub const PM_APPLICATION_INSTALL_NORMAL = PM_APPLICATION_INSTALL_TYPE.NORMAL;
pub const PM_APPLICATION_INSTALL_IN_ROM = PM_APPLICATION_INSTALL_TYPE.IN_ROM;
pub const PM_APPLICATION_INSTALL_PA = PM_APPLICATION_INSTALL_TYPE.PA;
pub const PM_APPLICATION_INSTALL_DEBUG = PM_APPLICATION_INSTALL_TYPE.DEBUG;
pub const PM_APPLICATION_INSTALL_ENTERPRISE = PM_APPLICATION_INSTALL_TYPE.ENTERPRISE;
pub const PM_APPLICATION_INSTALL_INVALID = PM_APPLICATION_INSTALL_TYPE.INVALID;

pub const PM_APPLICATION_STATE = enum(i32) {
    MIN = 0,
    INSTALLED = 1,
    INSTALLING = 2,
    UPDATING = 3,
    UNINSTALLING = 4,
    LICENSE_UPDATING = 5,
    MOVING = 6,
    DISABLED_SD_CARD = 7,
    DISABLED_ENTERPRISE = 8,
    DISABLED_BACKING_UP = 9,
    DISABLED_MDIL_BINDING = 10,
    INVALID = 11,
    pub const MAX = .DISABLED_MDIL_BINDING;
};
pub const PM_APPLICATION_STATE_MIN = PM_APPLICATION_STATE.MIN;
pub const PM_APPLICATION_STATE_INSTALLED = PM_APPLICATION_STATE.INSTALLED;
pub const PM_APPLICATION_STATE_INSTALLING = PM_APPLICATION_STATE.INSTALLING;
pub const PM_APPLICATION_STATE_UPDATING = PM_APPLICATION_STATE.UPDATING;
pub const PM_APPLICATION_STATE_UNINSTALLING = PM_APPLICATION_STATE.UNINSTALLING;
pub const PM_APPLICATION_STATE_LICENSE_UPDATING = PM_APPLICATION_STATE.LICENSE_UPDATING;
pub const PM_APPLICATION_STATE_MOVING = PM_APPLICATION_STATE.MOVING;
pub const PM_APPLICATION_STATE_DISABLED_SD_CARD = PM_APPLICATION_STATE.DISABLED_SD_CARD;
pub const PM_APPLICATION_STATE_DISABLED_ENTERPRISE = PM_APPLICATION_STATE.DISABLED_ENTERPRISE;
pub const PM_APPLICATION_STATE_DISABLED_BACKING_UP = PM_APPLICATION_STATE.DISABLED_BACKING_UP;
pub const PM_APPLICATION_STATE_DISABLED_MDIL_BINDING = PM_APPLICATION_STATE.DISABLED_MDIL_BINDING;
pub const PM_APPLICATION_STATE_MAX = PM_APPLICATION_STATE.DISABLED_MDIL_BINDING;
pub const PM_APPLICATION_STATE_INVALID = PM_APPLICATION_STATE.INVALID;

pub const PM_APPLICATION_HUBTYPE = enum(i32) {
    NONMUSIC = 0,
    MUSIC = 1,
    INVALID = 2,
};
pub const PM_APPLICATION_HUBTYPE_NONMUSIC = PM_APPLICATION_HUBTYPE.NONMUSIC;
pub const PM_APPLICATION_HUBTYPE_MUSIC = PM_APPLICATION_HUBTYPE.MUSIC;
pub const PM_APPLICATION_HUBTYPE_INVALID = PM_APPLICATION_HUBTYPE.INVALID;

pub const PM_TILE_HUBTYPE = enum(i32) {
    MUSIC = 1,
    MOSETTINGS = 268435456,
    GAMES = 536870912,
    APPLIST = 1073741824,
    STARTMENU = -2147483648,
    LOCKSCREEN = 16777216,
    KIDZONE = 33554432,
    CACHED = 67108864,
    INVALID = 67108865,
};
pub const PM_TILE_HUBTYPE_MUSIC = PM_TILE_HUBTYPE.MUSIC;
pub const PM_TILE_HUBTYPE_MOSETTINGS = PM_TILE_HUBTYPE.MOSETTINGS;
pub const PM_TILE_HUBTYPE_GAMES = PM_TILE_HUBTYPE.GAMES;
pub const PM_TILE_HUBTYPE_APPLIST = PM_TILE_HUBTYPE.APPLIST;
pub const PM_TILE_HUBTYPE_STARTMENU = PM_TILE_HUBTYPE.STARTMENU;
pub const PM_TILE_HUBTYPE_LOCKSCREEN = PM_TILE_HUBTYPE.LOCKSCREEN;
pub const PM_TILE_HUBTYPE_KIDZONE = PM_TILE_HUBTYPE.KIDZONE;
pub const PM_TILE_HUBTYPE_CACHED = PM_TILE_HUBTYPE.CACHED;
pub const PM_TILE_HUBTYPE_INVALID = PM_TILE_HUBTYPE.INVALID;

pub const PM_STARTTILE_TYPE = enum(i32) {
    PRIMARY = 1,
    SECONDARY = 2,
    APPLIST = 3,
    APPLISTPRIMARY = 4,
    INVALID = 5,
};
pub const PM_STARTTILE_TYPE_PRIMARY = PM_STARTTILE_TYPE.PRIMARY;
pub const PM_STARTTILE_TYPE_SECONDARY = PM_STARTTILE_TYPE.SECONDARY;
pub const PM_STARTTILE_TYPE_APPLIST = PM_STARTTILE_TYPE.APPLIST;
pub const PM_STARTTILE_TYPE_APPLISTPRIMARY = PM_STARTTILE_TYPE.APPLISTPRIMARY;
pub const PM_STARTTILE_TYPE_INVALID = PM_STARTTILE_TYPE.INVALID;

pub const PM_TASK_TYPE = enum(i32) {
    NORMAL = 0,
    DEFAULT = 1,
    SETTINGS = 2,
    BACKGROUNDSERVICEAGENT = 3,
    BACKGROUNDWORKER = 4,
    INVALID = 5,
};
pub const PM_TASK_TYPE_NORMAL = PM_TASK_TYPE.NORMAL;
pub const PM_TASK_TYPE_DEFAULT = PM_TASK_TYPE.DEFAULT;
pub const PM_TASK_TYPE_SETTINGS = PM_TASK_TYPE.SETTINGS;
pub const PM_TASK_TYPE_BACKGROUNDSERVICEAGENT = PM_TASK_TYPE.BACKGROUNDSERVICEAGENT;
pub const PM_TASK_TYPE_BACKGROUNDWORKER = PM_TASK_TYPE.BACKGROUNDWORKER;
pub const PM_TASK_TYPE_INVALID = PM_TASK_TYPE.INVALID;

pub const PACKMAN_RUNTIME = enum(i32) {
    NATIVE = 1,
    SILVERLIGHTMOBILE = 2,
    XNA = 3,
    MODERN_NATIVE = 4,
    JUPITER = 5,
    INVALID = 6,
};
pub const PACKMAN_RUNTIME_NATIVE = PACKMAN_RUNTIME.NATIVE;
pub const PACKMAN_RUNTIME_SILVERLIGHTMOBILE = PACKMAN_RUNTIME.SILVERLIGHTMOBILE;
pub const PACKMAN_RUNTIME_XNA = PACKMAN_RUNTIME.XNA;
pub const PACKMAN_RUNTIME_MODERN_NATIVE = PACKMAN_RUNTIME.MODERN_NATIVE;
pub const PACKMAN_RUNTIME_JUPITER = PACKMAN_RUNTIME.JUPITER;
pub const PACKMAN_RUNTIME_INVALID = PACKMAN_RUNTIME.INVALID;

pub const PM_ACTIVATION_POLICY = enum(i32) {
    RESUME = 0,
    RESUMESAMEPARAMS = 1,
    REPLACE = 2,
    REPLACESAMEPARAMS = 3,
    MULTISESSION = 4,
    REPLACE_IGNOREFOREGROUND = 5,
    UNKNOWN = 6,
    INVALID = 7,
};
pub const PM_ACTIVATION_POLICY_RESUME = PM_ACTIVATION_POLICY.RESUME;
pub const PM_ACTIVATION_POLICY_RESUMESAMEPARAMS = PM_ACTIVATION_POLICY.RESUMESAMEPARAMS;
pub const PM_ACTIVATION_POLICY_REPLACE = PM_ACTIVATION_POLICY.REPLACE;
pub const PM_ACTIVATION_POLICY_REPLACESAMEPARAMS = PM_ACTIVATION_POLICY.REPLACESAMEPARAMS;
pub const PM_ACTIVATION_POLICY_MULTISESSION = PM_ACTIVATION_POLICY.MULTISESSION;
pub const PM_ACTIVATION_POLICY_REPLACE_IGNOREFOREGROUND = PM_ACTIVATION_POLICY.REPLACE_IGNOREFOREGROUND;
pub const PM_ACTIVATION_POLICY_UNKNOWN = PM_ACTIVATION_POLICY.UNKNOWN;
pub const PM_ACTIVATION_POLICY_INVALID = PM_ACTIVATION_POLICY.INVALID;

pub const PM_TASK_TRANSITION = enum(i32) {
    DEFAULT = 0,
    NONE = 1,
    TURNSTILE = 2,
    SLIDE = 3,
    SWIVEL = 4,
    READERBOARD = 5,
    CUSTOM = 6,
    INVALID = 7,
};
pub const PM_TASK_TRANSITION_DEFAULT = PM_TASK_TRANSITION.DEFAULT;
pub const PM_TASK_TRANSITION_NONE = PM_TASK_TRANSITION.NONE;
pub const PM_TASK_TRANSITION_TURNSTILE = PM_TASK_TRANSITION.TURNSTILE;
pub const PM_TASK_TRANSITION_SLIDE = PM_TASK_TRANSITION.SLIDE;
pub const PM_TASK_TRANSITION_SWIVEL = PM_TASK_TRANSITION.SWIVEL;
pub const PM_TASK_TRANSITION_READERBOARD = PM_TASK_TRANSITION.READERBOARD;
pub const PM_TASK_TRANSITION_CUSTOM = PM_TASK_TRANSITION.CUSTOM;
pub const PM_TASK_TRANSITION_INVALID = PM_TASK_TRANSITION.INVALID;

pub const PM_ENUM_APP_FILTER = enum(i32) {
    ALL = 0,
    VISIBLE = 1,
    GENRE = 2,
    NONGAMES = 3,
    HUBTYPE = 4,
    PINABLEONKIDZONE = 5,
    ALL_INCLUDE_MODERN = 6,
    FRAMEWORK = 7,
    MAX = 8,
};
pub const PM_APP_FILTER_ALL = PM_ENUM_APP_FILTER.ALL;
pub const PM_APP_FILTER_VISIBLE = PM_ENUM_APP_FILTER.VISIBLE;
pub const PM_APP_FILTER_GENRE = PM_ENUM_APP_FILTER.GENRE;
pub const PM_APP_FILTER_NONGAMES = PM_ENUM_APP_FILTER.NONGAMES;
pub const PM_APP_FILTER_HUBTYPE = PM_ENUM_APP_FILTER.HUBTYPE;
pub const PM_APP_FILTER_PINABLEONKIDZONE = PM_ENUM_APP_FILTER.PINABLEONKIDZONE;
pub const PM_APP_FILTER_ALL_INCLUDE_MODERN = PM_ENUM_APP_FILTER.ALL_INCLUDE_MODERN;
pub const PM_APP_FILTER_FRAMEWORK = PM_ENUM_APP_FILTER.FRAMEWORK;
pub const PM_APP_FILTER_MAX = PM_ENUM_APP_FILTER.MAX;

pub const PM_ENUM_TILE_FILTER = enum(i32) {
    APPLIST = 8,
    PINNED = 9,
    HUBTYPE = 10,
    APP_ALL = 11,
    MAX = 12,
};
pub const PM_TILE_FILTER_APPLIST = PM_ENUM_TILE_FILTER.APPLIST;
pub const PM_TILE_FILTER_PINNED = PM_ENUM_TILE_FILTER.PINNED;
pub const PM_TILE_FILTER_HUBTYPE = PM_ENUM_TILE_FILTER.HUBTYPE;
pub const PM_TILE_FILTER_APP_ALL = PM_ENUM_TILE_FILTER.APP_ALL;
pub const PM_TILE_FILTER_MAX = PM_ENUM_TILE_FILTER.MAX;

pub const PM_ENUM_TASK_FILTER = enum(i32) {
    APP_ALL = 12,
    TASK_TYPE = 13,
    DEHYD_SUPRESSING = 14,
    APP_TASK_TYPE = 15,
    BGEXECUTION = 16,
    MAX = 17,
};
pub const PM_TASK_FILTER_APP_ALL = PM_ENUM_TASK_FILTER.APP_ALL;
pub const PM_TASK_FILTER_TASK_TYPE = PM_ENUM_TASK_FILTER.TASK_TYPE;
pub const PM_TASK_FILTER_DEHYD_SUPRESSING = PM_ENUM_TASK_FILTER.DEHYD_SUPRESSING;
pub const PM_TASK_FILTER_APP_TASK_TYPE = PM_ENUM_TASK_FILTER.APP_TASK_TYPE;
pub const PM_TASK_FILTER_BGEXECUTION = PM_ENUM_TASK_FILTER.BGEXECUTION;
pub const PM_TASK_FILTER_MAX = PM_ENUM_TASK_FILTER.MAX;

pub const PM_ENUM_EXTENSION_FILTER = enum(i32) {
    BY_CONSUMER = 17,
    PROTOCOL_ALL = 18,
    FTASSOC_FILETYPE_ALL = 19,
    FTASSOC_CONTENTTYPE_ALL = 20,
    FTASSOC_APPLICATION_ALL = 21,
    SHARETARGET_ALL = 22,
    FILEOPENPICKER_ALL = 23,
    FILESAVEPICKER_ALL = 24,
    CACHEDFILEUPDATER_ALL = 25,
    MAX = 26,
    pub const APPCONNECT = .BY_CONSUMER;
};
pub const PM_ENUM_EXTENSION_FILTER_BY_CONSUMER = PM_ENUM_EXTENSION_FILTER.BY_CONSUMER;
pub const PM_ENUM_EXTENSION_FILTER_APPCONNECT = PM_ENUM_EXTENSION_FILTER.BY_CONSUMER;
pub const PM_ENUM_EXTENSION_FILTER_PROTOCOL_ALL = PM_ENUM_EXTENSION_FILTER.PROTOCOL_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_FILETYPE_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_FILETYPE_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_CONTENTTYPE_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_CONTENTTYPE_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FTASSOC_APPLICATION_ALL = PM_ENUM_EXTENSION_FILTER.FTASSOC_APPLICATION_ALL;
pub const PM_ENUM_EXTENSION_FILTER_SHARETARGET_ALL = PM_ENUM_EXTENSION_FILTER.SHARETARGET_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FILEOPENPICKER_ALL = PM_ENUM_EXTENSION_FILTER.FILEOPENPICKER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_FILESAVEPICKER_ALL = PM_ENUM_EXTENSION_FILTER.FILESAVEPICKER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_CACHEDFILEUPDATER_ALL = PM_ENUM_EXTENSION_FILTER.CACHEDFILEUPDATER_ALL;
pub const PM_ENUM_EXTENSION_FILTER_MAX = PM_ENUM_EXTENSION_FILTER.MAX;

pub const PM_ENUM_BSA_FILTER = enum(i32) {
    ALL = 26,
    BY_TASKID = 27,
    BY_PRODUCTID = 28,
    BY_PERIODIC = 29,
    BY_ALL_LAUNCHONBOOT = 30,
    MAX = 31,
};
pub const PM_ENUM_BSA_FILTER_ALL = PM_ENUM_BSA_FILTER.ALL;
pub const PM_ENUM_BSA_FILTER_BY_TASKID = PM_ENUM_BSA_FILTER.BY_TASKID;
pub const PM_ENUM_BSA_FILTER_BY_PRODUCTID = PM_ENUM_BSA_FILTER.BY_PRODUCTID;
pub const PM_ENUM_BSA_FILTER_BY_PERIODIC = PM_ENUM_BSA_FILTER.BY_PERIODIC;
pub const PM_ENUM_BSA_FILTER_BY_ALL_LAUNCHONBOOT = PM_ENUM_BSA_FILTER.BY_ALL_LAUNCHONBOOT;
pub const PM_ENUM_BSA_FILTER_MAX = PM_ENUM_BSA_FILTER.MAX;

pub const PM_ENUM_BW_FILTER = enum(i32) {
    BOOTWORKER_ALL = 31,
    BY_TASKID = 32,
    MAX = 33,
};
pub const PM_ENUM_BW_FILTER_BOOTWORKER_ALL = PM_ENUM_BW_FILTER.BOOTWORKER_ALL;
pub const PM_ENUM_BW_FILTER_BY_TASKID = PM_ENUM_BW_FILTER.BY_TASKID;
pub const PM_ENUM_BW_FILTER_MAX = PM_ENUM_BW_FILTER.MAX;

pub const _tagAPPTASKTYPE = extern struct {
    ProductID: Guid,
    TaskType: PM_TASK_TYPE,
};

pub const PM_EXTENSIONCONSUMER = extern struct {
    ConsumerPID: Guid,
    ExtensionID: ?BSTR,
};

pub const PM_BSATASKID = extern struct {
    ProductID: Guid,
    TaskID: ?BSTR,
};

pub const PM_BWTASKID = extern struct {
    ProductID: Guid,
    TaskID: ?BSTR,
};

pub const PM_ENUM_FILTER = extern struct {
    FilterType: i32,
    FilterParameter: extern union {
        Dummy: i32,
        Genre: PM_APP_GENRE,
        AppHubType: PM_APPLICATION_HUBTYPE,
        HubType: PM_TILE_HUBTYPE,
        Tasktype: PM_TASK_TYPE,
        TaskProductID: Guid,
        TileProductID: Guid,
        AppTaskType: _tagAPPTASKTYPE,
        Consumer: PM_EXTENSIONCONSUMER,
        BSATask: PM_BSATASKID,
        BSAProductID: Guid,
        BWTask: PM_BWTASKID,
        ProtocolName: ?BSTR,
        FileType: ?BSTR,
        ContentType: ?BSTR,
        AppSupportedFileExtPID: Guid,
        ShareTargetFileType: ?BSTR,
    },
};

pub const PM_LIVETILE_RECURRENCE_TYPE = enum(i32) {
    INSTANT = 0,
    ONETIME = 1,
    INTERVAL = 2,
    pub const MAX = .INTERVAL;
};
pub const PM_LIVETILE_RECURRENCE_TYPE_INSTANT = PM_LIVETILE_RECURRENCE_TYPE.INSTANT;
pub const PM_LIVETILE_RECURRENCE_TYPE_ONETIME = PM_LIVETILE_RECURRENCE_TYPE.ONETIME;
pub const PM_LIVETILE_RECURRENCE_TYPE_INTERVAL = PM_LIVETILE_RECURRENCE_TYPE.INTERVAL;
pub const PM_LIVETILE_RECURRENCE_TYPE_MAX = PM_LIVETILE_RECURRENCE_TYPE.INTERVAL;

pub const PM_TILE_SIZE = enum(i32) {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    SQUARE310X310 = 3,
    TALL150X310 = 4,
    INVALID = 5,
};
pub const PM_TILE_SIZE_SMALL = PM_TILE_SIZE.SMALL;
pub const PM_TILE_SIZE_MEDIUM = PM_TILE_SIZE.MEDIUM;
pub const PM_TILE_SIZE_LARGE = PM_TILE_SIZE.LARGE;
pub const PM_TILE_SIZE_SQUARE310X310 = PM_TILE_SIZE.SQUARE310X310;
pub const PM_TILE_SIZE_TALL150X310 = PM_TILE_SIZE.TALL150X310;
pub const PM_TILE_SIZE_INVALID = PM_TILE_SIZE.INVALID;

pub const PM_LOGO_SIZE = enum(i32) {
    SMALL = 0,
    MEDIUM = 1,
    LARGE = 2,
    INVALID = 3,
};
pub const PM_LOGO_SIZE_SMALL = PM_LOGO_SIZE.SMALL;
pub const PM_LOGO_SIZE_MEDIUM = PM_LOGO_SIZE.MEDIUM;
pub const PM_LOGO_SIZE_LARGE = PM_LOGO_SIZE.LARGE;
pub const PM_LOGO_SIZE_INVALID = PM_LOGO_SIZE.INVALID;

pub const PM_STARTAPPBLOB = extern struct {
    cbSize: u32,
    ProductID: Guid,
    AppTitle: ?BSTR,
    IconPath: ?BSTR,
    IsUninstallable: BOOL,
    AppInstallType: PM_APPLICATION_INSTALL_TYPE,
    InstanceID: Guid,
    State: PM_APPLICATION_STATE,
    IsModern: BOOL,
    IsModernLightUp: BOOL,
    LightUpSupportMask: u16,
};

pub const PM_INVOCATIONINFO = extern struct {
    URIBaseOrAUMID: ?BSTR,
    URIFragmentOrArgs: ?BSTR,
};

pub const PM_STARTTILEBLOB = extern struct {
    cbSize: u32,
    ProductID: Guid,
    TileID: ?BSTR,
    TemplateType: TILE_TEMPLATE_TYPE,
    HubPosition: [32]u32,
    HubVisibilityBitmask: u32,
    IsDefault: BOOL,
    TileType: PM_STARTTILE_TYPE,
    pbPropBlob: ?*u8,
    cbPropBlob: u32,
    IsRestoring: BOOL,
    IsModern: BOOL,
    InvocationInfo: PM_INVOCATIONINFO,
};

pub const PM_INSTALLINFO = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    IsUninstallDisabled: BOOL,
    DeploymentOptions: u32,
    OfferID: Guid,
    MarketplaceAppVersion: ?BSTR,
};

pub const PM_UPDATEINFO_LEGACY = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    MarketplaceAppVersion: ?BSTR,
};

pub const PM_UPDATEINFO = extern struct {
    ProductID: Guid,
    PackagePath: ?BSTR,
    InstanceID: Guid,
    pbLicense: ?*u8,
    cbLicense: u32,
    MarketplaceAppVersion: ?BSTR,
    DeploymentOptions: u32,
};

const IID_IPMApplicationInfo_Value = Guid.initString("50afb58a-438c-4088-9789-f8c4899829c7");
pub const IID_IPMApplicationInfo = &IID_IPMApplicationInfo_Value;
pub const IPMApplicationInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn(
            self: *const IPMApplicationInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstanceID: *const fn(
            self: *const IPMApplicationInfo,
            pInstanceID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OfferID: *const fn(
            self: *const IPMApplicationInfo,
            pOfferID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultTask: *const fn(
            self: *const IPMApplicationInfo,
            pDefaultTask: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppTitle: *const fn(
            self: *const IPMApplicationInfo,
            pAppTitle: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconPath: *const fn(
            self: *const IPMApplicationInfo,
            pAppIconPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NotificationState: *const fn(
            self: *const IPMApplicationInfo,
            pIsNotified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppInstallType: *const fn(
            self: *const IPMApplicationInfo,
            pAppInstallType: ?*PM_APPLICATION_INSTALL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: *const fn(
            self: *const IPMApplicationInfo,
            pState: ?*PM_APPLICATION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRevoked: *const fn(
            self: *const IPMApplicationInfo,
            pIsRevoked: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UpdateAvailable: *const fn(
            self: *const IPMApplicationInfo,
            pIsUpdateAvailable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallDate: *const fn(
            self: *const IPMApplicationInfo,
            pInstallDate: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsUninstallable: *const fn(
            self: *const IPMApplicationInfo,
            pIsUninstallable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsThemable: *const fn(
            self: *const IPMApplicationInfo,
            pIsThemable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsTrial: *const fn(
            self: *const IPMApplicationInfo,
            pIsTrial: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallPath: *const fn(
            self: *const IPMApplicationInfo,
            pInstallPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataRoot: *const fn(
            self: *const IPMApplicationInfo,
            pDataRoot: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Genre: *const fn(
            self: *const IPMApplicationInfo,
            pGenre: ?*PM_APP_GENRE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Publisher: *const fn(
            self: *const IPMApplicationInfo,
            pPublisher: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Author: *const fn(
            self: *const IPMApplicationInfo,
            pAuthor: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn(
            self: *const IPMApplicationInfo,
            pDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: *const fn(
            self: *const IPMApplicationInfo,
            pVersion: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InvocationInfo: *const fn(
            self: *const IPMApplicationInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMajorVersion: *const fn(
            self: *const IPMApplicationInfo,
            pMajorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMinorVersion: *const fn(
            self: *const IPMApplicationInfo,
            pMinorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PublisherID: *const fn(
            self: *const IPMApplicationInfo,
            pPublisherID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMultiCore: *const fn(
            self: *const IPMApplicationInfo,
            pIsMultiCore: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SID: *const fn(
            self: *const IPMApplicationInfo,
            pSID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMajorVersionLightUp: *const fn(
            self: *const IPMApplicationInfo,
            pMajorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AppPlatMinorVersionLightUp: *const fn(
            self: *const IPMApplicationInfo,
            pMinorVer: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UpdateAvailable: *const fn(
            self: *const IPMApplicationInfo,
            IsUpdateAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NotificationState: *const fn(
            self: *const IPMApplicationInfo,
            IsNotified: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IconPath: *const fn(
            self: *const IPMApplicationInfo,
            AppIconPath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UninstallableState: *const fn(
            self: *const IPMApplicationInfo,
            IsUninstallable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPinableOnKidZone: *const fn(
            self: *const IPMApplicationInfo,
            pIsPinable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOriginallyPreInstalled: *const fn(
            self: *const IPMApplicationInfo,
            pIsPreinstalled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInstallOnSD: *const fn(
            self: *const IPMApplicationInfo,
            pIsInstallOnSD: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptoutOnSD: *const fn(
            self: *const IPMApplicationInfo,
            pIsOptoutOnSD: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptoutBackupRestore: *const fn(
            self: *const IPMApplicationInfo,
            pIsOptoutBackupRestore: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_EnterpriseDisabled: *const fn(
            self: *const IPMApplicationInfo,
            IsDisabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_EnterpriseUninstallable: *const fn(
            self: *const IPMApplicationInfo,
            IsUninstallable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnterpriseDisabled: *const fn(
            self: *const IPMApplicationInfo,
            IsDisabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnterpriseUninstallable: *const fn(
            self: *const IPMApplicationInfo,
            IsUninstallable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsVisibleOnAppList: *const fn(
            self: *const IPMApplicationInfo,
            pIsVisible: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInboxApp: *const fn(
            self: *const IPMApplicationInfo,
            pIsInboxApp: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StorageID: *const fn(
            self: *const IPMApplicationInfo,
            pStorageID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartAppBlob: *const fn(
            self: *const IPMApplicationInfo,
            pBlob: ?*PM_STARTAPPBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsMovable: *const fn(
            self: *const IPMApplicationInfo,
            pIsMovable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DeploymentAppEnumerationHubFilter: *const fn(
            self: *const IPMApplicationInfo,
            HubType: ?*PM_TILE_HUBTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModifiedDate: *const fn(
            self: *const IPMApplicationInfo,
            pModifiedDate: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOriginallyRestored: *const fn(
            self: *const IPMApplicationInfo,
            pIsRestored: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ShouldDeferMdilBind: *const fn(
            self: *const IPMApplicationInfo,
            pfDeferMdilBind: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFullyPreInstall: *const fn(
            self: *const IPMApplicationInfo,
            pfIsFullyPreInstall: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsMdilMaintenanceNeeded: *const fn(
            self: *const IPMApplicationInfo,
            fIsMdilMaintenanceNeeded: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_Title: *const fn(
            self: *const IPMApplicationInfo,
            AppTitle: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ProductID(self: *const IPMApplicationInfo, pProductID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_ProductID(self, pProductID);
    }
    pub fn get_InstanceID(self: *const IPMApplicationInfo, pInstanceID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_InstanceID(self, pInstanceID);
    }
    pub fn get_OfferID(self: *const IPMApplicationInfo, pOfferID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_OfferID(self, pOfferID);
    }
    pub fn get_DefaultTask(self: *const IPMApplicationInfo, pDefaultTask: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_DefaultTask(self, pDefaultTask);
    }
    pub fn get_AppTitle(self: *const IPMApplicationInfo, pAppTitle: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_AppTitle(self, pAppTitle);
    }
    pub fn get_IconPath(self: *const IPMApplicationInfo, pAppIconPath: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_IconPath(self, pAppIconPath);
    }
    pub fn get_NotificationState(self: *const IPMApplicationInfo, pIsNotified: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_NotificationState(self, pIsNotified);
    }
    pub fn get_AppInstallType(self: *const IPMApplicationInfo, pAppInstallType: ?*PM_APPLICATION_INSTALL_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_AppInstallType(self, pAppInstallType);
    }
    pub fn get_State(self: *const IPMApplicationInfo, pState: ?*PM_APPLICATION_STATE) callconv(.Inline) HRESULT {
        return self.vtable.get_State(self, pState);
    }
    pub fn get_IsRevoked(self: *const IPMApplicationInfo, pIsRevoked: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsRevoked(self, pIsRevoked);
    }
    pub fn get_UpdateAvailable(self: *const IPMApplicationInfo, pIsUpdateAvailable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_UpdateAvailable(self, pIsUpdateAvailable);
    }
    pub fn get_InstallDate(self: *const IPMApplicationInfo, pInstallDate: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.get_InstallDate(self, pInstallDate);
    }
    pub fn get_IsUninstallable(self: *const IPMApplicationInfo, pIsUninstallable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsUninstallable(self, pIsUninstallable);
    }
    pub fn get_IsThemable(self: *const IPMApplicationInfo, pIsThemable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsThemable(self, pIsThemable);
    }
    pub fn get_IsTrial(self: *const IPMApplicationInfo, pIsTrial: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsTrial(self, pIsTrial);
    }
    pub fn get_InstallPath(self: *const IPMApplicationInfo, pInstallPath: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InstallPath(self, pInstallPath);
    }
    pub fn get_DataRoot(self: *const IPMApplicationInfo, pDataRoot: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_DataRoot(self, pDataRoot);
    }
    pub fn get_Genre(self: *const IPMApplicationInfo, pGenre: ?*PM_APP_GENRE) callconv(.Inline) HRESULT {
        return self.vtable.get_Genre(self, pGenre);
    }
    pub fn get_Publisher(self: *const IPMApplicationInfo, pPublisher: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Publisher(self, pPublisher);
    }
    pub fn get_Author(self: *const IPMApplicationInfo, pAuthor: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Author(self, pAuthor);
    }
    pub fn get_Description(self: *const IPMApplicationInfo, pDescription: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Description(self, pDescription);
    }
    pub fn get_Version(self: *const IPMApplicationInfo, pVersion: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Version(self, pVersion);
    }
    pub fn get_InvocationInfo(self: *const IPMApplicationInfo, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pImageUrn, pParameters);
    }
    pub fn get_AppPlatMajorVersion(self: *const IPMApplicationInfo, pMajorVer: ?*u8) callconv(.Inline) HRESULT {
        return self.vtable.get_AppPlatMajorVersion(self, pMajorVer);
    }
    pub fn get_AppPlatMinorVersion(self: *const IPMApplicationInfo, pMinorVer: ?*u8) callconv(.Inline) HRESULT {
        return self.vtable.get_AppPlatMinorVersion(self, pMinorVer);
    }
    pub fn get_PublisherID(self: *const IPMApplicationInfo, pPublisherID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_PublisherID(self, pPublisherID);
    }
    pub fn get_IsMultiCore(self: *const IPMApplicationInfo, pIsMultiCore: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsMultiCore(self, pIsMultiCore);
    }
    pub fn get_SID(self: *const IPMApplicationInfo, pSID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_SID(self, pSID);
    }
    pub fn get_AppPlatMajorVersionLightUp(self: *const IPMApplicationInfo, pMajorVer: ?*u8) callconv(.Inline) HRESULT {
        return self.vtable.get_AppPlatMajorVersionLightUp(self, pMajorVer);
    }
    pub fn get_AppPlatMinorVersionLightUp(self: *const IPMApplicationInfo, pMinorVer: ?*u8) callconv(.Inline) HRESULT {
        return self.vtable.get_AppPlatMinorVersionLightUp(self, pMinorVer);
    }
    pub fn set_UpdateAvailable(self: *const IPMApplicationInfo, IsUpdateAvailable: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_UpdateAvailable(self, IsUpdateAvailable);
    }
    pub fn set_NotificationState(self: *const IPMApplicationInfo, IsNotified: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_NotificationState(self, IsNotified);
    }
    pub fn set_IconPath(self: *const IPMApplicationInfo, AppIconPath: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.set_IconPath(self, AppIconPath);
    }
    pub fn set_UninstallableState(self: *const IPMApplicationInfo, IsUninstallable: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_UninstallableState(self, IsUninstallable);
    }
    pub fn get_IsPinableOnKidZone(self: *const IPMApplicationInfo, pIsPinable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsPinableOnKidZone(self, pIsPinable);
    }
    pub fn get_IsOriginallyPreInstalled(self: *const IPMApplicationInfo, pIsPreinstalled: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsOriginallyPreInstalled(self, pIsPreinstalled);
    }
    pub fn get_IsInstallOnSD(self: *const IPMApplicationInfo, pIsInstallOnSD: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsInstallOnSD(self, pIsInstallOnSD);
    }
    pub fn get_IsOptoutOnSD(self: *const IPMApplicationInfo, pIsOptoutOnSD: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsOptoutOnSD(self, pIsOptoutOnSD);
    }
    pub fn get_IsOptoutBackupRestore(self: *const IPMApplicationInfo, pIsOptoutBackupRestore: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsOptoutBackupRestore(self, pIsOptoutBackupRestore);
    }
    pub fn set_EnterpriseDisabled(self: *const IPMApplicationInfo, IsDisabled: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_EnterpriseDisabled(self, IsDisabled);
    }
    pub fn set_EnterpriseUninstallable(self: *const IPMApplicationInfo, IsUninstallable: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_EnterpriseUninstallable(self, IsUninstallable);
    }
    pub fn get_EnterpriseDisabled(self: *const IPMApplicationInfo, IsDisabled: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_EnterpriseDisabled(self, IsDisabled);
    }
    pub fn get_EnterpriseUninstallable(self: *const IPMApplicationInfo, IsUninstallable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_EnterpriseUninstallable(self, IsUninstallable);
    }
    pub fn get_IsVisibleOnAppList(self: *const IPMApplicationInfo, pIsVisible: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsVisibleOnAppList(self, pIsVisible);
    }
    pub fn get_IsInboxApp(self: *const IPMApplicationInfo, pIsInboxApp: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsInboxApp(self, pIsInboxApp);
    }
    pub fn get_StorageID(self: *const IPMApplicationInfo, pStorageID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_StorageID(self, pStorageID);
    }
    pub fn get_StartAppBlob(self: *const IPMApplicationInfo, pBlob: ?*PM_STARTAPPBLOB) callconv(.Inline) HRESULT {
        return self.vtable.get_StartAppBlob(self, pBlob);
    }
    pub fn get_IsMovable(self: *const IPMApplicationInfo, pIsMovable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsMovable(self, pIsMovable);
    }
    pub fn get_DeploymentAppEnumerationHubFilter(self: *const IPMApplicationInfo, HubType: ?*PM_TILE_HUBTYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_DeploymentAppEnumerationHubFilter(self, HubType);
    }
    pub fn get_ModifiedDate(self: *const IPMApplicationInfo, pModifiedDate: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.get_ModifiedDate(self, pModifiedDate);
    }
    pub fn get_IsOriginallyRestored(self: *const IPMApplicationInfo, pIsRestored: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsOriginallyRestored(self, pIsRestored);
    }
    pub fn get_ShouldDeferMdilBind(self: *const IPMApplicationInfo, pfDeferMdilBind: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_ShouldDeferMdilBind(self, pfDeferMdilBind);
    }
    pub fn get_IsFullyPreInstall(self: *const IPMApplicationInfo, pfIsFullyPreInstall: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsFullyPreInstall(self, pfIsFullyPreInstall);
    }
    pub fn set_IsMdilMaintenanceNeeded(self: *const IPMApplicationInfo, fIsMdilMaintenanceNeeded: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_IsMdilMaintenanceNeeded(self, fIsMdilMaintenanceNeeded);
    }
    pub fn set_Title(self: *const IPMApplicationInfo, AppTitle: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.set_Title(self, AppTitle);
    }
};

const IID_IPMTilePropertyInfo_Value = Guid.initString("6c2b8017-1efa-42a7-86c0-6d4b640bf528");
pub const IID_IPMTilePropertyInfo = &IID_IPMTilePropertyInfo_Value;
pub const IPMTilePropertyInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyID: *const fn(
            self: *const IPMTilePropertyInfo,
            pPropID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyValue: *const fn(
            self: *const IPMTilePropertyInfo,
            pPropValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_Property: *const fn(
            self: *const IPMTilePropertyInfo,
            PropValue: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_PropertyID(self: *const IPMTilePropertyInfo, pPropID: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_PropertyID(self, pPropID);
    }
    pub fn get_PropertyValue(self: *const IPMTilePropertyInfo, pPropValue: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_PropertyValue(self, pPropValue);
    }
    pub fn set_Property(self: *const IPMTilePropertyInfo, PropValue: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.set_Property(self, PropValue);
    }
};

const IID_IPMTilePropertyEnumerator_Value = Guid.initString("cc4cd629-9047-4250-aac8-930e47812421");
pub const IID_IPMTilePropertyEnumerator = &IID_IPMTilePropertyEnumerator_Value;
pub const IPMTilePropertyEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMTilePropertyEnumerator,
            ppPropInfo: ?*?*IPMTilePropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMTilePropertyEnumerator, ppPropInfo: ?*?*IPMTilePropertyInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppPropInfo);
    }
};

const IID_IPMTileInfo_Value = Guid.initString("d1604833-2b08-4001-82cd-183ad734f752");
pub const IID_IPMTileInfo = &IID_IPMTileInfo_Value;
pub const IPMTileInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn(
            self: *const IPMTileInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileID: *const fn(
            self: *const IPMTileInfo,
            pTileID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TemplateType: *const fn(
            self: *const IPMTileInfo,
            pTemplateType: ?*TILE_TEMPLATE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HubPinnedState: *const fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            pPinned: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HubPosition: *const fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            pPosition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsNotified: *const fn(
            self: *const IPMTileInfo,
            pIsNotified: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsDefault: *const fn(
            self: *const IPMTileInfo,
            pIsDefault: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn(
            self: *const IPMTileInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileType: *const fn(
            self: *const IPMTileInfo,
            pStartTileType: ?*PM_STARTTILE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsThemable: *const fn(
            self: *const IPMTileInfo,
            pIsThemable: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PropertyById: *const fn(
            self: *const IPMTileInfo,
            PropID: u32,
            ppPropInfo: ?*?*IPMTilePropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InvocationInfo: *const fn(
            self: *const IPMTileInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PropertyEnum: *const fn(
            self: *const IPMTileInfo,
            ppTilePropEnum: ?*?*IPMTilePropertyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HubTileSize: *const fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            pSize: ?*PM_TILE_SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubPosition: *const fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            Position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NotifiedState: *const fn(
            self: *const IPMTileInfo,
            Notified: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubPinnedState: *const fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            Pinned: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_HubTileSize: *const fn(
            self: *const IPMTileInfo,
            HubType: PM_TILE_HUBTYPE,
            Size: PM_TILE_SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_InvocationInfo: *const fn(
            self: *const IPMTileInfo,
            TaskName: ?BSTR,
            TaskParameters: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTileBlob: *const fn(
            self: *const IPMTileInfo,
            pBlob: ?*PM_STARTTILEBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsRestoring: *const fn(
            self: *const IPMTileInfo,
            pIsRestoring: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsAutoRestoreDisabled: *const fn(
            self: *const IPMTileInfo,
            pIsAutoRestoreDisabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsRestoring: *const fn(
            self: *const IPMTileInfo,
            Restoring: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsAutoRestoreDisabled: *const fn(
            self: *const IPMTileInfo,
            AutoRestoreDisabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ProductID(self: *const IPMTileInfo, pProductID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_ProductID(self, pProductID);
    }
    pub fn get_TileID(self: *const IPMTileInfo, pTileID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_TileID(self, pTileID);
    }
    pub fn get_TemplateType(self: *const IPMTileInfo, pTemplateType: ?*TILE_TEMPLATE_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_TemplateType(self, pTemplateType);
    }
    pub fn get_HubPinnedState(self: *const IPMTileInfo, HubType: PM_TILE_HUBTYPE, pPinned: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_HubPinnedState(self, HubType, pPinned);
    }
    pub fn get_HubPosition(self: *const IPMTileInfo, HubType: PM_TILE_HUBTYPE, pPosition: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_HubPosition(self, HubType, pPosition);
    }
    pub fn get_IsNotified(self: *const IPMTileInfo, pIsNotified: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsNotified(self, pIsNotified);
    }
    pub fn get_IsDefault(self: *const IPMTileInfo, pIsDefault: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsDefault(self, pIsDefault);
    }
    pub fn get_TaskID(self: *const IPMTileInfo, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskID(self, pTaskID);
    }
    pub fn get_TileType(self: *const IPMTileInfo, pStartTileType: ?*PM_STARTTILE_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_TileType(self, pStartTileType);
    }
    pub fn get_IsThemable(self: *const IPMTileInfo, pIsThemable: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsThemable(self, pIsThemable);
    }
    pub fn get_PropertyById(self: *const IPMTileInfo, PropID: u32, ppPropInfo: ?*?*IPMTilePropertyInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_PropertyById(self, PropID, ppPropInfo);
    }
    pub fn get_InvocationInfo(self: *const IPMTileInfo, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pImageUrn, pParameters);
    }
    pub fn get_PropertyEnum(self: *const IPMTileInfo, ppTilePropEnum: ?*?*IPMTilePropertyEnumerator) callconv(.Inline) HRESULT {
        return self.vtable.get_PropertyEnum(self, ppTilePropEnum);
    }
    pub fn get_HubTileSize(self: *const IPMTileInfo, HubType: PM_TILE_HUBTYPE, pSize: ?*PM_TILE_SIZE) callconv(.Inline) HRESULT {
        return self.vtable.get_HubTileSize(self, HubType, pSize);
    }
    pub fn set_HubPosition(self: *const IPMTileInfo, HubType: PM_TILE_HUBTYPE, Position: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_HubPosition(self, HubType, Position);
    }
    pub fn set_NotifiedState(self: *const IPMTileInfo, Notified: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_NotifiedState(self, Notified);
    }
    pub fn set_HubPinnedState(self: *const IPMTileInfo, HubType: PM_TILE_HUBTYPE, Pinned: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_HubPinnedState(self, HubType, Pinned);
    }
    pub fn set_HubTileSize(self: *const IPMTileInfo, HubType: PM_TILE_HUBTYPE, Size: PM_TILE_SIZE) callconv(.Inline) HRESULT {
        return self.vtable.set_HubTileSize(self, HubType, Size);
    }
    pub fn set_InvocationInfo(self: *const IPMTileInfo, TaskName: ?BSTR, TaskParameters: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.set_InvocationInfo(self, TaskName, TaskParameters);
    }
    pub fn get_StartTileBlob(self: *const IPMTileInfo, pBlob: ?*PM_STARTTILEBLOB) callconv(.Inline) HRESULT {
        return self.vtable.get_StartTileBlob(self, pBlob);
    }
    pub fn get_IsRestoring(self: *const IPMTileInfo, pIsRestoring: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsRestoring(self, pIsRestoring);
    }
    pub fn get_IsAutoRestoreDisabled(self: *const IPMTileInfo, pIsAutoRestoreDisabled: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsAutoRestoreDisabled(self, pIsAutoRestoreDisabled);
    }
    pub fn set_IsRestoring(self: *const IPMTileInfo, Restoring: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_IsRestoring(self, Restoring);
    }
    pub fn set_IsAutoRestoreDisabled(self: *const IPMTileInfo, AutoRestoreDisabled: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_IsAutoRestoreDisabled(self, AutoRestoreDisabled);
    }
};

const IID_IPMTileInfoEnumerator_Value = Guid.initString("ded83065-e462-4b2c-acb5-e39cea61c874");
pub const IID_IPMTileInfoEnumerator = &IID_IPMTileInfoEnumerator_Value;
pub const IPMTileInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMTileInfoEnumerator,
            ppTileInfo: ?*?*IPMTileInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMTileInfoEnumerator, ppTileInfo: ?*?*IPMTileInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppTileInfo);
    }
};

const IID_IPMApplicationInfoEnumerator_Value = Guid.initString("0ec42a96-4d46-4dc6-a3d9-a7acaac0f5fa");
pub const IID_IPMApplicationInfoEnumerator = &IID_IPMApplicationInfoEnumerator_Value;
pub const IPMApplicationInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMApplicationInfoEnumerator,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMApplicationInfoEnumerator, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppAppInfo);
    }
};

const IID_IPMLiveTileJobInfo_Value = Guid.initString("6009a81f-4710-4697-b5f6-2208f6057b8e");
pub const IID_IPMLiveTileJobInfo = &IID_IPMLiveTileJobInfo_Value;
pub const IPMLiveTileJobInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn(
            self: *const IPMLiveTileJobInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TileID: *const fn(
            self: *const IPMLiveTileJobInfo,
            pTileID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NextSchedule: *const fn(
            self: *const IPMLiveTileJobInfo,
            pNextSchedule: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_NextSchedule: *const fn(
            self: *const IPMLiveTileJobInfo,
            ftNextSchedule: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartSchedule: *const fn(
            self: *const IPMLiveTileJobInfo,
            pStartSchedule: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_StartSchedule: *const fn(
            self: *const IPMLiveTileJobInfo,
            ftStartSchedule: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IntervalDuration: *const fn(
            self: *const IPMLiveTileJobInfo,
            pIntervalDuration: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IntervalDuration: *const fn(
            self: *const IPMLiveTileJobInfo,
            ulIntervalDuration: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunForever: *const fn(
            self: *const IPMLiveTileJobInfo,
            IsRunForever: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RunForever: *const fn(
            self: *const IPMLiveTileJobInfo,
            fRunForever: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxRunCount: *const fn(
            self: *const IPMLiveTileJobInfo,
            pMaxRunCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_MaxRunCount: *const fn(
            self: *const IPMLiveTileJobInfo,
            ulMaxRunCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RunCount: *const fn(
            self: *const IPMLiveTileJobInfo,
            pRunCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RunCount: *const fn(
            self: *const IPMLiveTileJobInfo,
            ulRunCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecurrenceType: *const fn(
            self: *const IPMLiveTileJobInfo,
            pRecurrenceType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_RecurrenceType: *const fn(
            self: *const IPMLiveTileJobInfo,
            ulRecurrenceType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TileXML: *const fn(
            self: *const IPMLiveTileJobInfo,
            pTileXml: [*]?*u8,
            pcbTileXml: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_TileXML: *const fn(
            self: *const IPMLiveTileJobInfo,
            pTileXml: [*:0]u8,
            cbTileXml: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_UrlXML: *const fn(
            self: *const IPMLiveTileJobInfo,
            pUrlXML: [*]?*u8,
            pcbUrlXML: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_UrlXML: *const fn(
            self: *const IPMLiveTileJobInfo,
            pUrlXML: [*:0]u8,
            cbUrlXML: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AttemptCount: *const fn(
            self: *const IPMLiveTileJobInfo,
            pAttemptCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_AttemptCount: *const fn(
            self: *const IPMLiveTileJobInfo,
            ulAttemptCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DownloadState: *const fn(
            self: *const IPMLiveTileJobInfo,
            pDownloadState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_DownloadState: *const fn(
            self: *const IPMLiveTileJobInfo,
            ulDownloadState: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ProductID(self: *const IPMLiveTileJobInfo, pProductID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_ProductID(self, pProductID);
    }
    pub fn get_TileID(self: *const IPMLiveTileJobInfo, pTileID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_TileID(self, pTileID);
    }
    pub fn get_NextSchedule(self: *const IPMLiveTileJobInfo, pNextSchedule: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.get_NextSchedule(self, pNextSchedule);
    }
    pub fn set_NextSchedule(self: *const IPMLiveTileJobInfo, ftNextSchedule: FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.set_NextSchedule(self, ftNextSchedule);
    }
    pub fn get_StartSchedule(self: *const IPMLiveTileJobInfo, pStartSchedule: ?*FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.get_StartSchedule(self, pStartSchedule);
    }
    pub fn set_StartSchedule(self: *const IPMLiveTileJobInfo, ftStartSchedule: FILETIME) callconv(.Inline) HRESULT {
        return self.vtable.set_StartSchedule(self, ftStartSchedule);
    }
    pub fn get_IntervalDuration(self: *const IPMLiveTileJobInfo, pIntervalDuration: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_IntervalDuration(self, pIntervalDuration);
    }
    pub fn set_IntervalDuration(self: *const IPMLiveTileJobInfo, ulIntervalDuration: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_IntervalDuration(self, ulIntervalDuration);
    }
    pub fn get_RunForever(self: *const IPMLiveTileJobInfo, IsRunForever: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_RunForever(self, IsRunForever);
    }
    pub fn set_RunForever(self: *const IPMLiveTileJobInfo, fRunForever: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_RunForever(self, fRunForever);
    }
    pub fn get_MaxRunCount(self: *const IPMLiveTileJobInfo, pMaxRunCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_MaxRunCount(self, pMaxRunCount);
    }
    pub fn set_MaxRunCount(self: *const IPMLiveTileJobInfo, ulMaxRunCount: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_MaxRunCount(self, ulMaxRunCount);
    }
    pub fn get_RunCount(self: *const IPMLiveTileJobInfo, pRunCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_RunCount(self, pRunCount);
    }
    pub fn set_RunCount(self: *const IPMLiveTileJobInfo, ulRunCount: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_RunCount(self, ulRunCount);
    }
    pub fn get_RecurrenceType(self: *const IPMLiveTileJobInfo, pRecurrenceType: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_RecurrenceType(self, pRecurrenceType);
    }
    pub fn set_RecurrenceType(self: *const IPMLiveTileJobInfo, ulRecurrenceType: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_RecurrenceType(self, ulRecurrenceType);
    }
    pub fn get_TileXML(self: *const IPMLiveTileJobInfo, pTileXml: [*]?*u8, pcbTileXml: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_TileXML(self, pTileXml, pcbTileXml);
    }
    pub fn set_TileXML(self: *const IPMLiveTileJobInfo, pTileXml: [*:0]u8, cbTileXml: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_TileXML(self, pTileXml, cbTileXml);
    }
    pub fn get_UrlXML(self: *const IPMLiveTileJobInfo, pUrlXML: [*]?*u8, pcbUrlXML: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_UrlXML(self, pUrlXML, pcbUrlXML);
    }
    pub fn set_UrlXML(self: *const IPMLiveTileJobInfo, pUrlXML: [*:0]u8, cbUrlXML: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_UrlXML(self, pUrlXML, cbUrlXML);
    }
    pub fn get_AttemptCount(self: *const IPMLiveTileJobInfo, pAttemptCount: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_AttemptCount(self, pAttemptCount);
    }
    pub fn set_AttemptCount(self: *const IPMLiveTileJobInfo, ulAttemptCount: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_AttemptCount(self, ulAttemptCount);
    }
    pub fn get_DownloadState(self: *const IPMLiveTileJobInfo, pDownloadState: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_DownloadState(self, pDownloadState);
    }
    pub fn set_DownloadState(self: *const IPMLiveTileJobInfo, ulDownloadState: u32) callconv(.Inline) HRESULT {
        return self.vtable.set_DownloadState(self, ulDownloadState);
    }
};

const IID_IPMLiveTileJobInfoEnumerator_Value = Guid.initString("bc042582-9415-4f36-9f99-06f104c07c03");
pub const IID_IPMLiveTileJobInfoEnumerator = &IID_IPMLiveTileJobInfoEnumerator_Value;
pub const IPMLiveTileJobInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMLiveTileJobInfoEnumerator,
            ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMLiveTileJobInfoEnumerator, ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppLiveTileJobInfo);
    }
};

const IID_IPMDeploymentManager_Value = Guid.initString("35f785fa-1979-4a8b-bc8f-fd70eb0d1544");
pub const IID_IPMDeploymentManager = &IID_IPMDeploymentManager_Value;
pub const IPMDeploymentManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportDownloadBegin: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadProgress: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            usProgress: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadComplete: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            hrResult: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginInstall: *const fn(
            self: *const IPMDeploymentManager,
            pInstallInfo: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdate: *const fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDeployPackage: *const fn(
            self: *const IPMDeploymentManager,
            pInstallInfo: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateDeployedPackageLegacy: *const fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO_LEGACY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUninstall: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEnterpriseAppInstall: *const fn(
            self: *const IPMDeploymentManager,
            pInstallInfo: ?*PM_INSTALLINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEnterpriseAppUpdate: *const fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateLicense: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            offerID: Guid,
            pbLicense: [*:0]u8,
            cbLicense: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallenge: *const fn(
            self: *const IPMDeploymentManager,
            PackagePath: ?BSTR,
            ppbChallenge: [*]?*u8,
            pcbChallenge: ?*u32,
            ppbKID: ?[*]?*u8,
            pcbKID: ?*u32,
            ppbDeviceID: ?[*]?*u8,
            pcbDeviceID: ?*u32,
            ppbSaltValue: ?[*]?*u8,
            pcbSaltValue: ?*u32,
            ppbKGVValue: ?[*]?*u8,
            pcbKGVValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallengeByProductID: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            ppbChallenge: [*]?*u8,
            pcbLicense: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseChallengeByProductID2: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            ppbChallenge: [*]?*u8,
            pcbLicense: ?*u32,
            ppbKID: ?[*]?*u8,
            pcbKID: ?*u32,
            ppbDeviceID: ?[*]?*u8,
            pcbDeviceID: ?*u32,
            ppbSaltValue: ?[*]?*u8,
            pcbSaltValue: ?*u32,
            ppbKGVValue: ?[*]?*u8,
            pcbKGVValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeLicense: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RebindMdilBinaries: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            FileNames: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RebindAllMdilBinaries: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            InstanceID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegenerateXbf: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            AssemblyPaths: ?*SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateXbfForCurrentLocale: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginProvision: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
            XMLpath: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDeprovision: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexSQLCEDatabases: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationsNeedMaintenance: *const fn(
            self: *const IPMDeploymentManager,
            RequiredMaintenanceOperations: u32,
            pcApplications: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateChamberProfile: *const fn(
            self: *const IPMDeploymentManager,
            ProductID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnterprisePolicyIsApplicationAllowed: *const fn(
            self: *const IPMDeploymentManager,
            productId: Guid,
            publisherName: ?[*:0]const u16,
            pIsAllowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUpdateDeployedPackage: *const fn(
            self: *const IPMDeploymentManager,
            pUpdateInfo: ?*PM_UPDATEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportRestoreCancelled: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveResourceString: *const fn(
            self: *const IPMDeploymentManager,
            resourceString: ?[*:0]const u16,
            pResolvedResourceString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateCapabilitiesForModernApps: *const fn(
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportDownloadStatusUpdate: *const fn(
            self: *const IPMDeploymentManager,
            productId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUninstallWithOptions: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            removalOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindDeferredMdilBinaries: *const fn(
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateXamlLightupXbfForCurrentLocale: *const fn(
            self: *const IPMDeploymentManager,
            PackageFamilyName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddLicenseForAppx: *const fn(
            self: *const IPMDeploymentManager,
            productID: Guid,
            pbLicense: [*:0]u8,
            cbLicense: u32,
            pbPlayReadyHeader: ?[*:0]u8,
            cbPlayReadyHeader: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FixJunctionsForAppsOnSDCard: *const fn(
            self: *const IPMDeploymentManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn ReportDownloadBegin(self: *const IPMDeploymentManager, productID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.ReportDownloadBegin(self, productID);
    }
    pub fn ReportDownloadProgress(self: *const IPMDeploymentManager, productID: Guid, usProgress: u16) callconv(.Inline) HRESULT {
        return self.vtable.ReportDownloadProgress(self, productID, usProgress);
    }
    pub fn ReportDownloadComplete(self: *const IPMDeploymentManager, productID: Guid, hrResult: HRESULT) callconv(.Inline) HRESULT {
        return self.vtable.ReportDownloadComplete(self, productID, hrResult);
    }
    pub fn BeginInstall(self: *const IPMDeploymentManager, pInstallInfo: ?*PM_INSTALLINFO) callconv(.Inline) HRESULT {
        return self.vtable.BeginInstall(self, pInstallInfo);
    }
    pub fn BeginUpdate(self: *const IPMDeploymentManager, pUpdateInfo: ?*PM_UPDATEINFO) callconv(.Inline) HRESULT {
        return self.vtable.BeginUpdate(self, pUpdateInfo);
    }
    pub fn BeginDeployPackage(self: *const IPMDeploymentManager, pInstallInfo: ?*PM_INSTALLINFO) callconv(.Inline) HRESULT {
        return self.vtable.BeginDeployPackage(self, pInstallInfo);
    }
    pub fn BeginUpdateDeployedPackageLegacy(self: *const IPMDeploymentManager, pUpdateInfo: ?*PM_UPDATEINFO_LEGACY) callconv(.Inline) HRESULT {
        return self.vtable.BeginUpdateDeployedPackageLegacy(self, pUpdateInfo);
    }
    pub fn BeginUninstall(self: *const IPMDeploymentManager, productID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.BeginUninstall(self, productID);
    }
    pub fn BeginEnterpriseAppInstall(self: *const IPMDeploymentManager, pInstallInfo: ?*PM_INSTALLINFO) callconv(.Inline) HRESULT {
        return self.vtable.BeginEnterpriseAppInstall(self, pInstallInfo);
    }
    pub fn BeginEnterpriseAppUpdate(self: *const IPMDeploymentManager, pUpdateInfo: ?*PM_UPDATEINFO) callconv(.Inline) HRESULT {
        return self.vtable.BeginEnterpriseAppUpdate(self, pUpdateInfo);
    }
    pub fn BeginUpdateLicense(self: *const IPMDeploymentManager, productID: Guid, offerID: Guid, pbLicense: [*:0]u8, cbLicense: u32) callconv(.Inline) HRESULT {
        return self.vtable.BeginUpdateLicense(self, productID, offerID, pbLicense, cbLicense);
    }
    pub fn GetLicenseChallenge(self: *const IPMDeploymentManager, PackagePath: ?BSTR, ppbChallenge: [*]?*u8, pcbChallenge: ?*u32, ppbKID: ?[*]?*u8, pcbKID: ?*u32, ppbDeviceID: ?[*]?*u8, pcbDeviceID: ?*u32, ppbSaltValue: ?[*]?*u8, pcbSaltValue: ?*u32, ppbKGVValue: ?[*]?*u8, pcbKGVValue: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetLicenseChallenge(self, PackagePath, ppbChallenge, pcbChallenge, ppbKID, pcbKID, ppbDeviceID, pcbDeviceID, ppbSaltValue, pcbSaltValue, ppbKGVValue, pcbKGVValue);
    }
    pub fn GetLicenseChallengeByProductID(self: *const IPMDeploymentManager, ProductID: Guid, ppbChallenge: [*]?*u8, pcbLicense: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetLicenseChallengeByProductID(self, ProductID, ppbChallenge, pcbLicense);
    }
    pub fn GetLicenseChallengeByProductID2(self: *const IPMDeploymentManager, ProductID: Guid, ppbChallenge: [*]?*u8, pcbLicense: ?*u32, ppbKID: ?[*]?*u8, pcbKID: ?*u32, ppbDeviceID: ?[*]?*u8, pcbDeviceID: ?*u32, ppbSaltValue: ?[*]?*u8, pcbSaltValue: ?*u32, ppbKGVValue: ?[*]?*u8, pcbKGVValue: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.GetLicenseChallengeByProductID2(self, ProductID, ppbChallenge, pcbLicense, ppbKID, pcbKID, ppbDeviceID, pcbDeviceID, ppbSaltValue, pcbSaltValue, ppbKGVValue, pcbKGVValue);
    }
    pub fn RevokeLicense(self: *const IPMDeploymentManager, productID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.RevokeLicense(self, productID);
    }
    pub fn RebindMdilBinaries(self: *const IPMDeploymentManager, ProductID: Guid, FileNames: ?*SAFEARRAY) callconv(.Inline) HRESULT {
        return self.vtable.RebindMdilBinaries(self, ProductID, FileNames);
    }
    pub fn RebindAllMdilBinaries(self: *const IPMDeploymentManager, ProductID: Guid, InstanceID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.RebindAllMdilBinaries(self, ProductID, InstanceID);
    }
    pub fn RegenerateXbf(self: *const IPMDeploymentManager, ProductID: Guid, AssemblyPaths: ?*SAFEARRAY) callconv(.Inline) HRESULT {
        return self.vtable.RegenerateXbf(self, ProductID, AssemblyPaths);
    }
    pub fn GenerateXbfForCurrentLocale(self: *const IPMDeploymentManager, ProductID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.GenerateXbfForCurrentLocale(self, ProductID);
    }
    pub fn BeginProvision(self: *const IPMDeploymentManager, ProductID: Guid, XMLpath: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.BeginProvision(self, ProductID, XMLpath);
    }
    pub fn BeginDeprovision(self: *const IPMDeploymentManager, ProductID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.BeginDeprovision(self, ProductID);
    }
    pub fn ReindexSQLCEDatabases(self: *const IPMDeploymentManager, ProductID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.ReindexSQLCEDatabases(self, ProductID);
    }
    pub fn SetApplicationsNeedMaintenance(self: *const IPMDeploymentManager, RequiredMaintenanceOperations: u32, pcApplications: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.SetApplicationsNeedMaintenance(self, RequiredMaintenanceOperations, pcApplications);
    }
    pub fn UpdateChamberProfile(self: *const IPMDeploymentManager, ProductID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.UpdateChamberProfile(self, ProductID);
    }
    pub fn EnterprisePolicyIsApplicationAllowed(self: *const IPMDeploymentManager, productId: Guid, publisherName: ?[*:0]const u16, pIsAllowed: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.EnterprisePolicyIsApplicationAllowed(self, productId, publisherName, pIsAllowed);
    }
    pub fn BeginUpdateDeployedPackage(self: *const IPMDeploymentManager, pUpdateInfo: ?*PM_UPDATEINFO) callconv(.Inline) HRESULT {
        return self.vtable.BeginUpdateDeployedPackage(self, pUpdateInfo);
    }
    pub fn ReportRestoreCancelled(self: *const IPMDeploymentManager, productID: Guid) callconv(.Inline) HRESULT {
        return self.vtable.ReportRestoreCancelled(self, productID);
    }
    pub fn ResolveResourceString(self: *const IPMDeploymentManager, resourceString: ?[*:0]const u16, pResolvedResourceString: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.ResolveResourceString(self, resourceString, pResolvedResourceString);
    }
    pub fn UpdateCapabilitiesForModernApps(self: *const IPMDeploymentManager) callconv(.Inline) HRESULT {
        return self.vtable.UpdateCapabilitiesForModernApps(self);
    }
    pub fn ReportDownloadStatusUpdate(self: *const IPMDeploymentManager, productId: Guid) callconv(.Inline) HRESULT {
        return self.vtable.ReportDownloadStatusUpdate(self, productId);
    }
    pub fn BeginUninstallWithOptions(self: *const IPMDeploymentManager, productID: Guid, removalOptions: u32) callconv(.Inline) HRESULT {
        return self.vtable.BeginUninstallWithOptions(self, productID, removalOptions);
    }
    pub fn BindDeferredMdilBinaries(self: *const IPMDeploymentManager) callconv(.Inline) HRESULT {
        return self.vtable.BindDeferredMdilBinaries(self);
    }
    pub fn GenerateXamlLightupXbfForCurrentLocale(self: *const IPMDeploymentManager, PackageFamilyName: ?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.GenerateXamlLightupXbfForCurrentLocale(self, PackageFamilyName);
    }
    pub fn AddLicenseForAppx(self: *const IPMDeploymentManager, productID: Guid, pbLicense: [*:0]u8, cbLicense: u32, pbPlayReadyHeader: ?[*:0]u8, cbPlayReadyHeader: u32) callconv(.Inline) HRESULT {
        return self.vtable.AddLicenseForAppx(self, productID, pbLicense, cbLicense, pbPlayReadyHeader, cbPlayReadyHeader);
    }
    pub fn FixJunctionsForAppsOnSDCard(self: *const IPMDeploymentManager) callconv(.Inline) HRESULT {
        return self.vtable.FixJunctionsForAppsOnSDCard(self);
    }
};

const IID_IPMEnumerationManager_Value = Guid.initString("698d57c2-292d-4cf3-b73c-d95a6922ed9a");
pub const IID_IPMEnumerationManager = &IID_IPMEnumerationManager_Value;
pub const IPMEnumerationManager = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_AllApplications: *const fn(
            self: *const IPMEnumerationManager,
            ppAppEnum: ?*?*IPMApplicationInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllTiles: *const fn(
            self: *const IPMEnumerationManager,
            ppTileEnum: ?*?*IPMTileInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllTasks: *const fn(
            self: *const IPMEnumerationManager,
            ppTaskEnum: ?*?*IPMTaskInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllExtensions: *const fn(
            self: *const IPMEnumerationManager,
            ppExtensionEnum: ?*?*IPMExtensionInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllBackgroundServiceAgents: *const fn(
            self: *const IPMEnumerationManager,
            ppBSAEnum: ?*?*IPMBackgroundServiceAgentInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllBackgroundWorkers: *const fn(
            self: *const IPMEnumerationManager,
            ppBSWEnum: ?*?*IPMBackgroundWorkerInfoEnumerator,
            Filter: PM_ENUM_FILTER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ApplicationInfo: *const fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TileInfo: *const fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TileID: ?BSTR,
            ppTileInfo: ?*?*IPMTileInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TaskInfo: *const fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TaskID: ?BSTR,
            ppTaskInfo: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TaskInfoEx: *const fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TaskID: ?[*:0]const u16,
            ppTaskInfo: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BackgroundServiceAgentInfo: *const fn(
            self: *const IPMEnumerationManager,
            BSAID: u32,
            ppTaskInfo: ?*?*IPMBackgroundServiceAgentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AllLiveTileJobs: *const fn(
            self: *const IPMEnumerationManager,
            ppLiveTileJobEnum: ?*?*IPMLiveTileJobInfoEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_LiveTileJob: *const fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            TileID: ?BSTR,
            RecurrenceType: PM_LIVETILE_RECURRENCE_TYPE,
            ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ApplicationInfoExternal: *const fn(
            self: *const IPMEnumerationManager,
            ProductID: Guid,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FileHandlerGenericLogo: *const fn(
            self: *const IPMEnumerationManager,
            FileType: ?BSTR,
            LogoSize: PM_LOGO_SIZE,
            pLogo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ApplicationInfoFromAccessClaims: *const fn(
            self: *const IPMEnumerationManager,
            SysAppID0: ?BSTR,
            SysAppID1: ?BSTR,
            ppAppInfo: ?*?*IPMApplicationInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StartTileEnumeratorBlob: *const fn(
            self: *const IPMEnumerationManager,
            Filter: PM_ENUM_FILTER,
            pcTiles: ?*u32,
            ppTileBlobs: [*]?*PM_STARTTILEBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StartAppEnumeratorBlob: *const fn(
            self: *const IPMEnumerationManager,
            Filter: PM_ENUM_FILTER,
            pcApps: ?*u32,
            ppAppBlobs: [*]?*PM_STARTAPPBLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_AllApplications(self: *const IPMEnumerationManager, ppAppEnum: ?*?*IPMApplicationInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
        return self.vtable.get_AllApplications(self, ppAppEnum, Filter);
    }
    pub fn get_AllTiles(self: *const IPMEnumerationManager, ppTileEnum: ?*?*IPMTileInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
        return self.vtable.get_AllTiles(self, ppTileEnum, Filter);
    }
    pub fn get_AllTasks(self: *const IPMEnumerationManager, ppTaskEnum: ?*?*IPMTaskInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
        return self.vtable.get_AllTasks(self, ppTaskEnum, Filter);
    }
    pub fn get_AllExtensions(self: *const IPMEnumerationManager, ppExtensionEnum: ?*?*IPMExtensionInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
        return self.vtable.get_AllExtensions(self, ppExtensionEnum, Filter);
    }
    pub fn get_AllBackgroundServiceAgents(self: *const IPMEnumerationManager, ppBSAEnum: ?*?*IPMBackgroundServiceAgentInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
        return self.vtable.get_AllBackgroundServiceAgents(self, ppBSAEnum, Filter);
    }
    pub fn get_AllBackgroundWorkers(self: *const IPMEnumerationManager, ppBSWEnum: ?*?*IPMBackgroundWorkerInfoEnumerator, Filter: PM_ENUM_FILTER) callconv(.Inline) HRESULT {
        return self.vtable.get_AllBackgroundWorkers(self, ppBSWEnum, Filter);
    }
    pub fn get_ApplicationInfo(self: *const IPMEnumerationManager, ProductID: Guid, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_ApplicationInfo(self, ProductID, ppAppInfo);
    }
    pub fn get_TileInfo(self: *const IPMEnumerationManager, ProductID: Guid, TileID: ?BSTR, ppTileInfo: ?*?*IPMTileInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_TileInfo(self, ProductID, TileID, ppTileInfo);
    }
    pub fn get_TaskInfo(self: *const IPMEnumerationManager, ProductID: Guid, TaskID: ?BSTR, ppTaskInfo: ?*?*IPMTaskInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskInfo(self, ProductID, TaskID, ppTaskInfo);
    }
    pub fn get_TaskInfoEx(self: *const IPMEnumerationManager, ProductID: Guid, TaskID: ?[*:0]const u16, ppTaskInfo: ?*?*IPMTaskInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskInfoEx(self, ProductID, TaskID, ppTaskInfo);
    }
    pub fn get_BackgroundServiceAgentInfo(self: *const IPMEnumerationManager, BSAID: u32, ppTaskInfo: ?*?*IPMBackgroundServiceAgentInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_BackgroundServiceAgentInfo(self, BSAID, ppTaskInfo);
    }
    pub fn get_AllLiveTileJobs(self: *const IPMEnumerationManager, ppLiveTileJobEnum: ?*?*IPMLiveTileJobInfoEnumerator) callconv(.Inline) HRESULT {
        return self.vtable.get_AllLiveTileJobs(self, ppLiveTileJobEnum);
    }
    pub fn get_LiveTileJob(self: *const IPMEnumerationManager, ProductID: Guid, TileID: ?BSTR, RecurrenceType: PM_LIVETILE_RECURRENCE_TYPE, ppLiveTileJobInfo: ?*?*IPMLiveTileJobInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_LiveTileJob(self, ProductID, TileID, RecurrenceType, ppLiveTileJobInfo);
    }
    pub fn get_ApplicationInfoExternal(self: *const IPMEnumerationManager, ProductID: Guid, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_ApplicationInfoExternal(self, ProductID, ppAppInfo);
    }
    pub fn get_FileHandlerGenericLogo(self: *const IPMEnumerationManager, FileType: ?BSTR, LogoSize: PM_LOGO_SIZE, pLogo: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_FileHandlerGenericLogo(self, FileType, LogoSize, pLogo);
    }
    pub fn get_ApplicationInfoFromAccessClaims(self: *const IPMEnumerationManager, SysAppID0: ?BSTR, SysAppID1: ?BSTR, ppAppInfo: ?*?*IPMApplicationInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_ApplicationInfoFromAccessClaims(self, SysAppID0, SysAppID1, ppAppInfo);
    }
    pub fn get_StartTileEnumeratorBlob(self: *const IPMEnumerationManager, Filter: PM_ENUM_FILTER, pcTiles: ?*u32, ppTileBlobs: [*]?*PM_STARTTILEBLOB) callconv(.Inline) HRESULT {
        return self.vtable.get_StartTileEnumeratorBlob(self, Filter, pcTiles, ppTileBlobs);
    }
    pub fn get_StartAppEnumeratorBlob(self: *const IPMEnumerationManager, Filter: PM_ENUM_FILTER, pcApps: ?*u32, ppAppBlobs: [*]?*PM_STARTAPPBLOB) callconv(.Inline) HRESULT {
        return self.vtable.get_StartAppEnumeratorBlob(self, Filter, pcApps, ppAppBlobs);
    }
};

const IID_IPMTaskInfo_Value = Guid.initString("bf1d8c33-1bf5-4ee0-b549-6b9dd3834942");
pub const IID_IPMTaskInfo = &IID_IPMTaskInfo_Value;
pub const IPMTaskInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn(
            self: *const IPMTaskInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn(
            self: *const IPMTaskInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NavigationPage: *const fn(
            self: *const IPMTaskInfo,
            pNavigationPage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskTransition: *const fn(
            self: *const IPMTaskInfo,
            pTaskTransition: ?*PM_TASK_TRANSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RuntimeType: *const fn(
            self: *const IPMTaskInfo,
            pRuntimetype: ?*PACKMAN_RUNTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ActivationPolicy: *const fn(
            self: *const IPMTaskInfo,
            pActivationPolicy: ?*PM_ACTIVATION_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskType: *const fn(
            self: *const IPMTaskInfo,
            pTaskType: ?*PM_TASK_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InvocationInfo: *const fn(
            self: *const IPMTaskInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImagePath: *const fn(
            self: *const IPMTaskInfo,
            pImagePath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ImageParams: *const fn(
            self: *const IPMTaskInfo,
            pImageParams: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallRootFolder: *const fn(
            self: *const IPMTaskInfo,
            pInstallRootFolder: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataRootFolder: *const fn(
            self: *const IPMTaskInfo,
            pDataRootFolder: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsSingleInstanceHost: *const fn(
            self: *const IPMTaskInfo,
            pIsSingleInstanceHost: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsInteropEnabled: *const fn(
            self: *const IPMTaskInfo,
            pIsInteropEnabled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ApplicationState: *const fn(
            self: *const IPMTaskInfo,
            pApplicationState: ?*PM_APPLICATION_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InstallType: *const fn(
            self: *const IPMTaskInfo,
            pInstallType: ?*PM_APPLICATION_INSTALL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Version: *const fn(
            self: *const IPMTaskInfo,
            pTargetMajorVersion: ?*u8,
            pTargetMinorVersion: ?*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitsPerPixel: *const fn(
            self: *const IPMTaskInfo,
            pBitsPerPixel: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressesDehydration: *const fn(
            self: *const IPMTaskInfo,
            pSuppressesDehydration: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundExecutionAbilities: *const fn(
            self: *const IPMTaskInfo,
            pBackgroundExecutionAbilities: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsOptedForExtendedMem: *const fn(
            self: *const IPMTaskInfo,
            pIsOptedIn: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ProductID(self: *const IPMTaskInfo, pProductID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_ProductID(self, pProductID);
    }
    pub fn get_TaskID(self: *const IPMTaskInfo, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskID(self, pTaskID);
    }
    pub fn get_NavigationPage(self: *const IPMTaskInfo, pNavigationPage: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_NavigationPage(self, pNavigationPage);
    }
    pub fn get_TaskTransition(self: *const IPMTaskInfo, pTaskTransition: ?*PM_TASK_TRANSITION) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskTransition(self, pTaskTransition);
    }
    pub fn get_RuntimeType(self: *const IPMTaskInfo, pRuntimetype: ?*PACKMAN_RUNTIME) callconv(.Inline) HRESULT {
        return self.vtable.get_RuntimeType(self, pRuntimetype);
    }
    pub fn get_ActivationPolicy(self: *const IPMTaskInfo, pActivationPolicy: ?*PM_ACTIVATION_POLICY) callconv(.Inline) HRESULT {
        return self.vtable.get_ActivationPolicy(self, pActivationPolicy);
    }
    pub fn get_TaskType(self: *const IPMTaskInfo, pTaskType: ?*PM_TASK_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskType(self, pTaskType);
    }
    pub fn get_InvocationInfo(self: *const IPMTaskInfo, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pImageUrn, pParameters);
    }
    pub fn get_ImagePath(self: *const IPMTaskInfo, pImagePath: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ImagePath(self, pImagePath);
    }
    pub fn get_ImageParams(self: *const IPMTaskInfo, pImageParams: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ImageParams(self, pImageParams);
    }
    pub fn get_InstallRootFolder(self: *const IPMTaskInfo, pInstallRootFolder: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InstallRootFolder(self, pInstallRootFolder);
    }
    pub fn get_DataRootFolder(self: *const IPMTaskInfo, pDataRootFolder: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_DataRootFolder(self, pDataRootFolder);
    }
    pub fn get_IsSingleInstanceHost(self: *const IPMTaskInfo, pIsSingleInstanceHost: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsSingleInstanceHost(self, pIsSingleInstanceHost);
    }
    pub fn get_IsInteropEnabled(self: *const IPMTaskInfo, pIsInteropEnabled: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsInteropEnabled(self, pIsInteropEnabled);
    }
    pub fn get_ApplicationState(self: *const IPMTaskInfo, pApplicationState: ?*PM_APPLICATION_STATE) callconv(.Inline) HRESULT {
        return self.vtable.get_ApplicationState(self, pApplicationState);
    }
    pub fn get_InstallType(self: *const IPMTaskInfo, pInstallType: ?*PM_APPLICATION_INSTALL_TYPE) callconv(.Inline) HRESULT {
        return self.vtable.get_InstallType(self, pInstallType);
    }
    pub fn get_Version(self: *const IPMTaskInfo, pTargetMajorVersion: ?*u8, pTargetMinorVersion: ?*u8) callconv(.Inline) HRESULT {
        return self.vtable.get_Version(self, pTargetMajorVersion, pTargetMinorVersion);
    }
    pub fn get_BitsPerPixel(self: *const IPMTaskInfo, pBitsPerPixel: ?*u16) callconv(.Inline) HRESULT {
        return self.vtable.get_BitsPerPixel(self, pBitsPerPixel);
    }
    pub fn get_SuppressesDehydration(self: *const IPMTaskInfo, pSuppressesDehydration: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_SuppressesDehydration(self, pSuppressesDehydration);
    }
    pub fn get_BackgroundExecutionAbilities(self: *const IPMTaskInfo, pBackgroundExecutionAbilities: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BackgroundExecutionAbilities(self, pBackgroundExecutionAbilities);
    }
    pub fn get_IsOptedForExtendedMem(self: *const IPMTaskInfo, pIsOptedIn: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsOptedForExtendedMem(self, pIsOptedIn);
    }
};

const IID_IPMTaskInfoEnumerator_Value = Guid.initString("0630b0f8-0bbc-4821-be74-c7995166ed2a");
pub const IID_IPMTaskInfoEnumerator = &IID_IPMTaskInfoEnumerator_Value;
pub const IPMTaskInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMTaskInfoEnumerator,
            ppTaskInfo: ?*?*IPMTaskInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMTaskInfoEnumerator, ppTaskInfo: ?*?*IPMTaskInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppTaskInfo);
    }
};

const IID_IPMExtensionInfo_Value = Guid.initString("49acde79-9788-4d0a-8aa0-1746afdb9e9d");
pub const IID_IPMExtensionInfo = &IID_IPMExtensionInfo_Value;
pub const IPMExtensionInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupplierPID: *const fn(
            self: *const IPMExtensionInfo,
            pSupplierPID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupplierTaskID: *const fn(
            self: *const IPMExtensionInfo,
            pSupplierTID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: *const fn(
            self: *const IPMExtensionInfo,
            pTitle: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IconPath: *const fn(
            self: *const IPMExtensionInfo,
            pIconPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExtraFile: *const fn(
            self: *const IPMExtensionInfo,
            pFilePath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InvocationInfo: *const fn(
            self: *const IPMExtensionInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_SupplierPID(self: *const IPMExtensionInfo, pSupplierPID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_SupplierPID(self, pSupplierPID);
    }
    pub fn get_SupplierTaskID(self: *const IPMExtensionInfo, pSupplierTID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_SupplierTaskID(self, pSupplierTID);
    }
    pub fn get_Title(self: *const IPMExtensionInfo, pTitle: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Title(self, pTitle);
    }
    pub fn get_IconPath(self: *const IPMExtensionInfo, pIconPath: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_IconPath(self, pIconPath);
    }
    pub fn get_ExtraFile(self: *const IPMExtensionInfo, pFilePath: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ExtraFile(self, pFilePath);
    }
    pub fn get_InvocationInfo(self: *const IPMExtensionInfo, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pImageUrn, pParameters);
    }
};

const IID_IPMExtensionFileExtensionInfo_Value = Guid.initString("6b87cb6c-0b88-4989-a4ec-033714f710d4");
pub const IID_IPMExtensionFileExtensionInfo = &IID_IPMExtensionFileExtensionInfo_Value;
pub const IPMExtensionFileExtensionInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            pName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplayName: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            pDisplayName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Logo: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            LogoSize: PM_LOGO_SIZE,
            pLogo: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ContentType: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            FileType: ?BSTR,
            pContentType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FileType: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            ContentType: ?BSTR,
            pFileType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InvocationInfo: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllFileTypes: *const fn(
            self: *const IPMExtensionFileExtensionInfo,
            pcbTypes: ?*u32,
            ppTypes: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Name(self: *const IPMExtensionFileExtensionInfo, pName: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Name(self, pName);
    }
    pub fn get_DisplayName(self: *const IPMExtensionFileExtensionInfo, pDisplayName: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_DisplayName(self, pDisplayName);
    }
    pub fn get_Logo(self: *const IPMExtensionFileExtensionInfo, LogoSize: PM_LOGO_SIZE, pLogo: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Logo(self, LogoSize, pLogo);
    }
    pub fn get_ContentType(self: *const IPMExtensionFileExtensionInfo, FileType: ?BSTR, pContentType: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_ContentType(self, FileType, pContentType);
    }
    pub fn get_FileType(self: *const IPMExtensionFileExtensionInfo, ContentType: ?BSTR, pFileType: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_FileType(self, ContentType, pFileType);
    }
    pub fn get_InvocationInfo(self: *const IPMExtensionFileExtensionInfo, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pImageUrn, pParameters);
    }
    pub fn get_AllFileTypes(self: *const IPMExtensionFileExtensionInfo, pcbTypes: ?*u32, ppTypes: [*]?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_AllFileTypes(self, pcbTypes, ppTypes);
    }
};

const IID_IPMExtensionProtocolInfo_Value = Guid.initString("1e3fa036-51eb-4453-baff-b8d8e4b46c8e");
pub const IID_IPMExtensionProtocolInfo = &IID_IPMExtensionProtocolInfo_Value;
pub const IPMExtensionProtocolInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Protocol: *const fn(
            self: *const IPMExtensionProtocolInfo,
            pProtocol: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InvocationInfo: *const fn(
            self: *const IPMExtensionProtocolInfo,
            pImageUrn: ?*?BSTR,
            pParameters: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Protocol(self: *const IPMExtensionProtocolInfo, pProtocol: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Protocol(self, pProtocol);
    }
    pub fn get_InvocationInfo(self: *const IPMExtensionProtocolInfo, pImageUrn: ?*?BSTR, pParameters: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pImageUrn, pParameters);
    }
};

const IID_IPMExtensionShareTargetInfo_Value = Guid.initString("5471f48b-c65c-4656-8c70-242e31195fea");
pub const IID_IPMExtensionShareTargetInfo = &IID_IPMExtensionShareTargetInfo_Value;
pub const IPMExtensionShareTargetInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_AllFileTypes: *const fn(
            self: *const IPMExtensionShareTargetInfo,
            pcTypes: ?*u32,
            ppTypes: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllDataFormats: *const fn(
            self: *const IPMExtensionShareTargetInfo,
            pcDataFormats: ?*u32,
            ppDataFormats: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: *const fn(
            self: *const IPMExtensionShareTargetInfo,
            pSupportsAllTypes: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_AllFileTypes(self: *const IPMExtensionShareTargetInfo, pcTypes: ?*u32, ppTypes: [*]?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_AllFileTypes(self, pcTypes, ppTypes);
    }
    pub fn get_AllDataFormats(self: *const IPMExtensionShareTargetInfo, pcDataFormats: ?*u32, ppDataFormats: [*]?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_AllDataFormats(self, pcDataFormats, ppDataFormats);
    }
    pub fn get_SupportsAllFileTypes(self: *const IPMExtensionShareTargetInfo, pSupportsAllTypes: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_SupportsAllFileTypes(self, pSupportsAllTypes);
    }
};

const IID_IPMExtensionContractInfo_Value = Guid.initString("e5666373-7ba1-467c-b819-b175db1c295b");
pub const IID_IPMExtensionContractInfo = &IID_IPMExtensionContractInfo_Value;
pub const IPMExtensionContractInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_InvocationInfo: *const fn(
            self: *const IPMExtensionContractInfo,
            pAUMID: ?*?BSTR,
            pArgs: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_InvocationInfo(self: *const IPMExtensionContractInfo, pAUMID: ?*?BSTR, pArgs: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_InvocationInfo(self, pAUMID, pArgs);
    }
};

const IID_IPMExtensionFileOpenPickerInfo_Value = Guid.initString("6dc91d25-9606-420c-9a78-e034a3418345");
pub const IID_IPMExtensionFileOpenPickerInfo = &IID_IPMExtensionFileOpenPickerInfo_Value;
pub const IPMExtensionFileOpenPickerInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_AllFileTypes: *const fn(
            self: *const IPMExtensionFileOpenPickerInfo,
            pcTypes: ?*u32,
            ppTypes: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: *const fn(
            self: *const IPMExtensionFileOpenPickerInfo,
            pSupportsAllTypes: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_AllFileTypes(self: *const IPMExtensionFileOpenPickerInfo, pcTypes: ?*u32, ppTypes: [*]?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_AllFileTypes(self, pcTypes, ppTypes);
    }
    pub fn get_SupportsAllFileTypes(self: *const IPMExtensionFileOpenPickerInfo, pSupportsAllTypes: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_SupportsAllFileTypes(self, pSupportsAllTypes);
    }
};

const IID_IPMExtensionFileSavePickerInfo_Value = Guid.initString("38005cba-f81a-493e-a0f8-922c8680da43");
pub const IID_IPMExtensionFileSavePickerInfo = &IID_IPMExtensionFileSavePickerInfo_Value;
pub const IPMExtensionFileSavePickerInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_AllFileTypes: *const fn(
            self: *const IPMExtensionFileSavePickerInfo,
            pcTypes: ?*u32,
            ppTypes: [*]?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsAllFileTypes: *const fn(
            self: *const IPMExtensionFileSavePickerInfo,
            pSupportsAllTypes: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_AllFileTypes(self: *const IPMExtensionFileSavePickerInfo, pcTypes: ?*u32, ppTypes: [*]?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_AllFileTypes(self, pcTypes, ppTypes);
    }
    pub fn get_SupportsAllFileTypes(self: *const IPMExtensionFileSavePickerInfo, pSupportsAllTypes: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_SupportsAllFileTypes(self, pSupportsAllTypes);
    }
};

const IID_IPMExtensionCachedFileUpdaterInfo_Value = Guid.initString("e2d77509-4e58-4ba9-af7e-b642e370e1b0");
pub const IID_IPMExtensionCachedFileUpdaterInfo = &IID_IPMExtensionCachedFileUpdaterInfo_Value;
pub const IPMExtensionCachedFileUpdaterInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SupportsUpdates: *const fn(
            self: *const IPMExtensionCachedFileUpdaterInfo,
            pSupportsUpdates: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_SupportsUpdates(self: *const IPMExtensionCachedFileUpdaterInfo, pSupportsUpdates: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_SupportsUpdates(self, pSupportsUpdates);
    }
};

const IID_IPMExtensionInfoEnumerator_Value = Guid.initString("403b9e82-1171-4573-8e6f-6f33f39b83dd");
pub const IID_IPMExtensionInfoEnumerator = &IID_IPMExtensionInfoEnumerator_Value;
pub const IPMExtensionInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMExtensionInfoEnumerator,
            ppExtensionInfo: ?*?*IPMExtensionInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMExtensionInfoEnumerator, ppExtensionInfo: ?*?*IPMExtensionInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppExtensionInfo);
    }
};

const IID_IPMBackgroundServiceAgentInfo_Value = Guid.initString("3a8b46da-928c-4879-998c-09dc96f3d490");
pub const IID_IPMBackgroundServiceAgentInfo = &IID_IPMBackgroundServiceAgentInfo_Value;
pub const IPMBackgroundServiceAgentInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BSAID: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBSAID: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGSpecifier: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGSpecifier: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGName: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGSource: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGSource: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGType: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pBGType: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsPeriodic: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pIsPeriodic: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScheduled: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pIsScheduled: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsScheduleAllowed: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pIsScheduleAllowed: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsLaunchOnBoot: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            pLaunchOnBoot: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsScheduled: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            IsScheduled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        set_IsScheduleAllowed: *const fn(
            self: *const IPMBackgroundServiceAgentInfo,
            IsScheduleAllowed: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ProductID(self: *const IPMBackgroundServiceAgentInfo, pProductID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_ProductID(self, pProductID);
    }
    pub fn get_TaskID(self: *const IPMBackgroundServiceAgentInfo, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskID(self, pTaskID);
    }
    pub fn get_BSAID(self: *const IPMBackgroundServiceAgentInfo, pBSAID: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_BSAID(self, pBSAID);
    }
    pub fn get_BGSpecifier(self: *const IPMBackgroundServiceAgentInfo, pBGSpecifier: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BGSpecifier(self, pBGSpecifier);
    }
    pub fn get_BGName(self: *const IPMBackgroundServiceAgentInfo, pBGName: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BGName(self, pBGName);
    }
    pub fn get_BGSource(self: *const IPMBackgroundServiceAgentInfo, pBGSource: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BGSource(self, pBGSource);
    }
    pub fn get_BGType(self: *const IPMBackgroundServiceAgentInfo, pBGType: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BGType(self, pBGType);
    }
    pub fn get_IsPeriodic(self: *const IPMBackgroundServiceAgentInfo, pIsPeriodic: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsPeriodic(self, pIsPeriodic);
    }
    pub fn get_IsScheduled(self: *const IPMBackgroundServiceAgentInfo, pIsScheduled: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsScheduled(self, pIsScheduled);
    }
    pub fn get_IsScheduleAllowed(self: *const IPMBackgroundServiceAgentInfo, pIsScheduleAllowed: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsScheduleAllowed(self, pIsScheduleAllowed);
    }
    pub fn get_Description(self: *const IPMBackgroundServiceAgentInfo, pDescription: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_Description(self, pDescription);
    }
    pub fn get_IsLaunchOnBoot(self: *const IPMBackgroundServiceAgentInfo, pLaunchOnBoot: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsLaunchOnBoot(self, pLaunchOnBoot);
    }
    pub fn set_IsScheduled(self: *const IPMBackgroundServiceAgentInfo, IsScheduled: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_IsScheduled(self, IsScheduled);
    }
    pub fn set_IsScheduleAllowed(self: *const IPMBackgroundServiceAgentInfo, IsScheduleAllowed: BOOL) callconv(.Inline) HRESULT {
        return self.vtable.set_IsScheduleAllowed(self, IsScheduleAllowed);
    }
};

const IID_IPMBackgroundWorkerInfo_Value = Guid.initString("7dd4531b-d3bf-4b6b-94f3-69c098b1497d");
pub const IID_IPMBackgroundWorkerInfo = &IID_IPMBackgroundWorkerInfo_Value;
pub const IPMBackgroundWorkerInfo = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProductID: *const fn(
            self: *const IPMBackgroundWorkerInfo,
            pProductID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TaskID: *const fn(
            self: *const IPMBackgroundWorkerInfo,
            pTaskID: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BGName: *const fn(
            self: *const IPMBackgroundWorkerInfo,
            pBGName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxStartupLatency: *const fn(
            self: *const IPMBackgroundWorkerInfo,
            pMaxStartupLatency: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExpectedRuntime: *const fn(
            self: *const IPMBackgroundWorkerInfo,
            pExpectedRuntime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBootWorker: *const fn(
            self: *const IPMBackgroundWorkerInfo,
            pIsBootWorker: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_ProductID(self: *const IPMBackgroundWorkerInfo, pProductID: ?*Guid) callconv(.Inline) HRESULT {
        return self.vtable.get_ProductID(self, pProductID);
    }
    pub fn get_TaskID(self: *const IPMBackgroundWorkerInfo, pTaskID: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_TaskID(self, pTaskID);
    }
    pub fn get_BGName(self: *const IPMBackgroundWorkerInfo, pBGName: ?*?BSTR) callconv(.Inline) HRESULT {
        return self.vtable.get_BGName(self, pBGName);
    }
    pub fn get_MaxStartupLatency(self: *const IPMBackgroundWorkerInfo, pMaxStartupLatency: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_MaxStartupLatency(self, pMaxStartupLatency);
    }
    pub fn get_ExpectedRuntime(self: *const IPMBackgroundWorkerInfo, pExpectedRuntime: ?*u32) callconv(.Inline) HRESULT {
        return self.vtable.get_ExpectedRuntime(self, pExpectedRuntime);
    }
    pub fn get_IsBootWorker(self: *const IPMBackgroundWorkerInfo, pIsBootWorker: ?*BOOL) callconv(.Inline) HRESULT {
        return self.vtable.get_IsBootWorker(self, pIsBootWorker);
    }
};

const IID_IPMBackgroundServiceAgentInfoEnumerator_Value = Guid.initString("18eb2072-ab56-43b3-872c-beafb7a6b391");
pub const IID_IPMBackgroundServiceAgentInfoEnumerator = &IID_IPMBackgroundServiceAgentInfoEnumerator_Value;
pub const IPMBackgroundServiceAgentInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMBackgroundServiceAgentInfoEnumerator,
            ppBSAInfo: ?*?*IPMBackgroundServiceAgentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMBackgroundServiceAgentInfoEnumerator, ppBSAInfo: ?*?*IPMBackgroundServiceAgentInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppBSAInfo);
    }
};

const IID_IPMBackgroundWorkerInfoEnumerator_Value = Guid.initString("87f479f8-90d8-4ec7-92b9-72787e2f636b");
pub const IID_IPMBackgroundWorkerInfoEnumerator = &IID_IPMBackgroundWorkerInfoEnumerator_Value;
pub const IPMBackgroundWorkerInfoEnumerator = extern union {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Next: *const fn(
            self: *const IPMBackgroundWorkerInfoEnumerator,
            ppBWInfo: ?*?*IPMBackgroundWorkerInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    IUnknown: IUnknown,
    pub fn get_Next(self: *const IPMBackgroundWorkerInfoEnumerator, ppBWInfo: ?*?*IPMBackgroundWorkerInfo) callconv(.Inline) HRESULT {
        return self.vtable.get_Next(self, ppBWInfo);
    }
};

pub const PPATCH_PROGRESS_CALLBACK = *const fn(
    CallbackContext: ?*anyopaque,
    CurrentPosition: u32,
    MaximumPosition: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PPATCH_SYMLOAD_CALLBACK = *const fn(
    WhichFile: u32,
    SymbolFileName: ?[*:0]const u8,
    SymType: u32,
    SymbolFileCheckSum: u32,
    SymbolFileTimeDate: u32,
    ImageFileCheckSum: u32,
    ImageFileTimeDate: u32,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PATCH_IGNORE_RANGE = extern struct {
    OffsetInOldFile: u32,
    LengthInBytes: u32,
};

pub const PATCH_RETAIN_RANGE = extern struct {
    OffsetInOldFile: u32,
    LengthInBytes: u32,
    OffsetInNewFile: u32,
};

pub const PATCH_OLD_FILE_INFO_A = extern struct {
    SizeOfThisStruct: u32,
    OldFileName: ?[*:0]const u8,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO_W = extern struct {
    SizeOfThisStruct: u32,
    OldFileName: ?[*:0]const u16,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO_H = extern struct {
    SizeOfThisStruct: u32,
    OldFileHandle: ?HANDLE,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_OLD_FILE_INFO = extern struct {
    SizeOfThisStruct: u32,
    Anonymous: extern union {
        OldFileNameA: ?[*:0]const u8,
        OldFileNameW: ?[*:0]const u16,
        OldFileHandle: ?HANDLE,
    },
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?*PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?*PATCH_RETAIN_RANGE,
};

pub const PATCH_INTERLEAVE_MAP = extern struct {
    CountRanges: u32,
    Range: [1]extern struct {
        OldOffset: u32,
        OldLength: u32,
        NewLength: u32,
    },
};

pub const PATCH_OPTION_DATA = extern struct {
    SizeOfThisStruct: u32,
    SymbolOptionFlags: u32,
    NewFileSymbolPath: ?[*:0]const u8,
    OldFileSymbolPathArray: ?*?PSTR,
    ExtendedOptionFlags: u32,
    SymLoadCallback: ?PPATCH_SYMLOAD_CALLBACK,
    SymLoadContext: ?*anyopaque,
    InterleaveMapArray: ?*?*PATCH_INTERLEAVE_MAP,
    MaxLzxWindowSize: u32,
};

pub const DELTA_INPUT = extern struct {
    Anonymous: extern union {
        lpcStart: ?*const anyopaque,
        lpStart: ?*anyopaque,
    },
    uSize: usize,
    Editable: BOOL,
};

pub const DELTA_OUTPUT = extern struct {
    lpStart: ?*anyopaque,
    uSize: usize,
};

pub const DELTA_HASH = extern struct {
    HashSize: u32,
    HashValue: [32]u8,
};

pub const DELTA_HEADER_INFO = extern struct {
    FileTypeSet: i64,
    FileType: i64,
    Flags: i64,
    TargetSize: usize,
    TargetFileTime: FILETIME,
    TargetHashAlgId: u32,
    TargetHash: DELTA_HASH,
};

pub const ACTIVATION_CONTEXT_QUERY_INDEX = extern struct {
    ulAssemblyIndex: u32,
    ulFileIndexInAssembly: u32,
};

pub const ASSEMBLY_FILE_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulFilenameLength: u32,
    ulPathLength: u32,
    lpFileName: ?[*:0]const u16,
    lpFilePath: ?[*:0]const u16,
};

pub const ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulEncodedAssemblyIdentityLength: u32,
    ulManifestPathType: u32,
    ulManifestPathLength: u32,
    liManifestLastWriteTime: LARGE_INTEGER,
    ulPolicyPathType: u32,
    ulPolicyPathLength: u32,
    liPolicyLastWriteTime: LARGE_INTEGER,
    ulMetadataSatelliteRosterIndex: u32,
    ulManifestVersionMajor: u32,
    ulManifestVersionMinor: u32,
    ulPolicyVersionMajor: u32,
    ulPolicyVersionMinor: u32,
    ulAssemblyDirectoryNameLength: u32,
    lpAssemblyEncodedAssemblyIdentity: ?[*:0]const u16,
    lpAssemblyManifestPath: ?[*:0]const u16,
    lpAssemblyPolicyPath: ?[*:0]const u16,
    lpAssemblyDirectoryName: ?[*:0]const u16,
    ulFileCount: u32,
};

pub const ACTCTX_REQUESTED_RUN_LEVEL = enum(i32) {
    UNSPECIFIED = 0,
    AS_INVOKER = 1,
    HIGHEST_AVAILABLE = 2,
    REQUIRE_ADMIN = 3,
    NUMBERS = 4,
};
pub const ACTCTX_RUN_LEVEL_UNSPECIFIED = ACTCTX_REQUESTED_RUN_LEVEL.UNSPECIFIED;
pub const ACTCTX_RUN_LEVEL_AS_INVOKER = ACTCTX_REQUESTED_RUN_LEVEL.AS_INVOKER;
pub const ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = ACTCTX_REQUESTED_RUN_LEVEL.HIGHEST_AVAILABLE;
pub const ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = ACTCTX_REQUESTED_RUN_LEVEL.REQUIRE_ADMIN;
pub const ACTCTX_RUN_LEVEL_NUMBERS = ACTCTX_REQUESTED_RUN_LEVEL.NUMBERS;

pub const ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = extern struct {
    ulFlags: u32,
    RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    UiAccess: u32,
};

pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE = enum(i32) {
    UNKNOWN = 0,
    OS = 1,
    MITIGATION = 2,
    MAXVERSIONTESTED = 3,
};
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.UNKNOWN;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.OS;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MITIGATION;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MAXVERSIONTESTED;

pub const COMPATIBILITY_CONTEXT_ELEMENT = extern struct {
    Id: Guid,
    Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
    MaxVersionTested: u64,
};

pub const ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = extern struct {
    ElementCount: u32,
    Elements: [1]COMPATIBILITY_CONTEXT_ELEMENT,
};

pub const ACTIVATION_CONTEXT_DETAILED_INFORMATION = extern struct {
    dwFlags: u32,
    ulFormatVersion: u32,
    ulAssemblyCount: u32,
    ulRootManifestPathType: u32,
    ulRootManifestPathChars: u32,
    ulRootConfigurationPathType: u32,
    ulRootConfigurationPathChars: u32,
    ulAppDirPathType: u32,
    ulAppDirPathChars: u32,
    lpRootManifestPath: ?[*:0]const u16,
    lpRootConfigurationPath: ?[*:0]const u16,
    lpAppDirPath: ?[*:0]const u16,
};

pub const ACTCTXA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u8,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u8,
    lpResourceName: ?[*:0]const u8,
    lpApplicationName: ?[*:0]const u8,
    hModule: ?HINSTANCE,
};

pub const ACTCTXW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u16,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u16,
    lpResourceName: ?[*:0]const u16,
    lpApplicationName: ?[*:0]const u16,
    hModule: ?HINSTANCE,
};

pub const ACTCTX_SECTION_KEYED_DATA = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: ?*anyopaque,
    ulLength: u32,
    lpSectionGlobalData: ?*anyopaque,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: ?*anyopaque,
    ulSectionTotalLength: u32,
    hActCtx: ?HANDLE,
    ulAssemblyRosterIndex: u32,
    ulFlags: u32,
    AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
};


//--------------------------------------------------------------------------------
// Section: Functions (322)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCloseHandle(
    hAny: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCloseAllHandles(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetInternalUI(
    dwUILevel: INSTALLUILEVEL,
    phWnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) INSTALLUILEVEL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetExternalUIA(
    puiHandler: ?INSTALLUI_HANDLERA,
    dwMessageFilter: u32,
    pvContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?INSTALLUI_HANDLERA;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetExternalUIW(
    puiHandler: ?INSTALLUI_HANDLERW,
    dwMessageFilter: u32,
    pvContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?INSTALLUI_HANDLERW;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetExternalUIRecord(
    puiHandler: ?PINSTALLUI_HANDLER_RECORD,
    dwMessageFilter: u32,
    pvContext: ?*anyopaque,
    ppuiPrevHandler: ?PINSTALLUI_HANDLER_RECORD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnableLogA(
    dwLogMode: INSTALLOGMODE,
    szLogFile: ?[*:0]const u8,
    dwLogAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnableLogW(
    dwLogMode: INSTALLOGMODE,
    szLogFile: ?[*:0]const u16,
    dwLogAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryProductStateA(
    szProduct: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryProductStateW(
    szProduct: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoA(
    szProduct: ?[*:0]const u8,
    szAttribute: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoW(
    szProduct: ?[*:0]const u16,
    szAttribute: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallProductA(
    szPackagePath: ?[*:0]const u8,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallProductW(
    szPackagePath: ?[*:0]const u16,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductA(
    szProduct: ?[*:0]const u8,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductW(
    szProduct: ?[*:0]const u16,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductExA(
    szProduct: ?[*:0]const u8,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureProductExW(
    szProduct: ?[*:0]const u16,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallProductA(
    szProduct: ?[*:0]const u8,
    szReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallProductW(
    szProduct: ?[*:0]const u16,
    szReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductExA(
    szPackagePath: ?[*:0]const u8,
    szScriptfilePath: ?[*:0]const u8,
    szTransforms: ?[*:0]const u8,
    lgidLanguage: u16,
    dwPlatform: u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductExW(
    szPackagePath: ?[*:0]const u16,
    szScriptfilePath: ?[*:0]const u16,
    szTransforms: ?[*:0]const u16,
    lgidLanguage: u16,
    dwPlatform: u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductA(
    szPackagePath: ?[*:0]const u8,
    szScriptfilePath: ?[*:0]const u8,
    szTransforms: ?[*:0]const u8,
    lgidLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseProductW(
    szPackagePath: ?[*:0]const u16,
    szScriptfilePath: ?[*:0]const u16,
    szTransforms: ?[*:0]const u16,
    lgidLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProcessAdvertiseScriptA(
    szScriptFile: ?[*:0]const u8,
    szIconFolder: ?[*:0]const u8,
    hRegData: ?HKEY,
    fShortcuts: BOOL,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProcessAdvertiseScriptW(
    szScriptFile: ?[*:0]const u16,
    szIconFolder: ?[*:0]const u16,
    hRegData: ?HKEY,
    fShortcuts: BOOL,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseScriptA(
    szScriptFile: ?[*:0]const u8,
    dwFlags: u32,
    phRegData: ?*?HKEY,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiAdvertiseScriptW(
    szScriptFile: ?[*:0]const u16,
    dwFlags: u32,
    phRegData: ?*?HKEY,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoFromScriptA(
    szScriptFile: ?[*:0]const u8,
    lpProductBuf39: ?PSTR,
    plgidLanguage: ?*u16,
    pdwVersion: ?*u32,
    lpNameBuf: ?[*:0]u8,
    pcchNameBuf: ?*u32,
    lpPackageBuf: ?[*:0]u8,
    pcchPackageBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductInfoFromScriptW(
    szScriptFile: ?[*:0]const u16,
    lpProductBuf39: ?PWSTR,
    plgidLanguage: ?*u16,
    pdwVersion: ?*u32,
    lpNameBuf: ?[*:0]u16,
    pcchNameBuf: ?*u32,
    lpPackageBuf: ?[*:0]u16,
    pcchPackageBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductCodeA(
    szComponent: ?[*:0]const u8,
    lpBuf39: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductCodeW(
    szComponent: ?[*:0]const u16,
    lpBuf39: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetUserInfoA(
    szProduct: ?[*:0]const u8,
    lpUserNameBuf: ?[*:0]u8,
    pcchUserNameBuf: ?*u32,
    lpOrgNameBuf: ?[*:0]u8,
    pcchOrgNameBuf: ?*u32,
    lpSerialBuf: ?[*:0]u8,
    pcchSerialBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetUserInfoW(
    szProduct: ?[*:0]const u16,
    lpUserNameBuf: ?[*:0]u16,
    pcchUserNameBuf: ?*u32,
    lpOrgNameBuf: ?[*:0]u16,
    pcchOrgNameBuf: ?*u32,
    lpSerialBuf: ?[*:0]u16,
    pcchSerialBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCollectUserInfoA(
    szProduct: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCollectUserInfoW(
    szProduct: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyPatchA(
    szPatchPackage: ?[*:0]const u8,
    szInstallPackage: ?[*:0]const u8,
    eInstallType: INSTALLTYPE,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyPatchW(
    szPatchPackage: ?[*:0]const u16,
    szInstallPackage: ?[*:0]const u16,
    eInstallType: INSTALLTYPE,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoA(
    szPatch: ?[*:0]const u8,
    szAttribute: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoW(
    szPatch: ?[*:0]const u16,
    szAttribute: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesA(
    szProduct: ?[*:0]const u8,
    iPatchIndex: u32,
    lpPatchBuf: ?PSTR,
    lpTransformsBuf: [*:0]u8,
    pcchTransformsBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesW(
    szProduct: ?[*:0]const u16,
    iPatchIndex: u32,
    lpPatchBuf: ?PWSTR,
    lpTransformsBuf: [*:0]u16,
    pcchTransformsBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRemovePatchesA(
    szPatchList: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    eUninstallType: INSTALLTYPE,
    szPropertyList: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRemovePatchesW(
    szPatchList: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    eUninstallType: INSTALLTYPE,
    szPropertyList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msi" fn MsiExtractPatchXMLDataA(
    szPatchPath: ?[*:0]const u8,
    dwReserved: u32,
    szXMLData: ?[*:0]u8,
    pcchXMLData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "msi" fn MsiExtractPatchXMLDataW(
    szPatchPath: ?[*:0]const u16,
    dwReserved: u32,
    szXMLData: ?[*:0]u16,
    pcchXMLData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoExA(
    szPatchCode: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u8,
    lpValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchInfoExW(
    szPatchCode: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u16,
    lpValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyMultiplePatchesA(
    szPatchPackages: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    szPropertiesList: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiApplyMultiplePatchesW(
    szPatchPackages: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    szPropertiesList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDeterminePatchSequenceA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDeterminePatchSequenceW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDetermineApplicablePatchesA(
    szProductPackagePath: ?[*:0]const u8,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDetermineApplicablePatchesW(
    szProductPackagePath: ?[*:0]const u16,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwFilter: u32,
    dwIndex: u32,
    szPatchCode: ?PSTR,
    szTargetProductCode: ?PSTR,
    pdwTargetProductContext: ?*MSIINSTALLCONTEXT,
    szTargetUserSid: ?[*:0]u8,
    pcchTargetUserSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumPatchesExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwFilter: u32,
    dwIndex: u32,
    szPatchCode: ?PWSTR,
    szTargetProductCode: ?PWSTR,
    pdwTargetProductContext: ?*MSIINSTALLCONTEXT,
    szTargetUserSid: ?[*:0]u16,
    pcchTargetUserSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szFeature: ?[*:0]const u8,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryFeatureStateExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szFeature: ?[*:0]const u16,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureExA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    dwInstallMode: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiUseFeatureExW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    dwInstallMode: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureUsageA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    pdwUseCount: ?*u32,
    pwDateUsed: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureUsageW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    pdwUseCount: ?*u32,
    pwDateUsed: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiConfigureFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    dwReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiReinstallFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    dwReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideComponentA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideComponentW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentA(
    szCategory: ?[*:0]const u8,
    szQualifier: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentW(
    szCategory: ?[*:0]const u16,
    szQualifier: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentExA(
    szCategory: ?[*:0]const u8,
    szQualifier: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    szProduct: ?[*:0]const u8,
    dwUnused1: u32,
    dwUnused2: u32,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideQualifiedComponentExW(
    szCategory: ?[*:0]const u16,
    szQualifier: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    szProduct: ?[*:0]const u16,
    dwUnused1: u32,
    dwUnused2: u32,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentPathA(
    szProduct: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    lpPathBuf: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentPathW(
    szProduct: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    lpPathBuf: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExA() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows8.0'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExW() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideAssemblyA(
    szAssemblyName: ?[*:0]const u8,
    szAppContext: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    dwAssemblyInfo: MSIASSEMBLYINFO,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProvideAssemblyW(
    szAssemblyName: ?[*:0]const u16,
    szAppContext: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    dwAssemblyInfo: MSIASSEMBLYINFO,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryComponentStateA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szComponentCode: ?[*:0]const u8,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiQueryComponentStateW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szComponentCode: ?[*:0]const u16,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsA(
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsW(
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwIndex: u32,
    szInstalledProductCode: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumProductsExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwIndex: u32,
    szInstalledProductCode: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumRelatedProductsA(
    lpUpgradeCode: ?[*:0]const u8,
    dwReserved: u32,
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumRelatedProductsW(
    lpUpgradeCode: ?[*:0]const u16,
    dwReserved: u32,
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumFeaturesA(
    szProduct: ?[*:0]const u8,
    iFeatureIndex: u32,
    lpFeatureBuf: ?PSTR,
    lpParentBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumFeaturesW(
    szProduct: ?[*:0]const u16,
    iFeatureIndex: u32,
    lpFeatureBuf: ?PWSTR,
    lpParentBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsA(
    iComponentIndex: u32,
    lpComponentBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsW(
    iComponentIndex: u32,
    lpComponentBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsExA(
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwIndex: u32,
    szInstalledComponentCode: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentsExW(
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwIndex: u32,
    szInstalledComponentCode: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsA(
    szComponent: ?[*:0]const u8,
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsW(
    szComponent: ?[*:0]const u16,
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsExA(
    szComponent: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwProductIndex: u32,
    szProductBuf: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumClientsExW(
    szComponent: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwProductIndex: u32,
    szProductBuf: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentQualifiersA(
    szComponent: ?[*:0]const u8,
    iIndex: u32,
    lpQualifierBuf: [*:0]u8,
    pcchQualifierBuf: ?*u32,
    lpApplicationDataBuf: ?[*:0]u8,
    pcchApplicationDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentQualifiersW(
    szComponent: ?[*:0]const u16,
    iIndex: u32,
    lpQualifierBuf: [*:0]u16,
    pcchQualifierBuf: ?*u32,
    lpApplicationDataBuf: ?[*:0]u16,
    pcchApplicationDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenProductA(
    szProduct: ?[*:0]const u8,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenProductW(
    szProduct: ?[*:0]const u16,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageA(
    szPackagePath: ?[*:0]const u8,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageW(
    szPackagePath: ?[*:0]const u16,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageExA(
    szPackagePath: ?[*:0]const u8,
    dwOptions: u32,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenPackageExW(
    szPackagePath: ?[*:0]const u16,
    dwOptions: u32,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchFileListA(
    szProductCode: ?[*:0]const u8,
    szPatchPackages: ?[*:0]const u8,
    pcFiles: ?*u32,
    pphFileRecords: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPatchFileListW(
    szProductCode: ?[*:0]const u16,
    szPatchPackages: ?[*:0]const u16,
    pcFiles: ?*u32,
    pphFileRecords: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductPropertyA(
    hProduct: MSIHANDLE,
    szProperty: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetProductPropertyW(
    hProduct: MSIHANDLE,
    szProperty: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiVerifyPackageA(
    szPackagePath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiVerifyPackageW(
    szPackagePath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureInfoA(
    hProduct: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    lpAttributes: ?*u32,
    lpTitleBuf: ?[*:0]u8,
    pcchTitleBuf: ?*u32,
    lpHelpBuf: ?[*:0]u8,
    pcchHelpBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureInfoW(
    hProduct: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    lpAttributes: ?*u32,
    lpTitleBuf: ?[*:0]u16,
    pcchTitleBuf: ?*u32,
    lpHelpBuf: ?[*:0]u16,
    pcchHelpBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingComponentA(
    szProduct: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingComponentW(
    szProduct: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingFileA(
    szProduct: ?[*:0]const u8,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiInstallMissingFileW(
    szProduct: ?[*:0]const u16,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiLocateComponentA(
    szComponent: ?[*:0]const u8,
    lpPathBuf: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiLocateComponentW(
    szComponent: ?[*:0]const u16,
    lpPathBuf: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
    szSource: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
    szSource: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u8,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddSourceExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u16,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddMediaDiskA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
    szVolumeLabel: ?[*:0]const u8,
    szDiskPrompt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListAddMediaDiskW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
    szVolumeLabel: ?[*:0]const u16,
    szDiskPrompt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearSourceA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearSourceW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearMediaDiskA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearMediaDiskW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListClearAllExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListForceResolutionExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListSetInfoA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListSetInfoW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListGetInfoA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListGetInfoW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumSourcesA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    szSource: ?[*:0]u8,
    pcchSource: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumSourcesW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    szSource: ?[*:0]u16,
    pcchSource: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumMediaDisksA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    pdwDiskId: ?*u32,
    szVolumeLabel: ?[*:0]u8,
    pcchVolumeLabel: ?*u32,
    szDiskPrompt: ?[*:0]u8,
    pcchDiskPrompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSourceListEnumMediaDisksW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    pdwDiskId: ?*u32,
    szVolumeLabel: ?[*:0]u16,
    pcchVolumeLabel: ?*u32,
    szDiskPrompt: ?[*:0]u16,
    pcchDiskPrompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileVersionA(
    szFilePath: ?[*:0]const u8,
    lpVersionBuf: ?[*:0]u8,
    pcchVersionBuf: ?*u32,
    lpLangBuf: ?[*:0]u8,
    pcchLangBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileVersionW(
    szFilePath: ?[*:0]const u16,
    lpVersionBuf: ?[*:0]u16,
    pcchVersionBuf: ?*u32,
    lpLangBuf: ?[*:0]u16,
    pcchLangBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileHashA(
    szFilePath: ?[*:0]const u8,
    dwOptions: u32,
    pHash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileHashW(
    szFilePath: ?[*:0]const u16,
    dwOptions: u32,
    pHash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileSignatureInformationA(
    szSignedObjectPath: ?[*:0]const u8,
    dwFlags: u32,
    ppcCertContext: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbHashData: ?*u8,
    pcbHashData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFileSignatureInformationW(
    szSignedObjectPath: ?[*:0]const u16,
    dwFlags: u32,
    ppcCertContext: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbHashData: ?*u8,
    pcbHashData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetShortcutTargetA(
    szShortcutPath: ?[*:0]const u8,
    szProductCode: ?PSTR,
    szFeatureId: ?PSTR,
    szComponentCode: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetShortcutTargetW(
    szShortcutPath: ?[*:0]const u16,
    szProductCode: ?PWSTR,
    szFeatureId: ?PWSTR,
    szComponentCode: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiIsProductElevatedA(
    szProduct: ?[*:0]const u8,
    pfElevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiIsProductElevatedW(
    szProduct: ?[*:0]const u16,
    pfElevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiNotifySidChangeA(
    pOldSid: ?[*:0]const u8,
    pNewSid: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiNotifySidChangeW(
    pOldSid: ?[*:0]const u16,
    pNewSid: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiBeginTransactionA(
    szName: ?[*:0]const u8,
    dwTransactionAttributes: u32,
    phTransactionHandle: ?*MSIHANDLE,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiBeginTransactionW(
    szName: ?[*:0]const u16,
    dwTransactionAttributes: u32,
    phTransactionHandle: ?*MSIHANDLE,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEndTransaction(
    dwTransactionState: MSITRANSACTIONSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiJoinTransaction(
    hTransactionHandle: MSIHANDLE,
    dwTransactionAttributes: u32,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseOpenViewA(
    hDatabase: MSIHANDLE,
    szQuery: ?[*:0]const u8,
    phView: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseOpenViewW(
    hDatabase: MSIHANDLE,
    szQuery: ?[*:0]const u16,
    phView: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewGetErrorA(
    hView: MSIHANDLE,
    szColumnNameBuffer: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewGetErrorW(
    hView: MSIHANDLE,
    szColumnNameBuffer: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewExecute(
    hView: MSIHANDLE,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewFetch(
    hView: MSIHANDLE,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewModify(
    hView: MSIHANDLE,
    eModifyMode: MSIMODIFY,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewGetColumnInfo(
    hView: MSIHANDLE,
    eColumnInfo: MSICOLINFO,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiViewClose(
    hView: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseIsTablePersistentA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseIsTablePersistentW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSummaryInformationA(
    hDatabase: MSIHANDLE,
    szDatabasePath: ?[*:0]const u8,
    uiUpdateCount: u32,
    phSummaryInfo: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSummaryInformationW(
    hDatabase: MSIHANDLE,
    szDatabasePath: ?[*:0]const u16,
    uiUpdateCount: u32,
    phSummaryInfo: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoGetPropertyCount(
    hSummaryInfo: MSIHANDLE,
    puiPropertyCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoSetPropertyA(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    uiDataType: u32,
    iValue: i32,
    pftValue: ?*FILETIME,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoSetPropertyW(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    uiDataType: u32,
    iValue: i32,
    pftValue: ?*FILETIME,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoGetPropertyA(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    puiDataType: ?*u32,
    piValue: ?*i32,
    pftValue: ?*FILETIME,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoGetPropertyW(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    puiDataType: ?*u32,
    piValue: ?*i32,
    pftValue: ?*FILETIME,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSummaryInfoPersist(
    hSummaryInfo: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenDatabaseA(
    szDatabasePath: ?[*:0]const u8,
    szPersist: ?[*:0]const u8,
    phDatabase: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiOpenDatabaseW(
    szDatabasePath: ?[*:0]const u16,
    szPersist: ?[*:0]const u16,
    phDatabase: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseImportA(
    hDatabase: MSIHANDLE,
    szFolderPath: ?[*:0]const u8,
    szFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseImportW(
    hDatabase: MSIHANDLE,
    szFolderPath: ?[*:0]const u16,
    szFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseExportA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
    szFolderPath: ?[*:0]const u8,
    szFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseExportW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
    szFolderPath: ?[*:0]const u16,
    szFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseMergeA(
    hDatabase: MSIHANDLE,
    hDatabaseMerge: MSIHANDLE,
    szTableName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseMergeW(
    hDatabase: MSIHANDLE,
    hDatabaseMerge: MSIHANDLE,
    szTableName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGenerateTransformA(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iReserved1: i32,
    iReserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseGenerateTransformW(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iReserved1: i32,
    iReserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseApplyTransformA(
    hDatabase: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iErrorConditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseApplyTransformW(
    hDatabase: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iErrorConditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCreateTransformSummaryInfoA(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iErrorConditions: MSITRANSFORM_ERROR,
    iValidation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCreateTransformSummaryInfoW(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iErrorConditions: MSITRANSFORM_ERROR,
    iValidation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDatabaseCommit(
    hDatabase: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetDatabaseState(
    hDatabase: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIDBSTATE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiCreateRecord(
    cParams: u32,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordIsNull(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordDataSize(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetInteger(
    hRecord: MSIHANDLE,
    iField: u32,
    iValue: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStringA(
    hRecord: MSIHANDLE,
    iField: u32,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStringW(
    hRecord: MSIHANDLE,
    iField: u32,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetInteger(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetStringA(
    hRecord: MSIHANDLE,
    iField: u32,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetStringW(
    hRecord: MSIHANDLE,
    iField: u32,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordGetFieldCount(
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStreamA(
    hRecord: MSIHANDLE,
    iField: u32,
    szFilePath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordSetStreamW(
    hRecord: MSIHANDLE,
    iField: u32,
    szFilePath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordReadStream(
    hRecord: MSIHANDLE,
    iField: u32,
    // TODO: what to do with BytesParamIndex 3?
    szDataBuf: ?PSTR,
    pcbDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiRecordClearData(
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetActiveDatabase(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetPropertyA(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u8,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetPropertyW(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u16,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPropertyA(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u8,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetPropertyW(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u16,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetLanguage(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetMode(
    hInstall: MSIHANDLE,
    eRunMode: MSIRUNMODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetMode(
    hInstall: MSIHANDLE,
    eRunMode: MSIRUNMODE,
    fState: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiFormatRecordA(
    hInstall: MSIHANDLE,
    hRecord: MSIHANDLE,
    szResultBuf: ?[*:0]u8,
    pcchResultBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiFormatRecordW(
    hInstall: MSIHANDLE,
    hRecord: MSIHANDLE,
    szResultBuf: ?[*:0]u16,
    pcchResultBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDoActionA(
    hInstall: MSIHANDLE,
    szAction: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiDoActionW(
    hInstall: MSIHANDLE,
    szAction: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSequenceA(
    hInstall: MSIHANDLE,
    szTable: ?[*:0]const u8,
    iSequenceMode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSequenceW(
    hInstall: MSIHANDLE,
    szTable: ?[*:0]const u16,
    iSequenceMode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiProcessMessage(
    hInstall: MSIHANDLE,
    eMessageType: INSTALLMESSAGE,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEvaluateConditionA(
    hInstall: MSIHANDLE,
    szCondition: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEvaluateConditionW(
    hInstall: MSIHANDLE,
    szCondition: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureStateA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureStateW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureStateA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureStateW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureAttributesA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetFeatureAttributesW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentStateA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetComponentStateW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetComponentStateA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetComponentStateW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureCostA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    iCostTree: MSICOSTTREE,
    iState: INSTALLSTATE,
    piCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureCostW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    iCostTree: MSICOSTTREE,
    iState: INSTALLSTATE,
    piCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentCostsA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    dwIndex: u32,
    iState: INSTALLSTATE,
    szDriveBuf: [*:0]u8,
    pcchDriveBuf: ?*u32,
    piCost: ?*i32,
    piTempCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnumComponentCostsW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    dwIndex: u32,
    iState: INSTALLSTATE,
    szDriveBuf: [*:0]u16,
    pcchDriveBuf: ?*u32,
    piCost: ?*i32,
    piTempCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetInstallLevel(
    hInstall: MSIHANDLE,
    iInstallLevel: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureValidStatesA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    lpInstallStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetFeatureValidStatesW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    lpInstallStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSourcePathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetSourcePathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetTargetPathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetTargetPathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetTargetPathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szFolderPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiSetTargetPathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szFolderPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiVerifyDiskSpace(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiEnableUIPreview(
    hDatabase: MSIHANDLE,
    phPreview: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewDialogA(
    hPreview: MSIHANDLE,
    szDialogName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewDialogW(
    hPreview: MSIHANDLE,
    szDialogName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewBillboardA(
    hPreview: MSIHANDLE,
    szControlName: ?[*:0]const u8,
    szBillboard: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiPreviewBillboardW(
    hPreview: MSIHANDLE,
    szControlName: ?[*:0]const u16,
    szBillboard: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows8.0'
pub extern "msi" fn MsiGetLastErrorRecord(
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcGetNextProtectedFile(
    RpcHandle: ?HANDLE,
    ProtFileData: ?*PROTECTED_FILE_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcIsFileProtected(
    RpcHandle: ?HANDLE,
    ProtFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "sfc" fn SfcIsKeyProtected(
    KeyHandle: ?HKEY,
    SubKeyName: ?[*:0]const u16,
    KeySam: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "sfc" fn SfpVerifyFile(
    pszFileName: ?[*:0]const u8,
    pszError: [*:0]u8,
    dwErrSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileA(
    OldFileName: ?[*:0]const u8,
    NewFileName: ?[*:0]const u8,
    PatchFileName: ?[*:0]const u8,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileW(
    OldFileName: ?[*:0]const u16,
    NewFileName: ?[*:0]const u16,
    PatchFileName: ?[*:0]const u16,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileByHandles(
    OldFileHandle: ?HANDLE,
    NewFileHandle: ?HANDLE,
    PatchFileHandle: ?HANDLE,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileExA(
    OldFileCount: u32,
    OldFileInfoArray: [*]PATCH_OLD_FILE_INFO_A,
    NewFileName: ?[*:0]const u8,
    PatchFileName: ?[*:0]const u8,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileExW(
    OldFileCount: u32,
    OldFileInfoArray: [*]PATCH_OLD_FILE_INFO_W,
    NewFileName: ?[*:0]const u16,
    PatchFileName: ?[*:0]const u16,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn CreatePatchFileByHandlesEx(
    OldFileCount: u32,
    OldFileInfoArray: [*]PATCH_OLD_FILE_INFO_H,
    NewFileHandle: ?HANDLE,
    PatchFileHandle: ?HANDLE,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileA(
    PatchFileName: ?[*:0]const u8,
    PatchHeaderFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileW(
    PatchFileName: ?[*:0]const u16,
    PatchHeaderFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatchc" fn ExtractPatchHeaderToFileByHandles(
    PatchFileHandle: ?HANDLE,
    PatchHeaderFileHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileA(
    PatchFileName: ?[*:0]const u8,
    OldFileName: ?[*:0]const u8,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileW(
    PatchFileName: ?[*:0]const u16,
    OldFileName: ?[*:0]const u16,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileByHandles(
    PatchFileHandle: ?HANDLE,
    OldFileHandle: ?HANDLE,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn TestApplyPatchToFileByBuffers(
    // TODO: what to do with BytesParamIndex 1?
    PatchFileBuffer: ?*u8,
    PatchFileSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    OldFileBuffer: ?*u8,
    OldFileSize: u32,
    NewFileSize: ?*u32,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileA(
    PatchFileName: ?[*:0]const u8,
    OldFileName: ?[*:0]const u8,
    NewFileName: ?[*:0]const u8,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileW(
    PatchFileName: ?[*:0]const u16,
    OldFileName: ?[*:0]const u16,
    NewFileName: ?[*:0]const u16,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByHandles(
    PatchFileHandle: ?HANDLE,
    OldFileHandle: ?HANDLE,
    NewFileHandle: ?HANDLE,
    ApplyOptionFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileExA(
    PatchFileName: ?[*:0]const u8,
    OldFileName: ?[*:0]const u8,
    NewFileName: ?[*:0]const u8,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileExW(
    PatchFileName: ?[*:0]const u16,
    OldFileName: ?[*:0]const u16,
    NewFileName: ?[*:0]const u16,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByHandlesEx(
    PatchFileHandle: ?HANDLE,
    OldFileHandle: ?HANDLE,
    NewFileHandle: ?HANDLE,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn ApplyPatchToFileByBuffers(
    // TODO: what to do with BytesParamIndex 1?
    PatchFileMapped: ?*u8,
    PatchFileSize: u32,
    // TODO: what to do with BytesParamIndex 3?
    OldFileMapped: ?*u8,
    OldFileSize: u32,
    // TODO: what to do with BytesParamIndex 5?
    NewFileBuffer: ?*?*u8,
    NewFileBufferSize: u32,
    NewFileActualSize: ?*u32,
    NewFileTime: ?*FILETIME,
    ApplyOptionFlags: u32,
    ProgressCallback: ?PPATCH_PROGRESS_CALLBACK,
    CallbackContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureA(
    FileName: ?[*:0]const u8,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    SignatureBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureW(
    FileName: ?[*:0]const u16,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    SignatureBuffer: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureByHandle(
    FileHandle: ?HANDLE,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 7?
    SignatureBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn GetFilePatchSignatureByBuffer(
    // TODO: what to do with BytesParamIndex 1?
    FileBufferWritable: ?*u8,
    FileSize: u32,
    OptionFlags: u32,
    OptionData: ?*anyopaque,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
    SignatureBufferSize: u32,
    // TODO: what to do with BytesParamIndex 8?
    SignatureBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "mspatcha" fn NormalizeFileForPatchSignature(
    // TODO: what to do with BytesParamIndex 1?
    FileBuffer: ?*anyopaque,
    FileSize: u32,
    OptionFlags: u32,
    OptionData: ?*PATCH_OPTION_DATA,
    NewFileCoffBase: u32,
    NewFileCoffTime: u32,
    IgnoreRangeCount: u32,
    IgnoreRangeArray: ?[*]PATCH_IGNORE_RANGE,
    RetainRangeCount: u32,
    RetainRangeArray: ?[*]PATCH_RETAIN_RANGE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "msdelta" fn GetDeltaInfoB(
    Delta: DELTA_INPUT,
    lpHeaderInfo: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaInfoA(
    lpDeltaName: ?[*:0]const u8,
    lpHeaderInfo: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaInfoW(
    lpDeltaName: ?[*:0]const u16,
    lpHeaderInfo: ?*DELTA_HEADER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaGetReverseB(
    ApplyFlags: i64,
    Source: DELTA_INPUT,
    Delta: DELTA_INPUT,
    lpReverseFileTime: ?*const FILETIME,
    lpTarget: ?*DELTA_OUTPUT,
    lpTargetReverse: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaB(
    ApplyFlags: i64,
    Source: DELTA_INPUT,
    Delta: DELTA_INPUT,
    lpTarget: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaProvidedB(
    ApplyFlags: i64,
    Source: DELTA_INPUT,
    Delta: DELTA_INPUT,
    // TODO: what to do with BytesParamIndex 4?
    lpTarget: ?*anyopaque,
    uTargetSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaA(
    ApplyFlags: i64,
    lpSourceName: ?[*:0]const u8,
    lpDeltaName: ?[*:0]const u8,
    lpTargetName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn ApplyDeltaW(
    ApplyFlags: i64,
    lpSourceName: ?[*:0]const u16,
    lpDeltaName: ?[*:0]const u16,
    lpTargetName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaB(
    FileTypeSet: i64,
    SetFlags: i64,
    ResetFlags: i64,
    Source: DELTA_INPUT,
    Target: DELTA_INPUT,
    SourceOptions: DELTA_INPUT,
    TargetOptions: DELTA_INPUT,
    GlobalOptions: DELTA_INPUT,
    lpTargetFileTime: ?*const FILETIME,
    HashAlgId: u32,
    lpDelta: ?*DELTA_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaA(
    FileTypeSet: i64,
    SetFlags: i64,
    ResetFlags: i64,
    lpSourceName: ?[*:0]const u8,
    lpTargetName: ?[*:0]const u8,
    lpSourceOptionsName: ?[*:0]const u8,
    lpTargetOptionsName: ?[*:0]const u8,
    GlobalOptions: DELTA_INPUT,
    lpTargetFileTime: ?*const FILETIME,
    HashAlgId: u32,
    lpDeltaName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn CreateDeltaW(
    FileTypeSet: i64,
    SetFlags: i64,
    ResetFlags: i64,
    lpSourceName: ?[*:0]const u16,
    lpTargetName: ?[*:0]const u16,
    lpSourceOptionsName: ?[*:0]const u16,
    lpTargetOptionsName: ?[*:0]const u16,
    GlobalOptions: DELTA_INPUT,
    lpTargetFileTime: ?*const FILETIME,
    HashAlgId: u32,
    lpDeltaName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureB(
    FileTypeSet: i64,
    HashAlgId: u32,
    Source: DELTA_INPUT,
    lpHash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureA(
    FileTypeSet: i64,
    HashAlgId: u32,
    lpSourceName: ?[*:0]const u8,
    lpHash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn GetDeltaSignatureW(
    FileTypeSet: i64,
    HashAlgId: u32,
    lpSourceName: ?[*:0]const u16,
    lpHash: ?*DELTA_HASH,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn DeltaNormalizeProvidedB(
    FileTypeSet: i64,
    NormalizeFlags: i64,
    NormalizeOptions: DELTA_INPUT,
    // TODO: what to do with BytesParamIndex 4?
    lpSource: ?*anyopaque,
    uSourceSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "msdelta" fn DeltaFree(
    lpMemory: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateActCtxA(
    pActCtx: ?*ACTCTXA,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn CreateActCtxW(
    pActCtx: ?*ACTCTXW,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn AddRefActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReleaseActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ZombifyActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ActivateActCtx(
    hActCtx: ?HANDLE,
    lpCookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DeactivateActCtx(
    dwFlags: u32,
    ulCookie: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetCurrentActCtx(
    lphActCtx: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindActCtxSectionStringA(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpStringToFind: ?[*:0]const u8,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindActCtxSectionStringW(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpStringToFind: ?[*:0]const u16,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FindActCtxSectionGuid(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpGuidToFind: ?*const Guid,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn QueryActCtxW(
    dwFlags: u32,
    hActCtx: ?HANDLE,
    pvSubInstance: ?*anyopaque,
    ulInfoClass: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?*anyopaque,
    cbBuffer: usize,
    pcbWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn QueryActCtxSettingsW(
    dwFlags: u32,
    hActCtx: ?HANDLE,
    settingsNameSpace: ?[*:0]const u16,
    settingName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?PWSTR,
    dwBuffer: usize,
    pdwWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (133)
//--------------------------------------------------------------------------------
pub const INSTALLUI_HANDLER = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().INSTALLUI_HANDLERA,
    .wide => @This().INSTALLUI_HANDLERW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'INSTALLUI_HANDLER' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MSIPATCHSEQUENCEINFO = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MSIPATCHSEQUENCEINFOA,
    .wide => @This().MSIPATCHSEQUENCEINFOW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MSIPATCHSEQUENCEINFO' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const PATCH_OLD_FILE_INFO_ = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().PATCH_OLD_FILE_INFO_A,
    .wide => @This().PATCH_OLD_FILE_INFO_W,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'PATCH_OLD_FILE_INFO_' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ACTCTX = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ACTCTXA,
    .wide => @This().ACTCTXW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ACTCTX' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSetExternalUI = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSetExternalUIA,
    .wide => @This().MsiSetExternalUIW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSetExternalUI' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnableLog = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnableLogA,
    .wide => @This().MsiEnableLogW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnableLog' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiQueryProductState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiQueryProductStateA,
    .wide => @This().MsiQueryProductStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiQueryProductState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetProductInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetProductInfoA,
    .wide => @This().MsiGetProductInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetProductInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetProductInfoEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetProductInfoExA,
    .wide => @This().MsiGetProductInfoExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetProductInfoEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiInstallProduct = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiInstallProductA,
    .wide => @This().MsiInstallProductW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiInstallProduct' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiConfigureProduct = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiConfigureProductA,
    .wide => @This().MsiConfigureProductW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiConfigureProduct' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiConfigureProductEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiConfigureProductExA,
    .wide => @This().MsiConfigureProductExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiConfigureProductEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiReinstallProduct = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiReinstallProductA,
    .wide => @This().MsiReinstallProductW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiReinstallProduct' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiAdvertiseProductEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiAdvertiseProductExA,
    .wide => @This().MsiAdvertiseProductExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiAdvertiseProductEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiAdvertiseProduct = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiAdvertiseProductA,
    .wide => @This().MsiAdvertiseProductW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiAdvertiseProduct' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiProcessAdvertiseScript = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiProcessAdvertiseScriptA,
    .wide => @This().MsiProcessAdvertiseScriptW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiProcessAdvertiseScript' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiAdvertiseScript = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiAdvertiseScriptA,
    .wide => @This().MsiAdvertiseScriptW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiAdvertiseScript' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetProductInfoFromScript = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetProductInfoFromScriptA,
    .wide => @This().MsiGetProductInfoFromScriptW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetProductInfoFromScript' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetProductCode = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetProductCodeA,
    .wide => @This().MsiGetProductCodeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetProductCode' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetUserInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetUserInfoA,
    .wide => @This().MsiGetUserInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetUserInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiCollectUserInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiCollectUserInfoA,
    .wide => @This().MsiCollectUserInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiCollectUserInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiApplyPatch = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiApplyPatchA,
    .wide => @This().MsiApplyPatchW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiApplyPatch' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetPatchInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetPatchInfoA,
    .wide => @This().MsiGetPatchInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetPatchInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumPatches = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumPatchesA,
    .wide => @This().MsiEnumPatchesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumPatches' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiRemovePatches = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiRemovePatchesA,
    .wide => @This().MsiRemovePatchesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiRemovePatches' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiExtractPatchXMLData = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiExtractPatchXMLDataA,
    .wide => @This().MsiExtractPatchXMLDataW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiExtractPatchXMLData' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetPatchInfoEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetPatchInfoExA,
    .wide => @This().MsiGetPatchInfoExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetPatchInfoEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiApplyMultiplePatches = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiApplyMultiplePatchesA,
    .wide => @This().MsiApplyMultiplePatchesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiApplyMultiplePatches' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDeterminePatchSequence = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDeterminePatchSequenceA,
    .wide => @This().MsiDeterminePatchSequenceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDeterminePatchSequence' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDetermineApplicablePatches = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDetermineApplicablePatchesA,
    .wide => @This().MsiDetermineApplicablePatchesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDetermineApplicablePatches' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumPatchesEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumPatchesExA,
    .wide => @This().MsiEnumPatchesExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumPatchesEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiQueryFeatureState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiQueryFeatureStateA,
    .wide => @This().MsiQueryFeatureStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiQueryFeatureState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiQueryFeatureStateEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiQueryFeatureStateExA,
    .wide => @This().MsiQueryFeatureStateExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiQueryFeatureStateEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiUseFeature = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiUseFeatureA,
    .wide => @This().MsiUseFeatureW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiUseFeature' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiUseFeatureEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiUseFeatureExA,
    .wide => @This().MsiUseFeatureExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiUseFeatureEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFeatureUsage = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFeatureUsageA,
    .wide => @This().MsiGetFeatureUsageW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFeatureUsage' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiConfigureFeature = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiConfigureFeatureA,
    .wide => @This().MsiConfigureFeatureW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiConfigureFeature' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiReinstallFeature = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiReinstallFeatureA,
    .wide => @This().MsiReinstallFeatureW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiReinstallFeature' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiProvideComponent = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiProvideComponentA,
    .wide => @This().MsiProvideComponentW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiProvideComponent' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiProvideQualifiedComponent = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiProvideQualifiedComponentA,
    .wide => @This().MsiProvideQualifiedComponentW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiProvideQualifiedComponent' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiProvideQualifiedComponentEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiProvideQualifiedComponentExA,
    .wide => @This().MsiProvideQualifiedComponentExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiProvideQualifiedComponentEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetComponentPath = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetComponentPathA,
    .wide => @This().MsiGetComponentPathW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetComponentPath' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetComponentPathEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetComponentPathExA,
    .wide => @This().MsiGetComponentPathExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetComponentPathEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiProvideAssembly = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiProvideAssemblyA,
    .wide => @This().MsiProvideAssemblyW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiProvideAssembly' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiQueryComponentState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiQueryComponentStateA,
    .wide => @This().MsiQueryComponentStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiQueryComponentState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumProducts = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumProductsA,
    .wide => @This().MsiEnumProductsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumProducts' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumProductsEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumProductsExA,
    .wide => @This().MsiEnumProductsExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumProductsEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumRelatedProducts = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumRelatedProductsA,
    .wide => @This().MsiEnumRelatedProductsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumRelatedProducts' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumFeatures = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumFeaturesA,
    .wide => @This().MsiEnumFeaturesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumFeatures' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumComponents = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumComponentsA,
    .wide => @This().MsiEnumComponentsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumComponents' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumComponentsEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumComponentsExA,
    .wide => @This().MsiEnumComponentsExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumComponentsEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumClients = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumClientsA,
    .wide => @This().MsiEnumClientsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumClients' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumClientsEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumClientsExA,
    .wide => @This().MsiEnumClientsExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumClientsEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumComponentQualifiers = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumComponentQualifiersA,
    .wide => @This().MsiEnumComponentQualifiersW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumComponentQualifiers' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiOpenProduct = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiOpenProductA,
    .wide => @This().MsiOpenProductW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiOpenProduct' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiOpenPackage = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiOpenPackageA,
    .wide => @This().MsiOpenPackageW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiOpenPackage' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiOpenPackageEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiOpenPackageExA,
    .wide => @This().MsiOpenPackageExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiOpenPackageEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetPatchFileList = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetPatchFileListA,
    .wide => @This().MsiGetPatchFileListW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetPatchFileList' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetProductProperty = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetProductPropertyA,
    .wide => @This().MsiGetProductPropertyW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetProductProperty' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiVerifyPackage = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiVerifyPackageA,
    .wide => @This().MsiVerifyPackageW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiVerifyPackage' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFeatureInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFeatureInfoA,
    .wide => @This().MsiGetFeatureInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFeatureInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiInstallMissingComponent = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiInstallMissingComponentA,
    .wide => @This().MsiInstallMissingComponentW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiInstallMissingComponent' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiInstallMissingFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiInstallMissingFileA,
    .wide => @This().MsiInstallMissingFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiInstallMissingFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiLocateComponent = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiLocateComponentA,
    .wide => @This().MsiLocateComponentW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiLocateComponent' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListClearAll = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListClearAllA,
    .wide => @This().MsiSourceListClearAllW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListClearAll' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListAddSource = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListAddSourceA,
    .wide => @This().MsiSourceListAddSourceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListAddSource' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListForceResolution = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListForceResolutionA,
    .wide => @This().MsiSourceListForceResolutionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListForceResolution' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListAddSourceEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListAddSourceExA,
    .wide => @This().MsiSourceListAddSourceExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListAddSourceEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListAddMediaDisk = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListAddMediaDiskA,
    .wide => @This().MsiSourceListAddMediaDiskW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListAddMediaDisk' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListClearSource = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListClearSourceA,
    .wide => @This().MsiSourceListClearSourceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListClearSource' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListClearMediaDisk = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListClearMediaDiskA,
    .wide => @This().MsiSourceListClearMediaDiskW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListClearMediaDisk' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListClearAllEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListClearAllExA,
    .wide => @This().MsiSourceListClearAllExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListClearAllEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListForceResolutionEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListForceResolutionExA,
    .wide => @This().MsiSourceListForceResolutionExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListForceResolutionEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListSetInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListSetInfoA,
    .wide => @This().MsiSourceListSetInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListSetInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListGetInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListGetInfoA,
    .wide => @This().MsiSourceListGetInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListGetInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListEnumSources = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListEnumSourcesA,
    .wide => @This().MsiSourceListEnumSourcesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListEnumSources' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSourceListEnumMediaDisks = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSourceListEnumMediaDisksA,
    .wide => @This().MsiSourceListEnumMediaDisksW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSourceListEnumMediaDisks' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFileVersion = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFileVersionA,
    .wide => @This().MsiGetFileVersionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFileVersion' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFileHash = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFileHashA,
    .wide => @This().MsiGetFileHashW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFileHash' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFileSignatureInformation = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFileSignatureInformationA,
    .wide => @This().MsiGetFileSignatureInformationW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFileSignatureInformation' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetShortcutTarget = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetShortcutTargetA,
    .wide => @This().MsiGetShortcutTargetW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetShortcutTarget' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiIsProductElevated = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiIsProductElevatedA,
    .wide => @This().MsiIsProductElevatedW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiIsProductElevated' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiNotifySidChange = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiNotifySidChangeA,
    .wide => @This().MsiNotifySidChangeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiNotifySidChange' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiBeginTransaction = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiBeginTransactionA,
    .wide => @This().MsiBeginTransactionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiBeginTransaction' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseOpenView = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseOpenViewA,
    .wide => @This().MsiDatabaseOpenViewW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseOpenView' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiViewGetError = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiViewGetErrorA,
    .wide => @This().MsiViewGetErrorW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiViewGetError' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseGetPrimaryKeys = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseGetPrimaryKeysA,
    .wide => @This().MsiDatabaseGetPrimaryKeysW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseGetPrimaryKeys' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseIsTablePersistent = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseIsTablePersistentA,
    .wide => @This().MsiDatabaseIsTablePersistentW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseIsTablePersistent' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetSummaryInformation = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetSummaryInformationA,
    .wide => @This().MsiGetSummaryInformationW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetSummaryInformation' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSummaryInfoSetProperty = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSummaryInfoSetPropertyA,
    .wide => @This().MsiSummaryInfoSetPropertyW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSummaryInfoSetProperty' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSummaryInfoGetProperty = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSummaryInfoGetPropertyA,
    .wide => @This().MsiSummaryInfoGetPropertyW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSummaryInfoGetProperty' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiOpenDatabase = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiOpenDatabaseA,
    .wide => @This().MsiOpenDatabaseW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiOpenDatabase' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseImport = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseImportA,
    .wide => @This().MsiDatabaseImportW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseImport' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseExport = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseExportA,
    .wide => @This().MsiDatabaseExportW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseExport' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseMerge = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseMergeA,
    .wide => @This().MsiDatabaseMergeW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseMerge' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseGenerateTransform = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseGenerateTransformA,
    .wide => @This().MsiDatabaseGenerateTransformW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseGenerateTransform' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDatabaseApplyTransform = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDatabaseApplyTransformA,
    .wide => @This().MsiDatabaseApplyTransformW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDatabaseApplyTransform' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiCreateTransformSummaryInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiCreateTransformSummaryInfoA,
    .wide => @This().MsiCreateTransformSummaryInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiCreateTransformSummaryInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiRecordSetString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiRecordSetStringA,
    .wide => @This().MsiRecordSetStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiRecordSetString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiRecordGetString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiRecordGetStringA,
    .wide => @This().MsiRecordGetStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiRecordGetString' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiRecordSetStream = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiRecordSetStreamA,
    .wide => @This().MsiRecordSetStreamW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiRecordSetStream' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSetProperty = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSetPropertyA,
    .wide => @This().MsiSetPropertyW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSetProperty' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetProperty = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetPropertyA,
    .wide => @This().MsiGetPropertyW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetProperty' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiFormatRecord = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiFormatRecordA,
    .wide => @This().MsiFormatRecordW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiFormatRecord' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiDoAction = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiDoActionA,
    .wide => @This().MsiDoActionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiDoAction' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSequence = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSequenceA,
    .wide => @This().MsiSequenceW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSequence' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEvaluateCondition = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEvaluateConditionA,
    .wide => @This().MsiEvaluateConditionW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEvaluateCondition' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFeatureState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFeatureStateA,
    .wide => @This().MsiGetFeatureStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFeatureState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSetFeatureState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSetFeatureStateA,
    .wide => @This().MsiSetFeatureStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSetFeatureState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSetFeatureAttributes = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSetFeatureAttributesA,
    .wide => @This().MsiSetFeatureAttributesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSetFeatureAttributes' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetComponentState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetComponentStateA,
    .wide => @This().MsiGetComponentStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetComponentState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSetComponentState = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSetComponentStateA,
    .wide => @This().MsiSetComponentStateW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSetComponentState' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFeatureCost = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFeatureCostA,
    .wide => @This().MsiGetFeatureCostW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFeatureCost' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiEnumComponentCosts = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiEnumComponentCostsA,
    .wide => @This().MsiEnumComponentCostsW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiEnumComponentCosts' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetFeatureValidStates = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetFeatureValidStatesA,
    .wide => @This().MsiGetFeatureValidStatesW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetFeatureValidStates' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetSourcePath = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetSourcePathA,
    .wide => @This().MsiGetSourcePathW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetSourcePath' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiGetTargetPath = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiGetTargetPathA,
    .wide => @This().MsiGetTargetPathW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiGetTargetPath' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiSetTargetPath = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiSetTargetPathA,
    .wide => @This().MsiSetTargetPathW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiSetTargetPath' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiPreviewDialog = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiPreviewDialogA,
    .wide => @This().MsiPreviewDialogW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiPreviewDialog' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const MsiPreviewBillboard = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().MsiPreviewBillboardA,
    .wide => @This().MsiPreviewBillboardW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'MsiPreviewBillboard' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CreatePatchFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CreatePatchFileA,
    .wide => @This().CreatePatchFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CreatePatchFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CreatePatchFileEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CreatePatchFileExA,
    .wide => @This().CreatePatchFileExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CreatePatchFileEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ExtractPatchHeaderToFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ExtractPatchHeaderToFileA,
    .wide => @This().ExtractPatchHeaderToFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ExtractPatchHeaderToFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const TestApplyPatchToFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().TestApplyPatchToFileA,
    .wide => @This().TestApplyPatchToFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'TestApplyPatchToFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ApplyPatchToFile = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ApplyPatchToFileA,
    .wide => @This().ApplyPatchToFileW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ApplyPatchToFile' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ApplyPatchToFileEx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ApplyPatchToFileExA,
    .wide => @This().ApplyPatchToFileExW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ApplyPatchToFileEx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetFilePatchSignature = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetFilePatchSignatureA,
    .wide => @This().GetFilePatchSignatureW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetFilePatchSignature' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetDeltaInfo = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetDeltaInfoA,
    .wide => @This().GetDeltaInfoW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetDeltaInfo' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const ApplyDelta = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().ApplyDeltaA,
    .wide => @This().ApplyDeltaW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'ApplyDelta' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CreateDelta = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CreateDeltaA,
    .wide => @This().CreateDeltaW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CreateDelta' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const GetDeltaSignature = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().GetDeltaSignatureA,
    .wide => @This().GetDeltaSignatureW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'GetDeltaSignature' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const CreateActCtx = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().CreateActCtxA,
    .wide => @This().CreateActCtxW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'CreateActCtx' requires that UNICODE be set to true or false in the root module",
    ),
};
pub const FindActCtxSectionString = switch (@import("../zig.zig").unicode_mode) {
    .ansi => @This().FindActCtxSectionStringA,
    .wide => @This().FindActCtxSectionStringW,
    .unspecified => if (@import("builtin").is_test) void else @compileError(
        "'FindActCtxSectionString' requires that UNICODE be set to true or false in the root module",
    ),
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = @import("../system/windows_programming.zig").ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CERT_CONTEXT = @import("../security/cryptography.zig").CERT_CONTEXT;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/com.zig").IDispatch;
const IStream = @import("../system/com.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../foundation.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const SAFEARRAY = @import("../system/com.zig").SAFEARRAY;
const ULARGE_INTEGER = @import("../foundation.zig").ULARGE_INTEGER;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPDISPLAYVAL")) { _ = LPDISPLAYVAL; }
    if (@hasDecl(@This(), "LPEVALCOMCALLBACK")) { _ = LPEVALCOMCALLBACK; }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERA")) { _ = INSTALLUI_HANDLERA; }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERW")) { _ = INSTALLUI_HANDLERW; }
    if (@hasDecl(@This(), "PINSTALLUI_HANDLER_RECORD")) { _ = PINSTALLUI_HANDLER_RECORD; }
    if (@hasDecl(@This(), "PPATCH_PROGRESS_CALLBACK")) { _ = PPATCH_PROGRESS_CALLBACK; }
    if (@hasDecl(@This(), "PPATCH_SYMLOAD_CALLBACK")) { _ = PPATCH_SYMLOAD_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
